[
  {
    "execution_id": "exec-6327245c-91d2601d-1751263761",
    "timestamp": "2025-06-30T06:09:21.656361+00:00",
    "sacred_chain": {
      "input_data": "quote",
      "context_sources": [
        "crates.io",
        "github.com",
        "lib.rs",
        "docs.rs"
      ],
      "reasoning_steps": [
        "Input canonicalized: 'quote' -> 'quote'",
        "Context gathered from 4 validated sources",
        "Metadata extracted: 4 fields",
        "Documentation analyzed: quality 7.0",
        "Sentiment analyzed: positive",
        "Ecosystem analyzed: utilities",
        "Quality score synthesized: 7.50",
        "Trust decision: DEFER - Insufficient data for decision",
        "IRL confidence: 8.600"
      ],
      "suggestion": "ALLOW: Positive community sentiment",
      "verdict": "DEFER",
      "audit_info": {
        "metadata": {
          "name": "quote",
          "type": "rust_crate",
          "source": "manual_input",
          "extraction_method": "irl_engine"
        },
        "sentiment": {
          "quality_score": 7.0,
          "completeness": 0.8,
          "examples_present": true,
          "api_documented": true
        },
        "ecosystem": {
          "overall": "positive",
          "positive_mentions": 10,
          "negative_mentions": 2,
          "neutral_mentions": 5,
          "total_mentions": 17
        },
        "quality_score": 7.5,
        "verdict_reason": "Insufficient data for decision",
        "sanitized_documentation": {
          "crates_io": {
            "url": "https://crates.io/crates/quote",
            "title": "quote v1.0.40",
            "content": {
              "raw_markdown": "#  quote v1.0.40\nQuasi-quoting macro quote!(...) \n  * [ #macros ](https://crates.io/keywords/macros)\n  * [ #syn ](https://crates.io/keywords/syn)\n\n\n  * [ Readme ](https://crates.io/crates/quote)\n  * [ 88 Versions ](https://crates.io/crates/quote/versions)\n  * [ Dependencies ](https://crates.io/crates/quote/dependencies)\n  * [ Dependents ](https://crates.io/crates/quote/reverse_dependencies)\n\n\n## Metadata\n4 months ago \nv1.56.0 \n[ MIT ](https://choosealicense.com/licenses/mit) OR [ Apache-2.0 ](https://choosealicense.com/licenses/apache-2.0)\n30.3 KiB \n## Install\nRun the following Cargo command in your project directory:\ncargo add quote\nOr add the following line to your Cargo.toml:\nquote = \"1.0.40\"\n## Documentation\n[ docs.rs/quote ](https://docs.rs/quote/)\n## Repository\n[ github.com/dtolnay/quote ](https://github.com/dtolnay/quote)\n## Owners\n## Categories\n  * [Procedural macro helpers](https://crates.io/categories/development-tools::procedural-macro-helpers)\n\n\n[ Report crate ](https://crates.io/support?crate=quote&inquire=crate-violation)\n### Stats Overview\n637,637,575 Downloads all time\n88 Versions published\n#### Downloads over the last 90 days\nDisplay as \nStacked \n  * Stacked \n  * Unstacked \n\n\nLoading\u2026\n",
              "markdown_with_citations": "#  quote v1.0.40\nQuasi-quoting macro quote!(...) \n  *  #macros \u27e81\u27e9\n  *  #syn \u27e82\u27e9\n\n\n  *  Readme \u27e83\u27e9\n  *  88 Versions \u27e84\u27e9\n  *  Dependencies \u27e85\u27e9\n  *  Dependents \u27e86\u27e9\n\n\n## Metadata\n4 months ago \nv1.56.0 \n MIT \u27e87\u27e9 OR  Apache-2.0 \u27e88\u27e9\n30.3 KiB \n## Install\nRun the following Cargo command in your project directory:\ncargo add quote\nOr add the following line to your Cargo.toml:\nquote = \"1.0.40\"\n## Documentation\n docs.rs/quote \u27e89\u27e9\n## Repository\n github.com/dtolnay/quote \u27e810\u27e9\n## Owners\n## Categories\n  * Procedural macro helpers\u27e811\u27e9\n\n\n Report crate \u27e812\u27e9\n### Stats Overview\n637,637,575 Downloads all time\n88 Versions published\n#### Downloads over the last 90 days\nDisplay as \nStacked \n  * Stacked \n  * Unstacked \n\n\nLoading\u2026\n",
              "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://crates.io/keywords/macros:  #macros \n\u27e82\u27e9 https://crates.io/keywords/syn:  #syn \n\u27e83\u27e9 https://crates.io/crates/quote:  Readme \n\u27e84\u27e9 https://crates.io/crates/quote/versions:  88 Versions \n\u27e85\u27e9 https://crates.io/crates/quote/dependencies:  Dependencies \n\u27e86\u27e9 https://crates.io/crates/quote/reverse_dependencies:  Dependents \n\u27e87\u27e9 https://choosealicense.com/licenses/mit:  MIT \n\u27e88\u27e9 https://choosealicense.com/licenses/apache-2.0:  Apache-2.0 \n\u27e89\u27e9 https://docs.rs/quote/:  docs.rs/quote \n\u27e810\u27e9 https://github.com/dtolnay/quote:  github.com/dtolnay/quote \n\u27e811\u27e9 https://crates.io/categories/development-tools::procedural-macro-helpers: Procedural macro helpers\n\u27e812\u27e9 https://crates.io/support?crate=quote&inquire=crate-violation:  Report crate \n",
              "fit_markdown": "",
              "fit_html": ""
            },
            "structured_data": {},
            "quality_score": 3.0,
            "extraction_method": "crawl4ai",
            "error": null,
            "metadata": {
              "doc_type": "docs",
              "content_length": 1221,
              "has_structured_data": false,
              "crawl_success": true
            },
            "timestamp": "117551.4957639"
          },
          "docs_rs": {
            "url": "https://docs.rs/quote",
            "title": "Crate quoteCopy item path",
            "content": {
              "raw_markdown": "[](https://docs.rs/quote/latest/quote/all.html \"show sidebar\")\n# Crate quoteCopy item path\n[Settings](https://docs.rs/quote/latest/settings.html)\n[Help](https://docs.rs/quote/latest/help.html)\nSummary[Source](https://docs.rs/quote/latest/src/quote/lib.rs.html#1-1454)\nExpand description\n[![github](https://img.shields.io/badge/github-8da0cb?style=for-the-badge&labelColor=555555&logo=github)](https://github.com/dtolnay/quote) [![crates-io](https://img.shields.io/badge/crates.io-fc8d62?style=for-the-badge&labelColor=555555&logo=rust)](https://crates.io/crates/quote) [![docs-rs](https://img.shields.io/badge/docs.rs-66c2a5?style=for-the-badge&labelColor=555555&logo=docs.rs)](https://docs.rs/quote)\nThis crate provides the [`quote!`](https://docs.rs/quote/latest/quote/macro.quote.html \"macro quote::quote\") macro for turning Rust syntax tree data structures into tokens of source code.\nProcedural macros in Rust receive a stream of tokens as input, execute arbitrary Rust code to determine how to manipulate those tokens, and produce a stream of tokens to hand back to the compiler to compile into the caller\u2019s crate. Quasi-quoting is a solution to one piece of that \u2014 producing tokens to return to the compiler.\nThe idea of quasi-quoting is that we write _code_ that we treat as _data_. Within the `quote!` macro, we can write what looks like code to our text editor or IDE. We get all the benefits of the editor\u2019s brace matching, syntax highlighting, indentation, and maybe autocompletion. But rather than compiling that as code into the current crate, we can treat it as data, pass it around, mutate it, and eventually hand it back to the compiler as tokens to compile into the macro caller\u2019s crate.\nThis crate is motivated by the procedural macro use case, but is a general-purpose Rust quasi-quoting library and is not specific to procedural macros.\n```\n[dependencies]\nquote = \"1.0\"\n```\n\n## [\u00a7](https://docs.rs/quote/latest/quote/#example)Example\nThe following quasi-quoted block of code is something you might find in [a](https://serde.rs/) procedural macro having to do with data structure serialization. The `#var` syntax performs interpolation of runtime variables into the quoted tokens. Check out the documentation of the [`quote!`](https://docs.rs/quote/latest/quote/macro.quote.html \"macro quote::quote\") macro for more detail about the syntax. See also the [`quote_spanned!`](https://docs.rs/quote/latest/quote/macro.quote_spanned.html \"macro quote::quote_spanned\") macro which is important for implementing hygienic procedural macros.\n```\nlet tokens = quote! {\n  struct SerializeWith #generics #where_clause {\n    value: &'a #field_ty,\n    phantom: core::marker::PhantomData<#item_ty>,\n  }\n  impl #generics serde::Serialize for SerializeWith #generics #where_clause {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n      S: serde::Serializer,\n    {\n      #path(self.value, serializer)\n    }\n  }\n  SerializeWith {\n    value: #value,\n    phantom: core::marker::PhantomData::<#item_ty>,\n  }\n};\n```\n\n## [\u00a7](https://docs.rs/quote/latest/quote/#non-macro-code-generators)Non-macro code generators\nWhen using `quote` in a build.rs or main.rs and writing the output out to a file, consider having the code generator pass the tokens through [prettyplease](https://github.com/dtolnay/prettyplease) before writing. This way if an error occurs in the generated code it is convenient for a human to read and debug.\n## Macros[\u00a7](https://docs.rs/quote/latest/quote/#macros)\n\n[format_ident](https://docs.rs/quote/latest/quote/macro.format_ident.html \"macro quote::format_ident\")\n    Formatting macro for constructing `Ident`s.\n\n[quote](https://docs.rs/quote/latest/quote/macro.quote.html \"macro quote::quote\")\n    The whole point.\n\n[quote_spanned](https://docs.rs/quote/latest/quote/macro.quote_spanned.html \"macro quote::quote_spanned\")\n    Same as `quote!`, but applies a given span to all tokens originating within the macro invocation.\n## Traits[\u00a7](https://docs.rs/quote/latest/quote/#traits)\n\n[IdentFragment](https://docs.rs/quote/latest/quote/trait.IdentFragment.html \"trait quote::IdentFragment\")\n    Specialized formatting trait used by `format_ident!`.\n\n[ToTokens](https://docs.rs/quote/latest/quote/trait.ToTokens.html \"trait quote::ToTokens\")\n    Types that can be interpolated inside a `quote!` invocation.\n\n[TokenStreamExt](https://docs.rs/quote/latest/quote/trait.TokenStreamExt.html \"trait quote::TokenStreamExt\")\n    TokenStream extension trait with methods for appending tokens.\n",
              "markdown_with_citations": "[](https://docs.rs/quote/latest/quote/all.html \"show sidebar\")\n# Crate quoteCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\n![github\u27e84\u27e9](https://github.com/dtolnay/quote) ![crates-io\u27e85\u27e9](https://crates.io/crates/quote) ![docs-rs\u27e86\u27e9](https://docs.rs/quote)\nThis crate provides the `quote!`\u27e87\u27e9 macro for turning Rust syntax tree data structures into tokens of source code.\nProcedural macros in Rust receive a stream of tokens as input, execute arbitrary Rust code to determine how to manipulate those tokens, and produce a stream of tokens to hand back to the compiler to compile into the caller\u2019s crate. Quasi-quoting is a solution to one piece of that \u2014 producing tokens to return to the compiler.\nThe idea of quasi-quoting is that we write _code_ that we treat as _data_. Within the `quote!` macro, we can write what looks like code to our text editor or IDE. We get all the benefits of the editor\u2019s brace matching, syntax highlighting, indentation, and maybe autocompletion. But rather than compiling that as code into the current crate, we can treat it as data, pass it around, mutate it, and eventually hand it back to the compiler as tokens to compile into the macro caller\u2019s crate.\nThis crate is motivated by the procedural macro use case, but is a general-purpose Rust quasi-quoting library and is not specific to procedural macros.\n```\n[dependencies]\nquote = \"1.0\"\n```\n\n## \u00a7\u27e88\u27e9Example\nThe following quasi-quoted block of code is something you might find in a\u27e89\u27e9 procedural macro having to do with data structure serialization. The `#var` syntax performs interpolation of runtime variables into the quoted tokens. Check out the documentation of the `quote!`\u27e87\u27e9 macro for more detail about the syntax. See also the `quote_spanned!`\u27e810\u27e9 macro which is important for implementing hygienic procedural macros.\n```\nlet tokens = quote! {\n  struct SerializeWith #generics #where_clause {\n    value: &'a #field_ty,\n    phantom: core::marker::PhantomData<#item_ty>,\n  }\n  impl #generics serde::Serialize for SerializeWith #generics #where_clause {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n      S: serde::Serializer,\n    {\n      #path(self.value, serializer)\n    }\n  }\n  SerializeWith {\n    value: #value,\n    phantom: core::marker::PhantomData::<#item_ty>,\n  }\n};\n```\n\n## \u00a7\u27e811\u27e9Non-macro code generators\nWhen using `quote` in a build.rs or main.rs and writing the output out to a file, consider having the code generator pass the tokens through prettyplease\u27e812\u27e9 before writing. This way if an error occurs in the generated code it is convenient for a human to read and debug.\n## Macros\u00a7\u27e813\u27e9\n\nformat_ident\u27e814\u27e9\n    Formatting macro for constructing `Ident`s.\n\nquote\u27e87\u27e9\n    The whole point.\n\nquote_spanned\u27e810\u27e9\n    Same as `quote!`, but applies a given span to all tokens originating within the macro invocation.\n## Traits\u00a7\u27e815\u27e9\n\nIdentFragment\u27e816\u27e9\n    Specialized formatting trait used by `format_ident!`.\n\nToTokens\u27e817\u27e9\n    Types that can be interpolated inside a `quote!` invocation.\n\nTokenStreamExt\u27e818\u27e9\n    TokenStream extension trait with methods for appending tokens.\n",
              "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/quote/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/quote/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/quote/latest/src/quote/lib.rs.html#1-1454: Source\n\u27e84\u27e9 https://img.shields.io/badge/github-8da0cb?style=for-the-badge&labelColor=555555&logo=github: ![github\n\u27e85\u27e9 https://img.shields.io/badge/crates.io-fc8d62?style=for-the-badge&labelColor=555555&logo=rust: ![crates-io\n\u27e86\u27e9 https://img.shields.io/badge/docs.rs-66c2a5?style=for-the-badge&labelColor=555555&logo=docs.rs: ![docs-rs\n\u27e87\u27e9 https://docs.rs/quote/latest/quote/macro.quote.html: macro quote::quote - `quote!`\n\u27e88\u27e9 https://docs.rs/quote/latest/quote/#example: \u00a7\n\u27e89\u27e9 https://serde.rs/: a\n\u27e810\u27e9 https://docs.rs/quote/latest/quote/macro.quote_spanned.html: macro quote::quote_spanned - `quote_spanned!`\n\u27e811\u27e9 https://docs.rs/quote/latest/quote/#non-macro-code-generators: \u00a7\n\u27e812\u27e9 https://github.com/dtolnay/prettyplease: prettyplease\n\u27e813\u27e9 https://docs.rs/quote/latest/quote/#macros: \u00a7\n\u27e814\u27e9 https://docs.rs/quote/latest/quote/macro.format_ident.html: macro quote::format_ident - format_ident\n\u27e815\u27e9 https://docs.rs/quote/latest/quote/#traits: \u00a7\n\u27e816\u27e9 https://docs.rs/quote/latest/quote/trait.IdentFragment.html: trait quote::IdentFragment - IdentFragment\n\u27e817\u27e9 https://docs.rs/quote/latest/quote/trait.ToTokens.html: trait quote::ToTokens - ToTokens\n\u27e818\u27e9 https://docs.rs/quote/latest/quote/trait.TokenStreamExt.html: trait quote::TokenStreamExt - TokenStreamExt\n",
              "fit_markdown": "",
              "fit_html": ""
            },
            "structured_data": {},
            "quality_score": 4.0,
            "extraction_method": "crawl4ai",
            "error": null,
            "metadata": {
              "doc_type": "docs",
              "content_length": 4530,
              "has_structured_data": false,
              "crawl_success": true
            },
            "timestamp": "117552.124536"
          },
          "lib_rs": {
            "url": "https://lib.rs/crates/quote",
            "title": "Untitled",
            "content": {
              "raw_markdown": "###  [87 releases](https://lib.rs/crates/quote/versions) (40 stable)\n1.0.40 |  Mar 11, 2025   \n---|---  \n1.0.38 |  Dec 26, 2024   \n1.0.37 |  Aug 22, 2024   \n1.0.36 |  Apr 10, 2024   \n0.3.10 |  Nov 26, 2016   \n#**2** in [Procedural macros](https://lib.rs/development-tools/procedural-macro-helpers \"Crates to help you write procedural macros in Rust.\n\")\nDownload history 6576648/week @ 2025-03-07 6776618/week @ 2025-03-14 7193019/week @ 2025-03-21 6639535/week @ 2025-03-28 7130730/week @ 2025-04-04 6920024/week @ 2025-04-11 6596972/week @ 2025-04-18 6655299/week @ 2025-04-25 6375278/week @ 2025-05-02 6626320/week @ 2025-05-09 7219567/week @ 2025-05-16 5666038/week @ 2025-05-23 5777568/week @ 2025-05-30 6324054/week @ 2025-06-06 7772712/week @ 2025-06-13 8057744/week @ 2025-06-20\n**28,904,620** downloads per month Used in [**126,535** crates (11,346 directly)](https://lib.rs/crates/quote/rev)\n**MIT/Apache**\n95KB  1.5K  SLoC\n# Rust Quasi-Quoting\n[![github](https://img.shields.io/badge/github-dtolnay/quote-8da0cb?style=for-the-badge&labelColor=555555&logo=github)](https://github.com/dtolnay/quote) [![crates.io](https://img.shields.io/crates/v/quote.svg?style=for-the-badge&color=fc8d62&logo=rust)](https://crates.io/crates/quote) [![docs.rs](https://img.shields.io/badge/docs.rs-quote-66c2a5?style=for-the-badge&labelColor=555555&logo=docs.rs)](https://docs.rs/quote) [![build status](https://img.shields.io/github/actions/workflow/status/dtolnay/quote/ci.yml?branch=master&style=for-the-badge)](https://github.com/dtolnay/quote/actions?query=branch%3Amaster)\nThis crate provides the [``quote!``](https://docs.rs/quote/1.0/quote/macro.quote.html) macro for turning Rust syntax tree data structures into tokens of source code.\nProcedural macros in Rust receive a stream of tokens as input, execute arbitrary Rust code to determine how to manipulate those tokens, and produce a stream of tokens to hand back to the compiler to compile into the caller's crate. Quasi-quoting is a solution to one piece of that \u2014 producing tokens to return to the compiler.\nThe idea of quasi-quoting is that we write _code_ that we treat as _data_. Within the ``quote!`` macro, we can write what looks like code to our text editor or IDE. We get all the benefits of the editor's brace matching, syntax highlighting, indentation, and maybe autocompletion. But rather than compiling that as code into the current crate, we can treat it as data, pass it around, mutate it, and eventually hand it back to the compiler as tokens to compile into the macro caller's crate.\nThis crate is motivated by the procedural macro use case, but is a general-purpose Rust quasi-quoting library and is not specific to procedural macros.\n```\n```[``dependencies``]`\n`quote ``=` ``\"`1.0`\"``\n``\n```\n\n_Version requirement: Quote supports rustc 1.56 and up._ [_Release notes_](https://github.com/dtolnay/quote/releases)\n## Syntax\nThe quote crate provides a [``quote!``](https://docs.rs/quote/1.0/quote/macro.quote.html) macro within which you can write Rust code that gets packaged into a [``TokenStream``](https://docs.rs/proc-macro2/1.0/proc_macro2/struct.TokenStream.html) and can be treated as data. You should think of ``TokenStream`` as representing a fragment of Rust source code.\nWithin the ``quote!`` macro, interpolation is done with ```#`var``. Any type implementing the [```quote`::``ToTokens``](https://docs.rs/quote/1.0/quote/trait.ToTokens.html) trait can be interpolated. This includes most Rust primitive types as well as most of the syntax tree types from [``syn``](https://github.com/dtolnay/syn).\n```\n``let` tokens `=` `quote!` ``{`\n  ``struct` ```SerializeWith` #generics #where_clause ```{`\n    `value``:` `&``'a` #field_ty,\n    `phantom``:` `core`::```marker`::```PhantomData`<``#``item_ty>,\n  `}``\n  ``impl` ``#`generics` `serde`::`Serialize` `for` `SerializeWith` #`generics` #`where_clause` ```{`\n    ``fn` `serialize````<`S`>`````(``&``self`, `serializer``:` S```)```` ``->` ``Result``<```S`::````Ok`, ``S`::```Error`>``\n````where`\n      S`:` `serde`::``Serializer,\n```{`\n      `#``path``(``self``.`value`,` serializer`)`\n    `}``\n  `}``\n  SerializeWith `{`\n    value`:` `#`value`,`\n    phantom`:` `core`::```marker`::```PhantomData`::````<``#``item_ty`>``,`\n  `}`\n```}```;`\n`\n```\n\n## Repetition\nRepetition is done using ```#``(``...``)``*``` or ```#``(``...``)``,``*``` similar to ``macro_rules!``. This iterates through the elements of any variable interpolated within the repetition and inserts a copy of the repetition body for each one. The variables in an interpolation may be a ```Vec```, slice, ``BTreeSet``, or any ```Iterator```.\n  * ```#``(``#`var`)``*``` \u2014 no separators\n  * ```#``(``#`var`)``,``*``` \u2014 the character before the asterisk is used as a separator\n  * ```#``(` ``struct` `#``var```;` `)``*``` \u2014 the repetition can contain other things\n  * ```#``(` `#`k `=>` `println!``(```\"``{}``\"```,` `#`v`)``,` `)``*``` \u2014 even multiple interpolations\n\n\nNote that there is a difference between ```#``(``#`var `,``)``*``` and ```#``(``#`var`)``,``*```\u2014the latter does not produce a trailing comma. This matches the behavior of delimiters in ``macro_rules!``.\n## Returning tokens to the compiler\nThe ``quote!`` macro evaluates to an expression of type ```proc_macro2`::``TokenStream``. Meanwhile Rust procedural macros are expected to return the type ```proc_macro`::``TokenStream``.\nThe difference between the two types is that ``proc_macro`` types are entirely specific to procedural macros and cannot ever exist in code outside of a procedural macro, while ``proc_macro2`` types may exist anywhere including tests and non-macro code like main.rs and build.rs. This is why even the procedural macro ecosystem is largely built around ``proc_macro2``, because that ensures the libraries are unit testable and accessible in non-macro contexts.\nThere is a [```From```](https://doc.rust-lang.org/std/convert/trait.From.html)-conversion in both directions so returning the output of ``quote!`` from a procedural macro usually looks like ``tokens`.``into``(``)``` or ```proc_macro`::```TokenStream`::``from`(`tokens`)```.\n## Examples\n### Combining quoted fragments\nUsually you don't end up constructing an entire final ``TokenStream`` in one piece. Different parts may come from different helper functions. The tokens produced by ``quote!`` themselves implement ``ToTokens`` and so can be interpolated into later ``quote!`` invocations to build up a final result.\n```\n``let` type_definition `=` `quote!` ``{``...````}```;`\n`let` methods `=` `quote!` ``{``...````}```;`\n`let` tokens `=` `quote!` ``{`\n  `#`type_definition\n  `#`methods\n```}```;`\n`\n```\n\n### Constructing identifiers\nSuppose we have an identifier ``ident`` which came from somewhere in a macro input and we need to modify it in some way for the macro output. Let's consider prepending the identifier with an underscore.\nSimply interpolating the identifier next to an underscore will not have the behavior of concatenating them. The underscore and the identifier will continue to be two separate tokens as if you had written ```_` x``.\n```\n```//` incorrect`\n`quote!` ``{`\n  `let` `mut` `_``#`ident `=` `0``;`\n```}``\n`\n```\n\nThe solution is to build a new identifier token with the correct value. As this is such a common case, the ``format_ident!`` macro provides a convenient utility for doing so correctly.\n```\n``let` varname `=` `format_ident!``(```\"`_{}`\"```,` ident`)``;`\n`quote!` ``{`\n  `let` `mut` `#`varname `=` `0``;`\n```}``\n`\n```\n\nAlternatively, the APIs provided by Syn and proc-macro2 can be used to directly build the identifier. This is roughly equivalent to the above, but will not handle ``ident`` being a raw identifier.\n```\n``let` concatenated `=` `format!``(```\"`_`{}``\"```,` ident`)``;`\n`let` varname `=` `syn`::```Ident`::``new`(``&`concatenated`,` ident`.``span``(``)``)``;`\n`quote!` ``{`\n  `let` `mut` `#`varname `=` `0``;`\n```}``\n`\n```\n\n### Making method calls\nLet's say our macro requires some type specified in the macro input to have a constructor called ``new``. We have the type in a variable called ``field_type`` of type ```syn`::``Type`` and want to invoke the constructor.\n```\n```//` incorrect`\n`quote!` ``{`\n  `let` value `=` `#``field_type`::``new`(``)``;`\n```}``\n`\n```\n\nThis works only sometimes. If ``field_type`` is ```String```, the expanded code contains ```String```::``new`(``)``` which is fine. But if ``field_type`` is something like ````Vec``<``i32``>```` then the expanded code is ````Vec``<``i32``>````::``new`(``)``` which is invalid syntax. Ordinarily in handwritten Rust we would write ```Vec``:``:```<``i32``>````::``new`(``)``` but for macros often the following is more convenient.\n```\n``quote!` ``{`\n  `let` value `=` ``<``#``field_type`>```::``new`(``)``;`\n```}``\n`\n```\n\nThis expands to ```<```Vec``<``i32``>```>```::``new`(``)``` which behaves correctly.\nA similar pattern is appropriate for trait methods.\n```\n``quote!` ``{`\n  `let` value `=` ``<``#``field_type `as` `core`::```default`::``Default`>```::``default`(``)``;`\n```}``\n`\n```\n\n## Hygiene\nAny interpolated tokens preserve the ``Span`` information provided by their ``ToTokens`` implementation. Tokens that originate within a ``quote!`` invocation are spanned with [```Span`::``call_site`(``)```](https://docs.rs/proc-macro2/1.0/proc_macro2/struct.Span.html#method.call_site).\nA different span can be provided explicitly through the [``quote_spanned!``](https://docs.rs/quote/1.0/quote/macro.quote_spanned.html) macro.\n## Non-macro code generators\nWhen using ``quote`` in a build.rs or main.rs and writing the output out to a file, consider having the code generator pass the tokens through [prettyplease](https://github.com/dtolnay/prettyplease) before writing. This way if an error occurs in the generated code it is convenient for a human to read and debug.\nBe aware that no kind of hygiene or span information is retained when tokens are written to a file; the conversion from tokens to source code is lossy.\nExample usage in build.rs:\n```\n``let` output `=` `quote!` ``{` `...` ```}```;`\n`let` syntax_tree `=` `syn`::``parse2`(`output`)``.``unwrap``(``)``;`\n`let` formatted `=` `prettyplease`::``unparse`(``&`syntax_tree`)``;`\n`let` out_dir `=` `env`::``var_os`(```\"`OUT_DIR`\"```)``.``unwrap``(``)``;`\n`let` dest_path `=` `Path`::``new`(``&`out_dir`)``.``join``(```\"`out.rs`\"```)``;`\n`fs`::``write`(`dest_path`,` formatted`)``.``unwrap``(``)``;`\n`\n```\n\n#### License\nLicensed under either of [Apache License, Version 2.0](https://github.com/dtolnay/quote/blob/ab1e92c27a492e6077e203a6f85496bb4b1522e8/LICENSE-APACHE) or [MIT license](https://github.com/dtolnay/quote/blob/ab1e92c27a492e6077e203a6f85496bb4b1522e8/LICENSE-MIT) at your option.  Unless you explicitly state otherwise, any contribution intentionally submitted for inclusion in this crate by you, as defined in the Apache-2.0 license, shall be dual licensed as above, without any additional terms or conditions. \n#### Dependencies\n~52KB \n  * [proc-macro2](https://lib.rs/crates/proc-macro2 \"1.0.80\")\n\n\n  * dev  [rustversion](https://lib.rs/crates/rustversion \"1.0\")\n  * dev  [trybuild](https://lib.rs/crates/trybuild \"1.0.66\")[+diff](https://lib.rs/crates/trybuild/features#feature-diff)\n\n\n#### [Other feature](https://lib.rs/crates/quote/features)\n  * [proc-macro](https://lib.rs/crates/quote/features#feature-proc-macro)\n\n\n  *[SLoC]: Lines of code, excluding comments\n",
              "markdown_with_citations": "###  87 releases\u27e81\u27e9 (40 stable)\n1.0.40 |  Mar 11, 2025   \n---|---  \n1.0.38 |  Dec 26, 2024   \n1.0.37 |  Aug 22, 2024   \n1.0.36 |  Apr 10, 2024   \n0.3.10 |  Nov 26, 2016   \n#**2** in Procedural macros\u27e82\u27e9\nDownload history 6576648/week @ 2025-03-07 6776618/week @ 2025-03-14 7193019/week @ 2025-03-21 6639535/week @ 2025-03-28 7130730/week @ 2025-04-04 6920024/week @ 2025-04-11 6596972/week @ 2025-04-18 6655299/week @ 2025-04-25 6375278/week @ 2025-05-02 6626320/week @ 2025-05-09 7219567/week @ 2025-05-16 5666038/week @ 2025-05-23 5777568/week @ 2025-05-30 6324054/week @ 2025-06-06 7772712/week @ 2025-06-13 8057744/week @ 2025-06-20\n**28,904,620** downloads per month Used in **126,535** crates (11,346 directly)\u27e83\u27e9\n**MIT/Apache**\n95KB  1.5K  SLoC\n# Rust Quasi-Quoting\n![github\u27e84\u27e9](https://github.com/dtolnay/quote) ![crates.io\u27e85\u27e9](https://crates.io/crates/quote) ![docs.rs\u27e86\u27e9](https://docs.rs/quote) ![build status\u27e87\u27e9](https://github.com/dtolnay/quote/actions?query=branch%3Amaster)\nThis crate provides the ``quote!``\u27e88\u27e9 macro for turning Rust syntax tree data structures into tokens of source code.\nProcedural macros in Rust receive a stream of tokens as input, execute arbitrary Rust code to determine how to manipulate those tokens, and produce a stream of tokens to hand back to the compiler to compile into the caller's crate. Quasi-quoting is a solution to one piece of that \u2014 producing tokens to return to the compiler.\nThe idea of quasi-quoting is that we write _code_ that we treat as _data_. Within the ``quote!`` macro, we can write what looks like code to our text editor or IDE. We get all the benefits of the editor's brace matching, syntax highlighting, indentation, and maybe autocompletion. But rather than compiling that as code into the current crate, we can treat it as data, pass it around, mutate it, and eventually hand it back to the compiler as tokens to compile into the macro caller's crate.\nThis crate is motivated by the procedural macro use case, but is a general-purpose Rust quasi-quoting library and is not specific to procedural macros.\n```\n```[``dependencies``]`\n`quote ``=` ``\"`1.0`\"``\n``\n```\n\n_Version requirement: Quote supports rustc 1.56 and up._ _Release notes_\u27e89\u27e9\n## Syntax\nThe quote crate provides a ``quote!``\u27e88\u27e9 macro within which you can write Rust code that gets packaged into a ``TokenStream``\u27e810\u27e9 and can be treated as data. You should think of ``TokenStream`` as representing a fragment of Rust source code.\nWithin the ``quote!`` macro, interpolation is done with ```#`var``. Any type implementing the ```quote`::``ToTokens``\u27e811\u27e9 trait can be interpolated. This includes most Rust primitive types as well as most of the syntax tree types from ``syn``\u27e812\u27e9.\n```\n``let` tokens `=` `quote!` ``{`\n  ``struct` ```SerializeWith` #generics #where_clause ```{`\n    `value``:` `&``'a` #field_ty,\n    `phantom``:` `core`::```marker`::```PhantomData`<``#``item_ty>,\n  `}``\n  ``impl` ``#`generics` `serde`::`Serialize` `for` `SerializeWith` #`generics` #`where_clause` ```{`\n    ``fn` `serialize````<`S`>`````(``&``self`, `serializer``:` S```)```` ``->` ``Result``<```S`::````Ok`, ``S`::```Error`>``\n````where`\n      S`:` `serde`::``Serializer,\n```{`\n      `#``path``(``self``.`value`,` serializer`)`\n    `}``\n  `}``\n  SerializeWith `{`\n    value`:` `#`value`,`\n    phantom`:` `core`::```marker`::```PhantomData`::````<``#``item_ty`>``,`\n  `}`\n```}```;`\n`\n```\n\n## Repetition\nRepetition is done using ```#``(``...``)``*``` or ```#``(``...``)``,``*``` similar to ``macro_rules!``. This iterates through the elements of any variable interpolated within the repetition and inserts a copy of the repetition body for each one. The variables in an interpolation may be a ```Vec```, slice, ``BTreeSet``, or any ```Iterator```.\n  * ```#``(``#`var`)``*``` \u2014 no separators\n  * ```#``(``#`var`)``,``*``` \u2014 the character before the asterisk is used as a separator\n  * ```#``(` ``struct` `#``var```;` `)``*``` \u2014 the repetition can contain other things\n  * ```#``(` `#`k `=>` `println!``(```\"``{}``\"```,` `#`v`)``,` `)``*``` \u2014 even multiple interpolations\n\n\nNote that there is a difference between ```#``(``#`var `,``)``*``` and ```#``(``#`var`)``,``*```\u2014the latter does not produce a trailing comma. This matches the behavior of delimiters in ``macro_rules!``.\n## Returning tokens to the compiler\nThe ``quote!`` macro evaluates to an expression of type ```proc_macro2`::``TokenStream``. Meanwhile Rust procedural macros are expected to return the type ```proc_macro`::``TokenStream``.\nThe difference between the two types is that ``proc_macro`` types are entirely specific to procedural macros and cannot ever exist in code outside of a procedural macro, while ``proc_macro2`` types may exist anywhere including tests and non-macro code like main.rs and build.rs. This is why even the procedural macro ecosystem is largely built around ``proc_macro2``, because that ensures the libraries are unit testable and accessible in non-macro contexts.\nThere is a ```From```\u27e813\u27e9-conversion in both directions so returning the output of ``quote!`` from a procedural macro usually looks like ``tokens`.``into``(``)``` or ```proc_macro`::```TokenStream`::``from`(`tokens`)```.\n## Examples\n### Combining quoted fragments\nUsually you don't end up constructing an entire final ``TokenStream`` in one piece. Different parts may come from different helper functions. The tokens produced by ``quote!`` themselves implement ``ToTokens`` and so can be interpolated into later ``quote!`` invocations to build up a final result.\n```\n``let` type_definition `=` `quote!` ``{``...````}```;`\n`let` methods `=` `quote!` ``{``...````}```;`\n`let` tokens `=` `quote!` ``{`\n  `#`type_definition\n  `#`methods\n```}```;`\n`\n```\n\n### Constructing identifiers\nSuppose we have an identifier ``ident`` which came from somewhere in a macro input and we need to modify it in some way for the macro output. Let's consider prepending the identifier with an underscore.\nSimply interpolating the identifier next to an underscore will not have the behavior of concatenating them. The underscore and the identifier will continue to be two separate tokens as if you had written ```_` x``.\n```\n```//` incorrect`\n`quote!` ``{`\n  `let` `mut` `_``#`ident `=` `0``;`\n```}``\n`\n```\n\nThe solution is to build a new identifier token with the correct value. As this is such a common case, the ``format_ident!`` macro provides a convenient utility for doing so correctly.\n```\n``let` varname `=` `format_ident!``(```\"`_{}`\"```,` ident`)``;`\n`quote!` ``{`\n  `let` `mut` `#`varname `=` `0``;`\n```}``\n`\n```\n\nAlternatively, the APIs provided by Syn and proc-macro2 can be used to directly build the identifier. This is roughly equivalent to the above, but will not handle ``ident`` being a raw identifier.\n```\n``let` concatenated `=` `format!``(```\"`_`{}``\"```,` ident`)``;`\n`let` varname `=` `syn`::```Ident`::``new`(``&`concatenated`,` ident`.``span``(``)``)``;`\n`quote!` ``{`\n  `let` `mut` `#`varname `=` `0``;`\n```}``\n`\n```\n\n### Making method calls\nLet's say our macro requires some type specified in the macro input to have a constructor called ``new``. We have the type in a variable called ``field_type`` of type ```syn`::``Type`` and want to invoke the constructor.\n```\n```//` incorrect`\n`quote!` ``{`\n  `let` value `=` `#``field_type`::``new`(``)``;`\n```}``\n`\n```\n\nThis works only sometimes. If ``field_type`` is ```String```, the expanded code contains ```String```::``new`(``)``` which is fine. But if ``field_type`` is something like ````Vec``<``i32``>```` then the expanded code is ````Vec``<``i32``>````::``new`(``)``` which is invalid syntax. Ordinarily in handwritten Rust we would write ```Vec``:``:```<``i32``>````::``new`(``)``` but for macros often the following is more convenient.\n```\n``quote!` ``{`\n  `let` value `=` ``<``#``field_type`>```::``new`(``)``;`\n```}``\n`\n```\n\nThis expands to ```<```Vec``<``i32``>```>```::``new`(``)``` which behaves correctly.\nA similar pattern is appropriate for trait methods.\n```\n``quote!` ``{`\n  `let` value `=` ``<``#``field_type `as` `core`::```default`::``Default`>```::``default`(``)``;`\n```}``\n`\n```\n\n## Hygiene\nAny interpolated tokens preserve the ``Span`` information provided by their ``ToTokens`` implementation. Tokens that originate within a ``quote!`` invocation are spanned with ```Span`::``call_site`(``)```\u27e814\u27e9.\nA different span can be provided explicitly through the ``quote_spanned!``\u27e815\u27e9 macro.\n## Non-macro code generators\nWhen using ``quote`` in a build.rs or main.rs and writing the output out to a file, consider having the code generator pass the tokens through prettyplease\u27e816\u27e9 before writing. This way if an error occurs in the generated code it is convenient for a human to read and debug.\nBe aware that no kind of hygiene or span information is retained when tokens are written to a file; the conversion from tokens to source code is lossy.\nExample usage in build.rs:\n```\n``let` output `=` `quote!` ``{` `...` ```}```;`\n`let` syntax_tree `=` `syn`::``parse2`(`output`)``.``unwrap``(``)``;`\n`let` formatted `=` `prettyplease`::``unparse`(``&`syntax_tree`)``;`\n`let` out_dir `=` `env`::``var_os`(```\"`OUT_DIR`\"```)``.``unwrap``(``)``;`\n`let` dest_path `=` `Path`::``new`(``&`out_dir`)``.``join``(```\"`out.rs`\"```)``;`\n`fs`::``write`(`dest_path`,` formatted`)``.``unwrap``(``)``;`\n`\n```\n\n#### License\nLicensed under either of Apache License, Version 2.0\u27e817\u27e9 or MIT license\u27e818\u27e9 at your option.  Unless you explicitly state otherwise, any contribution intentionally submitted for inclusion in this crate by you, as defined in the Apache-2.0 license, shall be dual licensed as above, without any additional terms or conditions. \n#### Dependencies\n~52KB \n  * proc-macro2\u27e819\u27e9\n\n\n  * dev  rustversion\u27e820\u27e9\n  * dev  trybuild\u27e821\u27e9+diff\u27e822\u27e9\n\n\n#### Other feature\u27e823\u27e9\n  * proc-macro\u27e824\u27e9\n\n\n  *[SLoC]: Lines of code, excluding comments\n",
              "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://lib.rs/crates/quote/versions: 87 releases\n\u27e82\u27e9 https://lib.rs/development-tools/procedural-macro-helpers: Crates to help you write procedural macros in Rust.\n - Procedural macros\n\u27e83\u27e9 https://lib.rs/crates/quote/rev: **126,535** crates (11,346 directly)\n\u27e84\u27e9 https://img.shields.io/badge/github-dtolnay/quote-8da0cb?style=for-the-badge&labelColor=555555&logo=github: ![github\n\u27e85\u27e9 https://img.shields.io/crates/v/quote.svg?style=for-the-badge&color=fc8d62&logo=rust: ![crates.io\n\u27e86\u27e9 https://img.shields.io/badge/docs.rs-quote-66c2a5?style=for-the-badge&labelColor=555555&logo=docs.rs: ![docs.rs\n\u27e87\u27e9 https://img.shields.io/github/actions/workflow/status/dtolnay/quote/ci.yml?branch=master&style=for-the-badge: ![build status\n\u27e88\u27e9 https://docs.rs/quote/1.0/quote/macro.quote.html: ``quote!``\n\u27e89\u27e9 https://github.com/dtolnay/quote/releases: _Release notes_\n\u27e810\u27e9 https://docs.rs/proc-macro2/1.0/proc_macro2/struct.TokenStream.html: ``TokenStream``\n\u27e811\u27e9 https://docs.rs/quote/1.0/quote/trait.ToTokens.html: ```quote`::``ToTokens``\n\u27e812\u27e9 https://github.com/dtolnay/syn: ``syn``\n\u27e813\u27e9 https://doc.rust-lang.org/std/convert/trait.From.html: ```From```\n\u27e814\u27e9 https://docs.rs/proc-macro2/1.0/proc_macro2/struct.Span.html#method.call_site: ```Span`::``call_site`(``)```\n\u27e815\u27e9 https://docs.rs/quote/1.0/quote/macro.quote_spanned.html: ``quote_spanned!``\n\u27e816\u27e9 https://github.com/dtolnay/prettyplease: prettyplease\n\u27e817\u27e9 https://github.com/dtolnay/quote/blob/ab1e92c27a492e6077e203a6f85496bb4b1522e8/LICENSE-APACHE: Apache License, Version 2.0\n\u27e818\u27e9 https://github.com/dtolnay/quote/blob/ab1e92c27a492e6077e203a6f85496bb4b1522e8/LICENSE-MIT: MIT license\n\u27e819\u27e9 https://lib.rs/crates/proc-macro2: 1.0.80 - proc-macro2\n\u27e820\u27e9 https://lib.rs/crates/rustversion: 1.0 - rustversion\n\u27e821\u27e9 https://lib.rs/crates/trybuild: 1.0.66 - trybuild\n\u27e822\u27e9 https://lib.rs/crates/trybuild/features#feature-diff: +diff\n\u27e823\u27e9 https://lib.rs/crates/quote/features: Other feature\n\u27e824\u27e9 https://lib.rs/crates/quote/features#feature-proc-macro: proc-macro\n",
              "fit_markdown": "",
              "fit_html": ""
            },
            "structured_data": {},
            "quality_score": 3.0,
            "extraction_method": "crawl4ai",
            "error": null,
            "metadata": {
              "doc_type": "docs",
              "content_length": 11406,
              "has_structured_data": false,
              "crawl_success": true
            },
            "timestamp": "117552.7650714"
          }
        },
        "crate_analysis": {
          "status": "completed",
          "check": [
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#unicode-ident@1.0.18",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\unicode-ident-1.0.18\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "unicode_ident",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\unicode-ident-1.0.18\\src\\lib.rs",
                "edition": "2018",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmppghwo37y\\quote-1.0.40\\target\\debug\\deps\\libunicode_ident-0ff2238d530c1ee1.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#proc-macro2@1.0.94",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\proc-macro2-1.0.94\\Cargo.toml",
              "target": {
                "kind": [
                  "custom-build"
                ],
                "crate_types": [
                  "bin"
                ],
                "name": "build-script-build",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\proc-macro2-1.0.94\\build.rs",
                "edition": "2021",
                "doc": false,
                "doctest": false,
                "test": false
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "proc-macro"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmppghwo37y\\quote-1.0.40\\target\\debug\\build\\proc-macro2-462ae4e9848053e1\\build-script-build.exe",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmppghwo37y\\quote-1.0.40\\target\\debug\\build\\proc-macro2-462ae4e9848053e1\\build_script_build.pdb"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "build-script-executed",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#proc-macro2@1.0.94",
              "linked_libs": [],
              "linked_paths": [],
              "cfgs": [
                "wrap_proc_macro"
              ],
              "env": [],
              "out_dir": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmppghwo37y\\quote-1.0.40\\target\\debug\\build\\proc-macro2-521f40ba08857cbd\\out"
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#proc-macro2@1.0.94",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\proc-macro2-1.0.94\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "proc_macro2",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\proc-macro2-1.0.94\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "proc-macro"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmppghwo37y\\quote-1.0.40\\target\\debug\\deps\\libproc_macro2-2a165d4f3eefbff4.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "compiler-artifact",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmppghwo37y/quote-1.0.40#quote@1.0.40",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmppghwo37y\\quote-1.0.40\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "quote",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmppghwo37y\\quote-1.0.40\\src\\lib.rs",
                "edition": "2018",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "default",
                "proc-macro"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmppghwo37y\\quote-1.0.40\\target\\debug\\deps\\libquote-8ad9bb4dbebd85e0.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "build-finished",
              "success": true
            }
          ],
          "clippy": [
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#proc-macro2@1.0.94",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\proc-macro2-1.0.94\\Cargo.toml",
              "target": {
                "kind": [
                  "custom-build"
                ],
                "crate_types": [
                  "bin"
                ],
                "name": "build-script-build",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\proc-macro2-1.0.94\\build.rs",
                "edition": "2021",
                "doc": false,
                "doctest": false,
                "test": false
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "proc-macro"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmppghwo37y\\quote-1.0.40\\target\\debug\\build\\proc-macro2-462ae4e9848053e1\\build-script-build.exe",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmppghwo37y\\quote-1.0.40\\target\\debug\\build\\proc-macro2-462ae4e9848053e1\\build_script_build.pdb"
              ],
              "executable": null,
              "fresh": true
            },
            {
              "reason": "build-script-executed",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#proc-macro2@1.0.94",
              "linked_libs": [],
              "linked_paths": [],
              "cfgs": [
                "wrap_proc_macro"
              ],
              "env": [],
              "out_dir": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmppghwo37y\\quote-1.0.40\\target\\debug\\build\\proc-macro2-521f40ba08857cbd\\out"
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#unicode-ident@1.0.18",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\unicode-ident-1.0.18\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "unicode_ident",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\unicode-ident-1.0.18\\src\\lib.rs",
                "edition": "2018",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmppghwo37y\\quote-1.0.40\\target\\debug\\deps\\libunicode_ident-0ff2238d530c1ee1.rmeta"
              ],
              "executable": null,
              "fresh": true
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#proc-macro2@1.0.94",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\proc-macro2-1.0.94\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "proc_macro2",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\proc-macro2-1.0.94\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "proc-macro"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmppghwo37y\\quote-1.0.40\\target\\debug\\deps\\libproc_macro2-2a165d4f3eefbff4.rmeta"
              ],
              "executable": null,
              "fresh": true
            },
            {
              "reason": "compiler-artifact",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmppghwo37y/quote-1.0.40#quote@1.0.40",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmppghwo37y\\quote-1.0.40\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "quote",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmppghwo37y\\quote-1.0.40\\src\\lib.rs",
                "edition": "2018",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "default",
                "proc-macro"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmppghwo37y\\quote-1.0.40\\target\\debug\\deps\\libquote-afc208b146d6b5c8.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "build-finished",
              "success": true
            }
          ],
          "audit": {
            "database": {
              "advisory-count": 787,
              "last-commit": "7573f55ba337263f61167dbb0ea926cdc7c8eb5d",
              "last-updated": "2025-06-17T11:04:25+02:00"
            },
            "lockfile": {
              "dependency-count": 36
            },
            "settings": {
              "target_arch": [],
              "target_os": [],
              "severity": null,
              "ignore": [],
              "informational_warnings": [
                "unmaintained",
                "unsound",
                "notice"
              ]
            },
            "vulnerabilities": {
              "found": false,
              "count": 0,
              "list": []
            },
            "warnings": {}
          },
          "note": "Crate analysis performed with stable toolchain."
        },
        "crate_metadata": {
          "name": "quote",
          "version": "1.0.40",
          "description": "ALLOW: Positive community sentiment",
          "repository": "",
          "keywords": [],
          "categories": [],
          "readme": {
            "raw_markdown": "[](https://docs.rs/quote/latest/quote/all.html \"show sidebar\")\n# Crate quoteCopy item path\n[Settings](https://docs.rs/quote/latest/settings.html)\n[Help](https://docs.rs/quote/latest/help.html)\nSummary[Source](https://docs.rs/quote/latest/src/quote/lib.rs.html#1-1454)\nExpand description\n[![github](https://img.shields.io/badge/github-8da0cb?style=for-the-badge&labelColor=555555&logo=github)](https://github.com/dtolnay/quote) [![crates-io](https://img.shields.io/badge/crates.io-fc8d62?style=for-the-badge&labelColor=555555&logo=rust)](https://crates.io/crates/quote) [![docs-rs](https://img.shields.io/badge/docs.rs-66c2a5?style=for-the-badge&labelColor=555555&logo=docs.rs)](https://docs.rs/quote)\nThis crate provides the [`quote!`](https://docs.rs/quote/latest/quote/macro.quote.html \"macro quote::quote\") macro for turning Rust syntax tree data structures into tokens of source code.\nProcedural macros in Rust receive a stream of tokens as input, execute arbitrary Rust code to determine how to manipulate those tokens, and produce a stream of tokens to hand back to the compiler to compile into the caller\u2019s crate. Quasi-quoting is a solution to one piece of that \u2014 producing tokens to return to the compiler.\nThe idea of quasi-quoting is that we write _code_ that we treat as _data_. Within the `quote!` macro, we can write what looks like code to our text editor or IDE. We get all the benefits of the editor\u2019s brace matching, syntax highlighting, indentation, and maybe autocompletion. But rather than compiling that as code into the current crate, we can treat it as data, pass it around, mutate it, and eventually hand it back to the compiler as tokens to compile into the macro caller\u2019s crate.\nThis crate is motivated by the procedural macro use case, but is a general-purpose Rust quasi-quoting library and is not specific to procedural macros.\n```\n[dependencies]\nquote = \"1.0\"\n```\n\n## [\u00a7](https://docs.rs/quote/latest/quote/#example)Example\nThe following quasi-quoted block of code is something you might find in [a](https://serde.rs/) procedural macro having to do with data structure serialization. The `#var` syntax performs interpolation of runtime variables into the quoted tokens. Check out the documentation of the [`quote!`](https://docs.rs/quote/latest/quote/macro.quote.html \"macro quote::quote\") macro for more detail about the syntax. See also the [`quote_spanned!`](https://docs.rs/quote/latest/quote/macro.quote_spanned.html \"macro quote::quote_spanned\") macro which is important for implementing hygienic procedural macros.\n```\nlet tokens = quote! {\n  struct SerializeWith #generics #where_clause {\n    value: &'a #field_ty,\n    phantom: core::marker::PhantomData<#item_ty>,\n  }\n  impl #generics serde::Serialize for SerializeWith #generics #where_clause {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n      S: serde::Serializer,\n    {\n      #path(self.value, serializer)\n    }\n  }\n  SerializeWith {\n    value: #value,\n    phantom: core::marker::PhantomData::<#item_ty>,\n  }\n};\n```\n\n## [\u00a7](https://docs.rs/quote/latest/quote/#non-macro-code-generators)Non-macro code generators\nWhen using `quote` in a build.rs or main.rs and writing the output out to a file, consider having the code generator pass the tokens through [prettyplease](https://github.com/dtolnay/prettyplease) before writing. This way if an error occurs in the generated code it is convenient for a human to read and debug.\n## Macros[\u00a7](https://docs.rs/quote/latest/quote/#macros)\n\n[format_ident](https://docs.rs/quote/latest/quote/macro.format_ident.html \"macro quote::format_ident\")\n    Formatting macro for constructing `Ident`s.\n\n[quote](https://docs.rs/quote/latest/quote/macro.quote.html \"macro quote::quote\")\n    The whole point.\n\n[quote_spanned](https://docs.rs/quote/latest/quote/macro.quote_spanned.html \"macro quote::quote_spanned\")\n    Same as `quote!`, but applies a given span to all tokens originating within the macro invocation.\n## Traits[\u00a7](https://docs.rs/quote/latest/quote/#traits)\n\n[IdentFragment](https://docs.rs/quote/latest/quote/trait.IdentFragment.html \"trait quote::IdentFragment\")\n    Specialized formatting trait used by `format_ident!`.\n\n[ToTokens](https://docs.rs/quote/latest/quote/trait.ToTokens.html \"trait quote::ToTokens\")\n    Types that can be interpolated inside a `quote!` invocation.\n\n[TokenStreamExt](https://docs.rs/quote/latest/quote/trait.TokenStreamExt.html \"trait quote::TokenStreamExt\")\n    TokenStream extension trait with methods for appending tokens.\n",
            "markdown_with_citations": "[](https://docs.rs/quote/latest/quote/all.html \"show sidebar\")\n# Crate quoteCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\n![github\u27e84\u27e9](https://github.com/dtolnay/quote) ![crates-io\u27e85\u27e9](https://crates.io/crates/quote) ![docs-rs\u27e86\u27e9](https://docs.rs/quote)\nThis crate provides the `quote!`\u27e87\u27e9 macro for turning Rust syntax tree data structures into tokens of source code.\nProcedural macros in Rust receive a stream of tokens as input, execute arbitrary Rust code to determine how to manipulate those tokens, and produce a stream of tokens to hand back to the compiler to compile into the caller\u2019s crate. Quasi-quoting is a solution to one piece of that \u2014 producing tokens to return to the compiler.\nThe idea of quasi-quoting is that we write _code_ that we treat as _data_. Within the `quote!` macro, we can write what looks like code to our text editor or IDE. We get all the benefits of the editor\u2019s brace matching, syntax highlighting, indentation, and maybe autocompletion. But rather than compiling that as code into the current crate, we can treat it as data, pass it around, mutate it, and eventually hand it back to the compiler as tokens to compile into the macro caller\u2019s crate.\nThis crate is motivated by the procedural macro use case, but is a general-purpose Rust quasi-quoting library and is not specific to procedural macros.\n```\n[dependencies]\nquote = \"1.0\"\n```\n\n## \u00a7\u27e88\u27e9Example\nThe following quasi-quoted block of code is something you might find in a\u27e89\u27e9 procedural macro having to do with data structure serialization. The `#var` syntax performs interpolation of runtime variables into the quoted tokens. Check out the documentation of the `quote!`\u27e87\u27e9 macro for more detail about the syntax. See also the `quote_spanned!`\u27e810\u27e9 macro which is important for implementing hygienic procedural macros.\n```\nlet tokens = quote! {\n  struct SerializeWith #generics #where_clause {\n    value: &'a #field_ty,\n    phantom: core::marker::PhantomData<#item_ty>,\n  }\n  impl #generics serde::Serialize for SerializeWith #generics #where_clause {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n      S: serde::Serializer,\n    {\n      #path(self.value, serializer)\n    }\n  }\n  SerializeWith {\n    value: #value,\n    phantom: core::marker::PhantomData::<#item_ty>,\n  }\n};\n```\n\n## \u00a7\u27e811\u27e9Non-macro code generators\nWhen using `quote` in a build.rs or main.rs and writing the output out to a file, consider having the code generator pass the tokens through prettyplease\u27e812\u27e9 before writing. This way if an error occurs in the generated code it is convenient for a human to read and debug.\n## Macros\u00a7\u27e813\u27e9\n\nformat_ident\u27e814\u27e9\n    Formatting macro for constructing `Ident`s.\n\nquote\u27e87\u27e9\n    The whole point.\n\nquote_spanned\u27e810\u27e9\n    Same as `quote!`, but applies a given span to all tokens originating within the macro invocation.\n## Traits\u00a7\u27e815\u27e9\n\nIdentFragment\u27e816\u27e9\n    Specialized formatting trait used by `format_ident!`.\n\nToTokens\u27e817\u27e9\n    Types that can be interpolated inside a `quote!` invocation.\n\nTokenStreamExt\u27e818\u27e9\n    TokenStream extension trait with methods for appending tokens.\n",
            "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/quote/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/quote/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/quote/latest/src/quote/lib.rs.html#1-1454: Source\n\u27e84\u27e9 https://img.shields.io/badge/github-8da0cb?style=for-the-badge&labelColor=555555&logo=github: ![github\n\u27e85\u27e9 https://img.shields.io/badge/crates.io-fc8d62?style=for-the-badge&labelColor=555555&logo=rust: ![crates-io\n\u27e86\u27e9 https://img.shields.io/badge/docs.rs-66c2a5?style=for-the-badge&labelColor=555555&logo=docs.rs: ![docs-rs\n\u27e87\u27e9 https://docs.rs/quote/latest/quote/macro.quote.html: macro quote::quote - `quote!`\n\u27e88\u27e9 https://docs.rs/quote/latest/quote/#example: \u00a7\n\u27e89\u27e9 https://serde.rs/: a\n\u27e810\u27e9 https://docs.rs/quote/latest/quote/macro.quote_spanned.html: macro quote::quote_spanned - `quote_spanned!`\n\u27e811\u27e9 https://docs.rs/quote/latest/quote/#non-macro-code-generators: \u00a7\n\u27e812\u27e9 https://github.com/dtolnay/prettyplease: prettyplease\n\u27e813\u27e9 https://docs.rs/quote/latest/quote/#macros: \u00a7\n\u27e814\u27e9 https://docs.rs/quote/latest/quote/macro.format_ident.html: macro quote::format_ident - format_ident\n\u27e815\u27e9 https://docs.rs/quote/latest/quote/#traits: \u00a7\n\u27e816\u27e9 https://docs.rs/quote/latest/quote/trait.IdentFragment.html: trait quote::IdentFragment - IdentFragment\n\u27e817\u27e9 https://docs.rs/quote/latest/quote/trait.ToTokens.html: trait quote::ToTokens - ToTokens\n\u27e818\u27e9 https://docs.rs/quote/latest/quote/trait.TokenStreamExt.html: trait quote::TokenStreamExt - TokenStreamExt\n",
            "fit_markdown": "",
            "fit_html": ""
          },
          "downloads": 0,
          "github_stars": 0,
          "dependencies": [],
          "features": {},
          "code_snippets": [],
          "readme_sections": {},
          "librs_downloads": null,
          "source": "crates.io",
          "enhanced_scraping": {},
          "enhanced_features": [],
          "enhanced_dependencies": []
        },
        "enriched_crate": {
          "name": "quote",
          "version": "1.0.40",
          "description": "ALLOW: Positive community sentiment",
          "repository": "",
          "keywords": [],
          "categories": [],
          "readme": {
            "raw_markdown": "[](https://docs.rs/quote/latest/quote/all.html \"show sidebar\")\n# Crate quoteCopy item path\n[Settings](https://docs.rs/quote/latest/settings.html)\n[Help](https://docs.rs/quote/latest/help.html)\nSummary[Source](https://docs.rs/quote/latest/src/quote/lib.rs.html#1-1454)\nExpand description\n[![github](https://img.shields.io/badge/github-8da0cb?style=for-the-badge&labelColor=555555&logo=github)](https://github.com/dtolnay/quote) [![crates-io](https://img.shields.io/badge/crates.io-fc8d62?style=for-the-badge&labelColor=555555&logo=rust)](https://crates.io/crates/quote) [![docs-rs](https://img.shields.io/badge/docs.rs-66c2a5?style=for-the-badge&labelColor=555555&logo=docs.rs)](https://docs.rs/quote)\nThis crate provides the [`quote!`](https://docs.rs/quote/latest/quote/macro.quote.html \"macro quote::quote\") macro for turning Rust syntax tree data structures into tokens of source code.\nProcedural macros in Rust receive a stream of tokens as input, execute arbitrary Rust code to determine how to manipulate those tokens, and produce a stream of tokens to hand back to the compiler to compile into the caller\u2019s crate. Quasi-quoting is a solution to one piece of that \u2014 producing tokens to return to the compiler.\nThe idea of quasi-quoting is that we write _code_ that we treat as _data_. Within the `quote!` macro, we can write what looks like code to our text editor or IDE. We get all the benefits of the editor\u2019s brace matching, syntax highlighting, indentation, and maybe autocompletion. But rather than compiling that as code into the current crate, we can treat it as data, pass it around, mutate it, and eventually hand it back to the compiler as tokens to compile into the macro caller\u2019s crate.\nThis crate is motivated by the procedural macro use case, but is a general-purpose Rust quasi-quoting library and is not specific to procedural macros.\n```\n[dependencies]\nquote = \"1.0\"\n```\n\n## [\u00a7](https://docs.rs/quote/latest/quote/#example)Example\nThe following quasi-quoted block of code is something you might find in [a](https://serde.rs/) procedural macro having to do with data structure serialization. The `#var` syntax performs interpolation of runtime variables into the quoted tokens. Check out the documentation of the [`quote!`](https://docs.rs/quote/latest/quote/macro.quote.html \"macro quote::quote\") macro for more detail about the syntax. See also the [`quote_spanned!`](https://docs.rs/quote/latest/quote/macro.quote_spanned.html \"macro quote::quote_spanned\") macro which is important for implementing hygienic procedural macros.\n```\nlet tokens = quote! {\n  struct SerializeWith #generics #where_clause {\n    value: &'a #field_ty,\n    phantom: core::marker::PhantomData<#item_ty>,\n  }\n  impl #generics serde::Serialize for SerializeWith #generics #where_clause {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n      S: serde::Serializer,\n    {\n      #path(self.value, serializer)\n    }\n  }\n  SerializeWith {\n    value: #value,\n    phantom: core::marker::PhantomData::<#item_ty>,\n  }\n};\n```\n\n## [\u00a7](https://docs.rs/quote/latest/quote/#non-macro-code-generators)Non-macro code generators\nWhen using `quote` in a build.rs or main.rs and writing the output out to a file, consider having the code generator pass the tokens through [prettyplease](https://github.com/dtolnay/prettyplease) before writing. This way if an error occurs in the generated code it is convenient for a human to read and debug.\n## Macros[\u00a7](https://docs.rs/quote/latest/quote/#macros)\n\n[format_ident](https://docs.rs/quote/latest/quote/macro.format_ident.html \"macro quote::format_ident\")\n    Formatting macro for constructing `Ident`s.\n\n[quote](https://docs.rs/quote/latest/quote/macro.quote.html \"macro quote::quote\")\n    The whole point.\n\n[quote_spanned](https://docs.rs/quote/latest/quote/macro.quote_spanned.html \"macro quote::quote_spanned\")\n    Same as `quote!`, but applies a given span to all tokens originating within the macro invocation.\n## Traits[\u00a7](https://docs.rs/quote/latest/quote/#traits)\n\n[IdentFragment](https://docs.rs/quote/latest/quote/trait.IdentFragment.html \"trait quote::IdentFragment\")\n    Specialized formatting trait used by `format_ident!`.\n\n[ToTokens](https://docs.rs/quote/latest/quote/trait.ToTokens.html \"trait quote::ToTokens\")\n    Types that can be interpolated inside a `quote!` invocation.\n\n[TokenStreamExt](https://docs.rs/quote/latest/quote/trait.TokenStreamExt.html \"trait quote::TokenStreamExt\")\n    TokenStream extension trait with methods for appending tokens.\n",
            "markdown_with_citations": "[](https://docs.rs/quote/latest/quote/all.html \"show sidebar\")\n# Crate quoteCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\n![github\u27e84\u27e9](https://github.com/dtolnay/quote) ![crates-io\u27e85\u27e9](https://crates.io/crates/quote) ![docs-rs\u27e86\u27e9](https://docs.rs/quote)\nThis crate provides the `quote!`\u27e87\u27e9 macro for turning Rust syntax tree data structures into tokens of source code.\nProcedural macros in Rust receive a stream of tokens as input, execute arbitrary Rust code to determine how to manipulate those tokens, and produce a stream of tokens to hand back to the compiler to compile into the caller\u2019s crate. Quasi-quoting is a solution to one piece of that \u2014 producing tokens to return to the compiler.\nThe idea of quasi-quoting is that we write _code_ that we treat as _data_. Within the `quote!` macro, we can write what looks like code to our text editor or IDE. We get all the benefits of the editor\u2019s brace matching, syntax highlighting, indentation, and maybe autocompletion. But rather than compiling that as code into the current crate, we can treat it as data, pass it around, mutate it, and eventually hand it back to the compiler as tokens to compile into the macro caller\u2019s crate.\nThis crate is motivated by the procedural macro use case, but is a general-purpose Rust quasi-quoting library and is not specific to procedural macros.\n```\n[dependencies]\nquote = \"1.0\"\n```\n\n## \u00a7\u27e88\u27e9Example\nThe following quasi-quoted block of code is something you might find in a\u27e89\u27e9 procedural macro having to do with data structure serialization. The `#var` syntax performs interpolation of runtime variables into the quoted tokens. Check out the documentation of the `quote!`\u27e87\u27e9 macro for more detail about the syntax. See also the `quote_spanned!`\u27e810\u27e9 macro which is important for implementing hygienic procedural macros.\n```\nlet tokens = quote! {\n  struct SerializeWith #generics #where_clause {\n    value: &'a #field_ty,\n    phantom: core::marker::PhantomData<#item_ty>,\n  }\n  impl #generics serde::Serialize for SerializeWith #generics #where_clause {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n      S: serde::Serializer,\n    {\n      #path(self.value, serializer)\n    }\n  }\n  SerializeWith {\n    value: #value,\n    phantom: core::marker::PhantomData::<#item_ty>,\n  }\n};\n```\n\n## \u00a7\u27e811\u27e9Non-macro code generators\nWhen using `quote` in a build.rs or main.rs and writing the output out to a file, consider having the code generator pass the tokens through prettyplease\u27e812\u27e9 before writing. This way if an error occurs in the generated code it is convenient for a human to read and debug.\n## Macros\u00a7\u27e813\u27e9\n\nformat_ident\u27e814\u27e9\n    Formatting macro for constructing `Ident`s.\n\nquote\u27e87\u27e9\n    The whole point.\n\nquote_spanned\u27e810\u27e9\n    Same as `quote!`, but applies a given span to all tokens originating within the macro invocation.\n## Traits\u00a7\u27e815\u27e9\n\nIdentFragment\u27e816\u27e9\n    Specialized formatting trait used by `format_ident!`.\n\nToTokens\u27e817\u27e9\n    Types that can be interpolated inside a `quote!` invocation.\n\nTokenStreamExt\u27e818\u27e9\n    TokenStream extension trait with methods for appending tokens.\n",
            "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/quote/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/quote/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/quote/latest/src/quote/lib.rs.html#1-1454: Source\n\u27e84\u27e9 https://img.shields.io/badge/github-8da0cb?style=for-the-badge&labelColor=555555&logo=github: ![github\n\u27e85\u27e9 https://img.shields.io/badge/crates.io-fc8d62?style=for-the-badge&labelColor=555555&logo=rust: ![crates-io\n\u27e86\u27e9 https://img.shields.io/badge/docs.rs-66c2a5?style=for-the-badge&labelColor=555555&logo=docs.rs: ![docs-rs\n\u27e87\u27e9 https://docs.rs/quote/latest/quote/macro.quote.html: macro quote::quote - `quote!`\n\u27e88\u27e9 https://docs.rs/quote/latest/quote/#example: \u00a7\n\u27e89\u27e9 https://serde.rs/: a\n\u27e810\u27e9 https://docs.rs/quote/latest/quote/macro.quote_spanned.html: macro quote::quote_spanned - `quote_spanned!`\n\u27e811\u27e9 https://docs.rs/quote/latest/quote/#non-macro-code-generators: \u00a7\n\u27e812\u27e9 https://github.com/dtolnay/prettyplease: prettyplease\n\u27e813\u27e9 https://docs.rs/quote/latest/quote/#macros: \u00a7\n\u27e814\u27e9 https://docs.rs/quote/latest/quote/macro.format_ident.html: macro quote::format_ident - format_ident\n\u27e815\u27e9 https://docs.rs/quote/latest/quote/#traits: \u00a7\n\u27e816\u27e9 https://docs.rs/quote/latest/quote/trait.IdentFragment.html: trait quote::IdentFragment - IdentFragment\n\u27e817\u27e9 https://docs.rs/quote/latest/quote/trait.ToTokens.html: trait quote::ToTokens - ToTokens\n\u27e818\u27e9 https://docs.rs/quote/latest/quote/trait.TokenStreamExt.html: trait quote::TokenStreamExt - TokenStreamExt\n",
            "fit_markdown": "",
            "fit_html": ""
          },
          "downloads": 0,
          "github_stars": 0,
          "dependencies": [],
          "features": {},
          "code_snippets": [],
          "readme_sections": {},
          "librs_downloads": null,
          "source": "crates.io",
          "enhanced_scraping": {},
          "enhanced_features": [],
          "enhanced_dependencies": [],
          "readme_summary": "The `quote` crate provides the `quote!` macro for generating Rust code as token streams, enabling quasi-quoting for procedural macros and other code generation tasks. It supports interpolation of runtime variables, span customization with `quote_spanned!`, and includes utilities like `format_ident!` for constructing identifiers. Key traits like `ToTokens` and `TokenStreamExt` facilitate seamless manipulation and extension of token streams.",
          "feature_summary": null,
          "use_case": "DevTools",
          "score": 8.5,
          "factual_counterfactual": "### Pair 1: Macro Functionality\n\u2705 Factual: The `quote!` macro allows developers to write code that is treated as data, enabling the creation of token streams for procedural macros in Rust.  \n\u274c Counterfactual: The `quote!` macro directly compiles the quoted code into the current crate without treating it as data.\n\n---\n\n### Pair 2: Span Handling\n\u2705 Factual: The `quote_spanned!` macro applies a specified span to all tokens generated within the macro invocation, which is useful for ensuring hygienic procedural macros.  \n\u274c Counterfactual: The `quote_spanned!` macro automatically determines spans based on the context of the macro invocation and does not allow manual specification.\n\n---\n\n### Pair 3: Non-Macro Code Generators\n\u2705 Factual: When using `quote` in non-macro code generators, such as in `build.rs`, the generated tokens can be passed through the `prettyplease` crate to produce human-readable and debuggable code.  \n\u274c Counterfactual: The `quote` crate includes built-in functionality for formatting tokens into human-readable code without requiring external crates like `prettyplease`.",
          "source_analysis": null,
          "user_behavior": null,
          "security": null
        }
      },
      "irl_score": 8.6,
      "execution_id": "exec-6327245c-91d2601d-1751263761",
      "timestamp": "2025-06-30T06:09:21.656361+00:00",
      "canon_version": "1.3.0"
    },
    "rule_zero_compliant": true
  }
]