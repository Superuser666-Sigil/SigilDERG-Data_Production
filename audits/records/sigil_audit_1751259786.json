[
  {
    "execution_id": "exec-8d203327-209c5772-1751259780",
    "timestamp": "2025-06-30T05:03:00.733174+00:00",
    "sacred_chain": {
      "input_data": "quick-error",
      "context_sources": [
        "crates.io",
        "github.com",
        "lib.rs",
        "docs.rs"
      ],
      "reasoning_steps": [
        "Input canonicalized: 'quick-error' -> 'quick-error'",
        "Context gathered from 4 validated sources",
        "Metadata extracted: 4 fields",
        "Documentation analyzed: quality 7.0",
        "Sentiment analyzed: positive",
        "Ecosystem analyzed: utilities",
        "Quality score synthesized: 7.50",
        "Trust decision: DEFER - Insufficient data for decision",
        "IRL confidence: 8.600"
      ],
      "suggestion": "ALLOW: Positive community sentiment",
      "verdict": "DEFER",
      "audit_info": {
        "metadata": {
          "name": "quick-error",
          "type": "rust_crate",
          "source": "manual_input",
          "extraction_method": "irl_engine"
        },
        "sentiment": {
          "quality_score": 7.0,
          "completeness": 0.8,
          "examples_present": true,
          "api_documented": true
        },
        "ecosystem": {
          "overall": "positive",
          "positive_mentions": 10,
          "negative_mentions": 2,
          "neutral_mentions": 5,
          "total_mentions": 17
        },
        "quality_score": 7.5,
        "verdict_reason": "Insufficient data for decision",
        "sanitized_documentation": {
          "crates_io": {
            "url": "https://crates.io/crates/quick-error",
            "title": "quick-error v2.0.1",
            "content": {
              "raw_markdown": "#  quick-error v2.0.1\nA macro which makes error types pleasant to write. \n  * [ #type ](https://crates.io/keywords/type)\n  * [ #enum ](https://crates.io/keywords/enum)\n  * [ #error ](https://crates.io/keywords/error)\n  * [ #macro ](https://crates.io/keywords/macro)\n\n\n  * [ Readme ](https://crates.io/crates/quick-error)\n  * [ 16 Versions ](https://crates.io/crates/quick-error/versions)\n  * [ Dependencies ](https://crates.io/crates/quick-error/dependencies)\n  * [ Dependents ](https://crates.io/crates/quick-error/reverse_dependencies)\n\n\n## Metadata\nabout 4 years ago \n2018 edition \n[ MIT ](https://choosealicense.com/licenses/mit) OR [ Apache-2.0 ](https://choosealicense.com/licenses/apache-2.0)\n13.9 KiB \n## Install\nRun the following Cargo command in your project directory:\ncargo add quick-error\nOr add the following line to your Cargo.toml:\nquick-error = \"2.0.1\"\n## Documentation\n[ http://docs.rs/quick-error ](http://docs.rs/quick-error)\n## Repository\n[ http://github.com/tailhook/quick-error ](http://github.com/tailhook/quick-error)\n## Owners\n## Categories\n  * [Rust patterns](https://crates.io/categories/rust-patterns)\n\n\n[ Report crate ](https://crates.io/support?crate=quick-error&inquire=crate-violation)\n### Stats Overview\n154,990,646 Downloads all time\n16 Versions published\n#### Downloads over the last 90 days\nDisplay as \nStacked \n  * Stacked \n  * Unstacked \n\n\nLoading\u2026\n",
              "markdown_with_citations": "#  quick-error v2.0.1\nA macro which makes error types pleasant to write. \n  *  #type \u27e81\u27e9\n  *  #enum \u27e82\u27e9\n  *  #error \u27e83\u27e9\n  *  #macro \u27e84\u27e9\n\n\n  *  Readme \u27e85\u27e9\n  *  16 Versions \u27e86\u27e9\n  *  Dependencies \u27e87\u27e9\n  *  Dependents \u27e88\u27e9\n\n\n## Metadata\nabout 4 years ago \n2018 edition \n MIT \u27e89\u27e9 OR  Apache-2.0 \u27e810\u27e9\n13.9 KiB \n## Install\nRun the following Cargo command in your project directory:\ncargo add quick-error\nOr add the following line to your Cargo.toml:\nquick-error = \"2.0.1\"\n## Documentation\n http://docs.rs/quick-error \u27e811\u27e9\n## Repository\n http://github.com/tailhook/quick-error \u27e812\u27e9\n## Owners\n## Categories\n  * Rust patterns\u27e813\u27e9\n\n\n Report crate \u27e814\u27e9\n### Stats Overview\n154,990,646 Downloads all time\n16 Versions published\n#### Downloads over the last 90 days\nDisplay as \nStacked \n  * Stacked \n  * Unstacked \n\n\nLoading\u2026\n",
              "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://crates.io/keywords/type:  #type \n\u27e82\u27e9 https://crates.io/keywords/enum:  #enum \n\u27e83\u27e9 https://crates.io/keywords/error:  #error \n\u27e84\u27e9 https://crates.io/keywords/macro:  #macro \n\u27e85\u27e9 https://crates.io/crates/quick-error:  Readme \n\u27e86\u27e9 https://crates.io/crates/quick-error/versions:  16 Versions \n\u27e87\u27e9 https://crates.io/crates/quick-error/dependencies:  Dependencies \n\u27e88\u27e9 https://crates.io/crates/quick-error/reverse_dependencies:  Dependents \n\u27e89\u27e9 https://choosealicense.com/licenses/mit:  MIT \n\u27e810\u27e9 https://choosealicense.com/licenses/apache-2.0:  Apache-2.0 \n\u27e811\u27e9 http://docs.rs/quick-error:  http://docs.rs/quick-error \n\u27e812\u27e9 http://github.com/tailhook/quick-error:  http://github.com/tailhook/quick-error \n\u27e813\u27e9 https://crates.io/categories/rust-patterns: Rust patterns\n\u27e814\u27e9 https://crates.io/support?crate=quick-error&inquire=crate-violation:  Report crate \n",
              "fit_markdown": "",
              "fit_html": ""
            },
            "structured_data": {},
            "quality_score": 3.0,
            "extraction_method": "crawl4ai",
            "error": null,
            "metadata": {
              "doc_type": "docs",
              "content_length": 1388,
              "has_structured_data": false,
              "crawl_success": true
            },
            "timestamp": "113570.6583012"
          },
          "docs_rs": {
            "url": "https://docs.rs/quick-error",
            "title": "Crate quick_errorCopy item path",
            "content": {
              "raw_markdown": "[](https://docs.rs/quick-error/latest/quick_error/all.html \"show sidebar\")\n# Crate quick_errorCopy item path\n[Settings](https://docs.rs/quick-error/latest/settings.html)\n[Help](https://docs.rs/quick-error/latest/help.html)\nSummary[Source](https://docs.rs/quick-error/latest/src/quick_error/lib.rs.html#1-1336)\nExpand description\nA macro which makes errors easy to write\nMinimum type is like this:\n```\n#[macro_use] extern crate quick_error;\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    Variant1 {}\n  }\n}\n```\n\nBoth `pub` and non-public types may be declared, and all meta attributes (such as `#[derive(Debug)]`) are forwarded as is. The `Debug` must be implemented (but you may do that yourself if you like). The documentation comments `/// something` (as well as other meta attrbiutes) on variants are allowed.\n## [\u00a7](https://docs.rs/quick-error/latest/quick_error/#allowed-syntax)Allowed Syntax\nYou may add arbitrary parameters to any struct variant:\n```\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    /// IO Error\n    Io(err: std::io::Error) {}\n    /// Utf8 Error\n    Utf8(err: std::str::Utf8Error) {}\n  }\n}\n```\n\nNote unlike in normal Enum declarations you declare names of fields (which are omitted from type). How they can be used is outlined below.\nNow you might have noticed trailing braces `{}`. They are used to define implementations. By default:\n  * `Error::source()` returns None (even if type wraps some value)\n  * `Display` outputs debug representation\n  * No `From` implementations are defined\n\n\n```\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    Io(err: std::io::Error) {\n      display(\"{}\", err)\n    }\n    Utf8(err: std::str::Utf8Error) {\n      display(\"utf8 error\")\n    }\n  }\n}\n```\n\nTo change `source` method to return some error, add `source(value)`, for example:\n```\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    Io(err: std::io::Error) {\n      source(err)\n    }\n    Utf8(err: std::str::Utf8Error) {\n      display(\"utf8 error\")\n    }\n    Other(err: Box<std::error::Error>) {\n      source(&**err)\n    }\n  }\n}\n```\n\nNote you don\u2019t need to wrap value in `Some`, its implicit. In case you want `None` returned just omit the `source`. You can\u2019t return `None` conditionally.\nTo change how each clause is `Display`ed add `display(pattern,..args)`, for example:\n```\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    Io(err: std::io::Error) {\n      display(\"I/O error: {}\", err)\n    }\n    Utf8(err: std::str::Utf8Error) {\n      display(\"Utf8 error, valid up to {}\", err.valid_up_to())\n    }\n  }\n}\n```\n\nIf you need a reference to the error when `Display`ing, you can instead use `display(x) -> (pattern, ..args)`, where `x` sets the name of the reference.\n```\nuse std::error::Error; // put methods like `source()` of this trait into scope\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    Io(err: std::io::Error) {\n      display(x) -> (\"I/O: {}\", err)\n    }\n    Utf8(err: std::str::Utf8Error) {\n      display(self_) -> (\"UTF-8 error. Valid up to {}\", err.valid_up_to())\n    }\n  }\n}\n```\n\nTo convert to the type from any other, use one of the three forms of `from` clause.\nFor example, to convert simple wrapper use bare `from()`:\n```\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    Io(err: std::io::Error) {\n      from()\n    }\n  }\n}\n```\n\nThis implements `From<io::Error>`.\nTo convert to singleton enumeration type (discarding the value), use the `from(type)` form:\n```\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    FormatError {\n      from(std::fmt::Error)\n    }\n  }\n}\n```\n\nAnd the most powerful form is `from(var: type) -> (arguments...)`. It might be used to convert to type with multiple arguments or for arbitrary value conversions:\n```\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    FailedOperation(s: &'static str, errno: i32) {\n      from(errno: i32) -> (\"os error\", errno)\n      from(e: std::io::Error) -> (\"io error\", e.raw_os_error().unwrap())\n    }\n    /// Converts from both kinds of utf8 errors\n    Utf8(err: std::str::Utf8Error) {\n      from()\n      from(err: std::string::FromUtf8Error) -> (err.utf8_error())\n    }\n  }\n}\n```\n\n## [\u00a7](https://docs.rs/quick-error/latest/quick_error/#context)Context\nSince quick-error 1.1 we also have a `context` declaration, which is similar to (the longest form of) `from`, but allows adding some context to the error. We need a longer example to demonstrate this:\n```\nuse quick_error::ResultExt;\nquick_error! {\n  #[derive(Debug)]\n  pub enum Error {\n    File(filename: PathBuf, err: io::Error) {\n      context(path: &'a Path, err: io::Error)\n        -> (path.to_path_buf(), err)\n    }\n  }\n}\nfn openfile(path: &Path) -> Result<(), Error> {\n  File::open(path).context(path)?;\n  // If we didn't have context, the line above would be written as;\n  //\n  // File::open(path)\n  //   .map_err(|err| Error::File(path.to_path_buf(), err))?;\n  Ok(())\n}\n\n```\n\nEach `context(a: A, b: B)` clause implements `From<Context<A, B>> for Error`. Which means multiple `context` clauses are a subject to the normal coherence rules. Unfortunately, we can\u2019t provide full support of generics for the context, but you may either use a lifetime `'a` for references or `AsRef<Type>` (the latter means `A: AsRef<Type>`, and `Type` must be concrete). It\u2019s also occasionally useful to use a tuple as a type of the first argument.\nYou also need to `use quick_error::ResultExt` extension trait to get working `.context()` method.\nMore info on context in [this article](http://bit.ly/1PsuxDt).\nAll forms of `from`, `display`, `source`, and `context` clauses can be combined and put in arbitrary order. Only `from` and `context` can be used multiple times in single variant of enumeration. Docstrings are also okay. Empty braces can be omitted as of quick_error 0.1.3.\n## [\u00a7](https://docs.rs/quick-error/latest/quick_error/#private-enums)Private Enums\nSince quick-error 1.2.0 we have a way to make a private enum that is wrapped by public structure:\n```\n#[macro_use] extern crate quick_error;\nquick_error! {\n  #[derive(Debug)]\n  pub enum PubError wraps ErrorEnum {\n    Variant1 {}\n  }\n}\n```\n\nThis generates data structures like this\n```\n\npub struct PubError(ErrorEnum);\nenum ErrorEnum {\n  Variant1,\n}\n\n```\n\nWhich in turn allows you to export just `PubError` in your crate and keep actual enumeration private to the crate. This is useful to keep backwards compatibility for error types. Currently there is no shorcuts to define error constructors for the inner type, but we consider adding some in future versions.\nIt\u2019s possible to declare internal enum as public too.\n## Macros[\u00a7](https://docs.rs/quick-error/latest/quick_error/#macros)\n\n[quick_error](https://docs.rs/quick-error/latest/quick_error/macro.quick_error.html \"macro quick_error::quick_error\")\n    Main macro that does all the work\n## Structs[\u00a7](https://docs.rs/quick-error/latest/quick_error/#structs)\n\n[Context](https://docs.rs/quick-error/latest/quick_error/struct.Context.html \"struct quick_error::Context\")\n    Generic context type\n## Traits[\u00a7](https://docs.rs/quick-error/latest/quick_error/#traits)\n\n[ResultExt](https://docs.rs/quick-error/latest/quick_error/trait.ResultExt.html \"trait quick_error::ResultExt\")\n    Result extension trait adding a `context` method\n",
              "markdown_with_citations": "[](https://docs.rs/quick-error/latest/quick_error/all.html \"show sidebar\")\n# Crate quick_errorCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nA macro which makes errors easy to write\nMinimum type is like this:\n```\n#[macro_use] extern crate quick_error;\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    Variant1 {}\n  }\n}\n```\n\nBoth `pub` and non-public types may be declared, and all meta attributes (such as `#[derive(Debug)]`) are forwarded as is. The `Debug` must be implemented (but you may do that yourself if you like). The documentation comments `/// something` (as well as other meta attrbiutes) on variants are allowed.\n## \u00a7\u27e84\u27e9Allowed Syntax\nYou may add arbitrary parameters to any struct variant:\n```\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    /// IO Error\n    Io(err: std::io::Error) {}\n    /// Utf8 Error\n    Utf8(err: std::str::Utf8Error) {}\n  }\n}\n```\n\nNote unlike in normal Enum declarations you declare names of fields (which are omitted from type). How they can be used is outlined below.\nNow you might have noticed trailing braces `{}`. They are used to define implementations. By default:\n  * `Error::source()` returns None (even if type wraps some value)\n  * `Display` outputs debug representation\n  * No `From` implementations are defined\n\n\n```\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    Io(err: std::io::Error) {\n      display(\"{}\", err)\n    }\n    Utf8(err: std::str::Utf8Error) {\n      display(\"utf8 error\")\n    }\n  }\n}\n```\n\nTo change `source` method to return some error, add `source(value)`, for example:\n```\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    Io(err: std::io::Error) {\n      source(err)\n    }\n    Utf8(err: std::str::Utf8Error) {\n      display(\"utf8 error\")\n    }\n    Other(err: Box<std::error::Error>) {\n      source(&**err)\n    }\n  }\n}\n```\n\nNote you don\u2019t need to wrap value in `Some`, its implicit. In case you want `None` returned just omit the `source`. You can\u2019t return `None` conditionally.\nTo change how each clause is `Display`ed add `display(pattern,..args)`, for example:\n```\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    Io(err: std::io::Error) {\n      display(\"I/O error: {}\", err)\n    }\n    Utf8(err: std::str::Utf8Error) {\n      display(\"Utf8 error, valid up to {}\", err.valid_up_to())\n    }\n  }\n}\n```\n\nIf you need a reference to the error when `Display`ing, you can instead use `display(x) -> (pattern, ..args)`, where `x` sets the name of the reference.\n```\nuse std::error::Error; // put methods like `source()` of this trait into scope\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    Io(err: std::io::Error) {\n      display(x) -> (\"I/O: {}\", err)\n    }\n    Utf8(err: std::str::Utf8Error) {\n      display(self_) -> (\"UTF-8 error. Valid up to {}\", err.valid_up_to())\n    }\n  }\n}\n```\n\nTo convert to the type from any other, use one of the three forms of `from` clause.\nFor example, to convert simple wrapper use bare `from()`:\n```\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    Io(err: std::io::Error) {\n      from()\n    }\n  }\n}\n```\n\nThis implements `From<io::Error>`.\nTo convert to singleton enumeration type (discarding the value), use the `from(type)` form:\n```\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    FormatError {\n      from(std::fmt::Error)\n    }\n  }\n}\n```\n\nAnd the most powerful form is `from(var: type) -> (arguments...)`. It might be used to convert to type with multiple arguments or for arbitrary value conversions:\n```\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    FailedOperation(s: &'static str, errno: i32) {\n      from(errno: i32) -> (\"os error\", errno)\n      from(e: std::io::Error) -> (\"io error\", e.raw_os_error().unwrap())\n    }\n    /// Converts from both kinds of utf8 errors\n    Utf8(err: std::str::Utf8Error) {\n      from()\n      from(err: std::string::FromUtf8Error) -> (err.utf8_error())\n    }\n  }\n}\n```\n\n## \u00a7\u27e85\u27e9Context\nSince quick-error 1.1 we also have a `context` declaration, which is similar to (the longest form of) `from`, but allows adding some context to the error. We need a longer example to demonstrate this:\n```\nuse quick_error::ResultExt;\nquick_error! {\n  #[derive(Debug)]\n  pub enum Error {\n    File(filename: PathBuf, err: io::Error) {\n      context(path: &'a Path, err: io::Error)\n        -> (path.to_path_buf(), err)\n    }\n  }\n}\nfn openfile(path: &Path) -> Result<(), Error> {\n  File::open(path).context(path)?;\n  // If we didn't have context, the line above would be written as;\n  //\n  // File::open(path)\n  //   .map_err(|err| Error::File(path.to_path_buf(), err))?;\n  Ok(())\n}\n\n```\n\nEach `context(a: A, b: B)` clause implements `From<Context<A, B>> for Error`. Which means multiple `context` clauses are a subject to the normal coherence rules. Unfortunately, we can\u2019t provide full support of generics for the context, but you may either use a lifetime `'a` for references or `AsRef<Type>` (the latter means `A: AsRef<Type>`, and `Type` must be concrete). It\u2019s also occasionally useful to use a tuple as a type of the first argument.\nYou also need to `use quick_error::ResultExt` extension trait to get working `.context()` method.\nMore info on context in this article\u27e86\u27e9.\nAll forms of `from`, `display`, `source`, and `context` clauses can be combined and put in arbitrary order. Only `from` and `context` can be used multiple times in single variant of enumeration. Docstrings are also okay. Empty braces can be omitted as of quick_error 0.1.3.\n## \u00a7\u27e87\u27e9Private Enums\nSince quick-error 1.2.0 we have a way to make a private enum that is wrapped by public structure:\n```\n#[macro_use] extern crate quick_error;\nquick_error! {\n  #[derive(Debug)]\n  pub enum PubError wraps ErrorEnum {\n    Variant1 {}\n  }\n}\n```\n\nThis generates data structures like this\n```\n\npub struct PubError(ErrorEnum);\nenum ErrorEnum {\n  Variant1,\n}\n\n```\n\nWhich in turn allows you to export just `PubError` in your crate and keep actual enumeration private to the crate. This is useful to keep backwards compatibility for error types. Currently there is no shorcuts to define error constructors for the inner type, but we consider adding some in future versions.\nIt\u2019s possible to declare internal enum as public too.\n## Macros\u00a7\u27e88\u27e9\n\nquick_error\u27e89\u27e9\n    Main macro that does all the work\n## Structs\u00a7\u27e810\u27e9\n\nContext\u27e811\u27e9\n    Generic context type\n## Traits\u00a7\u27e812\u27e9\n\nResultExt\u27e813\u27e9\n    Result extension trait adding a `context` method\n",
              "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/quick-error/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/quick-error/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/quick-error/latest/src/quick_error/lib.rs.html#1-1336: Source\n\u27e84\u27e9 https://docs.rs/quick-error/latest/quick_error/#allowed-syntax: \u00a7\n\u27e85\u27e9 https://docs.rs/quick-error/latest/quick_error/#context: \u00a7\n\u27e86\u27e9 http://bit.ly/1PsuxDt: this article\n\u27e87\u27e9 https://docs.rs/quick-error/latest/quick_error/#private-enums: \u00a7\n\u27e88\u27e9 https://docs.rs/quick-error/latest/quick_error/#macros: \u00a7\n\u27e89\u27e9 https://docs.rs/quick-error/latest/quick_error/macro.quick_error.html: macro quick_error::quick_error - quick_error\n\u27e810\u27e9 https://docs.rs/quick-error/latest/quick_error/#structs: \u00a7\n\u27e811\u27e9 https://docs.rs/quick-error/latest/quick_error/struct.Context.html: struct quick_error::Context - Context\n\u27e812\u27e9 https://docs.rs/quick-error/latest/quick_error/#traits: \u00a7\n\u27e813\u27e9 https://docs.rs/quick-error/latest/quick_error/trait.ResultExt.html: trait quick_error::ResultExt - ResultExt\n",
              "fit_markdown": "",
              "fit_html": ""
            },
            "structured_data": {},
            "quality_score": 4.0,
            "extraction_method": "crawl4ai",
            "error": null,
            "metadata": {
              "doc_type": "docs",
              "content_length": 7276,
              "has_structured_data": false,
              "crawl_success": true
            },
            "timestamp": "113571.4341821"
          },
          "lib_rs": {
            "url": "https://lib.rs/crates/quick-error",
            "title": "Untitled",
            "content": {
              "raw_markdown": "###  [16 releases](https://lib.rs/crates/quick-error/versions) (8 stable)\n2.0.1 |  May 7, 2021   \n---|---  \n2.0.0 |  Aug 11, 2020   \n1.2.3 |  Jan 2, 2020   \n1.2.2 |  May 26, 2018   \n0.1.4 |  Oct 17, 2015   \n#**890** in [Rust patterns](https://lib.rs/rust-patterns \"Shared solutions for particular situations specific to programming in Rust.\")\nDownload history 2117967/week @ 2025-03-08 2412481/week @ 2025-03-15 3022746/week @ 2025-03-22 1823499/week @ 2025-03-29 1923035/week @ 2025-04-05 1602174/week @ 2025-04-12 1505971/week @ 2025-04-19 1406979/week @ 2025-04-26 1523226/week @ 2025-05-03 1551366/week @ 2025-05-10 1580124/week @ 2025-05-17 1270563/week @ 2025-05-24 1370518/week @ 2025-05-31 1395596/week @ 2025-06-07 1458986/week @ 2025-06-14 1316361/week @ 2025-06-21\n**5,773,063** downloads per month Used in [fewer than **296** crates](https://lib.rs/crates/quick-error/rev)\n**MIT/Apache**\n49KB  962 lines\n## Quick Error\nStatus:| production-ready  \n---|---  \nDocumentation:| <https://docs.rs/quick-error/>  \nA macro which makes error types pleasant to write.\nFeatures:\n  * Define enum type with arbitrary parameters\n  * Concise notation of `Display` and `Error` traits\n  * Full control of `Display` and `Error` trait implementation\n  * Any number of `From` traits\n  * Support for all enum-variants `Unit`, `Tuple` and `Struct`\n\n\nHere is the comprehensive example:\n```\nquick_error!{#[derive(Debug)]pubenum IoWrapper{Io(err: io::Error){from()display(\"I/O error: {}\",err)source(err)}Other(descr: &'static str){display(\"Error {}\",descr)}IoAt{place: &'static str,err: io::Error}{source(err)display(me)-> (\"io error at {}: {}\",place,err)from(s: String)-> {place: \"some string\",err: io::Error::new(io::ErrorKind::Other,s)}}Discard{from(&'staticstr)}}}\n\n```\n\n## License\nLicensed under either of\n>   * Apache License, Version 2.0, (./LICENSE-APACHE or <http://www.apache.org/licenses/LICENSE-2.0>)\n>   * MIT license (./LICENSE-MIT or <http://opensource.org/licenses/MIT>)\n> \n\nat your option.\n### Contribution\nUnless you explicitly state otherwise, any contribution intentionally submitted for inclusion in the work by you, as defined in the Apache-2.0 license, shall be dual licensed as above, without any additional terms or conditions.\n#### No runtime deps\n",
              "markdown_with_citations": "###  16 releases\u27e81\u27e9 (8 stable)\n2.0.1 |  May 7, 2021   \n---|---  \n2.0.0 |  Aug 11, 2020   \n1.2.3 |  Jan 2, 2020   \n1.2.2 |  May 26, 2018   \n0.1.4 |  Oct 17, 2015   \n#**890** in Rust patterns\u27e82\u27e9\nDownload history 2117967/week @ 2025-03-08 2412481/week @ 2025-03-15 3022746/week @ 2025-03-22 1823499/week @ 2025-03-29 1923035/week @ 2025-04-05 1602174/week @ 2025-04-12 1505971/week @ 2025-04-19 1406979/week @ 2025-04-26 1523226/week @ 2025-05-03 1551366/week @ 2025-05-10 1580124/week @ 2025-05-17 1270563/week @ 2025-05-24 1370518/week @ 2025-05-31 1395596/week @ 2025-06-07 1458986/week @ 2025-06-14 1316361/week @ 2025-06-21\n**5,773,063** downloads per month Used in fewer than **296** crates\u27e83\u27e9\n**MIT/Apache**\n49KB  962 lines\n## Quick Error\nStatus:| production-ready  \n---|---  \nDocumentation:| <https://docs.rs/quick-error/>  \nA macro which makes error types pleasant to write.\nFeatures:\n  * Define enum type with arbitrary parameters\n  * Concise notation of `Display` and `Error` traits\n  * Full control of `Display` and `Error` trait implementation\n  * Any number of `From` traits\n  * Support for all enum-variants `Unit`, `Tuple` and `Struct`\n\n\nHere is the comprehensive example:\n```\nquick_error!{#[derive(Debug)]pubenum IoWrapper{Io(err: io::Error){from()display(\"I/O error: {}\",err)source(err)}Other(descr: &'static str){display(\"Error {}\",descr)}IoAt{place: &'static str,err: io::Error}{source(err)display(me)-> (\"io error at {}: {}\",place,err)from(s: String)-> {place: \"some string\",err: io::Error::new(io::ErrorKind::Other,s)}}Discard{from(&'staticstr)}}}\n\n```\n\n## License\nLicensed under either of\n>   * Apache License, Version 2.0, (./LICENSE-APACHE or <http://www.apache.org/licenses/LICENSE-2.0>)\n>   * MIT license (./LICENSE-MIT or <http://opensource.org/licenses/MIT>)\n> \n\nat your option.\n### Contribution\nUnless you explicitly state otherwise, any contribution intentionally submitted for inclusion in the work by you, as defined in the Apache-2.0 license, shall be dual licensed as above, without any additional terms or conditions.\n#### No runtime deps\n",
              "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://lib.rs/crates/quick-error/versions: 16 releases\n\u27e82\u27e9 https://lib.rs/rust-patterns: Shared solutions for particular situations specific to programming in Rust. - Rust patterns\n\u27e83\u27e9 https://lib.rs/crates/quick-error/rev: fewer than **296** crates\n",
              "fit_markdown": "",
              "fit_html": ""
            },
            "structured_data": {},
            "quality_score": 3.0,
            "extraction_method": "crawl4ai",
            "error": null,
            "metadata": {
              "doc_type": "docs",
              "content_length": 2260,
              "has_structured_data": false,
              "crawl_success": true
            },
            "timestamp": "113571.7992093"
          }
        },
        "crate_analysis": {
          "status": "completed",
          "check": [
            {
              "reason": "compiler-artifact",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpe97mvk09/quick-error-2.0.1#quick-error@2.0.1",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpe97mvk09\\quick-error-2.0.1\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "quick_error",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpe97mvk09\\quick-error-2.0.1\\src\\lib.rs",
                "edition": "2018",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpe97mvk09\\quick-error-2.0.1\\target\\debug\\deps\\libquick_error-e231665061322f28.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "build-finished",
              "success": true
            }
          ],
          "clippy": [
            {
              "reason": "compiler-artifact",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpe97mvk09/quick-error-2.0.1#quick-error@2.0.1",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpe97mvk09\\quick-error-2.0.1\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "quick_error",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpe97mvk09\\quick-error-2.0.1\\src\\lib.rs",
                "edition": "2018",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpe97mvk09\\quick-error-2.0.1\\target\\debug\\deps\\libquick_error-fc89f471a934dc63.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "build-finished",
              "success": true
            }
          ],
          "audit": {
            "database": {
              "advisory-count": 787,
              "last-commit": "7573f55ba337263f61167dbb0ea926cdc7c8eb5d",
              "last-updated": "2025-06-17T11:04:25+02:00"
            },
            "lockfile": {
              "dependency-count": 1
            },
            "settings": {
              "target_arch": [],
              "target_os": [],
              "severity": null,
              "ignore": [],
              "informational_warnings": [
                "unmaintained",
                "unsound",
                "notice"
              ]
            },
            "vulnerabilities": {
              "found": false,
              "count": 0,
              "list": []
            },
            "warnings": {}
          },
          "note": "Crate analysis performed with stable toolchain."
        },
        "crate_metadata": {
          "name": "quick-error",
          "version": "2.0.1",
          "description": "ALLOW: Positive community sentiment",
          "repository": "",
          "keywords": [],
          "categories": [],
          "readme": {
            "raw_markdown": "[](https://docs.rs/quick-error/latest/quick_error/all.html \"show sidebar\")\n# Crate quick_errorCopy item path\n[Settings](https://docs.rs/quick-error/latest/settings.html)\n[Help](https://docs.rs/quick-error/latest/help.html)\nSummary[Source](https://docs.rs/quick-error/latest/src/quick_error/lib.rs.html#1-1336)\nExpand description\nA macro which makes errors easy to write\nMinimum type is like this:\n```\n#[macro_use] extern crate quick_error;\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    Variant1 {}\n  }\n}\n```\n\nBoth `pub` and non-public types may be declared, and all meta attributes (such as `#[derive(Debug)]`) are forwarded as is. The `Debug` must be implemented (but you may do that yourself if you like). The documentation comments `/// something` (as well as other meta attrbiutes) on variants are allowed.\n## [\u00a7](https://docs.rs/quick-error/latest/quick_error/#allowed-syntax)Allowed Syntax\nYou may add arbitrary parameters to any struct variant:\n```\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    /// IO Error\n    Io(err: std::io::Error) {}\n    /// Utf8 Error\n    Utf8(err: std::str::Utf8Error) {}\n  }\n}\n```\n\nNote unlike in normal Enum declarations you declare names of fields (which are omitted from type). How they can be used is outlined below.\nNow you might have noticed trailing braces `{}`. They are used to define implementations. By default:\n  * `Error::source()` returns None (even if type wraps some value)\n  * `Display` outputs debug representation\n  * No `From` implementations are defined\n\n\n```\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    Io(err: std::io::Error) {\n      display(\"{}\", err)\n    }\n    Utf8(err: std::str::Utf8Error) {\n      display(\"utf8 error\")\n    }\n  }\n}\n```\n\nTo change `source` method to return some error, add `source(value)`, for example:\n```\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    Io(err: std::io::Error) {\n      source(err)\n    }\n    Utf8(err: std::str::Utf8Error) {\n      display(\"utf8 error\")\n    }\n    Other(err: Box<std::error::Error>) {\n      source(&**err)\n    }\n  }\n}\n```\n\nNote you don\u2019t need to wrap value in `Some`, its implicit. In case you want `None` returned just omit the `source`. You can\u2019t return `None` conditionally.\nTo change how each clause is `Display`ed add `display(pattern,..args)`, for example:\n```\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    Io(err: std::io::Error) {\n      display(\"I/O error: {}\", err)\n    }\n    Utf8(err: std::str::Utf8Error) {\n      display(\"Utf8 error, valid up to {}\", err.valid_up_to())\n    }\n  }\n}\n```\n\nIf you need a reference to the error when `Display`ing, you can instead use `display(x) -> (pattern, ..args)`, where `x` sets the name of the reference.\n```\nuse std::error::Error; // put methods like `source()` of this trait into scope\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    Io(err: std::io::Error) {\n      display(x) -> (\"I/O: {}\", err)\n    }\n    Utf8(err: std::str::Utf8Error) {\n      display(self_) -> (\"UTF-8 error. Valid up to {}\", err.valid_up_to())\n    }\n  }\n}\n```\n\nTo convert to the type from any other, use one of the three forms of `from` clause.\nFor example, to convert simple wrapper use bare `from()`:\n```\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    Io(err: std::io::Error) {\n      from()\n    }\n  }\n}\n```\n\nThis implements `From<io::Error>`.\nTo convert to singleton enumeration type (discarding the value), use the `from(type)` form:\n```\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    FormatError {\n      from(std::fmt::Error)\n    }\n  }\n}\n```\n\nAnd the most powerful form is `from(var: type) -> (arguments...)`. It might be used to convert to type with multiple arguments or for arbitrary value conversions:\n```\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    FailedOperation(s: &'static str, errno: i32) {\n      from(errno: i32) -> (\"os error\", errno)\n      from(e: std::io::Error) -> (\"io error\", e.raw_os_error().unwrap())\n    }\n    /// Converts from both kinds of utf8 errors\n    Utf8(err: std::str::Utf8Error) {\n      from()\n      from(err: std::string::FromUtf8Error) -> (err.utf8_error())\n    }\n  }\n}\n```\n\n## [\u00a7](https://docs.rs/quick-error/latest/quick_error/#context)Context\nSince quick-error 1.1 we also have a `context` declaration, which is similar to (the longest form of) `from`, but allows adding some context to the error. We need a longer example to demonstrate this:\n```\nuse quick_error::ResultExt;\nquick_error! {\n  #[derive(Debug)]\n  pub enum Error {\n    File(filename: PathBuf, err: io::Error) {\n      context(path: &'a Path, err: io::Error)\n        -> (path.to_path_buf(), err)\n    }\n  }\n}\nfn openfile(path: &Path) -> Result<(), Error> {\n  File::open(path).context(path)?;\n  // If we didn't have context, the line above would be written as;\n  //\n  // File::open(path)\n  //   .map_err(|err| Error::File(path.to_path_buf(), err))?;\n  Ok(())\n}\n\n```\n\nEach `context(a: A, b: B)` clause implements `From<Context<A, B>> for Error`. Which means multiple `context` clauses are a subject to the normal coherence rules. Unfortunately, we can\u2019t provide full support of generics for the context, but you may either use a lifetime `'a` for references or `AsRef<Type>` (the latter means `A: AsRef<Type>`, and `Type` must be concrete). It\u2019s also occasionally useful to use a tuple as a type of the first argument.\nYou also need to `use quick_error::ResultExt` extension trait to get working `.context()` method.\nMore info on context in [this article](http://bit.ly/1PsuxDt).\nAll forms of `from`, `display`, `source`, and `context` clauses can be combined and put in arbitrary order. Only `from` and `context` can be used multiple times in single variant of enumeration. Docstrings are also okay. Empty braces can be omitted as of quick_error 0.1.3.\n## [\u00a7](https://docs.rs/quick-error/latest/quick_error/#private-enums)Private Enums\nSince quick-error 1.2.0 we have a way to make a private enum that is wrapped by public structure:\n```\n#[macro_use] extern crate quick_error;\nquick_error! {\n  #[derive(Debug)]\n  pub enum PubError wraps ErrorEnum {\n    Variant1 {}\n  }\n}\n```\n\nThis generates data structures like this\n```\n\npub struct PubError(ErrorEnum);\nenum ErrorEnum {\n  Variant1,\n}\n\n```\n\nWhich in turn allows you to export just `PubError` in your crate and keep actual enumeration private to the crate. This is useful to keep backwards compatibility for error types. Currently there is no shorcuts to define error constructors for the inner type, but we consider adding some in future versions.\nIt\u2019s possible to declare internal enum as public too.\n## Macros[\u00a7](https://docs.rs/quick-error/latest/quick_error/#macros)\n\n[quick_error](https://docs.rs/quick-error/latest/quick_error/macro.quick_error.html \"macro quick_error::quick_error\")\n    Main macro that does all the work\n## Structs[\u00a7](https://docs.rs/quick-error/latest/quick_error/#structs)\n\n[Context](https://docs.rs/quick-error/latest/quick_error/struct.Context.html \"struct quick_error::Context\")\n    Generic context type\n## Traits[\u00a7](https://docs.rs/quick-error/latest/quick_error/#traits)\n\n[ResultExt](https://docs.rs/quick-error/latest/quick_error/trait.ResultExt.html \"trait quick_error::ResultExt\")\n    Result extension trait adding a `context` method\n",
            "markdown_with_citations": "[](https://docs.rs/quick-error/latest/quick_error/all.html \"show sidebar\")\n# Crate quick_errorCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nA macro which makes errors easy to write\nMinimum type is like this:\n```\n#[macro_use] extern crate quick_error;\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    Variant1 {}\n  }\n}\n```\n\nBoth `pub` and non-public types may be declared, and all meta attributes (such as `#[derive(Debug)]`) are forwarded as is. The `Debug` must be implemented (but you may do that yourself if you like). The documentation comments `/// something` (as well as other meta attrbiutes) on variants are allowed.\n## \u00a7\u27e84\u27e9Allowed Syntax\nYou may add arbitrary parameters to any struct variant:\n```\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    /// IO Error\n    Io(err: std::io::Error) {}\n    /// Utf8 Error\n    Utf8(err: std::str::Utf8Error) {}\n  }\n}\n```\n\nNote unlike in normal Enum declarations you declare names of fields (which are omitted from type). How they can be used is outlined below.\nNow you might have noticed trailing braces `{}`. They are used to define implementations. By default:\n  * `Error::source()` returns None (even if type wraps some value)\n  * `Display` outputs debug representation\n  * No `From` implementations are defined\n\n\n```\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    Io(err: std::io::Error) {\n      display(\"{}\", err)\n    }\n    Utf8(err: std::str::Utf8Error) {\n      display(\"utf8 error\")\n    }\n  }\n}\n```\n\nTo change `source` method to return some error, add `source(value)`, for example:\n```\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    Io(err: std::io::Error) {\n      source(err)\n    }\n    Utf8(err: std::str::Utf8Error) {\n      display(\"utf8 error\")\n    }\n    Other(err: Box<std::error::Error>) {\n      source(&**err)\n    }\n  }\n}\n```\n\nNote you don\u2019t need to wrap value in `Some`, its implicit. In case you want `None` returned just omit the `source`. You can\u2019t return `None` conditionally.\nTo change how each clause is `Display`ed add `display(pattern,..args)`, for example:\n```\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    Io(err: std::io::Error) {\n      display(\"I/O error: {}\", err)\n    }\n    Utf8(err: std::str::Utf8Error) {\n      display(\"Utf8 error, valid up to {}\", err.valid_up_to())\n    }\n  }\n}\n```\n\nIf you need a reference to the error when `Display`ing, you can instead use `display(x) -> (pattern, ..args)`, where `x` sets the name of the reference.\n```\nuse std::error::Error; // put methods like `source()` of this trait into scope\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    Io(err: std::io::Error) {\n      display(x) -> (\"I/O: {}\", err)\n    }\n    Utf8(err: std::str::Utf8Error) {\n      display(self_) -> (\"UTF-8 error. Valid up to {}\", err.valid_up_to())\n    }\n  }\n}\n```\n\nTo convert to the type from any other, use one of the three forms of `from` clause.\nFor example, to convert simple wrapper use bare `from()`:\n```\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    Io(err: std::io::Error) {\n      from()\n    }\n  }\n}\n```\n\nThis implements `From<io::Error>`.\nTo convert to singleton enumeration type (discarding the value), use the `from(type)` form:\n```\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    FormatError {\n      from(std::fmt::Error)\n    }\n  }\n}\n```\n\nAnd the most powerful form is `from(var: type) -> (arguments...)`. It might be used to convert to type with multiple arguments or for arbitrary value conversions:\n```\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    FailedOperation(s: &'static str, errno: i32) {\n      from(errno: i32) -> (\"os error\", errno)\n      from(e: std::io::Error) -> (\"io error\", e.raw_os_error().unwrap())\n    }\n    /// Converts from both kinds of utf8 errors\n    Utf8(err: std::str::Utf8Error) {\n      from()\n      from(err: std::string::FromUtf8Error) -> (err.utf8_error())\n    }\n  }\n}\n```\n\n## \u00a7\u27e85\u27e9Context\nSince quick-error 1.1 we also have a `context` declaration, which is similar to (the longest form of) `from`, but allows adding some context to the error. We need a longer example to demonstrate this:\n```\nuse quick_error::ResultExt;\nquick_error! {\n  #[derive(Debug)]\n  pub enum Error {\n    File(filename: PathBuf, err: io::Error) {\n      context(path: &'a Path, err: io::Error)\n        -> (path.to_path_buf(), err)\n    }\n  }\n}\nfn openfile(path: &Path) -> Result<(), Error> {\n  File::open(path).context(path)?;\n  // If we didn't have context, the line above would be written as;\n  //\n  // File::open(path)\n  //   .map_err(|err| Error::File(path.to_path_buf(), err))?;\n  Ok(())\n}\n\n```\n\nEach `context(a: A, b: B)` clause implements `From<Context<A, B>> for Error`. Which means multiple `context` clauses are a subject to the normal coherence rules. Unfortunately, we can\u2019t provide full support of generics for the context, but you may either use a lifetime `'a` for references or `AsRef<Type>` (the latter means `A: AsRef<Type>`, and `Type` must be concrete). It\u2019s also occasionally useful to use a tuple as a type of the first argument.\nYou also need to `use quick_error::ResultExt` extension trait to get working `.context()` method.\nMore info on context in this article\u27e86\u27e9.\nAll forms of `from`, `display`, `source`, and `context` clauses can be combined and put in arbitrary order. Only `from` and `context` can be used multiple times in single variant of enumeration. Docstrings are also okay. Empty braces can be omitted as of quick_error 0.1.3.\n## \u00a7\u27e87\u27e9Private Enums\nSince quick-error 1.2.0 we have a way to make a private enum that is wrapped by public structure:\n```\n#[macro_use] extern crate quick_error;\nquick_error! {\n  #[derive(Debug)]\n  pub enum PubError wraps ErrorEnum {\n    Variant1 {}\n  }\n}\n```\n\nThis generates data structures like this\n```\n\npub struct PubError(ErrorEnum);\nenum ErrorEnum {\n  Variant1,\n}\n\n```\n\nWhich in turn allows you to export just `PubError` in your crate and keep actual enumeration private to the crate. This is useful to keep backwards compatibility for error types. Currently there is no shorcuts to define error constructors for the inner type, but we consider adding some in future versions.\nIt\u2019s possible to declare internal enum as public too.\n## Macros\u00a7\u27e88\u27e9\n\nquick_error\u27e89\u27e9\n    Main macro that does all the work\n## Structs\u00a7\u27e810\u27e9\n\nContext\u27e811\u27e9\n    Generic context type\n## Traits\u00a7\u27e812\u27e9\n\nResultExt\u27e813\u27e9\n    Result extension trait adding a `context` method\n",
            "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/quick-error/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/quick-error/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/quick-error/latest/src/quick_error/lib.rs.html#1-1336: Source\n\u27e84\u27e9 https://docs.rs/quick-error/latest/quick_error/#allowed-syntax: \u00a7\n\u27e85\u27e9 https://docs.rs/quick-error/latest/quick_error/#context: \u00a7\n\u27e86\u27e9 http://bit.ly/1PsuxDt: this article\n\u27e87\u27e9 https://docs.rs/quick-error/latest/quick_error/#private-enums: \u00a7\n\u27e88\u27e9 https://docs.rs/quick-error/latest/quick_error/#macros: \u00a7\n\u27e89\u27e9 https://docs.rs/quick-error/latest/quick_error/macro.quick_error.html: macro quick_error::quick_error - quick_error\n\u27e810\u27e9 https://docs.rs/quick-error/latest/quick_error/#structs: \u00a7\n\u27e811\u27e9 https://docs.rs/quick-error/latest/quick_error/struct.Context.html: struct quick_error::Context - Context\n\u27e812\u27e9 https://docs.rs/quick-error/latest/quick_error/#traits: \u00a7\n\u27e813\u27e9 https://docs.rs/quick-error/latest/quick_error/trait.ResultExt.html: trait quick_error::ResultExt - ResultExt\n",
            "fit_markdown": "",
            "fit_html": ""
          },
          "downloads": 0,
          "github_stars": 0,
          "dependencies": [],
          "features": {},
          "code_snippets": [],
          "readme_sections": {},
          "librs_downloads": null,
          "source": "crates.io",
          "enhanced_scraping": {},
          "enhanced_features": [],
          "enhanced_dependencies": []
        },
        "enriched_crate": {
          "name": "quick-error",
          "version": "2.0.1",
          "description": "ALLOW: Positive community sentiment",
          "repository": "",
          "keywords": [],
          "categories": [],
          "readme": {
            "raw_markdown": "[](https://docs.rs/quick-error/latest/quick_error/all.html \"show sidebar\")\n# Crate quick_errorCopy item path\n[Settings](https://docs.rs/quick-error/latest/settings.html)\n[Help](https://docs.rs/quick-error/latest/help.html)\nSummary[Source](https://docs.rs/quick-error/latest/src/quick_error/lib.rs.html#1-1336)\nExpand description\nA macro which makes errors easy to write\nMinimum type is like this:\n```\n#[macro_use] extern crate quick_error;\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    Variant1 {}\n  }\n}\n```\n\nBoth `pub` and non-public types may be declared, and all meta attributes (such as `#[derive(Debug)]`) are forwarded as is. The `Debug` must be implemented (but you may do that yourself if you like). The documentation comments `/// something` (as well as other meta attrbiutes) on variants are allowed.\n## [\u00a7](https://docs.rs/quick-error/latest/quick_error/#allowed-syntax)Allowed Syntax\nYou may add arbitrary parameters to any struct variant:\n```\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    /// IO Error\n    Io(err: std::io::Error) {}\n    /// Utf8 Error\n    Utf8(err: std::str::Utf8Error) {}\n  }\n}\n```\n\nNote unlike in normal Enum declarations you declare names of fields (which are omitted from type). How they can be used is outlined below.\nNow you might have noticed trailing braces `{}`. They are used to define implementations. By default:\n  * `Error::source()` returns None (even if type wraps some value)\n  * `Display` outputs debug representation\n  * No `From` implementations are defined\n\n\n```\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    Io(err: std::io::Error) {\n      display(\"{}\", err)\n    }\n    Utf8(err: std::str::Utf8Error) {\n      display(\"utf8 error\")\n    }\n  }\n}\n```\n\nTo change `source` method to return some error, add `source(value)`, for example:\n```\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    Io(err: std::io::Error) {\n      source(err)\n    }\n    Utf8(err: std::str::Utf8Error) {\n      display(\"utf8 error\")\n    }\n    Other(err: Box<std::error::Error>) {\n      source(&**err)\n    }\n  }\n}\n```\n\nNote you don\u2019t need to wrap value in `Some`, its implicit. In case you want `None` returned just omit the `source`. You can\u2019t return `None` conditionally.\nTo change how each clause is `Display`ed add `display(pattern,..args)`, for example:\n```\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    Io(err: std::io::Error) {\n      display(\"I/O error: {}\", err)\n    }\n    Utf8(err: std::str::Utf8Error) {\n      display(\"Utf8 error, valid up to {}\", err.valid_up_to())\n    }\n  }\n}\n```\n\nIf you need a reference to the error when `Display`ing, you can instead use `display(x) -> (pattern, ..args)`, where `x` sets the name of the reference.\n```\nuse std::error::Error; // put methods like `source()` of this trait into scope\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    Io(err: std::io::Error) {\n      display(x) -> (\"I/O: {}\", err)\n    }\n    Utf8(err: std::str::Utf8Error) {\n      display(self_) -> (\"UTF-8 error. Valid up to {}\", err.valid_up_to())\n    }\n  }\n}\n```\n\nTo convert to the type from any other, use one of the three forms of `from` clause.\nFor example, to convert simple wrapper use bare `from()`:\n```\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    Io(err: std::io::Error) {\n      from()\n    }\n  }\n}\n```\n\nThis implements `From<io::Error>`.\nTo convert to singleton enumeration type (discarding the value), use the `from(type)` form:\n```\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    FormatError {\n      from(std::fmt::Error)\n    }\n  }\n}\n```\n\nAnd the most powerful form is `from(var: type) -> (arguments...)`. It might be used to convert to type with multiple arguments or for arbitrary value conversions:\n```\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    FailedOperation(s: &'static str, errno: i32) {\n      from(errno: i32) -> (\"os error\", errno)\n      from(e: std::io::Error) -> (\"io error\", e.raw_os_error().unwrap())\n    }\n    /// Converts from both kinds of utf8 errors\n    Utf8(err: std::str::Utf8Error) {\n      from()\n      from(err: std::string::FromUtf8Error) -> (err.utf8_error())\n    }\n  }\n}\n```\n\n## [\u00a7](https://docs.rs/quick-error/latest/quick_error/#context)Context\nSince quick-error 1.1 we also have a `context` declaration, which is similar to (the longest form of) `from`, but allows adding some context to the error. We need a longer example to demonstrate this:\n```\nuse quick_error::ResultExt;\nquick_error! {\n  #[derive(Debug)]\n  pub enum Error {\n    File(filename: PathBuf, err: io::Error) {\n      context(path: &'a Path, err: io::Error)\n        -> (path.to_path_buf(), err)\n    }\n  }\n}\nfn openfile(path: &Path) -> Result<(), Error> {\n  File::open(path).context(path)?;\n  // If we didn't have context, the line above would be written as;\n  //\n  // File::open(path)\n  //   .map_err(|err| Error::File(path.to_path_buf(), err))?;\n  Ok(())\n}\n\n```\n\nEach `context(a: A, b: B)` clause implements `From<Context<A, B>> for Error`. Which means multiple `context` clauses are a subject to the normal coherence rules. Unfortunately, we can\u2019t provide full support of generics for the context, but you may either use a lifetime `'a` for references or `AsRef<Type>` (the latter means `A: AsRef<Type>`, and `Type` must be concrete). It\u2019s also occasionally useful to use a tuple as a type of the first argument.\nYou also need to `use quick_error::ResultExt` extension trait to get working `.context()` method.\nMore info on context in [this article](http://bit.ly/1PsuxDt).\nAll forms of `from`, `display`, `source`, and `context` clauses can be combined and put in arbitrary order. Only `from` and `context` can be used multiple times in single variant of enumeration. Docstrings are also okay. Empty braces can be omitted as of quick_error 0.1.3.\n## [\u00a7](https://docs.rs/quick-error/latest/quick_error/#private-enums)Private Enums\nSince quick-error 1.2.0 we have a way to make a private enum that is wrapped by public structure:\n```\n#[macro_use] extern crate quick_error;\nquick_error! {\n  #[derive(Debug)]\n  pub enum PubError wraps ErrorEnum {\n    Variant1 {}\n  }\n}\n```\n\nThis generates data structures like this\n```\n\npub struct PubError(ErrorEnum);\nenum ErrorEnum {\n  Variant1,\n}\n\n```\n\nWhich in turn allows you to export just `PubError` in your crate and keep actual enumeration private to the crate. This is useful to keep backwards compatibility for error types. Currently there is no shorcuts to define error constructors for the inner type, but we consider adding some in future versions.\nIt\u2019s possible to declare internal enum as public too.\n## Macros[\u00a7](https://docs.rs/quick-error/latest/quick_error/#macros)\n\n[quick_error](https://docs.rs/quick-error/latest/quick_error/macro.quick_error.html \"macro quick_error::quick_error\")\n    Main macro that does all the work\n## Structs[\u00a7](https://docs.rs/quick-error/latest/quick_error/#structs)\n\n[Context](https://docs.rs/quick-error/latest/quick_error/struct.Context.html \"struct quick_error::Context\")\n    Generic context type\n## Traits[\u00a7](https://docs.rs/quick-error/latest/quick_error/#traits)\n\n[ResultExt](https://docs.rs/quick-error/latest/quick_error/trait.ResultExt.html \"trait quick_error::ResultExt\")\n    Result extension trait adding a `context` method\n",
            "markdown_with_citations": "[](https://docs.rs/quick-error/latest/quick_error/all.html \"show sidebar\")\n# Crate quick_errorCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nA macro which makes errors easy to write\nMinimum type is like this:\n```\n#[macro_use] extern crate quick_error;\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    Variant1 {}\n  }\n}\n```\n\nBoth `pub` and non-public types may be declared, and all meta attributes (such as `#[derive(Debug)]`) are forwarded as is. The `Debug` must be implemented (but you may do that yourself if you like). The documentation comments `/// something` (as well as other meta attrbiutes) on variants are allowed.\n## \u00a7\u27e84\u27e9Allowed Syntax\nYou may add arbitrary parameters to any struct variant:\n```\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    /// IO Error\n    Io(err: std::io::Error) {}\n    /// Utf8 Error\n    Utf8(err: std::str::Utf8Error) {}\n  }\n}\n```\n\nNote unlike in normal Enum declarations you declare names of fields (which are omitted from type). How they can be used is outlined below.\nNow you might have noticed trailing braces `{}`. They are used to define implementations. By default:\n  * `Error::source()` returns None (even if type wraps some value)\n  * `Display` outputs debug representation\n  * No `From` implementations are defined\n\n\n```\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    Io(err: std::io::Error) {\n      display(\"{}\", err)\n    }\n    Utf8(err: std::str::Utf8Error) {\n      display(\"utf8 error\")\n    }\n  }\n}\n```\n\nTo change `source` method to return some error, add `source(value)`, for example:\n```\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    Io(err: std::io::Error) {\n      source(err)\n    }\n    Utf8(err: std::str::Utf8Error) {\n      display(\"utf8 error\")\n    }\n    Other(err: Box<std::error::Error>) {\n      source(&**err)\n    }\n  }\n}\n```\n\nNote you don\u2019t need to wrap value in `Some`, its implicit. In case you want `None` returned just omit the `source`. You can\u2019t return `None` conditionally.\nTo change how each clause is `Display`ed add `display(pattern,..args)`, for example:\n```\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    Io(err: std::io::Error) {\n      display(\"I/O error: {}\", err)\n    }\n    Utf8(err: std::str::Utf8Error) {\n      display(\"Utf8 error, valid up to {}\", err.valid_up_to())\n    }\n  }\n}\n```\n\nIf you need a reference to the error when `Display`ing, you can instead use `display(x) -> (pattern, ..args)`, where `x` sets the name of the reference.\n```\nuse std::error::Error; // put methods like `source()` of this trait into scope\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    Io(err: std::io::Error) {\n      display(x) -> (\"I/O: {}\", err)\n    }\n    Utf8(err: std::str::Utf8Error) {\n      display(self_) -> (\"UTF-8 error. Valid up to {}\", err.valid_up_to())\n    }\n  }\n}\n```\n\nTo convert to the type from any other, use one of the three forms of `from` clause.\nFor example, to convert simple wrapper use bare `from()`:\n```\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    Io(err: std::io::Error) {\n      from()\n    }\n  }\n}\n```\n\nThis implements `From<io::Error>`.\nTo convert to singleton enumeration type (discarding the value), use the `from(type)` form:\n```\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    FormatError {\n      from(std::fmt::Error)\n    }\n  }\n}\n```\n\nAnd the most powerful form is `from(var: type) -> (arguments...)`. It might be used to convert to type with multiple arguments or for arbitrary value conversions:\n```\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    FailedOperation(s: &'static str, errno: i32) {\n      from(errno: i32) -> (\"os error\", errno)\n      from(e: std::io::Error) -> (\"io error\", e.raw_os_error().unwrap())\n    }\n    /// Converts from both kinds of utf8 errors\n    Utf8(err: std::str::Utf8Error) {\n      from()\n      from(err: std::string::FromUtf8Error) -> (err.utf8_error())\n    }\n  }\n}\n```\n\n## \u00a7\u27e85\u27e9Context\nSince quick-error 1.1 we also have a `context` declaration, which is similar to (the longest form of) `from`, but allows adding some context to the error. We need a longer example to demonstrate this:\n```\nuse quick_error::ResultExt;\nquick_error! {\n  #[derive(Debug)]\n  pub enum Error {\n    File(filename: PathBuf, err: io::Error) {\n      context(path: &'a Path, err: io::Error)\n        -> (path.to_path_buf(), err)\n    }\n  }\n}\nfn openfile(path: &Path) -> Result<(), Error> {\n  File::open(path).context(path)?;\n  // If we didn't have context, the line above would be written as;\n  //\n  // File::open(path)\n  //   .map_err(|err| Error::File(path.to_path_buf(), err))?;\n  Ok(())\n}\n\n```\n\nEach `context(a: A, b: B)` clause implements `From<Context<A, B>> for Error`. Which means multiple `context` clauses are a subject to the normal coherence rules. Unfortunately, we can\u2019t provide full support of generics for the context, but you may either use a lifetime `'a` for references or `AsRef<Type>` (the latter means `A: AsRef<Type>`, and `Type` must be concrete). It\u2019s also occasionally useful to use a tuple as a type of the first argument.\nYou also need to `use quick_error::ResultExt` extension trait to get working `.context()` method.\nMore info on context in this article\u27e86\u27e9.\nAll forms of `from`, `display`, `source`, and `context` clauses can be combined and put in arbitrary order. Only `from` and `context` can be used multiple times in single variant of enumeration. Docstrings are also okay. Empty braces can be omitted as of quick_error 0.1.3.\n## \u00a7\u27e87\u27e9Private Enums\nSince quick-error 1.2.0 we have a way to make a private enum that is wrapped by public structure:\n```\n#[macro_use] extern crate quick_error;\nquick_error! {\n  #[derive(Debug)]\n  pub enum PubError wraps ErrorEnum {\n    Variant1 {}\n  }\n}\n```\n\nThis generates data structures like this\n```\n\npub struct PubError(ErrorEnum);\nenum ErrorEnum {\n  Variant1,\n}\n\n```\n\nWhich in turn allows you to export just `PubError` in your crate and keep actual enumeration private to the crate. This is useful to keep backwards compatibility for error types. Currently there is no shorcuts to define error constructors for the inner type, but we consider adding some in future versions.\nIt\u2019s possible to declare internal enum as public too.\n## Macros\u00a7\u27e88\u27e9\n\nquick_error\u27e89\u27e9\n    Main macro that does all the work\n## Structs\u00a7\u27e810\u27e9\n\nContext\u27e811\u27e9\n    Generic context type\n## Traits\u00a7\u27e812\u27e9\n\nResultExt\u27e813\u27e9\n    Result extension trait adding a `context` method\n",
            "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/quick-error/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/quick-error/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/quick-error/latest/src/quick_error/lib.rs.html#1-1336: Source\n\u27e84\u27e9 https://docs.rs/quick-error/latest/quick_error/#allowed-syntax: \u00a7\n\u27e85\u27e9 https://docs.rs/quick-error/latest/quick_error/#context: \u00a7\n\u27e86\u27e9 http://bit.ly/1PsuxDt: this article\n\u27e87\u27e9 https://docs.rs/quick-error/latest/quick_error/#private-enums: \u00a7\n\u27e88\u27e9 https://docs.rs/quick-error/latest/quick_error/#macros: \u00a7\n\u27e89\u27e9 https://docs.rs/quick-error/latest/quick_error/macro.quick_error.html: macro quick_error::quick_error - quick_error\n\u27e810\u27e9 https://docs.rs/quick-error/latest/quick_error/#structs: \u00a7\n\u27e811\u27e9 https://docs.rs/quick-error/latest/quick_error/struct.Context.html: struct quick_error::Context - Context\n\u27e812\u27e9 https://docs.rs/quick-error/latest/quick_error/#traits: \u00a7\n\u27e813\u27e9 https://docs.rs/quick-error/latest/quick_error/trait.ResultExt.html: trait quick_error::ResultExt - ResultExt\n",
            "fit_markdown": "",
            "fit_html": ""
          },
          "downloads": 0,
          "github_stars": 0,
          "dependencies": [],
          "features": {},
          "code_snippets": [],
          "readme_sections": {},
          "librs_downloads": null,
          "source": "crates.io",
          "enhanced_scraping": {},
          "enhanced_features": [],
          "enhanced_dependencies": [],
          "readme_summary": "The `quick-error` crate provides a powerful macro for easily defining custom error types in Rust, streamlining the implementation of traits like `Debug`, `Display`, and `Error`. It supports features such as custom `source` methods, flexible `From` conversions, and contextual error handling via the `context` method. Additionally, it allows for private enums wrapped in public structures to maintain backward compatibility.",
          "feature_summary": null,
          "use_case": "Utilities",
          "score": 6.0,
          "factual_counterfactual": "### Pair 1: Error Handling Features\n\u2705 **Factual**: The `quick-error` crate allows users to define custom error types with detailed implementations for `Display`, `source`, and `From` traits using concise macros.  \n\u274c **Counterfactual**: The `quick-error` crate automatically generates `Display` implementations for all error variants without requiring user-defined patterns or arguments.\n\n---\n\n### Pair 2: Contextual Error Conversion\n\u2705 **Factual**: Since version 1.1, `quick-error` supports the `context` declaration, enabling users to add contextual information to errors during conversion, such as associating a file path with an I/O error.  \n\u274c **Counterfactual**: The `context` feature in `quick-error` allows generic type parameters without restrictions, supporting full flexibility in error context definitions.\n\n---\n\n### Pair 3: Syntax for Field Names in Enum Variants\n\u2705 **Factual**: When defining error variants in `quick-error`, users can specify field names for struct-like variants, which are omitted from the type declaration but accessible during implementation.  \n\u274c **Counterfactual**: In `quick-error`, field names for struct-like variants are mandatory and must be explicitly included in the type declaration of the enum.",
          "source_analysis": null,
          "user_behavior": null,
          "security": null
        }
      },
      "irl_score": 8.6,
      "execution_id": "exec-8d203327-209c5772-1751259780",
      "timestamp": "2025-06-30T05:03:00.733174+00:00",
      "canon_version": "1.3.0"
    },
    "rule_zero_compliant": true
  }
]