[
  {
    "execution_id": "exec-80ce3bca-09d80d8a-1751260801",
    "timestamp": "2025-06-30T05:20:01.484578+00:00",
    "sacred_chain": {
      "input_data": "bitflags",
      "context_sources": [
        "crates.io",
        "github.com",
        "lib.rs",
        "docs.rs"
      ],
      "reasoning_steps": [
        "Input canonicalized: 'bitflags' -> 'bitflags'",
        "Context gathered from 4 validated sources",
        "Metadata extracted: 4 fields",
        "Documentation analyzed: quality 7.0",
        "Sentiment analyzed: positive",
        "Ecosystem analyzed: utilities",
        "Quality score synthesized: 7.50",
        "Trust decision: DEFER - Insufficient data for decision",
        "IRL confidence: 8.600"
      ],
      "suggestion": "ALLOW: Positive community sentiment",
      "verdict": "DEFER",
      "audit_info": {
        "metadata": {
          "name": "bitflags",
          "type": "rust_crate",
          "source": "manual_input",
          "extraction_method": "irl_engine"
        },
        "sentiment": {
          "quality_score": 7.0,
          "completeness": 0.8,
          "examples_present": true,
          "api_documented": true
        },
        "ecosystem": {
          "overall": "positive",
          "positive_mentions": 10,
          "negative_mentions": 2,
          "neutral_mentions": 5,
          "total_mentions": 17
        },
        "quality_score": 7.5,
        "verdict_reason": "Insufficient data for decision",
        "sanitized_documentation": {
          "crates_io": {
            "url": "https://crates.io/crates/bitflags",
            "title": "bitflags v2.9.1",
            "content": {
              "raw_markdown": "#  bitflags v2.9.1\nA macro to generate structures which behave like bitflags. \n  * [ #bit ](https://crates.io/keywords/bit)\n  * [ #bitflags ](https://crates.io/keywords/bitflags)\n  * [ #bitmask ](https://crates.io/keywords/bitmask)\n  * [ #flags ](https://crates.io/keywords/flags)\n\n\n  * [ Readme ](https://crates.io/crates/bitflags)\n  * [ 53 Versions ](https://crates.io/crates/bitflags/versions)\n  * [ Dependencies ](https://crates.io/crates/bitflags/dependencies)\n  * [ Dependents ](https://crates.io/crates/bitflags/reverse_dependencies)\n\n\n## Metadata\nabout 2 months ago \nv1.56.0 \n[ MIT ](https://choosealicense.com/licenses/mit) OR [ Apache-2.0 ](https://choosealicense.com/licenses/apache-2.0)\n46.8 KiB \n## Install\nRun the following Cargo command in your project directory:\ncargo add bitflags\nOr add the following line to your Cargo.toml:\nbitflags = \"2.9.1\"\n## Documentation\n[ docs.rs/bitflags ](https://docs.rs/bitflags)\n## Repository\n[ github.com/bitflags/bitflags ](https://github.com/bitflags/bitflags)\n## Owners\n## Categories\n  * [No standard library](https://crates.io/categories/no-std)\n\n\n[ Report crate ](https://crates.io/support?crate=bitflags&inquire=crate-violation)\n### Stats Overview\n687,899,636 Downloads all time\n53 Versions published\n#### Downloads over the last 90 days\nDisplay as \nStacked \n  * Stacked \n  * Unstacked \n\n\nLoading\u2026\n",
              "markdown_with_citations": "#  bitflags v2.9.1\nA macro to generate structures which behave like bitflags. \n  *  #bit \u27e81\u27e9\n  *  #bitflags \u27e82\u27e9\n  *  #bitmask \u27e83\u27e9\n  *  #flags \u27e84\u27e9\n\n\n  *  Readme \u27e85\u27e9\n  *  53 Versions \u27e86\u27e9\n  *  Dependencies \u27e87\u27e9\n  *  Dependents \u27e88\u27e9\n\n\n## Metadata\nabout 2 months ago \nv1.56.0 \n MIT \u27e89\u27e9 OR  Apache-2.0 \u27e810\u27e9\n46.8 KiB \n## Install\nRun the following Cargo command in your project directory:\ncargo add bitflags\nOr add the following line to your Cargo.toml:\nbitflags = \"2.9.1\"\n## Documentation\n docs.rs/bitflags \u27e811\u27e9\n## Repository\n github.com/bitflags/bitflags \u27e812\u27e9\n## Owners\n## Categories\n  * No standard library\u27e813\u27e9\n\n\n Report crate \u27e814\u27e9\n### Stats Overview\n687,899,636 Downloads all time\n53 Versions published\n#### Downloads over the last 90 days\nDisplay as \nStacked \n  * Stacked \n  * Unstacked \n\n\nLoading\u2026\n",
              "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://crates.io/keywords/bit:  #bit \n\u27e82\u27e9 https://crates.io/keywords/bitflags:  #bitflags \n\u27e83\u27e9 https://crates.io/keywords/bitmask:  #bitmask \n\u27e84\u27e9 https://crates.io/keywords/flags:  #flags \n\u27e85\u27e9 https://crates.io/crates/bitflags:  Readme \n\u27e86\u27e9 https://crates.io/crates/bitflags/versions:  53 Versions \n\u27e87\u27e9 https://crates.io/crates/bitflags/dependencies:  Dependencies \n\u27e88\u27e9 https://crates.io/crates/bitflags/reverse_dependencies:  Dependents \n\u27e89\u27e9 https://choosealicense.com/licenses/mit:  MIT \n\u27e810\u27e9 https://choosealicense.com/licenses/apache-2.0:  Apache-2.0 \n\u27e811\u27e9 https://docs.rs/bitflags:  docs.rs/bitflags \n\u27e812\u27e9 https://github.com/bitflags/bitflags:  github.com/bitflags/bitflags \n\u27e813\u27e9 https://crates.io/categories/no-std: No standard library\n\u27e814\u27e9 https://crates.io/support?crate=bitflags&inquire=crate-violation:  Report crate \n",
              "fit_markdown": "",
              "fit_html": ""
            },
            "structured_data": {},
            "quality_score": 3.0,
            "extraction_method": "crawl4ai",
            "error": null,
            "metadata": {
              "doc_type": "docs",
              "content_length": 1353,
              "has_structured_data": false,
              "crawl_success": true
            },
            "timestamp": "114591.2150879"
          },
          "docs_rs": {
            "url": "https://docs.rs/bitflags",
            "title": "Crate bitflagsCopy item path",
            "content": {
              "raw_markdown": "[](https://docs.rs/bitflags/latest/bitflags/all.html \"show sidebar\")\n# Crate bitflagsCopy item path\n[Settings](https://docs.rs/bitflags/latest/settings.html)\n[Help](https://docs.rs/bitflags/latest/help.html)\nSummary[Source](https://docs.rs/bitflags/latest/src/bitflags/lib.rs.html#11-1034)\nExpand description\nGenerate types for C-style flags with ergonomic APIs.\n## [\u00a7](https://docs.rs/bitflags/latest/bitflags/#getting-started)Getting started\nAdd `bitflags` to your `Cargo.toml`:\n```\n[dependencies.bitflags]\nversion = \"2.9.1\"\n```\n\n### [\u00a7](https://docs.rs/bitflags/latest/bitflags/#crate-features)Crate features\nThe `bitflags` library defines a few Cargo features that you can opt-in to:\n  * `std`: Implement the `Error` trait on error types used by `bitflags`.\n  * `serde`: Support deriving `serde` traits on generated flags types.\n  * `arbitrary`: Support deriving `arbitrary` traits on generated flags types.\n  * `bytemuck`: Support deriving `bytemuck` traits on generated flags types.\n\n\n### [\u00a7](https://docs.rs/bitflags/latest/bitflags/#generating-flags-types)Generating flags types\nUse the [`bitflags`](https://docs.rs/bitflags/latest/bitflags/macro.bitflags.html \"macro bitflags::bitflags\") macro to generate flags types:\n```\nuse bitflags::bitflags;\nbitflags! {\n  pub struct Flags: u32 {\n    const A = 0b00000001;\n    const B = 0b00000010;\n    const C = 0b00000100;\n  }\n}\n```\n\nSee the docs for the `bitflags` macro for the full syntax.\nAlso see the [`example_generated`](https://docs.rs/bitflags/latest/bitflags/example_generated/index.html) module for an example of what the `bitflags` macro generates for a flags type.\n#### [\u00a7](https://docs.rs/bitflags/latest/bitflags/#externally-defined-flags)Externally defined flags\nIf you\u2019re generating flags types for an external source, such as a C API, you can define an extra unnamed flag as a mask of all bits the external source may ever set. Usually this would be all bits (`!0`):\n```\nbitflags! {\n  pub struct Flags: u32 {\n    const A = 0b00000001;\n    const B = 0b00000010;\n    const C = 0b00000100;\n    // The source may set any bits\n    const _ = !0;\n  }\n}\n```\n\nWhy should you do this? Generated methods like `all` and truncating operators like `!` only consider bits in defined flags. Adding an unnamed flag makes those methods consider additional bits, without generating additional constants for them. It helps compatibility when the external source may start setting additional bits at any time. The [known and unknown bits](https://docs.rs/bitflags/latest/bitflags/#known-and-unknown-bits) section has more details on this behavior.\n#### [\u00a7](https://docs.rs/bitflags/latest/bitflags/#custom-derives)Custom derives\nYou can derive some traits on generated flags types if you enable Cargo features. The following libraries are currently supported:\n  * `serde`: Support `#[derive(Serialize, Deserialize)]`, using text for human-readable formats, and a raw number for binary formats.\n  * `arbitrary`: Support `#[derive(Arbitrary)]`, only generating flags values with known bits.\n  * `bytemuck`: Support `#[derive(Pod, Zeroable)]`, for casting between flags values and their underlying bits values.\n\n\nYou can also define your own flags type outside of the [`bitflags`](https://docs.rs/bitflags/latest/bitflags/macro.bitflags.html \"macro bitflags::bitflags\") macro and then use it to generate methods. This can be useful if you need a custom `#[derive]` attribute for a library that `bitflags` doesn\u2019t natively support:\n```\n#[derive(SomeTrait)]\npub struct Flags(u32);\nbitflags! {\n  impl Flags: u32 {\n    const A = 0b00000001;\n    const B = 0b00000010;\n    const C = 0b00000100;\n  }\n}\n```\n\n#### [\u00a7](https://docs.rs/bitflags/latest/bitflags/#adding-custom-methods)Adding custom methods\nThe [`bitflags`](https://docs.rs/bitflags/latest/bitflags/macro.bitflags.html \"macro bitflags::bitflags\") macro supports attributes on generated flags types within the macro itself, while `impl` blocks can be added outside of it:\n```\nbitflags! {\n  // Attributes can be applied to flags types\n  #[repr(transparent)]\n  #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n  pub struct Flags: u32 {\n    const A = 0b00000001;\n    const B = 0b00000010;\n    const C = 0b00000100;\n  }\n}\n// Impl blocks can be added to flags types\nimpl Flags {\n  pub fn as_u64(&self) -> u64 {\n    self.bits() as u64\n  }\n}\n```\n\n### [\u00a7](https://docs.rs/bitflags/latest/bitflags/#working-with-flags-values)Working with flags values\nUse generated constants and standard bitwise operators to interact with flags values:\n```\n// union\nlet ab = Flags::A | Flags::B;\n// intersection\nlet a = ab & Flags::A;\n// difference\nlet b = ab - Flags::A;\n// complement\nlet c = !ab;\n```\n\nSee the docs for the [`Flags`](https://docs.rs/bitflags/latest/bitflags/trait.Flags.html \"trait bitflags::Flags\") trait for more details on operators and how they behave.\n## [\u00a7](https://docs.rs/bitflags/latest/bitflags/#formatting-and-parsing)Formatting and parsing\n`bitflags` defines a text format that can be used to convert any flags value to and from strings.\nSee the [`parser`](https://docs.rs/bitflags/latest/bitflags/parser/index.html \"mod bitflags::parser\") module for more details.\n## [\u00a7](https://docs.rs/bitflags/latest/bitflags/#specification)Specification\nThe terminology and behavior of generated flags types is [specified in the source repository](https://github.com/bitflags/bitflags/blob/main/spec.md). Details are repeated in these docs where appropriate, but is exhaustively listed in the spec. Some things are worth calling out explicitly here.\n### [\u00a7](https://docs.rs/bitflags/latest/bitflags/#flags-types-flags-values-flags)Flags types, flags values, flags\nThe spec and these docs use consistent terminology to refer to things in the bitflags domain:\n  * **Bits type** : A type that defines a fixed number of bits at specific locations.\n  * **Flag** : A set of bits in a bits type that may have a unique name.\n  * **Flags type** : A set of defined flags over a specific bits type.\n  * **Flags value** : An instance of a flags type using its specific bits value for storage.\n\n\n```\nbitflags! {\n  struct FlagsType: u8 {\n//          -- Bits type\n//     --------- Flags type\n    const A = 1;\n//      ----- Flag\n  }\n}\nlet flag = FlagsType::A;\n// ---- Flags value\n```\n\n### [\u00a7](https://docs.rs/bitflags/latest/bitflags/#known-and-unknown-bits)Known and unknown bits\nAny bits in a flag you define are called _known bits_. Any other bits are _unknown bits_. In the following flags type:\n```\nbitflags! {\n  struct Flags: u8 {\n    const A = 1;\n    const B = 1 << 1;\n    const C = 1 << 2;\n  }\n}\n```\n\nThe known bits are `0b0000_0111` and the unknown bits are `0b1111_1000`.\n`bitflags` doesn\u2019t guarantee that a flags value will only ever have known bits set, but some operators will unset any unknown bits they encounter. In a future version of `bitflags`, all operators will unset unknown bits.\nIf you\u2019re using `bitflags` for flags types defined externally, such as from C, you probably want all bits to be considered known, in case that external source changes. You can do this using an unnamed flag, as described in [externally defined flags](https://docs.rs/bitflags/latest/bitflags/#externally-defined-flags).\n### [\u00a7](https://docs.rs/bitflags/latest/bitflags/#zero-bit-flags)Zero-bit flags\nFlags with no bits set should be avoided because they interact strangely with [`Flags::contains`](https://docs.rs/bitflags/latest/bitflags/trait.Flags.html#method.contains \"method bitflags::Flags::contains\") and [`Flags::intersects`](https://docs.rs/bitflags/latest/bitflags/trait.Flags.html#method.intersects \"method bitflags::Flags::intersects\"). A zero-bit flag is always contained, but is never intersected. The names of zero-bit flags can be parsed, but are never formatted.\n### [\u00a7](https://docs.rs/bitflags/latest/bitflags/#multi-bit-flags)Multi-bit flags\nFlags that set multiple bits should be avoided unless each bit is also in a single-bit flag. Take the following flags type as an example:\n```\nbitflags! {\n  struct Flags: u8 {\n    const A = 1;\n    const B = 1 | 1 << 1;\n  }\n}\n```\n\nThe result of `Flags::A ^ Flags::B` is `0b0000_0010`, which doesn\u2019t correspond to either `Flags::A` or `Flags::B` even though it\u2019s still a known bit.\n## Modules[\u00a7](https://docs.rs/bitflags/latest/bitflags/#modules)\n\n[example_generated](https://docs.rs/bitflags/latest/bitflags/example_generated/index.html \"mod bitflags::example_generated\")\n    This module shows an example of code generated by the macro. **IT MUST NOT BE USED OUTSIDE THIS CRATE**.\n\n[iter](https://docs.rs/bitflags/latest/bitflags/iter/index.html \"mod bitflags::iter\")\n    Yield the bits of a source flags value in a set of contained flags values.\n\n[parser](https://docs.rs/bitflags/latest/bitflags/parser/index.html \"mod bitflags::parser\")\n    Parsing flags from text.\n## Macros[\u00a7](https://docs.rs/bitflags/latest/bitflags/#macros)\n\n[bitflags](https://docs.rs/bitflags/latest/bitflags/macro.bitflags.html \"macro bitflags::bitflags\")\n    Generate a flags type.\n\n[bitflags_match](https://docs.rs/bitflags/latest/bitflags/macro.bitflags_match.html \"macro bitflags::bitflags_match\")\n    A macro that matches flags values, similar to Rust\u2019s `match` statement.\n## Structs[\u00a7](https://docs.rs/bitflags/latest/bitflags/#structs)\n\n[Flag](https://docs.rs/bitflags/latest/bitflags/struct.Flag.html \"struct bitflags::Flag\")\n    A defined flags value that may be named or unnamed.\n## Traits[\u00a7](https://docs.rs/bitflags/latest/bitflags/#traits)\n\n[Bits](https://docs.rs/bitflags/latest/bitflags/trait.Bits.html \"trait bitflags::Bits\")\n    A bits type that can be used as storage for a flags type.\n\n[Flags](https://docs.rs/bitflags/latest/bitflags/trait.Flags.html \"trait bitflags::Flags\")\n    A set of defined flags using a bits type as storage.\n",
              "markdown_with_citations": "[](https://docs.rs/bitflags/latest/bitflags/all.html \"show sidebar\")\n# Crate bitflagsCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nGenerate types for C-style flags with ergonomic APIs.\n## \u00a7\u27e84\u27e9Getting started\nAdd `bitflags` to your `Cargo.toml`:\n```\n[dependencies.bitflags]\nversion = \"2.9.1\"\n```\n\n### \u00a7\u27e85\u27e9Crate features\nThe `bitflags` library defines a few Cargo features that you can opt-in to:\n  * `std`: Implement the `Error` trait on error types used by `bitflags`.\n  * `serde`: Support deriving `serde` traits on generated flags types.\n  * `arbitrary`: Support deriving `arbitrary` traits on generated flags types.\n  * `bytemuck`: Support deriving `bytemuck` traits on generated flags types.\n\n\n### \u00a7\u27e86\u27e9Generating flags types\nUse the `bitflags`\u27e87\u27e9 macro to generate flags types:\n```\nuse bitflags::bitflags;\nbitflags! {\n  pub struct Flags: u32 {\n    const A = 0b00000001;\n    const B = 0b00000010;\n    const C = 0b00000100;\n  }\n}\n```\n\nSee the docs for the `bitflags` macro for the full syntax.\nAlso see the `example_generated`\u27e88\u27e9 module for an example of what the `bitflags` macro generates for a flags type.\n#### \u00a7\u27e89\u27e9Externally defined flags\nIf you\u2019re generating flags types for an external source, such as a C API, you can define an extra unnamed flag as a mask of all bits the external source may ever set. Usually this would be all bits (`!0`):\n```\nbitflags! {\n  pub struct Flags: u32 {\n    const A = 0b00000001;\n    const B = 0b00000010;\n    const C = 0b00000100;\n    // The source may set any bits\n    const _ = !0;\n  }\n}\n```\n\nWhy should you do this? Generated methods like `all` and truncating operators like `!` only consider bits in defined flags. Adding an unnamed flag makes those methods consider additional bits, without generating additional constants for them. It helps compatibility when the external source may start setting additional bits at any time. The known and unknown bits\u27e810\u27e9 section has more details on this behavior.\n#### \u00a7\u27e811\u27e9Custom derives\nYou can derive some traits on generated flags types if you enable Cargo features. The following libraries are currently supported:\n  * `serde`: Support `#[derive(Serialize, Deserialize)]`, using text for human-readable formats, and a raw number for binary formats.\n  * `arbitrary`: Support `#[derive(Arbitrary)]`, only generating flags values with known bits.\n  * `bytemuck`: Support `#[derive(Pod, Zeroable)]`, for casting between flags values and their underlying bits values.\n\n\nYou can also define your own flags type outside of the `bitflags`\u27e87\u27e9 macro and then use it to generate methods. This can be useful if you need a custom `#[derive]` attribute for a library that `bitflags` doesn\u2019t natively support:\n```\n#[derive(SomeTrait)]\npub struct Flags(u32);\nbitflags! {\n  impl Flags: u32 {\n    const A = 0b00000001;\n    const B = 0b00000010;\n    const C = 0b00000100;\n  }\n}\n```\n\n#### \u00a7\u27e812\u27e9Adding custom methods\nThe `bitflags`\u27e87\u27e9 macro supports attributes on generated flags types within the macro itself, while `impl` blocks can be added outside of it:\n```\nbitflags! {\n  // Attributes can be applied to flags types\n  #[repr(transparent)]\n  #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n  pub struct Flags: u32 {\n    const A = 0b00000001;\n    const B = 0b00000010;\n    const C = 0b00000100;\n  }\n}\n// Impl blocks can be added to flags types\nimpl Flags {\n  pub fn as_u64(&self) -> u64 {\n    self.bits() as u64\n  }\n}\n```\n\n### \u00a7\u27e813\u27e9Working with flags values\nUse generated constants and standard bitwise operators to interact with flags values:\n```\n// union\nlet ab = Flags::A | Flags::B;\n// intersection\nlet a = ab & Flags::A;\n// difference\nlet b = ab - Flags::A;\n// complement\nlet c = !ab;\n```\n\nSee the docs for the `Flags`\u27e814\u27e9 trait for more details on operators and how they behave.\n## \u00a7\u27e815\u27e9Formatting and parsing\n`bitflags` defines a text format that can be used to convert any flags value to and from strings.\nSee the `parser`\u27e816\u27e9 module for more details.\n## \u00a7\u27e817\u27e9Specification\nThe terminology and behavior of generated flags types is specified in the source repository\u27e818\u27e9. Details are repeated in these docs where appropriate, but is exhaustively listed in the spec. Some things are worth calling out explicitly here.\n### \u00a7\u27e819\u27e9Flags types, flags values, flags\nThe spec and these docs use consistent terminology to refer to things in the bitflags domain:\n  * **Bits type** : A type that defines a fixed number of bits at specific locations.\n  * **Flag** : A set of bits in a bits type that may have a unique name.\n  * **Flags type** : A set of defined flags over a specific bits type.\n  * **Flags value** : An instance of a flags type using its specific bits value for storage.\n\n\n```\nbitflags! {\n  struct FlagsType: u8 {\n//          -- Bits type\n//     --------- Flags type\n    const A = 1;\n//      ----- Flag\n  }\n}\nlet flag = FlagsType::A;\n// ---- Flags value\n```\n\n### \u00a7\u27e810\u27e9Known and unknown bits\nAny bits in a flag you define are called _known bits_. Any other bits are _unknown bits_. In the following flags type:\n```\nbitflags! {\n  struct Flags: u8 {\n    const A = 1;\n    const B = 1 << 1;\n    const C = 1 << 2;\n  }\n}\n```\n\nThe known bits are `0b0000_0111` and the unknown bits are `0b1111_1000`.\n`bitflags` doesn\u2019t guarantee that a flags value will only ever have known bits set, but some operators will unset any unknown bits they encounter. In a future version of `bitflags`, all operators will unset unknown bits.\nIf you\u2019re using `bitflags` for flags types defined externally, such as from C, you probably want all bits to be considered known, in case that external source changes. You can do this using an unnamed flag, as described in externally defined flags\u27e89\u27e9.\n### \u00a7\u27e820\u27e9Zero-bit flags\nFlags with no bits set should be avoided because they interact strangely with `Flags::contains`\u27e821\u27e9 and `Flags::intersects`\u27e822\u27e9. A zero-bit flag is always contained, but is never intersected. The names of zero-bit flags can be parsed, but are never formatted.\n### \u00a7\u27e823\u27e9Multi-bit flags\nFlags that set multiple bits should be avoided unless each bit is also in a single-bit flag. Take the following flags type as an example:\n```\nbitflags! {\n  struct Flags: u8 {\n    const A = 1;\n    const B = 1 | 1 << 1;\n  }\n}\n```\n\nThe result of `Flags::A ^ Flags::B` is `0b0000_0010`, which doesn\u2019t correspond to either `Flags::A` or `Flags::B` even though it\u2019s still a known bit.\n## Modules\u00a7\u27e824\u27e9\n\nexample_generated\u27e88\u27e9\n    This module shows an example of code generated by the macro. **IT MUST NOT BE USED OUTSIDE THIS CRATE**.\n\niter\u27e825\u27e9\n    Yield the bits of a source flags value in a set of contained flags values.\n\nparser\u27e816\u27e9\n    Parsing flags from text.\n## Macros\u00a7\u27e826\u27e9\n\nbitflags\u27e87\u27e9\n    Generate a flags type.\n\nbitflags_match\u27e827\u27e9\n    A macro that matches flags values, similar to Rust\u2019s `match` statement.\n## Structs\u00a7\u27e828\u27e9\n\nFlag\u27e829\u27e9\n    A defined flags value that may be named or unnamed.\n## Traits\u00a7\u27e830\u27e9\n\nBits\u27e831\u27e9\n    A bits type that can be used as storage for a flags type.\n\nFlags\u27e814\u27e9\n    A set of defined flags using a bits type as storage.\n",
              "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/bitflags/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/bitflags/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/bitflags/latest/src/bitflags/lib.rs.html#11-1034: Source\n\u27e84\u27e9 https://docs.rs/bitflags/latest/bitflags/#getting-started: \u00a7\n\u27e85\u27e9 https://docs.rs/bitflags/latest/bitflags/#crate-features: \u00a7\n\u27e86\u27e9 https://docs.rs/bitflags/latest/bitflags/#generating-flags-types: \u00a7\n\u27e87\u27e9 https://docs.rs/bitflags/latest/bitflags/macro.bitflags.html: macro bitflags::bitflags - `bitflags`\n\u27e88\u27e9 https://docs.rs/bitflags/latest/bitflags/example_generated/index.html: `example_generated`\n\u27e89\u27e9 https://docs.rs/bitflags/latest/bitflags/#externally-defined-flags: \u00a7\n\u27e810\u27e9 https://docs.rs/bitflags/latest/bitflags/#known-and-unknown-bits: known and unknown bits\n\u27e811\u27e9 https://docs.rs/bitflags/latest/bitflags/#custom-derives: \u00a7\n\u27e812\u27e9 https://docs.rs/bitflags/latest/bitflags/#adding-custom-methods: \u00a7\n\u27e813\u27e9 https://docs.rs/bitflags/latest/bitflags/#working-with-flags-values: \u00a7\n\u27e814\u27e9 https://docs.rs/bitflags/latest/bitflags/trait.Flags.html: trait bitflags::Flags - `Flags`\n\u27e815\u27e9 https://docs.rs/bitflags/latest/bitflags/#formatting-and-parsing: \u00a7\n\u27e816\u27e9 https://docs.rs/bitflags/latest/bitflags/parser/index.html: mod bitflags::parser - `parser`\n\u27e817\u27e9 https://docs.rs/bitflags/latest/bitflags/#specification: \u00a7\n\u27e818\u27e9 https://github.com/bitflags/bitflags/blob/main/spec.md: specified in the source repository\n\u27e819\u27e9 https://docs.rs/bitflags/latest/bitflags/#flags-types-flags-values-flags: \u00a7\n\u27e820\u27e9 https://docs.rs/bitflags/latest/bitflags/#zero-bit-flags: \u00a7\n\u27e821\u27e9 https://docs.rs/bitflags/latest/bitflags/trait.Flags.html#method.contains: method bitflags::Flags::contains - `Flags::contains`\n\u27e822\u27e9 https://docs.rs/bitflags/latest/bitflags/trait.Flags.html#method.intersects: method bitflags::Flags::intersects - `Flags::intersects`\n\u27e823\u27e9 https://docs.rs/bitflags/latest/bitflags/#multi-bit-flags: \u00a7\n\u27e824\u27e9 https://docs.rs/bitflags/latest/bitflags/#modules: \u00a7\n\u27e825\u27e9 https://docs.rs/bitflags/latest/bitflags/iter/index.html: mod bitflags::iter - iter\n\u27e826\u27e9 https://docs.rs/bitflags/latest/bitflags/#macros: \u00a7\n\u27e827\u27e9 https://docs.rs/bitflags/latest/bitflags/macro.bitflags_match.html: macro bitflags::bitflags_match - bitflags_match\n\u27e828\u27e9 https://docs.rs/bitflags/latest/bitflags/#structs: \u00a7\n\u27e829\u27e9 https://docs.rs/bitflags/latest/bitflags/struct.Flag.html: struct bitflags::Flag - Flag\n\u27e830\u27e9 https://docs.rs/bitflags/latest/bitflags/#traits: \u00a7\n\u27e831\u27e9 https://docs.rs/bitflags/latest/bitflags/trait.Bits.html: trait bitflags::Bits - Bits\n",
              "fit_markdown": "",
              "fit_html": ""
            },
            "structured_data": {},
            "quality_score": 4.0,
            "extraction_method": "crawl4ai",
            "error": null,
            "metadata": {
              "doc_type": "docs",
              "content_length": 9767,
              "has_structured_data": false,
              "crawl_success": true
            },
            "timestamp": "114591.8690791"
          },
          "lib_rs": {
            "url": "https://lib.rs/crates/bitflags",
            "title": "Untitled",
            "content": {
              "raw_markdown": "###  [47 releases](https://lib.rs/crates/bitflags/versions) (28 stable)\n2.9.1 |  May 15, 2025   \n---|---  \n2.9.0 |  Mar 1, 2025   \n2.8.0 |  Jan 15, 2025   \n2.6.0 |  Jun 24, 2024   \n0.1.1 |  Feb 9, 2015   \n#**1** in [Rust patterns](https://lib.rs/rust-patterns \"Shared solutions for particular situations specific to programming in Rust.\")\nDownload history 7867021/week @ 2025-03-10 8402671/week @ 2025-03-17 8367601/week @ 2025-03-24 7776957/week @ 2025-03-31 8396646/week @ 2025-04-07 7694204/week @ 2025-04-14 7339922/week @ 2025-04-21 7371509/week @ 2025-04-28 7328278/week @ 2025-05-05 7872050/week @ 2025-05-12 7964109/week @ 2025-05-19 6725594/week @ 2025-05-26 7347245/week @ 2025-06-02 8079476/week @ 2025-06-09 9029180/week @ 2025-06-16 7849707/week @ 2025-06-23\n**32,733,951** downloads per month Used in [**86,317** crates (3,331 directly)](https://lib.rs/crates/bitflags/rev)\n**MIT/Apache**\n155KB  3.5K  SLoC\n# bitflags\n[![Rust](https://img.gs/czjpqfbdkz/full/https://github.com/bitflags/bitflags/workflows/Rust/badge.svg)](https://github.com/bitflags/bitflags/actions) [![Latest version](https://img.shields.io/crates/v/bitflags.svg)](https://crates.io/crates/bitflags) [![Documentation](https://img.gs/czjpqfbdkz/full/https://docs.rs/bitflags/badge.svg)](https://docs.rs/bitflags) ![License](https://img.shields.io/crates/l/bitflags.svg)\n``bitflags`` generates flags enums with well-defined semantics and ergonomic end-user APIs.\nYou can use ``bitflags`` to:\n  * provide more user-friendly bindings to C APIs where flags may or may not be fully known in advance.\n  * generate efficient options types with string parsing and formatting support.\n\n\nYou can't use ``bitflags`` to:\n  * guarantee only bits corresponding to defined flags will ever be set. ``bitflags`` allows access to the underlying bits type so arbitrary bits may be set.\n  * define bitfields. ``bitflags`` only generates types where set bits denote the presence of some combination of flags.\n  * [Documentation](https://docs.rs/bitflags)\n  * [Specification](https://github.com/bitflags/bitflags/blob/main/spec.md)\n  * [Release notes](https://github.com/bitflags/bitflags/releases)\n\n\n## Usage\nAdd this to your ``Cargo.toml``:\n```\n```[``dependencies``]`\n`bitflags ``=` ``\"`2.9.1`\"``\n``\n```\n\nand this to your source code:\n```\n``use` `bitflags`::``bitflags`;`\n`\n```\n\n## Example\nGenerate a flags structure:\n```\n``use` `bitflags`::``bitflags`;`\n``//` The `bitflags!` macro generates `struct`s that manage a set of flags.`\n`bitflags!` ``{`\n  ``///` Represents a set of flags.`\n  ``#``[``derive```(```Debug`,` Clone`,` Copy`,` PartialEq`,` Eq`,` PartialOrd`,` Ord`,` Hash```)```]``\n  ``struct` ```Flags`: u32 ```{`\n    ``///` The value `A`, at bit position `0`.`\n    const A = 0b00000001;\n    ``///` The value `B`, at bit position `1`.`\n    const B = 0b00000010;\n    ``///` The value `C`, at bit position `2`.`\n    const C = 0b00000100;\n    ``///` The combination of `A`, `B`, and `C`.`\n    const ABC = `Self``:``:`A.bits`(``)` | ``Self`::```B.bits`(``)` | ``Self`::```C.bits`(``)`;\n  `}``\n```}``\n``fn` `main`````(````)``````{`\n  `let` e1 `=` `Flags`::``A `|` `Flags`::``C`;`\n  `let` e2 `=` `Flags`::``B `|` `Flags`::``C`;`\n  `assert_eq!``(``(`e1 `|` e2`)``,` `Flags`::```ABC``)``;`  ``//` union`\n  `assert_eq!``(``(`e1 `&` e2`)``,` `Flags`::``C`)``;`   ``//` intersection`\n  `assert_eq!``(``(`e1 `-` e2`)``,` `Flags`::``A`)``;`   ``//` set difference`\n  `assert_eq!``(``!`e2`,` `Flags`::``A`)``;`      ``//` set complement`\n```}```\n`\n```\n\n## Rust Version Support\nThe minimum supported Rust version is documented in the ``Cargo.toml`` file. This may be bumped in minor releases as necessary.\n#### Dependencies\n~0\u2013460KB \n  * [ optional ](https://lib.rs/crates/bitflags/features#feature-arbitrary \"arbitrary is optional feature\") [arbitrary](https://lib.rs/crates/arbitrary \"1.0\")\n  * [ optional ](https://lib.rs/crates/bitflags/features#feature-bytemuck \"bytemuck is optional feature\") [bytemuck](https://lib.rs/crates/bytemuck \"1.12\")\n  * [rustc-dep-of-std?](https://lib.rs/crates/bitflags/features#feature-rustc-dep-of-std \"optional feature\") [compiler_builtins](https://lib.rs/crates/compiler_builtins \"new\") 0.1.2\n  * [rustc-dep-of-std?](https://lib.rs/crates/bitflags/features#feature-rustc-dep-of-std \"optional feature\") [rustc-std-workspace-core](https://lib.rs/crates/rustc-std-workspace-core \"renamed core, 1.0.0\")\n  * [ optional ](https://lib.rs/crates/bitflags/features#feature-serde \"serde is optional feature\") [serde](https://lib.rs/crates/serde \"1.0.103\")\n\n\n  * dev  [rustversion](https://lib.rs/crates/rustversion \"1.0\")\n  * dev  [serde_derive](https://lib.rs/crates/serde_derive \"1.0.103\")\n  * dev  [serde_json](https://lib.rs/crates/serde_json \"1.0\")\n  * dev  [serde_test](https://lib.rs/crates/serde_test \"1.0.19\")\n  * dev  [trybuild](https://lib.rs/crates/trybuild \"1.0.18\")\n  * dev  [zerocopy](https://lib.rs/crates/zerocopy \"0.8\")[+derive](https://lib.rs/crates/zerocopy/features#feature-derive)\n\n\n#### [Other features](https://lib.rs/crates/bitflags/features)\n  * [example_generated](https://lib.rs/crates/bitflags/features#feature-example_generated)\n  * [std](https://lib.rs/crates/bitflags/features#feature-std)\n\n\n  *[SLoC]: Lines of code, excluding comments\n",
              "markdown_with_citations": "###  47 releases\u27e81\u27e9 (28 stable)\n2.9.1 |  May 15, 2025   \n---|---  \n2.9.0 |  Mar 1, 2025   \n2.8.0 |  Jan 15, 2025   \n2.6.0 |  Jun 24, 2024   \n0.1.1 |  Feb 9, 2015   \n#**1** in Rust patterns\u27e82\u27e9\nDownload history 7867021/week @ 2025-03-10 8402671/week @ 2025-03-17 8367601/week @ 2025-03-24 7776957/week @ 2025-03-31 8396646/week @ 2025-04-07 7694204/week @ 2025-04-14 7339922/week @ 2025-04-21 7371509/week @ 2025-04-28 7328278/week @ 2025-05-05 7872050/week @ 2025-05-12 7964109/week @ 2025-05-19 6725594/week @ 2025-05-26 7347245/week @ 2025-06-02 8079476/week @ 2025-06-09 9029180/week @ 2025-06-16 7849707/week @ 2025-06-23\n**32,733,951** downloads per month Used in **86,317** crates (3,331 directly)\u27e83\u27e9\n**MIT/Apache**\n155KB  3.5K  SLoC\n# bitflags\n![Rust\u27e84\u27e9](https://github.com/bitflags/bitflags/actions) ![Latest version\u27e85\u27e9](https://crates.io/crates/bitflags) ![Documentation\u27e86\u27e9](https://docs.rs/bitflags) ![License\u27e87\u27e9]\n``bitflags`` generates flags enums with well-defined semantics and ergonomic end-user APIs.\nYou can use ``bitflags`` to:\n  * provide more user-friendly bindings to C APIs where flags may or may not be fully known in advance.\n  * generate efficient options types with string parsing and formatting support.\n\n\nYou can't use ``bitflags`` to:\n  * guarantee only bits corresponding to defined flags will ever be set. ``bitflags`` allows access to the underlying bits type so arbitrary bits may be set.\n  * define bitfields. ``bitflags`` only generates types where set bits denote the presence of some combination of flags.\n  * Documentation\u27e88\u27e9\n  * Specification\u27e89\u27e9\n  * Release notes\u27e810\u27e9\n\n\n## Usage\nAdd this to your ``Cargo.toml``:\n```\n```[``dependencies``]`\n`bitflags ``=` ``\"`2.9.1`\"``\n``\n```\n\nand this to your source code:\n```\n``use` `bitflags`::``bitflags`;`\n`\n```\n\n## Example\nGenerate a flags structure:\n```\n``use` `bitflags`::``bitflags`;`\n``//` The `bitflags!` macro generates `struct`s that manage a set of flags.`\n`bitflags!` ``{`\n  ``///` Represents a set of flags.`\n  ``#``[``derive```(```Debug`,` Clone`,` Copy`,` PartialEq`,` Eq`,` PartialOrd`,` Ord`,` Hash```)```]``\n  ``struct` ```Flags`: u32 ```{`\n    ``///` The value `A`, at bit position `0`.`\n    const A = 0b00000001;\n    ``///` The value `B`, at bit position `1`.`\n    const B = 0b00000010;\n    ``///` The value `C`, at bit position `2`.`\n    const C = 0b00000100;\n    ``///` The combination of `A`, `B`, and `C`.`\n    const ABC = `Self``:``:`A.bits`(``)` | ``Self`::```B.bits`(``)` | ``Self`::```C.bits`(``)`;\n  `}``\n```}``\n``fn` `main`````(````)``````{`\n  `let` e1 `=` `Flags`::``A `|` `Flags`::``C`;`\n  `let` e2 `=` `Flags`::``B `|` `Flags`::``C`;`\n  `assert_eq!``(``(`e1 `|` e2`)``,` `Flags`::```ABC``)``;`  ``//` union`\n  `assert_eq!``(``(`e1 `&` e2`)``,` `Flags`::``C`)``;`   ``//` intersection`\n  `assert_eq!``(``(`e1 `-` e2`)``,` `Flags`::``A`)``;`   ``//` set difference`\n  `assert_eq!``(``!`e2`,` `Flags`::``A`)``;`      ``//` set complement`\n```}```\n`\n```\n\n## Rust Version Support\nThe minimum supported Rust version is documented in the ``Cargo.toml`` file. This may be bumped in minor releases as necessary.\n#### Dependencies\n~0\u2013460KB \n  *  optional \u27e811\u27e9 arbitrary\u27e812\u27e9\n  *  optional \u27e813\u27e9 bytemuck\u27e814\u27e9\n  * rustc-dep-of-std?\u27e815\u27e9 compiler_builtins\u27e816\u27e9 0.1.2\n  * rustc-dep-of-std?\u27e815\u27e9 rustc-std-workspace-core\u27e817\u27e9\n  *  optional \u27e818\u27e9 serde\u27e819\u27e9\n\n\n  * dev  rustversion\u27e820\u27e9\n  * dev  serde_derive\u27e821\u27e9\n  * dev  serde_json\u27e822\u27e9\n  * dev  serde_test\u27e823\u27e9\n  * dev  trybuild\u27e824\u27e9\n  * dev  zerocopy\u27e825\u27e9+derive\u27e826\u27e9\n\n\n#### Other features\u27e827\u27e9\n  * example_generated\u27e828\u27e9\n  * std\u27e829\u27e9\n\n\n  *[SLoC]: Lines of code, excluding comments\n",
              "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://lib.rs/crates/bitflags/versions: 47 releases\n\u27e82\u27e9 https://lib.rs/rust-patterns: Shared solutions for particular situations specific to programming in Rust. - Rust patterns\n\u27e83\u27e9 https://lib.rs/crates/bitflags/rev: **86,317** crates (3,331 directly)\n\u27e84\u27e9 https://img.gs/czjpqfbdkz/full/https://github.com/bitflags/bitflags/workflows/Rust/badge.svg: ![Rust\n\u27e85\u27e9 https://img.shields.io/crates/v/bitflags.svg: ![Latest version\n\u27e86\u27e9 https://img.gs/czjpqfbdkz/full/https://docs.rs/bitflags/badge.svg: ![Documentation\n\u27e87\u27e9 https://img.shields.io/crates/l/bitflags.svg: License\n\u27e88\u27e9 https://docs.rs/bitflags: Documentation\n\u27e89\u27e9 https://github.com/bitflags/bitflags/blob/main/spec.md: Specification\n\u27e810\u27e9 https://github.com/bitflags/bitflags/releases: Release notes\n\u27e811\u27e9 https://lib.rs/crates/bitflags/features#feature-arbitrary: arbitrary is optional feature -  optional \n\u27e812\u27e9 https://lib.rs/crates/arbitrary: 1.0 - arbitrary\n\u27e813\u27e9 https://lib.rs/crates/bitflags/features#feature-bytemuck: bytemuck is optional feature -  optional \n\u27e814\u27e9 https://lib.rs/crates/bytemuck: 1.12 - bytemuck\n\u27e815\u27e9 https://lib.rs/crates/bitflags/features#feature-rustc-dep-of-std: optional feature - rustc-dep-of-std?\n\u27e816\u27e9 https://lib.rs/crates/compiler_builtins: new - compiler_builtins\n\u27e817\u27e9 https://lib.rs/crates/rustc-std-workspace-core: renamed core, 1.0.0 - rustc-std-workspace-core\n\u27e818\u27e9 https://lib.rs/crates/bitflags/features#feature-serde: serde is optional feature -  optional \n\u27e819\u27e9 https://lib.rs/crates/serde: 1.0.103 - serde\n\u27e820\u27e9 https://lib.rs/crates/rustversion: 1.0 - rustversion\n\u27e821\u27e9 https://lib.rs/crates/serde_derive: 1.0.103 - serde_derive\n\u27e822\u27e9 https://lib.rs/crates/serde_json: 1.0 - serde_json\n\u27e823\u27e9 https://lib.rs/crates/serde_test: 1.0.19 - serde_test\n\u27e824\u27e9 https://lib.rs/crates/trybuild: 1.0.18 - trybuild\n\u27e825\u27e9 https://lib.rs/crates/zerocopy: 0.8 - zerocopy\n\u27e826\u27e9 https://lib.rs/crates/zerocopy/features#feature-derive: +derive\n\u27e827\u27e9 https://lib.rs/crates/bitflags/features: Other features\n\u27e828\u27e9 https://lib.rs/crates/bitflags/features#feature-example_generated: example_generated\n\u27e829\u27e9 https://lib.rs/crates/bitflags/features#feature-std: std\n",
              "fit_markdown": "",
              "fit_html": ""
            },
            "structured_data": {},
            "quality_score": 3.0,
            "extraction_method": "crawl4ai",
            "error": null,
            "metadata": {
              "doc_type": "docs",
              "content_length": 5253,
              "has_structured_data": false,
              "crawl_success": true
            },
            "timestamp": "114592.561739"
          }
        },
        "crate_analysis": {
          "status": "completed",
          "check": [
            {
              "reason": "compiler-artifact",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpx2ao429o/bitflags-2.9.1#bitflags@2.9.1",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpx2ao429o\\bitflags-2.9.1\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "bitflags",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpx2ao429o\\bitflags-2.9.1\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpx2ao429o\\bitflags-2.9.1\\target\\debug\\deps\\libbitflags-1b6442aae3520366.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "build-finished",
              "success": true
            }
          ],
          "clippy": [
            {
              "reason": "compiler-artifact",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpx2ao429o/bitflags-2.9.1#bitflags@2.9.1",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpx2ao429o\\bitflags-2.9.1\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "bitflags",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpx2ao429o\\bitflags-2.9.1\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpx2ao429o\\bitflags-2.9.1\\target\\debug\\deps\\libbitflags-fc3ed0ca2d5fc391.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "build-finished",
              "success": true
            }
          ],
          "audit": {
            "database": {
              "advisory-count": 787,
              "last-commit": "7573f55ba337263f61167dbb0ea926cdc7c8eb5d",
              "last-updated": "2025-06-17T11:04:25+02:00"
            },
            "lockfile": {
              "dependency-count": 45
            },
            "settings": {
              "target_arch": [],
              "target_os": [],
              "severity": null,
              "ignore": [],
              "informational_warnings": [
                "unmaintained",
                "unsound",
                "notice"
              ]
            },
            "vulnerabilities": {
              "found": false,
              "count": 0,
              "list": []
            },
            "warnings": {}
          },
          "note": "Crate analysis performed with stable toolchain."
        },
        "crate_metadata": {
          "name": "bitflags",
          "version": "2.9.1",
          "description": "ALLOW: Positive community sentiment",
          "repository": "",
          "keywords": [],
          "categories": [],
          "readme": {
            "raw_markdown": "[](https://docs.rs/bitflags/latest/bitflags/all.html \"show sidebar\")\n# Crate bitflagsCopy item path\n[Settings](https://docs.rs/bitflags/latest/settings.html)\n[Help](https://docs.rs/bitflags/latest/help.html)\nSummary[Source](https://docs.rs/bitflags/latest/src/bitflags/lib.rs.html#11-1034)\nExpand description\nGenerate types for C-style flags with ergonomic APIs.\n## [\u00a7](https://docs.rs/bitflags/latest/bitflags/#getting-started)Getting started\nAdd `bitflags` to your `Cargo.toml`:\n```\n[dependencies.bitflags]\nversion = \"2.9.1\"\n```\n\n### [\u00a7](https://docs.rs/bitflags/latest/bitflags/#crate-features)Crate features\nThe `bitflags` library defines a few Cargo features that you can opt-in to:\n  * `std`: Implement the `Error` trait on error types used by `bitflags`.\n  * `serde`: Support deriving `serde` traits on generated flags types.\n  * `arbitrary`: Support deriving `arbitrary` traits on generated flags types.\n  * `bytemuck`: Support deriving `bytemuck` traits on generated flags types.\n\n\n### [\u00a7](https://docs.rs/bitflags/latest/bitflags/#generating-flags-types)Generating flags types\nUse the [`bitflags`](https://docs.rs/bitflags/latest/bitflags/macro.bitflags.html \"macro bitflags::bitflags\") macro to generate flags types:\n```\nuse bitflags::bitflags;\nbitflags! {\n  pub struct Flags: u32 {\n    const A = 0b00000001;\n    const B = 0b00000010;\n    const C = 0b00000100;\n  }\n}\n```\n\nSee the docs for the `bitflags` macro for the full syntax.\nAlso see the [`example_generated`](https://docs.rs/bitflags/latest/bitflags/example_generated/index.html) module for an example of what the `bitflags` macro generates for a flags type.\n#### [\u00a7](https://docs.rs/bitflags/latest/bitflags/#externally-defined-flags)Externally defined flags\nIf you\u2019re generating flags types for an external source, such as a C API, you can define an extra unnamed flag as a mask of all bits the external source may ever set. Usually this would be all bits (`!0`):\n```\nbitflags! {\n  pub struct Flags: u32 {\n    const A = 0b00000001;\n    const B = 0b00000010;\n    const C = 0b00000100;\n    // The source may set any bits\n    const _ = !0;\n  }\n}\n```\n\nWhy should you do this? Generated methods like `all` and truncating operators like `!` only consider bits in defined flags. Adding an unnamed flag makes those methods consider additional bits, without generating additional constants for them. It helps compatibility when the external source may start setting additional bits at any time. The [known and unknown bits](https://docs.rs/bitflags/latest/bitflags/#known-and-unknown-bits) section has more details on this behavior.\n#### [\u00a7](https://docs.rs/bitflags/latest/bitflags/#custom-derives)Custom derives\nYou can derive some traits on generated flags types if you enable Cargo features. The following libraries are currently supported:\n  * `serde`: Support `#[derive(Serialize, Deserialize)]`, using text for human-readable formats, and a raw number for binary formats.\n  * `arbitrary`: Support `#[derive(Arbitrary)]`, only generating flags values with known bits.\n  * `bytemuck`: Support `#[derive(Pod, Zeroable)]`, for casting between flags values and their underlying bits values.\n\n\nYou can also define your own flags type outside of the [`bitflags`](https://docs.rs/bitflags/latest/bitflags/macro.bitflags.html \"macro bitflags::bitflags\") macro and then use it to generate methods. This can be useful if you need a custom `#[derive]` attribute for a library that `bitflags` doesn\u2019t natively support:\n```\n#[derive(SomeTrait)]\npub struct Flags(u32);\nbitflags! {\n  impl Flags: u32 {\n    const A = 0b00000001;\n    const B = 0b00000010;\n    const C = 0b00000100;\n  }\n}\n```\n\n#### [\u00a7](https://docs.rs/bitflags/latest/bitflags/#adding-custom-methods)Adding custom methods\nThe [`bitflags`](https://docs.rs/bitflags/latest/bitflags/macro.bitflags.html \"macro bitflags::bitflags\") macro supports attributes on generated flags types within the macro itself, while `impl` blocks can be added outside of it:\n```\nbitflags! {\n  // Attributes can be applied to flags types\n  #[repr(transparent)]\n  #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n  pub struct Flags: u32 {\n    const A = 0b00000001;\n    const B = 0b00000010;\n    const C = 0b00000100;\n  }\n}\n// Impl blocks can be added to flags types\nimpl Flags {\n  pub fn as_u64(&self) -> u64 {\n    self.bits() as u64\n  }\n}\n```\n\n### [\u00a7](https://docs.rs/bitflags/latest/bitflags/#working-with-flags-values)Working with flags values\nUse generated constants and standard bitwise operators to interact with flags values:\n```\n// union\nlet ab = Flags::A | Flags::B;\n// intersection\nlet a = ab & Flags::A;\n// difference\nlet b = ab - Flags::A;\n// complement\nlet c = !ab;\n```\n\nSee the docs for the [`Flags`](https://docs.rs/bitflags/latest/bitflags/trait.Flags.html \"trait bitflags::Flags\") trait for more details on operators and how they behave.\n## [\u00a7](https://docs.rs/bitflags/latest/bitflags/#formatting-and-parsing)Formatting and parsing\n`bitflags` defines a text format that can be used to convert any flags value to and from strings.\nSee the [`parser`](https://docs.rs/bitflags/latest/bitflags/parser/index.html \"mod bitflags::parser\") module for more details.\n## [\u00a7](https://docs.rs/bitflags/latest/bitflags/#specification)Specification\nThe terminology and behavior of generated flags types is [specified in the source repository](https://github.com/bitflags/bitflags/blob/main/spec.md). Details are repeated in these docs where appropriate, but is exhaustively listed in the spec. Some things are worth calling out explicitly here.\n### [\u00a7](https://docs.rs/bitflags/latest/bitflags/#flags-types-flags-values-flags)Flags types, flags values, flags\nThe spec and these docs use consistent terminology to refer to things in the bitflags domain:\n  * **Bits type** : A type that defines a fixed number of bits at specific locations.\n  * **Flag** : A set of bits in a bits type that may have a unique name.\n  * **Flags type** : A set of defined flags over a specific bits type.\n  * **Flags value** : An instance of a flags type using its specific bits value for storage.\n\n\n```\nbitflags! {\n  struct FlagsType: u8 {\n//          -- Bits type\n//     --------- Flags type\n    const A = 1;\n//      ----- Flag\n  }\n}\nlet flag = FlagsType::A;\n// ---- Flags value\n```\n\n### [\u00a7](https://docs.rs/bitflags/latest/bitflags/#known-and-unknown-bits)Known and unknown bits\nAny bits in a flag you define are called _known bits_. Any other bits are _unknown bits_. In the following flags type:\n```\nbitflags! {\n  struct Flags: u8 {\n    const A = 1;\n    const B = 1 << 1;\n    const C = 1 << 2;\n  }\n}\n```\n\nThe known bits are `0b0000_0111` and the unknown bits are `0b1111_1000`.\n`bitflags` doesn\u2019t guarantee that a flags value will only ever have known bits set, but some operators will unset any unknown bits they encounter. In a future version of `bitflags`, all operators will unset unknown bits.\nIf you\u2019re using `bitflags` for flags types defined externally, such as from C, you probably want all bits to be considered known, in case that external source changes. You can do this using an unnamed flag, as described in [externally defined flags](https://docs.rs/bitflags/latest/bitflags/#externally-defined-flags).\n### [\u00a7](https://docs.rs/bitflags/latest/bitflags/#zero-bit-flags)Zero-bit flags\nFlags with no bits set should be avoided because they interact strangely with [`Flags::contains`](https://docs.rs/bitflags/latest/bitflags/trait.Flags.html#method.contains \"method bitflags::Flags::contains\") and [`Flags::intersects`](https://docs.rs/bitflags/latest/bitflags/trait.Flags.html#method.intersects \"method bitflags::Flags::intersects\"). A zero-bit flag is always contained, but is never intersected. The names of zero-bit flags can be parsed, but are never formatted.\n### [\u00a7](https://docs.rs/bitflags/latest/bitflags/#multi-bit-flags)Multi-bit flags\nFlags that set multiple bits should be avoided unless each bit is also in a single-bit flag. Take the following flags type as an example:\n```\nbitflags! {\n  struct Flags: u8 {\n    const A = 1;\n    const B = 1 | 1 << 1;\n  }\n}\n```\n\nThe result of `Flags::A ^ Flags::B` is `0b0000_0010`, which doesn\u2019t correspond to either `Flags::A` or `Flags::B` even though it\u2019s still a known bit.\n## Modules[\u00a7](https://docs.rs/bitflags/latest/bitflags/#modules)\n\n[example_generated](https://docs.rs/bitflags/latest/bitflags/example_generated/index.html \"mod bitflags::example_generated\")\n    This module shows an example of code generated by the macro. **IT MUST NOT BE USED OUTSIDE THIS CRATE**.\n\n[iter](https://docs.rs/bitflags/latest/bitflags/iter/index.html \"mod bitflags::iter\")\n    Yield the bits of a source flags value in a set of contained flags values.\n\n[parser](https://docs.rs/bitflags/latest/bitflags/parser/index.html \"mod bitflags::parser\")\n    Parsing flags from text.\n## Macros[\u00a7](https://docs.rs/bitflags/latest/bitflags/#macros)\n\n[bitflags](https://docs.rs/bitflags/latest/bitflags/macro.bitflags.html \"macro bitflags::bitflags\")\n    Generate a flags type.\n\n[bitflags_match](https://docs.rs/bitflags/latest/bitflags/macro.bitflags_match.html \"macro bitflags::bitflags_match\")\n    A macro that matches flags values, similar to Rust\u2019s `match` statement.\n## Structs[\u00a7](https://docs.rs/bitflags/latest/bitflags/#structs)\n\n[Flag](https://docs.rs/bitflags/latest/bitflags/struct.Flag.html \"struct bitflags::Flag\")\n    A defined flags value that may be named or unnamed.\n## Traits[\u00a7](https://docs.rs/bitflags/latest/bitflags/#traits)\n\n[Bits](https://docs.rs/bitflags/latest/bitflags/trait.Bits.html \"trait bitflags::Bits\")\n    A bits type that can be used as storage for a flags type.\n\n[Flags](https://docs.rs/bitflags/latest/bitflags/trait.Flags.html \"trait bitflags::Flags\")\n    A set of defined flags using a bits type as storage.\n",
            "markdown_with_citations": "[](https://docs.rs/bitflags/latest/bitflags/all.html \"show sidebar\")\n# Crate bitflagsCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nGenerate types for C-style flags with ergonomic APIs.\n## \u00a7\u27e84\u27e9Getting started\nAdd `bitflags` to your `Cargo.toml`:\n```\n[dependencies.bitflags]\nversion = \"2.9.1\"\n```\n\n### \u00a7\u27e85\u27e9Crate features\nThe `bitflags` library defines a few Cargo features that you can opt-in to:\n  * `std`: Implement the `Error` trait on error types used by `bitflags`.\n  * `serde`: Support deriving `serde` traits on generated flags types.\n  * `arbitrary`: Support deriving `arbitrary` traits on generated flags types.\n  * `bytemuck`: Support deriving `bytemuck` traits on generated flags types.\n\n\n### \u00a7\u27e86\u27e9Generating flags types\nUse the `bitflags`\u27e87\u27e9 macro to generate flags types:\n```\nuse bitflags::bitflags;\nbitflags! {\n  pub struct Flags: u32 {\n    const A = 0b00000001;\n    const B = 0b00000010;\n    const C = 0b00000100;\n  }\n}\n```\n\nSee the docs for the `bitflags` macro for the full syntax.\nAlso see the `example_generated`\u27e88\u27e9 module for an example of what the `bitflags` macro generates for a flags type.\n#### \u00a7\u27e89\u27e9Externally defined flags\nIf you\u2019re generating flags types for an external source, such as a C API, you can define an extra unnamed flag as a mask of all bits the external source may ever set. Usually this would be all bits (`!0`):\n```\nbitflags! {\n  pub struct Flags: u32 {\n    const A = 0b00000001;\n    const B = 0b00000010;\n    const C = 0b00000100;\n    // The source may set any bits\n    const _ = !0;\n  }\n}\n```\n\nWhy should you do this? Generated methods like `all` and truncating operators like `!` only consider bits in defined flags. Adding an unnamed flag makes those methods consider additional bits, without generating additional constants for them. It helps compatibility when the external source may start setting additional bits at any time. The known and unknown bits\u27e810\u27e9 section has more details on this behavior.\n#### \u00a7\u27e811\u27e9Custom derives\nYou can derive some traits on generated flags types if you enable Cargo features. The following libraries are currently supported:\n  * `serde`: Support `#[derive(Serialize, Deserialize)]`, using text for human-readable formats, and a raw number for binary formats.\n  * `arbitrary`: Support `#[derive(Arbitrary)]`, only generating flags values with known bits.\n  * `bytemuck`: Support `#[derive(Pod, Zeroable)]`, for casting between flags values and their underlying bits values.\n\n\nYou can also define your own flags type outside of the `bitflags`\u27e87\u27e9 macro and then use it to generate methods. This can be useful if you need a custom `#[derive]` attribute for a library that `bitflags` doesn\u2019t natively support:\n```\n#[derive(SomeTrait)]\npub struct Flags(u32);\nbitflags! {\n  impl Flags: u32 {\n    const A = 0b00000001;\n    const B = 0b00000010;\n    const C = 0b00000100;\n  }\n}\n```\n\n#### \u00a7\u27e812\u27e9Adding custom methods\nThe `bitflags`\u27e87\u27e9 macro supports attributes on generated flags types within the macro itself, while `impl` blocks can be added outside of it:\n```\nbitflags! {\n  // Attributes can be applied to flags types\n  #[repr(transparent)]\n  #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n  pub struct Flags: u32 {\n    const A = 0b00000001;\n    const B = 0b00000010;\n    const C = 0b00000100;\n  }\n}\n// Impl blocks can be added to flags types\nimpl Flags {\n  pub fn as_u64(&self) -> u64 {\n    self.bits() as u64\n  }\n}\n```\n\n### \u00a7\u27e813\u27e9Working with flags values\nUse generated constants and standard bitwise operators to interact with flags values:\n```\n// union\nlet ab = Flags::A | Flags::B;\n// intersection\nlet a = ab & Flags::A;\n// difference\nlet b = ab - Flags::A;\n// complement\nlet c = !ab;\n```\n\nSee the docs for the `Flags`\u27e814\u27e9 trait for more details on operators and how they behave.\n## \u00a7\u27e815\u27e9Formatting and parsing\n`bitflags` defines a text format that can be used to convert any flags value to and from strings.\nSee the `parser`\u27e816\u27e9 module for more details.\n## \u00a7\u27e817\u27e9Specification\nThe terminology and behavior of generated flags types is specified in the source repository\u27e818\u27e9. Details are repeated in these docs where appropriate, but is exhaustively listed in the spec. Some things are worth calling out explicitly here.\n### \u00a7\u27e819\u27e9Flags types, flags values, flags\nThe spec and these docs use consistent terminology to refer to things in the bitflags domain:\n  * **Bits type** : A type that defines a fixed number of bits at specific locations.\n  * **Flag** : A set of bits in a bits type that may have a unique name.\n  * **Flags type** : A set of defined flags over a specific bits type.\n  * **Flags value** : An instance of a flags type using its specific bits value for storage.\n\n\n```\nbitflags! {\n  struct FlagsType: u8 {\n//          -- Bits type\n//     --------- Flags type\n    const A = 1;\n//      ----- Flag\n  }\n}\nlet flag = FlagsType::A;\n// ---- Flags value\n```\n\n### \u00a7\u27e810\u27e9Known and unknown bits\nAny bits in a flag you define are called _known bits_. Any other bits are _unknown bits_. In the following flags type:\n```\nbitflags! {\n  struct Flags: u8 {\n    const A = 1;\n    const B = 1 << 1;\n    const C = 1 << 2;\n  }\n}\n```\n\nThe known bits are `0b0000_0111` and the unknown bits are `0b1111_1000`.\n`bitflags` doesn\u2019t guarantee that a flags value will only ever have known bits set, but some operators will unset any unknown bits they encounter. In a future version of `bitflags`, all operators will unset unknown bits.\nIf you\u2019re using `bitflags` for flags types defined externally, such as from C, you probably want all bits to be considered known, in case that external source changes. You can do this using an unnamed flag, as described in externally defined flags\u27e89\u27e9.\n### \u00a7\u27e820\u27e9Zero-bit flags\nFlags with no bits set should be avoided because they interact strangely with `Flags::contains`\u27e821\u27e9 and `Flags::intersects`\u27e822\u27e9. A zero-bit flag is always contained, but is never intersected. The names of zero-bit flags can be parsed, but are never formatted.\n### \u00a7\u27e823\u27e9Multi-bit flags\nFlags that set multiple bits should be avoided unless each bit is also in a single-bit flag. Take the following flags type as an example:\n```\nbitflags! {\n  struct Flags: u8 {\n    const A = 1;\n    const B = 1 | 1 << 1;\n  }\n}\n```\n\nThe result of `Flags::A ^ Flags::B` is `0b0000_0010`, which doesn\u2019t correspond to either `Flags::A` or `Flags::B` even though it\u2019s still a known bit.\n## Modules\u00a7\u27e824\u27e9\n\nexample_generated\u27e88\u27e9\n    This module shows an example of code generated by the macro. **IT MUST NOT BE USED OUTSIDE THIS CRATE**.\n\niter\u27e825\u27e9\n    Yield the bits of a source flags value in a set of contained flags values.\n\nparser\u27e816\u27e9\n    Parsing flags from text.\n## Macros\u00a7\u27e826\u27e9\n\nbitflags\u27e87\u27e9\n    Generate a flags type.\n\nbitflags_match\u27e827\u27e9\n    A macro that matches flags values, similar to Rust\u2019s `match` statement.\n## Structs\u00a7\u27e828\u27e9\n\nFlag\u27e829\u27e9\n    A defined flags value that may be named or unnamed.\n## Traits\u00a7\u27e830\u27e9\n\nBits\u27e831\u27e9\n    A bits type that can be used as storage for a flags type.\n\nFlags\u27e814\u27e9\n    A set of defined flags using a bits type as storage.\n",
            "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/bitflags/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/bitflags/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/bitflags/latest/src/bitflags/lib.rs.html#11-1034: Source\n\u27e84\u27e9 https://docs.rs/bitflags/latest/bitflags/#getting-started: \u00a7\n\u27e85\u27e9 https://docs.rs/bitflags/latest/bitflags/#crate-features: \u00a7\n\u27e86\u27e9 https://docs.rs/bitflags/latest/bitflags/#generating-flags-types: \u00a7\n\u27e87\u27e9 https://docs.rs/bitflags/latest/bitflags/macro.bitflags.html: macro bitflags::bitflags - `bitflags`\n\u27e88\u27e9 https://docs.rs/bitflags/latest/bitflags/example_generated/index.html: `example_generated`\n\u27e89\u27e9 https://docs.rs/bitflags/latest/bitflags/#externally-defined-flags: \u00a7\n\u27e810\u27e9 https://docs.rs/bitflags/latest/bitflags/#known-and-unknown-bits: known and unknown bits\n\u27e811\u27e9 https://docs.rs/bitflags/latest/bitflags/#custom-derives: \u00a7\n\u27e812\u27e9 https://docs.rs/bitflags/latest/bitflags/#adding-custom-methods: \u00a7\n\u27e813\u27e9 https://docs.rs/bitflags/latest/bitflags/#working-with-flags-values: \u00a7\n\u27e814\u27e9 https://docs.rs/bitflags/latest/bitflags/trait.Flags.html: trait bitflags::Flags - `Flags`\n\u27e815\u27e9 https://docs.rs/bitflags/latest/bitflags/#formatting-and-parsing: \u00a7\n\u27e816\u27e9 https://docs.rs/bitflags/latest/bitflags/parser/index.html: mod bitflags::parser - `parser`\n\u27e817\u27e9 https://docs.rs/bitflags/latest/bitflags/#specification: \u00a7\n\u27e818\u27e9 https://github.com/bitflags/bitflags/blob/main/spec.md: specified in the source repository\n\u27e819\u27e9 https://docs.rs/bitflags/latest/bitflags/#flags-types-flags-values-flags: \u00a7\n\u27e820\u27e9 https://docs.rs/bitflags/latest/bitflags/#zero-bit-flags: \u00a7\n\u27e821\u27e9 https://docs.rs/bitflags/latest/bitflags/trait.Flags.html#method.contains: method bitflags::Flags::contains - `Flags::contains`\n\u27e822\u27e9 https://docs.rs/bitflags/latest/bitflags/trait.Flags.html#method.intersects: method bitflags::Flags::intersects - `Flags::intersects`\n\u27e823\u27e9 https://docs.rs/bitflags/latest/bitflags/#multi-bit-flags: \u00a7\n\u27e824\u27e9 https://docs.rs/bitflags/latest/bitflags/#modules: \u00a7\n\u27e825\u27e9 https://docs.rs/bitflags/latest/bitflags/iter/index.html: mod bitflags::iter - iter\n\u27e826\u27e9 https://docs.rs/bitflags/latest/bitflags/#macros: \u00a7\n\u27e827\u27e9 https://docs.rs/bitflags/latest/bitflags/macro.bitflags_match.html: macro bitflags::bitflags_match - bitflags_match\n\u27e828\u27e9 https://docs.rs/bitflags/latest/bitflags/#structs: \u00a7\n\u27e829\u27e9 https://docs.rs/bitflags/latest/bitflags/struct.Flag.html: struct bitflags::Flag - Flag\n\u27e830\u27e9 https://docs.rs/bitflags/latest/bitflags/#traits: \u00a7\n\u27e831\u27e9 https://docs.rs/bitflags/latest/bitflags/trait.Bits.html: trait bitflags::Bits - Bits\n",
            "fit_markdown": "",
            "fit_html": ""
          },
          "downloads": 0,
          "github_stars": 0,
          "dependencies": [],
          "features": {},
          "code_snippets": [],
          "readme_sections": {},
          "librs_downloads": null,
          "source": "crates.io",
          "enhanced_scraping": {},
          "enhanced_features": [],
          "enhanced_dependencies": []
        },
        "enriched_crate": {
          "name": "bitflags",
          "version": "2.9.1",
          "description": "ALLOW: Positive community sentiment",
          "repository": "",
          "keywords": [],
          "categories": [],
          "readme": {
            "raw_markdown": "[](https://docs.rs/bitflags/latest/bitflags/all.html \"show sidebar\")\n# Crate bitflagsCopy item path\n[Settings](https://docs.rs/bitflags/latest/settings.html)\n[Help](https://docs.rs/bitflags/latest/help.html)\nSummary[Source](https://docs.rs/bitflags/latest/src/bitflags/lib.rs.html#11-1034)\nExpand description\nGenerate types for C-style flags with ergonomic APIs.\n## [\u00a7](https://docs.rs/bitflags/latest/bitflags/#getting-started)Getting started\nAdd `bitflags` to your `Cargo.toml`:\n```\n[dependencies.bitflags]\nversion = \"2.9.1\"\n```\n\n### [\u00a7](https://docs.rs/bitflags/latest/bitflags/#crate-features)Crate features\nThe `bitflags` library defines a few Cargo features that you can opt-in to:\n  * `std`: Implement the `Error` trait on error types used by `bitflags`.\n  * `serde`: Support deriving `serde` traits on generated flags types.\n  * `arbitrary`: Support deriving `arbitrary` traits on generated flags types.\n  * `bytemuck`: Support deriving `bytemuck` traits on generated flags types.\n\n\n### [\u00a7](https://docs.rs/bitflags/latest/bitflags/#generating-flags-types)Generating flags types\nUse the [`bitflags`](https://docs.rs/bitflags/latest/bitflags/macro.bitflags.html \"macro bitflags::bitflags\") macro to generate flags types:\n```\nuse bitflags::bitflags;\nbitflags! {\n  pub struct Flags: u32 {\n    const A = 0b00000001;\n    const B = 0b00000010;\n    const C = 0b00000100;\n  }\n}\n```\n\nSee the docs for the `bitflags` macro for the full syntax.\nAlso see the [`example_generated`](https://docs.rs/bitflags/latest/bitflags/example_generated/index.html) module for an example of what the `bitflags` macro generates for a flags type.\n#### [\u00a7](https://docs.rs/bitflags/latest/bitflags/#externally-defined-flags)Externally defined flags\nIf you\u2019re generating flags types for an external source, such as a C API, you can define an extra unnamed flag as a mask of all bits the external source may ever set. Usually this would be all bits (`!0`):\n```\nbitflags! {\n  pub struct Flags: u32 {\n    const A = 0b00000001;\n    const B = 0b00000010;\n    const C = 0b00000100;\n    // The source may set any bits\n    const _ = !0;\n  }\n}\n```\n\nWhy should you do this? Generated methods like `all` and truncating operators like `!` only consider bits in defined flags. Adding an unnamed flag makes those methods consider additional bits, without generating additional constants for them. It helps compatibility when the external source may start setting additional bits at any time. The [known and unknown bits](https://docs.rs/bitflags/latest/bitflags/#known-and-unknown-bits) section has more details on this behavior.\n#### [\u00a7](https://docs.rs/bitflags/latest/bitflags/#custom-derives)Custom derives\nYou can derive some traits on generated flags types if you enable Cargo features. The following libraries are currently supported:\n  * `serde`: Support `#[derive(Serialize, Deserialize)]`, using text for human-readable formats, and a raw number for binary formats.\n  * `arbitrary`: Support `#[derive(Arbitrary)]`, only generating flags values with known bits.\n  * `bytemuck`: Support `#[derive(Pod, Zeroable)]`, for casting between flags values and their underlying bits values.\n\n\nYou can also define your own flags type outside of the [`bitflags`](https://docs.rs/bitflags/latest/bitflags/macro.bitflags.html \"macro bitflags::bitflags\") macro and then use it to generate methods. This can be useful if you need a custom `#[derive]` attribute for a library that `bitflags` doesn\u2019t natively support:\n```\n#[derive(SomeTrait)]\npub struct Flags(u32);\nbitflags! {\n  impl Flags: u32 {\n    const A = 0b00000001;\n    const B = 0b00000010;\n    const C = 0b00000100;\n  }\n}\n```\n\n#### [\u00a7](https://docs.rs/bitflags/latest/bitflags/#adding-custom-methods)Adding custom methods\nThe [`bitflags`](https://docs.rs/bitflags/latest/bitflags/macro.bitflags.html \"macro bitflags::bitflags\") macro supports attributes on generated flags types within the macro itself, while `impl` blocks can be added outside of it:\n```\nbitflags! {\n  // Attributes can be applied to flags types\n  #[repr(transparent)]\n  #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n  pub struct Flags: u32 {\n    const A = 0b00000001;\n    const B = 0b00000010;\n    const C = 0b00000100;\n  }\n}\n// Impl blocks can be added to flags types\nimpl Flags {\n  pub fn as_u64(&self) -> u64 {\n    self.bits() as u64\n  }\n}\n```\n\n### [\u00a7](https://docs.rs/bitflags/latest/bitflags/#working-with-flags-values)Working with flags values\nUse generated constants and standard bitwise operators to interact with flags values:\n```\n// union\nlet ab = Flags::A | Flags::B;\n// intersection\nlet a = ab & Flags::A;\n// difference\nlet b = ab - Flags::A;\n// complement\nlet c = !ab;\n```\n\nSee the docs for the [`Flags`](https://docs.rs/bitflags/latest/bitflags/trait.Flags.html \"trait bitflags::Flags\") trait for more details on operators and how they behave.\n## [\u00a7](https://docs.rs/bitflags/latest/bitflags/#formatting-and-parsing)Formatting and parsing\n`bitflags` defines a text format that can be used to convert any flags value to and from strings.\nSee the [`parser`](https://docs.rs/bitflags/latest/bitflags/parser/index.html \"mod bitflags::parser\") module for more details.\n## [\u00a7](https://docs.rs/bitflags/latest/bitflags/#specification)Specification\nThe terminology and behavior of generated flags types is [specified in the source repository](https://github.com/bitflags/bitflags/blob/main/spec.md). Details are repeated in these docs where appropriate, but is exhaustively listed in the spec. Some things are worth calling out explicitly here.\n### [\u00a7](https://docs.rs/bitflags/latest/bitflags/#flags-types-flags-values-flags)Flags types, flags values, flags\nThe spec and these docs use consistent terminology to refer to things in the bitflags domain:\n  * **Bits type** : A type that defines a fixed number of bits at specific locations.\n  * **Flag** : A set of bits in a bits type that may have a unique name.\n  * **Flags type** : A set of defined flags over a specific bits type.\n  * **Flags value** : An instance of a flags type using its specific bits value for storage.\n\n\n```\nbitflags! {\n  struct FlagsType: u8 {\n//          -- Bits type\n//     --------- Flags type\n    const A = 1;\n//      ----- Flag\n  }\n}\nlet flag = FlagsType::A;\n// ---- Flags value\n```\n\n### [\u00a7](https://docs.rs/bitflags/latest/bitflags/#known-and-unknown-bits)Known and unknown bits\nAny bits in a flag you define are called _known bits_. Any other bits are _unknown bits_. In the following flags type:\n```\nbitflags! {\n  struct Flags: u8 {\n    const A = 1;\n    const B = 1 << 1;\n    const C = 1 << 2;\n  }\n}\n```\n\nThe known bits are `0b0000_0111` and the unknown bits are `0b1111_1000`.\n`bitflags` doesn\u2019t guarantee that a flags value will only ever have known bits set, but some operators will unset any unknown bits they encounter. In a future version of `bitflags`, all operators will unset unknown bits.\nIf you\u2019re using `bitflags` for flags types defined externally, such as from C, you probably want all bits to be considered known, in case that external source changes. You can do this using an unnamed flag, as described in [externally defined flags](https://docs.rs/bitflags/latest/bitflags/#externally-defined-flags).\n### [\u00a7](https://docs.rs/bitflags/latest/bitflags/#zero-bit-flags)Zero-bit flags\nFlags with no bits set should be avoided because they interact strangely with [`Flags::contains`](https://docs.rs/bitflags/latest/bitflags/trait.Flags.html#method.contains \"method bitflags::Flags::contains\") and [`Flags::intersects`](https://docs.rs/bitflags/latest/bitflags/trait.Flags.html#method.intersects \"method bitflags::Flags::intersects\"). A zero-bit flag is always contained, but is never intersected. The names of zero-bit flags can be parsed, but are never formatted.\n### [\u00a7](https://docs.rs/bitflags/latest/bitflags/#multi-bit-flags)Multi-bit flags\nFlags that set multiple bits should be avoided unless each bit is also in a single-bit flag. Take the following flags type as an example:\n```\nbitflags! {\n  struct Flags: u8 {\n    const A = 1;\n    const B = 1 | 1 << 1;\n  }\n}\n```\n\nThe result of `Flags::A ^ Flags::B` is `0b0000_0010`, which doesn\u2019t correspond to either `Flags::A` or `Flags::B` even though it\u2019s still a known bit.\n## Modules[\u00a7](https://docs.rs/bitflags/latest/bitflags/#modules)\n\n[example_generated](https://docs.rs/bitflags/latest/bitflags/example_generated/index.html \"mod bitflags::example_generated\")\n    This module shows an example of code generated by the macro. **IT MUST NOT BE USED OUTSIDE THIS CRATE**.\n\n[iter](https://docs.rs/bitflags/latest/bitflags/iter/index.html \"mod bitflags::iter\")\n    Yield the bits of a source flags value in a set of contained flags values.\n\n[parser](https://docs.rs/bitflags/latest/bitflags/parser/index.html \"mod bitflags::parser\")\n    Parsing flags from text.\n## Macros[\u00a7](https://docs.rs/bitflags/latest/bitflags/#macros)\n\n[bitflags](https://docs.rs/bitflags/latest/bitflags/macro.bitflags.html \"macro bitflags::bitflags\")\n    Generate a flags type.\n\n[bitflags_match](https://docs.rs/bitflags/latest/bitflags/macro.bitflags_match.html \"macro bitflags::bitflags_match\")\n    A macro that matches flags values, similar to Rust\u2019s `match` statement.\n## Structs[\u00a7](https://docs.rs/bitflags/latest/bitflags/#structs)\n\n[Flag](https://docs.rs/bitflags/latest/bitflags/struct.Flag.html \"struct bitflags::Flag\")\n    A defined flags value that may be named or unnamed.\n## Traits[\u00a7](https://docs.rs/bitflags/latest/bitflags/#traits)\n\n[Bits](https://docs.rs/bitflags/latest/bitflags/trait.Bits.html \"trait bitflags::Bits\")\n    A bits type that can be used as storage for a flags type.\n\n[Flags](https://docs.rs/bitflags/latest/bitflags/trait.Flags.html \"trait bitflags::Flags\")\n    A set of defined flags using a bits type as storage.\n",
            "markdown_with_citations": "[](https://docs.rs/bitflags/latest/bitflags/all.html \"show sidebar\")\n# Crate bitflagsCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nGenerate types for C-style flags with ergonomic APIs.\n## \u00a7\u27e84\u27e9Getting started\nAdd `bitflags` to your `Cargo.toml`:\n```\n[dependencies.bitflags]\nversion = \"2.9.1\"\n```\n\n### \u00a7\u27e85\u27e9Crate features\nThe `bitflags` library defines a few Cargo features that you can opt-in to:\n  * `std`: Implement the `Error` trait on error types used by `bitflags`.\n  * `serde`: Support deriving `serde` traits on generated flags types.\n  * `arbitrary`: Support deriving `arbitrary` traits on generated flags types.\n  * `bytemuck`: Support deriving `bytemuck` traits on generated flags types.\n\n\n### \u00a7\u27e86\u27e9Generating flags types\nUse the `bitflags`\u27e87\u27e9 macro to generate flags types:\n```\nuse bitflags::bitflags;\nbitflags! {\n  pub struct Flags: u32 {\n    const A = 0b00000001;\n    const B = 0b00000010;\n    const C = 0b00000100;\n  }\n}\n```\n\nSee the docs for the `bitflags` macro for the full syntax.\nAlso see the `example_generated`\u27e88\u27e9 module for an example of what the `bitflags` macro generates for a flags type.\n#### \u00a7\u27e89\u27e9Externally defined flags\nIf you\u2019re generating flags types for an external source, such as a C API, you can define an extra unnamed flag as a mask of all bits the external source may ever set. Usually this would be all bits (`!0`):\n```\nbitflags! {\n  pub struct Flags: u32 {\n    const A = 0b00000001;\n    const B = 0b00000010;\n    const C = 0b00000100;\n    // The source may set any bits\n    const _ = !0;\n  }\n}\n```\n\nWhy should you do this? Generated methods like `all` and truncating operators like `!` only consider bits in defined flags. Adding an unnamed flag makes those methods consider additional bits, without generating additional constants for them. It helps compatibility when the external source may start setting additional bits at any time. The known and unknown bits\u27e810\u27e9 section has more details on this behavior.\n#### \u00a7\u27e811\u27e9Custom derives\nYou can derive some traits on generated flags types if you enable Cargo features. The following libraries are currently supported:\n  * `serde`: Support `#[derive(Serialize, Deserialize)]`, using text for human-readable formats, and a raw number for binary formats.\n  * `arbitrary`: Support `#[derive(Arbitrary)]`, only generating flags values with known bits.\n  * `bytemuck`: Support `#[derive(Pod, Zeroable)]`, for casting between flags values and their underlying bits values.\n\n\nYou can also define your own flags type outside of the `bitflags`\u27e87\u27e9 macro and then use it to generate methods. This can be useful if you need a custom `#[derive]` attribute for a library that `bitflags` doesn\u2019t natively support:\n```\n#[derive(SomeTrait)]\npub struct Flags(u32);\nbitflags! {\n  impl Flags: u32 {\n    const A = 0b00000001;\n    const B = 0b00000010;\n    const C = 0b00000100;\n  }\n}\n```\n\n#### \u00a7\u27e812\u27e9Adding custom methods\nThe `bitflags`\u27e87\u27e9 macro supports attributes on generated flags types within the macro itself, while `impl` blocks can be added outside of it:\n```\nbitflags! {\n  // Attributes can be applied to flags types\n  #[repr(transparent)]\n  #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n  pub struct Flags: u32 {\n    const A = 0b00000001;\n    const B = 0b00000010;\n    const C = 0b00000100;\n  }\n}\n// Impl blocks can be added to flags types\nimpl Flags {\n  pub fn as_u64(&self) -> u64 {\n    self.bits() as u64\n  }\n}\n```\n\n### \u00a7\u27e813\u27e9Working with flags values\nUse generated constants and standard bitwise operators to interact with flags values:\n```\n// union\nlet ab = Flags::A | Flags::B;\n// intersection\nlet a = ab & Flags::A;\n// difference\nlet b = ab - Flags::A;\n// complement\nlet c = !ab;\n```\n\nSee the docs for the `Flags`\u27e814\u27e9 trait for more details on operators and how they behave.\n## \u00a7\u27e815\u27e9Formatting and parsing\n`bitflags` defines a text format that can be used to convert any flags value to and from strings.\nSee the `parser`\u27e816\u27e9 module for more details.\n## \u00a7\u27e817\u27e9Specification\nThe terminology and behavior of generated flags types is specified in the source repository\u27e818\u27e9. Details are repeated in these docs where appropriate, but is exhaustively listed in the spec. Some things are worth calling out explicitly here.\n### \u00a7\u27e819\u27e9Flags types, flags values, flags\nThe spec and these docs use consistent terminology to refer to things in the bitflags domain:\n  * **Bits type** : A type that defines a fixed number of bits at specific locations.\n  * **Flag** : A set of bits in a bits type that may have a unique name.\n  * **Flags type** : A set of defined flags over a specific bits type.\n  * **Flags value** : An instance of a flags type using its specific bits value for storage.\n\n\n```\nbitflags! {\n  struct FlagsType: u8 {\n//          -- Bits type\n//     --------- Flags type\n    const A = 1;\n//      ----- Flag\n  }\n}\nlet flag = FlagsType::A;\n// ---- Flags value\n```\n\n### \u00a7\u27e810\u27e9Known and unknown bits\nAny bits in a flag you define are called _known bits_. Any other bits are _unknown bits_. In the following flags type:\n```\nbitflags! {\n  struct Flags: u8 {\n    const A = 1;\n    const B = 1 << 1;\n    const C = 1 << 2;\n  }\n}\n```\n\nThe known bits are `0b0000_0111` and the unknown bits are `0b1111_1000`.\n`bitflags` doesn\u2019t guarantee that a flags value will only ever have known bits set, but some operators will unset any unknown bits they encounter. In a future version of `bitflags`, all operators will unset unknown bits.\nIf you\u2019re using `bitflags` for flags types defined externally, such as from C, you probably want all bits to be considered known, in case that external source changes. You can do this using an unnamed flag, as described in externally defined flags\u27e89\u27e9.\n### \u00a7\u27e820\u27e9Zero-bit flags\nFlags with no bits set should be avoided because they interact strangely with `Flags::contains`\u27e821\u27e9 and `Flags::intersects`\u27e822\u27e9. A zero-bit flag is always contained, but is never intersected. The names of zero-bit flags can be parsed, but are never formatted.\n### \u00a7\u27e823\u27e9Multi-bit flags\nFlags that set multiple bits should be avoided unless each bit is also in a single-bit flag. Take the following flags type as an example:\n```\nbitflags! {\n  struct Flags: u8 {\n    const A = 1;\n    const B = 1 | 1 << 1;\n  }\n}\n```\n\nThe result of `Flags::A ^ Flags::B` is `0b0000_0010`, which doesn\u2019t correspond to either `Flags::A` or `Flags::B` even though it\u2019s still a known bit.\n## Modules\u00a7\u27e824\u27e9\n\nexample_generated\u27e88\u27e9\n    This module shows an example of code generated by the macro. **IT MUST NOT BE USED OUTSIDE THIS CRATE**.\n\niter\u27e825\u27e9\n    Yield the bits of a source flags value in a set of contained flags values.\n\nparser\u27e816\u27e9\n    Parsing flags from text.\n## Macros\u00a7\u27e826\u27e9\n\nbitflags\u27e87\u27e9\n    Generate a flags type.\n\nbitflags_match\u27e827\u27e9\n    A macro that matches flags values, similar to Rust\u2019s `match` statement.\n## Structs\u00a7\u27e828\u27e9\n\nFlag\u27e829\u27e9\n    A defined flags value that may be named or unnamed.\n## Traits\u00a7\u27e830\u27e9\n\nBits\u27e831\u27e9\n    A bits type that can be used as storage for a flags type.\n\nFlags\u27e814\u27e9\n    A set of defined flags using a bits type as storage.\n",
            "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/bitflags/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/bitflags/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/bitflags/latest/src/bitflags/lib.rs.html#11-1034: Source\n\u27e84\u27e9 https://docs.rs/bitflags/latest/bitflags/#getting-started: \u00a7\n\u27e85\u27e9 https://docs.rs/bitflags/latest/bitflags/#crate-features: \u00a7\n\u27e86\u27e9 https://docs.rs/bitflags/latest/bitflags/#generating-flags-types: \u00a7\n\u27e87\u27e9 https://docs.rs/bitflags/latest/bitflags/macro.bitflags.html: macro bitflags::bitflags - `bitflags`\n\u27e88\u27e9 https://docs.rs/bitflags/latest/bitflags/example_generated/index.html: `example_generated`\n\u27e89\u27e9 https://docs.rs/bitflags/latest/bitflags/#externally-defined-flags: \u00a7\n\u27e810\u27e9 https://docs.rs/bitflags/latest/bitflags/#known-and-unknown-bits: known and unknown bits\n\u27e811\u27e9 https://docs.rs/bitflags/latest/bitflags/#custom-derives: \u00a7\n\u27e812\u27e9 https://docs.rs/bitflags/latest/bitflags/#adding-custom-methods: \u00a7\n\u27e813\u27e9 https://docs.rs/bitflags/latest/bitflags/#working-with-flags-values: \u00a7\n\u27e814\u27e9 https://docs.rs/bitflags/latest/bitflags/trait.Flags.html: trait bitflags::Flags - `Flags`\n\u27e815\u27e9 https://docs.rs/bitflags/latest/bitflags/#formatting-and-parsing: \u00a7\n\u27e816\u27e9 https://docs.rs/bitflags/latest/bitflags/parser/index.html: mod bitflags::parser - `parser`\n\u27e817\u27e9 https://docs.rs/bitflags/latest/bitflags/#specification: \u00a7\n\u27e818\u27e9 https://github.com/bitflags/bitflags/blob/main/spec.md: specified in the source repository\n\u27e819\u27e9 https://docs.rs/bitflags/latest/bitflags/#flags-types-flags-values-flags: \u00a7\n\u27e820\u27e9 https://docs.rs/bitflags/latest/bitflags/#zero-bit-flags: \u00a7\n\u27e821\u27e9 https://docs.rs/bitflags/latest/bitflags/trait.Flags.html#method.contains: method bitflags::Flags::contains - `Flags::contains`\n\u27e822\u27e9 https://docs.rs/bitflags/latest/bitflags/trait.Flags.html#method.intersects: method bitflags::Flags::intersects - `Flags::intersects`\n\u27e823\u27e9 https://docs.rs/bitflags/latest/bitflags/#multi-bit-flags: \u00a7\n\u27e824\u27e9 https://docs.rs/bitflags/latest/bitflags/#modules: \u00a7\n\u27e825\u27e9 https://docs.rs/bitflags/latest/bitflags/iter/index.html: mod bitflags::iter - iter\n\u27e826\u27e9 https://docs.rs/bitflags/latest/bitflags/#macros: \u00a7\n\u27e827\u27e9 https://docs.rs/bitflags/latest/bitflags/macro.bitflags_match.html: macro bitflags::bitflags_match - bitflags_match\n\u27e828\u27e9 https://docs.rs/bitflags/latest/bitflags/#structs: \u00a7\n\u27e829\u27e9 https://docs.rs/bitflags/latest/bitflags/struct.Flag.html: struct bitflags::Flag - Flag\n\u27e830\u27e9 https://docs.rs/bitflags/latest/bitflags/#traits: \u00a7\n\u27e831\u27e9 https://docs.rs/bitflags/latest/bitflags/trait.Bits.html: trait bitflags::Bits - Bits\n",
            "fit_markdown": "",
            "fit_html": ""
          },
          "downloads": 0,
          "github_stars": 0,
          "dependencies": [],
          "features": {},
          "code_snippets": [],
          "readme_sections": {},
          "librs_downloads": null,
          "source": "crates.io",
          "enhanced_scraping": {},
          "enhanced_features": [],
          "enhanced_dependencies": [],
          "readme_summary": "The `bitflags` crate provides a macro for defining C-style bitflags with ergonomic APIs, enabling easy manipulation of flag values using bitwise operations. It supports features like `serde`, `arbitrary`, and `bytemuck` for deriving traits, allows custom methods and attributes, and handles both known and unknown bits for compatibility with external sources. Additionally, it offers formatting, parsing, and comprehensive documentation for working with flags types and values.",
          "feature_summary": null,
          "use_case": "Utilities",
          "score": 8.5,
          "factual_counterfactual": "### Pair 1: Generating Flags Types  \n\u2705 **Factual:** The `bitflags` crate provides a macro, `bitflags!`, which allows users to define C-style flags with ergonomic APIs, including constants and bitwise operators for manipulating flag values.  \n\u274c **Counterfactual:** The `bitflags` macro automatically generates runtime checks to ensure all defined flags are mutually exclusive, preventing overlapping bits in flag definitions.  \n\n---\n\n### Pair 2: Cargo Features  \n\u2705 **Factual:** The `bitflags` crate supports optional Cargo features like `serde`, `arbitrary`, and `bytemuck`, enabling users to derive traits such as `Serialize`, `Deserialize`, and `Pod` for compatibility with external libraries.  \n\u274c **Counterfactual:** The `bitflags` crate requires the `std` feature to function, as it depends on the standard library for basic operations like bitwise manipulation.  \n\n---\n\n### Pair 3: Working with Flags Values  \n\u2705 **Factual:** Flags generated by the `bitflags` macro can be combined, intersected, and complemented using standard bitwise operators, such as `|`, `&`, `!`, and `-`.  \n\u274c **Counterfactual:** Flags generated by the `bitflags` macro are immutable and cannot be modified after their initial definition, requiring new flag instances for every operation.",
          "source_analysis": null,
          "user_behavior": null,
          "security": null
        }
      },
      "irl_score": 8.6,
      "execution_id": "exec-80ce3bca-09d80d8a-1751260801",
      "timestamp": "2025-06-30T05:20:01.484578+00:00",
      "canon_version": "1.3.0"
    },
    "rule_zero_compliant": true
  }
]