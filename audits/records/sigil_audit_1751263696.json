[
  {
    "execution_id": "exec-ed415da6-2ddfb17b-1751263681",
    "timestamp": "2025-06-30T06:08:01.345264+00:00",
    "sacred_chain": {
      "input_data": "syn",
      "context_sources": [
        "crates.io",
        "github.com",
        "lib.rs",
        "docs.rs"
      ],
      "reasoning_steps": [
        "Input canonicalized: 'syn' -> 'syn'",
        "Context gathered from 4 validated sources",
        "Metadata extracted: 4 fields",
        "Documentation analyzed: quality 7.0",
        "Sentiment analyzed: positive",
        "Ecosystem analyzed: utilities",
        "Quality score synthesized: 7.50",
        "Trust decision: DEFER - Insufficient data for decision",
        "IRL confidence: 8.600"
      ],
      "suggestion": "ALLOW: Positive community sentiment",
      "verdict": "DEFER",
      "audit_info": {
        "metadata": {
          "name": "syn",
          "type": "rust_crate",
          "source": "manual_input",
          "extraction_method": "irl_engine"
        },
        "sentiment": {
          "quality_score": 7.0,
          "completeness": 0.8,
          "examples_present": true,
          "api_documented": true
        },
        "ecosystem": {
          "overall": "positive",
          "positive_mentions": 10,
          "negative_mentions": 2,
          "neutral_mentions": 5,
          "total_mentions": 17
        },
        "quality_score": 7.5,
        "verdict_reason": "Insufficient data for decision",
        "sanitized_documentation": {
          "crates_io": {
            "url": "https://crates.io/crates/syn",
            "title": "syn v2.0.104",
            "content": {
              "raw_markdown": "#  syn v2.0.104\nParser for Rust source code \n  * [ #macros ](https://crates.io/keywords/macros)\n  * [ #syn ](https://crates.io/keywords/syn)\n\n\n  * [ Readme ](https://crates.io/crates/syn)\n  * [ 337 Versions ](https://crates.io/crates/syn/versions)\n  * [ Dependencies ](https://crates.io/crates/syn/dependencies)\n  * [ Dependents ](https://crates.io/crates/syn/reverse_dependencies)\n\n\n## Metadata\n9 days ago \nv1.61.0 \n[ MIT ](https://choosealicense.com/licenses/mit) OR [ Apache-2.0 ](https://choosealicense.com/licenses/apache-2.0)\n293 KiB \n## Install\nRun the following Cargo command in your project directory:\ncargo add syn\nOr add the following line to your Cargo.toml:\nsyn = \"2.0.104\"\n## Documentation\n[ docs.rs/syn ](https://docs.rs/syn)\n## Repository\n[ github.com/dtolnay/syn ](https://github.com/dtolnay/syn)\n## Owners\n## Categories\n  * [Procedural macro helpers](https://crates.io/categories/development-tools::procedural-macro-helpers)\n  * [Parser implementations](https://crates.io/categories/parser-implementations)\n\n\n[ Report crate ](https://crates.io/support?crate=syn&inquire=crate-violation)\n### Stats Overview\n939,209,182 Downloads all time\n337 Versions published\n#### Downloads over the last 90 days\nDisplay as \nStacked \n  * Stacked \n  * Unstacked \n\n\nLoading\u2026\n",
              "markdown_with_citations": "#  syn v2.0.104\nParser for Rust source code \n  *  #macros \u27e81\u27e9\n  *  #syn \u27e82\u27e9\n\n\n  *  Readme \u27e83\u27e9\n  *  337 Versions \u27e84\u27e9\n  *  Dependencies \u27e85\u27e9\n  *  Dependents \u27e86\u27e9\n\n\n## Metadata\n9 days ago \nv1.61.0 \n MIT \u27e87\u27e9 OR  Apache-2.0 \u27e88\u27e9\n293 KiB \n## Install\nRun the following Cargo command in your project directory:\ncargo add syn\nOr add the following line to your Cargo.toml:\nsyn = \"2.0.104\"\n## Documentation\n docs.rs/syn \u27e89\u27e9\n## Repository\n github.com/dtolnay/syn \u27e810\u27e9\n## Owners\n## Categories\n  * Procedural macro helpers\u27e811\u27e9\n  * Parser implementations\u27e812\u27e9\n\n\n Report crate \u27e813\u27e9\n### Stats Overview\n939,209,182 Downloads all time\n337 Versions published\n#### Downloads over the last 90 days\nDisplay as \nStacked \n  * Stacked \n  * Unstacked \n\n\nLoading\u2026\n",
              "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://crates.io/keywords/macros:  #macros \n\u27e82\u27e9 https://crates.io/keywords/syn:  #syn \n\u27e83\u27e9 https://crates.io/crates/syn:  Readme \n\u27e84\u27e9 https://crates.io/crates/syn/versions:  337 Versions \n\u27e85\u27e9 https://crates.io/crates/syn/dependencies:  Dependencies \n\u27e86\u27e9 https://crates.io/crates/syn/reverse_dependencies:  Dependents \n\u27e87\u27e9 https://choosealicense.com/licenses/mit:  MIT \n\u27e88\u27e9 https://choosealicense.com/licenses/apache-2.0:  Apache-2.0 \n\u27e89\u27e9 https://docs.rs/syn:  docs.rs/syn \n\u27e810\u27e9 https://github.com/dtolnay/syn:  github.com/dtolnay/syn \n\u27e811\u27e9 https://crates.io/categories/development-tools::procedural-macro-helpers: Procedural macro helpers\n\u27e812\u27e9 https://crates.io/categories/parser-implementations: Parser implementations\n\u27e813\u27e9 https://crates.io/support?crate=syn&inquire=crate-violation:  Report crate \n",
              "fit_markdown": "",
              "fit_html": ""
            },
            "structured_data": {},
            "quality_score": 3.0,
            "extraction_method": "crawl4ai",
            "error": null,
            "metadata": {
              "doc_type": "docs",
              "content_length": 1275,
              "has_structured_data": false,
              "crawl_success": true
            },
            "timestamp": "117469.6270163"
          },
          "docs_rs": {
            "url": "https://docs.rs/syn",
            "title": "Crate synCopy item path",
            "content": {
              "raw_markdown": "[](https://docs.rs/syn/latest/syn/all.html \"show sidebar\")\n# Crate synCopy item path\n[Settings](https://docs.rs/syn/latest/settings.html)\n[Help](https://docs.rs/syn/latest/help.html)\nSummary[Source](https://docs.rs/syn/latest/src/syn/lib.rs.html#1-1011)\nExpand description\n[![github](https://img.shields.io/badge/github-8da0cb?style=for-the-badge&labelColor=555555&logo=github)](https://github.com/dtolnay/syn) [![crates-io](https://img.shields.io/badge/crates.io-fc8d62?style=for-the-badge&labelColor=555555&logo=rust)](https://crates.io/crates/syn) [![docs-rs](https://img.shields.io/badge/docs.rs-66c2a5?style=for-the-badge&labelColor=555555&logo=docs.rs)](https://docs.rs/syn/latest/syn/index.html \"mod syn\")\nSyn is a parsing library for parsing a stream of Rust tokens into a syntax tree of Rust source code.\nCurrently this library is geared toward use in Rust procedural macros, but contains some APIs that may be useful more generally.\n  * **Data structures** \u2014 Syn provides a complete syntax tree that can represent any valid Rust source code. The syntax tree is rooted at [`syn::File`](https://docs.rs/syn/latest/syn/struct.File.html \"struct syn::File\") which represents a full source file, but there are other entry points that may be useful to procedural macros including [`syn::Item`](https://docs.rs/syn/latest/syn/enum.Item.html \"enum syn::Item\"), [`syn::Expr`](https://docs.rs/syn/latest/syn/enum.Expr.html \"enum syn::Expr\") and [`syn::Type`](https://docs.rs/syn/latest/syn/enum.Type.html \"enum syn::Type\").\n  * **Derives** \u2014 Of particular interest to derive macros is [`syn::DeriveInput`](https://docs.rs/syn/latest/syn/struct.DeriveInput.html \"struct syn::DeriveInput\") which is any of the three legal input items to a derive macro. An example below shows using this type in a library that can derive implementations of a user-defined trait.\n  * **Parsing** \u2014 Parsing in Syn is built around [parser functions](https://docs.rs/syn/latest/syn/parse/index.html \"mod syn::parse\") with the signature `fn(ParseStream) -> Result<T>`. Every syntax tree node defined by Syn is individually parsable and may be used as a building block for custom syntaxes, or you may dream up your own brand new syntax without involving any of our syntax tree types.\n  * **Location information** \u2014 Every token parsed by Syn is associated with a `Span` that tracks line and column information back to the source of that token. These spans allow a procedural macro to display detailed error messages pointing to all the right places in the user\u2019s code. There is an example of this below.\n  * **Feature flags** \u2014 Functionality is aggressively feature gated so your procedural macros enable only what they need, and do not pay in compile time for all the rest.\n\n\n## [\u00a7](https://docs.rs/syn/latest/syn/#example-of-a-derive-macro)Example of a derive macro\nThe canonical derive macro using Syn looks like this. We write an ordinary Rust function tagged with a `proc_macro_derive` attribute and the name of the trait we are deriving. Any time that derive appears in the user\u2019s code, the Rust compiler passes their data structure as tokens into our macro. We get to execute arbitrary Rust code to figure out what to do with those tokens, then hand some tokens back to the compiler to compile into the user\u2019s crate.\n```\n[dependencies]\nsyn = \"2.0\"\nquote = \"1.0\"\n[lib]\nproc-macro = true\n```\n\n```\nuse proc_macro::TokenStream;\nuse quote::quote;\nuse syn::{parse_macro_input, DeriveInput};\n#[proc_macro_derive(MyMacro)]\npub fn my_macro(input: TokenStream) -> TokenStream {\n  // Parse the input tokens into a syntax tree\n  let input = parse_macro_input!(input as DeriveInput);\n  // Build the output, possibly using quasi-quotation\n  let expanded = quote! {\n    // ...\n  };\n  // Hand the output tokens back to the compiler\n  TokenStream::from(expanded)\n}\n```\n\nThe [`heapsize`](https://github.com/dtolnay/syn/tree/master/examples/heapsize) example directory shows a complete working implementation of a derive macro. The example derives a `HeapSize` trait which computes an estimate of the amount of heap memory owned by a value.\n```\npub trait HeapSize {\n  /// Total number of bytes of heap memory owned by `self`.\n  fn heap_size_of_children(&self) -> usize;\n}\n```\n\nThe derive macro allows users to write `#[derive(HeapSize)]` on data structures in their program.\n```\n#[derive(HeapSize)]\nstruct Demo<'a, T: ?Sized> {\n  a: Box<T>,\n  b: u8,\n  c: &'a str,\n  d: String,\n}\n```\n\n## [\u00a7](https://docs.rs/syn/latest/syn/#spans-and-error-reporting)Spans and error reporting\nThe token-based procedural macro API provides great control over where the compiler\u2019s error messages are displayed in user code. Consider the error the user sees if one of their field types does not implement `HeapSize`.\n```\n#[derive(HeapSize)]\nstruct Broken {\n  ok: String,\n  bad: std::thread::Thread,\n}\n```\n\nBy tracking span information all the way through the expansion of a procedural macro as shown in the `heapsize` example, token-based macros in Syn are able to trigger errors that directly pinpoint the source of the problem.\n```\nerror[E0277]: the trait bound `std::thread::Thread: HeapSize` is not satisfied\n --> src/main.rs:7:5\n |\n7 |   bad: std::thread::Thread,\n |   ^^^^^^^^^^^^^^^^^^^^^^^^ the trait `HeapSize` is not implemented for `Thread`\n```\n\n## [\u00a7](https://docs.rs/syn/latest/syn/#parsing-a-custom-syntax)Parsing a custom syntax\nThe [`lazy-static`](https://github.com/dtolnay/syn/tree/master/examples/lazy-static) example directory shows the implementation of a `functionlike!(...)` procedural macro in which the input tokens are parsed using Syn\u2019s parsing API.\nThe example reimplements the popular `lazy_static` crate from crates.io as a procedural macro.\n```\nlazy_static! {\n  static ref USERNAME: Regex = Regex::new(\"^[a-z0-9_-]{3,16}$\").unwrap();\n}\n```\n\nThe implementation shows how to trigger custom warnings and error messages on the macro input.\n```\nwarning: come on, pick a more creative name\n --> src/main.rs:10:16\n  |\n10 |   static ref FOO: String = \"lazy_static\".to_owned();\n  |        ^^^\n```\n\n## [\u00a7](https://docs.rs/syn/latest/syn/#testing)Testing\nWhen testing macros, we often care not just that the macro can be used successfully but also that when the macro is provided with invalid input it produces maximally helpful error messages. Consider using the [`trybuild`](https://github.com/dtolnay/trybuild) crate to write tests for errors that are emitted by your macro or errors detected by the Rust compiler in the expanded code following misuse of the macro. Such tests help avoid regressions from later refactors that mistakenly make an error no longer trigger or be less helpful than it used to be.\n## [\u00a7](https://docs.rs/syn/latest/syn/#debugging)Debugging\nWhen developing a procedural macro it can be helpful to look at what the generated code looks like. Use `cargo rustc -- -Zunstable-options --pretty=expanded` or the [`cargo expand`](https://github.com/dtolnay/cargo-expand) subcommand.\nTo show the expanded code for some crate that uses your procedural macro, run `cargo expand` from that crate. To show the expanded code for one of your own test cases, run `cargo expand --test the_test_case` where the last argument is the name of the test file without the `.rs` extension.\nThis write-up by Brandon W Maister discusses debugging in more detail: [Debugging Rust\u2019s new Custom Derive system](https://quodlibetor.github.io/posts/debugging-rusts-new-custom-derive-system/).\n## [\u00a7](https://docs.rs/syn/latest/syn/#optional-features)Optional features\nSyn puts a lot of functionality behind optional features in order to optimize compile time for the most common use cases. The following features are available.\n  * **`derive`**_(enabled by default)_ \u2014 Data structures for representing the possible input to a derive macro, including structs and enums and types.\n  * **`full`**\u2014 Data structures for representing the syntax tree of all valid Rust source code, including items and expressions.\n  * **`parsing`**_(enabled by default)_ \u2014 Ability to parse input tokens into a syntax tree node of a chosen type.\n  * **`printing`**_(enabled by default)_ \u2014 Ability to print a syntax tree node as tokens of Rust source code.\n  * **`visit`**\u2014 Trait for traversing a syntax tree.\n  * **`visit-mut`**\u2014 Trait for traversing and mutating in place a syntax tree.\n  * **`fold`**\u2014 Trait for transforming an owned syntax tree.\n  * **`clone-impls`**_(enabled by default)_ \u2014 Clone impls for all syntax tree types.\n  * **`extra-traits`**\u2014 Debug, Eq, PartialEq, Hash impls for all syntax tree types.\n  * **`proc-macro`**_(enabled by default)_ \u2014 Runtime dependency on the dynamic library libproc_macro from rustc toolchain.\n\n\n## Modules[\u00a7](https://docs.rs/syn/latest/syn/#modules)\n\n[buffer](https://docs.rs/syn/latest/syn/buffer/index.html \"mod syn::buffer\")`parsing`\n    A stably addressed token buffer supporting efficient traversal based on a cheaply copyable cursor.\n\n[ext](https://docs.rs/syn/latest/syn/ext/index.html \"mod syn::ext\")`parsing`\n    Extension traits to provide parsing methods on foreign types.\n\n[fold](https://docs.rs/syn/latest/syn/fold/index.html \"mod syn::fold\")`fold`\n    Syntax tree traversal to transform the nodes of an owned syntax tree.\n\n[meta](https://docs.rs/syn/latest/syn/meta/index.html \"mod syn::meta\")`parsing` and (`full` or `derive`)\n    Facility for interpreting structured content inside of an `Attribute`.\n\n[parse](https://docs.rs/syn/latest/syn/parse/index.html \"mod syn::parse\")`parsing`\n    Parsing interface for parsing a token stream into a syntax tree node.\n\n[punctuated](https://docs.rs/syn/latest/syn/punctuated/index.html \"mod syn::punctuated\")\n    A punctuated sequence of syntax tree nodes separated by punctuation.\n\n[spanned](https://docs.rs/syn/latest/syn/spanned/index.html \"mod syn::spanned\")`parsing` and `printing`\n    A trait that can provide the `Span` of the complete contents of a syntax tree node.\n\n[token](https://docs.rs/syn/latest/syn/token/index.html \"mod syn::token\")\n    Tokens representing Rust punctuation, keywords, and delimiters.\n\n[visit](https://docs.rs/syn/latest/syn/visit/index.html \"mod syn::visit\")`visit`\n    Syntax tree traversal to walk a shared borrow of a syntax tree.\n\n[visit_mut](https://docs.rs/syn/latest/syn/visit_mut/index.html \"mod syn::visit_mut\")`visit-mut`\n    Syntax tree traversal to mutate an exclusive borrow of a syntax tree in place.\n## Macros[\u00a7](https://docs.rs/syn/latest/syn/#macros)\n\n[Token](https://docs.rs/syn/latest/syn/macro.Token.html \"macro syn::Token\")\n    A type-macro that expands to the name of the Rust type representation of a given token.\n\n[braced](https://docs.rs/syn/latest/syn/macro.braced.html \"macro syn::braced\")`parsing`\n    Parse a set of curly braces and expose their content to subsequent parsers.\n\n[bracketed](https://docs.rs/syn/latest/syn/macro.bracketed.html \"macro syn::bracketed\")`parsing`\n    Parse a set of square brackets and expose their content to subsequent parsers.\n\n[custom_keyword](https://docs.rs/syn/latest/syn/macro.custom_keyword.html \"macro syn::custom_keyword\")\n    Define a type that supports parsing and printing a given identifier as if it were a keyword.\n\n[custom_punctuation](https://docs.rs/syn/latest/syn/macro.custom_punctuation.html \"macro syn::custom_punctuation\")\n    Define a type that supports parsing and printing a multi-character symbol as if it were a punctuation token.\n\n[parenthesized](https://docs.rs/syn/latest/syn/macro.parenthesized.html \"macro syn::parenthesized\")`parsing`\n    Parse a set of parentheses and expose their content to subsequent parsers.\n\n[parse_macro_input](https://docs.rs/syn/latest/syn/macro.parse_macro_input.html \"macro syn::parse_macro_input\")`parsing` and `proc-macro`\n    Parse the input TokenStream of a macro, triggering a compile error if the tokens fail to parse.\n\n[parse_quote](https://docs.rs/syn/latest/syn/macro.parse_quote.html \"macro syn::parse_quote\")`parsing` and `printing`\n    Quasi-quotation macro that accepts input like the [`quote!`](https://docs.rs/quote/1.0/quote/index.html) macro but uses type inference to figure out a return type for those tokens.\n\n[parse_quote_spanned](https://docs.rs/syn/latest/syn/macro.parse_quote_spanned.html \"macro syn::parse_quote_spanned\")`parsing` and `printing`\n    This macro is [`parse_quote!`](https://docs.rs/syn/latest/syn/macro.parse_quote.html \"macro syn::parse_quote\") + [`quote_spanned!`](https://docs.rs/quote/1.0.40/x86_64-unknown-linux-gnu/quote/macro.quote_spanned.html \"macro quote::quote_spanned\").\n## Structs[\u00a7](https://docs.rs/syn/latest/syn/#structs)\n\n[Abi](https://docs.rs/syn/latest/syn/struct.Abi.html \"struct syn::Abi\")`full` or `derive`\n    The binary interface of a function: `extern \"C\"`.\n\n[AngleBracketedGenericArguments](https://docs.rs/syn/latest/syn/struct.AngleBracketedGenericArguments.html \"struct syn::AngleBracketedGenericArguments\")`full` or `derive`\n    Angle bracketed arguments of a path segment: the `<K, V>` in `HashMap<K, V>`.\n\n[Arm](https://docs.rs/syn/latest/syn/struct.Arm.html \"struct syn::Arm\")`full`\n    One arm of a `match` expression: `0..=10 => { return true; }`.\n\n[AssocConst](https://docs.rs/syn/latest/syn/struct.AssocConst.html \"struct syn::AssocConst\")`full` or `derive`\n    An equality constraint on an associated constant: the `PANIC = false` in `Trait<PANIC = false>`.\n\n[AssocType](https://docs.rs/syn/latest/syn/struct.AssocType.html \"struct syn::AssocType\")`full` or `derive`\n    A binding (equality constraint) on an associated type: the `Item = u8` in `Iterator<Item = u8>`.\n\n[Attribute](https://docs.rs/syn/latest/syn/struct.Attribute.html \"struct syn::Attribute\")`full` or `derive`\n    An attribute, like `#[repr(transparent)]`.\n\n[BareFnArg](https://docs.rs/syn/latest/syn/struct.BareFnArg.html \"struct syn::BareFnArg\")`full` or `derive`\n    An argument in a function type: the `usize` in `fn(usize) -> bool`.\n\n[BareVariadic](https://docs.rs/syn/latest/syn/struct.BareVariadic.html \"struct syn::BareVariadic\")`full` or `derive`\n    The variadic argument of a function pointer like `fn(usize, ...)`.\n\n[Block](https://docs.rs/syn/latest/syn/struct.Block.html \"struct syn::Block\")`full`\n    A braced block containing Rust statements.\n\n[BoundLifetimes](https://docs.rs/syn/latest/syn/struct.BoundLifetimes.html \"struct syn::BoundLifetimes\")`full` or `derive`\n    A set of bound lifetimes: `for<'a, 'b, 'c>`.\n\n[ConstParam](https://docs.rs/syn/latest/syn/struct.ConstParam.html \"struct syn::ConstParam\")`full` or `derive`\n    A const generic parameter: `const LENGTH: usize`.\n\n[Constraint](https://docs.rs/syn/latest/syn/struct.Constraint.html \"struct syn::Constraint\")`full` or `derive`\n    An associated type bound: `Iterator<Item: Display>`.\n\n[DataEnum](https://docs.rs/syn/latest/syn/struct.DataEnum.html \"struct syn::DataEnum\")`derive`\n    An enum input to a `proc_macro_derive` macro.\n\n[DataStruct](https://docs.rs/syn/latest/syn/struct.DataStruct.html \"struct syn::DataStruct\")`derive`\n    A struct input to a `proc_macro_derive` macro.\n\n[DataUnion](https://docs.rs/syn/latest/syn/struct.DataUnion.html \"struct syn::DataUnion\")`derive`\n    An untagged union input to a `proc_macro_derive` macro.\n\n[DeriveInput](https://docs.rs/syn/latest/syn/struct.DeriveInput.html \"struct syn::DeriveInput\")`derive`\n    Data structure sent to a `proc_macro_derive` macro.\n\n[Error](https://docs.rs/syn/latest/syn/struct.Error.html \"struct syn::Error\")\n    Error returned when a Syn parser cannot parse the input tokens.\n\n[ExprArray](https://docs.rs/syn/latest/syn/struct.ExprArray.html \"struct syn::ExprArray\")`full`\n    A slice literal expression: `[a, b, c, d]`.\n\n[ExprAssign](https://docs.rs/syn/latest/syn/struct.ExprAssign.html \"struct syn::ExprAssign\")`full`\n    An assignment expression: `a = compute()`.\n\n[ExprAsync](https://docs.rs/syn/latest/syn/struct.ExprAsync.html \"struct syn::ExprAsync\")`full`\n    An async block: `async { ... }`.\n\n[ExprAwait](https://docs.rs/syn/latest/syn/struct.ExprAwait.html \"struct syn::ExprAwait\")`full`\n    An await expression: `fut.await`.\n\n[ExprBinary](https://docs.rs/syn/latest/syn/struct.ExprBinary.html \"struct syn::ExprBinary\")`full` or `derive`\n    A binary operation: `a + b`, `a += b`.\n\n[ExprBlock](https://docs.rs/syn/latest/syn/struct.ExprBlock.html \"struct syn::ExprBlock\")`full`\n    A blocked scope: `{ ... }`.\n\n[ExprBreak](https://docs.rs/syn/latest/syn/struct.ExprBreak.html \"struct syn::ExprBreak\")`full`\n    A `break`, with an optional label to break and an optional expression.\n\n[ExprCall](https://docs.rs/syn/latest/syn/struct.ExprCall.html \"struct syn::ExprCall\")`full` or `derive`\n    A function call expression: `invoke(a, b)`.\n\n[ExprCast](https://docs.rs/syn/latest/syn/struct.ExprCast.html \"struct syn::ExprCast\")`full` or `derive`\n    A cast expression: `foo as f64`.\n\n[ExprClosure](https://docs.rs/syn/latest/syn/struct.ExprClosure.html \"struct syn::ExprClosure\")`full`\n    A closure expression: `|a, b| a + b`.\n\n[ExprConst](https://docs.rs/syn/latest/syn/struct.ExprConst.html \"struct syn::ExprConst\")`full`\n    A const block: `const { ... }`.\n\n[ExprContinue](https://docs.rs/syn/latest/syn/struct.ExprContinue.html \"struct syn::ExprContinue\")`full`\n    A `continue`, with an optional label.\n\n[ExprField](https://docs.rs/syn/latest/syn/struct.ExprField.html \"struct syn::ExprField\")`full` or `derive`\n    Access of a named struct field (`obj.k`) or unnamed tuple struct field (`obj.0`).\n\n[ExprForLoop](https://docs.rs/syn/latest/syn/struct.ExprForLoop.html \"struct syn::ExprForLoop\")`full`\n    A for loop: `for pat in expr { ... }`.\n\n[ExprGroup](https://docs.rs/syn/latest/syn/struct.ExprGroup.html \"struct syn::ExprGroup\")`full`\n    An expression contained within invisible delimiters.\n\n[ExprIf](https://docs.rs/syn/latest/syn/struct.ExprIf.html \"struct syn::ExprIf\")`full`\n    An `if` expression with an optional `else` block: `if expr { ... } else { ... }`.\n\n[ExprIndex](https://docs.rs/syn/latest/syn/struct.ExprIndex.html \"struct syn::ExprIndex\")`full` or `derive`\n    A square bracketed indexing expression: `vector[2]`.\n\n[ExprInfer](https://docs.rs/syn/latest/syn/struct.ExprInfer.html \"struct syn::ExprInfer\")`full`\n    The inferred value of a const generic argument, denoted `_`.\n\n[ExprLet](https://docs.rs/syn/latest/syn/struct.ExprLet.html \"struct syn::ExprLet\")`full`\n    A `let` guard: `let Some(x) = opt`.\n\n[ExprLit](https://docs.rs/syn/latest/syn/struct.ExprLit.html \"struct syn::ExprLit\")`full` or `derive`\n    A literal in place of an expression: `1`, `\"foo\"`.\n\n[ExprLoop](https://docs.rs/syn/latest/syn/struct.ExprLoop.html \"struct syn::ExprLoop\")`full`\n    Conditionless loop: `loop { ... }`.\n\n[ExprMacro](https://docs.rs/syn/latest/syn/struct.ExprMacro.html \"struct syn::ExprMacro\")`full` or `derive`\n    A macro invocation expression: `format!(\"{}\", q)`.\n\n[ExprMatch](https://docs.rs/syn/latest/syn/struct.ExprMatch.html \"struct syn::ExprMatch\")`full`\n    A `match` expression: `match n { Some(n) => {}, None => {} }`.\n\n[ExprMethodCall](https://docs.rs/syn/latest/syn/struct.ExprMethodCall.html \"struct syn::ExprMethodCall\")`full` or `derive`\n    A method call expression: `x.foo::<T>(a, b)`.\n\n[ExprParen](https://docs.rs/syn/latest/syn/struct.ExprParen.html \"struct syn::ExprParen\")`full` or `derive`\n    A parenthesized expression: `(a + b)`.\n\n[ExprPath](https://docs.rs/syn/latest/syn/struct.ExprPath.html \"struct syn::ExprPath\")`full` or `derive`\n    A path like `std::mem::replace` possibly containing generic parameters and a qualified self-type.\n\n[ExprRange](https://docs.rs/syn/latest/syn/struct.ExprRange.html \"struct syn::ExprRange\")`full`\n    A range expression: `1..2`, `1..`, `..2`, `1..=2`, `..=2`.\n\n[ExprRawAddr](https://docs.rs/syn/latest/syn/struct.ExprRawAddr.html \"struct syn::ExprRawAddr\")`full`\n    Address-of operation: `&raw const place` or `&raw mut place`.\n\n[ExprReference](https://docs.rs/syn/latest/syn/struct.ExprReference.html \"struct syn::ExprReference\")`full` or `derive`\n    A referencing operation: `&a` or `&mut a`.\n\n[ExprRepeat](https://docs.rs/syn/latest/syn/struct.ExprRepeat.html \"struct syn::ExprRepeat\")`full`\n    An array literal constructed from one repeated element: `[0u8; N]`.\n\n[ExprReturn](https://docs.rs/syn/latest/syn/struct.ExprReturn.html \"struct syn::ExprReturn\")`full`\n    A `return`, with an optional value to be returned.\n\n[ExprStruct](https://docs.rs/syn/latest/syn/struct.ExprStruct.html \"struct syn::ExprStruct\")`full` or `derive`\n    A struct literal expression: `Point { x: 1, y: 1 }`.\n\n[ExprTry](https://docs.rs/syn/latest/syn/struct.ExprTry.html \"struct syn::ExprTry\")`full`\n    A try-expression: `expr?`.\n\n[ExprTryBlock](https://docs.rs/syn/latest/syn/struct.ExprTryBlock.html \"struct syn::ExprTryBlock\")`full`\n    A try block: `try { ... }`.\n\n[ExprTuple](https://docs.rs/syn/latest/syn/struct.ExprTuple.html \"struct syn::ExprTuple\")`full`\n    A tuple expression: `(a, b, c, d)`.\n\n[ExprUnary](https://docs.rs/syn/latest/syn/struct.ExprUnary.html \"struct syn::ExprUnary\")`full` or `derive`\n    A unary operation: `!x`, `*x`.\n\n[ExprUnsafe](https://docs.rs/syn/latest/syn/struct.ExprUnsafe.html \"struct syn::ExprUnsafe\")`full`\n    An unsafe block: `unsafe { ... }`.\n\n[ExprWhile](https://docs.rs/syn/latest/syn/struct.ExprWhile.html \"struct syn::ExprWhile\")`full`\n    A while loop: `while expr { ... }`.\n\n[ExprYield](https://docs.rs/syn/latest/syn/struct.ExprYield.html \"struct syn::ExprYield\")`full`\n    A yield expression: `yield expr`.\n\n[Field](https://docs.rs/syn/latest/syn/struct.Field.html \"struct syn::Field\")`full` or `derive`\n    A field of a struct or enum variant.\n\n[FieldPat](https://docs.rs/syn/latest/syn/struct.FieldPat.html \"struct syn::FieldPat\")`full`\n    A single field in a struct pattern.\n\n[FieldValue](https://docs.rs/syn/latest/syn/struct.FieldValue.html \"struct syn::FieldValue\")`full` or `derive`\n    A field-value pair in a struct literal.\n\n[FieldsNamed](https://docs.rs/syn/latest/syn/struct.FieldsNamed.html \"struct syn::FieldsNamed\")`full` or `derive`\n    Named fields of a struct or struct variant such as `Point { x: f64, y: f64 }`.\n\n[FieldsUnnamed](https://docs.rs/syn/latest/syn/struct.FieldsUnnamed.html \"struct syn::FieldsUnnamed\")`full` or `derive`\n    Unnamed fields of a tuple struct or tuple variant such as `Some(T)`.\n\n[File](https://docs.rs/syn/latest/syn/struct.File.html \"struct syn::File\")`full`\n    A complete file of Rust source code.\n\n[ForeignItemFn](https://docs.rs/syn/latest/syn/struct.ForeignItemFn.html \"struct syn::ForeignItemFn\")`full`\n    A foreign function in an `extern` block.\n\n[ForeignItemMacro](https://docs.rs/syn/latest/syn/struct.ForeignItemMacro.html \"struct syn::ForeignItemMacro\")`full`\n    A macro invocation within an extern block.\n\n[ForeignItemStatic](https://docs.rs/syn/latest/syn/struct.ForeignItemStatic.html \"struct syn::ForeignItemStatic\")`full`\n    A foreign static item in an `extern` block: `static ext: u8`.\n\n[ForeignItemType](https://docs.rs/syn/latest/syn/struct.ForeignItemType.html \"struct syn::ForeignItemType\")`full`\n    A foreign type in an `extern` block: `type void`.\n\n[Generics](https://docs.rs/syn/latest/syn/struct.Generics.html \"struct syn::Generics\")`full` or `derive`\n    Lifetimes and type parameters attached to a declaration of a function, enum, trait, etc.\n\n[Ident](https://docs.rs/syn/latest/syn/struct.Ident.html \"struct syn::Ident\")\n    A word of Rust code, which may be a keyword or legal variable name.\n\n[ImplGenerics](https://docs.rs/syn/latest/syn/struct.ImplGenerics.html \"struct syn::ImplGenerics\")(`full` or `derive`) and `printing`\n    Returned by `Generics::split_for_impl`.\n\n[ImplItemConst](https://docs.rs/syn/latest/syn/struct.ImplItemConst.html \"struct syn::ImplItemConst\")`full`\n    An associated constant within an impl block.\n\n[ImplItemFn](https://docs.rs/syn/latest/syn/struct.ImplItemFn.html \"struct syn::ImplItemFn\")`full`\n    An associated function within an impl block.\n\n[ImplItemMacro](https://docs.rs/syn/latest/syn/struct.ImplItemMacro.html \"struct syn::ImplItemMacro\")`full`\n    A macro invocation within an impl block.\n\n[ImplItemType](https://docs.rs/syn/latest/syn/struct.ImplItemType.html \"struct syn::ImplItemType\")`full`\n    An associated type within an impl block.\n\n[Index](https://docs.rs/syn/latest/syn/struct.Index.html \"struct syn::Index\")`full` or `derive`\n    The index of an unnamed tuple struct field.\n\n[ItemConst](https://docs.rs/syn/latest/syn/struct.ItemConst.html \"struct syn::ItemConst\")`full`\n    A constant item: `const MAX: u16 = 65535`.\n\n[ItemEnum](https://docs.rs/syn/latest/syn/struct.ItemEnum.html \"struct syn::ItemEnum\")`full`\n    An enum definition: `enum Foo<A, B> { A(A), B(B) }`.\n\n[ItemExternCrate](https://docs.rs/syn/latest/syn/struct.ItemExternCrate.html \"struct syn::ItemExternCrate\")`full`\n    An `extern crate` item: `extern crate serde`.\n\n[ItemFn](https://docs.rs/syn/latest/syn/struct.ItemFn.html \"struct syn::ItemFn\")`full`\n    A free-standing function: `fn process(n: usize) -> Result<()> { ... }`.\n\n[ItemForeignMod](https://docs.rs/syn/latest/syn/struct.ItemForeignMod.html \"struct syn::ItemForeignMod\")`full`\n    A block of foreign items: `extern \"C\" { ... }`.\n\n[ItemImpl](https://docs.rs/syn/latest/syn/struct.ItemImpl.html \"struct syn::ItemImpl\")`full`\n    An impl block providing trait or associated items: `impl<A> Trait for Data<A> { ... }`.\n\n[ItemMacro](https://docs.rs/syn/latest/syn/struct.ItemMacro.html \"struct syn::ItemMacro\")`full`\n    A macro invocation, which includes `macro_rules!` definitions.\n\n[ItemMod](https://docs.rs/syn/latest/syn/struct.ItemMod.html \"struct syn::ItemMod\")`full`\n    A module or module declaration: `mod m` or `mod m { ... }`.\n\n[ItemStatic](https://docs.rs/syn/latest/syn/struct.ItemStatic.html \"struct syn::ItemStatic\")`full`\n    A static item: `static BIKE: Shed = Shed(42)`.\n\n[ItemStruct](https://docs.rs/syn/latest/syn/struct.ItemStruct.html \"struct syn::ItemStruct\")`full`\n    A struct definition: `struct Foo<A> { x: A }`.\n\n[ItemTrait](https://docs.rs/syn/latest/syn/struct.ItemTrait.html \"struct syn::ItemTrait\")`full`\n    A trait definition: `pub trait Iterator { ... }`.\n\n[ItemTraitAlias](https://docs.rs/syn/latest/syn/struct.ItemTraitAlias.html \"struct syn::ItemTraitAlias\")`full`\n    A trait alias: `pub trait SharableIterator = Iterator + Sync`.\n\n[ItemType](https://docs.rs/syn/latest/syn/struct.ItemType.html \"struct syn::ItemType\")`full`\n    A type alias: `type Result<T> = std::result::Result<T, MyError>`.\n\n[ItemUnion](https://docs.rs/syn/latest/syn/struct.ItemUnion.html \"struct syn::ItemUnion\")`full`\n    A union definition: `union Foo<A, B> { x: A, y: B }`.\n\n[ItemUse](https://docs.rs/syn/latest/syn/struct.ItemUse.html \"struct syn::ItemUse\")`full`\n    A use declaration: `use std::collections::HashMap`.\n\n[Label](https://docs.rs/syn/latest/syn/struct.Label.html \"struct syn::Label\")`full`\n    A lifetime labeling a `for`, `while`, or `loop`.\n\n[Lifetime](https://docs.rs/syn/latest/syn/struct.Lifetime.html \"struct syn::Lifetime\")\n    A Rust lifetime: `'a`.\n\n[LifetimeParam](https://docs.rs/syn/latest/syn/struct.LifetimeParam.html \"struct syn::LifetimeParam\")`full` or `derive`\n    A lifetime definition: `'a: 'b + 'c + 'd`.\n\n[LitBool](https://docs.rs/syn/latest/syn/struct.LitBool.html \"struct syn::LitBool\")\n    A boolean literal: `true` or `false`.\n\n[LitByte](https://docs.rs/syn/latest/syn/struct.LitByte.html \"struct syn::LitByte\")\n    A byte literal: `b'f'`.\n\n[LitByteStr](https://docs.rs/syn/latest/syn/struct.LitByteStr.html \"struct syn::LitByteStr\")\n    A byte string literal: `b\"foo\"`.\n\n[LitCStr](https://docs.rs/syn/latest/syn/struct.LitCStr.html \"struct syn::LitCStr\")\n    A nul-terminated C-string literal: `c\"foo\"`.\n\n[LitChar](https://docs.rs/syn/latest/syn/struct.LitChar.html \"struct syn::LitChar\")\n    A character literal: `'a'`.\n\n[LitFloat](https://docs.rs/syn/latest/syn/struct.LitFloat.html \"struct syn::LitFloat\")\n    A floating point literal: `1f64` or `1.0e10f64`.\n\n[LitInt](https://docs.rs/syn/latest/syn/struct.LitInt.html \"struct syn::LitInt\")\n    An integer literal: `1` or `1u16`.\n\n[LitStr](https://docs.rs/syn/latest/syn/struct.LitStr.html \"struct syn::LitStr\")\n    A UTF-8 string literal: `\"foo\"`.\n\n[Local](https://docs.rs/syn/latest/syn/struct.Local.html \"struct syn::Local\")`full`\n    A local `let` binding: `let x: u64 = s.parse()?;`.\n\n[LocalInit](https://docs.rs/syn/latest/syn/struct.LocalInit.html \"struct syn::LocalInit\")`full`\n    The expression assigned in a local `let` binding, including optional diverging `else` block.\n\n[Macro](https://docs.rs/syn/latest/syn/struct.Macro.html \"struct syn::Macro\")`full` or `derive`\n    A macro invocation: `println!(\"{}\", mac)`.\n\n[MetaList](https://docs.rs/syn/latest/syn/struct.MetaList.html \"struct syn::MetaList\")`full` or `derive`\n    A structured list within an attribute, like `derive(Copy, Clone)`.\n\n[MetaNameValue](https://docs.rs/syn/latest/syn/struct.MetaNameValue.html \"struct syn::MetaNameValue\")`full` or `derive`\n    A name-value pair within an attribute, like `feature = \"nightly\"`.\n\n[ParenthesizedGenericArguments](https://docs.rs/syn/latest/syn/struct.ParenthesizedGenericArguments.html \"struct syn::ParenthesizedGenericArguments\")`full` or `derive`\n    Arguments of a function path segment: the `(A, B) -> C` in `Fn(A,B) -> C`.\n\n[PatConst](https://docs.rs/syn/latest/syn/struct.PatConst.html \"struct syn::PatConst\")`full`\n    A const block: `const { ... }`.\n\n[PatIdent](https://docs.rs/syn/latest/syn/struct.PatIdent.html \"struct syn::PatIdent\")`full`\n    A pattern that binds a new variable: `ref mut binding @ SUBPATTERN`.\n\n[PatLit](https://docs.rs/syn/latest/syn/struct.PatLit.html \"struct syn::PatLit\")`full`\n    A literal in place of an expression: `1`, `\"foo\"`.\n\n[PatMacro](https://docs.rs/syn/latest/syn/struct.PatMacro.html \"struct syn::PatMacro\")`full`\n    A macro invocation expression: `format!(\"{}\", q)`.\n\n[PatOr](https://docs.rs/syn/latest/syn/struct.PatOr.html \"struct syn::PatOr\")`full`\n    A pattern that matches any one of a set of cases.\n\n[PatParen](https://docs.rs/syn/latest/syn/struct.PatParen.html \"struct syn::PatParen\")`full`\n    A parenthesized pattern: `(A | B)`.\n\n[PatPath](https://docs.rs/syn/latest/syn/struct.PatPath.html \"struct syn::PatPath\")`full`\n    A path like `std::mem::replace` possibly containing generic parameters and a qualified self-type.\n\n[PatRange](https://docs.rs/syn/latest/syn/struct.PatRange.html \"struct syn::PatRange\")`full`\n    A range expression: `1..2`, `1..`, `..2`, `1..=2`, `..=2`.\n\n[PatReference](https://docs.rs/syn/latest/syn/struct.PatReference.html \"struct syn::PatReference\")`full`\n    A reference pattern: `&mut var`.\n\n[PatRest](https://docs.rs/syn/latest/syn/struct.PatRest.html \"struct syn::PatRest\")`full`\n    The dots in a tuple or slice pattern: `[0, 1, ..]`.\n\n[PatSlice](https://docs.rs/syn/latest/syn/struct.PatSlice.html \"struct syn::PatSlice\")`full`\n    A dynamically sized slice pattern: `[a, b, ref i @ .., y, z]`.\n\n[PatStruct](https://docs.rs/syn/latest/syn/struct.PatStruct.html \"struct syn::PatStruct\")`full`\n    A struct or struct variant pattern: `Variant { x, y, .. }`.\n\n[PatTuple](https://docs.rs/syn/latest/syn/struct.PatTuple.html \"struct syn::PatTuple\")`full`\n    A tuple pattern: `(a, b)`.\n\n[PatTupleStruct](https://docs.rs/syn/latest/syn/struct.PatTupleStruct.html \"struct syn::PatTupleStruct\")`full`\n    A tuple struct or tuple variant pattern: `Variant(x, y, .., z)`.\n\n[PatType](https://docs.rs/syn/latest/syn/struct.PatType.html \"struct syn::PatType\")`full`\n    A type ascription pattern: `foo: f64`.\n\n[PatWild](https://docs.rs/syn/latest/syn/struct.PatWild.html \"struct syn::PatWild\")`full`\n    A pattern that matches any value: `_`.\n\n[Path](https://docs.rs/syn/latest/syn/struct.Path.html \"struct syn::Path\")`full` or `derive`\n    A path at which a named item is exported (e.g. `std::collections::HashMap`).\n\n[PathSegment](https://docs.rs/syn/latest/syn/struct.PathSegment.html \"struct syn::PathSegment\")`full` or `derive`\n    A segment of a path together with any path arguments on that segment.\n\n[PreciseCapture](https://docs.rs/syn/latest/syn/struct.PreciseCapture.html \"struct syn::PreciseCapture\")`full`\n    Precise capturing bound: the \u2018use<\u2026>\u2019 in `impl Trait + use<'a, T>`.\n\n[PredicateLifetime](https://docs.rs/syn/latest/syn/struct.PredicateLifetime.html \"struct syn::PredicateLifetime\")`full` or `derive`\n    A lifetime predicate in a `where` clause: `'a: 'b + 'c`.\n\n[PredicateType](https://docs.rs/syn/latest/syn/struct.PredicateType.html \"struct syn::PredicateType\")`full` or `derive`\n    A type predicate in a `where` clause: `for<'c> Foo<'c>: Trait<'c>`.\n\n[QSelf](https://docs.rs/syn/latest/syn/struct.QSelf.html \"struct syn::QSelf\")`full` or `derive`\n    The explicit Self type in a qualified path: the `T` in `<T as Display>::fmt`.\n\n[Receiver](https://docs.rs/syn/latest/syn/struct.Receiver.html \"struct syn::Receiver\")`full`\n    The `self` argument of an associated method.\n\n[Signature](https://docs.rs/syn/latest/syn/struct.Signature.html \"struct syn::Signature\")`full`\n    A function signature in a trait or implementation: `unsafe fn initialize(&self)`.\n\n[StmtMacro](https://docs.rs/syn/latest/syn/struct.StmtMacro.html \"struct syn::StmtMacro\")`full`\n    A macro invocation in statement position.\n\n[TraitBound](https://docs.rs/syn/latest/syn/struct.TraitBound.html \"struct syn::TraitBound\")`full` or `derive`\n    A trait used as a bound on a type parameter.\n\n[TraitItemConst](https://docs.rs/syn/latest/syn/struct.TraitItemConst.html \"struct syn::TraitItemConst\")`full`\n    An associated constant within the definition of a trait.\n\n[TraitItemFn](https://docs.rs/syn/latest/syn/struct.TraitItemFn.html \"struct syn::TraitItemFn\")`full`\n    An associated function within the definition of a trait.\n\n[TraitItemMacro](https://docs.rs/syn/latest/syn/struct.TraitItemMacro.html \"struct syn::TraitItemMacro\")`full`\n    A macro invocation within the definition of a trait.\n\n[TraitItemType](https://docs.rs/syn/latest/syn/struct.TraitItemType.html \"struct syn::TraitItemType\")`full`\n    An associated type within the definition of a trait.\n\n[Turbofish](https://docs.rs/syn/latest/syn/struct.Turbofish.html \"struct syn::Turbofish\")(`full` or `derive`) and `printing`\n    Returned by `TypeGenerics::as_turbofish`.\n\n[TypeArray](https://docs.rs/syn/latest/syn/struct.TypeArray.html \"struct syn::TypeArray\")`full` or `derive`\n    A fixed size array type: `[T; n]`.\n\n[TypeBareFn](https://docs.rs/syn/latest/syn/struct.TypeBareFn.html \"struct syn::TypeBareFn\")`full` or `derive`\n    A bare function type: `fn(usize) -> bool`.\n\n[TypeGenerics](https://docs.rs/syn/latest/syn/struct.TypeGenerics.html \"struct syn::TypeGenerics\")(`full` or `derive`) and `printing`\n    Returned by `Generics::split_for_impl`.\n\n[TypeGroup](https://docs.rs/syn/latest/syn/struct.TypeGroup.html \"struct syn::TypeGroup\")`full` or `derive`\n    A type contained within invisible delimiters.\n\n[TypeImplTrait](https://docs.rs/syn/latest/syn/struct.TypeImplTrait.html \"struct syn::TypeImplTrait\")`full` or `derive`\n    An `impl Bound1 + Bound2 + Bound3` type where `Bound` is a trait or a lifetime.\n\n[TypeInfer](https://docs.rs/syn/latest/syn/struct.TypeInfer.html \"struct syn::TypeInfer\")`full` or `derive`\n    Indication that a type should be inferred by the compiler: `_`.\n\n[TypeMacro](https://docs.rs/syn/latest/syn/struct.TypeMacro.html \"struct syn::TypeMacro\")`full` or `derive`\n    A macro in the type position.\n\n[TypeNever](https://docs.rs/syn/latest/syn/struct.TypeNever.html \"struct syn::TypeNever\")`full` or `derive`\n    The never type: `!`.\n\n[TypeParam](https://docs.rs/syn/latest/syn/struct.TypeParam.html \"struct syn::TypeParam\")`full` or `derive`\n    A generic type parameter: `T: Into<String>`.\n\n[TypeParen](https://docs.rs/syn/latest/syn/struct.TypeParen.html \"struct syn::TypeParen\")`full` or `derive`\n    A parenthesized type equivalent to the inner type.\n\n[TypePath](https://docs.rs/syn/latest/syn/struct.TypePath.html \"struct syn::TypePath\")`full` or `derive`\n    A path like `std::slice::Iter`, optionally qualified with a self-type as in `<Vec<T> as SomeTrait>::Associated`.\n\n[TypePtr](https://docs.rs/syn/latest/syn/struct.TypePtr.html \"struct syn::TypePtr\")`full` or `derive`\n    A raw pointer type: `*const T` or `*mut T`.\n\n[TypeReference](https://docs.rs/syn/latest/syn/struct.TypeReference.html \"struct syn::TypeReference\")`full` or `derive`\n    A reference type: `&'a T` or `&'a mut T`.\n\n[TypeSlice](https://docs.rs/syn/latest/syn/struct.TypeSlice.html \"struct syn::TypeSlice\")`full` or `derive`\n    A dynamically sized slice type: `[T]`.\n\n[TypeTraitObject](https://docs.rs/syn/latest/syn/struct.TypeTraitObject.html \"struct syn::TypeTraitObject\")`full` or `derive`\n    A trait object type `dyn Bound1 + Bound2 + Bound3` where `Bound` is a trait or a lifetime.\n\n[TypeTuple](https://docs.rs/syn/latest/syn/struct.TypeTuple.html \"struct syn::TypeTuple\")`full` or `derive`\n    A tuple type: `(A, B, C, String)`.\n\n[UseGlob](https://docs.rs/syn/latest/syn/struct.UseGlob.html \"struct syn::UseGlob\")`full`\n    A glob import in a `use` item: `*`.\n\n[UseGroup](https://docs.rs/syn/latest/syn/struct.UseGroup.html \"struct syn::UseGroup\")`full`\n    A braced group of imports in a `use` item: `{A, B, C}`.\n\n[UseName](https://docs.rs/syn/latest/syn/struct.UseName.html \"struct syn::UseName\")`full`\n    An identifier imported by a `use` item: `HashMap`.\n\n[UsePath](https://docs.rs/syn/latest/syn/struct.UsePath.html \"struct syn::UsePath\")`full`\n    A path prefix of imports in a `use` item: `std::...`.\n\n[UseRename](https://docs.rs/syn/latest/syn/struct.UseRename.html \"struct syn::UseRename\")`full`\n    An renamed identifier imported by a `use` item: `HashMap as Map`.\n\n[Variadic](https://docs.rs/syn/latest/syn/struct.Variadic.html \"struct syn::Variadic\")`full`\n    The variadic argument of a foreign function.\n\n[Variant](https://docs.rs/syn/latest/syn/struct.Variant.html \"struct syn::Variant\")`full` or `derive`\n    An enum variant.\n\n[VisRestricted](https://docs.rs/syn/latest/syn/struct.VisRestricted.html \"struct syn::VisRestricted\")`full` or `derive`\n    A visibility level restricted to some path: `pub(self)` or `pub(super)` or `pub(crate)` or `pub(in some::module)`.\n\n[WhereClause](https://docs.rs/syn/latest/syn/struct.WhereClause.html \"struct syn::WhereClause\")`full` or `derive`\n    A `where` clause in a definition: `where T: Deserialize<'de>, D: 'static`.\n## Enums[\u00a7](https://docs.rs/syn/latest/syn/#enums)\n\n[AttrStyle](https://docs.rs/syn/latest/syn/enum.AttrStyle.html \"enum syn::AttrStyle\")`full` or `derive`\n    Distinguishes between attributes that decorate an item and attributes that are contained within an item.\n\n[BinOp](https://docs.rs/syn/latest/syn/enum.BinOp.html \"enum syn::BinOp\")`full` or `derive`\n    A binary operator: `+`, `+=`, `&`.\n\n[CapturedParam](https://docs.rs/syn/latest/syn/enum.CapturedParam.html \"enum syn::CapturedParam\")`full`\n    Single parameter in a precise capturing bound.\n\n[Data](https://docs.rs/syn/latest/syn/enum.Data.html \"enum syn::Data\")`derive`\n    The storage of a struct, enum or union data structure.\n\n[Expr](https://docs.rs/syn/latest/syn/enum.Expr.html \"enum syn::Expr\")`full` or `derive`\n    A Rust expression.\n\n[FieldMutability](https://docs.rs/syn/latest/syn/enum.FieldMutability.html \"enum syn::FieldMutability\")`full` or `derive`\n    Unused, but reserved for RFC 3323 restrictions.\n\n[Fields](https://docs.rs/syn/latest/syn/enum.Fields.html \"enum syn::Fields\")`full` or `derive`\n    Data stored within an enum variant or struct.\n\n[FnArg](https://docs.rs/syn/latest/syn/enum.FnArg.html \"enum syn::FnArg\")`full`\n    An argument in a function signature: the `n: usize` in `fn f(n: usize)`.\n\n[ForeignItem](https://docs.rs/syn/latest/syn/enum.ForeignItem.html \"enum syn::ForeignItem\")`full`\n    An item within an `extern` block.\n\n[GenericArgument](https://docs.rs/syn/latest/syn/enum.GenericArgument.html \"enum syn::GenericArgument\")`full` or `derive`\n    An individual generic argument, like `'a`, `T`, or `Item = T`.\n\n[GenericParam](https://docs.rs/syn/latest/syn/enum.GenericParam.html \"enum syn::GenericParam\")`full` or `derive`\n    A generic type parameter, lifetime, or const generic: `T: Into<String>`, `'a: 'b`, `const LEN: usize`.\n\n[ImplItem](https://docs.rs/syn/latest/syn/enum.ImplItem.html \"enum syn::ImplItem\")`full`\n    An item within an impl block.\n\n[ImplRestriction](https://docs.rs/syn/latest/syn/enum.ImplRestriction.html \"enum syn::ImplRestriction\")`full`\n    Unused, but reserved for RFC 3323 restrictions.\n\n[Item](https://docs.rs/syn/latest/syn/enum.Item.html \"enum syn::Item\")`full`\n    Things that can appear directly inside of a module or scope.\n\n[Lit](https://docs.rs/syn/latest/syn/enum.Lit.html \"enum syn::Lit\")\n    A Rust literal such as a string or integer or boolean.\n\n[MacroDelimiter](https://docs.rs/syn/latest/syn/enum.MacroDelimiter.html \"enum syn::MacroDelimiter\")`full` or `derive`\n    A grouping token that surrounds a macro body: `m!(...)` or `m!{...}` or `m![...]`.\n\n[Member](https://docs.rs/syn/latest/syn/enum.Member.html \"enum syn::Member\")`full` or `derive`\n    A struct or tuple struct field accessed in a struct literal or field expression.\n\n[Meta](https://docs.rs/syn/latest/syn/enum.Meta.html \"enum syn::Meta\")`full` or `derive`\n    Content of a compile-time structured attribute.\n\n[Pat](https://docs.rs/syn/latest/syn/enum.Pat.html \"enum syn::Pat\")`full`\n    A pattern in a local binding, function signature, match expression, or various other places.\n\n[PathArguments](https://docs.rs/syn/latest/syn/enum.PathArguments.html \"enum syn::PathArguments\")`full` or `derive`\n    Angle bracketed or parenthesized arguments of a path segment.\n\n[PointerMutability](https://docs.rs/syn/latest/syn/enum.PointerMutability.html \"enum syn::PointerMutability\")`full`\n    Mutability of a raw pointer (`*const T`, `*mut T`), in which non-mutable isn\u2019t the implicit default.\n\n[RangeLimits](https://docs.rs/syn/latest/syn/enum.RangeLimits.html \"enum syn::RangeLimits\")`full`\n    Limit types of a range, inclusive or exclusive.\n\n[ReturnType](https://docs.rs/syn/latest/syn/enum.ReturnType.html \"enum syn::ReturnType\")`full` or `derive`\n    Return type of a function signature.\n\n[StaticMutability](https://docs.rs/syn/latest/syn/enum.StaticMutability.html \"enum syn::StaticMutability\")`full`\n    The mutability of an `Item::Static` or `ForeignItem::Static`.\n\n[Stmt](https://docs.rs/syn/latest/syn/enum.Stmt.html \"enum syn::Stmt\")`full`\n    A statement, usually ending in a semicolon.\n\n[TraitBoundModifier](https://docs.rs/syn/latest/syn/enum.TraitBoundModifier.html \"enum syn::TraitBoundModifier\")`full` or `derive`\n    A modifier on a trait bound, currently only used for the `?` in `?Sized`.\n\n[TraitItem](https://docs.rs/syn/latest/syn/enum.TraitItem.html \"enum syn::TraitItem\")`full`\n    An item declaration within the definition of a trait.\n\n[Type](https://docs.rs/syn/latest/syn/enum.Type.html \"enum syn::Type\")`full` or `derive`\n    The possible types that a Rust value could have.\n\n[TypeParamBound](https://docs.rs/syn/latest/syn/enum.TypeParamBound.html \"enum syn::TypeParamBound\")`full` or `derive`\n    A trait or lifetime used as a bound on a type parameter.\n\n[UnOp](https://docs.rs/syn/latest/syn/enum.UnOp.html \"enum syn::UnOp\")`full` or `derive`\n    A unary operator: `*`, `!`, `-`.\n\n[UseTree](https://docs.rs/syn/latest/syn/enum.UseTree.html \"enum syn::UseTree\")`full`\n    A suffix of an import tree in a `use` item: `Type as Renamed` or `*`.\n\n[Visibility](https://docs.rs/syn/latest/syn/enum.Visibility.html \"enum syn::Visibility\")`full` or `derive`\n    The visibility level of an item: inherited or `pub` or `pub(restricted)`.\n\n[WherePredicate](https://docs.rs/syn/latest/syn/enum.WherePredicate.html \"enum syn::WherePredicate\")`full` or `derive`\n    A single predicate in a `where` clause: `T: Deserialize<'de>`.\n## Functions[\u00a7](https://docs.rs/syn/latest/syn/#functions)\n\n[parse](https://docs.rs/syn/latest/syn/fn.parse.html \"fn syn::parse\")`parsing` and `proc-macro`\n    Parse tokens of source code into the chosen syntax tree node.\n\n[parse2](https://docs.rs/syn/latest/syn/fn.parse2.html \"fn syn::parse2\")`parsing`\n    Parse a proc-macro2 token stream into the chosen syntax tree node.\n\n[parse_file](https://docs.rs/syn/latest/syn/fn.parse_file.html \"fn syn::parse_file\")`parsing` and `full`\n    Parse the content of a file of Rust code.\n\n[parse_str](https://docs.rs/syn/latest/syn/fn.parse_str.html \"fn syn::parse_str\")`parsing`\n    Parse a string of Rust code into the chosen syntax tree node.\n## Type Aliases[\u00a7](https://docs.rs/syn/latest/syn/#types)\n\n[Result](https://docs.rs/syn/latest/syn/type.Result.html \"type syn::Result\")\n    The result of a Syn parser.\n",
              "markdown_with_citations": "[](https://docs.rs/syn/latest/syn/all.html \"show sidebar\")\n# Crate synCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\n![github\u27e84\u27e9](https://github.com/dtolnay/syn) ![crates-io\u27e85\u27e9](https://crates.io/crates/syn) ![docs-rs\u27e86\u27e9](https://docs.rs/syn/latest/syn/index.html \"mod syn\")\nSyn is a parsing library for parsing a stream of Rust tokens into a syntax tree of Rust source code.\nCurrently this library is geared toward use in Rust procedural macros, but contains some APIs that may be useful more generally.\n  * **Data structures** \u2014 Syn provides a complete syntax tree that can represent any valid Rust source code. The syntax tree is rooted at `syn::File`\u27e87\u27e9 which represents a full source file, but there are other entry points that may be useful to procedural macros including `syn::Item`\u27e88\u27e9, `syn::Expr`\u27e89\u27e9 and `syn::Type`\u27e810\u27e9.\n  * **Derives** \u2014 Of particular interest to derive macros is `syn::DeriveInput`\u27e811\u27e9 which is any of the three legal input items to a derive macro. An example below shows using this type in a library that can derive implementations of a user-defined trait.\n  * **Parsing** \u2014 Parsing in Syn is built around parser functions\u27e812\u27e9 with the signature `fn(ParseStream) -> Result<T>`. Every syntax tree node defined by Syn is individually parsable and may be used as a building block for custom syntaxes, or you may dream up your own brand new syntax without involving any of our syntax tree types.\n  * **Location information** \u2014 Every token parsed by Syn is associated with a `Span` that tracks line and column information back to the source of that token. These spans allow a procedural macro to display detailed error messages pointing to all the right places in the user\u2019s code. There is an example of this below.\n  * **Feature flags** \u2014 Functionality is aggressively feature gated so your procedural macros enable only what they need, and do not pay in compile time for all the rest.\n\n\n## \u00a7\u27e813\u27e9Example of a derive macro\nThe canonical derive macro using Syn looks like this. We write an ordinary Rust function tagged with a `proc_macro_derive` attribute and the name of the trait we are deriving. Any time that derive appears in the user\u2019s code, the Rust compiler passes their data structure as tokens into our macro. We get to execute arbitrary Rust code to figure out what to do with those tokens, then hand some tokens back to the compiler to compile into the user\u2019s crate.\n```\n[dependencies]\nsyn = \"2.0\"\nquote = \"1.0\"\n[lib]\nproc-macro = true\n```\n\n```\nuse proc_macro::TokenStream;\nuse quote::quote;\nuse syn::{parse_macro_input, DeriveInput};\n#[proc_macro_derive(MyMacro)]\npub fn my_macro(input: TokenStream) -> TokenStream {\n  // Parse the input tokens into a syntax tree\n  let input = parse_macro_input!(input as DeriveInput);\n  // Build the output, possibly using quasi-quotation\n  let expanded = quote! {\n    // ...\n  };\n  // Hand the output tokens back to the compiler\n  TokenStream::from(expanded)\n}\n```\n\nThe `heapsize`\u27e814\u27e9 example directory shows a complete working implementation of a derive macro. The example derives a `HeapSize` trait which computes an estimate of the amount of heap memory owned by a value.\n```\npub trait HeapSize {\n  /// Total number of bytes of heap memory owned by `self`.\n  fn heap_size_of_children(&self) -> usize;\n}\n```\n\nThe derive macro allows users to write `#[derive(HeapSize)]` on data structures in their program.\n```\n#[derive(HeapSize)]\nstruct Demo<'a, T: ?Sized> {\n  a: Box<T>,\n  b: u8,\n  c: &'a str,\n  d: String,\n}\n```\n\n## \u00a7\u27e815\u27e9Spans and error reporting\nThe token-based procedural macro API provides great control over where the compiler\u2019s error messages are displayed in user code. Consider the error the user sees if one of their field types does not implement `HeapSize`.\n```\n#[derive(HeapSize)]\nstruct Broken {\n  ok: String,\n  bad: std::thread::Thread,\n}\n```\n\nBy tracking span information all the way through the expansion of a procedural macro as shown in the `heapsize` example, token-based macros in Syn are able to trigger errors that directly pinpoint the source of the problem.\n```\nerror[E0277]: the trait bound `std::thread::Thread: HeapSize` is not satisfied\n --> src/main.rs:7:5\n |\n7 |   bad: std::thread::Thread,\n |   ^^^^^^^^^^^^^^^^^^^^^^^^ the trait `HeapSize` is not implemented for `Thread`\n```\n\n## \u00a7\u27e816\u27e9Parsing a custom syntax\nThe `lazy-static`\u27e817\u27e9 example directory shows the implementation of a `functionlike!(...)` procedural macro in which the input tokens are parsed using Syn\u2019s parsing API.\nThe example reimplements the popular `lazy_static` crate from crates.io as a procedural macro.\n```\nlazy_static! {\n  static ref USERNAME: Regex = Regex::new(\"^[a-z0-9_-]{3,16}$\").unwrap();\n}\n```\n\nThe implementation shows how to trigger custom warnings and error messages on the macro input.\n```\nwarning: come on, pick a more creative name\n --> src/main.rs:10:16\n  |\n10 |   static ref FOO: String = \"lazy_static\".to_owned();\n  |        ^^^\n```\n\n## \u00a7\u27e818\u27e9Testing\nWhen testing macros, we often care not just that the macro can be used successfully but also that when the macro is provided with invalid input it produces maximally helpful error messages. Consider using the `trybuild`\u27e819\u27e9 crate to write tests for errors that are emitted by your macro or errors detected by the Rust compiler in the expanded code following misuse of the macro. Such tests help avoid regressions from later refactors that mistakenly make an error no longer trigger or be less helpful than it used to be.\n## \u00a7\u27e820\u27e9Debugging\nWhen developing a procedural macro it can be helpful to look at what the generated code looks like. Use `cargo rustc -- -Zunstable-options --pretty=expanded` or the `cargo expand`\u27e821\u27e9 subcommand.\nTo show the expanded code for some crate that uses your procedural macro, run `cargo expand` from that crate. To show the expanded code for one of your own test cases, run `cargo expand --test the_test_case` where the last argument is the name of the test file without the `.rs` extension.\nThis write-up by Brandon W Maister discusses debugging in more detail: Debugging Rust\u2019s new Custom Derive system\u27e822\u27e9.\n## \u00a7\u27e823\u27e9Optional features\nSyn puts a lot of functionality behind optional features in order to optimize compile time for the most common use cases. The following features are available.\n  * **`derive`**_(enabled by default)_ \u2014 Data structures for representing the possible input to a derive macro, including structs and enums and types.\n  * **`full`**\u2014 Data structures for representing the syntax tree of all valid Rust source code, including items and expressions.\n  * **`parsing`**_(enabled by default)_ \u2014 Ability to parse input tokens into a syntax tree node of a chosen type.\n  * **`printing`**_(enabled by default)_ \u2014 Ability to print a syntax tree node as tokens of Rust source code.\n  * **`visit`**\u2014 Trait for traversing a syntax tree.\n  * **`visit-mut`**\u2014 Trait for traversing and mutating in place a syntax tree.\n  * **`fold`**\u2014 Trait for transforming an owned syntax tree.\n  * **`clone-impls`**_(enabled by default)_ \u2014 Clone impls for all syntax tree types.\n  * **`extra-traits`**\u2014 Debug, Eq, PartialEq, Hash impls for all syntax tree types.\n  * **`proc-macro`**_(enabled by default)_ \u2014 Runtime dependency on the dynamic library libproc_macro from rustc toolchain.\n\n\n## Modules\u00a7\u27e824\u27e9\n\nbuffer\u27e825\u27e9`parsing`\n    A stably addressed token buffer supporting efficient traversal based on a cheaply copyable cursor.\n\next\u27e826\u27e9`parsing`\n    Extension traits to provide parsing methods on foreign types.\n\nfold\u27e827\u27e9`fold`\n    Syntax tree traversal to transform the nodes of an owned syntax tree.\n\nmeta\u27e828\u27e9`parsing` and (`full` or `derive`)\n    Facility for interpreting structured content inside of an `Attribute`.\n\nparse\u27e812\u27e9`parsing`\n    Parsing interface for parsing a token stream into a syntax tree node.\n\npunctuated\u27e829\u27e9\n    A punctuated sequence of syntax tree nodes separated by punctuation.\n\nspanned\u27e830\u27e9`parsing` and `printing`\n    A trait that can provide the `Span` of the complete contents of a syntax tree node.\n\ntoken\u27e831\u27e9\n    Tokens representing Rust punctuation, keywords, and delimiters.\n\nvisit\u27e832\u27e9`visit`\n    Syntax tree traversal to walk a shared borrow of a syntax tree.\n\nvisit_mut\u27e833\u27e9`visit-mut`\n    Syntax tree traversal to mutate an exclusive borrow of a syntax tree in place.\n## Macros\u00a7\u27e834\u27e9\n\nToken\u27e835\u27e9\n    A type-macro that expands to the name of the Rust type representation of a given token.\n\nbraced\u27e836\u27e9`parsing`\n    Parse a set of curly braces and expose their content to subsequent parsers.\n\nbracketed\u27e837\u27e9`parsing`\n    Parse a set of square brackets and expose their content to subsequent parsers.\n\ncustom_keyword\u27e838\u27e9\n    Define a type that supports parsing and printing a given identifier as if it were a keyword.\n\ncustom_punctuation\u27e839\u27e9\n    Define a type that supports parsing and printing a multi-character symbol as if it were a punctuation token.\n\nparenthesized\u27e840\u27e9`parsing`\n    Parse a set of parentheses and expose their content to subsequent parsers.\n\nparse_macro_input\u27e841\u27e9`parsing` and `proc-macro`\n    Parse the input TokenStream of a macro, triggering a compile error if the tokens fail to parse.\n\nparse_quote\u27e842\u27e9`parsing` and `printing`\n    Quasi-quotation macro that accepts input like the `quote!`\u27e843\u27e9 macro but uses type inference to figure out a return type for those tokens.\n\nparse_quote_spanned\u27e844\u27e9`parsing` and `printing`\n    This macro is `parse_quote!`\u27e842\u27e9 + `quote_spanned!`\u27e845\u27e9.\n## Structs\u00a7\u27e846\u27e9\n\nAbi\u27e847\u27e9`full` or `derive`\n    The binary interface of a function: `extern \"C\"`.\n\nAngleBracketedGenericArguments\u27e848\u27e9`full` or `derive`\n    Angle bracketed arguments of a path segment: the `<K, V>` in `HashMap<K, V>`.\n\nArm\u27e849\u27e9`full`\n    One arm of a `match` expression: `0..=10 => { return true; }`.\n\nAssocConst\u27e850\u27e9`full` or `derive`\n    An equality constraint on an associated constant: the `PANIC = false` in `Trait<PANIC = false>`.\n\nAssocType\u27e851\u27e9`full` or `derive`\n    A binding (equality constraint) on an associated type: the `Item = u8` in `Iterator<Item = u8>`.\n\nAttribute\u27e852\u27e9`full` or `derive`\n    An attribute, like `#[repr(transparent)]`.\n\nBareFnArg\u27e853\u27e9`full` or `derive`\n    An argument in a function type: the `usize` in `fn(usize) -> bool`.\n\nBareVariadic\u27e854\u27e9`full` or `derive`\n    The variadic argument of a function pointer like `fn(usize, ...)`.\n\nBlock\u27e855\u27e9`full`\n    A braced block containing Rust statements.\n\nBoundLifetimes\u27e856\u27e9`full` or `derive`\n    A set of bound lifetimes: `for<'a, 'b, 'c>`.\n\nConstParam\u27e857\u27e9`full` or `derive`\n    A const generic parameter: `const LENGTH: usize`.\n\nConstraint\u27e858\u27e9`full` or `derive`\n    An associated type bound: `Iterator<Item: Display>`.\n\nDataEnum\u27e859\u27e9`derive`\n    An enum input to a `proc_macro_derive` macro.\n\nDataStruct\u27e860\u27e9`derive`\n    A struct input to a `proc_macro_derive` macro.\n\nDataUnion\u27e861\u27e9`derive`\n    An untagged union input to a `proc_macro_derive` macro.\n\nDeriveInput\u27e811\u27e9`derive`\n    Data structure sent to a `proc_macro_derive` macro.\n\nError\u27e862\u27e9\n    Error returned when a Syn parser cannot parse the input tokens.\n\nExprArray\u27e863\u27e9`full`\n    A slice literal expression: `[a, b, c, d]`.\n\nExprAssign\u27e864\u27e9`full`\n    An assignment expression: `a = compute()`.\n\nExprAsync\u27e865\u27e9`full`\n    An async block: `async { ... }`.\n\nExprAwait\u27e866\u27e9`full`\n    An await expression: `fut.await`.\n\nExprBinary\u27e867\u27e9`full` or `derive`\n    A binary operation: `a + b`, `a += b`.\n\nExprBlock\u27e868\u27e9`full`\n    A blocked scope: `{ ... }`.\n\nExprBreak\u27e869\u27e9`full`\n    A `break`, with an optional label to break and an optional expression.\n\nExprCall\u27e870\u27e9`full` or `derive`\n    A function call expression: `invoke(a, b)`.\n\nExprCast\u27e871\u27e9`full` or `derive`\n    A cast expression: `foo as f64`.\n\nExprClosure\u27e872\u27e9`full`\n    A closure expression: `|a, b| a + b`.\n\nExprConst\u27e873\u27e9`full`\n    A const block: `const { ... }`.\n\nExprContinue\u27e874\u27e9`full`\n    A `continue`, with an optional label.\n\nExprField\u27e875\u27e9`full` or `derive`\n    Access of a named struct field (`obj.k`) or unnamed tuple struct field (`obj.0`).\n\nExprForLoop\u27e876\u27e9`full`\n    A for loop: `for pat in expr { ... }`.\n\nExprGroup\u27e877\u27e9`full`\n    An expression contained within invisible delimiters.\n\nExprIf\u27e878\u27e9`full`\n    An `if` expression with an optional `else` block: `if expr { ... } else { ... }`.\n\nExprIndex\u27e879\u27e9`full` or `derive`\n    A square bracketed indexing expression: `vector[2]`.\n\nExprInfer\u27e880\u27e9`full`\n    The inferred value of a const generic argument, denoted `_`.\n\nExprLet\u27e881\u27e9`full`\n    A `let` guard: `let Some(x) = opt`.\n\nExprLit\u27e882\u27e9`full` or `derive`\n    A literal in place of an expression: `1`, `\"foo\"`.\n\nExprLoop\u27e883\u27e9`full`\n    Conditionless loop: `loop { ... }`.\n\nExprMacro\u27e884\u27e9`full` or `derive`\n    A macro invocation expression: `format!(\"{}\", q)`.\n\nExprMatch\u27e885\u27e9`full`\n    A `match` expression: `match n { Some(n) => {}, None => {} }`.\n\nExprMethodCall\u27e886\u27e9`full` or `derive`\n    A method call expression: `x.foo::<T>(a, b)`.\n\nExprParen\u27e887\u27e9`full` or `derive`\n    A parenthesized expression: `(a + b)`.\n\nExprPath\u27e888\u27e9`full` or `derive`\n    A path like `std::mem::replace` possibly containing generic parameters and a qualified self-type.\n\nExprRange\u27e889\u27e9`full`\n    A range expression: `1..2`, `1..`, `..2`, `1..=2`, `..=2`.\n\nExprRawAddr\u27e890\u27e9`full`\n    Address-of operation: `&raw const place` or `&raw mut place`.\n\nExprReference\u27e891\u27e9`full` or `derive`\n    A referencing operation: `&a` or `&mut a`.\n\nExprRepeat\u27e892\u27e9`full`\n    An array literal constructed from one repeated element: `[0u8; N]`.\n\nExprReturn\u27e893\u27e9`full`\n    A `return`, with an optional value to be returned.\n\nExprStruct\u27e894\u27e9`full` or `derive`\n    A struct literal expression: `Point { x: 1, y: 1 }`.\n\nExprTry\u27e895\u27e9`full`\n    A try-expression: `expr?`.\n\nExprTryBlock\u27e896\u27e9`full`\n    A try block: `try { ... }`.\n\nExprTuple\u27e897\u27e9`full`\n    A tuple expression: `(a, b, c, d)`.\n\nExprUnary\u27e898\u27e9`full` or `derive`\n    A unary operation: `!x`, `*x`.\n\nExprUnsafe\u27e899\u27e9`full`\n    An unsafe block: `unsafe { ... }`.\n\nExprWhile\u27e8100\u27e9`full`\n    A while loop: `while expr { ... }`.\n\nExprYield\u27e8101\u27e9`full`\n    A yield expression: `yield expr`.\n\nField\u27e8102\u27e9`full` or `derive`\n    A field of a struct or enum variant.\n\nFieldPat\u27e8103\u27e9`full`\n    A single field in a struct pattern.\n\nFieldValue\u27e8104\u27e9`full` or `derive`\n    A field-value pair in a struct literal.\n\nFieldsNamed\u27e8105\u27e9`full` or `derive`\n    Named fields of a struct or struct variant such as `Point { x: f64, y: f64 }`.\n\nFieldsUnnamed\u27e8106\u27e9`full` or `derive`\n    Unnamed fields of a tuple struct or tuple variant such as `Some(T)`.\n\nFile\u27e87\u27e9`full`\n    A complete file of Rust source code.\n\nForeignItemFn\u27e8107\u27e9`full`\n    A foreign function in an `extern` block.\n\nForeignItemMacro\u27e8108\u27e9`full`\n    A macro invocation within an extern block.\n\nForeignItemStatic\u27e8109\u27e9`full`\n    A foreign static item in an `extern` block: `static ext: u8`.\n\nForeignItemType\u27e8110\u27e9`full`\n    A foreign type in an `extern` block: `type void`.\n\nGenerics\u27e8111\u27e9`full` or `derive`\n    Lifetimes and type parameters attached to a declaration of a function, enum, trait, etc.\n\nIdent\u27e8112\u27e9\n    A word of Rust code, which may be a keyword or legal variable name.\n\nImplGenerics\u27e8113\u27e9(`full` or `derive`) and `printing`\n    Returned by `Generics::split_for_impl`.\n\nImplItemConst\u27e8114\u27e9`full`\n    An associated constant within an impl block.\n\nImplItemFn\u27e8115\u27e9`full`\n    An associated function within an impl block.\n\nImplItemMacro\u27e8116\u27e9`full`\n    A macro invocation within an impl block.\n\nImplItemType\u27e8117\u27e9`full`\n    An associated type within an impl block.\n\nIndex\u27e8118\u27e9`full` or `derive`\n    The index of an unnamed tuple struct field.\n\nItemConst\u27e8119\u27e9`full`\n    A constant item: `const MAX: u16 = 65535`.\n\nItemEnum\u27e8120\u27e9`full`\n    An enum definition: `enum Foo<A, B> { A(A), B(B) }`.\n\nItemExternCrate\u27e8121\u27e9`full`\n    An `extern crate` item: `extern crate serde`.\n\nItemFn\u27e8122\u27e9`full`\n    A free-standing function: `fn process(n: usize) -> Result<()> { ... }`.\n\nItemForeignMod\u27e8123\u27e9`full`\n    A block of foreign items: `extern \"C\" { ... }`.\n\nItemImpl\u27e8124\u27e9`full`\n    An impl block providing trait or associated items: `impl<A> Trait for Data<A> { ... }`.\n\nItemMacro\u27e8125\u27e9`full`\n    A macro invocation, which includes `macro_rules!` definitions.\n\nItemMod\u27e8126\u27e9`full`\n    A module or module declaration: `mod m` or `mod m { ... }`.\n\nItemStatic\u27e8127\u27e9`full`\n    A static item: `static BIKE: Shed = Shed(42)`.\n\nItemStruct\u27e8128\u27e9`full`\n    A struct definition: `struct Foo<A> { x: A }`.\n\nItemTrait\u27e8129\u27e9`full`\n    A trait definition: `pub trait Iterator { ... }`.\n\nItemTraitAlias\u27e8130\u27e9`full`\n    A trait alias: `pub trait SharableIterator = Iterator + Sync`.\n\nItemType\u27e8131\u27e9`full`\n    A type alias: `type Result<T> = std::result::Result<T, MyError>`.\n\nItemUnion\u27e8132\u27e9`full`\n    A union definition: `union Foo<A, B> { x: A, y: B }`.\n\nItemUse\u27e8133\u27e9`full`\n    A use declaration: `use std::collections::HashMap`.\n\nLabel\u27e8134\u27e9`full`\n    A lifetime labeling a `for`, `while`, or `loop`.\n\nLifetime\u27e8135\u27e9\n    A Rust lifetime: `'a`.\n\nLifetimeParam\u27e8136\u27e9`full` or `derive`\n    A lifetime definition: `'a: 'b + 'c + 'd`.\n\nLitBool\u27e8137\u27e9\n    A boolean literal: `true` or `false`.\n\nLitByte\u27e8138\u27e9\n    A byte literal: `b'f'`.\n\nLitByteStr\u27e8139\u27e9\n    A byte string literal: `b\"foo\"`.\n\nLitCStr\u27e8140\u27e9\n    A nul-terminated C-string literal: `c\"foo\"`.\n\nLitChar\u27e8141\u27e9\n    A character literal: `'a'`.\n\nLitFloat\u27e8142\u27e9\n    A floating point literal: `1f64` or `1.0e10f64`.\n\nLitInt\u27e8143\u27e9\n    An integer literal: `1` or `1u16`.\n\nLitStr\u27e8144\u27e9\n    A UTF-8 string literal: `\"foo\"`.\n\nLocal\u27e8145\u27e9`full`\n    A local `let` binding: `let x: u64 = s.parse()?;`.\n\nLocalInit\u27e8146\u27e9`full`\n    The expression assigned in a local `let` binding, including optional diverging `else` block.\n\nMacro\u27e8147\u27e9`full` or `derive`\n    A macro invocation: `println!(\"{}\", mac)`.\n\nMetaList\u27e8148\u27e9`full` or `derive`\n    A structured list within an attribute, like `derive(Copy, Clone)`.\n\nMetaNameValue\u27e8149\u27e9`full` or `derive`\n    A name-value pair within an attribute, like `feature = \"nightly\"`.\n\nParenthesizedGenericArguments\u27e8150\u27e9`full` or `derive`\n    Arguments of a function path segment: the `(A, B) -> C` in `Fn(A,B) -> C`.\n\nPatConst\u27e8151\u27e9`full`\n    A const block: `const { ... }`.\n\nPatIdent\u27e8152\u27e9`full`\n    A pattern that binds a new variable: `ref mut binding @ SUBPATTERN`.\n\nPatLit\u27e8153\u27e9`full`\n    A literal in place of an expression: `1`, `\"foo\"`.\n\nPatMacro\u27e8154\u27e9`full`\n    A macro invocation expression: `format!(\"{}\", q)`.\n\nPatOr\u27e8155\u27e9`full`\n    A pattern that matches any one of a set of cases.\n\nPatParen\u27e8156\u27e9`full`\n    A parenthesized pattern: `(A | B)`.\n\nPatPath\u27e8157\u27e9`full`\n    A path like `std::mem::replace` possibly containing generic parameters and a qualified self-type.\n\nPatRange\u27e8158\u27e9`full`\n    A range expression: `1..2`, `1..`, `..2`, `1..=2`, `..=2`.\n\nPatReference\u27e8159\u27e9`full`\n    A reference pattern: `&mut var`.\n\nPatRest\u27e8160\u27e9`full`\n    The dots in a tuple or slice pattern: `[0, 1, ..]`.\n\nPatSlice\u27e8161\u27e9`full`\n    A dynamically sized slice pattern: `[a, b, ref i @ .., y, z]`.\n\nPatStruct\u27e8162\u27e9`full`\n    A struct or struct variant pattern: `Variant { x, y, .. }`.\n\nPatTuple\u27e8163\u27e9`full`\n    A tuple pattern: `(a, b)`.\n\nPatTupleStruct\u27e8164\u27e9`full`\n    A tuple struct or tuple variant pattern: `Variant(x, y, .., z)`.\n\nPatType\u27e8165\u27e9`full`\n    A type ascription pattern: `foo: f64`.\n\nPatWild\u27e8166\u27e9`full`\n    A pattern that matches any value: `_`.\n\nPath\u27e8167\u27e9`full` or `derive`\n    A path at which a named item is exported (e.g. `std::collections::HashMap`).\n\nPathSegment\u27e8168\u27e9`full` or `derive`\n    A segment of a path together with any path arguments on that segment.\n\nPreciseCapture\u27e8169\u27e9`full`\n    Precise capturing bound: the \u2018use<\u2026>\u2019 in `impl Trait + use<'a, T>`.\n\nPredicateLifetime\u27e8170\u27e9`full` or `derive`\n    A lifetime predicate in a `where` clause: `'a: 'b + 'c`.\n\nPredicateType\u27e8171\u27e9`full` or `derive`\n    A type predicate in a `where` clause: `for<'c> Foo<'c>: Trait<'c>`.\n\nQSelf\u27e8172\u27e9`full` or `derive`\n    The explicit Self type in a qualified path: the `T` in `<T as Display>::fmt`.\n\nReceiver\u27e8173\u27e9`full`\n    The `self` argument of an associated method.\n\nSignature\u27e8174\u27e9`full`\n    A function signature in a trait or implementation: `unsafe fn initialize(&self)`.\n\nStmtMacro\u27e8175\u27e9`full`\n    A macro invocation in statement position.\n\nTraitBound\u27e8176\u27e9`full` or `derive`\n    A trait used as a bound on a type parameter.\n\nTraitItemConst\u27e8177\u27e9`full`\n    An associated constant within the definition of a trait.\n\nTraitItemFn\u27e8178\u27e9`full`\n    An associated function within the definition of a trait.\n\nTraitItemMacro\u27e8179\u27e9`full`\n    A macro invocation within the definition of a trait.\n\nTraitItemType\u27e8180\u27e9`full`\n    An associated type within the definition of a trait.\n\nTurbofish\u27e8181\u27e9(`full` or `derive`) and `printing`\n    Returned by `TypeGenerics::as_turbofish`.\n\nTypeArray\u27e8182\u27e9`full` or `derive`\n    A fixed size array type: `[T; n]`.\n\nTypeBareFn\u27e8183\u27e9`full` or `derive`\n    A bare function type: `fn(usize) -> bool`.\n\nTypeGenerics\u27e8184\u27e9(`full` or `derive`) and `printing`\n    Returned by `Generics::split_for_impl`.\n\nTypeGroup\u27e8185\u27e9`full` or `derive`\n    A type contained within invisible delimiters.\n\nTypeImplTrait\u27e8186\u27e9`full` or `derive`\n    An `impl Bound1 + Bound2 + Bound3` type where `Bound` is a trait or a lifetime.\n\nTypeInfer\u27e8187\u27e9`full` or `derive`\n    Indication that a type should be inferred by the compiler: `_`.\n\nTypeMacro\u27e8188\u27e9`full` or `derive`\n    A macro in the type position.\n\nTypeNever\u27e8189\u27e9`full` or `derive`\n    The never type: `!`.\n\nTypeParam\u27e8190\u27e9`full` or `derive`\n    A generic type parameter: `T: Into<String>`.\n\nTypeParen\u27e8191\u27e9`full` or `derive`\n    A parenthesized type equivalent to the inner type.\n\nTypePath\u27e8192\u27e9`full` or `derive`\n    A path like `std::slice::Iter`, optionally qualified with a self-type as in `<Vec<T> as SomeTrait>::Associated`.\n\nTypePtr\u27e8193\u27e9`full` or `derive`\n    A raw pointer type: `*const T` or `*mut T`.\n\nTypeReference\u27e8194\u27e9`full` or `derive`\n    A reference type: `&'a T` or `&'a mut T`.\n\nTypeSlice\u27e8195\u27e9`full` or `derive`\n    A dynamically sized slice type: `[T]`.\n\nTypeTraitObject\u27e8196\u27e9`full` or `derive`\n    A trait object type `dyn Bound1 + Bound2 + Bound3` where `Bound` is a trait or a lifetime.\n\nTypeTuple\u27e8197\u27e9`full` or `derive`\n    A tuple type: `(A, B, C, String)`.\n\nUseGlob\u27e8198\u27e9`full`\n    A glob import in a `use` item: `*`.\n\nUseGroup\u27e8199\u27e9`full`\n    A braced group of imports in a `use` item: `{A, B, C}`.\n\nUseName\u27e8200\u27e9`full`\n    An identifier imported by a `use` item: `HashMap`.\n\nUsePath\u27e8201\u27e9`full`\n    A path prefix of imports in a `use` item: `std::...`.\n\nUseRename\u27e8202\u27e9`full`\n    An renamed identifier imported by a `use` item: `HashMap as Map`.\n\nVariadic\u27e8203\u27e9`full`\n    The variadic argument of a foreign function.\n\nVariant\u27e8204\u27e9`full` or `derive`\n    An enum variant.\n\nVisRestricted\u27e8205\u27e9`full` or `derive`\n    A visibility level restricted to some path: `pub(self)` or `pub(super)` or `pub(crate)` or `pub(in some::module)`.\n\nWhereClause\u27e8206\u27e9`full` or `derive`\n    A `where` clause in a definition: `where T: Deserialize<'de>, D: 'static`.\n## Enums\u00a7\u27e8207\u27e9\n\nAttrStyle\u27e8208\u27e9`full` or `derive`\n    Distinguishes between attributes that decorate an item and attributes that are contained within an item.\n\nBinOp\u27e8209\u27e9`full` or `derive`\n    A binary operator: `+`, `+=`, `&`.\n\nCapturedParam\u27e8210\u27e9`full`\n    Single parameter in a precise capturing bound.\n\nData\u27e8211\u27e9`derive`\n    The storage of a struct, enum or union data structure.\n\nExpr\u27e89\u27e9`full` or `derive`\n    A Rust expression.\n\nFieldMutability\u27e8212\u27e9`full` or `derive`\n    Unused, but reserved for RFC 3323 restrictions.\n\nFields\u27e8213\u27e9`full` or `derive`\n    Data stored within an enum variant or struct.\n\nFnArg\u27e8214\u27e9`full`\n    An argument in a function signature: the `n: usize` in `fn f(n: usize)`.\n\nForeignItem\u27e8215\u27e9`full`\n    An item within an `extern` block.\n\nGenericArgument\u27e8216\u27e9`full` or `derive`\n    An individual generic argument, like `'a`, `T`, or `Item = T`.\n\nGenericParam\u27e8217\u27e9`full` or `derive`\n    A generic type parameter, lifetime, or const generic: `T: Into<String>`, `'a: 'b`, `const LEN: usize`.\n\nImplItem\u27e8218\u27e9`full`\n    An item within an impl block.\n\nImplRestriction\u27e8219\u27e9`full`\n    Unused, but reserved for RFC 3323 restrictions.\n\nItem\u27e88\u27e9`full`\n    Things that can appear directly inside of a module or scope.\n\nLit\u27e8220\u27e9\n    A Rust literal such as a string or integer or boolean.\n\nMacroDelimiter\u27e8221\u27e9`full` or `derive`\n    A grouping token that surrounds a macro body: `m!(...)` or `m!{...}` or `m![...]`.\n\nMember\u27e8222\u27e9`full` or `derive`\n    A struct or tuple struct field accessed in a struct literal or field expression.\n\nMeta\u27e8223\u27e9`full` or `derive`\n    Content of a compile-time structured attribute.\n\nPat\u27e8224\u27e9`full`\n    A pattern in a local binding, function signature, match expression, or various other places.\n\nPathArguments\u27e8225\u27e9`full` or `derive`\n    Angle bracketed or parenthesized arguments of a path segment.\n\nPointerMutability\u27e8226\u27e9`full`\n    Mutability of a raw pointer (`*const T`, `*mut T`), in which non-mutable isn\u2019t the implicit default.\n\nRangeLimits\u27e8227\u27e9`full`\n    Limit types of a range, inclusive or exclusive.\n\nReturnType\u27e8228\u27e9`full` or `derive`\n    Return type of a function signature.\n\nStaticMutability\u27e8229\u27e9`full`\n    The mutability of an `Item::Static` or `ForeignItem::Static`.\n\nStmt\u27e8230\u27e9`full`\n    A statement, usually ending in a semicolon.\n\nTraitBoundModifier\u27e8231\u27e9`full` or `derive`\n    A modifier on a trait bound, currently only used for the `?` in `?Sized`.\n\nTraitItem\u27e8232\u27e9`full`\n    An item declaration within the definition of a trait.\n\nType\u27e810\u27e9`full` or `derive`\n    The possible types that a Rust value could have.\n\nTypeParamBound\u27e8233\u27e9`full` or `derive`\n    A trait or lifetime used as a bound on a type parameter.\n\nUnOp\u27e8234\u27e9`full` or `derive`\n    A unary operator: `*`, `!`, `-`.\n\nUseTree\u27e8235\u27e9`full`\n    A suffix of an import tree in a `use` item: `Type as Renamed` or `*`.\n\nVisibility\u27e8236\u27e9`full` or `derive`\n    The visibility level of an item: inherited or `pub` or `pub(restricted)`.\n\nWherePredicate\u27e8237\u27e9`full` or `derive`\n    A single predicate in a `where` clause: `T: Deserialize<'de>`.\n## Functions\u00a7\u27e8238\u27e9\n\nparse\u27e8239\u27e9`parsing` and `proc-macro`\n    Parse tokens of source code into the chosen syntax tree node.\n\nparse2\u27e8240\u27e9`parsing`\n    Parse a proc-macro2 token stream into the chosen syntax tree node.\n\nparse_file\u27e8241\u27e9`parsing` and `full`\n    Parse the content of a file of Rust code.\n\nparse_str\u27e8242\u27e9`parsing`\n    Parse a string of Rust code into the chosen syntax tree node.\n## Type Aliases\u00a7\u27e8243\u27e9\n\nResult\u27e8244\u27e9\n    The result of a Syn parser.\n",
              "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/syn/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/syn/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/syn/latest/src/syn/lib.rs.html#1-1011: Source\n\u27e84\u27e9 https://img.shields.io/badge/github-8da0cb?style=for-the-badge&labelColor=555555&logo=github: ![github\n\u27e85\u27e9 https://img.shields.io/badge/crates.io-fc8d62?style=for-the-badge&labelColor=555555&logo=rust: ![crates-io\n\u27e86\u27e9 https://img.shields.io/badge/docs.rs-66c2a5?style=for-the-badge&labelColor=555555&logo=docs.rs: ![docs-rs\n\u27e87\u27e9 https://docs.rs/syn/latest/syn/struct.File.html: struct syn::File - `syn::File`\n\u27e88\u27e9 https://docs.rs/syn/latest/syn/enum.Item.html: enum syn::Item - `syn::Item`\n\u27e89\u27e9 https://docs.rs/syn/latest/syn/enum.Expr.html: enum syn::Expr - `syn::Expr`\n\u27e810\u27e9 https://docs.rs/syn/latest/syn/enum.Type.html: enum syn::Type - `syn::Type`\n\u27e811\u27e9 https://docs.rs/syn/latest/syn/struct.DeriveInput.html: struct syn::DeriveInput - `syn::DeriveInput`\n\u27e812\u27e9 https://docs.rs/syn/latest/syn/parse/index.html: mod syn::parse - parser functions\n\u27e813\u27e9 https://docs.rs/syn/latest/syn/#example-of-a-derive-macro: \u00a7\n\u27e814\u27e9 https://github.com/dtolnay/syn/tree/master/examples/heapsize: `heapsize`\n\u27e815\u27e9 https://docs.rs/syn/latest/syn/#spans-and-error-reporting: \u00a7\n\u27e816\u27e9 https://docs.rs/syn/latest/syn/#parsing-a-custom-syntax: \u00a7\n\u27e817\u27e9 https://github.com/dtolnay/syn/tree/master/examples/lazy-static: `lazy-static`\n\u27e818\u27e9 https://docs.rs/syn/latest/syn/#testing: \u00a7\n\u27e819\u27e9 https://github.com/dtolnay/trybuild: `trybuild`\n\u27e820\u27e9 https://docs.rs/syn/latest/syn/#debugging: \u00a7\n\u27e821\u27e9 https://github.com/dtolnay/cargo-expand: `cargo expand`\n\u27e822\u27e9 https://quodlibetor.github.io/posts/debugging-rusts-new-custom-derive-system/: Debugging Rust\u2019s new Custom Derive system\n\u27e823\u27e9 https://docs.rs/syn/latest/syn/#optional-features: \u00a7\n\u27e824\u27e9 https://docs.rs/syn/latest/syn/#modules: \u00a7\n\u27e825\u27e9 https://docs.rs/syn/latest/syn/buffer/index.html: mod syn::buffer - buffer\n\u27e826\u27e9 https://docs.rs/syn/latest/syn/ext/index.html: mod syn::ext - ext\n\u27e827\u27e9 https://docs.rs/syn/latest/syn/fold/index.html: mod syn::fold - fold\n\u27e828\u27e9 https://docs.rs/syn/latest/syn/meta/index.html: mod syn::meta - meta\n\u27e829\u27e9 https://docs.rs/syn/latest/syn/punctuated/index.html: mod syn::punctuated - punctuated\n\u27e830\u27e9 https://docs.rs/syn/latest/syn/spanned/index.html: mod syn::spanned - spanned\n\u27e831\u27e9 https://docs.rs/syn/latest/syn/token/index.html: mod syn::token - token\n\u27e832\u27e9 https://docs.rs/syn/latest/syn/visit/index.html: mod syn::visit - visit\n\u27e833\u27e9 https://docs.rs/syn/latest/syn/visit_mut/index.html: mod syn::visit_mut - visit_mut\n\u27e834\u27e9 https://docs.rs/syn/latest/syn/#macros: \u00a7\n\u27e835\u27e9 https://docs.rs/syn/latest/syn/macro.Token.html: macro syn::Token - Token\n\u27e836\u27e9 https://docs.rs/syn/latest/syn/macro.braced.html: macro syn::braced - braced\n\u27e837\u27e9 https://docs.rs/syn/latest/syn/macro.bracketed.html: macro syn::bracketed - bracketed\n\u27e838\u27e9 https://docs.rs/syn/latest/syn/macro.custom_keyword.html: macro syn::custom_keyword - custom_keyword\n\u27e839\u27e9 https://docs.rs/syn/latest/syn/macro.custom_punctuation.html: macro syn::custom_punctuation - custom_punctuation\n\u27e840\u27e9 https://docs.rs/syn/latest/syn/macro.parenthesized.html: macro syn::parenthesized - parenthesized\n\u27e841\u27e9 https://docs.rs/syn/latest/syn/macro.parse_macro_input.html: macro syn::parse_macro_input - parse_macro_input\n\u27e842\u27e9 https://docs.rs/syn/latest/syn/macro.parse_quote.html: macro syn::parse_quote - parse_quote\n\u27e843\u27e9 https://docs.rs/quote/1.0/quote/index.html: `quote!`\n\u27e844\u27e9 https://docs.rs/syn/latest/syn/macro.parse_quote_spanned.html: macro syn::parse_quote_spanned - parse_quote_spanned\n\u27e845\u27e9 https://docs.rs/quote/1.0.40/x86_64-unknown-linux-gnu/quote/macro.quote_spanned.html: macro quote::quote_spanned - `quote_spanned!`\n\u27e846\u27e9 https://docs.rs/syn/latest/syn/#structs: \u00a7\n\u27e847\u27e9 https://docs.rs/syn/latest/syn/struct.Abi.html: struct syn::Abi - Abi\n\u27e848\u27e9 https://docs.rs/syn/latest/syn/struct.AngleBracketedGenericArguments.html: struct syn::AngleBracketedGenericArguments - AngleBracketedGenericArguments\n\u27e849\u27e9 https://docs.rs/syn/latest/syn/struct.Arm.html: struct syn::Arm - Arm\n\u27e850\u27e9 https://docs.rs/syn/latest/syn/struct.AssocConst.html: struct syn::AssocConst - AssocConst\n\u27e851\u27e9 https://docs.rs/syn/latest/syn/struct.AssocType.html: struct syn::AssocType - AssocType\n\u27e852\u27e9 https://docs.rs/syn/latest/syn/struct.Attribute.html: struct syn::Attribute - Attribute\n\u27e853\u27e9 https://docs.rs/syn/latest/syn/struct.BareFnArg.html: struct syn::BareFnArg - BareFnArg\n\u27e854\u27e9 https://docs.rs/syn/latest/syn/struct.BareVariadic.html: struct syn::BareVariadic - BareVariadic\n\u27e855\u27e9 https://docs.rs/syn/latest/syn/struct.Block.html: struct syn::Block - Block\n\u27e856\u27e9 https://docs.rs/syn/latest/syn/struct.BoundLifetimes.html: struct syn::BoundLifetimes - BoundLifetimes\n\u27e857\u27e9 https://docs.rs/syn/latest/syn/struct.ConstParam.html: struct syn::ConstParam - ConstParam\n\u27e858\u27e9 https://docs.rs/syn/latest/syn/struct.Constraint.html: struct syn::Constraint - Constraint\n\u27e859\u27e9 https://docs.rs/syn/latest/syn/struct.DataEnum.html: struct syn::DataEnum - DataEnum\n\u27e860\u27e9 https://docs.rs/syn/latest/syn/struct.DataStruct.html: struct syn::DataStruct - DataStruct\n\u27e861\u27e9 https://docs.rs/syn/latest/syn/struct.DataUnion.html: struct syn::DataUnion - DataUnion\n\u27e862\u27e9 https://docs.rs/syn/latest/syn/struct.Error.html: struct syn::Error - Error\n\u27e863\u27e9 https://docs.rs/syn/latest/syn/struct.ExprArray.html: struct syn::ExprArray - ExprArray\n\u27e864\u27e9 https://docs.rs/syn/latest/syn/struct.ExprAssign.html: struct syn::ExprAssign - ExprAssign\n\u27e865\u27e9 https://docs.rs/syn/latest/syn/struct.ExprAsync.html: struct syn::ExprAsync - ExprAsync\n\u27e866\u27e9 https://docs.rs/syn/latest/syn/struct.ExprAwait.html: struct syn::ExprAwait - ExprAwait\n\u27e867\u27e9 https://docs.rs/syn/latest/syn/struct.ExprBinary.html: struct syn::ExprBinary - ExprBinary\n\u27e868\u27e9 https://docs.rs/syn/latest/syn/struct.ExprBlock.html: struct syn::ExprBlock - ExprBlock\n\u27e869\u27e9 https://docs.rs/syn/latest/syn/struct.ExprBreak.html: struct syn::ExprBreak - ExprBreak\n\u27e870\u27e9 https://docs.rs/syn/latest/syn/struct.ExprCall.html: struct syn::ExprCall - ExprCall\n\u27e871\u27e9 https://docs.rs/syn/latest/syn/struct.ExprCast.html: struct syn::ExprCast - ExprCast\n\u27e872\u27e9 https://docs.rs/syn/latest/syn/struct.ExprClosure.html: struct syn::ExprClosure - ExprClosure\n\u27e873\u27e9 https://docs.rs/syn/latest/syn/struct.ExprConst.html: struct syn::ExprConst - ExprConst\n\u27e874\u27e9 https://docs.rs/syn/latest/syn/struct.ExprContinue.html: struct syn::ExprContinue - ExprContinue\n\u27e875\u27e9 https://docs.rs/syn/latest/syn/struct.ExprField.html: struct syn::ExprField - ExprField\n\u27e876\u27e9 https://docs.rs/syn/latest/syn/struct.ExprForLoop.html: struct syn::ExprForLoop - ExprForLoop\n\u27e877\u27e9 https://docs.rs/syn/latest/syn/struct.ExprGroup.html: struct syn::ExprGroup - ExprGroup\n\u27e878\u27e9 https://docs.rs/syn/latest/syn/struct.ExprIf.html: struct syn::ExprIf - ExprIf\n\u27e879\u27e9 https://docs.rs/syn/latest/syn/struct.ExprIndex.html: struct syn::ExprIndex - ExprIndex\n\u27e880\u27e9 https://docs.rs/syn/latest/syn/struct.ExprInfer.html: struct syn::ExprInfer - ExprInfer\n\u27e881\u27e9 https://docs.rs/syn/latest/syn/struct.ExprLet.html: struct syn::ExprLet - ExprLet\n\u27e882\u27e9 https://docs.rs/syn/latest/syn/struct.ExprLit.html: struct syn::ExprLit - ExprLit\n\u27e883\u27e9 https://docs.rs/syn/latest/syn/struct.ExprLoop.html: struct syn::ExprLoop - ExprLoop\n\u27e884\u27e9 https://docs.rs/syn/latest/syn/struct.ExprMacro.html: struct syn::ExprMacro - ExprMacro\n\u27e885\u27e9 https://docs.rs/syn/latest/syn/struct.ExprMatch.html: struct syn::ExprMatch - ExprMatch\n\u27e886\u27e9 https://docs.rs/syn/latest/syn/struct.ExprMethodCall.html: struct syn::ExprMethodCall - ExprMethodCall\n\u27e887\u27e9 https://docs.rs/syn/latest/syn/struct.ExprParen.html: struct syn::ExprParen - ExprParen\n\u27e888\u27e9 https://docs.rs/syn/latest/syn/struct.ExprPath.html: struct syn::ExprPath - ExprPath\n\u27e889\u27e9 https://docs.rs/syn/latest/syn/struct.ExprRange.html: struct syn::ExprRange - ExprRange\n\u27e890\u27e9 https://docs.rs/syn/latest/syn/struct.ExprRawAddr.html: struct syn::ExprRawAddr - ExprRawAddr\n\u27e891\u27e9 https://docs.rs/syn/latest/syn/struct.ExprReference.html: struct syn::ExprReference - ExprReference\n\u27e892\u27e9 https://docs.rs/syn/latest/syn/struct.ExprRepeat.html: struct syn::ExprRepeat - ExprRepeat\n\u27e893\u27e9 https://docs.rs/syn/latest/syn/struct.ExprReturn.html: struct syn::ExprReturn - ExprReturn\n\u27e894\u27e9 https://docs.rs/syn/latest/syn/struct.ExprStruct.html: struct syn::ExprStruct - ExprStruct\n\u27e895\u27e9 https://docs.rs/syn/latest/syn/struct.ExprTry.html: struct syn::ExprTry - ExprTry\n\u27e896\u27e9 https://docs.rs/syn/latest/syn/struct.ExprTryBlock.html: struct syn::ExprTryBlock - ExprTryBlock\n\u27e897\u27e9 https://docs.rs/syn/latest/syn/struct.ExprTuple.html: struct syn::ExprTuple - ExprTuple\n\u27e898\u27e9 https://docs.rs/syn/latest/syn/struct.ExprUnary.html: struct syn::ExprUnary - ExprUnary\n\u27e899\u27e9 https://docs.rs/syn/latest/syn/struct.ExprUnsafe.html: struct syn::ExprUnsafe - ExprUnsafe\n\u27e8100\u27e9 https://docs.rs/syn/latest/syn/struct.ExprWhile.html: struct syn::ExprWhile - ExprWhile\n\u27e8101\u27e9 https://docs.rs/syn/latest/syn/struct.ExprYield.html: struct syn::ExprYield - ExprYield\n\u27e8102\u27e9 https://docs.rs/syn/latest/syn/struct.Field.html: struct syn::Field - Field\n\u27e8103\u27e9 https://docs.rs/syn/latest/syn/struct.FieldPat.html: struct syn::FieldPat - FieldPat\n\u27e8104\u27e9 https://docs.rs/syn/latest/syn/struct.FieldValue.html: struct syn::FieldValue - FieldValue\n\u27e8105\u27e9 https://docs.rs/syn/latest/syn/struct.FieldsNamed.html: struct syn::FieldsNamed - FieldsNamed\n\u27e8106\u27e9 https://docs.rs/syn/latest/syn/struct.FieldsUnnamed.html: struct syn::FieldsUnnamed - FieldsUnnamed\n\u27e8107\u27e9 https://docs.rs/syn/latest/syn/struct.ForeignItemFn.html: struct syn::ForeignItemFn - ForeignItemFn\n\u27e8108\u27e9 https://docs.rs/syn/latest/syn/struct.ForeignItemMacro.html: struct syn::ForeignItemMacro - ForeignItemMacro\n\u27e8109\u27e9 https://docs.rs/syn/latest/syn/struct.ForeignItemStatic.html: struct syn::ForeignItemStatic - ForeignItemStatic\n\u27e8110\u27e9 https://docs.rs/syn/latest/syn/struct.ForeignItemType.html: struct syn::ForeignItemType - ForeignItemType\n\u27e8111\u27e9 https://docs.rs/syn/latest/syn/struct.Generics.html: struct syn::Generics - Generics\n\u27e8112\u27e9 https://docs.rs/syn/latest/syn/struct.Ident.html: struct syn::Ident - Ident\n\u27e8113\u27e9 https://docs.rs/syn/latest/syn/struct.ImplGenerics.html: struct syn::ImplGenerics - ImplGenerics\n\u27e8114\u27e9 https://docs.rs/syn/latest/syn/struct.ImplItemConst.html: struct syn::ImplItemConst - ImplItemConst\n\u27e8115\u27e9 https://docs.rs/syn/latest/syn/struct.ImplItemFn.html: struct syn::ImplItemFn - ImplItemFn\n\u27e8116\u27e9 https://docs.rs/syn/latest/syn/struct.ImplItemMacro.html: struct syn::ImplItemMacro - ImplItemMacro\n\u27e8117\u27e9 https://docs.rs/syn/latest/syn/struct.ImplItemType.html: struct syn::ImplItemType - ImplItemType\n\u27e8118\u27e9 https://docs.rs/syn/latest/syn/struct.Index.html: struct syn::Index - Index\n\u27e8119\u27e9 https://docs.rs/syn/latest/syn/struct.ItemConst.html: struct syn::ItemConst - ItemConst\n\u27e8120\u27e9 https://docs.rs/syn/latest/syn/struct.ItemEnum.html: struct syn::ItemEnum - ItemEnum\n\u27e8121\u27e9 https://docs.rs/syn/latest/syn/struct.ItemExternCrate.html: struct syn::ItemExternCrate - ItemExternCrate\n\u27e8122\u27e9 https://docs.rs/syn/latest/syn/struct.ItemFn.html: struct syn::ItemFn - ItemFn\n\u27e8123\u27e9 https://docs.rs/syn/latest/syn/struct.ItemForeignMod.html: struct syn::ItemForeignMod - ItemForeignMod\n\u27e8124\u27e9 https://docs.rs/syn/latest/syn/struct.ItemImpl.html: struct syn::ItemImpl - ItemImpl\n\u27e8125\u27e9 https://docs.rs/syn/latest/syn/struct.ItemMacro.html: struct syn::ItemMacro - ItemMacro\n\u27e8126\u27e9 https://docs.rs/syn/latest/syn/struct.ItemMod.html: struct syn::ItemMod - ItemMod\n\u27e8127\u27e9 https://docs.rs/syn/latest/syn/struct.ItemStatic.html: struct syn::ItemStatic - ItemStatic\n\u27e8128\u27e9 https://docs.rs/syn/latest/syn/struct.ItemStruct.html: struct syn::ItemStruct - ItemStruct\n\u27e8129\u27e9 https://docs.rs/syn/latest/syn/struct.ItemTrait.html: struct syn::ItemTrait - ItemTrait\n\u27e8130\u27e9 https://docs.rs/syn/latest/syn/struct.ItemTraitAlias.html: struct syn::ItemTraitAlias - ItemTraitAlias\n\u27e8131\u27e9 https://docs.rs/syn/latest/syn/struct.ItemType.html: struct syn::ItemType - ItemType\n\u27e8132\u27e9 https://docs.rs/syn/latest/syn/struct.ItemUnion.html: struct syn::ItemUnion - ItemUnion\n\u27e8133\u27e9 https://docs.rs/syn/latest/syn/struct.ItemUse.html: struct syn::ItemUse - ItemUse\n\u27e8134\u27e9 https://docs.rs/syn/latest/syn/struct.Label.html: struct syn::Label - Label\n\u27e8135\u27e9 https://docs.rs/syn/latest/syn/struct.Lifetime.html: struct syn::Lifetime - Lifetime\n\u27e8136\u27e9 https://docs.rs/syn/latest/syn/struct.LifetimeParam.html: struct syn::LifetimeParam - LifetimeParam\n\u27e8137\u27e9 https://docs.rs/syn/latest/syn/struct.LitBool.html: struct syn::LitBool - LitBool\n\u27e8138\u27e9 https://docs.rs/syn/latest/syn/struct.LitByte.html: struct syn::LitByte - LitByte\n\u27e8139\u27e9 https://docs.rs/syn/latest/syn/struct.LitByteStr.html: struct syn::LitByteStr - LitByteStr\n\u27e8140\u27e9 https://docs.rs/syn/latest/syn/struct.LitCStr.html: struct syn::LitCStr - LitCStr\n\u27e8141\u27e9 https://docs.rs/syn/latest/syn/struct.LitChar.html: struct syn::LitChar - LitChar\n\u27e8142\u27e9 https://docs.rs/syn/latest/syn/struct.LitFloat.html: struct syn::LitFloat - LitFloat\n\u27e8143\u27e9 https://docs.rs/syn/latest/syn/struct.LitInt.html: struct syn::LitInt - LitInt\n\u27e8144\u27e9 https://docs.rs/syn/latest/syn/struct.LitStr.html: struct syn::LitStr - LitStr\n\u27e8145\u27e9 https://docs.rs/syn/latest/syn/struct.Local.html: struct syn::Local - Local\n\u27e8146\u27e9 https://docs.rs/syn/latest/syn/struct.LocalInit.html: struct syn::LocalInit - LocalInit\n\u27e8147\u27e9 https://docs.rs/syn/latest/syn/struct.Macro.html: struct syn::Macro - Macro\n\u27e8148\u27e9 https://docs.rs/syn/latest/syn/struct.MetaList.html: struct syn::MetaList - MetaList\n\u27e8149\u27e9 https://docs.rs/syn/latest/syn/struct.MetaNameValue.html: struct syn::MetaNameValue - MetaNameValue\n\u27e8150\u27e9 https://docs.rs/syn/latest/syn/struct.ParenthesizedGenericArguments.html: struct syn::ParenthesizedGenericArguments - ParenthesizedGenericArguments\n\u27e8151\u27e9 https://docs.rs/syn/latest/syn/struct.PatConst.html: struct syn::PatConst - PatConst\n\u27e8152\u27e9 https://docs.rs/syn/latest/syn/struct.PatIdent.html: struct syn::PatIdent - PatIdent\n\u27e8153\u27e9 https://docs.rs/syn/latest/syn/struct.PatLit.html: struct syn::PatLit - PatLit\n\u27e8154\u27e9 https://docs.rs/syn/latest/syn/struct.PatMacro.html: struct syn::PatMacro - PatMacro\n\u27e8155\u27e9 https://docs.rs/syn/latest/syn/struct.PatOr.html: struct syn::PatOr - PatOr\n\u27e8156\u27e9 https://docs.rs/syn/latest/syn/struct.PatParen.html: struct syn::PatParen - PatParen\n\u27e8157\u27e9 https://docs.rs/syn/latest/syn/struct.PatPath.html: struct syn::PatPath - PatPath\n\u27e8158\u27e9 https://docs.rs/syn/latest/syn/struct.PatRange.html: struct syn::PatRange - PatRange\n\u27e8159\u27e9 https://docs.rs/syn/latest/syn/struct.PatReference.html: struct syn::PatReference - PatReference\n\u27e8160\u27e9 https://docs.rs/syn/latest/syn/struct.PatRest.html: struct syn::PatRest - PatRest\n\u27e8161\u27e9 https://docs.rs/syn/latest/syn/struct.PatSlice.html: struct syn::PatSlice - PatSlice\n\u27e8162\u27e9 https://docs.rs/syn/latest/syn/struct.PatStruct.html: struct syn::PatStruct - PatStruct\n\u27e8163\u27e9 https://docs.rs/syn/latest/syn/struct.PatTuple.html: struct syn::PatTuple - PatTuple\n\u27e8164\u27e9 https://docs.rs/syn/latest/syn/struct.PatTupleStruct.html: struct syn::PatTupleStruct - PatTupleStruct\n\u27e8165\u27e9 https://docs.rs/syn/latest/syn/struct.PatType.html: struct syn::PatType - PatType\n\u27e8166\u27e9 https://docs.rs/syn/latest/syn/struct.PatWild.html: struct syn::PatWild - PatWild\n\u27e8167\u27e9 https://docs.rs/syn/latest/syn/struct.Path.html: struct syn::Path - Path\n\u27e8168\u27e9 https://docs.rs/syn/latest/syn/struct.PathSegment.html: struct syn::PathSegment - PathSegment\n\u27e8169\u27e9 https://docs.rs/syn/latest/syn/struct.PreciseCapture.html: struct syn::PreciseCapture - PreciseCapture\n\u27e8170\u27e9 https://docs.rs/syn/latest/syn/struct.PredicateLifetime.html: struct syn::PredicateLifetime - PredicateLifetime\n\u27e8171\u27e9 https://docs.rs/syn/latest/syn/struct.PredicateType.html: struct syn::PredicateType - PredicateType\n\u27e8172\u27e9 https://docs.rs/syn/latest/syn/struct.QSelf.html: struct syn::QSelf - QSelf\n\u27e8173\u27e9 https://docs.rs/syn/latest/syn/struct.Receiver.html: struct syn::Receiver - Receiver\n\u27e8174\u27e9 https://docs.rs/syn/latest/syn/struct.Signature.html: struct syn::Signature - Signature\n\u27e8175\u27e9 https://docs.rs/syn/latest/syn/struct.StmtMacro.html: struct syn::StmtMacro - StmtMacro\n\u27e8176\u27e9 https://docs.rs/syn/latest/syn/struct.TraitBound.html: struct syn::TraitBound - TraitBound\n\u27e8177\u27e9 https://docs.rs/syn/latest/syn/struct.TraitItemConst.html: struct syn::TraitItemConst - TraitItemConst\n\u27e8178\u27e9 https://docs.rs/syn/latest/syn/struct.TraitItemFn.html: struct syn::TraitItemFn - TraitItemFn\n\u27e8179\u27e9 https://docs.rs/syn/latest/syn/struct.TraitItemMacro.html: struct syn::TraitItemMacro - TraitItemMacro\n\u27e8180\u27e9 https://docs.rs/syn/latest/syn/struct.TraitItemType.html: struct syn::TraitItemType - TraitItemType\n\u27e8181\u27e9 https://docs.rs/syn/latest/syn/struct.Turbofish.html: struct syn::Turbofish - Turbofish\n\u27e8182\u27e9 https://docs.rs/syn/latest/syn/struct.TypeArray.html: struct syn::TypeArray - TypeArray\n\u27e8183\u27e9 https://docs.rs/syn/latest/syn/struct.TypeBareFn.html: struct syn::TypeBareFn - TypeBareFn\n\u27e8184\u27e9 https://docs.rs/syn/latest/syn/struct.TypeGenerics.html: struct syn::TypeGenerics - TypeGenerics\n\u27e8185\u27e9 https://docs.rs/syn/latest/syn/struct.TypeGroup.html: struct syn::TypeGroup - TypeGroup\n\u27e8186\u27e9 https://docs.rs/syn/latest/syn/struct.TypeImplTrait.html: struct syn::TypeImplTrait - TypeImplTrait\n\u27e8187\u27e9 https://docs.rs/syn/latest/syn/struct.TypeInfer.html: struct syn::TypeInfer - TypeInfer\n\u27e8188\u27e9 https://docs.rs/syn/latest/syn/struct.TypeMacro.html: struct syn::TypeMacro - TypeMacro\n\u27e8189\u27e9 https://docs.rs/syn/latest/syn/struct.TypeNever.html: struct syn::TypeNever - TypeNever\n\u27e8190\u27e9 https://docs.rs/syn/latest/syn/struct.TypeParam.html: struct syn::TypeParam - TypeParam\n\u27e8191\u27e9 https://docs.rs/syn/latest/syn/struct.TypeParen.html: struct syn::TypeParen - TypeParen\n\u27e8192\u27e9 https://docs.rs/syn/latest/syn/struct.TypePath.html: struct syn::TypePath - TypePath\n\u27e8193\u27e9 https://docs.rs/syn/latest/syn/struct.TypePtr.html: struct syn::TypePtr - TypePtr\n\u27e8194\u27e9 https://docs.rs/syn/latest/syn/struct.TypeReference.html: struct syn::TypeReference - TypeReference\n\u27e8195\u27e9 https://docs.rs/syn/latest/syn/struct.TypeSlice.html: struct syn::TypeSlice - TypeSlice\n\u27e8196\u27e9 https://docs.rs/syn/latest/syn/struct.TypeTraitObject.html: struct syn::TypeTraitObject - TypeTraitObject\n\u27e8197\u27e9 https://docs.rs/syn/latest/syn/struct.TypeTuple.html: struct syn::TypeTuple - TypeTuple\n\u27e8198\u27e9 https://docs.rs/syn/latest/syn/struct.UseGlob.html: struct syn::UseGlob - UseGlob\n\u27e8199\u27e9 https://docs.rs/syn/latest/syn/struct.UseGroup.html: struct syn::UseGroup - UseGroup\n\u27e8200\u27e9 https://docs.rs/syn/latest/syn/struct.UseName.html: struct syn::UseName - UseName\n\u27e8201\u27e9 https://docs.rs/syn/latest/syn/struct.UsePath.html: struct syn::UsePath - UsePath\n\u27e8202\u27e9 https://docs.rs/syn/latest/syn/struct.UseRename.html: struct syn::UseRename - UseRename\n\u27e8203\u27e9 https://docs.rs/syn/latest/syn/struct.Variadic.html: struct syn::Variadic - Variadic\n\u27e8204\u27e9 https://docs.rs/syn/latest/syn/struct.Variant.html: struct syn::Variant - Variant\n\u27e8205\u27e9 https://docs.rs/syn/latest/syn/struct.VisRestricted.html: struct syn::VisRestricted - VisRestricted\n\u27e8206\u27e9 https://docs.rs/syn/latest/syn/struct.WhereClause.html: struct syn::WhereClause - WhereClause\n\u27e8207\u27e9 https://docs.rs/syn/latest/syn/#enums: \u00a7\n\u27e8208\u27e9 https://docs.rs/syn/latest/syn/enum.AttrStyle.html: enum syn::AttrStyle - AttrStyle\n\u27e8209\u27e9 https://docs.rs/syn/latest/syn/enum.BinOp.html: enum syn::BinOp - BinOp\n\u27e8210\u27e9 https://docs.rs/syn/latest/syn/enum.CapturedParam.html: enum syn::CapturedParam - CapturedParam\n\u27e8211\u27e9 https://docs.rs/syn/latest/syn/enum.Data.html: enum syn::Data - Data\n\u27e8212\u27e9 https://docs.rs/syn/latest/syn/enum.FieldMutability.html: enum syn::FieldMutability - FieldMutability\n\u27e8213\u27e9 https://docs.rs/syn/latest/syn/enum.Fields.html: enum syn::Fields - Fields\n\u27e8214\u27e9 https://docs.rs/syn/latest/syn/enum.FnArg.html: enum syn::FnArg - FnArg\n\u27e8215\u27e9 https://docs.rs/syn/latest/syn/enum.ForeignItem.html: enum syn::ForeignItem - ForeignItem\n\u27e8216\u27e9 https://docs.rs/syn/latest/syn/enum.GenericArgument.html: enum syn::GenericArgument - GenericArgument\n\u27e8217\u27e9 https://docs.rs/syn/latest/syn/enum.GenericParam.html: enum syn::GenericParam - GenericParam\n\u27e8218\u27e9 https://docs.rs/syn/latest/syn/enum.ImplItem.html: enum syn::ImplItem - ImplItem\n\u27e8219\u27e9 https://docs.rs/syn/latest/syn/enum.ImplRestriction.html: enum syn::ImplRestriction - ImplRestriction\n\u27e8220\u27e9 https://docs.rs/syn/latest/syn/enum.Lit.html: enum syn::Lit - Lit\n\u27e8221\u27e9 https://docs.rs/syn/latest/syn/enum.MacroDelimiter.html: enum syn::MacroDelimiter - MacroDelimiter\n\u27e8222\u27e9 https://docs.rs/syn/latest/syn/enum.Member.html: enum syn::Member - Member\n\u27e8223\u27e9 https://docs.rs/syn/latest/syn/enum.Meta.html: enum syn::Meta - Meta\n\u27e8224\u27e9 https://docs.rs/syn/latest/syn/enum.Pat.html: enum syn::Pat - Pat\n\u27e8225\u27e9 https://docs.rs/syn/latest/syn/enum.PathArguments.html: enum syn::PathArguments - PathArguments\n\u27e8226\u27e9 https://docs.rs/syn/latest/syn/enum.PointerMutability.html: enum syn::PointerMutability - PointerMutability\n\u27e8227\u27e9 https://docs.rs/syn/latest/syn/enum.RangeLimits.html: enum syn::RangeLimits - RangeLimits\n\u27e8228\u27e9 https://docs.rs/syn/latest/syn/enum.ReturnType.html: enum syn::ReturnType - ReturnType\n\u27e8229\u27e9 https://docs.rs/syn/latest/syn/enum.StaticMutability.html: enum syn::StaticMutability - StaticMutability\n\u27e8230\u27e9 https://docs.rs/syn/latest/syn/enum.Stmt.html: enum syn::Stmt - Stmt\n\u27e8231\u27e9 https://docs.rs/syn/latest/syn/enum.TraitBoundModifier.html: enum syn::TraitBoundModifier - TraitBoundModifier\n\u27e8232\u27e9 https://docs.rs/syn/latest/syn/enum.TraitItem.html: enum syn::TraitItem - TraitItem\n\u27e8233\u27e9 https://docs.rs/syn/latest/syn/enum.TypeParamBound.html: enum syn::TypeParamBound - TypeParamBound\n\u27e8234\u27e9 https://docs.rs/syn/latest/syn/enum.UnOp.html: enum syn::UnOp - UnOp\n\u27e8235\u27e9 https://docs.rs/syn/latest/syn/enum.UseTree.html: enum syn::UseTree - UseTree\n\u27e8236\u27e9 https://docs.rs/syn/latest/syn/enum.Visibility.html: enum syn::Visibility - Visibility\n\u27e8237\u27e9 https://docs.rs/syn/latest/syn/enum.WherePredicate.html: enum syn::WherePredicate - WherePredicate\n\u27e8238\u27e9 https://docs.rs/syn/latest/syn/#functions: \u00a7\n\u27e8239\u27e9 https://docs.rs/syn/latest/syn/fn.parse.html: fn syn::parse - parse\n\u27e8240\u27e9 https://docs.rs/syn/latest/syn/fn.parse2.html: fn syn::parse2 - parse2\n\u27e8241\u27e9 https://docs.rs/syn/latest/syn/fn.parse_file.html: fn syn::parse_file - parse_file\n\u27e8242\u27e9 https://docs.rs/syn/latest/syn/fn.parse_str.html: fn syn::parse_str - parse_str\n\u27e8243\u27e9 https://docs.rs/syn/latest/syn/#types: \u00a7\n\u27e8244\u27e9 https://docs.rs/syn/latest/syn/type.Result.html: type syn::Result - Result\n",
              "fit_markdown": "",
              "fit_html": ""
            },
            "structured_data": {},
            "quality_score": 4.0,
            "extraction_method": "crawl4ai",
            "error": null,
            "metadata": {
              "doc_type": "docs",
              "content_length": 44677,
              "has_structured_data": false,
              "crawl_success": true
            },
            "timestamp": "117471.8180694"
          },
          "lib_rs": {
            "url": "https://lib.rs/crates/syn",
            "title": "Untitled",
            "content": {
              "raw_markdown": "###  [320 releases](https://lib.rs/crates/syn/versions) (213 stable)\n2.0.104 |  Jun 20, 2025   \n---|---  \n2.0.101 |  Apr 26, 2025   \n2.0.100 |  Mar 9, 2025   \n2.0.93 |  Dec 28, 2024   \n0.10.3 |  ~~Nov 11, 2016~~  \n#**1** in [Procedural macros](https://lib.rs/development-tools/procedural-macro-helpers \"Crates to help you write procedural macros in Rust.\n\")\nDownload history 9954714/week @ 2025-03-10 10508083/week @ 2025-03-17 10325983/week @ 2025-03-24 9995708/week @ 2025-03-31 10598323/week @ 2025-04-07 9661778/week @ 2025-04-14 9117497/week @ 2025-04-21 9564277/week @ 2025-04-28 9349901/week @ 2025-05-05 9803845/week @ 2025-05-12 9767685/week @ 2025-05-19 8201040/week @ 2025-05-26 8655780/week @ 2025-06-02 10116207/week @ 2025-06-09 11626003/week @ 2025-06-16 10190859/week @ 2025-06-23\n**41,111,469** downloads per month Used in [**125,424** crates (11,460 directly)](https://lib.rs/crates/syn/rev)\n**MIT/Apache**\n1.5MB  **42K** SLoC\n# Parser for Rust source code\n[![github](https://img.shields.io/badge/github-dtolnay/syn-8da0cb?style=for-the-badge&labelColor=555555&logo=github)](https://github.com/dtolnay/syn) [![crates.io](https://img.shields.io/crates/v/syn.svg?style=for-the-badge&color=fc8d62&logo=rust)](https://crates.io/crates/syn) [![docs.rs](https://img.shields.io/badge/docs.rs-syn-66c2a5?style=for-the-badge&labelColor=555555&logo=docs.rs)](https://docs.rs/syn) [![build status](https://img.shields.io/github/actions/workflow/status/dtolnay/syn/ci.yml?branch=master&style=for-the-badge)](https://github.com/dtolnay/syn/actions?query=branch%3Amaster)\nSyn is a parsing library for parsing a stream of Rust tokens into a syntax tree of Rust source code.\nCurrently this library is geared toward use in Rust procedural macros, but contains some APIs that may be useful more generally.\n  * **Data structures** \u2014 Syn provides a complete syntax tree that can represent any valid Rust source code. The syntax tree is rooted at [```syn`::``File``](https://docs.rs/syn/2.0/syn/struct.File.html) which represents a full source file, but there are other entry points that may be useful to procedural macros including [```syn`::``Item``](https://docs.rs/syn/2.0/syn/enum.Item.html), [```syn`::``Expr``](https://docs.rs/syn/2.0/syn/enum.Expr.html) and [```syn`::``Type``](https://docs.rs/syn/2.0/syn/enum.Type.html).\n  * **Derives** \u2014 Of particular interest to derive macros is [```syn`::``DeriveInput``](https://docs.rs/syn/2.0/syn/struct.DeriveInput.html) which is any of the three legal input items to a derive macro. An example below shows using this type in a library that can derive implementations of a user-defined trait.\n  * **Parsing** \u2014 Parsing in Syn is built around [parser functions](https://docs.rs/syn/2.0/syn/parse/index.html) with the signature ```fn``(`ParseStream`)` ``->` ``Result``<`T`>`````. Every syntax tree node defined by Syn is individually parsable and may be used as a building block for custom syntaxes, or you may dream up your own brand new syntax without involving any of our syntax tree types.\n  * **Location information** \u2014 Every token parsed by Syn is associated with a ``Span`` that tracks line and column information back to the source of that token. These spans allow a procedural macro to display detailed error messages pointing to all the right places in the user's code. There is an example of this below.\n  * **Feature flags** \u2014 Functionality is aggressively feature gated so your procedural macros enable only what they need, and do not pay in compile time for all the rest.\n\n\n_Version requirement: Syn supports rustc 1.61 and up._\n[_Release notes_](https://github.com/dtolnay/syn/releases)\n## Resources\nThe best way to learn about procedural macros is by writing some. Consider working through [this procedural macro workshop](https://github.com/dtolnay/proc-macro-workshop) to get familiar with the different types of procedural macros. The workshop contains relevant links into the Syn documentation as you work through each project.\n## Example of a derive macro\nThe canonical derive macro using Syn looks like this. We write an ordinary Rust function tagged with a ``proc_macro_derive`` attribute and the name of the trait we are deriving. Any time that derive appears in the user's code, the Rust compiler passes their data structure as tokens into our macro. We get to execute arbitrary Rust code to figure out what to do with those tokens, then hand some tokens back to the compiler to compile into the user's crate.\n```\n```[``dependencies``]`\n`syn ``=` ``\"`2.0`\"``\n`quote ``=` ``\"`1.0`\"``\n```[``lib``]`\n`proc-macro ``=` `true`\n``\n```\n```\n``use` `proc_macro`::``TokenStream`;`\n`use` `quote`::``quote`;`\n`use` `syn`::````{`parse_macro_input`,` DeriveInput```}```;`\n``#``[``proc_macro_derive```(```MyMacro```)```]``\n``pub` `fn` `my_macro`````(``input``:` TokenStream```)```` ``->` TokenStream` ````{`\n  ``//` Parse the input tokens into a syntax tree`\n  `let` input `=` `parse_macro_input!``(`input `as` DeriveInput`)``;`\n  ``//` Build the output, possibly using quasi-quotation`\n  `let` expanded `=` `quote!` `{`\n    ``//` ...`\n  `}``;`\n  ``//` Hand the output tokens back to the compiler`\n  `TokenStream`::``from`(`expanded`)`\n```}```\n`\n```\n\nThe [``heapsize``](https://github.com/dtolnay/syn/blob/2283a9852a5ae363a72ac09e5897d7f2f89157b2/examples/heapsize) example directory shows a complete working implementation of a derive macro. The example derives a ``HeapSize`` trait which computes an estimate of the amount of heap memory owned by a value.\n```\n```pub` `trait` `HeapSize` ``{`\n  ``///` Total number of bytes of heap memory owned by `self`.`\n  ``fn` `heap_size_of_children`````(``&``self````)```` ``->` `usize````;`\n```}```\n`\n```\n\nThe derive macro allows users to write ````#``[``derive```(```HeapSize```)```]```` on data structures in their program.\n```\n```#``[``derive```(```HeapSize```)```]``\n``struct` ````Demo``<``'a`, T`:` `?````Sized> ````{`\n  `a``:` ``Box``<`T`>``,\n  `b``:` `u8`,\n  `c``:` `&``'a` `str`,\n  `d``:` String,\n```}```\n`\n```\n\n## Spans and error reporting\nThe token-based procedural macro API provides great control over where the compiler's error messages are displayed in user code. Consider the error the user sees if one of their field types does not implement ``HeapSize``.\n```\n```#``[``derive```(```HeapSize```)```]``\n``struct` ```Broken` ````{`\n  `ok``:` String,\n  `bad``:` `std`::```thread`::``Thread,\n```}```\n`\n```\n\nBy tracking span information all the way through the expansion of a procedural macro as shown in the ``heapsize`` example, token-based macros in Syn are able to trigger errors that directly pinpoint the source of the problem.\n```\n```error[E0277]:``` the trait bound `````std::thread::Thread:`` HeapSize``` is not satisfied`\n ``--````>` src/main.rs:7:5\n` `|`\n``7`` `|`   ``bad:``` std::thread::Thread,`\n `|`   ``^^^^^^^^^^^^^^^^^^^^^^^^``` the trait `````HeapSize````` is not implemented for `````std::thread::Thread``````\n`\n```\n\n## Parsing a custom syntax\nThe [``lazy-static``](https://github.com/dtolnay/syn/blob/2283a9852a5ae363a72ac09e5897d7f2f89157b2/examples/lazy-static) example directory shows the implementation of a ```functionlike!``(``...``)``` procedural macro in which the input tokens are parsed using Syn's parsing API.\nThe example reimplements the popular ``lazy_static`` crate from crates.io as a procedural macro.\n```\n``lazy_static!` ``{`\n  `static` `ref` `USERNAME``:` Regex `=` `Regex`::``new`(```\"`^[a-z0-9_-]{3,16}$`\"```)``.``unwrap``(``)``;`\n```}``\n`\n```\n\nThe implementation shows how to trigger custom warnings and error messages on the macro input.\n```\n```warning:``` come on, pick a more creative name`\n ``--````>` src/main.rs:10:16\n`  `|`\n``10`` `|`   ``static``` ref FOO: String = ``\"`lazy_static`\"``.to_owned(`)`;`\n  `|`        ``^^^``\n`\n```\n\n## Testing\nWhen testing macros, we often care not just that the macro can be used successfully but also that when the macro is provided with invalid input it produces maximally helpful error messages. Consider using the [``trybuild``](https://github.com/dtolnay/trybuild) crate to write tests for errors that are emitted by your macro or errors detected by the Rust compiler in the expanded code following misuse of the macro. Such tests help avoid regressions from later refactors that mistakenly make an error no longer trigger or be less helpful than it used to be.\n## Debugging\nWhen developing a procedural macro it can be helpful to look at what the generated code looks like. Use ````cargo``` rustc` --``` -Zunstable-options --pretty=expanded``` or the [````cargo``` expand```](https://github.com/dtolnay/cargo-expand) subcommand.\nTo show the expanded code for some crate that uses your procedural macro, run ````cargo``` expand``` from that crate. To show the expanded code for one of your own test cases, run ````cargo``` expand`` --`test` the_test_case``` where the last argument is the name of the test file without the ``.rs`` extension.\nThis write-up by Brandon W Maister discusses debugging in more detail: [Debugging Rust's new Custom Derive system](https://quodlibetor.github.io/posts/debugging-rusts-new-custom-derive-system/).\n## Optional features\nSyn puts a lot of functionality behind optional features in order to optimize compile time for the most common use cases. The following features are available.\n  * **``derive``**_(enabled by default)_ \u2014 Data structures for representing the possible input to a derive macro, including structs and enums and types.\n  * **``full``**\u2014 Data structures for representing the syntax tree of all valid Rust source code, including items and expressions.\n  * **``parsing``**_(enabled by default)_ \u2014 Ability to parse input tokens into a syntax tree node of a chosen type.\n  * **``printing``**_(enabled by default)_ \u2014 Ability to print a syntax tree node as tokens of Rust source code.\n  * **``visit``**\u2014 Trait for traversing a syntax tree.\n  * **``visit-mut``**\u2014 Trait for traversing and mutating in place a syntax tree.\n  * **``fold``**\u2014 Trait for transforming an owned syntax tree.\n  * **``clone-impls``**_(enabled by default)_ \u2014 Clone impls for all syntax tree types.\n  * **``extra-traits``**\u2014 Debug, Eq, PartialEq, Hash impls for all syntax tree types.\n  * **``proc-macro``**_(enabled by default)_ \u2014 Runtime dependency on the dynamic library libproc_macro from rustc toolchain.\n\n\n## Proc macro shim\nSyn operates on the token representation provided by the [proc-macro2](https://docs.rs/proc-macro2/1.0/proc_macro2/) crate from crates.io rather than using the compiler's built in proc-macro crate directly. This enables code using Syn to execute outside of the context of a procedural macro, such as in unit tests or build.rs, and we avoid needing incompatible ecosystems for proc macros vs non-macro use cases.\nIn general all of your code should be written against proc-macro2 rather than proc-macro. The one exception is in the signatures of procedural macro entry points, which are required by the language to use ```proc_macro`::``TokenStream``.\nThe proc-macro2 crate will automatically detect and use the compiler's data structures when a procedural macro is active.\n#### License\nLicensed under either of [Apache License, Version 2.0](https://github.com/dtolnay/syn/blob/2283a9852a5ae363a72ac09e5897d7f2f89157b2/LICENSE-APACHE) or [MIT license](https://github.com/dtolnay/syn/blob/2283a9852a5ae363a72ac09e5897d7f2f89157b2/LICENSE-MIT) at your option.  Unless you explicitly state otherwise, any contribution intentionally submitted for inclusion in this crate by you, as defined in the Apache-2.0 license, shall be dual licensed as above, without any additional terms or conditions. \n#### Dependencies\n  * [proc-macro2](https://lib.rs/crates/proc-macro2 \"1.0.91\")\n  * [printing](https://lib.rs/crates/syn/features#feature-printing \"default feature\") [proc-macro](https://lib.rs/crates/syn/features#feature-proc-macro \"default feature\") [quote](https://lib.rs/crates/quote \"1.0.35\")\n  * [unicode-ident](https://lib.rs/crates/unicode-ident \"1\")\n\n\n  * dev  [anyhow](https://lib.rs/crates/anyhow \"1\")\n  * dev  [automod](https://lib.rs/crates/automod \"1\")\n  * dev  [flate2](https://lib.rs/crates/flate2 \"1\") not miri\n  * dev  [insta](https://lib.rs/crates/insta \"1\")\n  * dev  [rayon](https://lib.rs/crates/rayon \"1\") not miri\n  * dev  [ref-cast](https://lib.rs/crates/ref-cast \"1\")\n  * dev  [reqwest](https://lib.rs/crates/reqwest \"new\") 0.12[+blocking](https://lib.rs/crates/reqwest/features#feature-blocking) not miri\n  * dev  [rustversion](https://lib.rs/crates/rustversion \"1\")\n  * dev  [syn-test-suite](https://lib.rs/crates/syn-test-suite \"0\")\n  * dev  [tar](https://lib.rs/crates/tar \"0.4.16\") not miri\n  * dev  [termcolor](https://lib.rs/crates/termcolor \"1\")\n  * dev  [walkdir](https://lib.rs/crates/walkdir \"2.3.2\") not miri\n\n\n#### [Other features](https://lib.rs/crates/syn/features)\n  * [clone-impls](https://lib.rs/crates/syn/features#feature-clone-impls)\n  * [derive](https://lib.rs/crates/syn/features#feature-derive)\n  * [extra-traits](https://lib.rs/crates/syn/features#feature-extra-traits)\n  * [fold](https://lib.rs/crates/syn/features#feature-fold)\n  * [full](https://lib.rs/crates/syn/features#feature-full)\n  * [parsing](https://lib.rs/crates/syn/features#feature-parsing)\n  * [test](https://lib.rs/crates/syn/features#feature-test)\n  * [visit](https://lib.rs/crates/syn/features#feature-visit)\n  * [visit-mut](https://lib.rs/crates/syn/features#feature-visit-mut)\n\n\n  *[SLoC]: Lines of code, excluding comments\n",
              "markdown_with_citations": "###  320 releases\u27e81\u27e9 (213 stable)\n2.0.104 |  Jun 20, 2025   \n---|---  \n2.0.101 |  Apr 26, 2025   \n2.0.100 |  Mar 9, 2025   \n2.0.93 |  Dec 28, 2024   \n0.10.3 |  ~~Nov 11, 2016~~  \n#**1** in Procedural macros\u27e82\u27e9\nDownload history 9954714/week @ 2025-03-10 10508083/week @ 2025-03-17 10325983/week @ 2025-03-24 9995708/week @ 2025-03-31 10598323/week @ 2025-04-07 9661778/week @ 2025-04-14 9117497/week @ 2025-04-21 9564277/week @ 2025-04-28 9349901/week @ 2025-05-05 9803845/week @ 2025-05-12 9767685/week @ 2025-05-19 8201040/week @ 2025-05-26 8655780/week @ 2025-06-02 10116207/week @ 2025-06-09 11626003/week @ 2025-06-16 10190859/week @ 2025-06-23\n**41,111,469** downloads per month Used in **125,424** crates (11,460 directly)\u27e83\u27e9\n**MIT/Apache**\n1.5MB  **42K** SLoC\n# Parser for Rust source code\n![github\u27e84\u27e9](https://github.com/dtolnay/syn) ![crates.io\u27e85\u27e9](https://crates.io/crates/syn) ![docs.rs\u27e86\u27e9](https://docs.rs/syn) ![build status\u27e87\u27e9](https://github.com/dtolnay/syn/actions?query=branch%3Amaster)\nSyn is a parsing library for parsing a stream of Rust tokens into a syntax tree of Rust source code.\nCurrently this library is geared toward use in Rust procedural macros, but contains some APIs that may be useful more generally.\n  * **Data structures** \u2014 Syn provides a complete syntax tree that can represent any valid Rust source code. The syntax tree is rooted at ```syn`::``File``\u27e88\u27e9 which represents a full source file, but there are other entry points that may be useful to procedural macros including ```syn`::``Item``\u27e89\u27e9, ```syn`::``Expr``\u27e810\u27e9 and ```syn`::``Type``\u27e811\u27e9.\n  * **Derives** \u2014 Of particular interest to derive macros is ```syn`::``DeriveInput``\u27e812\u27e9 which is any of the three legal input items to a derive macro. An example below shows using this type in a library that can derive implementations of a user-defined trait.\n  * **Parsing** \u2014 Parsing in Syn is built around parser functions\u27e813\u27e9 with the signature ```fn``(`ParseStream`)` ``->` ``Result``<`T`>`````. Every syntax tree node defined by Syn is individually parsable and may be used as a building block for custom syntaxes, or you may dream up your own brand new syntax without involving any of our syntax tree types.\n  * **Location information** \u2014 Every token parsed by Syn is associated with a ``Span`` that tracks line and column information back to the source of that token. These spans allow a procedural macro to display detailed error messages pointing to all the right places in the user's code. There is an example of this below.\n  * **Feature flags** \u2014 Functionality is aggressively feature gated so your procedural macros enable only what they need, and do not pay in compile time for all the rest.\n\n\n_Version requirement: Syn supports rustc 1.61 and up._\n_Release notes_\u27e814\u27e9\n## Resources\nThe best way to learn about procedural macros is by writing some. Consider working through this procedural macro workshop\u27e815\u27e9 to get familiar with the different types of procedural macros. The workshop contains relevant links into the Syn documentation as you work through each project.\n## Example of a derive macro\nThe canonical derive macro using Syn looks like this. We write an ordinary Rust function tagged with a ``proc_macro_derive`` attribute and the name of the trait we are deriving. Any time that derive appears in the user's code, the Rust compiler passes their data structure as tokens into our macro. We get to execute arbitrary Rust code to figure out what to do with those tokens, then hand some tokens back to the compiler to compile into the user's crate.\n```\n```[``dependencies``]`\n`syn ``=` ``\"`2.0`\"``\n`quote ``=` ``\"`1.0`\"``\n```[``lib``]`\n`proc-macro ``=` `true`\n``\n```\n```\n``use` `proc_macro`::``TokenStream`;`\n`use` `quote`::``quote`;`\n`use` `syn`::````{`parse_macro_input`,` DeriveInput```}```;`\n``#``[``proc_macro_derive```(```MyMacro```)```]``\n``pub` `fn` `my_macro`````(``input``:` TokenStream```)```` ``->` TokenStream` ````{`\n  ``//` Parse the input tokens into a syntax tree`\n  `let` input `=` `parse_macro_input!``(`input `as` DeriveInput`)``;`\n  ``//` Build the output, possibly using quasi-quotation`\n  `let` expanded `=` `quote!` `{`\n    ``//` ...`\n  `}``;`\n  ``//` Hand the output tokens back to the compiler`\n  `TokenStream`::``from`(`expanded`)`\n```}```\n`\n```\n\nThe ``heapsize``\u27e816\u27e9 example directory shows a complete working implementation of a derive macro. The example derives a ``HeapSize`` trait which computes an estimate of the amount of heap memory owned by a value.\n```\n```pub` `trait` `HeapSize` ``{`\n  ``///` Total number of bytes of heap memory owned by `self`.`\n  ``fn` `heap_size_of_children`````(``&``self````)```` ``->` `usize````;`\n```}```\n`\n```\n\nThe derive macro allows users to write ````#``[``derive```(```HeapSize```)```]```` on data structures in their program.\n```\n```#``[``derive```(```HeapSize```)```]``\n``struct` ````Demo``<``'a`, T`:` `?````Sized> ````{`\n  `a``:` ``Box``<`T`>``,\n  `b``:` `u8`,\n  `c``:` `&``'a` `str`,\n  `d``:` String,\n```}```\n`\n```\n\n## Spans and error reporting\nThe token-based procedural macro API provides great control over where the compiler's error messages are displayed in user code. Consider the error the user sees if one of their field types does not implement ``HeapSize``.\n```\n```#``[``derive```(```HeapSize```)```]``\n``struct` ```Broken` ````{`\n  `ok``:` String,\n  `bad``:` `std`::```thread`::``Thread,\n```}```\n`\n```\n\nBy tracking span information all the way through the expansion of a procedural macro as shown in the ``heapsize`` example, token-based macros in Syn are able to trigger errors that directly pinpoint the source of the problem.\n```\n```error[E0277]:``` the trait bound `````std::thread::Thread:`` HeapSize``` is not satisfied`\n ``--````>` src/main.rs:7:5\n` `|`\n``7`` `|`   ``bad:``` std::thread::Thread,`\n `|`   ``^^^^^^^^^^^^^^^^^^^^^^^^``` the trait `````HeapSize````` is not implemented for `````std::thread::Thread``````\n`\n```\n\n## Parsing a custom syntax\nThe ``lazy-static``\u27e817\u27e9 example directory shows the implementation of a ```functionlike!``(``...``)``` procedural macro in which the input tokens are parsed using Syn's parsing API.\nThe example reimplements the popular ``lazy_static`` crate from crates.io as a procedural macro.\n```\n``lazy_static!` ``{`\n  `static` `ref` `USERNAME``:` Regex `=` `Regex`::``new`(```\"`^[a-z0-9_-]{3,16}$`\"```)``.``unwrap``(``)``;`\n```}``\n`\n```\n\nThe implementation shows how to trigger custom warnings and error messages on the macro input.\n```\n```warning:``` come on, pick a more creative name`\n ``--````>` src/main.rs:10:16\n`  `|`\n``10`` `|`   ``static``` ref FOO: String = ``\"`lazy_static`\"``.to_owned(`)`;`\n  `|`        ``^^^``\n`\n```\n\n## Testing\nWhen testing macros, we often care not just that the macro can be used successfully but also that when the macro is provided with invalid input it produces maximally helpful error messages. Consider using the ``trybuild``\u27e818\u27e9 crate to write tests for errors that are emitted by your macro or errors detected by the Rust compiler in the expanded code following misuse of the macro. Such tests help avoid regressions from later refactors that mistakenly make an error no longer trigger or be less helpful than it used to be.\n## Debugging\nWhen developing a procedural macro it can be helpful to look at what the generated code looks like. Use ````cargo``` rustc` --``` -Zunstable-options --pretty=expanded``` or the ````cargo``` expand```\u27e819\u27e9 subcommand.\nTo show the expanded code for some crate that uses your procedural macro, run ````cargo``` expand``` from that crate. To show the expanded code for one of your own test cases, run ````cargo``` expand`` --`test` the_test_case``` where the last argument is the name of the test file without the ``.rs`` extension.\nThis write-up by Brandon W Maister discusses debugging in more detail: Debugging Rust's new Custom Derive system\u27e820\u27e9.\n## Optional features\nSyn puts a lot of functionality behind optional features in order to optimize compile time for the most common use cases. The following features are available.\n  * **``derive``**_(enabled by default)_ \u2014 Data structures for representing the possible input to a derive macro, including structs and enums and types.\n  * **``full``**\u2014 Data structures for representing the syntax tree of all valid Rust source code, including items and expressions.\n  * **``parsing``**_(enabled by default)_ \u2014 Ability to parse input tokens into a syntax tree node of a chosen type.\n  * **``printing``**_(enabled by default)_ \u2014 Ability to print a syntax tree node as tokens of Rust source code.\n  * **``visit``**\u2014 Trait for traversing a syntax tree.\n  * **``visit-mut``**\u2014 Trait for traversing and mutating in place a syntax tree.\n  * **``fold``**\u2014 Trait for transforming an owned syntax tree.\n  * **``clone-impls``**_(enabled by default)_ \u2014 Clone impls for all syntax tree types.\n  * **``extra-traits``**\u2014 Debug, Eq, PartialEq, Hash impls for all syntax tree types.\n  * **``proc-macro``**_(enabled by default)_ \u2014 Runtime dependency on the dynamic library libproc_macro from rustc toolchain.\n\n\n## Proc macro shim\nSyn operates on the token representation provided by the proc-macro2\u27e821\u27e9 crate from crates.io rather than using the compiler's built in proc-macro crate directly. This enables code using Syn to execute outside of the context of a procedural macro, such as in unit tests or build.rs, and we avoid needing incompatible ecosystems for proc macros vs non-macro use cases.\nIn general all of your code should be written against proc-macro2 rather than proc-macro. The one exception is in the signatures of procedural macro entry points, which are required by the language to use ```proc_macro`::``TokenStream``.\nThe proc-macro2 crate will automatically detect and use the compiler's data structures when a procedural macro is active.\n#### License\nLicensed under either of Apache License, Version 2.0\u27e822\u27e9 or MIT license\u27e823\u27e9 at your option.  Unless you explicitly state otherwise, any contribution intentionally submitted for inclusion in this crate by you, as defined in the Apache-2.0 license, shall be dual licensed as above, without any additional terms or conditions. \n#### Dependencies\n  * proc-macro2\u27e824\u27e9\n  * printing\u27e825\u27e9 proc-macro\u27e826\u27e9 quote\u27e827\u27e9\n  * unicode-ident\u27e828\u27e9\n\n\n  * dev  anyhow\u27e829\u27e9\n  * dev  automod\u27e830\u27e9\n  * dev  flate2\u27e831\u27e9 not miri\n  * dev  insta\u27e832\u27e9\n  * dev  rayon\u27e833\u27e9 not miri\n  * dev  ref-cast\u27e834\u27e9\n  * dev  reqwest\u27e835\u27e9 0.12+blocking\u27e836\u27e9 not miri\n  * dev  rustversion\u27e837\u27e9\n  * dev  syn-test-suite\u27e838\u27e9\n  * dev  tar\u27e839\u27e9 not miri\n  * dev  termcolor\u27e840\u27e9\n  * dev  walkdir\u27e841\u27e9 not miri\n\n\n#### Other features\u27e842\u27e9\n  * clone-impls\u27e843\u27e9\n  * derive\u27e844\u27e9\n  * extra-traits\u27e845\u27e9\n  * fold\u27e846\u27e9\n  * full\u27e847\u27e9\n  * parsing\u27e848\u27e9\n  * test\u27e849\u27e9\n  * visit\u27e850\u27e9\n  * visit-mut\u27e851\u27e9\n\n\n  *[SLoC]: Lines of code, excluding comments\n",
              "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://lib.rs/crates/syn/versions: 320 releases\n\u27e82\u27e9 https://lib.rs/development-tools/procedural-macro-helpers: Crates to help you write procedural macros in Rust.\n - Procedural macros\n\u27e83\u27e9 https://lib.rs/crates/syn/rev: **125,424** crates (11,460 directly)\n\u27e84\u27e9 https://img.shields.io/badge/github-dtolnay/syn-8da0cb?style=for-the-badge&labelColor=555555&logo=github: ![github\n\u27e85\u27e9 https://img.shields.io/crates/v/syn.svg?style=for-the-badge&color=fc8d62&logo=rust: ![crates.io\n\u27e86\u27e9 https://img.shields.io/badge/docs.rs-syn-66c2a5?style=for-the-badge&labelColor=555555&logo=docs.rs: ![docs.rs\n\u27e87\u27e9 https://img.shields.io/github/actions/workflow/status/dtolnay/syn/ci.yml?branch=master&style=for-the-badge: ![build status\n\u27e88\u27e9 https://docs.rs/syn/2.0/syn/struct.File.html: ```syn`::``File``\n\u27e89\u27e9 https://docs.rs/syn/2.0/syn/enum.Item.html: ```syn`::``Item``\n\u27e810\u27e9 https://docs.rs/syn/2.0/syn/enum.Expr.html: ```syn`::``Expr``\n\u27e811\u27e9 https://docs.rs/syn/2.0/syn/enum.Type.html: ```syn`::``Type``\n\u27e812\u27e9 https://docs.rs/syn/2.0/syn/struct.DeriveInput.html: ```syn`::``DeriveInput``\n\u27e813\u27e9 https://docs.rs/syn/2.0/syn/parse/index.html: parser functions\n\u27e814\u27e9 https://github.com/dtolnay/syn/releases: _Release notes_\n\u27e815\u27e9 https://github.com/dtolnay/proc-macro-workshop: this procedural macro workshop\n\u27e816\u27e9 https://github.com/dtolnay/syn/blob/2283a9852a5ae363a72ac09e5897d7f2f89157b2/examples/heapsize: ``heapsize``\n\u27e817\u27e9 https://github.com/dtolnay/syn/blob/2283a9852a5ae363a72ac09e5897d7f2f89157b2/examples/lazy-static: ``lazy-static``\n\u27e818\u27e9 https://github.com/dtolnay/trybuild: ``trybuild``\n\u27e819\u27e9 https://github.com/dtolnay/cargo-expand: ````cargo``` expand```\n\u27e820\u27e9 https://quodlibetor.github.io/posts/debugging-rusts-new-custom-derive-system/: Debugging Rust's new Custom Derive system\n\u27e821\u27e9 https://docs.rs/proc-macro2/1.0/proc_macro2/: proc-macro2\n\u27e822\u27e9 https://github.com/dtolnay/syn/blob/2283a9852a5ae363a72ac09e5897d7f2f89157b2/LICENSE-APACHE: Apache License, Version 2.0\n\u27e823\u27e9 https://github.com/dtolnay/syn/blob/2283a9852a5ae363a72ac09e5897d7f2f89157b2/LICENSE-MIT: MIT license\n\u27e824\u27e9 https://lib.rs/crates/proc-macro2: 1.0.91 - proc-macro2\n\u27e825\u27e9 https://lib.rs/crates/syn/features#feature-printing: default feature - printing\n\u27e826\u27e9 https://lib.rs/crates/syn/features#feature-proc-macro: default feature - proc-macro\n\u27e827\u27e9 https://lib.rs/crates/quote: 1.0.35 - quote\n\u27e828\u27e9 https://lib.rs/crates/unicode-ident: 1 - unicode-ident\n\u27e829\u27e9 https://lib.rs/crates/anyhow: 1 - anyhow\n\u27e830\u27e9 https://lib.rs/crates/automod: 1 - automod\n\u27e831\u27e9 https://lib.rs/crates/flate2: 1 - flate2\n\u27e832\u27e9 https://lib.rs/crates/insta: 1 - insta\n\u27e833\u27e9 https://lib.rs/crates/rayon: 1 - rayon\n\u27e834\u27e9 https://lib.rs/crates/ref-cast: 1 - ref-cast\n\u27e835\u27e9 https://lib.rs/crates/reqwest: new - reqwest\n\u27e836\u27e9 https://lib.rs/crates/reqwest/features#feature-blocking: +blocking\n\u27e837\u27e9 https://lib.rs/crates/rustversion: 1 - rustversion\n\u27e838\u27e9 https://lib.rs/crates/syn-test-suite: 0 - syn-test-suite\n\u27e839\u27e9 https://lib.rs/crates/tar: 0.4.16 - tar\n\u27e840\u27e9 https://lib.rs/crates/termcolor: 1 - termcolor\n\u27e841\u27e9 https://lib.rs/crates/walkdir: 2.3.2 - walkdir\n\u27e842\u27e9 https://lib.rs/crates/syn/features: Other features\n\u27e843\u27e9 https://lib.rs/crates/syn/features#feature-clone-impls: clone-impls\n\u27e844\u27e9 https://lib.rs/crates/syn/features#feature-derive: derive\n\u27e845\u27e9 https://lib.rs/crates/syn/features#feature-extra-traits: extra-traits\n\u27e846\u27e9 https://lib.rs/crates/syn/features#feature-fold: fold\n\u27e847\u27e9 https://lib.rs/crates/syn/features#feature-full: full\n\u27e848\u27e9 https://lib.rs/crates/syn/features#feature-parsing: parsing\n\u27e849\u27e9 https://lib.rs/crates/syn/features#feature-test: test\n\u27e850\u27e9 https://lib.rs/crates/syn/features#feature-visit: visit\n\u27e851\u27e9 https://lib.rs/crates/syn/features#feature-visit-mut: visit-mut\n",
              "fit_markdown": "",
              "fit_html": ""
            },
            "structured_data": {},
            "quality_score": 3.0,
            "extraction_method": "crawl4ai",
            "error": null,
            "metadata": {
              "doc_type": "docs",
              "content_length": 13475,
              "has_structured_data": false,
              "crawl_success": true
            },
            "timestamp": "117472.453144"
          }
        },
        "crate_analysis": {
          "status": "completed",
          "check": [
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#unicode-ident@1.0.18",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\unicode-ident-1.0.18\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "unicode_ident",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\unicode-ident-1.0.18\\src\\lib.rs",
                "edition": "2018",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmptiom0n8y\\syn-2.0.104\\target\\debug\\deps\\libunicode_ident-0ff2238d530c1ee1.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#proc-macro2@1.0.95",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\proc-macro2-1.0.95\\Cargo.toml",
              "target": {
                "kind": [
                  "custom-build"
                ],
                "crate_types": [
                  "bin"
                ],
                "name": "build-script-build",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\proc-macro2-1.0.95\\build.rs",
                "edition": "2021",
                "doc": false,
                "doctest": false,
                "test": false
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "proc-macro"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmptiom0n8y\\syn-2.0.104\\target\\debug\\build\\proc-macro2-fc3323aef1101545\\build-script-build.exe",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmptiom0n8y\\syn-2.0.104\\target\\debug\\build\\proc-macro2-fc3323aef1101545\\build_script_build.pdb"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "build-script-executed",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#proc-macro2@1.0.95",
              "linked_libs": [],
              "linked_paths": [],
              "cfgs": [
                "wrap_proc_macro"
              ],
              "env": [],
              "out_dir": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmptiom0n8y\\syn-2.0.104\\target\\debug\\build\\proc-macro2-50129f8dc69949e8\\out"
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#proc-macro2@1.0.95",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\proc-macro2-1.0.95\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "proc_macro2",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\proc-macro2-1.0.95\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "proc-macro"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmptiom0n8y\\syn-2.0.104\\target\\debug\\deps\\libproc_macro2-aedc4ad791082512.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#quote@1.0.40",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\quote-1.0.40\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "quote",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\quote-1.0.40\\src\\lib.rs",
                "edition": "2018",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "proc-macro"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmptiom0n8y\\syn-2.0.104\\target\\debug\\deps\\libquote-bb56e62c50f8fcc5.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "compiler-artifact",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmptiom0n8y/syn-2.0.104#syn@2.0.104",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmptiom0n8y\\syn-2.0.104\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "syn",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmptiom0n8y\\syn-2.0.104\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "clone-impls",
                "default",
                "derive",
                "parsing",
                "printing",
                "proc-macro"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmptiom0n8y\\syn-2.0.104\\target\\debug\\deps\\libsyn-ccaf6aaa6d50f51f.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "build-finished",
              "success": true
            }
          ],
          "clippy": [
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#proc-macro2@1.0.95",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\proc-macro2-1.0.95\\Cargo.toml",
              "target": {
                "kind": [
                  "custom-build"
                ],
                "crate_types": [
                  "bin"
                ],
                "name": "build-script-build",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\proc-macro2-1.0.95\\build.rs",
                "edition": "2021",
                "doc": false,
                "doctest": false,
                "test": false
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "proc-macro"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmptiom0n8y\\syn-2.0.104\\target\\debug\\build\\proc-macro2-fc3323aef1101545\\build-script-build.exe",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmptiom0n8y\\syn-2.0.104\\target\\debug\\build\\proc-macro2-fc3323aef1101545\\build_script_build.pdb"
              ],
              "executable": null,
              "fresh": true
            },
            {
              "reason": "build-script-executed",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#proc-macro2@1.0.95",
              "linked_libs": [],
              "linked_paths": [],
              "cfgs": [
                "wrap_proc_macro"
              ],
              "env": [],
              "out_dir": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmptiom0n8y\\syn-2.0.104\\target\\debug\\build\\proc-macro2-50129f8dc69949e8\\out"
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#unicode-ident@1.0.18",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\unicode-ident-1.0.18\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "unicode_ident",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\unicode-ident-1.0.18\\src\\lib.rs",
                "edition": "2018",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmptiom0n8y\\syn-2.0.104\\target\\debug\\deps\\libunicode_ident-0ff2238d530c1ee1.rmeta"
              ],
              "executable": null,
              "fresh": true
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#proc-macro2@1.0.95",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\proc-macro2-1.0.95\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "proc_macro2",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\proc-macro2-1.0.95\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "proc-macro"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmptiom0n8y\\syn-2.0.104\\target\\debug\\deps\\libproc_macro2-aedc4ad791082512.rmeta"
              ],
              "executable": null,
              "fresh": true
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#quote@1.0.40",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\quote-1.0.40\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "quote",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\quote-1.0.40\\src\\lib.rs",
                "edition": "2018",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "proc-macro"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmptiom0n8y\\syn-2.0.104\\target\\debug\\deps\\libquote-bb56e62c50f8fcc5.rmeta"
              ],
              "executable": null,
              "fresh": true
            },
            {
              "reason": "compiler-artifact",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmptiom0n8y/syn-2.0.104#syn@2.0.104",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmptiom0n8y\\syn-2.0.104\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "syn",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmptiom0n8y\\syn-2.0.104\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "clone-impls",
                "default",
                "derive",
                "parsing",
                "printing",
                "proc-macro"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmptiom0n8y\\syn-2.0.104\\target\\debug\\deps\\libsyn-062d3b93e5366c42.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "build-finished",
              "success": true
            }
          ],
          "audit": {
            "database": {
              "advisory-count": 787,
              "last-commit": "7573f55ba337263f61167dbb0ea926cdc7c8eb5d",
              "last-updated": "2025-06-17T11:04:25+02:00"
            },
            "lockfile": {
              "dependency-count": 194
            },
            "settings": {
              "target_arch": [],
              "target_os": [],
              "severity": null,
              "ignore": [],
              "informational_warnings": [
                "unmaintained",
                "unsound",
                "notice"
              ]
            },
            "vulnerabilities": {
              "found": false,
              "count": 0,
              "list": []
            },
            "warnings": {}
          },
          "note": "Crate analysis performed with stable toolchain."
        },
        "crate_metadata": {
          "name": "syn",
          "version": "2.0.104",
          "description": "ALLOW: Positive community sentiment",
          "repository": "",
          "keywords": [],
          "categories": [],
          "readme": {
            "raw_markdown": "[](https://docs.rs/syn/latest/syn/all.html \"show sidebar\")\n# Crate synCopy item path\n[Settings](https://docs.rs/syn/latest/settings.html)\n[Help](https://docs.rs/syn/latest/help.html)\nSummary[Source](https://docs.rs/syn/latest/src/syn/lib.rs.html#1-1011)\nExpand description\n[![github](https://img.shields.io/badge/github-8da0cb?style=for-the-badge&labelColor=555555&logo=github)](https://github.com/dtolnay/syn) [![crates-io](https://img.shields.io/badge/crates.io-fc8d62?style=for-the-badge&labelColor=555555&logo=rust)](https://crates.io/crates/syn) [![docs-rs](https://img.shields.io/badge/docs.rs-66c2a5?style=for-the-badge&labelColor=555555&logo=docs.rs)](https://docs.rs/syn/latest/syn/index.html \"mod syn\")\nSyn is a parsing library for parsing a stream of Rust tokens into a syntax tree of Rust source code.\nCurrently this library is geared toward use in Rust procedural macros, but contains some APIs that may be useful more generally.\n  * **Data structures** \u2014 Syn provides a complete syntax tree that can represent any valid Rust source code. The syntax tree is rooted at [`syn::File`](https://docs.rs/syn/latest/syn/struct.File.html \"struct syn::File\") which represents a full source file, but there are other entry points that may be useful to procedural macros including [`syn::Item`](https://docs.rs/syn/latest/syn/enum.Item.html \"enum syn::Item\"), [`syn::Expr`](https://docs.rs/syn/latest/syn/enum.Expr.html \"enum syn::Expr\") and [`syn::Type`](https://docs.rs/syn/latest/syn/enum.Type.html \"enum syn::Type\").\n  * **Derives** \u2014 Of particular interest to derive macros is [`syn::DeriveInput`](https://docs.rs/syn/latest/syn/struct.DeriveInput.html \"struct syn::DeriveInput\") which is any of the three legal input items to a derive macro. An example below shows using this type in a library that can derive implementations of a user-defined trait.\n  * **Parsing** \u2014 Parsing in Syn is built around [parser functions](https://docs.rs/syn/latest/syn/parse/index.html \"mod syn::parse\") with the signature `fn(ParseStream) -> Result<T>`. Every syntax tree node defined by Syn is individually parsable and may be used as a building block for custom syntaxes, or you may dream up your own brand new syntax without involving any of our syntax tree types.\n  * **Location information** \u2014 Every token parsed by Syn is associated with a `Span` that tracks line and column information back to the source of that token. These spans allow a procedural macro to display detailed error messages pointing to all the right places in the user\u2019s code. There is an example of this below.\n  * **Feature flags** \u2014 Functionality is aggressively feature gated so your procedural macros enable only what they need, and do not pay in compile time for all the rest.\n\n\n## [\u00a7](https://docs.rs/syn/latest/syn/#example-of-a-derive-macro)Example of a derive macro\nThe canonical derive macro using Syn looks like this. We write an ordinary Rust function tagged with a `proc_macro_derive` attribute and the name of the trait we are deriving. Any time that derive appears in the user\u2019s code, the Rust compiler passes their data structure as tokens into our macro. We get to execute arbitrary Rust code to figure out what to do with those tokens, then hand some tokens back to the compiler to compile into the user\u2019s crate.\n```\n[dependencies]\nsyn = \"2.0\"\nquote = \"1.0\"\n[lib]\nproc-macro = true\n```\n\n```\nuse proc_macro::TokenStream;\nuse quote::quote;\nuse syn::{parse_macro_input, DeriveInput};\n#[proc_macro_derive(MyMacro)]\npub fn my_macro(input: TokenStream) -> TokenStream {\n  // Parse the input tokens into a syntax tree\n  let input = parse_macro_input!(input as DeriveInput);\n  // Build the output, possibly using quasi-quotation\n  let expanded = quote! {\n    // ...\n  };\n  // Hand the output tokens back to the compiler\n  TokenStream::from(expanded)\n}\n```\n\nThe [`heapsize`](https://github.com/dtolnay/syn/tree/master/examples/heapsize) example directory shows a complete working implementation of a derive macro. The example derives a `HeapSize` trait which computes an estimate of the amount of heap memory owned by a value.\n```\npub trait HeapSize {\n  /// Total number of bytes of heap memory owned by `self`.\n  fn heap_size_of_children(&self) -> usize;\n}\n```\n\nThe derive macro allows users to write `#[derive(HeapSize)]` on data structures in their program.\n```\n#[derive(HeapSize)]\nstruct Demo<'a, T: ?Sized> {\n  a: Box<T>,\n  b: u8,\n  c: &'a str,\n  d: String,\n}\n```\n\n## [\u00a7](https://docs.rs/syn/latest/syn/#spans-and-error-reporting)Spans and error reporting\nThe token-based procedural macro API provides great control over where the compiler\u2019s error messages are displayed in user code. Consider the error the user sees if one of their field types does not implement `HeapSize`.\n```\n#[derive(HeapSize)]\nstruct Broken {\n  ok: String,\n  bad: std::thread::Thread,\n}\n```\n\nBy tracking span information all the way through the expansion of a procedural macro as shown in the `heapsize` example, token-based macros in Syn are able to trigger errors that directly pinpoint the source of the problem.\n```\nerror[E0277]: the trait bound `std::thread::Thread: HeapSize` is not satisfied\n --> src/main.rs:7:5\n |\n7 |   bad: std::thread::Thread,\n |   ^^^^^^^^^^^^^^^^^^^^^^^^ the trait `HeapSize` is not implemented for `Thread`\n```\n\n## [\u00a7](https://docs.rs/syn/latest/syn/#parsing-a-custom-syntax)Parsing a custom syntax\nThe [`lazy-static`](https://github.com/dtolnay/syn/tree/master/examples/lazy-static) example directory shows the implementation of a `functionlike!(...)` procedural macro in which the input tokens are parsed using Syn\u2019s parsing API.\nThe example reimplements the popular `lazy_static` crate from crates.io as a procedural macro.\n```\nlazy_static! {\n  static ref USERNAME: Regex = Regex::new(\"^[a-z0-9_-]{3,16}$\").unwrap();\n}\n```\n\nThe implementation shows how to trigger custom warnings and error messages on the macro input.\n```\nwarning: come on, pick a more creative name\n --> src/main.rs:10:16\n  |\n10 |   static ref FOO: String = \"lazy_static\".to_owned();\n  |        ^^^\n```\n\n## [\u00a7](https://docs.rs/syn/latest/syn/#testing)Testing\nWhen testing macros, we often care not just that the macro can be used successfully but also that when the macro is provided with invalid input it produces maximally helpful error messages. Consider using the [`trybuild`](https://github.com/dtolnay/trybuild) crate to write tests for errors that are emitted by your macro or errors detected by the Rust compiler in the expanded code following misuse of the macro. Such tests help avoid regressions from later refactors that mistakenly make an error no longer trigger or be less helpful than it used to be.\n## [\u00a7](https://docs.rs/syn/latest/syn/#debugging)Debugging\nWhen developing a procedural macro it can be helpful to look at what the generated code looks like. Use `cargo rustc -- -Zunstable-options --pretty=expanded` or the [`cargo expand`](https://github.com/dtolnay/cargo-expand) subcommand.\nTo show the expanded code for some crate that uses your procedural macro, run `cargo expand` from that crate. To show the expanded code for one of your own test cases, run `cargo expand --test the_test_case` where the last argument is the name of the test file without the `.rs` extension.\nThis write-up by Brandon W Maister discusses debugging in more detail: [Debugging Rust\u2019s new Custom Derive system](https://quodlibetor.github.io/posts/debugging-rusts-new-custom-derive-system/).\n## [\u00a7](https://docs.rs/syn/latest/syn/#optional-features)Optional features\nSyn puts a lot of functionality behind optional features in order to optimize compile time for the most common use cases. The following features are available.\n  * **`derive`**_(enabled by default)_ \u2014 Data structures for representing the possible input to a derive macro, including structs and enums and types.\n  * **`full`**\u2014 Data structures for representing the syntax tree of all valid Rust source code, including items and expressions.\n  * **`parsing`**_(enabled by default)_ \u2014 Ability to parse input tokens into a syntax tree node of a chosen type.\n  * **`printing`**_(enabled by default)_ \u2014 Ability to print a syntax tree node as tokens of Rust source code.\n  * **`visit`**\u2014 Trait for traversing a syntax tree.\n  * **`visit-mut`**\u2014 Trait for traversing and mutating in place a syntax tree.\n  * **`fold`**\u2014 Trait for transforming an owned syntax tree.\n  * **`clone-impls`**_(enabled by default)_ \u2014 Clone impls for all syntax tree types.\n  * **`extra-traits`**\u2014 Debug, Eq, PartialEq, Hash impls for all syntax tree types.\n  * **`proc-macro`**_(enabled by default)_ \u2014 Runtime dependency on the dynamic library libproc_macro from rustc toolchain.\n\n\n## Modules[\u00a7](https://docs.rs/syn/latest/syn/#modules)\n\n[buffer](https://docs.rs/syn/latest/syn/buffer/index.html \"mod syn::buffer\")`parsing`\n    A stably addressed token buffer supporting efficient traversal based on a cheaply copyable cursor.\n\n[ext](https://docs.rs/syn/latest/syn/ext/index.html \"mod syn::ext\")`parsing`\n    Extension traits to provide parsing methods on foreign types.\n\n[fold](https://docs.rs/syn/latest/syn/fold/index.html \"mod syn::fold\")`fold`\n    Syntax tree traversal to transform the nodes of an owned syntax tree.\n\n[meta](https://docs.rs/syn/latest/syn/meta/index.html \"mod syn::meta\")`parsing` and (`full` or `derive`)\n    Facility for interpreting structured content inside of an `Attribute`.\n\n[parse](https://docs.rs/syn/latest/syn/parse/index.html \"mod syn::parse\")`parsing`\n    Parsing interface for parsing a token stream into a syntax tree node.\n\n[punctuated](https://docs.rs/syn/latest/syn/punctuated/index.html \"mod syn::punctuated\")\n    A punctuated sequence of syntax tree nodes separated by punctuation.\n\n[spanned](https://docs.rs/syn/latest/syn/spanned/index.html \"mod syn::spanned\")`parsing` and `printing`\n    A trait that can provide the `Span` of the complete contents of a syntax tree node.\n\n[token](https://docs.rs/syn/latest/syn/token/index.html \"mod syn::token\")\n    Tokens representing Rust punctuation, keywords, and delimiters.\n\n[visit](https://docs.rs/syn/latest/syn/visit/index.html \"mod syn::visit\")`visit`\n    Syntax tree traversal to walk a shared borrow of a syntax tree.\n\n[visit_mut](https://docs.rs/syn/latest/syn/visit_mut/index.html \"mod syn::visit_mut\")`visit-mut`\n    Syntax tree traversal to mutate an exclusive borrow of a syntax tree in place.\n## Macros[\u00a7](https://docs.rs/syn/latest/syn/#macros)\n\n[Token](https://docs.rs/syn/latest/syn/macro.Token.html \"macro syn::Token\")\n    A type-macro that expands to the name of the Rust type representation of a given token.\n\n[braced](https://docs.rs/syn/latest/syn/macro.braced.html \"macro syn::braced\")`parsing`\n    Parse a set of curly braces and expose their content to subsequent parsers.\n\n[bracketed](https://docs.rs/syn/latest/syn/macro.bracketed.html \"macro syn::bracketed\")`parsing`\n    Parse a set of square brackets and expose their content to subsequent parsers.\n\n[custom_keyword](https://docs.rs/syn/latest/syn/macro.custom_keyword.html \"macro syn::custom_keyword\")\n    Define a type that supports parsing and printing a given identifier as if it were a keyword.\n\n[custom_punctuation](https://docs.rs/syn/latest/syn/macro.custom_punctuation.html \"macro syn::custom_punctuation\")\n    Define a type that supports parsing and printing a multi-character symbol as if it were a punctuation token.\n\n[parenthesized](https://docs.rs/syn/latest/syn/macro.parenthesized.html \"macro syn::parenthesized\")`parsing`\n    Parse a set of parentheses and expose their content to subsequent parsers.\n\n[parse_macro_input](https://docs.rs/syn/latest/syn/macro.parse_macro_input.html \"macro syn::parse_macro_input\")`parsing` and `proc-macro`\n    Parse the input TokenStream of a macro, triggering a compile error if the tokens fail to parse.\n\n[parse_quote](https://docs.rs/syn/latest/syn/macro.parse_quote.html \"macro syn::parse_quote\")`parsing` and `printing`\n    Quasi-quotation macro that accepts input like the [`quote!`](https://docs.rs/quote/1.0/quote/index.html) macro but uses type inference to figure out a return type for those tokens.\n\n[parse_quote_spanned](https://docs.rs/syn/latest/syn/macro.parse_quote_spanned.html \"macro syn::parse_quote_spanned\")`parsing` and `printing`\n    This macro is [`parse_quote!`](https://docs.rs/syn/latest/syn/macro.parse_quote.html \"macro syn::parse_quote\") + [`quote_spanned!`](https://docs.rs/quote/1.0.40/x86_64-unknown-linux-gnu/quote/macro.quote_spanned.html \"macro quote::quote_spanned\").\n## Structs[\u00a7](https://docs.rs/syn/latest/syn/#structs)\n\n[Abi](https://docs.rs/syn/latest/syn/struct.Abi.html \"struct syn::Abi\")`full` or `derive`\n    The binary interface of a function: `extern \"C\"`.\n\n[AngleBracketedGenericArguments](https://docs.rs/syn/latest/syn/struct.AngleBracketedGenericArguments.html \"struct syn::AngleBracketedGenericArguments\")`full` or `derive`\n    Angle bracketed arguments of a path segment: the `<K, V>` in `HashMap<K, V>`.\n\n[Arm](https://docs.rs/syn/latest/syn/struct.Arm.html \"struct syn::Arm\")`full`\n    One arm of a `match` expression: `0..=10 => { return true; }`.\n\n[AssocConst](https://docs.rs/syn/latest/syn/struct.AssocConst.html \"struct syn::AssocConst\")`full` or `derive`\n    An equality constraint on an associated constant: the `PANIC = false` in `Trait<PANIC = false>`.\n\n[AssocType](https://docs.rs/syn/latest/syn/struct.AssocType.html \"struct syn::AssocType\")`full` or `derive`\n    A binding (equality constraint) on an associated type: the `Item = u8` in `Iterator<Item = u8>`.\n\n[Attribute](https://docs.rs/syn/latest/syn/struct.Attribute.html \"struct syn::Attribute\")`full` or `derive`\n    An attribute, like `#[repr(transparent)]`.\n\n[BareFnArg](https://docs.rs/syn/latest/syn/struct.BareFnArg.html \"struct syn::BareFnArg\")`full` or `derive`\n    An argument in a function type: the `usize` in `fn(usize) -> bool`.\n\n[BareVariadic](https://docs.rs/syn/latest/syn/struct.BareVariadic.html \"struct syn::BareVariadic\")`full` or `derive`\n    The variadic argument of a function pointer like `fn(usize, ...)`.\n\n[Block](https://docs.rs/syn/latest/syn/struct.Block.html \"struct syn::Block\")`full`\n    A braced block containing Rust statements.\n\n[BoundLifetimes](https://docs.rs/syn/latest/syn/struct.BoundLifetimes.html \"struct syn::BoundLifetimes\")`full` or `derive`\n    A set of bound lifetimes: `for<'a, 'b, 'c>`.\n\n[ConstParam](https://docs.rs/syn/latest/syn/struct.ConstParam.html \"struct syn::ConstParam\")`full` or `derive`\n    A const generic parameter: `const LENGTH: usize`.\n\n[Constraint](https://docs.rs/syn/latest/syn/struct.Constraint.html \"struct syn::Constraint\")`full` or `derive`\n    An associated type bound: `Iterator<Item: Display>`.\n\n[DataEnum](https://docs.rs/syn/latest/syn/struct.DataEnum.html \"struct syn::DataEnum\")`derive`\n    An enum input to a `proc_macro_derive` macro.\n\n[DataStruct](https://docs.rs/syn/latest/syn/struct.DataStruct.html \"struct syn::DataStruct\")`derive`\n    A struct input to a `proc_macro_derive` macro.\n\n[DataUnion](https://docs.rs/syn/latest/syn/struct.DataUnion.html \"struct syn::DataUnion\")`derive`\n    An untagged union input to a `proc_macro_derive` macro.\n\n[DeriveInput](https://docs.rs/syn/latest/syn/struct.DeriveInput.html \"struct syn::DeriveInput\")`derive`\n    Data structure sent to a `proc_macro_derive` macro.\n\n[Error](https://docs.rs/syn/latest/syn/struct.Error.html \"struct syn::Error\")\n    Error returned when a Syn parser cannot parse the input tokens.\n\n[ExprArray](https://docs.rs/syn/latest/syn/struct.ExprArray.html \"struct syn::ExprArray\")`full`\n    A slice literal expression: `[a, b, c, d]`.\n\n[ExprAssign](https://docs.rs/syn/latest/syn/struct.ExprAssign.html \"struct syn::ExprAssign\")`full`\n    An assignment expression: `a = compute()`.\n\n[ExprAsync](https://docs.rs/syn/latest/syn/struct.ExprAsync.html \"struct syn::ExprAsync\")`full`\n    An async block: `async { ... }`.\n\n[ExprAwait](https://docs.rs/syn/latest/syn/struct.ExprAwait.html \"struct syn::ExprAwait\")`full`\n    An await expression: `fut.await`.\n\n[ExprBinary](https://docs.rs/syn/latest/syn/struct.ExprBinary.html \"struct syn::ExprBinary\")`full` or `derive`\n    A binary operation: `a + b`, `a += b`.\n\n[ExprBlock](https://docs.rs/syn/latest/syn/struct.ExprBlock.html \"struct syn::ExprBlock\")`full`\n    A blocked scope: `{ ... }`.\n\n[ExprBreak](https://docs.rs/syn/latest/syn/struct.ExprBreak.html \"struct syn::ExprBreak\")`full`\n    A `break`, with an optional label to break and an optional expression.\n\n[ExprCall](https://docs.rs/syn/latest/syn/struct.ExprCall.html \"struct syn::ExprCall\")`full` or `derive`\n    A function call expression: `invoke(a, b)`.\n\n[ExprCast](https://docs.rs/syn/latest/syn/struct.ExprCast.html \"struct syn::ExprCast\")`full` or `derive`\n    A cast expression: `foo as f64`.\n\n[ExprClosure](https://docs.rs/syn/latest/syn/struct.ExprClosure.html \"struct syn::ExprClosure\")`full`\n    A closure expression: `|a, b| a + b`.\n\n[ExprConst](https://docs.rs/syn/latest/syn/struct.ExprConst.html \"struct syn::ExprConst\")`full`\n    A const block: `const { ... }`.\n\n[ExprContinue](https://docs.rs/syn/latest/syn/struct.ExprContinue.html \"struct syn::ExprContinue\")`full`\n    A `continue`, with an optional label.\n\n[ExprField](https://docs.rs/syn/latest/syn/struct.ExprField.html \"struct syn::ExprField\")`full` or `derive`\n    Access of a named struct field (`obj.k`) or unnamed tuple struct field (`obj.0`).\n\n[ExprForLoop](https://docs.rs/syn/latest/syn/struct.ExprForLoop.html \"struct syn::ExprForLoop\")`full`\n    A for loop: `for pat in expr { ... }`.\n\n[ExprGroup](https://docs.rs/syn/latest/syn/struct.ExprGroup.html \"struct syn::ExprGroup\")`full`\n    An expression contained within invisible delimiters.\n\n[ExprIf](https://docs.rs/syn/latest/syn/struct.ExprIf.html \"struct syn::ExprIf\")`full`\n    An `if` expression with an optional `else` block: `if expr { ... } else { ... }`.\n\n[ExprIndex](https://docs.rs/syn/latest/syn/struct.ExprIndex.html \"struct syn::ExprIndex\")`full` or `derive`\n    A square bracketed indexing expression: `vector[2]`.\n\n[ExprInfer](https://docs.rs/syn/latest/syn/struct.ExprInfer.html \"struct syn::ExprInfer\")`full`\n    The inferred value of a const generic argument, denoted `_`.\n\n[ExprLet](https://docs.rs/syn/latest/syn/struct.ExprLet.html \"struct syn::ExprLet\")`full`\n    A `let` guard: `let Some(x) = opt`.\n\n[ExprLit](https://docs.rs/syn/latest/syn/struct.ExprLit.html \"struct syn::ExprLit\")`full` or `derive`\n    A literal in place of an expression: `1`, `\"foo\"`.\n\n[ExprLoop](https://docs.rs/syn/latest/syn/struct.ExprLoop.html \"struct syn::ExprLoop\")`full`\n    Conditionless loop: `loop { ... }`.\n\n[ExprMacro](https://docs.rs/syn/latest/syn/struct.ExprMacro.html \"struct syn::ExprMacro\")`full` or `derive`\n    A macro invocation expression: `format!(\"{}\", q)`.\n\n[ExprMatch](https://docs.rs/syn/latest/syn/struct.ExprMatch.html \"struct syn::ExprMatch\")`full`\n    A `match` expression: `match n { Some(n) => {}, None => {} }`.\n\n[ExprMethodCall](https://docs.rs/syn/latest/syn/struct.ExprMethodCall.html \"struct syn::ExprMethodCall\")`full` or `derive`\n    A method call expression: `x.foo::<T>(a, b)`.\n\n[ExprParen](https://docs.rs/syn/latest/syn/struct.ExprParen.html \"struct syn::ExprParen\")`full` or `derive`\n    A parenthesized expression: `(a + b)`.\n\n[ExprPath](https://docs.rs/syn/latest/syn/struct.ExprPath.html \"struct syn::ExprPath\")`full` or `derive`\n    A path like `std::mem::replace` possibly containing generic parameters and a qualified self-type.\n\n[ExprRange](https://docs.rs/syn/latest/syn/struct.ExprRange.html \"struct syn::ExprRange\")`full`\n    A range expression: `1..2`, `1..`, `..2`, `1..=2`, `..=2`.\n\n[ExprRawAddr](https://docs.rs/syn/latest/syn/struct.ExprRawAddr.html \"struct syn::ExprRawAddr\")`full`\n    Address-of operation: `&raw const place` or `&raw mut place`.\n\n[ExprReference](https://docs.rs/syn/latest/syn/struct.ExprReference.html \"struct syn::ExprReference\")`full` or `derive`\n    A referencing operation: `&a` or `&mut a`.\n\n[ExprRepeat](https://docs.rs/syn/latest/syn/struct.ExprRepeat.html \"struct syn::ExprRepeat\")`full`\n    An array literal constructed from one repeated element: `[0u8; N]`.\n\n[ExprReturn](https://docs.rs/syn/latest/syn/struct.ExprReturn.html \"struct syn::ExprReturn\")`full`\n    A `return`, with an optional value to be returned.\n\n[ExprStruct](https://docs.rs/syn/latest/syn/struct.ExprStruct.html \"struct syn::ExprStruct\")`full` or `derive`\n    A struct literal expression: `Point { x: 1, y: 1 }`.\n\n[ExprTry](https://docs.rs/syn/latest/syn/struct.ExprTry.html \"struct syn::ExprTry\")`full`\n    A try-expression: `expr?`.\n\n[ExprTryBlock](https://docs.rs/syn/latest/syn/struct.ExprTryBlock.html \"struct syn::ExprTryBlock\")`full`\n    A try block: `try { ... }`.\n\n[ExprTuple](https://docs.rs/syn/latest/syn/struct.ExprTuple.html \"struct syn::ExprTuple\")`full`\n    A tuple expression: `(a, b, c, d)`.\n\n[ExprUnary](https://docs.rs/syn/latest/syn/struct.ExprUnary.html \"struct syn::ExprUnary\")`full` or `derive`\n    A unary operation: `!x`, `*x`.\n\n[ExprUnsafe](https://docs.rs/syn/latest/syn/struct.ExprUnsafe.html \"struct syn::ExprUnsafe\")`full`\n    An unsafe block: `unsafe { ... }`.\n\n[ExprWhile](https://docs.rs/syn/latest/syn/struct.ExprWhile.html \"struct syn::ExprWhile\")`full`\n    A while loop: `while expr { ... }`.\n\n[ExprYield](https://docs.rs/syn/latest/syn/struct.ExprYield.html \"struct syn::ExprYield\")`full`\n    A yield expression: `yield expr`.\n\n[Field](https://docs.rs/syn/latest/syn/struct.Field.html \"struct syn::Field\")`full` or `derive`\n    A field of a struct or enum variant.\n\n[FieldPat](https://docs.rs/syn/latest/syn/struct.FieldPat.html \"struct syn::FieldPat\")`full`\n    A single field in a struct pattern.\n\n[FieldValue](https://docs.rs/syn/latest/syn/struct.FieldValue.html \"struct syn::FieldValue\")`full` or `derive`\n    A field-value pair in a struct literal.\n\n[FieldsNamed](https://docs.rs/syn/latest/syn/struct.FieldsNamed.html \"struct syn::FieldsNamed\")`full` or `derive`\n    Named fields of a struct or struct variant such as `Point { x: f64, y: f64 }`.\n\n[FieldsUnnamed](https://docs.rs/syn/latest/syn/struct.FieldsUnnamed.html \"struct syn::FieldsUnnamed\")`full` or `derive`\n    Unnamed fields of a tuple struct or tuple variant such as `Some(T)`.\n\n[File](https://docs.rs/syn/latest/syn/struct.File.html \"struct syn::File\")`full`\n    A complete file of Rust source code.\n\n[ForeignItemFn](https://docs.rs/syn/latest/syn/struct.ForeignItemFn.html \"struct syn::ForeignItemFn\")`full`\n    A foreign function in an `extern` block.\n\n[ForeignItemMacro](https://docs.rs/syn/latest/syn/struct.ForeignItemMacro.html \"struct syn::ForeignItemMacro\")`full`\n    A macro invocation within an extern block.\n\n[ForeignItemStatic](https://docs.rs/syn/latest/syn/struct.ForeignItemStatic.html \"struct syn::ForeignItemStatic\")`full`\n    A foreign static item in an `extern` block: `static ext: u8`.\n\n[ForeignItemType](https://docs.rs/syn/latest/syn/struct.ForeignItemType.html \"struct syn::ForeignItemType\")`full`\n    A foreign type in an `extern` block: `type void`.\n\n[Generics](https://docs.rs/syn/latest/syn/struct.Generics.html \"struct syn::Generics\")`full` or `derive`\n    Lifetimes and type parameters attached to a declaration of a function, enum, trait, etc.\n\n[Ident](https://docs.rs/syn/latest/syn/struct.Ident.html \"struct syn::Ident\")\n    A word of Rust code, which may be a keyword or legal variable name.\n\n[ImplGenerics](https://docs.rs/syn/latest/syn/struct.ImplGenerics.html \"struct syn::ImplGenerics\")(`full` or `derive`) and `printing`\n    Returned by `Generics::split_for_impl`.\n\n[ImplItemConst](https://docs.rs/syn/latest/syn/struct.ImplItemConst.html \"struct syn::ImplItemConst\")`full`\n    An associated constant within an impl block.\n\n[ImplItemFn](https://docs.rs/syn/latest/syn/struct.ImplItemFn.html \"struct syn::ImplItemFn\")`full`\n    An associated function within an impl block.\n\n[ImplItemMacro](https://docs.rs/syn/latest/syn/struct.ImplItemMacro.html \"struct syn::ImplItemMacro\")`full`\n    A macro invocation within an impl block.\n\n[ImplItemType](https://docs.rs/syn/latest/syn/struct.ImplItemType.html \"struct syn::ImplItemType\")`full`\n    An associated type within an impl block.\n\n[Index](https://docs.rs/syn/latest/syn/struct.Index.html \"struct syn::Index\")`full` or `derive`\n    The index of an unnamed tuple struct field.\n\n[ItemConst](https://docs.rs/syn/latest/syn/struct.ItemConst.html \"struct syn::ItemConst\")`full`\n    A constant item: `const MAX: u16 = 65535`.\n\n[ItemEnum](https://docs.rs/syn/latest/syn/struct.ItemEnum.html \"struct syn::ItemEnum\")`full`\n    An enum definition: `enum Foo<A, B> { A(A), B(B) }`.\n\n[ItemExternCrate](https://docs.rs/syn/latest/syn/struct.ItemExternCrate.html \"struct syn::ItemExternCrate\")`full`\n    An `extern crate` item: `extern crate serde`.\n\n[ItemFn](https://docs.rs/syn/latest/syn/struct.ItemFn.html \"struct syn::ItemFn\")`full`\n    A free-standing function: `fn process(n: usize) -> Result<()> { ... }`.\n\n[ItemForeignMod](https://docs.rs/syn/latest/syn/struct.ItemForeignMod.html \"struct syn::ItemForeignMod\")`full`\n    A block of foreign items: `extern \"C\" { ... }`.\n\n[ItemImpl](https://docs.rs/syn/latest/syn/struct.ItemImpl.html \"struct syn::ItemImpl\")`full`\n    An impl block providing trait or associated items: `impl<A> Trait for Data<A> { ... }`.\n\n[ItemMacro](https://docs.rs/syn/latest/syn/struct.ItemMacro.html \"struct syn::ItemMacro\")`full`\n    A macro invocation, which includes `macro_rules!` definitions.\n\n[ItemMod](https://docs.rs/syn/latest/syn/struct.ItemMod.html \"struct syn::ItemMod\")`full`\n    A module or module declaration: `mod m` or `mod m { ... }`.\n\n[ItemStatic](https://docs.rs/syn/latest/syn/struct.ItemStatic.html \"struct syn::ItemStatic\")`full`\n    A static item: `static BIKE: Shed = Shed(42)`.\n\n[ItemStruct](https://docs.rs/syn/latest/syn/struct.ItemStruct.html \"struct syn::ItemStruct\")`full`\n    A struct definition: `struct Foo<A> { x: A }`.\n\n[ItemTrait](https://docs.rs/syn/latest/syn/struct.ItemTrait.html \"struct syn::ItemTrait\")`full`\n    A trait definition: `pub trait Iterator { ... }`.\n\n[ItemTraitAlias](https://docs.rs/syn/latest/syn/struct.ItemTraitAlias.html \"struct syn::ItemTraitAlias\")`full`\n    A trait alias: `pub trait SharableIterator = Iterator + Sync`.\n\n[ItemType](https://docs.rs/syn/latest/syn/struct.ItemType.html \"struct syn::ItemType\")`full`\n    A type alias: `type Result<T> = std::result::Result<T, MyError>`.\n\n[ItemUnion](https://docs.rs/syn/latest/syn/struct.ItemUnion.html \"struct syn::ItemUnion\")`full`\n    A union definition: `union Foo<A, B> { x: A, y: B }`.\n\n[ItemUse](https://docs.rs/syn/latest/syn/struct.ItemUse.html \"struct syn::ItemUse\")`full`\n    A use declaration: `use std::collections::HashMap`.\n\n[Label](https://docs.rs/syn/latest/syn/struct.Label.html \"struct syn::Label\")`full`\n    A lifetime labeling a `for`, `while`, or `loop`.\n\n[Lifetime](https://docs.rs/syn/latest/syn/struct.Lifetime.html \"struct syn::Lifetime\")\n    A Rust lifetime: `'a`.\n\n[LifetimeParam](https://docs.rs/syn/latest/syn/struct.LifetimeParam.html \"struct syn::LifetimeParam\")`full` or `derive`\n    A lifetime definition: `'a: 'b + 'c + 'd`.\n\n[LitBool](https://docs.rs/syn/latest/syn/struct.LitBool.html \"struct syn::LitBool\")\n    A boolean literal: `true` or `false`.\n\n[LitByte](https://docs.rs/syn/latest/syn/struct.LitByte.html \"struct syn::LitByte\")\n    A byte literal: `b'f'`.\n\n[LitByteStr](https://docs.rs/syn/latest/syn/struct.LitByteStr.html \"struct syn::LitByteStr\")\n    A byte string literal: `b\"foo\"`.\n\n[LitCStr](https://docs.rs/syn/latest/syn/struct.LitCStr.html \"struct syn::LitCStr\")\n    A nul-terminated C-string literal: `c\"foo\"`.\n\n[LitChar](https://docs.rs/syn/latest/syn/struct.LitChar.html \"struct syn::LitChar\")\n    A character literal: `'a'`.\n\n[LitFloat](https://docs.rs/syn/latest/syn/struct.LitFloat.html \"struct syn::LitFloat\")\n    A floating point literal: `1f64` or `1.0e10f64`.\n\n[LitInt](https://docs.rs/syn/latest/syn/struct.LitInt.html \"struct syn::LitInt\")\n    An integer literal: `1` or `1u16`.\n\n[LitStr](https://docs.rs/syn/latest/syn/struct.LitStr.html \"struct syn::LitStr\")\n    A UTF-8 string literal: `\"foo\"`.\n\n[Local](https://docs.rs/syn/latest/syn/struct.Local.html \"struct syn::Local\")`full`\n    A local `let` binding: `let x: u64 = s.parse()?;`.\n\n[LocalInit](https://docs.rs/syn/latest/syn/struct.LocalInit.html \"struct syn::LocalInit\")`full`\n    The expression assigned in a local `let` binding, including optional diverging `else` block.\n\n[Macro](https://docs.rs/syn/latest/syn/struct.Macro.html \"struct syn::Macro\")`full` or `derive`\n    A macro invocation: `println!(\"{}\", mac)`.\n\n[MetaList](https://docs.rs/syn/latest/syn/struct.MetaList.html \"struct syn::MetaList\")`full` or `derive`\n    A structured list within an attribute, like `derive(Copy, Clone)`.\n\n[MetaNameValue](https://docs.rs/syn/latest/syn/struct.MetaNameValue.html \"struct syn::MetaNameValue\")`full` or `derive`\n    A name-value pair within an attribute, like `feature = \"nightly\"`.\n\n[ParenthesizedGenericArguments](https://docs.rs/syn/latest/syn/struct.ParenthesizedGenericArguments.html \"struct syn::ParenthesizedGenericArguments\")`full` or `derive`\n    Arguments of a function path segment: the `(A, B) -> C` in `Fn(A,B) -> C`.\n\n[PatConst](https://docs.rs/syn/latest/syn/struct.PatConst.html \"struct syn::PatConst\")`full`\n    A const block: `const { ... }`.\n\n[PatIdent](https://docs.rs/syn/latest/syn/struct.PatIdent.html \"struct syn::PatIdent\")`full`\n    A pattern that binds a new variable: `ref mut binding @ SUBPATTERN`.\n\n[PatLit](https://docs.rs/syn/latest/syn/struct.PatLit.html \"struct syn::PatLit\")`full`\n    A literal in place of an expression: `1`, `\"foo\"`.\n\n[PatMacro](https://docs.rs/syn/latest/syn/struct.PatMacro.html \"struct syn::PatMacro\")`full`\n    A macro invocation expression: `format!(\"{}\", q)`.\n\n[PatOr](https://docs.rs/syn/latest/syn/struct.PatOr.html \"struct syn::PatOr\")`full`\n    A pattern that matches any one of a set of cases.\n\n[PatParen](https://docs.rs/syn/latest/syn/struct.PatParen.html \"struct syn::PatParen\")`full`\n    A parenthesized pattern: `(A | B)`.\n\n[PatPath](https://docs.rs/syn/latest/syn/struct.PatPath.html \"struct syn::PatPath\")`full`\n    A path like `std::mem::replace` possibly containing generic parameters and a qualified self-type.\n\n[PatRange](https://docs.rs/syn/latest/syn/struct.PatRange.html \"struct syn::PatRange\")`full`\n    A range expression: `1..2`, `1..`, `..2`, `1..=2`, `..=2`.\n\n[PatReference](https://docs.rs/syn/latest/syn/struct.PatReference.html \"struct syn::PatReference\")`full`\n    A reference pattern: `&mut var`.\n\n[PatRest](https://docs.rs/syn/latest/syn/struct.PatRest.html \"struct syn::PatRest\")`full`\n    The dots in a tuple or slice pattern: `[0, 1, ..]`.\n\n[PatSlice](https://docs.rs/syn/latest/syn/struct.PatSlice.html \"struct syn::PatSlice\")`full`\n    A dynamically sized slice pattern: `[a, b, ref i @ .., y, z]`.\n\n[PatStruct](https://docs.rs/syn/latest/syn/struct.PatStruct.html \"struct syn::PatStruct\")`full`\n    A struct or struct variant pattern: `Variant { x, y, .. }`.\n\n[PatTuple](https://docs.rs/syn/latest/syn/struct.PatTuple.html \"struct syn::PatTuple\")`full`\n    A tuple pattern: `(a, b)`.\n\n[PatTupleStruct](https://docs.rs/syn/latest/syn/struct.PatTupleStruct.html \"struct syn::PatTupleStruct\")`full`\n    A tuple struct or tuple variant pattern: `Variant(x, y, .., z)`.\n\n[PatType](https://docs.rs/syn/latest/syn/struct.PatType.html \"struct syn::PatType\")`full`\n    A type ascription pattern: `foo: f64`.\n\n[PatWild](https://docs.rs/syn/latest/syn/struct.PatWild.html \"struct syn::PatWild\")`full`\n    A pattern that matches any value: `_`.\n\n[Path](https://docs.rs/syn/latest/syn/struct.Path.html \"struct syn::Path\")`full` or `derive`\n    A path at which a named item is exported (e.g. `std::collections::HashMap`).\n\n[PathSegment](https://docs.rs/syn/latest/syn/struct.PathSegment.html \"struct syn::PathSegment\")`full` or `derive`\n    A segment of a path together with any path arguments on that segment.\n\n[PreciseCapture](https://docs.rs/syn/latest/syn/struct.PreciseCapture.html \"struct syn::PreciseCapture\")`full`\n    Precise capturing bound: the \u2018use<\u2026>\u2019 in `impl Trait + use<'a, T>`.\n\n[PredicateLifetime](https://docs.rs/syn/latest/syn/struct.PredicateLifetime.html \"struct syn::PredicateLifetime\")`full` or `derive`\n    A lifetime predicate in a `where` clause: `'a: 'b + 'c`.\n\n[PredicateType](https://docs.rs/syn/latest/syn/struct.PredicateType.html \"struct syn::PredicateType\")`full` or `derive`\n    A type predicate in a `where` clause: `for<'c> Foo<'c>: Trait<'c>`.\n\n[QSelf](https://docs.rs/syn/latest/syn/struct.QSelf.html \"struct syn::QSelf\")`full` or `derive`\n    The explicit Self type in a qualified path: the `T` in `<T as Display>::fmt`.\n\n[Receiver](https://docs.rs/syn/latest/syn/struct.Receiver.html \"struct syn::Receiver\")`full`\n    The `self` argument of an associated method.\n\n[Signature](https://docs.rs/syn/latest/syn/struct.Signature.html \"struct syn::Signature\")`full`\n    A function signature in a trait or implementation: `unsafe fn initialize(&self)`.\n\n[StmtMacro](https://docs.rs/syn/latest/syn/struct.StmtMacro.html \"struct syn::StmtMacro\")`full`\n    A macro invocation in statement position.\n\n[TraitBound](https://docs.rs/syn/latest/syn/struct.TraitBound.html \"struct syn::TraitBound\")`full` or `derive`\n    A trait used as a bound on a type parameter.\n\n[TraitItemConst](https://docs.rs/syn/latest/syn/struct.TraitItemConst.html \"struct syn::TraitItemConst\")`full`\n    An associated constant within the definition of a trait.\n\n[TraitItemFn](https://docs.rs/syn/latest/syn/struct.TraitItemFn.html \"struct syn::TraitItemFn\")`full`\n    An associated function within the definition of a trait.\n\n[TraitItemMacro](https://docs.rs/syn/latest/syn/struct.TraitItemMacro.html \"struct syn::TraitItemMacro\")`full`\n    A macro invocation within the definition of a trait.\n\n[TraitItemType](https://docs.rs/syn/latest/syn/struct.TraitItemType.html \"struct syn::TraitItemType\")`full`\n    An associated type within the definition of a trait.\n\n[Turbofish](https://docs.rs/syn/latest/syn/struct.Turbofish.html \"struct syn::Turbofish\")(`full` or `derive`) and `printing`\n    Returned by `TypeGenerics::as_turbofish`.\n\n[TypeArray](https://docs.rs/syn/latest/syn/struct.TypeArray.html \"struct syn::TypeArray\")`full` or `derive`\n    A fixed size array type: `[T; n]`.\n\n[TypeBareFn](https://docs.rs/syn/latest/syn/struct.TypeBareFn.html \"struct syn::TypeBareFn\")`full` or `derive`\n    A bare function type: `fn(usize) -> bool`.\n\n[TypeGenerics](https://docs.rs/syn/latest/syn/struct.TypeGenerics.html \"struct syn::TypeGenerics\")(`full` or `derive`) and `printing`\n    Returned by `Generics::split_for_impl`.\n\n[TypeGroup](https://docs.rs/syn/latest/syn/struct.TypeGroup.html \"struct syn::TypeGroup\")`full` or `derive`\n    A type contained within invisible delimiters.\n\n[TypeImplTrait](https://docs.rs/syn/latest/syn/struct.TypeImplTrait.html \"struct syn::TypeImplTrait\")`full` or `derive`\n    An `impl Bound1 + Bound2 + Bound3` type where `Bound` is a trait or a lifetime.\n\n[TypeInfer](https://docs.rs/syn/latest/syn/struct.TypeInfer.html \"struct syn::TypeInfer\")`full` or `derive`\n    Indication that a type should be inferred by the compiler: `_`.\n\n[TypeMacro](https://docs.rs/syn/latest/syn/struct.TypeMacro.html \"struct syn::TypeMacro\")`full` or `derive`\n    A macro in the type position.\n\n[TypeNever](https://docs.rs/syn/latest/syn/struct.TypeNever.html \"struct syn::TypeNever\")`full` or `derive`\n    The never type: `!`.\n\n[TypeParam](https://docs.rs/syn/latest/syn/struct.TypeParam.html \"struct syn::TypeParam\")`full` or `derive`\n    A generic type parameter: `T: Into<String>`.\n\n[TypeParen](https://docs.rs/syn/latest/syn/struct.TypeParen.html \"struct syn::TypeParen\")`full` or `derive`\n    A parenthesized type equivalent to the inner type.\n\n[TypePath](https://docs.rs/syn/latest/syn/struct.TypePath.html \"struct syn::TypePath\")`full` or `derive`\n    A path like `std::slice::Iter`, optionally qualified with a self-type as in `<Vec<T> as SomeTrait>::Associated`.\n\n[TypePtr](https://docs.rs/syn/latest/syn/struct.TypePtr.html \"struct syn::TypePtr\")`full` or `derive`\n    A raw pointer type: `*const T` or `*mut T`.\n\n[TypeReference](https://docs.rs/syn/latest/syn/struct.TypeReference.html \"struct syn::TypeReference\")`full` or `derive`\n    A reference type: `&'a T` or `&'a mut T`.\n\n[TypeSlice](https://docs.rs/syn/latest/syn/struct.TypeSlice.html \"struct syn::TypeSlice\")`full` or `derive`\n    A dynamically sized slice type: `[T]`.\n\n[TypeTraitObject](https://docs.rs/syn/latest/syn/struct.TypeTraitObject.html \"struct syn::TypeTraitObject\")`full` or `derive`\n    A trait object type `dyn Bound1 + Bound2 + Bound3` where `Bound` is a trait or a lifetime.\n\n[TypeTuple](https://docs.rs/syn/latest/syn/struct.TypeTuple.html \"struct syn::TypeTuple\")`full` or `derive`\n    A tuple type: `(A, B, C, String)`.\n\n[UseGlob](https://docs.rs/syn/latest/syn/struct.UseGlob.html \"struct syn::UseGlob\")`full`\n    A glob import in a `use` item: `*`.\n\n[UseGroup](https://docs.rs/syn/latest/syn/struct.UseGroup.html \"struct syn::UseGroup\")`full`\n    A braced group of imports in a `use` item: `{A, B, C}`.\n\n[UseName](https://docs.rs/syn/latest/syn/struct.UseName.html \"struct syn::UseName\")`full`\n    An identifier imported by a `use` item: `HashMap`.\n\n[UsePath](https://docs.rs/syn/latest/syn/struct.UsePath.html \"struct syn::UsePath\")`full`\n    A path prefix of imports in a `use` item: `std::...`.\n\n[UseRename](https://docs.rs/syn/latest/syn/struct.UseRename.html \"struct syn::UseRename\")`full`\n    An renamed identifier imported by a `use` item: `HashMap as Map`.\n\n[Variadic](https://docs.rs/syn/latest/syn/struct.Variadic.html \"struct syn::Variadic\")`full`\n    The variadic argument of a foreign function.\n\n[Variant](https://docs.rs/syn/latest/syn/struct.Variant.html \"struct syn::Variant\")`full` or `derive`\n    An enum variant.\n\n[VisRestricted](https://docs.rs/syn/latest/syn/struct.VisRestricted.html \"struct syn::VisRestricted\")`full` or `derive`\n    A visibility level restricted to some path: `pub(self)` or `pub(super)` or `pub(crate)` or `pub(in some::module)`.\n\n[WhereClause](https://docs.rs/syn/latest/syn/struct.WhereClause.html \"struct syn::WhereClause\")`full` or `derive`\n    A `where` clause in a definition: `where T: Deserialize<'de>, D: 'static`.\n## Enums[\u00a7](https://docs.rs/syn/latest/syn/#enums)\n\n[AttrStyle](https://docs.rs/syn/latest/syn/enum.AttrStyle.html \"enum syn::AttrStyle\")`full` or `derive`\n    Distinguishes between attributes that decorate an item and attributes that are contained within an item.\n\n[BinOp](https://docs.rs/syn/latest/syn/enum.BinOp.html \"enum syn::BinOp\")`full` or `derive`\n    A binary operator: `+`, `+=`, `&`.\n\n[CapturedParam](https://docs.rs/syn/latest/syn/enum.CapturedParam.html \"enum syn::CapturedParam\")`full`\n    Single parameter in a precise capturing bound.\n\n[Data](https://docs.rs/syn/latest/syn/enum.Data.html \"enum syn::Data\")`derive`\n    The storage of a struct, enum or union data structure.\n\n[Expr](https://docs.rs/syn/latest/syn/enum.Expr.html \"enum syn::Expr\")`full` or `derive`\n    A Rust expression.\n\n[FieldMutability](https://docs.rs/syn/latest/syn/enum.FieldMutability.html \"enum syn::FieldMutability\")`full` or `derive`\n    Unused, but reserved for RFC 3323 restrictions.\n\n[Fields](https://docs.rs/syn/latest/syn/enum.Fields.html \"enum syn::Fields\")`full` or `derive`\n    Data stored within an enum variant or struct.\n\n[FnArg](https://docs.rs/syn/latest/syn/enum.FnArg.html \"enum syn::FnArg\")`full`\n    An argument in a function signature: the `n: usize` in `fn f(n: usize)`.\n\n[ForeignItem](https://docs.rs/syn/latest/syn/enum.ForeignItem.html \"enum syn::ForeignItem\")`full`\n    An item within an `extern` block.\n\n[GenericArgument](https://docs.rs/syn/latest/syn/enum.GenericArgument.html \"enum syn::GenericArgument\")`full` or `derive`\n    An individual generic argument, like `'a`, `T`, or `Item = T`.\n\n[GenericParam](https://docs.rs/syn/latest/syn/enum.GenericParam.html \"enum syn::GenericParam\")`full` or `derive`\n    A generic type parameter, lifetime, or const generic: `T: Into<String>`, `'a: 'b`, `const LEN: usize`.\n\n[ImplItem](https://docs.rs/syn/latest/syn/enum.ImplItem.html \"enum syn::ImplItem\")`full`\n    An item within an impl block.\n\n[ImplRestriction](https://docs.rs/syn/latest/syn/enum.ImplRestriction.html \"enum syn::ImplRestriction\")`full`\n    Unused, but reserved for RFC 3323 restrictions.\n\n[Item](https://docs.rs/syn/latest/syn/enum.Item.html \"enum syn::Item\")`full`\n    Things that can appear directly inside of a module or scope.\n\n[Lit](https://docs.rs/syn/latest/syn/enum.Lit.html \"enum syn::Lit\")\n    A Rust literal such as a string or integer or boolean.\n\n[MacroDelimiter](https://docs.rs/syn/latest/syn/enum.MacroDelimiter.html \"enum syn::MacroDelimiter\")`full` or `derive`\n    A grouping token that surrounds a macro body: `m!(...)` or `m!{...}` or `m![...]`.\n\n[Member](https://docs.rs/syn/latest/syn/enum.Member.html \"enum syn::Member\")`full` or `derive`\n    A struct or tuple struct field accessed in a struct literal or field expression.\n\n[Meta](https://docs.rs/syn/latest/syn/enum.Meta.html \"enum syn::Meta\")`full` or `derive`\n    Content of a compile-time structured attribute.\n\n[Pat](https://docs.rs/syn/latest/syn/enum.Pat.html \"enum syn::Pat\")`full`\n    A pattern in a local binding, function signature, match expression, or various other places.\n\n[PathArguments](https://docs.rs/syn/latest/syn/enum.PathArguments.html \"enum syn::PathArguments\")`full` or `derive`\n    Angle bracketed or parenthesized arguments of a path segment.\n\n[PointerMutability](https://docs.rs/syn/latest/syn/enum.PointerMutability.html \"enum syn::PointerMutability\")`full`\n    Mutability of a raw pointer (`*const T`, `*mut T`), in which non-mutable isn\u2019t the implicit default.\n\n[RangeLimits](https://docs.rs/syn/latest/syn/enum.RangeLimits.html \"enum syn::RangeLimits\")`full`\n    Limit types of a range, inclusive or exclusive.\n\n[ReturnType](https://docs.rs/syn/latest/syn/enum.ReturnType.html \"enum syn::ReturnType\")`full` or `derive`\n    Return type of a function signature.\n\n[StaticMutability](https://docs.rs/syn/latest/syn/enum.StaticMutability.html \"enum syn::StaticMutability\")`full`\n    The mutability of an `Item::Static` or `ForeignItem::Static`.\n\n[Stmt](https://docs.rs/syn/latest/syn/enum.Stmt.html \"enum syn::Stmt\")`full`\n    A statement, usually ending in a semicolon.\n\n[TraitBoundModifier](https://docs.rs/syn/latest/syn/enum.TraitBoundModifier.html \"enum syn::TraitBoundModifier\")`full` or `derive`\n    A modifier on a trait bound, currently only used for the `?` in `?Sized`.\n\n[TraitItem](https://docs.rs/syn/latest/syn/enum.TraitItem.html \"enum syn::TraitItem\")`full`\n    An item declaration within the definition of a trait.\n\n[Type](https://docs.rs/syn/latest/syn/enum.Type.html \"enum syn::Type\")`full` or `derive`\n    The possible types that a Rust value could have.\n\n[TypeParamBound](https://docs.rs/syn/latest/syn/enum.TypeParamBound.html \"enum syn::TypeParamBound\")`full` or `derive`\n    A trait or lifetime used as a bound on a type parameter.\n\n[UnOp](https://docs.rs/syn/latest/syn/enum.UnOp.html \"enum syn::UnOp\")`full` or `derive`\n    A unary operator: `*`, `!`, `-`.\n\n[UseTree](https://docs.rs/syn/latest/syn/enum.UseTree.html \"enum syn::UseTree\")`full`\n    A suffix of an import tree in a `use` item: `Type as Renamed` or `*`.\n\n[Visibility](https://docs.rs/syn/latest/syn/enum.Visibility.html \"enum syn::Visibility\")`full` or `derive`\n    The visibility level of an item: inherited or `pub` or `pub(restricted)`.\n\n[WherePredicate](https://docs.rs/syn/latest/syn/enum.WherePredicate.html \"enum syn::WherePredicate\")`full` or `derive`\n    A single predicate in a `where` clause: `T: Deserialize<'de>`.\n## Functions[\u00a7](https://docs.rs/syn/latest/syn/#functions)\n\n[parse](https://docs.rs/syn/latest/syn/fn.parse.html \"fn syn::parse\")`parsing` and `proc-macro`\n    Parse tokens of source code into the chosen syntax tree node.\n\n[parse2](https://docs.rs/syn/latest/syn/fn.parse2.html \"fn syn::parse2\")`parsing`\n    Parse a proc-macro2 token stream into the chosen syntax tree node.\n\n[parse_file](https://docs.rs/syn/latest/syn/fn.parse_file.html \"fn syn::parse_file\")`parsing` and `full`\n    Parse the content of a file of Rust code.\n\n[parse_str](https://docs.rs/syn/latest/syn/fn.parse_str.html \"fn syn::parse_str\")`parsing`\n    Parse a string of Rust code into the chosen syntax tree node.\n## Type Aliases[\u00a7](https://docs.rs/syn/latest/syn/#types)\n\n[Result](https://docs.rs/syn/latest/syn/type.Result.html \"type syn::Result\")\n    The result of a Syn parser.\n",
            "markdown_with_citations": "[](https://docs.rs/syn/latest/syn/all.html \"show sidebar\")\n# Crate synCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\n![github\u27e84\u27e9](https://github.com/dtolnay/syn) ![crates-io\u27e85\u27e9](https://crates.io/crates/syn) ![docs-rs\u27e86\u27e9](https://docs.rs/syn/latest/syn/index.html \"mod syn\")\nSyn is a parsing library for parsing a stream of Rust tokens into a syntax tree of Rust source code.\nCurrently this library is geared toward use in Rust procedural macros, but contains some APIs that may be useful more generally.\n  * **Data structures** \u2014 Syn provides a complete syntax tree that can represent any valid Rust source code. The syntax tree is rooted at `syn::File`\u27e87\u27e9 which represents a full source file, but there are other entry points that may be useful to procedural macros including `syn::Item`\u27e88\u27e9, `syn::Expr`\u27e89\u27e9 and `syn::Type`\u27e810\u27e9.\n  * **Derives** \u2014 Of particular interest to derive macros is `syn::DeriveInput`\u27e811\u27e9 which is any of the three legal input items to a derive macro. An example below shows using this type in a library that can derive implementations of a user-defined trait.\n  * **Parsing** \u2014 Parsing in Syn is built around parser functions\u27e812\u27e9 with the signature `fn(ParseStream) -> Result<T>`. Every syntax tree node defined by Syn is individually parsable and may be used as a building block for custom syntaxes, or you may dream up your own brand new syntax without involving any of our syntax tree types.\n  * **Location information** \u2014 Every token parsed by Syn is associated with a `Span` that tracks line and column information back to the source of that token. These spans allow a procedural macro to display detailed error messages pointing to all the right places in the user\u2019s code. There is an example of this below.\n  * **Feature flags** \u2014 Functionality is aggressively feature gated so your procedural macros enable only what they need, and do not pay in compile time for all the rest.\n\n\n## \u00a7\u27e813\u27e9Example of a derive macro\nThe canonical derive macro using Syn looks like this. We write an ordinary Rust function tagged with a `proc_macro_derive` attribute and the name of the trait we are deriving. Any time that derive appears in the user\u2019s code, the Rust compiler passes their data structure as tokens into our macro. We get to execute arbitrary Rust code to figure out what to do with those tokens, then hand some tokens back to the compiler to compile into the user\u2019s crate.\n```\n[dependencies]\nsyn = \"2.0\"\nquote = \"1.0\"\n[lib]\nproc-macro = true\n```\n\n```\nuse proc_macro::TokenStream;\nuse quote::quote;\nuse syn::{parse_macro_input, DeriveInput};\n#[proc_macro_derive(MyMacro)]\npub fn my_macro(input: TokenStream) -> TokenStream {\n  // Parse the input tokens into a syntax tree\n  let input = parse_macro_input!(input as DeriveInput);\n  // Build the output, possibly using quasi-quotation\n  let expanded = quote! {\n    // ...\n  };\n  // Hand the output tokens back to the compiler\n  TokenStream::from(expanded)\n}\n```\n\nThe `heapsize`\u27e814\u27e9 example directory shows a complete working implementation of a derive macro. The example derives a `HeapSize` trait which computes an estimate of the amount of heap memory owned by a value.\n```\npub trait HeapSize {\n  /// Total number of bytes of heap memory owned by `self`.\n  fn heap_size_of_children(&self) -> usize;\n}\n```\n\nThe derive macro allows users to write `#[derive(HeapSize)]` on data structures in their program.\n```\n#[derive(HeapSize)]\nstruct Demo<'a, T: ?Sized> {\n  a: Box<T>,\n  b: u8,\n  c: &'a str,\n  d: String,\n}\n```\n\n## \u00a7\u27e815\u27e9Spans and error reporting\nThe token-based procedural macro API provides great control over where the compiler\u2019s error messages are displayed in user code. Consider the error the user sees if one of their field types does not implement `HeapSize`.\n```\n#[derive(HeapSize)]\nstruct Broken {\n  ok: String,\n  bad: std::thread::Thread,\n}\n```\n\nBy tracking span information all the way through the expansion of a procedural macro as shown in the `heapsize` example, token-based macros in Syn are able to trigger errors that directly pinpoint the source of the problem.\n```\nerror[E0277]: the trait bound `std::thread::Thread: HeapSize` is not satisfied\n --> src/main.rs:7:5\n |\n7 |   bad: std::thread::Thread,\n |   ^^^^^^^^^^^^^^^^^^^^^^^^ the trait `HeapSize` is not implemented for `Thread`\n```\n\n## \u00a7\u27e816\u27e9Parsing a custom syntax\nThe `lazy-static`\u27e817\u27e9 example directory shows the implementation of a `functionlike!(...)` procedural macro in which the input tokens are parsed using Syn\u2019s parsing API.\nThe example reimplements the popular `lazy_static` crate from crates.io as a procedural macro.\n```\nlazy_static! {\n  static ref USERNAME: Regex = Regex::new(\"^[a-z0-9_-]{3,16}$\").unwrap();\n}\n```\n\nThe implementation shows how to trigger custom warnings and error messages on the macro input.\n```\nwarning: come on, pick a more creative name\n --> src/main.rs:10:16\n  |\n10 |   static ref FOO: String = \"lazy_static\".to_owned();\n  |        ^^^\n```\n\n## \u00a7\u27e818\u27e9Testing\nWhen testing macros, we often care not just that the macro can be used successfully but also that when the macro is provided with invalid input it produces maximally helpful error messages. Consider using the `trybuild`\u27e819\u27e9 crate to write tests for errors that are emitted by your macro or errors detected by the Rust compiler in the expanded code following misuse of the macro. Such tests help avoid regressions from later refactors that mistakenly make an error no longer trigger or be less helpful than it used to be.\n## \u00a7\u27e820\u27e9Debugging\nWhen developing a procedural macro it can be helpful to look at what the generated code looks like. Use `cargo rustc -- -Zunstable-options --pretty=expanded` or the `cargo expand`\u27e821\u27e9 subcommand.\nTo show the expanded code for some crate that uses your procedural macro, run `cargo expand` from that crate. To show the expanded code for one of your own test cases, run `cargo expand --test the_test_case` where the last argument is the name of the test file without the `.rs` extension.\nThis write-up by Brandon W Maister discusses debugging in more detail: Debugging Rust\u2019s new Custom Derive system\u27e822\u27e9.\n## \u00a7\u27e823\u27e9Optional features\nSyn puts a lot of functionality behind optional features in order to optimize compile time for the most common use cases. The following features are available.\n  * **`derive`**_(enabled by default)_ \u2014 Data structures for representing the possible input to a derive macro, including structs and enums and types.\n  * **`full`**\u2014 Data structures for representing the syntax tree of all valid Rust source code, including items and expressions.\n  * **`parsing`**_(enabled by default)_ \u2014 Ability to parse input tokens into a syntax tree node of a chosen type.\n  * **`printing`**_(enabled by default)_ \u2014 Ability to print a syntax tree node as tokens of Rust source code.\n  * **`visit`**\u2014 Trait for traversing a syntax tree.\n  * **`visit-mut`**\u2014 Trait for traversing and mutating in place a syntax tree.\n  * **`fold`**\u2014 Trait for transforming an owned syntax tree.\n  * **`clone-impls`**_(enabled by default)_ \u2014 Clone impls for all syntax tree types.\n  * **`extra-traits`**\u2014 Debug, Eq, PartialEq, Hash impls for all syntax tree types.\n  * **`proc-macro`**_(enabled by default)_ \u2014 Runtime dependency on the dynamic library libproc_macro from rustc toolchain.\n\n\n## Modules\u00a7\u27e824\u27e9\n\nbuffer\u27e825\u27e9`parsing`\n    A stably addressed token buffer supporting efficient traversal based on a cheaply copyable cursor.\n\next\u27e826\u27e9`parsing`\n    Extension traits to provide parsing methods on foreign types.\n\nfold\u27e827\u27e9`fold`\n    Syntax tree traversal to transform the nodes of an owned syntax tree.\n\nmeta\u27e828\u27e9`parsing` and (`full` or `derive`)\n    Facility for interpreting structured content inside of an `Attribute`.\n\nparse\u27e812\u27e9`parsing`\n    Parsing interface for parsing a token stream into a syntax tree node.\n\npunctuated\u27e829\u27e9\n    A punctuated sequence of syntax tree nodes separated by punctuation.\n\nspanned\u27e830\u27e9`parsing` and `printing`\n    A trait that can provide the `Span` of the complete contents of a syntax tree node.\n\ntoken\u27e831\u27e9\n    Tokens representing Rust punctuation, keywords, and delimiters.\n\nvisit\u27e832\u27e9`visit`\n    Syntax tree traversal to walk a shared borrow of a syntax tree.\n\nvisit_mut\u27e833\u27e9`visit-mut`\n    Syntax tree traversal to mutate an exclusive borrow of a syntax tree in place.\n## Macros\u00a7\u27e834\u27e9\n\nToken\u27e835\u27e9\n    A type-macro that expands to the name of the Rust type representation of a given token.\n\nbraced\u27e836\u27e9`parsing`\n    Parse a set of curly braces and expose their content to subsequent parsers.\n\nbracketed\u27e837\u27e9`parsing`\n    Parse a set of square brackets and expose their content to subsequent parsers.\n\ncustom_keyword\u27e838\u27e9\n    Define a type that supports parsing and printing a given identifier as if it were a keyword.\n\ncustom_punctuation\u27e839\u27e9\n    Define a type that supports parsing and printing a multi-character symbol as if it were a punctuation token.\n\nparenthesized\u27e840\u27e9`parsing`\n    Parse a set of parentheses and expose their content to subsequent parsers.\n\nparse_macro_input\u27e841\u27e9`parsing` and `proc-macro`\n    Parse the input TokenStream of a macro, triggering a compile error if the tokens fail to parse.\n\nparse_quote\u27e842\u27e9`parsing` and `printing`\n    Quasi-quotation macro that accepts input like the `quote!`\u27e843\u27e9 macro but uses type inference to figure out a return type for those tokens.\n\nparse_quote_spanned\u27e844\u27e9`parsing` and `printing`\n    This macro is `parse_quote!`\u27e842\u27e9 + `quote_spanned!`\u27e845\u27e9.\n## Structs\u00a7\u27e846\u27e9\n\nAbi\u27e847\u27e9`full` or `derive`\n    The binary interface of a function: `extern \"C\"`.\n\nAngleBracketedGenericArguments\u27e848\u27e9`full` or `derive`\n    Angle bracketed arguments of a path segment: the `<K, V>` in `HashMap<K, V>`.\n\nArm\u27e849\u27e9`full`\n    One arm of a `match` expression: `0..=10 => { return true; }`.\n\nAssocConst\u27e850\u27e9`full` or `derive`\n    An equality constraint on an associated constant: the `PANIC = false` in `Trait<PANIC = false>`.\n\nAssocType\u27e851\u27e9`full` or `derive`\n    A binding (equality constraint) on an associated type: the `Item = u8` in `Iterator<Item = u8>`.\n\nAttribute\u27e852\u27e9`full` or `derive`\n    An attribute, like `#[repr(transparent)]`.\n\nBareFnArg\u27e853\u27e9`full` or `derive`\n    An argument in a function type: the `usize` in `fn(usize) -> bool`.\n\nBareVariadic\u27e854\u27e9`full` or `derive`\n    The variadic argument of a function pointer like `fn(usize, ...)`.\n\nBlock\u27e855\u27e9`full`\n    A braced block containing Rust statements.\n\nBoundLifetimes\u27e856\u27e9`full` or `derive`\n    A set of bound lifetimes: `for<'a, 'b, 'c>`.\n\nConstParam\u27e857\u27e9`full` or `derive`\n    A const generic parameter: `const LENGTH: usize`.\n\nConstraint\u27e858\u27e9`full` or `derive`\n    An associated type bound: `Iterator<Item: Display>`.\n\nDataEnum\u27e859\u27e9`derive`\n    An enum input to a `proc_macro_derive` macro.\n\nDataStruct\u27e860\u27e9`derive`\n    A struct input to a `proc_macro_derive` macro.\n\nDataUnion\u27e861\u27e9`derive`\n    An untagged union input to a `proc_macro_derive` macro.\n\nDeriveInput\u27e811\u27e9`derive`\n    Data structure sent to a `proc_macro_derive` macro.\n\nError\u27e862\u27e9\n    Error returned when a Syn parser cannot parse the input tokens.\n\nExprArray\u27e863\u27e9`full`\n    A slice literal expression: `[a, b, c, d]`.\n\nExprAssign\u27e864\u27e9`full`\n    An assignment expression: `a = compute()`.\n\nExprAsync\u27e865\u27e9`full`\n    An async block: `async { ... }`.\n\nExprAwait\u27e866\u27e9`full`\n    An await expression: `fut.await`.\n\nExprBinary\u27e867\u27e9`full` or `derive`\n    A binary operation: `a + b`, `a += b`.\n\nExprBlock\u27e868\u27e9`full`\n    A blocked scope: `{ ... }`.\n\nExprBreak\u27e869\u27e9`full`\n    A `break`, with an optional label to break and an optional expression.\n\nExprCall\u27e870\u27e9`full` or `derive`\n    A function call expression: `invoke(a, b)`.\n\nExprCast\u27e871\u27e9`full` or `derive`\n    A cast expression: `foo as f64`.\n\nExprClosure\u27e872\u27e9`full`\n    A closure expression: `|a, b| a + b`.\n\nExprConst\u27e873\u27e9`full`\n    A const block: `const { ... }`.\n\nExprContinue\u27e874\u27e9`full`\n    A `continue`, with an optional label.\n\nExprField\u27e875\u27e9`full` or `derive`\n    Access of a named struct field (`obj.k`) or unnamed tuple struct field (`obj.0`).\n\nExprForLoop\u27e876\u27e9`full`\n    A for loop: `for pat in expr { ... }`.\n\nExprGroup\u27e877\u27e9`full`\n    An expression contained within invisible delimiters.\n\nExprIf\u27e878\u27e9`full`\n    An `if` expression with an optional `else` block: `if expr { ... } else { ... }`.\n\nExprIndex\u27e879\u27e9`full` or `derive`\n    A square bracketed indexing expression: `vector[2]`.\n\nExprInfer\u27e880\u27e9`full`\n    The inferred value of a const generic argument, denoted `_`.\n\nExprLet\u27e881\u27e9`full`\n    A `let` guard: `let Some(x) = opt`.\n\nExprLit\u27e882\u27e9`full` or `derive`\n    A literal in place of an expression: `1`, `\"foo\"`.\n\nExprLoop\u27e883\u27e9`full`\n    Conditionless loop: `loop { ... }`.\n\nExprMacro\u27e884\u27e9`full` or `derive`\n    A macro invocation expression: `format!(\"{}\", q)`.\n\nExprMatch\u27e885\u27e9`full`\n    A `match` expression: `match n { Some(n) => {}, None => {} }`.\n\nExprMethodCall\u27e886\u27e9`full` or `derive`\n    A method call expression: `x.foo::<T>(a, b)`.\n\nExprParen\u27e887\u27e9`full` or `derive`\n    A parenthesized expression: `(a + b)`.\n\nExprPath\u27e888\u27e9`full` or `derive`\n    A path like `std::mem::replace` possibly containing generic parameters and a qualified self-type.\n\nExprRange\u27e889\u27e9`full`\n    A range expression: `1..2`, `1..`, `..2`, `1..=2`, `..=2`.\n\nExprRawAddr\u27e890\u27e9`full`\n    Address-of operation: `&raw const place` or `&raw mut place`.\n\nExprReference\u27e891\u27e9`full` or `derive`\n    A referencing operation: `&a` or `&mut a`.\n\nExprRepeat\u27e892\u27e9`full`\n    An array literal constructed from one repeated element: `[0u8; N]`.\n\nExprReturn\u27e893\u27e9`full`\n    A `return`, with an optional value to be returned.\n\nExprStruct\u27e894\u27e9`full` or `derive`\n    A struct literal expression: `Point { x: 1, y: 1 }`.\n\nExprTry\u27e895\u27e9`full`\n    A try-expression: `expr?`.\n\nExprTryBlock\u27e896\u27e9`full`\n    A try block: `try { ... }`.\n\nExprTuple\u27e897\u27e9`full`\n    A tuple expression: `(a, b, c, d)`.\n\nExprUnary\u27e898\u27e9`full` or `derive`\n    A unary operation: `!x`, `*x`.\n\nExprUnsafe\u27e899\u27e9`full`\n    An unsafe block: `unsafe { ... }`.\n\nExprWhile\u27e8100\u27e9`full`\n    A while loop: `while expr { ... }`.\n\nExprYield\u27e8101\u27e9`full`\n    A yield expression: `yield expr`.\n\nField\u27e8102\u27e9`full` or `derive`\n    A field of a struct or enum variant.\n\nFieldPat\u27e8103\u27e9`full`\n    A single field in a struct pattern.\n\nFieldValue\u27e8104\u27e9`full` or `derive`\n    A field-value pair in a struct literal.\n\nFieldsNamed\u27e8105\u27e9`full` or `derive`\n    Named fields of a struct or struct variant such as `Point { x: f64, y: f64 }`.\n\nFieldsUnnamed\u27e8106\u27e9`full` or `derive`\n    Unnamed fields of a tuple struct or tuple variant such as `Some(T)`.\n\nFile\u27e87\u27e9`full`\n    A complete file of Rust source code.\n\nForeignItemFn\u27e8107\u27e9`full`\n    A foreign function in an `extern` block.\n\nForeignItemMacro\u27e8108\u27e9`full`\n    A macro invocation within an extern block.\n\nForeignItemStatic\u27e8109\u27e9`full`\n    A foreign static item in an `extern` block: `static ext: u8`.\n\nForeignItemType\u27e8110\u27e9`full`\n    A foreign type in an `extern` block: `type void`.\n\nGenerics\u27e8111\u27e9`full` or `derive`\n    Lifetimes and type parameters attached to a declaration of a function, enum, trait, etc.\n\nIdent\u27e8112\u27e9\n    A word of Rust code, which may be a keyword or legal variable name.\n\nImplGenerics\u27e8113\u27e9(`full` or `derive`) and `printing`\n    Returned by `Generics::split_for_impl`.\n\nImplItemConst\u27e8114\u27e9`full`\n    An associated constant within an impl block.\n\nImplItemFn\u27e8115\u27e9`full`\n    An associated function within an impl block.\n\nImplItemMacro\u27e8116\u27e9`full`\n    A macro invocation within an impl block.\n\nImplItemType\u27e8117\u27e9`full`\n    An associated type within an impl block.\n\nIndex\u27e8118\u27e9`full` or `derive`\n    The index of an unnamed tuple struct field.\n\nItemConst\u27e8119\u27e9`full`\n    A constant item: `const MAX: u16 = 65535`.\n\nItemEnum\u27e8120\u27e9`full`\n    An enum definition: `enum Foo<A, B> { A(A), B(B) }`.\n\nItemExternCrate\u27e8121\u27e9`full`\n    An `extern crate` item: `extern crate serde`.\n\nItemFn\u27e8122\u27e9`full`\n    A free-standing function: `fn process(n: usize) -> Result<()> { ... }`.\n\nItemForeignMod\u27e8123\u27e9`full`\n    A block of foreign items: `extern \"C\" { ... }`.\n\nItemImpl\u27e8124\u27e9`full`\n    An impl block providing trait or associated items: `impl<A> Trait for Data<A> { ... }`.\n\nItemMacro\u27e8125\u27e9`full`\n    A macro invocation, which includes `macro_rules!` definitions.\n\nItemMod\u27e8126\u27e9`full`\n    A module or module declaration: `mod m` or `mod m { ... }`.\n\nItemStatic\u27e8127\u27e9`full`\n    A static item: `static BIKE: Shed = Shed(42)`.\n\nItemStruct\u27e8128\u27e9`full`\n    A struct definition: `struct Foo<A> { x: A }`.\n\nItemTrait\u27e8129\u27e9`full`\n    A trait definition: `pub trait Iterator { ... }`.\n\nItemTraitAlias\u27e8130\u27e9`full`\n    A trait alias: `pub trait SharableIterator = Iterator + Sync`.\n\nItemType\u27e8131\u27e9`full`\n    A type alias: `type Result<T> = std::result::Result<T, MyError>`.\n\nItemUnion\u27e8132\u27e9`full`\n    A union definition: `union Foo<A, B> { x: A, y: B }`.\n\nItemUse\u27e8133\u27e9`full`\n    A use declaration: `use std::collections::HashMap`.\n\nLabel\u27e8134\u27e9`full`\n    A lifetime labeling a `for`, `while`, or `loop`.\n\nLifetime\u27e8135\u27e9\n    A Rust lifetime: `'a`.\n\nLifetimeParam\u27e8136\u27e9`full` or `derive`\n    A lifetime definition: `'a: 'b + 'c + 'd`.\n\nLitBool\u27e8137\u27e9\n    A boolean literal: `true` or `false`.\n\nLitByte\u27e8138\u27e9\n    A byte literal: `b'f'`.\n\nLitByteStr\u27e8139\u27e9\n    A byte string literal: `b\"foo\"`.\n\nLitCStr\u27e8140\u27e9\n    A nul-terminated C-string literal: `c\"foo\"`.\n\nLitChar\u27e8141\u27e9\n    A character literal: `'a'`.\n\nLitFloat\u27e8142\u27e9\n    A floating point literal: `1f64` or `1.0e10f64`.\n\nLitInt\u27e8143\u27e9\n    An integer literal: `1` or `1u16`.\n\nLitStr\u27e8144\u27e9\n    A UTF-8 string literal: `\"foo\"`.\n\nLocal\u27e8145\u27e9`full`\n    A local `let` binding: `let x: u64 = s.parse()?;`.\n\nLocalInit\u27e8146\u27e9`full`\n    The expression assigned in a local `let` binding, including optional diverging `else` block.\n\nMacro\u27e8147\u27e9`full` or `derive`\n    A macro invocation: `println!(\"{}\", mac)`.\n\nMetaList\u27e8148\u27e9`full` or `derive`\n    A structured list within an attribute, like `derive(Copy, Clone)`.\n\nMetaNameValue\u27e8149\u27e9`full` or `derive`\n    A name-value pair within an attribute, like `feature = \"nightly\"`.\n\nParenthesizedGenericArguments\u27e8150\u27e9`full` or `derive`\n    Arguments of a function path segment: the `(A, B) -> C` in `Fn(A,B) -> C`.\n\nPatConst\u27e8151\u27e9`full`\n    A const block: `const { ... }`.\n\nPatIdent\u27e8152\u27e9`full`\n    A pattern that binds a new variable: `ref mut binding @ SUBPATTERN`.\n\nPatLit\u27e8153\u27e9`full`\n    A literal in place of an expression: `1`, `\"foo\"`.\n\nPatMacro\u27e8154\u27e9`full`\n    A macro invocation expression: `format!(\"{}\", q)`.\n\nPatOr\u27e8155\u27e9`full`\n    A pattern that matches any one of a set of cases.\n\nPatParen\u27e8156\u27e9`full`\n    A parenthesized pattern: `(A | B)`.\n\nPatPath\u27e8157\u27e9`full`\n    A path like `std::mem::replace` possibly containing generic parameters and a qualified self-type.\n\nPatRange\u27e8158\u27e9`full`\n    A range expression: `1..2`, `1..`, `..2`, `1..=2`, `..=2`.\n\nPatReference\u27e8159\u27e9`full`\n    A reference pattern: `&mut var`.\n\nPatRest\u27e8160\u27e9`full`\n    The dots in a tuple or slice pattern: `[0, 1, ..]`.\n\nPatSlice\u27e8161\u27e9`full`\n    A dynamically sized slice pattern: `[a, b, ref i @ .., y, z]`.\n\nPatStruct\u27e8162\u27e9`full`\n    A struct or struct variant pattern: `Variant { x, y, .. }`.\n\nPatTuple\u27e8163\u27e9`full`\n    A tuple pattern: `(a, b)`.\n\nPatTupleStruct\u27e8164\u27e9`full`\n    A tuple struct or tuple variant pattern: `Variant(x, y, .., z)`.\n\nPatType\u27e8165\u27e9`full`\n    A type ascription pattern: `foo: f64`.\n\nPatWild\u27e8166\u27e9`full`\n    A pattern that matches any value: `_`.\n\nPath\u27e8167\u27e9`full` or `derive`\n    A path at which a named item is exported (e.g. `std::collections::HashMap`).\n\nPathSegment\u27e8168\u27e9`full` or `derive`\n    A segment of a path together with any path arguments on that segment.\n\nPreciseCapture\u27e8169\u27e9`full`\n    Precise capturing bound: the \u2018use<\u2026>\u2019 in `impl Trait + use<'a, T>`.\n\nPredicateLifetime\u27e8170\u27e9`full` or `derive`\n    A lifetime predicate in a `where` clause: `'a: 'b + 'c`.\n\nPredicateType\u27e8171\u27e9`full` or `derive`\n    A type predicate in a `where` clause: `for<'c> Foo<'c>: Trait<'c>`.\n\nQSelf\u27e8172\u27e9`full` or `derive`\n    The explicit Self type in a qualified path: the `T` in `<T as Display>::fmt`.\n\nReceiver\u27e8173\u27e9`full`\n    The `self` argument of an associated method.\n\nSignature\u27e8174\u27e9`full`\n    A function signature in a trait or implementation: `unsafe fn initialize(&self)`.\n\nStmtMacro\u27e8175\u27e9`full`\n    A macro invocation in statement position.\n\nTraitBound\u27e8176\u27e9`full` or `derive`\n    A trait used as a bound on a type parameter.\n\nTraitItemConst\u27e8177\u27e9`full`\n    An associated constant within the definition of a trait.\n\nTraitItemFn\u27e8178\u27e9`full`\n    An associated function within the definition of a trait.\n\nTraitItemMacro\u27e8179\u27e9`full`\n    A macro invocation within the definition of a trait.\n\nTraitItemType\u27e8180\u27e9`full`\n    An associated type within the definition of a trait.\n\nTurbofish\u27e8181\u27e9(`full` or `derive`) and `printing`\n    Returned by `TypeGenerics::as_turbofish`.\n\nTypeArray\u27e8182\u27e9`full` or `derive`\n    A fixed size array type: `[T; n]`.\n\nTypeBareFn\u27e8183\u27e9`full` or `derive`\n    A bare function type: `fn(usize) -> bool`.\n\nTypeGenerics\u27e8184\u27e9(`full` or `derive`) and `printing`\n    Returned by `Generics::split_for_impl`.\n\nTypeGroup\u27e8185\u27e9`full` or `derive`\n    A type contained within invisible delimiters.\n\nTypeImplTrait\u27e8186\u27e9`full` or `derive`\n    An `impl Bound1 + Bound2 + Bound3` type where `Bound` is a trait or a lifetime.\n\nTypeInfer\u27e8187\u27e9`full` or `derive`\n    Indication that a type should be inferred by the compiler: `_`.\n\nTypeMacro\u27e8188\u27e9`full` or `derive`\n    A macro in the type position.\n\nTypeNever\u27e8189\u27e9`full` or `derive`\n    The never type: `!`.\n\nTypeParam\u27e8190\u27e9`full` or `derive`\n    A generic type parameter: `T: Into<String>`.\n\nTypeParen\u27e8191\u27e9`full` or `derive`\n    A parenthesized type equivalent to the inner type.\n\nTypePath\u27e8192\u27e9`full` or `derive`\n    A path like `std::slice::Iter`, optionally qualified with a self-type as in `<Vec<T> as SomeTrait>::Associated`.\n\nTypePtr\u27e8193\u27e9`full` or `derive`\n    A raw pointer type: `*const T` or `*mut T`.\n\nTypeReference\u27e8194\u27e9`full` or `derive`\n    A reference type: `&'a T` or `&'a mut T`.\n\nTypeSlice\u27e8195\u27e9`full` or `derive`\n    A dynamically sized slice type: `[T]`.\n\nTypeTraitObject\u27e8196\u27e9`full` or `derive`\n    A trait object type `dyn Bound1 + Bound2 + Bound3` where `Bound` is a trait or a lifetime.\n\nTypeTuple\u27e8197\u27e9`full` or `derive`\n    A tuple type: `(A, B, C, String)`.\n\nUseGlob\u27e8198\u27e9`full`\n    A glob import in a `use` item: `*`.\n\nUseGroup\u27e8199\u27e9`full`\n    A braced group of imports in a `use` item: `{A, B, C}`.\n\nUseName\u27e8200\u27e9`full`\n    An identifier imported by a `use` item: `HashMap`.\n\nUsePath\u27e8201\u27e9`full`\n    A path prefix of imports in a `use` item: `std::...`.\n\nUseRename\u27e8202\u27e9`full`\n    An renamed identifier imported by a `use` item: `HashMap as Map`.\n\nVariadic\u27e8203\u27e9`full`\n    The variadic argument of a foreign function.\n\nVariant\u27e8204\u27e9`full` or `derive`\n    An enum variant.\n\nVisRestricted\u27e8205\u27e9`full` or `derive`\n    A visibility level restricted to some path: `pub(self)` or `pub(super)` or `pub(crate)` or `pub(in some::module)`.\n\nWhereClause\u27e8206\u27e9`full` or `derive`\n    A `where` clause in a definition: `where T: Deserialize<'de>, D: 'static`.\n## Enums\u00a7\u27e8207\u27e9\n\nAttrStyle\u27e8208\u27e9`full` or `derive`\n    Distinguishes between attributes that decorate an item and attributes that are contained within an item.\n\nBinOp\u27e8209\u27e9`full` or `derive`\n    A binary operator: `+`, `+=`, `&`.\n\nCapturedParam\u27e8210\u27e9`full`\n    Single parameter in a precise capturing bound.\n\nData\u27e8211\u27e9`derive`\n    The storage of a struct, enum or union data structure.\n\nExpr\u27e89\u27e9`full` or `derive`\n    A Rust expression.\n\nFieldMutability\u27e8212\u27e9`full` or `derive`\n    Unused, but reserved for RFC 3323 restrictions.\n\nFields\u27e8213\u27e9`full` or `derive`\n    Data stored within an enum variant or struct.\n\nFnArg\u27e8214\u27e9`full`\n    An argument in a function signature: the `n: usize` in `fn f(n: usize)`.\n\nForeignItem\u27e8215\u27e9`full`\n    An item within an `extern` block.\n\nGenericArgument\u27e8216\u27e9`full` or `derive`\n    An individual generic argument, like `'a`, `T`, or `Item = T`.\n\nGenericParam\u27e8217\u27e9`full` or `derive`\n    A generic type parameter, lifetime, or const generic: `T: Into<String>`, `'a: 'b`, `const LEN: usize`.\n\nImplItem\u27e8218\u27e9`full`\n    An item within an impl block.\n\nImplRestriction\u27e8219\u27e9`full`\n    Unused, but reserved for RFC 3323 restrictions.\n\nItem\u27e88\u27e9`full`\n    Things that can appear directly inside of a module or scope.\n\nLit\u27e8220\u27e9\n    A Rust literal such as a string or integer or boolean.\n\nMacroDelimiter\u27e8221\u27e9`full` or `derive`\n    A grouping token that surrounds a macro body: `m!(...)` or `m!{...}` or `m![...]`.\n\nMember\u27e8222\u27e9`full` or `derive`\n    A struct or tuple struct field accessed in a struct literal or field expression.\n\nMeta\u27e8223\u27e9`full` or `derive`\n    Content of a compile-time structured attribute.\n\nPat\u27e8224\u27e9`full`\n    A pattern in a local binding, function signature, match expression, or various other places.\n\nPathArguments\u27e8225\u27e9`full` or `derive`\n    Angle bracketed or parenthesized arguments of a path segment.\n\nPointerMutability\u27e8226\u27e9`full`\n    Mutability of a raw pointer (`*const T`, `*mut T`), in which non-mutable isn\u2019t the implicit default.\n\nRangeLimits\u27e8227\u27e9`full`\n    Limit types of a range, inclusive or exclusive.\n\nReturnType\u27e8228\u27e9`full` or `derive`\n    Return type of a function signature.\n\nStaticMutability\u27e8229\u27e9`full`\n    The mutability of an `Item::Static` or `ForeignItem::Static`.\n\nStmt\u27e8230\u27e9`full`\n    A statement, usually ending in a semicolon.\n\nTraitBoundModifier\u27e8231\u27e9`full` or `derive`\n    A modifier on a trait bound, currently only used for the `?` in `?Sized`.\n\nTraitItem\u27e8232\u27e9`full`\n    An item declaration within the definition of a trait.\n\nType\u27e810\u27e9`full` or `derive`\n    The possible types that a Rust value could have.\n\nTypeParamBound\u27e8233\u27e9`full` or `derive`\n    A trait or lifetime used as a bound on a type parameter.\n\nUnOp\u27e8234\u27e9`full` or `derive`\n    A unary operator: `*`, `!`, `-`.\n\nUseTree\u27e8235\u27e9`full`\n    A suffix of an import tree in a `use` item: `Type as Renamed` or `*`.\n\nVisibility\u27e8236\u27e9`full` or `derive`\n    The visibility level of an item: inherited or `pub` or `pub(restricted)`.\n\nWherePredicate\u27e8237\u27e9`full` or `derive`\n    A single predicate in a `where` clause: `T: Deserialize<'de>`.\n## Functions\u00a7\u27e8238\u27e9\n\nparse\u27e8239\u27e9`parsing` and `proc-macro`\n    Parse tokens of source code into the chosen syntax tree node.\n\nparse2\u27e8240\u27e9`parsing`\n    Parse a proc-macro2 token stream into the chosen syntax tree node.\n\nparse_file\u27e8241\u27e9`parsing` and `full`\n    Parse the content of a file of Rust code.\n\nparse_str\u27e8242\u27e9`parsing`\n    Parse a string of Rust code into the chosen syntax tree node.\n## Type Aliases\u00a7\u27e8243\u27e9\n\nResult\u27e8244\u27e9\n    The result of a Syn parser.\n",
            "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/syn/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/syn/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/syn/latest/src/syn/lib.rs.html#1-1011: Source\n\u27e84\u27e9 https://img.shields.io/badge/github-8da0cb?style=for-the-badge&labelColor=555555&logo=github: ![github\n\u27e85\u27e9 https://img.shields.io/badge/crates.io-fc8d62?style=for-the-badge&labelColor=555555&logo=rust: ![crates-io\n\u27e86\u27e9 https://img.shields.io/badge/docs.rs-66c2a5?style=for-the-badge&labelColor=555555&logo=docs.rs: ![docs-rs\n\u27e87\u27e9 https://docs.rs/syn/latest/syn/struct.File.html: struct syn::File - `syn::File`\n\u27e88\u27e9 https://docs.rs/syn/latest/syn/enum.Item.html: enum syn::Item - `syn::Item`\n\u27e89\u27e9 https://docs.rs/syn/latest/syn/enum.Expr.html: enum syn::Expr - `syn::Expr`\n\u27e810\u27e9 https://docs.rs/syn/latest/syn/enum.Type.html: enum syn::Type - `syn::Type`\n\u27e811\u27e9 https://docs.rs/syn/latest/syn/struct.DeriveInput.html: struct syn::DeriveInput - `syn::DeriveInput`\n\u27e812\u27e9 https://docs.rs/syn/latest/syn/parse/index.html: mod syn::parse - parser functions\n\u27e813\u27e9 https://docs.rs/syn/latest/syn/#example-of-a-derive-macro: \u00a7\n\u27e814\u27e9 https://github.com/dtolnay/syn/tree/master/examples/heapsize: `heapsize`\n\u27e815\u27e9 https://docs.rs/syn/latest/syn/#spans-and-error-reporting: \u00a7\n\u27e816\u27e9 https://docs.rs/syn/latest/syn/#parsing-a-custom-syntax: \u00a7\n\u27e817\u27e9 https://github.com/dtolnay/syn/tree/master/examples/lazy-static: `lazy-static`\n\u27e818\u27e9 https://docs.rs/syn/latest/syn/#testing: \u00a7\n\u27e819\u27e9 https://github.com/dtolnay/trybuild: `trybuild`\n\u27e820\u27e9 https://docs.rs/syn/latest/syn/#debugging: \u00a7\n\u27e821\u27e9 https://github.com/dtolnay/cargo-expand: `cargo expand`\n\u27e822\u27e9 https://quodlibetor.github.io/posts/debugging-rusts-new-custom-derive-system/: Debugging Rust\u2019s new Custom Derive system\n\u27e823\u27e9 https://docs.rs/syn/latest/syn/#optional-features: \u00a7\n\u27e824\u27e9 https://docs.rs/syn/latest/syn/#modules: \u00a7\n\u27e825\u27e9 https://docs.rs/syn/latest/syn/buffer/index.html: mod syn::buffer - buffer\n\u27e826\u27e9 https://docs.rs/syn/latest/syn/ext/index.html: mod syn::ext - ext\n\u27e827\u27e9 https://docs.rs/syn/latest/syn/fold/index.html: mod syn::fold - fold\n\u27e828\u27e9 https://docs.rs/syn/latest/syn/meta/index.html: mod syn::meta - meta\n\u27e829\u27e9 https://docs.rs/syn/latest/syn/punctuated/index.html: mod syn::punctuated - punctuated\n\u27e830\u27e9 https://docs.rs/syn/latest/syn/spanned/index.html: mod syn::spanned - spanned\n\u27e831\u27e9 https://docs.rs/syn/latest/syn/token/index.html: mod syn::token - token\n\u27e832\u27e9 https://docs.rs/syn/latest/syn/visit/index.html: mod syn::visit - visit\n\u27e833\u27e9 https://docs.rs/syn/latest/syn/visit_mut/index.html: mod syn::visit_mut - visit_mut\n\u27e834\u27e9 https://docs.rs/syn/latest/syn/#macros: \u00a7\n\u27e835\u27e9 https://docs.rs/syn/latest/syn/macro.Token.html: macro syn::Token - Token\n\u27e836\u27e9 https://docs.rs/syn/latest/syn/macro.braced.html: macro syn::braced - braced\n\u27e837\u27e9 https://docs.rs/syn/latest/syn/macro.bracketed.html: macro syn::bracketed - bracketed\n\u27e838\u27e9 https://docs.rs/syn/latest/syn/macro.custom_keyword.html: macro syn::custom_keyword - custom_keyword\n\u27e839\u27e9 https://docs.rs/syn/latest/syn/macro.custom_punctuation.html: macro syn::custom_punctuation - custom_punctuation\n\u27e840\u27e9 https://docs.rs/syn/latest/syn/macro.parenthesized.html: macro syn::parenthesized - parenthesized\n\u27e841\u27e9 https://docs.rs/syn/latest/syn/macro.parse_macro_input.html: macro syn::parse_macro_input - parse_macro_input\n\u27e842\u27e9 https://docs.rs/syn/latest/syn/macro.parse_quote.html: macro syn::parse_quote - parse_quote\n\u27e843\u27e9 https://docs.rs/quote/1.0/quote/index.html: `quote!`\n\u27e844\u27e9 https://docs.rs/syn/latest/syn/macro.parse_quote_spanned.html: macro syn::parse_quote_spanned - parse_quote_spanned\n\u27e845\u27e9 https://docs.rs/quote/1.0.40/x86_64-unknown-linux-gnu/quote/macro.quote_spanned.html: macro quote::quote_spanned - `quote_spanned!`\n\u27e846\u27e9 https://docs.rs/syn/latest/syn/#structs: \u00a7\n\u27e847\u27e9 https://docs.rs/syn/latest/syn/struct.Abi.html: struct syn::Abi - Abi\n\u27e848\u27e9 https://docs.rs/syn/latest/syn/struct.AngleBracketedGenericArguments.html: struct syn::AngleBracketedGenericArguments - AngleBracketedGenericArguments\n\u27e849\u27e9 https://docs.rs/syn/latest/syn/struct.Arm.html: struct syn::Arm - Arm\n\u27e850\u27e9 https://docs.rs/syn/latest/syn/struct.AssocConst.html: struct syn::AssocConst - AssocConst\n\u27e851\u27e9 https://docs.rs/syn/latest/syn/struct.AssocType.html: struct syn::AssocType - AssocType\n\u27e852\u27e9 https://docs.rs/syn/latest/syn/struct.Attribute.html: struct syn::Attribute - Attribute\n\u27e853\u27e9 https://docs.rs/syn/latest/syn/struct.BareFnArg.html: struct syn::BareFnArg - BareFnArg\n\u27e854\u27e9 https://docs.rs/syn/latest/syn/struct.BareVariadic.html: struct syn::BareVariadic - BareVariadic\n\u27e855\u27e9 https://docs.rs/syn/latest/syn/struct.Block.html: struct syn::Block - Block\n\u27e856\u27e9 https://docs.rs/syn/latest/syn/struct.BoundLifetimes.html: struct syn::BoundLifetimes - BoundLifetimes\n\u27e857\u27e9 https://docs.rs/syn/latest/syn/struct.ConstParam.html: struct syn::ConstParam - ConstParam\n\u27e858\u27e9 https://docs.rs/syn/latest/syn/struct.Constraint.html: struct syn::Constraint - Constraint\n\u27e859\u27e9 https://docs.rs/syn/latest/syn/struct.DataEnum.html: struct syn::DataEnum - DataEnum\n\u27e860\u27e9 https://docs.rs/syn/latest/syn/struct.DataStruct.html: struct syn::DataStruct - DataStruct\n\u27e861\u27e9 https://docs.rs/syn/latest/syn/struct.DataUnion.html: struct syn::DataUnion - DataUnion\n\u27e862\u27e9 https://docs.rs/syn/latest/syn/struct.Error.html: struct syn::Error - Error\n\u27e863\u27e9 https://docs.rs/syn/latest/syn/struct.ExprArray.html: struct syn::ExprArray - ExprArray\n\u27e864\u27e9 https://docs.rs/syn/latest/syn/struct.ExprAssign.html: struct syn::ExprAssign - ExprAssign\n\u27e865\u27e9 https://docs.rs/syn/latest/syn/struct.ExprAsync.html: struct syn::ExprAsync - ExprAsync\n\u27e866\u27e9 https://docs.rs/syn/latest/syn/struct.ExprAwait.html: struct syn::ExprAwait - ExprAwait\n\u27e867\u27e9 https://docs.rs/syn/latest/syn/struct.ExprBinary.html: struct syn::ExprBinary - ExprBinary\n\u27e868\u27e9 https://docs.rs/syn/latest/syn/struct.ExprBlock.html: struct syn::ExprBlock - ExprBlock\n\u27e869\u27e9 https://docs.rs/syn/latest/syn/struct.ExprBreak.html: struct syn::ExprBreak - ExprBreak\n\u27e870\u27e9 https://docs.rs/syn/latest/syn/struct.ExprCall.html: struct syn::ExprCall - ExprCall\n\u27e871\u27e9 https://docs.rs/syn/latest/syn/struct.ExprCast.html: struct syn::ExprCast - ExprCast\n\u27e872\u27e9 https://docs.rs/syn/latest/syn/struct.ExprClosure.html: struct syn::ExprClosure - ExprClosure\n\u27e873\u27e9 https://docs.rs/syn/latest/syn/struct.ExprConst.html: struct syn::ExprConst - ExprConst\n\u27e874\u27e9 https://docs.rs/syn/latest/syn/struct.ExprContinue.html: struct syn::ExprContinue - ExprContinue\n\u27e875\u27e9 https://docs.rs/syn/latest/syn/struct.ExprField.html: struct syn::ExprField - ExprField\n\u27e876\u27e9 https://docs.rs/syn/latest/syn/struct.ExprForLoop.html: struct syn::ExprForLoop - ExprForLoop\n\u27e877\u27e9 https://docs.rs/syn/latest/syn/struct.ExprGroup.html: struct syn::ExprGroup - ExprGroup\n\u27e878\u27e9 https://docs.rs/syn/latest/syn/struct.ExprIf.html: struct syn::ExprIf - ExprIf\n\u27e879\u27e9 https://docs.rs/syn/latest/syn/struct.ExprIndex.html: struct syn::ExprIndex - ExprIndex\n\u27e880\u27e9 https://docs.rs/syn/latest/syn/struct.ExprInfer.html: struct syn::ExprInfer - ExprInfer\n\u27e881\u27e9 https://docs.rs/syn/latest/syn/struct.ExprLet.html: struct syn::ExprLet - ExprLet\n\u27e882\u27e9 https://docs.rs/syn/latest/syn/struct.ExprLit.html: struct syn::ExprLit - ExprLit\n\u27e883\u27e9 https://docs.rs/syn/latest/syn/struct.ExprLoop.html: struct syn::ExprLoop - ExprLoop\n\u27e884\u27e9 https://docs.rs/syn/latest/syn/struct.ExprMacro.html: struct syn::ExprMacro - ExprMacro\n\u27e885\u27e9 https://docs.rs/syn/latest/syn/struct.ExprMatch.html: struct syn::ExprMatch - ExprMatch\n\u27e886\u27e9 https://docs.rs/syn/latest/syn/struct.ExprMethodCall.html: struct syn::ExprMethodCall - ExprMethodCall\n\u27e887\u27e9 https://docs.rs/syn/latest/syn/struct.ExprParen.html: struct syn::ExprParen - ExprParen\n\u27e888\u27e9 https://docs.rs/syn/latest/syn/struct.ExprPath.html: struct syn::ExprPath - ExprPath\n\u27e889\u27e9 https://docs.rs/syn/latest/syn/struct.ExprRange.html: struct syn::ExprRange - ExprRange\n\u27e890\u27e9 https://docs.rs/syn/latest/syn/struct.ExprRawAddr.html: struct syn::ExprRawAddr - ExprRawAddr\n\u27e891\u27e9 https://docs.rs/syn/latest/syn/struct.ExprReference.html: struct syn::ExprReference - ExprReference\n\u27e892\u27e9 https://docs.rs/syn/latest/syn/struct.ExprRepeat.html: struct syn::ExprRepeat - ExprRepeat\n\u27e893\u27e9 https://docs.rs/syn/latest/syn/struct.ExprReturn.html: struct syn::ExprReturn - ExprReturn\n\u27e894\u27e9 https://docs.rs/syn/latest/syn/struct.ExprStruct.html: struct syn::ExprStruct - ExprStruct\n\u27e895\u27e9 https://docs.rs/syn/latest/syn/struct.ExprTry.html: struct syn::ExprTry - ExprTry\n\u27e896\u27e9 https://docs.rs/syn/latest/syn/struct.ExprTryBlock.html: struct syn::ExprTryBlock - ExprTryBlock\n\u27e897\u27e9 https://docs.rs/syn/latest/syn/struct.ExprTuple.html: struct syn::ExprTuple - ExprTuple\n\u27e898\u27e9 https://docs.rs/syn/latest/syn/struct.ExprUnary.html: struct syn::ExprUnary - ExprUnary\n\u27e899\u27e9 https://docs.rs/syn/latest/syn/struct.ExprUnsafe.html: struct syn::ExprUnsafe - ExprUnsafe\n\u27e8100\u27e9 https://docs.rs/syn/latest/syn/struct.ExprWhile.html: struct syn::ExprWhile - ExprWhile\n\u27e8101\u27e9 https://docs.rs/syn/latest/syn/struct.ExprYield.html: struct syn::ExprYield - ExprYield\n\u27e8102\u27e9 https://docs.rs/syn/latest/syn/struct.Field.html: struct syn::Field - Field\n\u27e8103\u27e9 https://docs.rs/syn/latest/syn/struct.FieldPat.html: struct syn::FieldPat - FieldPat\n\u27e8104\u27e9 https://docs.rs/syn/latest/syn/struct.FieldValue.html: struct syn::FieldValue - FieldValue\n\u27e8105\u27e9 https://docs.rs/syn/latest/syn/struct.FieldsNamed.html: struct syn::FieldsNamed - FieldsNamed\n\u27e8106\u27e9 https://docs.rs/syn/latest/syn/struct.FieldsUnnamed.html: struct syn::FieldsUnnamed - FieldsUnnamed\n\u27e8107\u27e9 https://docs.rs/syn/latest/syn/struct.ForeignItemFn.html: struct syn::ForeignItemFn - ForeignItemFn\n\u27e8108\u27e9 https://docs.rs/syn/latest/syn/struct.ForeignItemMacro.html: struct syn::ForeignItemMacro - ForeignItemMacro\n\u27e8109\u27e9 https://docs.rs/syn/latest/syn/struct.ForeignItemStatic.html: struct syn::ForeignItemStatic - ForeignItemStatic\n\u27e8110\u27e9 https://docs.rs/syn/latest/syn/struct.ForeignItemType.html: struct syn::ForeignItemType - ForeignItemType\n\u27e8111\u27e9 https://docs.rs/syn/latest/syn/struct.Generics.html: struct syn::Generics - Generics\n\u27e8112\u27e9 https://docs.rs/syn/latest/syn/struct.Ident.html: struct syn::Ident - Ident\n\u27e8113\u27e9 https://docs.rs/syn/latest/syn/struct.ImplGenerics.html: struct syn::ImplGenerics - ImplGenerics\n\u27e8114\u27e9 https://docs.rs/syn/latest/syn/struct.ImplItemConst.html: struct syn::ImplItemConst - ImplItemConst\n\u27e8115\u27e9 https://docs.rs/syn/latest/syn/struct.ImplItemFn.html: struct syn::ImplItemFn - ImplItemFn\n\u27e8116\u27e9 https://docs.rs/syn/latest/syn/struct.ImplItemMacro.html: struct syn::ImplItemMacro - ImplItemMacro\n\u27e8117\u27e9 https://docs.rs/syn/latest/syn/struct.ImplItemType.html: struct syn::ImplItemType - ImplItemType\n\u27e8118\u27e9 https://docs.rs/syn/latest/syn/struct.Index.html: struct syn::Index - Index\n\u27e8119\u27e9 https://docs.rs/syn/latest/syn/struct.ItemConst.html: struct syn::ItemConst - ItemConst\n\u27e8120\u27e9 https://docs.rs/syn/latest/syn/struct.ItemEnum.html: struct syn::ItemEnum - ItemEnum\n\u27e8121\u27e9 https://docs.rs/syn/latest/syn/struct.ItemExternCrate.html: struct syn::ItemExternCrate - ItemExternCrate\n\u27e8122\u27e9 https://docs.rs/syn/latest/syn/struct.ItemFn.html: struct syn::ItemFn - ItemFn\n\u27e8123\u27e9 https://docs.rs/syn/latest/syn/struct.ItemForeignMod.html: struct syn::ItemForeignMod - ItemForeignMod\n\u27e8124\u27e9 https://docs.rs/syn/latest/syn/struct.ItemImpl.html: struct syn::ItemImpl - ItemImpl\n\u27e8125\u27e9 https://docs.rs/syn/latest/syn/struct.ItemMacro.html: struct syn::ItemMacro - ItemMacro\n\u27e8126\u27e9 https://docs.rs/syn/latest/syn/struct.ItemMod.html: struct syn::ItemMod - ItemMod\n\u27e8127\u27e9 https://docs.rs/syn/latest/syn/struct.ItemStatic.html: struct syn::ItemStatic - ItemStatic\n\u27e8128\u27e9 https://docs.rs/syn/latest/syn/struct.ItemStruct.html: struct syn::ItemStruct - ItemStruct\n\u27e8129\u27e9 https://docs.rs/syn/latest/syn/struct.ItemTrait.html: struct syn::ItemTrait - ItemTrait\n\u27e8130\u27e9 https://docs.rs/syn/latest/syn/struct.ItemTraitAlias.html: struct syn::ItemTraitAlias - ItemTraitAlias\n\u27e8131\u27e9 https://docs.rs/syn/latest/syn/struct.ItemType.html: struct syn::ItemType - ItemType\n\u27e8132\u27e9 https://docs.rs/syn/latest/syn/struct.ItemUnion.html: struct syn::ItemUnion - ItemUnion\n\u27e8133\u27e9 https://docs.rs/syn/latest/syn/struct.ItemUse.html: struct syn::ItemUse - ItemUse\n\u27e8134\u27e9 https://docs.rs/syn/latest/syn/struct.Label.html: struct syn::Label - Label\n\u27e8135\u27e9 https://docs.rs/syn/latest/syn/struct.Lifetime.html: struct syn::Lifetime - Lifetime\n\u27e8136\u27e9 https://docs.rs/syn/latest/syn/struct.LifetimeParam.html: struct syn::LifetimeParam - LifetimeParam\n\u27e8137\u27e9 https://docs.rs/syn/latest/syn/struct.LitBool.html: struct syn::LitBool - LitBool\n\u27e8138\u27e9 https://docs.rs/syn/latest/syn/struct.LitByte.html: struct syn::LitByte - LitByte\n\u27e8139\u27e9 https://docs.rs/syn/latest/syn/struct.LitByteStr.html: struct syn::LitByteStr - LitByteStr\n\u27e8140\u27e9 https://docs.rs/syn/latest/syn/struct.LitCStr.html: struct syn::LitCStr - LitCStr\n\u27e8141\u27e9 https://docs.rs/syn/latest/syn/struct.LitChar.html: struct syn::LitChar - LitChar\n\u27e8142\u27e9 https://docs.rs/syn/latest/syn/struct.LitFloat.html: struct syn::LitFloat - LitFloat\n\u27e8143\u27e9 https://docs.rs/syn/latest/syn/struct.LitInt.html: struct syn::LitInt - LitInt\n\u27e8144\u27e9 https://docs.rs/syn/latest/syn/struct.LitStr.html: struct syn::LitStr - LitStr\n\u27e8145\u27e9 https://docs.rs/syn/latest/syn/struct.Local.html: struct syn::Local - Local\n\u27e8146\u27e9 https://docs.rs/syn/latest/syn/struct.LocalInit.html: struct syn::LocalInit - LocalInit\n\u27e8147\u27e9 https://docs.rs/syn/latest/syn/struct.Macro.html: struct syn::Macro - Macro\n\u27e8148\u27e9 https://docs.rs/syn/latest/syn/struct.MetaList.html: struct syn::MetaList - MetaList\n\u27e8149\u27e9 https://docs.rs/syn/latest/syn/struct.MetaNameValue.html: struct syn::MetaNameValue - MetaNameValue\n\u27e8150\u27e9 https://docs.rs/syn/latest/syn/struct.ParenthesizedGenericArguments.html: struct syn::ParenthesizedGenericArguments - ParenthesizedGenericArguments\n\u27e8151\u27e9 https://docs.rs/syn/latest/syn/struct.PatConst.html: struct syn::PatConst - PatConst\n\u27e8152\u27e9 https://docs.rs/syn/latest/syn/struct.PatIdent.html: struct syn::PatIdent - PatIdent\n\u27e8153\u27e9 https://docs.rs/syn/latest/syn/struct.PatLit.html: struct syn::PatLit - PatLit\n\u27e8154\u27e9 https://docs.rs/syn/latest/syn/struct.PatMacro.html: struct syn::PatMacro - PatMacro\n\u27e8155\u27e9 https://docs.rs/syn/latest/syn/struct.PatOr.html: struct syn::PatOr - PatOr\n\u27e8156\u27e9 https://docs.rs/syn/latest/syn/struct.PatParen.html: struct syn::PatParen - PatParen\n\u27e8157\u27e9 https://docs.rs/syn/latest/syn/struct.PatPath.html: struct syn::PatPath - PatPath\n\u27e8158\u27e9 https://docs.rs/syn/latest/syn/struct.PatRange.html: struct syn::PatRange - PatRange\n\u27e8159\u27e9 https://docs.rs/syn/latest/syn/struct.PatReference.html: struct syn::PatReference - PatReference\n\u27e8160\u27e9 https://docs.rs/syn/latest/syn/struct.PatRest.html: struct syn::PatRest - PatRest\n\u27e8161\u27e9 https://docs.rs/syn/latest/syn/struct.PatSlice.html: struct syn::PatSlice - PatSlice\n\u27e8162\u27e9 https://docs.rs/syn/latest/syn/struct.PatStruct.html: struct syn::PatStruct - PatStruct\n\u27e8163\u27e9 https://docs.rs/syn/latest/syn/struct.PatTuple.html: struct syn::PatTuple - PatTuple\n\u27e8164\u27e9 https://docs.rs/syn/latest/syn/struct.PatTupleStruct.html: struct syn::PatTupleStruct - PatTupleStruct\n\u27e8165\u27e9 https://docs.rs/syn/latest/syn/struct.PatType.html: struct syn::PatType - PatType\n\u27e8166\u27e9 https://docs.rs/syn/latest/syn/struct.PatWild.html: struct syn::PatWild - PatWild\n\u27e8167\u27e9 https://docs.rs/syn/latest/syn/struct.Path.html: struct syn::Path - Path\n\u27e8168\u27e9 https://docs.rs/syn/latest/syn/struct.PathSegment.html: struct syn::PathSegment - PathSegment\n\u27e8169\u27e9 https://docs.rs/syn/latest/syn/struct.PreciseCapture.html: struct syn::PreciseCapture - PreciseCapture\n\u27e8170\u27e9 https://docs.rs/syn/latest/syn/struct.PredicateLifetime.html: struct syn::PredicateLifetime - PredicateLifetime\n\u27e8171\u27e9 https://docs.rs/syn/latest/syn/struct.PredicateType.html: struct syn::PredicateType - PredicateType\n\u27e8172\u27e9 https://docs.rs/syn/latest/syn/struct.QSelf.html: struct syn::QSelf - QSelf\n\u27e8173\u27e9 https://docs.rs/syn/latest/syn/struct.Receiver.html: struct syn::Receiver - Receiver\n\u27e8174\u27e9 https://docs.rs/syn/latest/syn/struct.Signature.html: struct syn::Signature - Signature\n\u27e8175\u27e9 https://docs.rs/syn/latest/syn/struct.StmtMacro.html: struct syn::StmtMacro - StmtMacro\n\u27e8176\u27e9 https://docs.rs/syn/latest/syn/struct.TraitBound.html: struct syn::TraitBound - TraitBound\n\u27e8177\u27e9 https://docs.rs/syn/latest/syn/struct.TraitItemConst.html: struct syn::TraitItemConst - TraitItemConst\n\u27e8178\u27e9 https://docs.rs/syn/latest/syn/struct.TraitItemFn.html: struct syn::TraitItemFn - TraitItemFn\n\u27e8179\u27e9 https://docs.rs/syn/latest/syn/struct.TraitItemMacro.html: struct syn::TraitItemMacro - TraitItemMacro\n\u27e8180\u27e9 https://docs.rs/syn/latest/syn/struct.TraitItemType.html: struct syn::TraitItemType - TraitItemType\n\u27e8181\u27e9 https://docs.rs/syn/latest/syn/struct.Turbofish.html: struct syn::Turbofish - Turbofish\n\u27e8182\u27e9 https://docs.rs/syn/latest/syn/struct.TypeArray.html: struct syn::TypeArray - TypeArray\n\u27e8183\u27e9 https://docs.rs/syn/latest/syn/struct.TypeBareFn.html: struct syn::TypeBareFn - TypeBareFn\n\u27e8184\u27e9 https://docs.rs/syn/latest/syn/struct.TypeGenerics.html: struct syn::TypeGenerics - TypeGenerics\n\u27e8185\u27e9 https://docs.rs/syn/latest/syn/struct.TypeGroup.html: struct syn::TypeGroup - TypeGroup\n\u27e8186\u27e9 https://docs.rs/syn/latest/syn/struct.TypeImplTrait.html: struct syn::TypeImplTrait - TypeImplTrait\n\u27e8187\u27e9 https://docs.rs/syn/latest/syn/struct.TypeInfer.html: struct syn::TypeInfer - TypeInfer\n\u27e8188\u27e9 https://docs.rs/syn/latest/syn/struct.TypeMacro.html: struct syn::TypeMacro - TypeMacro\n\u27e8189\u27e9 https://docs.rs/syn/latest/syn/struct.TypeNever.html: struct syn::TypeNever - TypeNever\n\u27e8190\u27e9 https://docs.rs/syn/latest/syn/struct.TypeParam.html: struct syn::TypeParam - TypeParam\n\u27e8191\u27e9 https://docs.rs/syn/latest/syn/struct.TypeParen.html: struct syn::TypeParen - TypeParen\n\u27e8192\u27e9 https://docs.rs/syn/latest/syn/struct.TypePath.html: struct syn::TypePath - TypePath\n\u27e8193\u27e9 https://docs.rs/syn/latest/syn/struct.TypePtr.html: struct syn::TypePtr - TypePtr\n\u27e8194\u27e9 https://docs.rs/syn/latest/syn/struct.TypeReference.html: struct syn::TypeReference - TypeReference\n\u27e8195\u27e9 https://docs.rs/syn/latest/syn/struct.TypeSlice.html: struct syn::TypeSlice - TypeSlice\n\u27e8196\u27e9 https://docs.rs/syn/latest/syn/struct.TypeTraitObject.html: struct syn::TypeTraitObject - TypeTraitObject\n\u27e8197\u27e9 https://docs.rs/syn/latest/syn/struct.TypeTuple.html: struct syn::TypeTuple - TypeTuple\n\u27e8198\u27e9 https://docs.rs/syn/latest/syn/struct.UseGlob.html: struct syn::UseGlob - UseGlob\n\u27e8199\u27e9 https://docs.rs/syn/latest/syn/struct.UseGroup.html: struct syn::UseGroup - UseGroup\n\u27e8200\u27e9 https://docs.rs/syn/latest/syn/struct.UseName.html: struct syn::UseName - UseName\n\u27e8201\u27e9 https://docs.rs/syn/latest/syn/struct.UsePath.html: struct syn::UsePath - UsePath\n\u27e8202\u27e9 https://docs.rs/syn/latest/syn/struct.UseRename.html: struct syn::UseRename - UseRename\n\u27e8203\u27e9 https://docs.rs/syn/latest/syn/struct.Variadic.html: struct syn::Variadic - Variadic\n\u27e8204\u27e9 https://docs.rs/syn/latest/syn/struct.Variant.html: struct syn::Variant - Variant\n\u27e8205\u27e9 https://docs.rs/syn/latest/syn/struct.VisRestricted.html: struct syn::VisRestricted - VisRestricted\n\u27e8206\u27e9 https://docs.rs/syn/latest/syn/struct.WhereClause.html: struct syn::WhereClause - WhereClause\n\u27e8207\u27e9 https://docs.rs/syn/latest/syn/#enums: \u00a7\n\u27e8208\u27e9 https://docs.rs/syn/latest/syn/enum.AttrStyle.html: enum syn::AttrStyle - AttrStyle\n\u27e8209\u27e9 https://docs.rs/syn/latest/syn/enum.BinOp.html: enum syn::BinOp - BinOp\n\u27e8210\u27e9 https://docs.rs/syn/latest/syn/enum.CapturedParam.html: enum syn::CapturedParam - CapturedParam\n\u27e8211\u27e9 https://docs.rs/syn/latest/syn/enum.Data.html: enum syn::Data - Data\n\u27e8212\u27e9 https://docs.rs/syn/latest/syn/enum.FieldMutability.html: enum syn::FieldMutability - FieldMutability\n\u27e8213\u27e9 https://docs.rs/syn/latest/syn/enum.Fields.html: enum syn::Fields - Fields\n\u27e8214\u27e9 https://docs.rs/syn/latest/syn/enum.FnArg.html: enum syn::FnArg - FnArg\n\u27e8215\u27e9 https://docs.rs/syn/latest/syn/enum.ForeignItem.html: enum syn::ForeignItem - ForeignItem\n\u27e8216\u27e9 https://docs.rs/syn/latest/syn/enum.GenericArgument.html: enum syn::GenericArgument - GenericArgument\n\u27e8217\u27e9 https://docs.rs/syn/latest/syn/enum.GenericParam.html: enum syn::GenericParam - GenericParam\n\u27e8218\u27e9 https://docs.rs/syn/latest/syn/enum.ImplItem.html: enum syn::ImplItem - ImplItem\n\u27e8219\u27e9 https://docs.rs/syn/latest/syn/enum.ImplRestriction.html: enum syn::ImplRestriction - ImplRestriction\n\u27e8220\u27e9 https://docs.rs/syn/latest/syn/enum.Lit.html: enum syn::Lit - Lit\n\u27e8221\u27e9 https://docs.rs/syn/latest/syn/enum.MacroDelimiter.html: enum syn::MacroDelimiter - MacroDelimiter\n\u27e8222\u27e9 https://docs.rs/syn/latest/syn/enum.Member.html: enum syn::Member - Member\n\u27e8223\u27e9 https://docs.rs/syn/latest/syn/enum.Meta.html: enum syn::Meta - Meta\n\u27e8224\u27e9 https://docs.rs/syn/latest/syn/enum.Pat.html: enum syn::Pat - Pat\n\u27e8225\u27e9 https://docs.rs/syn/latest/syn/enum.PathArguments.html: enum syn::PathArguments - PathArguments\n\u27e8226\u27e9 https://docs.rs/syn/latest/syn/enum.PointerMutability.html: enum syn::PointerMutability - PointerMutability\n\u27e8227\u27e9 https://docs.rs/syn/latest/syn/enum.RangeLimits.html: enum syn::RangeLimits - RangeLimits\n\u27e8228\u27e9 https://docs.rs/syn/latest/syn/enum.ReturnType.html: enum syn::ReturnType - ReturnType\n\u27e8229\u27e9 https://docs.rs/syn/latest/syn/enum.StaticMutability.html: enum syn::StaticMutability - StaticMutability\n\u27e8230\u27e9 https://docs.rs/syn/latest/syn/enum.Stmt.html: enum syn::Stmt - Stmt\n\u27e8231\u27e9 https://docs.rs/syn/latest/syn/enum.TraitBoundModifier.html: enum syn::TraitBoundModifier - TraitBoundModifier\n\u27e8232\u27e9 https://docs.rs/syn/latest/syn/enum.TraitItem.html: enum syn::TraitItem - TraitItem\n\u27e8233\u27e9 https://docs.rs/syn/latest/syn/enum.TypeParamBound.html: enum syn::TypeParamBound - TypeParamBound\n\u27e8234\u27e9 https://docs.rs/syn/latest/syn/enum.UnOp.html: enum syn::UnOp - UnOp\n\u27e8235\u27e9 https://docs.rs/syn/latest/syn/enum.UseTree.html: enum syn::UseTree - UseTree\n\u27e8236\u27e9 https://docs.rs/syn/latest/syn/enum.Visibility.html: enum syn::Visibility - Visibility\n\u27e8237\u27e9 https://docs.rs/syn/latest/syn/enum.WherePredicate.html: enum syn::WherePredicate - WherePredicate\n\u27e8238\u27e9 https://docs.rs/syn/latest/syn/#functions: \u00a7\n\u27e8239\u27e9 https://docs.rs/syn/latest/syn/fn.parse.html: fn syn::parse - parse\n\u27e8240\u27e9 https://docs.rs/syn/latest/syn/fn.parse2.html: fn syn::parse2 - parse2\n\u27e8241\u27e9 https://docs.rs/syn/latest/syn/fn.parse_file.html: fn syn::parse_file - parse_file\n\u27e8242\u27e9 https://docs.rs/syn/latest/syn/fn.parse_str.html: fn syn::parse_str - parse_str\n\u27e8243\u27e9 https://docs.rs/syn/latest/syn/#types: \u00a7\n\u27e8244\u27e9 https://docs.rs/syn/latest/syn/type.Result.html: type syn::Result - Result\n",
            "fit_markdown": "",
            "fit_html": ""
          },
          "downloads": 0,
          "github_stars": 0,
          "dependencies": [],
          "features": {},
          "code_snippets": [],
          "readme_sections": {},
          "librs_downloads": null,
          "source": "crates.io",
          "enhanced_scraping": {},
          "enhanced_features": [],
          "enhanced_dependencies": []
        },
        "enriched_crate": {
          "name": "syn",
          "version": "2.0.104",
          "description": "ALLOW: Positive community sentiment",
          "repository": "",
          "keywords": [],
          "categories": [],
          "readme": {
            "raw_markdown": "[](https://docs.rs/syn/latest/syn/all.html \"show sidebar\")\n# Crate synCopy item path\n[Settings](https://docs.rs/syn/latest/settings.html)\n[Help](https://docs.rs/syn/latest/help.html)\nSummary[Source](https://docs.rs/syn/latest/src/syn/lib.rs.html#1-1011)\nExpand description\n[![github](https://img.shields.io/badge/github-8da0cb?style=for-the-badge&labelColor=555555&logo=github)](https://github.com/dtolnay/syn) [![crates-io](https://img.shields.io/badge/crates.io-fc8d62?style=for-the-badge&labelColor=555555&logo=rust)](https://crates.io/crates/syn) [![docs-rs](https://img.shields.io/badge/docs.rs-66c2a5?style=for-the-badge&labelColor=555555&logo=docs.rs)](https://docs.rs/syn/latest/syn/index.html \"mod syn\")\nSyn is a parsing library for parsing a stream of Rust tokens into a syntax tree of Rust source code.\nCurrently this library is geared toward use in Rust procedural macros, but contains some APIs that may be useful more generally.\n  * **Data structures** \u2014 Syn provides a complete syntax tree that can represent any valid Rust source code. The syntax tree is rooted at [`syn::File`](https://docs.rs/syn/latest/syn/struct.File.html \"struct syn::File\") which represents a full source file, but there are other entry points that may be useful to procedural macros including [`syn::Item`](https://docs.rs/syn/latest/syn/enum.Item.html \"enum syn::Item\"), [`syn::Expr`](https://docs.rs/syn/latest/syn/enum.Expr.html \"enum syn::Expr\") and [`syn::Type`](https://docs.rs/syn/latest/syn/enum.Type.html \"enum syn::Type\").\n  * **Derives** \u2014 Of particular interest to derive macros is [`syn::DeriveInput`](https://docs.rs/syn/latest/syn/struct.DeriveInput.html \"struct syn::DeriveInput\") which is any of the three legal input items to a derive macro. An example below shows using this type in a library that can derive implementations of a user-defined trait.\n  * **Parsing** \u2014 Parsing in Syn is built around [parser functions](https://docs.rs/syn/latest/syn/parse/index.html \"mod syn::parse\") with the signature `fn(ParseStream) -> Result<T>`. Every syntax tree node defined by Syn is individually parsable and may be used as a building block for custom syntaxes, or you may dream up your own brand new syntax without involving any of our syntax tree types.\n  * **Location information** \u2014 Every token parsed by Syn is associated with a `Span` that tracks line and column information back to the source of that token. These spans allow a procedural macro to display detailed error messages pointing to all the right places in the user\u2019s code. There is an example of this below.\n  * **Feature flags** \u2014 Functionality is aggressively feature gated so your procedural macros enable only what they need, and do not pay in compile time for all the rest.\n\n\n## [\u00a7](https://docs.rs/syn/latest/syn/#example-of-a-derive-macro)Example of a derive macro\nThe canonical derive macro using Syn looks like this. We write an ordinary Rust function tagged with a `proc_macro_derive` attribute and the name of the trait we are deriving. Any time that derive appears in the user\u2019s code, the Rust compiler passes their data structure as tokens into our macro. We get to execute arbitrary Rust code to figure out what to do with those tokens, then hand some tokens back to the compiler to compile into the user\u2019s crate.\n```\n[dependencies]\nsyn = \"2.0\"\nquote = \"1.0\"\n[lib]\nproc-macro = true\n```\n\n```\nuse proc_macro::TokenStream;\nuse quote::quote;\nuse syn::{parse_macro_input, DeriveInput};\n#[proc_macro_derive(MyMacro)]\npub fn my_macro(input: TokenStream) -> TokenStream {\n  // Parse the input tokens into a syntax tree\n  let input = parse_macro_input!(input as DeriveInput);\n  // Build the output, possibly using quasi-quotation\n  let expanded = quote! {\n    // ...\n  };\n  // Hand the output tokens back to the compiler\n  TokenStream::from(expanded)\n}\n```\n\nThe [`heapsize`](https://github.com/dtolnay/syn/tree/master/examples/heapsize) example directory shows a complete working implementation of a derive macro. The example derives a `HeapSize` trait which computes an estimate of the amount of heap memory owned by a value.\n```\npub trait HeapSize {\n  /// Total number of bytes of heap memory owned by `self`.\n  fn heap_size_of_children(&self) -> usize;\n}\n```\n\nThe derive macro allows users to write `#[derive(HeapSize)]` on data structures in their program.\n```\n#[derive(HeapSize)]\nstruct Demo<'a, T: ?Sized> {\n  a: Box<T>,\n  b: u8,\n  c: &'a str,\n  d: String,\n}\n```\n\n## [\u00a7](https://docs.rs/syn/latest/syn/#spans-and-error-reporting)Spans and error reporting\nThe token-based procedural macro API provides great control over where the compiler\u2019s error messages are displayed in user code. Consider the error the user sees if one of their field types does not implement `HeapSize`.\n```\n#[derive(HeapSize)]\nstruct Broken {\n  ok: String,\n  bad: std::thread::Thread,\n}\n```\n\nBy tracking span information all the way through the expansion of a procedural macro as shown in the `heapsize` example, token-based macros in Syn are able to trigger errors that directly pinpoint the source of the problem.\n```\nerror[E0277]: the trait bound `std::thread::Thread: HeapSize` is not satisfied\n --> src/main.rs:7:5\n |\n7 |   bad: std::thread::Thread,\n |   ^^^^^^^^^^^^^^^^^^^^^^^^ the trait `HeapSize` is not implemented for `Thread`\n```\n\n## [\u00a7](https://docs.rs/syn/latest/syn/#parsing-a-custom-syntax)Parsing a custom syntax\nThe [`lazy-static`](https://github.com/dtolnay/syn/tree/master/examples/lazy-static) example directory shows the implementation of a `functionlike!(...)` procedural macro in which the input tokens are parsed using Syn\u2019s parsing API.\nThe example reimplements the popular `lazy_static` crate from crates.io as a procedural macro.\n```\nlazy_static! {\n  static ref USERNAME: Regex = Regex::new(\"^[a-z0-9_-]{3,16}$\").unwrap();\n}\n```\n\nThe implementation shows how to trigger custom warnings and error messages on the macro input.\n```\nwarning: come on, pick a more creative name\n --> src/main.rs:10:16\n  |\n10 |   static ref FOO: String = \"lazy_static\".to_owned();\n  |        ^^^\n```\n\n## [\u00a7](https://docs.rs/syn/latest/syn/#testing)Testing\nWhen testing macros, we often care not just that the macro can be used successfully but also that when the macro is provided with invalid input it produces maximally helpful error messages. Consider using the [`trybuild`](https://github.com/dtolnay/trybuild) crate to write tests for errors that are emitted by your macro or errors detected by the Rust compiler in the expanded code following misuse of the macro. Such tests help avoid regressions from later refactors that mistakenly make an error no longer trigger or be less helpful than it used to be.\n## [\u00a7](https://docs.rs/syn/latest/syn/#debugging)Debugging\nWhen developing a procedural macro it can be helpful to look at what the generated code looks like. Use `cargo rustc -- -Zunstable-options --pretty=expanded` or the [`cargo expand`](https://github.com/dtolnay/cargo-expand) subcommand.\nTo show the expanded code for some crate that uses your procedural macro, run `cargo expand` from that crate. To show the expanded code for one of your own test cases, run `cargo expand --test the_test_case` where the last argument is the name of the test file without the `.rs` extension.\nThis write-up by Brandon W Maister discusses debugging in more detail: [Debugging Rust\u2019s new Custom Derive system](https://quodlibetor.github.io/posts/debugging-rusts-new-custom-derive-system/).\n## [\u00a7](https://docs.rs/syn/latest/syn/#optional-features)Optional features\nSyn puts a lot of functionality behind optional features in order to optimize compile time for the most common use cases. The following features are available.\n  * **`derive`**_(enabled by default)_ \u2014 Data structures for representing the possible input to a derive macro, including structs and enums and types.\n  * **`full`**\u2014 Data structures for representing the syntax tree of all valid Rust source code, including items and expressions.\n  * **`parsing`**_(enabled by default)_ \u2014 Ability to parse input tokens into a syntax tree node of a chosen type.\n  * **`printing`**_(enabled by default)_ \u2014 Ability to print a syntax tree node as tokens of Rust source code.\n  * **`visit`**\u2014 Trait for traversing a syntax tree.\n  * **`visit-mut`**\u2014 Trait for traversing and mutating in place a syntax tree.\n  * **`fold`**\u2014 Trait for transforming an owned syntax tree.\n  * **`clone-impls`**_(enabled by default)_ \u2014 Clone impls for all syntax tree types.\n  * **`extra-traits`**\u2014 Debug, Eq, PartialEq, Hash impls for all syntax tree types.\n  * **`proc-macro`**_(enabled by default)_ \u2014 Runtime dependency on the dynamic library libproc_macro from rustc toolchain.\n\n\n## Modules[\u00a7](https://docs.rs/syn/latest/syn/#modules)\n\n[buffer](https://docs.rs/syn/latest/syn/buffer/index.html \"mod syn::buffer\")`parsing`\n    A stably addressed token buffer supporting efficient traversal based on a cheaply copyable cursor.\n\n[ext](https://docs.rs/syn/latest/syn/ext/index.html \"mod syn::ext\")`parsing`\n    Extension traits to provide parsing methods on foreign types.\n\n[fold](https://docs.rs/syn/latest/syn/fold/index.html \"mod syn::fold\")`fold`\n    Syntax tree traversal to transform the nodes of an owned syntax tree.\n\n[meta](https://docs.rs/syn/latest/syn/meta/index.html \"mod syn::meta\")`parsing` and (`full` or `derive`)\n    Facility for interpreting structured content inside of an `Attribute`.\n\n[parse](https://docs.rs/syn/latest/syn/parse/index.html \"mod syn::parse\")`parsing`\n    Parsing interface for parsing a token stream into a syntax tree node.\n\n[punctuated](https://docs.rs/syn/latest/syn/punctuated/index.html \"mod syn::punctuated\")\n    A punctuated sequence of syntax tree nodes separated by punctuation.\n\n[spanned](https://docs.rs/syn/latest/syn/spanned/index.html \"mod syn::spanned\")`parsing` and `printing`\n    A trait that can provide the `Span` of the complete contents of a syntax tree node.\n\n[token](https://docs.rs/syn/latest/syn/token/index.html \"mod syn::token\")\n    Tokens representing Rust punctuation, keywords, and delimiters.\n\n[visit](https://docs.rs/syn/latest/syn/visit/index.html \"mod syn::visit\")`visit`\n    Syntax tree traversal to walk a shared borrow of a syntax tree.\n\n[visit_mut](https://docs.rs/syn/latest/syn/visit_mut/index.html \"mod syn::visit_mut\")`visit-mut`\n    Syntax tree traversal to mutate an exclusive borrow of a syntax tree in place.\n## Macros[\u00a7](https://docs.rs/syn/latest/syn/#macros)\n\n[Token](https://docs.rs/syn/latest/syn/macro.Token.html \"macro syn::Token\")\n    A type-macro that expands to the name of the Rust type representation of a given token.\n\n[braced](https://docs.rs/syn/latest/syn/macro.braced.html \"macro syn::braced\")`parsing`\n    Parse a set of curly braces and expose their content to subsequent parsers.\n\n[bracketed](https://docs.rs/syn/latest/syn/macro.bracketed.html \"macro syn::bracketed\")`parsing`\n    Parse a set of square brackets and expose their content to subsequent parsers.\n\n[custom_keyword](https://docs.rs/syn/latest/syn/macro.custom_keyword.html \"macro syn::custom_keyword\")\n    Define a type that supports parsing and printing a given identifier as if it were a keyword.\n\n[custom_punctuation](https://docs.rs/syn/latest/syn/macro.custom_punctuation.html \"macro syn::custom_punctuation\")\n    Define a type that supports parsing and printing a multi-character symbol as if it were a punctuation token.\n\n[parenthesized](https://docs.rs/syn/latest/syn/macro.parenthesized.html \"macro syn::parenthesized\")`parsing`\n    Parse a set of parentheses and expose their content to subsequent parsers.\n\n[parse_macro_input](https://docs.rs/syn/latest/syn/macro.parse_macro_input.html \"macro syn::parse_macro_input\")`parsing` and `proc-macro`\n    Parse the input TokenStream of a macro, triggering a compile error if the tokens fail to parse.\n\n[parse_quote](https://docs.rs/syn/latest/syn/macro.parse_quote.html \"macro syn::parse_quote\")`parsing` and `printing`\n    Quasi-quotation macro that accepts input like the [`quote!`](https://docs.rs/quote/1.0/quote/index.html) macro but uses type inference to figure out a return type for those tokens.\n\n[parse_quote_spanned](https://docs.rs/syn/latest/syn/macro.parse_quote_spanned.html \"macro syn::parse_quote_spanned\")`parsing` and `printing`\n    This macro is [`parse_quote!`](https://docs.rs/syn/latest/syn/macro.parse_quote.html \"macro syn::parse_quote\") + [`quote_spanned!`](https://docs.rs/quote/1.0.40/x86_64-unknown-linux-gnu/quote/macro.quote_spanned.html \"macro quote::quote_spanned\").\n## Structs[\u00a7](https://docs.rs/syn/latest/syn/#structs)\n\n[Abi](https://docs.rs/syn/latest/syn/struct.Abi.html \"struct syn::Abi\")`full` or `derive`\n    The binary interface of a function: `extern \"C\"`.\n\n[AngleBracketedGenericArguments](https://docs.rs/syn/latest/syn/struct.AngleBracketedGenericArguments.html \"struct syn::AngleBracketedGenericArguments\")`full` or `derive`\n    Angle bracketed arguments of a path segment: the `<K, V>` in `HashMap<K, V>`.\n\n[Arm](https://docs.rs/syn/latest/syn/struct.Arm.html \"struct syn::Arm\")`full`\n    One arm of a `match` expression: `0..=10 => { return true; }`.\n\n[AssocConst](https://docs.rs/syn/latest/syn/struct.AssocConst.html \"struct syn::AssocConst\")`full` or `derive`\n    An equality constraint on an associated constant: the `PANIC = false` in `Trait<PANIC = false>`.\n\n[AssocType](https://docs.rs/syn/latest/syn/struct.AssocType.html \"struct syn::AssocType\")`full` or `derive`\n    A binding (equality constraint) on an associated type: the `Item = u8` in `Iterator<Item = u8>`.\n\n[Attribute](https://docs.rs/syn/latest/syn/struct.Attribute.html \"struct syn::Attribute\")`full` or `derive`\n    An attribute, like `#[repr(transparent)]`.\n\n[BareFnArg](https://docs.rs/syn/latest/syn/struct.BareFnArg.html \"struct syn::BareFnArg\")`full` or `derive`\n    An argument in a function type: the `usize` in `fn(usize) -> bool`.\n\n[BareVariadic](https://docs.rs/syn/latest/syn/struct.BareVariadic.html \"struct syn::BareVariadic\")`full` or `derive`\n    The variadic argument of a function pointer like `fn(usize, ...)`.\n\n[Block](https://docs.rs/syn/latest/syn/struct.Block.html \"struct syn::Block\")`full`\n    A braced block containing Rust statements.\n\n[BoundLifetimes](https://docs.rs/syn/latest/syn/struct.BoundLifetimes.html \"struct syn::BoundLifetimes\")`full` or `derive`\n    A set of bound lifetimes: `for<'a, 'b, 'c>`.\n\n[ConstParam](https://docs.rs/syn/latest/syn/struct.ConstParam.html \"struct syn::ConstParam\")`full` or `derive`\n    A const generic parameter: `const LENGTH: usize`.\n\n[Constraint](https://docs.rs/syn/latest/syn/struct.Constraint.html \"struct syn::Constraint\")`full` or `derive`\n    An associated type bound: `Iterator<Item: Display>`.\n\n[DataEnum](https://docs.rs/syn/latest/syn/struct.DataEnum.html \"struct syn::DataEnum\")`derive`\n    An enum input to a `proc_macro_derive` macro.\n\n[DataStruct](https://docs.rs/syn/latest/syn/struct.DataStruct.html \"struct syn::DataStruct\")`derive`\n    A struct input to a `proc_macro_derive` macro.\n\n[DataUnion](https://docs.rs/syn/latest/syn/struct.DataUnion.html \"struct syn::DataUnion\")`derive`\n    An untagged union input to a `proc_macro_derive` macro.\n\n[DeriveInput](https://docs.rs/syn/latest/syn/struct.DeriveInput.html \"struct syn::DeriveInput\")`derive`\n    Data structure sent to a `proc_macro_derive` macro.\n\n[Error](https://docs.rs/syn/latest/syn/struct.Error.html \"struct syn::Error\")\n    Error returned when a Syn parser cannot parse the input tokens.\n\n[ExprArray](https://docs.rs/syn/latest/syn/struct.ExprArray.html \"struct syn::ExprArray\")`full`\n    A slice literal expression: `[a, b, c, d]`.\n\n[ExprAssign](https://docs.rs/syn/latest/syn/struct.ExprAssign.html \"struct syn::ExprAssign\")`full`\n    An assignment expression: `a = compute()`.\n\n[ExprAsync](https://docs.rs/syn/latest/syn/struct.ExprAsync.html \"struct syn::ExprAsync\")`full`\n    An async block: `async { ... }`.\n\n[ExprAwait](https://docs.rs/syn/latest/syn/struct.ExprAwait.html \"struct syn::ExprAwait\")`full`\n    An await expression: `fut.await`.\n\n[ExprBinary](https://docs.rs/syn/latest/syn/struct.ExprBinary.html \"struct syn::ExprBinary\")`full` or `derive`\n    A binary operation: `a + b`, `a += b`.\n\n[ExprBlock](https://docs.rs/syn/latest/syn/struct.ExprBlock.html \"struct syn::ExprBlock\")`full`\n    A blocked scope: `{ ... }`.\n\n[ExprBreak](https://docs.rs/syn/latest/syn/struct.ExprBreak.html \"struct syn::ExprBreak\")`full`\n    A `break`, with an optional label to break and an optional expression.\n\n[ExprCall](https://docs.rs/syn/latest/syn/struct.ExprCall.html \"struct syn::ExprCall\")`full` or `derive`\n    A function call expression: `invoke(a, b)`.\n\n[ExprCast](https://docs.rs/syn/latest/syn/struct.ExprCast.html \"struct syn::ExprCast\")`full` or `derive`\n    A cast expression: `foo as f64`.\n\n[ExprClosure](https://docs.rs/syn/latest/syn/struct.ExprClosure.html \"struct syn::ExprClosure\")`full`\n    A closure expression: `|a, b| a + b`.\n\n[ExprConst](https://docs.rs/syn/latest/syn/struct.ExprConst.html \"struct syn::ExprConst\")`full`\n    A const block: `const { ... }`.\n\n[ExprContinue](https://docs.rs/syn/latest/syn/struct.ExprContinue.html \"struct syn::ExprContinue\")`full`\n    A `continue`, with an optional label.\n\n[ExprField](https://docs.rs/syn/latest/syn/struct.ExprField.html \"struct syn::ExprField\")`full` or `derive`\n    Access of a named struct field (`obj.k`) or unnamed tuple struct field (`obj.0`).\n\n[ExprForLoop](https://docs.rs/syn/latest/syn/struct.ExprForLoop.html \"struct syn::ExprForLoop\")`full`\n    A for loop: `for pat in expr { ... }`.\n\n[ExprGroup](https://docs.rs/syn/latest/syn/struct.ExprGroup.html \"struct syn::ExprGroup\")`full`\n    An expression contained within invisible delimiters.\n\n[ExprIf](https://docs.rs/syn/latest/syn/struct.ExprIf.html \"struct syn::ExprIf\")`full`\n    An `if` expression with an optional `else` block: `if expr { ... } else { ... }`.\n\n[ExprIndex](https://docs.rs/syn/latest/syn/struct.ExprIndex.html \"struct syn::ExprIndex\")`full` or `derive`\n    A square bracketed indexing expression: `vector[2]`.\n\n[ExprInfer](https://docs.rs/syn/latest/syn/struct.ExprInfer.html \"struct syn::ExprInfer\")`full`\n    The inferred value of a const generic argument, denoted `_`.\n\n[ExprLet](https://docs.rs/syn/latest/syn/struct.ExprLet.html \"struct syn::ExprLet\")`full`\n    A `let` guard: `let Some(x) = opt`.\n\n[ExprLit](https://docs.rs/syn/latest/syn/struct.ExprLit.html \"struct syn::ExprLit\")`full` or `derive`\n    A literal in place of an expression: `1`, `\"foo\"`.\n\n[ExprLoop](https://docs.rs/syn/latest/syn/struct.ExprLoop.html \"struct syn::ExprLoop\")`full`\n    Conditionless loop: `loop { ... }`.\n\n[ExprMacro](https://docs.rs/syn/latest/syn/struct.ExprMacro.html \"struct syn::ExprMacro\")`full` or `derive`\n    A macro invocation expression: `format!(\"{}\", q)`.\n\n[ExprMatch](https://docs.rs/syn/latest/syn/struct.ExprMatch.html \"struct syn::ExprMatch\")`full`\n    A `match` expression: `match n { Some(n) => {}, None => {} }`.\n\n[ExprMethodCall](https://docs.rs/syn/latest/syn/struct.ExprMethodCall.html \"struct syn::ExprMethodCall\")`full` or `derive`\n    A method call expression: `x.foo::<T>(a, b)`.\n\n[ExprParen](https://docs.rs/syn/latest/syn/struct.ExprParen.html \"struct syn::ExprParen\")`full` or `derive`\n    A parenthesized expression: `(a + b)`.\n\n[ExprPath](https://docs.rs/syn/latest/syn/struct.ExprPath.html \"struct syn::ExprPath\")`full` or `derive`\n    A path like `std::mem::replace` possibly containing generic parameters and a qualified self-type.\n\n[ExprRange](https://docs.rs/syn/latest/syn/struct.ExprRange.html \"struct syn::ExprRange\")`full`\n    A range expression: `1..2`, `1..`, `..2`, `1..=2`, `..=2`.\n\n[ExprRawAddr](https://docs.rs/syn/latest/syn/struct.ExprRawAddr.html \"struct syn::ExprRawAddr\")`full`\n    Address-of operation: `&raw const place` or `&raw mut place`.\n\n[ExprReference](https://docs.rs/syn/latest/syn/struct.ExprReference.html \"struct syn::ExprReference\")`full` or `derive`\n    A referencing operation: `&a` or `&mut a`.\n\n[ExprRepeat](https://docs.rs/syn/latest/syn/struct.ExprRepeat.html \"struct syn::ExprRepeat\")`full`\n    An array literal constructed from one repeated element: `[0u8; N]`.\n\n[ExprReturn](https://docs.rs/syn/latest/syn/struct.ExprReturn.html \"struct syn::ExprReturn\")`full`\n    A `return`, with an optional value to be returned.\n\n[ExprStruct](https://docs.rs/syn/latest/syn/struct.ExprStruct.html \"struct syn::ExprStruct\")`full` or `derive`\n    A struct literal expression: `Point { x: 1, y: 1 }`.\n\n[ExprTry](https://docs.rs/syn/latest/syn/struct.ExprTry.html \"struct syn::ExprTry\")`full`\n    A try-expression: `expr?`.\n\n[ExprTryBlock](https://docs.rs/syn/latest/syn/struct.ExprTryBlock.html \"struct syn::ExprTryBlock\")`full`\n    A try block: `try { ... }`.\n\n[ExprTuple](https://docs.rs/syn/latest/syn/struct.ExprTuple.html \"struct syn::ExprTuple\")`full`\n    A tuple expression: `(a, b, c, d)`.\n\n[ExprUnary](https://docs.rs/syn/latest/syn/struct.ExprUnary.html \"struct syn::ExprUnary\")`full` or `derive`\n    A unary operation: `!x`, `*x`.\n\n[ExprUnsafe](https://docs.rs/syn/latest/syn/struct.ExprUnsafe.html \"struct syn::ExprUnsafe\")`full`\n    An unsafe block: `unsafe { ... }`.\n\n[ExprWhile](https://docs.rs/syn/latest/syn/struct.ExprWhile.html \"struct syn::ExprWhile\")`full`\n    A while loop: `while expr { ... }`.\n\n[ExprYield](https://docs.rs/syn/latest/syn/struct.ExprYield.html \"struct syn::ExprYield\")`full`\n    A yield expression: `yield expr`.\n\n[Field](https://docs.rs/syn/latest/syn/struct.Field.html \"struct syn::Field\")`full` or `derive`\n    A field of a struct or enum variant.\n\n[FieldPat](https://docs.rs/syn/latest/syn/struct.FieldPat.html \"struct syn::FieldPat\")`full`\n    A single field in a struct pattern.\n\n[FieldValue](https://docs.rs/syn/latest/syn/struct.FieldValue.html \"struct syn::FieldValue\")`full` or `derive`\n    A field-value pair in a struct literal.\n\n[FieldsNamed](https://docs.rs/syn/latest/syn/struct.FieldsNamed.html \"struct syn::FieldsNamed\")`full` or `derive`\n    Named fields of a struct or struct variant such as `Point { x: f64, y: f64 }`.\n\n[FieldsUnnamed](https://docs.rs/syn/latest/syn/struct.FieldsUnnamed.html \"struct syn::FieldsUnnamed\")`full` or `derive`\n    Unnamed fields of a tuple struct or tuple variant such as `Some(T)`.\n\n[File](https://docs.rs/syn/latest/syn/struct.File.html \"struct syn::File\")`full`\n    A complete file of Rust source code.\n\n[ForeignItemFn](https://docs.rs/syn/latest/syn/struct.ForeignItemFn.html \"struct syn::ForeignItemFn\")`full`\n    A foreign function in an `extern` block.\n\n[ForeignItemMacro](https://docs.rs/syn/latest/syn/struct.ForeignItemMacro.html \"struct syn::ForeignItemMacro\")`full`\n    A macro invocation within an extern block.\n\n[ForeignItemStatic](https://docs.rs/syn/latest/syn/struct.ForeignItemStatic.html \"struct syn::ForeignItemStatic\")`full`\n    A foreign static item in an `extern` block: `static ext: u8`.\n\n[ForeignItemType](https://docs.rs/syn/latest/syn/struct.ForeignItemType.html \"struct syn::ForeignItemType\")`full`\n    A foreign type in an `extern` block: `type void`.\n\n[Generics](https://docs.rs/syn/latest/syn/struct.Generics.html \"struct syn::Generics\")`full` or `derive`\n    Lifetimes and type parameters attached to a declaration of a function, enum, trait, etc.\n\n[Ident](https://docs.rs/syn/latest/syn/struct.Ident.html \"struct syn::Ident\")\n    A word of Rust code, which may be a keyword or legal variable name.\n\n[ImplGenerics](https://docs.rs/syn/latest/syn/struct.ImplGenerics.html \"struct syn::ImplGenerics\")(`full` or `derive`) and `printing`\n    Returned by `Generics::split_for_impl`.\n\n[ImplItemConst](https://docs.rs/syn/latest/syn/struct.ImplItemConst.html \"struct syn::ImplItemConst\")`full`\n    An associated constant within an impl block.\n\n[ImplItemFn](https://docs.rs/syn/latest/syn/struct.ImplItemFn.html \"struct syn::ImplItemFn\")`full`\n    An associated function within an impl block.\n\n[ImplItemMacro](https://docs.rs/syn/latest/syn/struct.ImplItemMacro.html \"struct syn::ImplItemMacro\")`full`\n    A macro invocation within an impl block.\n\n[ImplItemType](https://docs.rs/syn/latest/syn/struct.ImplItemType.html \"struct syn::ImplItemType\")`full`\n    An associated type within an impl block.\n\n[Index](https://docs.rs/syn/latest/syn/struct.Index.html \"struct syn::Index\")`full` or `derive`\n    The index of an unnamed tuple struct field.\n\n[ItemConst](https://docs.rs/syn/latest/syn/struct.ItemConst.html \"struct syn::ItemConst\")`full`\n    A constant item: `const MAX: u16 = 65535`.\n\n[ItemEnum](https://docs.rs/syn/latest/syn/struct.ItemEnum.html \"struct syn::ItemEnum\")`full`\n    An enum definition: `enum Foo<A, B> { A(A), B(B) }`.\n\n[ItemExternCrate](https://docs.rs/syn/latest/syn/struct.ItemExternCrate.html \"struct syn::ItemExternCrate\")`full`\n    An `extern crate` item: `extern crate serde`.\n\n[ItemFn](https://docs.rs/syn/latest/syn/struct.ItemFn.html \"struct syn::ItemFn\")`full`\n    A free-standing function: `fn process(n: usize) -> Result<()> { ... }`.\n\n[ItemForeignMod](https://docs.rs/syn/latest/syn/struct.ItemForeignMod.html \"struct syn::ItemForeignMod\")`full`\n    A block of foreign items: `extern \"C\" { ... }`.\n\n[ItemImpl](https://docs.rs/syn/latest/syn/struct.ItemImpl.html \"struct syn::ItemImpl\")`full`\n    An impl block providing trait or associated items: `impl<A> Trait for Data<A> { ... }`.\n\n[ItemMacro](https://docs.rs/syn/latest/syn/struct.ItemMacro.html \"struct syn::ItemMacro\")`full`\n    A macro invocation, which includes `macro_rules!` definitions.\n\n[ItemMod](https://docs.rs/syn/latest/syn/struct.ItemMod.html \"struct syn::ItemMod\")`full`\n    A module or module declaration: `mod m` or `mod m { ... }`.\n\n[ItemStatic](https://docs.rs/syn/latest/syn/struct.ItemStatic.html \"struct syn::ItemStatic\")`full`\n    A static item: `static BIKE: Shed = Shed(42)`.\n\n[ItemStruct](https://docs.rs/syn/latest/syn/struct.ItemStruct.html \"struct syn::ItemStruct\")`full`\n    A struct definition: `struct Foo<A> { x: A }`.\n\n[ItemTrait](https://docs.rs/syn/latest/syn/struct.ItemTrait.html \"struct syn::ItemTrait\")`full`\n    A trait definition: `pub trait Iterator { ... }`.\n\n[ItemTraitAlias](https://docs.rs/syn/latest/syn/struct.ItemTraitAlias.html \"struct syn::ItemTraitAlias\")`full`\n    A trait alias: `pub trait SharableIterator = Iterator + Sync`.\n\n[ItemType](https://docs.rs/syn/latest/syn/struct.ItemType.html \"struct syn::ItemType\")`full`\n    A type alias: `type Result<T> = std::result::Result<T, MyError>`.\n\n[ItemUnion](https://docs.rs/syn/latest/syn/struct.ItemUnion.html \"struct syn::ItemUnion\")`full`\n    A union definition: `union Foo<A, B> { x: A, y: B }`.\n\n[ItemUse](https://docs.rs/syn/latest/syn/struct.ItemUse.html \"struct syn::ItemUse\")`full`\n    A use declaration: `use std::collections::HashMap`.\n\n[Label](https://docs.rs/syn/latest/syn/struct.Label.html \"struct syn::Label\")`full`\n    A lifetime labeling a `for`, `while`, or `loop`.\n\n[Lifetime](https://docs.rs/syn/latest/syn/struct.Lifetime.html \"struct syn::Lifetime\")\n    A Rust lifetime: `'a`.\n\n[LifetimeParam](https://docs.rs/syn/latest/syn/struct.LifetimeParam.html \"struct syn::LifetimeParam\")`full` or `derive`\n    A lifetime definition: `'a: 'b + 'c + 'd`.\n\n[LitBool](https://docs.rs/syn/latest/syn/struct.LitBool.html \"struct syn::LitBool\")\n    A boolean literal: `true` or `false`.\n\n[LitByte](https://docs.rs/syn/latest/syn/struct.LitByte.html \"struct syn::LitByte\")\n    A byte literal: `b'f'`.\n\n[LitByteStr](https://docs.rs/syn/latest/syn/struct.LitByteStr.html \"struct syn::LitByteStr\")\n    A byte string literal: `b\"foo\"`.\n\n[LitCStr](https://docs.rs/syn/latest/syn/struct.LitCStr.html \"struct syn::LitCStr\")\n    A nul-terminated C-string literal: `c\"foo\"`.\n\n[LitChar](https://docs.rs/syn/latest/syn/struct.LitChar.html \"struct syn::LitChar\")\n    A character literal: `'a'`.\n\n[LitFloat](https://docs.rs/syn/latest/syn/struct.LitFloat.html \"struct syn::LitFloat\")\n    A floating point literal: `1f64` or `1.0e10f64`.\n\n[LitInt](https://docs.rs/syn/latest/syn/struct.LitInt.html \"struct syn::LitInt\")\n    An integer literal: `1` or `1u16`.\n\n[LitStr](https://docs.rs/syn/latest/syn/struct.LitStr.html \"struct syn::LitStr\")\n    A UTF-8 string literal: `\"foo\"`.\n\n[Local](https://docs.rs/syn/latest/syn/struct.Local.html \"struct syn::Local\")`full`\n    A local `let` binding: `let x: u64 = s.parse()?;`.\n\n[LocalInit](https://docs.rs/syn/latest/syn/struct.LocalInit.html \"struct syn::LocalInit\")`full`\n    The expression assigned in a local `let` binding, including optional diverging `else` block.\n\n[Macro](https://docs.rs/syn/latest/syn/struct.Macro.html \"struct syn::Macro\")`full` or `derive`\n    A macro invocation: `println!(\"{}\", mac)`.\n\n[MetaList](https://docs.rs/syn/latest/syn/struct.MetaList.html \"struct syn::MetaList\")`full` or `derive`\n    A structured list within an attribute, like `derive(Copy, Clone)`.\n\n[MetaNameValue](https://docs.rs/syn/latest/syn/struct.MetaNameValue.html \"struct syn::MetaNameValue\")`full` or `derive`\n    A name-value pair within an attribute, like `feature = \"nightly\"`.\n\n[ParenthesizedGenericArguments](https://docs.rs/syn/latest/syn/struct.ParenthesizedGenericArguments.html \"struct syn::ParenthesizedGenericArguments\")`full` or `derive`\n    Arguments of a function path segment: the `(A, B) -> C` in `Fn(A,B) -> C`.\n\n[PatConst](https://docs.rs/syn/latest/syn/struct.PatConst.html \"struct syn::PatConst\")`full`\n    A const block: `const { ... }`.\n\n[PatIdent](https://docs.rs/syn/latest/syn/struct.PatIdent.html \"struct syn::PatIdent\")`full`\n    A pattern that binds a new variable: `ref mut binding @ SUBPATTERN`.\n\n[PatLit](https://docs.rs/syn/latest/syn/struct.PatLit.html \"struct syn::PatLit\")`full`\n    A literal in place of an expression: `1`, `\"foo\"`.\n\n[PatMacro](https://docs.rs/syn/latest/syn/struct.PatMacro.html \"struct syn::PatMacro\")`full`\n    A macro invocation expression: `format!(\"{}\", q)`.\n\n[PatOr](https://docs.rs/syn/latest/syn/struct.PatOr.html \"struct syn::PatOr\")`full`\n    A pattern that matches any one of a set of cases.\n\n[PatParen](https://docs.rs/syn/latest/syn/struct.PatParen.html \"struct syn::PatParen\")`full`\n    A parenthesized pattern: `(A | B)`.\n\n[PatPath](https://docs.rs/syn/latest/syn/struct.PatPath.html \"struct syn::PatPath\")`full`\n    A path like `std::mem::replace` possibly containing generic parameters and a qualified self-type.\n\n[PatRange](https://docs.rs/syn/latest/syn/struct.PatRange.html \"struct syn::PatRange\")`full`\n    A range expression: `1..2`, `1..`, `..2`, `1..=2`, `..=2`.\n\n[PatReference](https://docs.rs/syn/latest/syn/struct.PatReference.html \"struct syn::PatReference\")`full`\n    A reference pattern: `&mut var`.\n\n[PatRest](https://docs.rs/syn/latest/syn/struct.PatRest.html \"struct syn::PatRest\")`full`\n    The dots in a tuple or slice pattern: `[0, 1, ..]`.\n\n[PatSlice](https://docs.rs/syn/latest/syn/struct.PatSlice.html \"struct syn::PatSlice\")`full`\n    A dynamically sized slice pattern: `[a, b, ref i @ .., y, z]`.\n\n[PatStruct](https://docs.rs/syn/latest/syn/struct.PatStruct.html \"struct syn::PatStruct\")`full`\n    A struct or struct variant pattern: `Variant { x, y, .. }`.\n\n[PatTuple](https://docs.rs/syn/latest/syn/struct.PatTuple.html \"struct syn::PatTuple\")`full`\n    A tuple pattern: `(a, b)`.\n\n[PatTupleStruct](https://docs.rs/syn/latest/syn/struct.PatTupleStruct.html \"struct syn::PatTupleStruct\")`full`\n    A tuple struct or tuple variant pattern: `Variant(x, y, .., z)`.\n\n[PatType](https://docs.rs/syn/latest/syn/struct.PatType.html \"struct syn::PatType\")`full`\n    A type ascription pattern: `foo: f64`.\n\n[PatWild](https://docs.rs/syn/latest/syn/struct.PatWild.html \"struct syn::PatWild\")`full`\n    A pattern that matches any value: `_`.\n\n[Path](https://docs.rs/syn/latest/syn/struct.Path.html \"struct syn::Path\")`full` or `derive`\n    A path at which a named item is exported (e.g. `std::collections::HashMap`).\n\n[PathSegment](https://docs.rs/syn/latest/syn/struct.PathSegment.html \"struct syn::PathSegment\")`full` or `derive`\n    A segment of a path together with any path arguments on that segment.\n\n[PreciseCapture](https://docs.rs/syn/latest/syn/struct.PreciseCapture.html \"struct syn::PreciseCapture\")`full`\n    Precise capturing bound: the \u2018use<\u2026>\u2019 in `impl Trait + use<'a, T>`.\n\n[PredicateLifetime](https://docs.rs/syn/latest/syn/struct.PredicateLifetime.html \"struct syn::PredicateLifetime\")`full` or `derive`\n    A lifetime predicate in a `where` clause: `'a: 'b + 'c`.\n\n[PredicateType](https://docs.rs/syn/latest/syn/struct.PredicateType.html \"struct syn::PredicateType\")`full` or `derive`\n    A type predicate in a `where` clause: `for<'c> Foo<'c>: Trait<'c>`.\n\n[QSelf](https://docs.rs/syn/latest/syn/struct.QSelf.html \"struct syn::QSelf\")`full` or `derive`\n    The explicit Self type in a qualified path: the `T` in `<T as Display>::fmt`.\n\n[Receiver](https://docs.rs/syn/latest/syn/struct.Receiver.html \"struct syn::Receiver\")`full`\n    The `self` argument of an associated method.\n\n[Signature](https://docs.rs/syn/latest/syn/struct.Signature.html \"struct syn::Signature\")`full`\n    A function signature in a trait or implementation: `unsafe fn initialize(&self)`.\n\n[StmtMacro](https://docs.rs/syn/latest/syn/struct.StmtMacro.html \"struct syn::StmtMacro\")`full`\n    A macro invocation in statement position.\n\n[TraitBound](https://docs.rs/syn/latest/syn/struct.TraitBound.html \"struct syn::TraitBound\")`full` or `derive`\n    A trait used as a bound on a type parameter.\n\n[TraitItemConst](https://docs.rs/syn/latest/syn/struct.TraitItemConst.html \"struct syn::TraitItemConst\")`full`\n    An associated constant within the definition of a trait.\n\n[TraitItemFn](https://docs.rs/syn/latest/syn/struct.TraitItemFn.html \"struct syn::TraitItemFn\")`full`\n    An associated function within the definition of a trait.\n\n[TraitItemMacro](https://docs.rs/syn/latest/syn/struct.TraitItemMacro.html \"struct syn::TraitItemMacro\")`full`\n    A macro invocation within the definition of a trait.\n\n[TraitItemType](https://docs.rs/syn/latest/syn/struct.TraitItemType.html \"struct syn::TraitItemType\")`full`\n    An associated type within the definition of a trait.\n\n[Turbofish](https://docs.rs/syn/latest/syn/struct.Turbofish.html \"struct syn::Turbofish\")(`full` or `derive`) and `printing`\n    Returned by `TypeGenerics::as_turbofish`.\n\n[TypeArray](https://docs.rs/syn/latest/syn/struct.TypeArray.html \"struct syn::TypeArray\")`full` or `derive`\n    A fixed size array type: `[T; n]`.\n\n[TypeBareFn](https://docs.rs/syn/latest/syn/struct.TypeBareFn.html \"struct syn::TypeBareFn\")`full` or `derive`\n    A bare function type: `fn(usize) -> bool`.\n\n[TypeGenerics](https://docs.rs/syn/latest/syn/struct.TypeGenerics.html \"struct syn::TypeGenerics\")(`full` or `derive`) and `printing`\n    Returned by `Generics::split_for_impl`.\n\n[TypeGroup](https://docs.rs/syn/latest/syn/struct.TypeGroup.html \"struct syn::TypeGroup\")`full` or `derive`\n    A type contained within invisible delimiters.\n\n[TypeImplTrait](https://docs.rs/syn/latest/syn/struct.TypeImplTrait.html \"struct syn::TypeImplTrait\")`full` or `derive`\n    An `impl Bound1 + Bound2 + Bound3` type where `Bound` is a trait or a lifetime.\n\n[TypeInfer](https://docs.rs/syn/latest/syn/struct.TypeInfer.html \"struct syn::TypeInfer\")`full` or `derive`\n    Indication that a type should be inferred by the compiler: `_`.\n\n[TypeMacro](https://docs.rs/syn/latest/syn/struct.TypeMacro.html \"struct syn::TypeMacro\")`full` or `derive`\n    A macro in the type position.\n\n[TypeNever](https://docs.rs/syn/latest/syn/struct.TypeNever.html \"struct syn::TypeNever\")`full` or `derive`\n    The never type: `!`.\n\n[TypeParam](https://docs.rs/syn/latest/syn/struct.TypeParam.html \"struct syn::TypeParam\")`full` or `derive`\n    A generic type parameter: `T: Into<String>`.\n\n[TypeParen](https://docs.rs/syn/latest/syn/struct.TypeParen.html \"struct syn::TypeParen\")`full` or `derive`\n    A parenthesized type equivalent to the inner type.\n\n[TypePath](https://docs.rs/syn/latest/syn/struct.TypePath.html \"struct syn::TypePath\")`full` or `derive`\n    A path like `std::slice::Iter`, optionally qualified with a self-type as in `<Vec<T> as SomeTrait>::Associated`.\n\n[TypePtr](https://docs.rs/syn/latest/syn/struct.TypePtr.html \"struct syn::TypePtr\")`full` or `derive`\n    A raw pointer type: `*const T` or `*mut T`.\n\n[TypeReference](https://docs.rs/syn/latest/syn/struct.TypeReference.html \"struct syn::TypeReference\")`full` or `derive`\n    A reference type: `&'a T` or `&'a mut T`.\n\n[TypeSlice](https://docs.rs/syn/latest/syn/struct.TypeSlice.html \"struct syn::TypeSlice\")`full` or `derive`\n    A dynamically sized slice type: `[T]`.\n\n[TypeTraitObject](https://docs.rs/syn/latest/syn/struct.TypeTraitObject.html \"struct syn::TypeTraitObject\")`full` or `derive`\n    A trait object type `dyn Bound1 + Bound2 + Bound3` where `Bound` is a trait or a lifetime.\n\n[TypeTuple](https://docs.rs/syn/latest/syn/struct.TypeTuple.html \"struct syn::TypeTuple\")`full` or `derive`\n    A tuple type: `(A, B, C, String)`.\n\n[UseGlob](https://docs.rs/syn/latest/syn/struct.UseGlob.html \"struct syn::UseGlob\")`full`\n    A glob import in a `use` item: `*`.\n\n[UseGroup](https://docs.rs/syn/latest/syn/struct.UseGroup.html \"struct syn::UseGroup\")`full`\n    A braced group of imports in a `use` item: `{A, B, C}`.\n\n[UseName](https://docs.rs/syn/latest/syn/struct.UseName.html \"struct syn::UseName\")`full`\n    An identifier imported by a `use` item: `HashMap`.\n\n[UsePath](https://docs.rs/syn/latest/syn/struct.UsePath.html \"struct syn::UsePath\")`full`\n    A path prefix of imports in a `use` item: `std::...`.\n\n[UseRename](https://docs.rs/syn/latest/syn/struct.UseRename.html \"struct syn::UseRename\")`full`\n    An renamed identifier imported by a `use` item: `HashMap as Map`.\n\n[Variadic](https://docs.rs/syn/latest/syn/struct.Variadic.html \"struct syn::Variadic\")`full`\n    The variadic argument of a foreign function.\n\n[Variant](https://docs.rs/syn/latest/syn/struct.Variant.html \"struct syn::Variant\")`full` or `derive`\n    An enum variant.\n\n[VisRestricted](https://docs.rs/syn/latest/syn/struct.VisRestricted.html \"struct syn::VisRestricted\")`full` or `derive`\n    A visibility level restricted to some path: `pub(self)` or `pub(super)` or `pub(crate)` or `pub(in some::module)`.\n\n[WhereClause](https://docs.rs/syn/latest/syn/struct.WhereClause.html \"struct syn::WhereClause\")`full` or `derive`\n    A `where` clause in a definition: `where T: Deserialize<'de>, D: 'static`.\n## Enums[\u00a7](https://docs.rs/syn/latest/syn/#enums)\n\n[AttrStyle](https://docs.rs/syn/latest/syn/enum.AttrStyle.html \"enum syn::AttrStyle\")`full` or `derive`\n    Distinguishes between attributes that decorate an item and attributes that are contained within an item.\n\n[BinOp](https://docs.rs/syn/latest/syn/enum.BinOp.html \"enum syn::BinOp\")`full` or `derive`\n    A binary operator: `+`, `+=`, `&`.\n\n[CapturedParam](https://docs.rs/syn/latest/syn/enum.CapturedParam.html \"enum syn::CapturedParam\")`full`\n    Single parameter in a precise capturing bound.\n\n[Data](https://docs.rs/syn/latest/syn/enum.Data.html \"enum syn::Data\")`derive`\n    The storage of a struct, enum or union data structure.\n\n[Expr](https://docs.rs/syn/latest/syn/enum.Expr.html \"enum syn::Expr\")`full` or `derive`\n    A Rust expression.\n\n[FieldMutability](https://docs.rs/syn/latest/syn/enum.FieldMutability.html \"enum syn::FieldMutability\")`full` or `derive`\n    Unused, but reserved for RFC 3323 restrictions.\n\n[Fields](https://docs.rs/syn/latest/syn/enum.Fields.html \"enum syn::Fields\")`full` or `derive`\n    Data stored within an enum variant or struct.\n\n[FnArg](https://docs.rs/syn/latest/syn/enum.FnArg.html \"enum syn::FnArg\")`full`\n    An argument in a function signature: the `n: usize` in `fn f(n: usize)`.\n\n[ForeignItem](https://docs.rs/syn/latest/syn/enum.ForeignItem.html \"enum syn::ForeignItem\")`full`\n    An item within an `extern` block.\n\n[GenericArgument](https://docs.rs/syn/latest/syn/enum.GenericArgument.html \"enum syn::GenericArgument\")`full` or `derive`\n    An individual generic argument, like `'a`, `T`, or `Item = T`.\n\n[GenericParam](https://docs.rs/syn/latest/syn/enum.GenericParam.html \"enum syn::GenericParam\")`full` or `derive`\n    A generic type parameter, lifetime, or const generic: `T: Into<String>`, `'a: 'b`, `const LEN: usize`.\n\n[ImplItem](https://docs.rs/syn/latest/syn/enum.ImplItem.html \"enum syn::ImplItem\")`full`\n    An item within an impl block.\n\n[ImplRestriction](https://docs.rs/syn/latest/syn/enum.ImplRestriction.html \"enum syn::ImplRestriction\")`full`\n    Unused, but reserved for RFC 3323 restrictions.\n\n[Item](https://docs.rs/syn/latest/syn/enum.Item.html \"enum syn::Item\")`full`\n    Things that can appear directly inside of a module or scope.\n\n[Lit](https://docs.rs/syn/latest/syn/enum.Lit.html \"enum syn::Lit\")\n    A Rust literal such as a string or integer or boolean.\n\n[MacroDelimiter](https://docs.rs/syn/latest/syn/enum.MacroDelimiter.html \"enum syn::MacroDelimiter\")`full` or `derive`\n    A grouping token that surrounds a macro body: `m!(...)` or `m!{...}` or `m![...]`.\n\n[Member](https://docs.rs/syn/latest/syn/enum.Member.html \"enum syn::Member\")`full` or `derive`\n    A struct or tuple struct field accessed in a struct literal or field expression.\n\n[Meta](https://docs.rs/syn/latest/syn/enum.Meta.html \"enum syn::Meta\")`full` or `derive`\n    Content of a compile-time structured attribute.\n\n[Pat](https://docs.rs/syn/latest/syn/enum.Pat.html \"enum syn::Pat\")`full`\n    A pattern in a local binding, function signature, match expression, or various other places.\n\n[PathArguments](https://docs.rs/syn/latest/syn/enum.PathArguments.html \"enum syn::PathArguments\")`full` or `derive`\n    Angle bracketed or parenthesized arguments of a path segment.\n\n[PointerMutability](https://docs.rs/syn/latest/syn/enum.PointerMutability.html \"enum syn::PointerMutability\")`full`\n    Mutability of a raw pointer (`*const T`, `*mut T`), in which non-mutable isn\u2019t the implicit default.\n\n[RangeLimits](https://docs.rs/syn/latest/syn/enum.RangeLimits.html \"enum syn::RangeLimits\")`full`\n    Limit types of a range, inclusive or exclusive.\n\n[ReturnType](https://docs.rs/syn/latest/syn/enum.ReturnType.html \"enum syn::ReturnType\")`full` or `derive`\n    Return type of a function signature.\n\n[StaticMutability](https://docs.rs/syn/latest/syn/enum.StaticMutability.html \"enum syn::StaticMutability\")`full`\n    The mutability of an `Item::Static` or `ForeignItem::Static`.\n\n[Stmt](https://docs.rs/syn/latest/syn/enum.Stmt.html \"enum syn::Stmt\")`full`\n    A statement, usually ending in a semicolon.\n\n[TraitBoundModifier](https://docs.rs/syn/latest/syn/enum.TraitBoundModifier.html \"enum syn::TraitBoundModifier\")`full` or `derive`\n    A modifier on a trait bound, currently only used for the `?` in `?Sized`.\n\n[TraitItem](https://docs.rs/syn/latest/syn/enum.TraitItem.html \"enum syn::TraitItem\")`full`\n    An item declaration within the definition of a trait.\n\n[Type](https://docs.rs/syn/latest/syn/enum.Type.html \"enum syn::Type\")`full` or `derive`\n    The possible types that a Rust value could have.\n\n[TypeParamBound](https://docs.rs/syn/latest/syn/enum.TypeParamBound.html \"enum syn::TypeParamBound\")`full` or `derive`\n    A trait or lifetime used as a bound on a type parameter.\n\n[UnOp](https://docs.rs/syn/latest/syn/enum.UnOp.html \"enum syn::UnOp\")`full` or `derive`\n    A unary operator: `*`, `!`, `-`.\n\n[UseTree](https://docs.rs/syn/latest/syn/enum.UseTree.html \"enum syn::UseTree\")`full`\n    A suffix of an import tree in a `use` item: `Type as Renamed` or `*`.\n\n[Visibility](https://docs.rs/syn/latest/syn/enum.Visibility.html \"enum syn::Visibility\")`full` or `derive`\n    The visibility level of an item: inherited or `pub` or `pub(restricted)`.\n\n[WherePredicate](https://docs.rs/syn/latest/syn/enum.WherePredicate.html \"enum syn::WherePredicate\")`full` or `derive`\n    A single predicate in a `where` clause: `T: Deserialize<'de>`.\n## Functions[\u00a7](https://docs.rs/syn/latest/syn/#functions)\n\n[parse](https://docs.rs/syn/latest/syn/fn.parse.html \"fn syn::parse\")`parsing` and `proc-macro`\n    Parse tokens of source code into the chosen syntax tree node.\n\n[parse2](https://docs.rs/syn/latest/syn/fn.parse2.html \"fn syn::parse2\")`parsing`\n    Parse a proc-macro2 token stream into the chosen syntax tree node.\n\n[parse_file](https://docs.rs/syn/latest/syn/fn.parse_file.html \"fn syn::parse_file\")`parsing` and `full`\n    Parse the content of a file of Rust code.\n\n[parse_str](https://docs.rs/syn/latest/syn/fn.parse_str.html \"fn syn::parse_str\")`parsing`\n    Parse a string of Rust code into the chosen syntax tree node.\n## Type Aliases[\u00a7](https://docs.rs/syn/latest/syn/#types)\n\n[Result](https://docs.rs/syn/latest/syn/type.Result.html \"type syn::Result\")\n    The result of a Syn parser.\n",
            "markdown_with_citations": "[](https://docs.rs/syn/latest/syn/all.html \"show sidebar\")\n# Crate synCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\n![github\u27e84\u27e9](https://github.com/dtolnay/syn) ![crates-io\u27e85\u27e9](https://crates.io/crates/syn) ![docs-rs\u27e86\u27e9](https://docs.rs/syn/latest/syn/index.html \"mod syn\")\nSyn is a parsing library for parsing a stream of Rust tokens into a syntax tree of Rust source code.\nCurrently this library is geared toward use in Rust procedural macros, but contains some APIs that may be useful more generally.\n  * **Data structures** \u2014 Syn provides a complete syntax tree that can represent any valid Rust source code. The syntax tree is rooted at `syn::File`\u27e87\u27e9 which represents a full source file, but there are other entry points that may be useful to procedural macros including `syn::Item`\u27e88\u27e9, `syn::Expr`\u27e89\u27e9 and `syn::Type`\u27e810\u27e9.\n  * **Derives** \u2014 Of particular interest to derive macros is `syn::DeriveInput`\u27e811\u27e9 which is any of the three legal input items to a derive macro. An example below shows using this type in a library that can derive implementations of a user-defined trait.\n  * **Parsing** \u2014 Parsing in Syn is built around parser functions\u27e812\u27e9 with the signature `fn(ParseStream) -> Result<T>`. Every syntax tree node defined by Syn is individually parsable and may be used as a building block for custom syntaxes, or you may dream up your own brand new syntax without involving any of our syntax tree types.\n  * **Location information** \u2014 Every token parsed by Syn is associated with a `Span` that tracks line and column information back to the source of that token. These spans allow a procedural macro to display detailed error messages pointing to all the right places in the user\u2019s code. There is an example of this below.\n  * **Feature flags** \u2014 Functionality is aggressively feature gated so your procedural macros enable only what they need, and do not pay in compile time for all the rest.\n\n\n## \u00a7\u27e813\u27e9Example of a derive macro\nThe canonical derive macro using Syn looks like this. We write an ordinary Rust function tagged with a `proc_macro_derive` attribute and the name of the trait we are deriving. Any time that derive appears in the user\u2019s code, the Rust compiler passes their data structure as tokens into our macro. We get to execute arbitrary Rust code to figure out what to do with those tokens, then hand some tokens back to the compiler to compile into the user\u2019s crate.\n```\n[dependencies]\nsyn = \"2.0\"\nquote = \"1.0\"\n[lib]\nproc-macro = true\n```\n\n```\nuse proc_macro::TokenStream;\nuse quote::quote;\nuse syn::{parse_macro_input, DeriveInput};\n#[proc_macro_derive(MyMacro)]\npub fn my_macro(input: TokenStream) -> TokenStream {\n  // Parse the input tokens into a syntax tree\n  let input = parse_macro_input!(input as DeriveInput);\n  // Build the output, possibly using quasi-quotation\n  let expanded = quote! {\n    // ...\n  };\n  // Hand the output tokens back to the compiler\n  TokenStream::from(expanded)\n}\n```\n\nThe `heapsize`\u27e814\u27e9 example directory shows a complete working implementation of a derive macro. The example derives a `HeapSize` trait which computes an estimate of the amount of heap memory owned by a value.\n```\npub trait HeapSize {\n  /// Total number of bytes of heap memory owned by `self`.\n  fn heap_size_of_children(&self) -> usize;\n}\n```\n\nThe derive macro allows users to write `#[derive(HeapSize)]` on data structures in their program.\n```\n#[derive(HeapSize)]\nstruct Demo<'a, T: ?Sized> {\n  a: Box<T>,\n  b: u8,\n  c: &'a str,\n  d: String,\n}\n```\n\n## \u00a7\u27e815\u27e9Spans and error reporting\nThe token-based procedural macro API provides great control over where the compiler\u2019s error messages are displayed in user code. Consider the error the user sees if one of their field types does not implement `HeapSize`.\n```\n#[derive(HeapSize)]\nstruct Broken {\n  ok: String,\n  bad: std::thread::Thread,\n}\n```\n\nBy tracking span information all the way through the expansion of a procedural macro as shown in the `heapsize` example, token-based macros in Syn are able to trigger errors that directly pinpoint the source of the problem.\n```\nerror[E0277]: the trait bound `std::thread::Thread: HeapSize` is not satisfied\n --> src/main.rs:7:5\n |\n7 |   bad: std::thread::Thread,\n |   ^^^^^^^^^^^^^^^^^^^^^^^^ the trait `HeapSize` is not implemented for `Thread`\n```\n\n## \u00a7\u27e816\u27e9Parsing a custom syntax\nThe `lazy-static`\u27e817\u27e9 example directory shows the implementation of a `functionlike!(...)` procedural macro in which the input tokens are parsed using Syn\u2019s parsing API.\nThe example reimplements the popular `lazy_static` crate from crates.io as a procedural macro.\n```\nlazy_static! {\n  static ref USERNAME: Regex = Regex::new(\"^[a-z0-9_-]{3,16}$\").unwrap();\n}\n```\n\nThe implementation shows how to trigger custom warnings and error messages on the macro input.\n```\nwarning: come on, pick a more creative name\n --> src/main.rs:10:16\n  |\n10 |   static ref FOO: String = \"lazy_static\".to_owned();\n  |        ^^^\n```\n\n## \u00a7\u27e818\u27e9Testing\nWhen testing macros, we often care not just that the macro can be used successfully but also that when the macro is provided with invalid input it produces maximally helpful error messages. Consider using the `trybuild`\u27e819\u27e9 crate to write tests for errors that are emitted by your macro or errors detected by the Rust compiler in the expanded code following misuse of the macro. Such tests help avoid regressions from later refactors that mistakenly make an error no longer trigger or be less helpful than it used to be.\n## \u00a7\u27e820\u27e9Debugging\nWhen developing a procedural macro it can be helpful to look at what the generated code looks like. Use `cargo rustc -- -Zunstable-options --pretty=expanded` or the `cargo expand`\u27e821\u27e9 subcommand.\nTo show the expanded code for some crate that uses your procedural macro, run `cargo expand` from that crate. To show the expanded code for one of your own test cases, run `cargo expand --test the_test_case` where the last argument is the name of the test file without the `.rs` extension.\nThis write-up by Brandon W Maister discusses debugging in more detail: Debugging Rust\u2019s new Custom Derive system\u27e822\u27e9.\n## \u00a7\u27e823\u27e9Optional features\nSyn puts a lot of functionality behind optional features in order to optimize compile time for the most common use cases. The following features are available.\n  * **`derive`**_(enabled by default)_ \u2014 Data structures for representing the possible input to a derive macro, including structs and enums and types.\n  * **`full`**\u2014 Data structures for representing the syntax tree of all valid Rust source code, including items and expressions.\n  * **`parsing`**_(enabled by default)_ \u2014 Ability to parse input tokens into a syntax tree node of a chosen type.\n  * **`printing`**_(enabled by default)_ \u2014 Ability to print a syntax tree node as tokens of Rust source code.\n  * **`visit`**\u2014 Trait for traversing a syntax tree.\n  * **`visit-mut`**\u2014 Trait for traversing and mutating in place a syntax tree.\n  * **`fold`**\u2014 Trait for transforming an owned syntax tree.\n  * **`clone-impls`**_(enabled by default)_ \u2014 Clone impls for all syntax tree types.\n  * **`extra-traits`**\u2014 Debug, Eq, PartialEq, Hash impls for all syntax tree types.\n  * **`proc-macro`**_(enabled by default)_ \u2014 Runtime dependency on the dynamic library libproc_macro from rustc toolchain.\n\n\n## Modules\u00a7\u27e824\u27e9\n\nbuffer\u27e825\u27e9`parsing`\n    A stably addressed token buffer supporting efficient traversal based on a cheaply copyable cursor.\n\next\u27e826\u27e9`parsing`\n    Extension traits to provide parsing methods on foreign types.\n\nfold\u27e827\u27e9`fold`\n    Syntax tree traversal to transform the nodes of an owned syntax tree.\n\nmeta\u27e828\u27e9`parsing` and (`full` or `derive`)\n    Facility for interpreting structured content inside of an `Attribute`.\n\nparse\u27e812\u27e9`parsing`\n    Parsing interface for parsing a token stream into a syntax tree node.\n\npunctuated\u27e829\u27e9\n    A punctuated sequence of syntax tree nodes separated by punctuation.\n\nspanned\u27e830\u27e9`parsing` and `printing`\n    A trait that can provide the `Span` of the complete contents of a syntax tree node.\n\ntoken\u27e831\u27e9\n    Tokens representing Rust punctuation, keywords, and delimiters.\n\nvisit\u27e832\u27e9`visit`\n    Syntax tree traversal to walk a shared borrow of a syntax tree.\n\nvisit_mut\u27e833\u27e9`visit-mut`\n    Syntax tree traversal to mutate an exclusive borrow of a syntax tree in place.\n## Macros\u00a7\u27e834\u27e9\n\nToken\u27e835\u27e9\n    A type-macro that expands to the name of the Rust type representation of a given token.\n\nbraced\u27e836\u27e9`parsing`\n    Parse a set of curly braces and expose their content to subsequent parsers.\n\nbracketed\u27e837\u27e9`parsing`\n    Parse a set of square brackets and expose their content to subsequent parsers.\n\ncustom_keyword\u27e838\u27e9\n    Define a type that supports parsing and printing a given identifier as if it were a keyword.\n\ncustom_punctuation\u27e839\u27e9\n    Define a type that supports parsing and printing a multi-character symbol as if it were a punctuation token.\n\nparenthesized\u27e840\u27e9`parsing`\n    Parse a set of parentheses and expose their content to subsequent parsers.\n\nparse_macro_input\u27e841\u27e9`parsing` and `proc-macro`\n    Parse the input TokenStream of a macro, triggering a compile error if the tokens fail to parse.\n\nparse_quote\u27e842\u27e9`parsing` and `printing`\n    Quasi-quotation macro that accepts input like the `quote!`\u27e843\u27e9 macro but uses type inference to figure out a return type for those tokens.\n\nparse_quote_spanned\u27e844\u27e9`parsing` and `printing`\n    This macro is `parse_quote!`\u27e842\u27e9 + `quote_spanned!`\u27e845\u27e9.\n## Structs\u00a7\u27e846\u27e9\n\nAbi\u27e847\u27e9`full` or `derive`\n    The binary interface of a function: `extern \"C\"`.\n\nAngleBracketedGenericArguments\u27e848\u27e9`full` or `derive`\n    Angle bracketed arguments of a path segment: the `<K, V>` in `HashMap<K, V>`.\n\nArm\u27e849\u27e9`full`\n    One arm of a `match` expression: `0..=10 => { return true; }`.\n\nAssocConst\u27e850\u27e9`full` or `derive`\n    An equality constraint on an associated constant: the `PANIC = false` in `Trait<PANIC = false>`.\n\nAssocType\u27e851\u27e9`full` or `derive`\n    A binding (equality constraint) on an associated type: the `Item = u8` in `Iterator<Item = u8>`.\n\nAttribute\u27e852\u27e9`full` or `derive`\n    An attribute, like `#[repr(transparent)]`.\n\nBareFnArg\u27e853\u27e9`full` or `derive`\n    An argument in a function type: the `usize` in `fn(usize) -> bool`.\n\nBareVariadic\u27e854\u27e9`full` or `derive`\n    The variadic argument of a function pointer like `fn(usize, ...)`.\n\nBlock\u27e855\u27e9`full`\n    A braced block containing Rust statements.\n\nBoundLifetimes\u27e856\u27e9`full` or `derive`\n    A set of bound lifetimes: `for<'a, 'b, 'c>`.\n\nConstParam\u27e857\u27e9`full` or `derive`\n    A const generic parameter: `const LENGTH: usize`.\n\nConstraint\u27e858\u27e9`full` or `derive`\n    An associated type bound: `Iterator<Item: Display>`.\n\nDataEnum\u27e859\u27e9`derive`\n    An enum input to a `proc_macro_derive` macro.\n\nDataStruct\u27e860\u27e9`derive`\n    A struct input to a `proc_macro_derive` macro.\n\nDataUnion\u27e861\u27e9`derive`\n    An untagged union input to a `proc_macro_derive` macro.\n\nDeriveInput\u27e811\u27e9`derive`\n    Data structure sent to a `proc_macro_derive` macro.\n\nError\u27e862\u27e9\n    Error returned when a Syn parser cannot parse the input tokens.\n\nExprArray\u27e863\u27e9`full`\n    A slice literal expression: `[a, b, c, d]`.\n\nExprAssign\u27e864\u27e9`full`\n    An assignment expression: `a = compute()`.\n\nExprAsync\u27e865\u27e9`full`\n    An async block: `async { ... }`.\n\nExprAwait\u27e866\u27e9`full`\n    An await expression: `fut.await`.\n\nExprBinary\u27e867\u27e9`full` or `derive`\n    A binary operation: `a + b`, `a += b`.\n\nExprBlock\u27e868\u27e9`full`\n    A blocked scope: `{ ... }`.\n\nExprBreak\u27e869\u27e9`full`\n    A `break`, with an optional label to break and an optional expression.\n\nExprCall\u27e870\u27e9`full` or `derive`\n    A function call expression: `invoke(a, b)`.\n\nExprCast\u27e871\u27e9`full` or `derive`\n    A cast expression: `foo as f64`.\n\nExprClosure\u27e872\u27e9`full`\n    A closure expression: `|a, b| a + b`.\n\nExprConst\u27e873\u27e9`full`\n    A const block: `const { ... }`.\n\nExprContinue\u27e874\u27e9`full`\n    A `continue`, with an optional label.\n\nExprField\u27e875\u27e9`full` or `derive`\n    Access of a named struct field (`obj.k`) or unnamed tuple struct field (`obj.0`).\n\nExprForLoop\u27e876\u27e9`full`\n    A for loop: `for pat in expr { ... }`.\n\nExprGroup\u27e877\u27e9`full`\n    An expression contained within invisible delimiters.\n\nExprIf\u27e878\u27e9`full`\n    An `if` expression with an optional `else` block: `if expr { ... } else { ... }`.\n\nExprIndex\u27e879\u27e9`full` or `derive`\n    A square bracketed indexing expression: `vector[2]`.\n\nExprInfer\u27e880\u27e9`full`\n    The inferred value of a const generic argument, denoted `_`.\n\nExprLet\u27e881\u27e9`full`\n    A `let` guard: `let Some(x) = opt`.\n\nExprLit\u27e882\u27e9`full` or `derive`\n    A literal in place of an expression: `1`, `\"foo\"`.\n\nExprLoop\u27e883\u27e9`full`\n    Conditionless loop: `loop { ... }`.\n\nExprMacro\u27e884\u27e9`full` or `derive`\n    A macro invocation expression: `format!(\"{}\", q)`.\n\nExprMatch\u27e885\u27e9`full`\n    A `match` expression: `match n { Some(n) => {}, None => {} }`.\n\nExprMethodCall\u27e886\u27e9`full` or `derive`\n    A method call expression: `x.foo::<T>(a, b)`.\n\nExprParen\u27e887\u27e9`full` or `derive`\n    A parenthesized expression: `(a + b)`.\n\nExprPath\u27e888\u27e9`full` or `derive`\n    A path like `std::mem::replace` possibly containing generic parameters and a qualified self-type.\n\nExprRange\u27e889\u27e9`full`\n    A range expression: `1..2`, `1..`, `..2`, `1..=2`, `..=2`.\n\nExprRawAddr\u27e890\u27e9`full`\n    Address-of operation: `&raw const place` or `&raw mut place`.\n\nExprReference\u27e891\u27e9`full` or `derive`\n    A referencing operation: `&a` or `&mut a`.\n\nExprRepeat\u27e892\u27e9`full`\n    An array literal constructed from one repeated element: `[0u8; N]`.\n\nExprReturn\u27e893\u27e9`full`\n    A `return`, with an optional value to be returned.\n\nExprStruct\u27e894\u27e9`full` or `derive`\n    A struct literal expression: `Point { x: 1, y: 1 }`.\n\nExprTry\u27e895\u27e9`full`\n    A try-expression: `expr?`.\n\nExprTryBlock\u27e896\u27e9`full`\n    A try block: `try { ... }`.\n\nExprTuple\u27e897\u27e9`full`\n    A tuple expression: `(a, b, c, d)`.\n\nExprUnary\u27e898\u27e9`full` or `derive`\n    A unary operation: `!x`, `*x`.\n\nExprUnsafe\u27e899\u27e9`full`\n    An unsafe block: `unsafe { ... }`.\n\nExprWhile\u27e8100\u27e9`full`\n    A while loop: `while expr { ... }`.\n\nExprYield\u27e8101\u27e9`full`\n    A yield expression: `yield expr`.\n\nField\u27e8102\u27e9`full` or `derive`\n    A field of a struct or enum variant.\n\nFieldPat\u27e8103\u27e9`full`\n    A single field in a struct pattern.\n\nFieldValue\u27e8104\u27e9`full` or `derive`\n    A field-value pair in a struct literal.\n\nFieldsNamed\u27e8105\u27e9`full` or `derive`\n    Named fields of a struct or struct variant such as `Point { x: f64, y: f64 }`.\n\nFieldsUnnamed\u27e8106\u27e9`full` or `derive`\n    Unnamed fields of a tuple struct or tuple variant such as `Some(T)`.\n\nFile\u27e87\u27e9`full`\n    A complete file of Rust source code.\n\nForeignItemFn\u27e8107\u27e9`full`\n    A foreign function in an `extern` block.\n\nForeignItemMacro\u27e8108\u27e9`full`\n    A macro invocation within an extern block.\n\nForeignItemStatic\u27e8109\u27e9`full`\n    A foreign static item in an `extern` block: `static ext: u8`.\n\nForeignItemType\u27e8110\u27e9`full`\n    A foreign type in an `extern` block: `type void`.\n\nGenerics\u27e8111\u27e9`full` or `derive`\n    Lifetimes and type parameters attached to a declaration of a function, enum, trait, etc.\n\nIdent\u27e8112\u27e9\n    A word of Rust code, which may be a keyword or legal variable name.\n\nImplGenerics\u27e8113\u27e9(`full` or `derive`) and `printing`\n    Returned by `Generics::split_for_impl`.\n\nImplItemConst\u27e8114\u27e9`full`\n    An associated constant within an impl block.\n\nImplItemFn\u27e8115\u27e9`full`\n    An associated function within an impl block.\n\nImplItemMacro\u27e8116\u27e9`full`\n    A macro invocation within an impl block.\n\nImplItemType\u27e8117\u27e9`full`\n    An associated type within an impl block.\n\nIndex\u27e8118\u27e9`full` or `derive`\n    The index of an unnamed tuple struct field.\n\nItemConst\u27e8119\u27e9`full`\n    A constant item: `const MAX: u16 = 65535`.\n\nItemEnum\u27e8120\u27e9`full`\n    An enum definition: `enum Foo<A, B> { A(A), B(B) }`.\n\nItemExternCrate\u27e8121\u27e9`full`\n    An `extern crate` item: `extern crate serde`.\n\nItemFn\u27e8122\u27e9`full`\n    A free-standing function: `fn process(n: usize) -> Result<()> { ... }`.\n\nItemForeignMod\u27e8123\u27e9`full`\n    A block of foreign items: `extern \"C\" { ... }`.\n\nItemImpl\u27e8124\u27e9`full`\n    An impl block providing trait or associated items: `impl<A> Trait for Data<A> { ... }`.\n\nItemMacro\u27e8125\u27e9`full`\n    A macro invocation, which includes `macro_rules!` definitions.\n\nItemMod\u27e8126\u27e9`full`\n    A module or module declaration: `mod m` or `mod m { ... }`.\n\nItemStatic\u27e8127\u27e9`full`\n    A static item: `static BIKE: Shed = Shed(42)`.\n\nItemStruct\u27e8128\u27e9`full`\n    A struct definition: `struct Foo<A> { x: A }`.\n\nItemTrait\u27e8129\u27e9`full`\n    A trait definition: `pub trait Iterator { ... }`.\n\nItemTraitAlias\u27e8130\u27e9`full`\n    A trait alias: `pub trait SharableIterator = Iterator + Sync`.\n\nItemType\u27e8131\u27e9`full`\n    A type alias: `type Result<T> = std::result::Result<T, MyError>`.\n\nItemUnion\u27e8132\u27e9`full`\n    A union definition: `union Foo<A, B> { x: A, y: B }`.\n\nItemUse\u27e8133\u27e9`full`\n    A use declaration: `use std::collections::HashMap`.\n\nLabel\u27e8134\u27e9`full`\n    A lifetime labeling a `for`, `while`, or `loop`.\n\nLifetime\u27e8135\u27e9\n    A Rust lifetime: `'a`.\n\nLifetimeParam\u27e8136\u27e9`full` or `derive`\n    A lifetime definition: `'a: 'b + 'c + 'd`.\n\nLitBool\u27e8137\u27e9\n    A boolean literal: `true` or `false`.\n\nLitByte\u27e8138\u27e9\n    A byte literal: `b'f'`.\n\nLitByteStr\u27e8139\u27e9\n    A byte string literal: `b\"foo\"`.\n\nLitCStr\u27e8140\u27e9\n    A nul-terminated C-string literal: `c\"foo\"`.\n\nLitChar\u27e8141\u27e9\n    A character literal: `'a'`.\n\nLitFloat\u27e8142\u27e9\n    A floating point literal: `1f64` or `1.0e10f64`.\n\nLitInt\u27e8143\u27e9\n    An integer literal: `1` or `1u16`.\n\nLitStr\u27e8144\u27e9\n    A UTF-8 string literal: `\"foo\"`.\n\nLocal\u27e8145\u27e9`full`\n    A local `let` binding: `let x: u64 = s.parse()?;`.\n\nLocalInit\u27e8146\u27e9`full`\n    The expression assigned in a local `let` binding, including optional diverging `else` block.\n\nMacro\u27e8147\u27e9`full` or `derive`\n    A macro invocation: `println!(\"{}\", mac)`.\n\nMetaList\u27e8148\u27e9`full` or `derive`\n    A structured list within an attribute, like `derive(Copy, Clone)`.\n\nMetaNameValue\u27e8149\u27e9`full` or `derive`\n    A name-value pair within an attribute, like `feature = \"nightly\"`.\n\nParenthesizedGenericArguments\u27e8150\u27e9`full` or `derive`\n    Arguments of a function path segment: the `(A, B) -> C` in `Fn(A,B) -> C`.\n\nPatConst\u27e8151\u27e9`full`\n    A const block: `const { ... }`.\n\nPatIdent\u27e8152\u27e9`full`\n    A pattern that binds a new variable: `ref mut binding @ SUBPATTERN`.\n\nPatLit\u27e8153\u27e9`full`\n    A literal in place of an expression: `1`, `\"foo\"`.\n\nPatMacro\u27e8154\u27e9`full`\n    A macro invocation expression: `format!(\"{}\", q)`.\n\nPatOr\u27e8155\u27e9`full`\n    A pattern that matches any one of a set of cases.\n\nPatParen\u27e8156\u27e9`full`\n    A parenthesized pattern: `(A | B)`.\n\nPatPath\u27e8157\u27e9`full`\n    A path like `std::mem::replace` possibly containing generic parameters and a qualified self-type.\n\nPatRange\u27e8158\u27e9`full`\n    A range expression: `1..2`, `1..`, `..2`, `1..=2`, `..=2`.\n\nPatReference\u27e8159\u27e9`full`\n    A reference pattern: `&mut var`.\n\nPatRest\u27e8160\u27e9`full`\n    The dots in a tuple or slice pattern: `[0, 1, ..]`.\n\nPatSlice\u27e8161\u27e9`full`\n    A dynamically sized slice pattern: `[a, b, ref i @ .., y, z]`.\n\nPatStruct\u27e8162\u27e9`full`\n    A struct or struct variant pattern: `Variant { x, y, .. }`.\n\nPatTuple\u27e8163\u27e9`full`\n    A tuple pattern: `(a, b)`.\n\nPatTupleStruct\u27e8164\u27e9`full`\n    A tuple struct or tuple variant pattern: `Variant(x, y, .., z)`.\n\nPatType\u27e8165\u27e9`full`\n    A type ascription pattern: `foo: f64`.\n\nPatWild\u27e8166\u27e9`full`\n    A pattern that matches any value: `_`.\n\nPath\u27e8167\u27e9`full` or `derive`\n    A path at which a named item is exported (e.g. `std::collections::HashMap`).\n\nPathSegment\u27e8168\u27e9`full` or `derive`\n    A segment of a path together with any path arguments on that segment.\n\nPreciseCapture\u27e8169\u27e9`full`\n    Precise capturing bound: the \u2018use<\u2026>\u2019 in `impl Trait + use<'a, T>`.\n\nPredicateLifetime\u27e8170\u27e9`full` or `derive`\n    A lifetime predicate in a `where` clause: `'a: 'b + 'c`.\n\nPredicateType\u27e8171\u27e9`full` or `derive`\n    A type predicate in a `where` clause: `for<'c> Foo<'c>: Trait<'c>`.\n\nQSelf\u27e8172\u27e9`full` or `derive`\n    The explicit Self type in a qualified path: the `T` in `<T as Display>::fmt`.\n\nReceiver\u27e8173\u27e9`full`\n    The `self` argument of an associated method.\n\nSignature\u27e8174\u27e9`full`\n    A function signature in a trait or implementation: `unsafe fn initialize(&self)`.\n\nStmtMacro\u27e8175\u27e9`full`\n    A macro invocation in statement position.\n\nTraitBound\u27e8176\u27e9`full` or `derive`\n    A trait used as a bound on a type parameter.\n\nTraitItemConst\u27e8177\u27e9`full`\n    An associated constant within the definition of a trait.\n\nTraitItemFn\u27e8178\u27e9`full`\n    An associated function within the definition of a trait.\n\nTraitItemMacro\u27e8179\u27e9`full`\n    A macro invocation within the definition of a trait.\n\nTraitItemType\u27e8180\u27e9`full`\n    An associated type within the definition of a trait.\n\nTurbofish\u27e8181\u27e9(`full` or `derive`) and `printing`\n    Returned by `TypeGenerics::as_turbofish`.\n\nTypeArray\u27e8182\u27e9`full` or `derive`\n    A fixed size array type: `[T; n]`.\n\nTypeBareFn\u27e8183\u27e9`full` or `derive`\n    A bare function type: `fn(usize) -> bool`.\n\nTypeGenerics\u27e8184\u27e9(`full` or `derive`) and `printing`\n    Returned by `Generics::split_for_impl`.\n\nTypeGroup\u27e8185\u27e9`full` or `derive`\n    A type contained within invisible delimiters.\n\nTypeImplTrait\u27e8186\u27e9`full` or `derive`\n    An `impl Bound1 + Bound2 + Bound3` type where `Bound` is a trait or a lifetime.\n\nTypeInfer\u27e8187\u27e9`full` or `derive`\n    Indication that a type should be inferred by the compiler: `_`.\n\nTypeMacro\u27e8188\u27e9`full` or `derive`\n    A macro in the type position.\n\nTypeNever\u27e8189\u27e9`full` or `derive`\n    The never type: `!`.\n\nTypeParam\u27e8190\u27e9`full` or `derive`\n    A generic type parameter: `T: Into<String>`.\n\nTypeParen\u27e8191\u27e9`full` or `derive`\n    A parenthesized type equivalent to the inner type.\n\nTypePath\u27e8192\u27e9`full` or `derive`\n    A path like `std::slice::Iter`, optionally qualified with a self-type as in `<Vec<T> as SomeTrait>::Associated`.\n\nTypePtr\u27e8193\u27e9`full` or `derive`\n    A raw pointer type: `*const T` or `*mut T`.\n\nTypeReference\u27e8194\u27e9`full` or `derive`\n    A reference type: `&'a T` or `&'a mut T`.\n\nTypeSlice\u27e8195\u27e9`full` or `derive`\n    A dynamically sized slice type: `[T]`.\n\nTypeTraitObject\u27e8196\u27e9`full` or `derive`\n    A trait object type `dyn Bound1 + Bound2 + Bound3` where `Bound` is a trait or a lifetime.\n\nTypeTuple\u27e8197\u27e9`full` or `derive`\n    A tuple type: `(A, B, C, String)`.\n\nUseGlob\u27e8198\u27e9`full`\n    A glob import in a `use` item: `*`.\n\nUseGroup\u27e8199\u27e9`full`\n    A braced group of imports in a `use` item: `{A, B, C}`.\n\nUseName\u27e8200\u27e9`full`\n    An identifier imported by a `use` item: `HashMap`.\n\nUsePath\u27e8201\u27e9`full`\n    A path prefix of imports in a `use` item: `std::...`.\n\nUseRename\u27e8202\u27e9`full`\n    An renamed identifier imported by a `use` item: `HashMap as Map`.\n\nVariadic\u27e8203\u27e9`full`\n    The variadic argument of a foreign function.\n\nVariant\u27e8204\u27e9`full` or `derive`\n    An enum variant.\n\nVisRestricted\u27e8205\u27e9`full` or `derive`\n    A visibility level restricted to some path: `pub(self)` or `pub(super)` or `pub(crate)` or `pub(in some::module)`.\n\nWhereClause\u27e8206\u27e9`full` or `derive`\n    A `where` clause in a definition: `where T: Deserialize<'de>, D: 'static`.\n## Enums\u00a7\u27e8207\u27e9\n\nAttrStyle\u27e8208\u27e9`full` or `derive`\n    Distinguishes between attributes that decorate an item and attributes that are contained within an item.\n\nBinOp\u27e8209\u27e9`full` or `derive`\n    A binary operator: `+`, `+=`, `&`.\n\nCapturedParam\u27e8210\u27e9`full`\n    Single parameter in a precise capturing bound.\n\nData\u27e8211\u27e9`derive`\n    The storage of a struct, enum or union data structure.\n\nExpr\u27e89\u27e9`full` or `derive`\n    A Rust expression.\n\nFieldMutability\u27e8212\u27e9`full` or `derive`\n    Unused, but reserved for RFC 3323 restrictions.\n\nFields\u27e8213\u27e9`full` or `derive`\n    Data stored within an enum variant or struct.\n\nFnArg\u27e8214\u27e9`full`\n    An argument in a function signature: the `n: usize` in `fn f(n: usize)`.\n\nForeignItem\u27e8215\u27e9`full`\n    An item within an `extern` block.\n\nGenericArgument\u27e8216\u27e9`full` or `derive`\n    An individual generic argument, like `'a`, `T`, or `Item = T`.\n\nGenericParam\u27e8217\u27e9`full` or `derive`\n    A generic type parameter, lifetime, or const generic: `T: Into<String>`, `'a: 'b`, `const LEN: usize`.\n\nImplItem\u27e8218\u27e9`full`\n    An item within an impl block.\n\nImplRestriction\u27e8219\u27e9`full`\n    Unused, but reserved for RFC 3323 restrictions.\n\nItem\u27e88\u27e9`full`\n    Things that can appear directly inside of a module or scope.\n\nLit\u27e8220\u27e9\n    A Rust literal such as a string or integer or boolean.\n\nMacroDelimiter\u27e8221\u27e9`full` or `derive`\n    A grouping token that surrounds a macro body: `m!(...)` or `m!{...}` or `m![...]`.\n\nMember\u27e8222\u27e9`full` or `derive`\n    A struct or tuple struct field accessed in a struct literal or field expression.\n\nMeta\u27e8223\u27e9`full` or `derive`\n    Content of a compile-time structured attribute.\n\nPat\u27e8224\u27e9`full`\n    A pattern in a local binding, function signature, match expression, or various other places.\n\nPathArguments\u27e8225\u27e9`full` or `derive`\n    Angle bracketed or parenthesized arguments of a path segment.\n\nPointerMutability\u27e8226\u27e9`full`\n    Mutability of a raw pointer (`*const T`, `*mut T`), in which non-mutable isn\u2019t the implicit default.\n\nRangeLimits\u27e8227\u27e9`full`\n    Limit types of a range, inclusive or exclusive.\n\nReturnType\u27e8228\u27e9`full` or `derive`\n    Return type of a function signature.\n\nStaticMutability\u27e8229\u27e9`full`\n    The mutability of an `Item::Static` or `ForeignItem::Static`.\n\nStmt\u27e8230\u27e9`full`\n    A statement, usually ending in a semicolon.\n\nTraitBoundModifier\u27e8231\u27e9`full` or `derive`\n    A modifier on a trait bound, currently only used for the `?` in `?Sized`.\n\nTraitItem\u27e8232\u27e9`full`\n    An item declaration within the definition of a trait.\n\nType\u27e810\u27e9`full` or `derive`\n    The possible types that a Rust value could have.\n\nTypeParamBound\u27e8233\u27e9`full` or `derive`\n    A trait or lifetime used as a bound on a type parameter.\n\nUnOp\u27e8234\u27e9`full` or `derive`\n    A unary operator: `*`, `!`, `-`.\n\nUseTree\u27e8235\u27e9`full`\n    A suffix of an import tree in a `use` item: `Type as Renamed` or `*`.\n\nVisibility\u27e8236\u27e9`full` or `derive`\n    The visibility level of an item: inherited or `pub` or `pub(restricted)`.\n\nWherePredicate\u27e8237\u27e9`full` or `derive`\n    A single predicate in a `where` clause: `T: Deserialize<'de>`.\n## Functions\u00a7\u27e8238\u27e9\n\nparse\u27e8239\u27e9`parsing` and `proc-macro`\n    Parse tokens of source code into the chosen syntax tree node.\n\nparse2\u27e8240\u27e9`parsing`\n    Parse a proc-macro2 token stream into the chosen syntax tree node.\n\nparse_file\u27e8241\u27e9`parsing` and `full`\n    Parse the content of a file of Rust code.\n\nparse_str\u27e8242\u27e9`parsing`\n    Parse a string of Rust code into the chosen syntax tree node.\n## Type Aliases\u00a7\u27e8243\u27e9\n\nResult\u27e8244\u27e9\n    The result of a Syn parser.\n",
            "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/syn/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/syn/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/syn/latest/src/syn/lib.rs.html#1-1011: Source\n\u27e84\u27e9 https://img.shields.io/badge/github-8da0cb?style=for-the-badge&labelColor=555555&logo=github: ![github\n\u27e85\u27e9 https://img.shields.io/badge/crates.io-fc8d62?style=for-the-badge&labelColor=555555&logo=rust: ![crates-io\n\u27e86\u27e9 https://img.shields.io/badge/docs.rs-66c2a5?style=for-the-badge&labelColor=555555&logo=docs.rs: ![docs-rs\n\u27e87\u27e9 https://docs.rs/syn/latest/syn/struct.File.html: struct syn::File - `syn::File`\n\u27e88\u27e9 https://docs.rs/syn/latest/syn/enum.Item.html: enum syn::Item - `syn::Item`\n\u27e89\u27e9 https://docs.rs/syn/latest/syn/enum.Expr.html: enum syn::Expr - `syn::Expr`\n\u27e810\u27e9 https://docs.rs/syn/latest/syn/enum.Type.html: enum syn::Type - `syn::Type`\n\u27e811\u27e9 https://docs.rs/syn/latest/syn/struct.DeriveInput.html: struct syn::DeriveInput - `syn::DeriveInput`\n\u27e812\u27e9 https://docs.rs/syn/latest/syn/parse/index.html: mod syn::parse - parser functions\n\u27e813\u27e9 https://docs.rs/syn/latest/syn/#example-of-a-derive-macro: \u00a7\n\u27e814\u27e9 https://github.com/dtolnay/syn/tree/master/examples/heapsize: `heapsize`\n\u27e815\u27e9 https://docs.rs/syn/latest/syn/#spans-and-error-reporting: \u00a7\n\u27e816\u27e9 https://docs.rs/syn/latest/syn/#parsing-a-custom-syntax: \u00a7\n\u27e817\u27e9 https://github.com/dtolnay/syn/tree/master/examples/lazy-static: `lazy-static`\n\u27e818\u27e9 https://docs.rs/syn/latest/syn/#testing: \u00a7\n\u27e819\u27e9 https://github.com/dtolnay/trybuild: `trybuild`\n\u27e820\u27e9 https://docs.rs/syn/latest/syn/#debugging: \u00a7\n\u27e821\u27e9 https://github.com/dtolnay/cargo-expand: `cargo expand`\n\u27e822\u27e9 https://quodlibetor.github.io/posts/debugging-rusts-new-custom-derive-system/: Debugging Rust\u2019s new Custom Derive system\n\u27e823\u27e9 https://docs.rs/syn/latest/syn/#optional-features: \u00a7\n\u27e824\u27e9 https://docs.rs/syn/latest/syn/#modules: \u00a7\n\u27e825\u27e9 https://docs.rs/syn/latest/syn/buffer/index.html: mod syn::buffer - buffer\n\u27e826\u27e9 https://docs.rs/syn/latest/syn/ext/index.html: mod syn::ext - ext\n\u27e827\u27e9 https://docs.rs/syn/latest/syn/fold/index.html: mod syn::fold - fold\n\u27e828\u27e9 https://docs.rs/syn/latest/syn/meta/index.html: mod syn::meta - meta\n\u27e829\u27e9 https://docs.rs/syn/latest/syn/punctuated/index.html: mod syn::punctuated - punctuated\n\u27e830\u27e9 https://docs.rs/syn/latest/syn/spanned/index.html: mod syn::spanned - spanned\n\u27e831\u27e9 https://docs.rs/syn/latest/syn/token/index.html: mod syn::token - token\n\u27e832\u27e9 https://docs.rs/syn/latest/syn/visit/index.html: mod syn::visit - visit\n\u27e833\u27e9 https://docs.rs/syn/latest/syn/visit_mut/index.html: mod syn::visit_mut - visit_mut\n\u27e834\u27e9 https://docs.rs/syn/latest/syn/#macros: \u00a7\n\u27e835\u27e9 https://docs.rs/syn/latest/syn/macro.Token.html: macro syn::Token - Token\n\u27e836\u27e9 https://docs.rs/syn/latest/syn/macro.braced.html: macro syn::braced - braced\n\u27e837\u27e9 https://docs.rs/syn/latest/syn/macro.bracketed.html: macro syn::bracketed - bracketed\n\u27e838\u27e9 https://docs.rs/syn/latest/syn/macro.custom_keyword.html: macro syn::custom_keyword - custom_keyword\n\u27e839\u27e9 https://docs.rs/syn/latest/syn/macro.custom_punctuation.html: macro syn::custom_punctuation - custom_punctuation\n\u27e840\u27e9 https://docs.rs/syn/latest/syn/macro.parenthesized.html: macro syn::parenthesized - parenthesized\n\u27e841\u27e9 https://docs.rs/syn/latest/syn/macro.parse_macro_input.html: macro syn::parse_macro_input - parse_macro_input\n\u27e842\u27e9 https://docs.rs/syn/latest/syn/macro.parse_quote.html: macro syn::parse_quote - parse_quote\n\u27e843\u27e9 https://docs.rs/quote/1.0/quote/index.html: `quote!`\n\u27e844\u27e9 https://docs.rs/syn/latest/syn/macro.parse_quote_spanned.html: macro syn::parse_quote_spanned - parse_quote_spanned\n\u27e845\u27e9 https://docs.rs/quote/1.0.40/x86_64-unknown-linux-gnu/quote/macro.quote_spanned.html: macro quote::quote_spanned - `quote_spanned!`\n\u27e846\u27e9 https://docs.rs/syn/latest/syn/#structs: \u00a7\n\u27e847\u27e9 https://docs.rs/syn/latest/syn/struct.Abi.html: struct syn::Abi - Abi\n\u27e848\u27e9 https://docs.rs/syn/latest/syn/struct.AngleBracketedGenericArguments.html: struct syn::AngleBracketedGenericArguments - AngleBracketedGenericArguments\n\u27e849\u27e9 https://docs.rs/syn/latest/syn/struct.Arm.html: struct syn::Arm - Arm\n\u27e850\u27e9 https://docs.rs/syn/latest/syn/struct.AssocConst.html: struct syn::AssocConst - AssocConst\n\u27e851\u27e9 https://docs.rs/syn/latest/syn/struct.AssocType.html: struct syn::AssocType - AssocType\n\u27e852\u27e9 https://docs.rs/syn/latest/syn/struct.Attribute.html: struct syn::Attribute - Attribute\n\u27e853\u27e9 https://docs.rs/syn/latest/syn/struct.BareFnArg.html: struct syn::BareFnArg - BareFnArg\n\u27e854\u27e9 https://docs.rs/syn/latest/syn/struct.BareVariadic.html: struct syn::BareVariadic - BareVariadic\n\u27e855\u27e9 https://docs.rs/syn/latest/syn/struct.Block.html: struct syn::Block - Block\n\u27e856\u27e9 https://docs.rs/syn/latest/syn/struct.BoundLifetimes.html: struct syn::BoundLifetimes - BoundLifetimes\n\u27e857\u27e9 https://docs.rs/syn/latest/syn/struct.ConstParam.html: struct syn::ConstParam - ConstParam\n\u27e858\u27e9 https://docs.rs/syn/latest/syn/struct.Constraint.html: struct syn::Constraint - Constraint\n\u27e859\u27e9 https://docs.rs/syn/latest/syn/struct.DataEnum.html: struct syn::DataEnum - DataEnum\n\u27e860\u27e9 https://docs.rs/syn/latest/syn/struct.DataStruct.html: struct syn::DataStruct - DataStruct\n\u27e861\u27e9 https://docs.rs/syn/latest/syn/struct.DataUnion.html: struct syn::DataUnion - DataUnion\n\u27e862\u27e9 https://docs.rs/syn/latest/syn/struct.Error.html: struct syn::Error - Error\n\u27e863\u27e9 https://docs.rs/syn/latest/syn/struct.ExprArray.html: struct syn::ExprArray - ExprArray\n\u27e864\u27e9 https://docs.rs/syn/latest/syn/struct.ExprAssign.html: struct syn::ExprAssign - ExprAssign\n\u27e865\u27e9 https://docs.rs/syn/latest/syn/struct.ExprAsync.html: struct syn::ExprAsync - ExprAsync\n\u27e866\u27e9 https://docs.rs/syn/latest/syn/struct.ExprAwait.html: struct syn::ExprAwait - ExprAwait\n\u27e867\u27e9 https://docs.rs/syn/latest/syn/struct.ExprBinary.html: struct syn::ExprBinary - ExprBinary\n\u27e868\u27e9 https://docs.rs/syn/latest/syn/struct.ExprBlock.html: struct syn::ExprBlock - ExprBlock\n\u27e869\u27e9 https://docs.rs/syn/latest/syn/struct.ExprBreak.html: struct syn::ExprBreak - ExprBreak\n\u27e870\u27e9 https://docs.rs/syn/latest/syn/struct.ExprCall.html: struct syn::ExprCall - ExprCall\n\u27e871\u27e9 https://docs.rs/syn/latest/syn/struct.ExprCast.html: struct syn::ExprCast - ExprCast\n\u27e872\u27e9 https://docs.rs/syn/latest/syn/struct.ExprClosure.html: struct syn::ExprClosure - ExprClosure\n\u27e873\u27e9 https://docs.rs/syn/latest/syn/struct.ExprConst.html: struct syn::ExprConst - ExprConst\n\u27e874\u27e9 https://docs.rs/syn/latest/syn/struct.ExprContinue.html: struct syn::ExprContinue - ExprContinue\n\u27e875\u27e9 https://docs.rs/syn/latest/syn/struct.ExprField.html: struct syn::ExprField - ExprField\n\u27e876\u27e9 https://docs.rs/syn/latest/syn/struct.ExprForLoop.html: struct syn::ExprForLoop - ExprForLoop\n\u27e877\u27e9 https://docs.rs/syn/latest/syn/struct.ExprGroup.html: struct syn::ExprGroup - ExprGroup\n\u27e878\u27e9 https://docs.rs/syn/latest/syn/struct.ExprIf.html: struct syn::ExprIf - ExprIf\n\u27e879\u27e9 https://docs.rs/syn/latest/syn/struct.ExprIndex.html: struct syn::ExprIndex - ExprIndex\n\u27e880\u27e9 https://docs.rs/syn/latest/syn/struct.ExprInfer.html: struct syn::ExprInfer - ExprInfer\n\u27e881\u27e9 https://docs.rs/syn/latest/syn/struct.ExprLet.html: struct syn::ExprLet - ExprLet\n\u27e882\u27e9 https://docs.rs/syn/latest/syn/struct.ExprLit.html: struct syn::ExprLit - ExprLit\n\u27e883\u27e9 https://docs.rs/syn/latest/syn/struct.ExprLoop.html: struct syn::ExprLoop - ExprLoop\n\u27e884\u27e9 https://docs.rs/syn/latest/syn/struct.ExprMacro.html: struct syn::ExprMacro - ExprMacro\n\u27e885\u27e9 https://docs.rs/syn/latest/syn/struct.ExprMatch.html: struct syn::ExprMatch - ExprMatch\n\u27e886\u27e9 https://docs.rs/syn/latest/syn/struct.ExprMethodCall.html: struct syn::ExprMethodCall - ExprMethodCall\n\u27e887\u27e9 https://docs.rs/syn/latest/syn/struct.ExprParen.html: struct syn::ExprParen - ExprParen\n\u27e888\u27e9 https://docs.rs/syn/latest/syn/struct.ExprPath.html: struct syn::ExprPath - ExprPath\n\u27e889\u27e9 https://docs.rs/syn/latest/syn/struct.ExprRange.html: struct syn::ExprRange - ExprRange\n\u27e890\u27e9 https://docs.rs/syn/latest/syn/struct.ExprRawAddr.html: struct syn::ExprRawAddr - ExprRawAddr\n\u27e891\u27e9 https://docs.rs/syn/latest/syn/struct.ExprReference.html: struct syn::ExprReference - ExprReference\n\u27e892\u27e9 https://docs.rs/syn/latest/syn/struct.ExprRepeat.html: struct syn::ExprRepeat - ExprRepeat\n\u27e893\u27e9 https://docs.rs/syn/latest/syn/struct.ExprReturn.html: struct syn::ExprReturn - ExprReturn\n\u27e894\u27e9 https://docs.rs/syn/latest/syn/struct.ExprStruct.html: struct syn::ExprStruct - ExprStruct\n\u27e895\u27e9 https://docs.rs/syn/latest/syn/struct.ExprTry.html: struct syn::ExprTry - ExprTry\n\u27e896\u27e9 https://docs.rs/syn/latest/syn/struct.ExprTryBlock.html: struct syn::ExprTryBlock - ExprTryBlock\n\u27e897\u27e9 https://docs.rs/syn/latest/syn/struct.ExprTuple.html: struct syn::ExprTuple - ExprTuple\n\u27e898\u27e9 https://docs.rs/syn/latest/syn/struct.ExprUnary.html: struct syn::ExprUnary - ExprUnary\n\u27e899\u27e9 https://docs.rs/syn/latest/syn/struct.ExprUnsafe.html: struct syn::ExprUnsafe - ExprUnsafe\n\u27e8100\u27e9 https://docs.rs/syn/latest/syn/struct.ExprWhile.html: struct syn::ExprWhile - ExprWhile\n\u27e8101\u27e9 https://docs.rs/syn/latest/syn/struct.ExprYield.html: struct syn::ExprYield - ExprYield\n\u27e8102\u27e9 https://docs.rs/syn/latest/syn/struct.Field.html: struct syn::Field - Field\n\u27e8103\u27e9 https://docs.rs/syn/latest/syn/struct.FieldPat.html: struct syn::FieldPat - FieldPat\n\u27e8104\u27e9 https://docs.rs/syn/latest/syn/struct.FieldValue.html: struct syn::FieldValue - FieldValue\n\u27e8105\u27e9 https://docs.rs/syn/latest/syn/struct.FieldsNamed.html: struct syn::FieldsNamed - FieldsNamed\n\u27e8106\u27e9 https://docs.rs/syn/latest/syn/struct.FieldsUnnamed.html: struct syn::FieldsUnnamed - FieldsUnnamed\n\u27e8107\u27e9 https://docs.rs/syn/latest/syn/struct.ForeignItemFn.html: struct syn::ForeignItemFn - ForeignItemFn\n\u27e8108\u27e9 https://docs.rs/syn/latest/syn/struct.ForeignItemMacro.html: struct syn::ForeignItemMacro - ForeignItemMacro\n\u27e8109\u27e9 https://docs.rs/syn/latest/syn/struct.ForeignItemStatic.html: struct syn::ForeignItemStatic - ForeignItemStatic\n\u27e8110\u27e9 https://docs.rs/syn/latest/syn/struct.ForeignItemType.html: struct syn::ForeignItemType - ForeignItemType\n\u27e8111\u27e9 https://docs.rs/syn/latest/syn/struct.Generics.html: struct syn::Generics - Generics\n\u27e8112\u27e9 https://docs.rs/syn/latest/syn/struct.Ident.html: struct syn::Ident - Ident\n\u27e8113\u27e9 https://docs.rs/syn/latest/syn/struct.ImplGenerics.html: struct syn::ImplGenerics - ImplGenerics\n\u27e8114\u27e9 https://docs.rs/syn/latest/syn/struct.ImplItemConst.html: struct syn::ImplItemConst - ImplItemConst\n\u27e8115\u27e9 https://docs.rs/syn/latest/syn/struct.ImplItemFn.html: struct syn::ImplItemFn - ImplItemFn\n\u27e8116\u27e9 https://docs.rs/syn/latest/syn/struct.ImplItemMacro.html: struct syn::ImplItemMacro - ImplItemMacro\n\u27e8117\u27e9 https://docs.rs/syn/latest/syn/struct.ImplItemType.html: struct syn::ImplItemType - ImplItemType\n\u27e8118\u27e9 https://docs.rs/syn/latest/syn/struct.Index.html: struct syn::Index - Index\n\u27e8119\u27e9 https://docs.rs/syn/latest/syn/struct.ItemConst.html: struct syn::ItemConst - ItemConst\n\u27e8120\u27e9 https://docs.rs/syn/latest/syn/struct.ItemEnum.html: struct syn::ItemEnum - ItemEnum\n\u27e8121\u27e9 https://docs.rs/syn/latest/syn/struct.ItemExternCrate.html: struct syn::ItemExternCrate - ItemExternCrate\n\u27e8122\u27e9 https://docs.rs/syn/latest/syn/struct.ItemFn.html: struct syn::ItemFn - ItemFn\n\u27e8123\u27e9 https://docs.rs/syn/latest/syn/struct.ItemForeignMod.html: struct syn::ItemForeignMod - ItemForeignMod\n\u27e8124\u27e9 https://docs.rs/syn/latest/syn/struct.ItemImpl.html: struct syn::ItemImpl - ItemImpl\n\u27e8125\u27e9 https://docs.rs/syn/latest/syn/struct.ItemMacro.html: struct syn::ItemMacro - ItemMacro\n\u27e8126\u27e9 https://docs.rs/syn/latest/syn/struct.ItemMod.html: struct syn::ItemMod - ItemMod\n\u27e8127\u27e9 https://docs.rs/syn/latest/syn/struct.ItemStatic.html: struct syn::ItemStatic - ItemStatic\n\u27e8128\u27e9 https://docs.rs/syn/latest/syn/struct.ItemStruct.html: struct syn::ItemStruct - ItemStruct\n\u27e8129\u27e9 https://docs.rs/syn/latest/syn/struct.ItemTrait.html: struct syn::ItemTrait - ItemTrait\n\u27e8130\u27e9 https://docs.rs/syn/latest/syn/struct.ItemTraitAlias.html: struct syn::ItemTraitAlias - ItemTraitAlias\n\u27e8131\u27e9 https://docs.rs/syn/latest/syn/struct.ItemType.html: struct syn::ItemType - ItemType\n\u27e8132\u27e9 https://docs.rs/syn/latest/syn/struct.ItemUnion.html: struct syn::ItemUnion - ItemUnion\n\u27e8133\u27e9 https://docs.rs/syn/latest/syn/struct.ItemUse.html: struct syn::ItemUse - ItemUse\n\u27e8134\u27e9 https://docs.rs/syn/latest/syn/struct.Label.html: struct syn::Label - Label\n\u27e8135\u27e9 https://docs.rs/syn/latest/syn/struct.Lifetime.html: struct syn::Lifetime - Lifetime\n\u27e8136\u27e9 https://docs.rs/syn/latest/syn/struct.LifetimeParam.html: struct syn::LifetimeParam - LifetimeParam\n\u27e8137\u27e9 https://docs.rs/syn/latest/syn/struct.LitBool.html: struct syn::LitBool - LitBool\n\u27e8138\u27e9 https://docs.rs/syn/latest/syn/struct.LitByte.html: struct syn::LitByte - LitByte\n\u27e8139\u27e9 https://docs.rs/syn/latest/syn/struct.LitByteStr.html: struct syn::LitByteStr - LitByteStr\n\u27e8140\u27e9 https://docs.rs/syn/latest/syn/struct.LitCStr.html: struct syn::LitCStr - LitCStr\n\u27e8141\u27e9 https://docs.rs/syn/latest/syn/struct.LitChar.html: struct syn::LitChar - LitChar\n\u27e8142\u27e9 https://docs.rs/syn/latest/syn/struct.LitFloat.html: struct syn::LitFloat - LitFloat\n\u27e8143\u27e9 https://docs.rs/syn/latest/syn/struct.LitInt.html: struct syn::LitInt - LitInt\n\u27e8144\u27e9 https://docs.rs/syn/latest/syn/struct.LitStr.html: struct syn::LitStr - LitStr\n\u27e8145\u27e9 https://docs.rs/syn/latest/syn/struct.Local.html: struct syn::Local - Local\n\u27e8146\u27e9 https://docs.rs/syn/latest/syn/struct.LocalInit.html: struct syn::LocalInit - LocalInit\n\u27e8147\u27e9 https://docs.rs/syn/latest/syn/struct.Macro.html: struct syn::Macro - Macro\n\u27e8148\u27e9 https://docs.rs/syn/latest/syn/struct.MetaList.html: struct syn::MetaList - MetaList\n\u27e8149\u27e9 https://docs.rs/syn/latest/syn/struct.MetaNameValue.html: struct syn::MetaNameValue - MetaNameValue\n\u27e8150\u27e9 https://docs.rs/syn/latest/syn/struct.ParenthesizedGenericArguments.html: struct syn::ParenthesizedGenericArguments - ParenthesizedGenericArguments\n\u27e8151\u27e9 https://docs.rs/syn/latest/syn/struct.PatConst.html: struct syn::PatConst - PatConst\n\u27e8152\u27e9 https://docs.rs/syn/latest/syn/struct.PatIdent.html: struct syn::PatIdent - PatIdent\n\u27e8153\u27e9 https://docs.rs/syn/latest/syn/struct.PatLit.html: struct syn::PatLit - PatLit\n\u27e8154\u27e9 https://docs.rs/syn/latest/syn/struct.PatMacro.html: struct syn::PatMacro - PatMacro\n\u27e8155\u27e9 https://docs.rs/syn/latest/syn/struct.PatOr.html: struct syn::PatOr - PatOr\n\u27e8156\u27e9 https://docs.rs/syn/latest/syn/struct.PatParen.html: struct syn::PatParen - PatParen\n\u27e8157\u27e9 https://docs.rs/syn/latest/syn/struct.PatPath.html: struct syn::PatPath - PatPath\n\u27e8158\u27e9 https://docs.rs/syn/latest/syn/struct.PatRange.html: struct syn::PatRange - PatRange\n\u27e8159\u27e9 https://docs.rs/syn/latest/syn/struct.PatReference.html: struct syn::PatReference - PatReference\n\u27e8160\u27e9 https://docs.rs/syn/latest/syn/struct.PatRest.html: struct syn::PatRest - PatRest\n\u27e8161\u27e9 https://docs.rs/syn/latest/syn/struct.PatSlice.html: struct syn::PatSlice - PatSlice\n\u27e8162\u27e9 https://docs.rs/syn/latest/syn/struct.PatStruct.html: struct syn::PatStruct - PatStruct\n\u27e8163\u27e9 https://docs.rs/syn/latest/syn/struct.PatTuple.html: struct syn::PatTuple - PatTuple\n\u27e8164\u27e9 https://docs.rs/syn/latest/syn/struct.PatTupleStruct.html: struct syn::PatTupleStruct - PatTupleStruct\n\u27e8165\u27e9 https://docs.rs/syn/latest/syn/struct.PatType.html: struct syn::PatType - PatType\n\u27e8166\u27e9 https://docs.rs/syn/latest/syn/struct.PatWild.html: struct syn::PatWild - PatWild\n\u27e8167\u27e9 https://docs.rs/syn/latest/syn/struct.Path.html: struct syn::Path - Path\n\u27e8168\u27e9 https://docs.rs/syn/latest/syn/struct.PathSegment.html: struct syn::PathSegment - PathSegment\n\u27e8169\u27e9 https://docs.rs/syn/latest/syn/struct.PreciseCapture.html: struct syn::PreciseCapture - PreciseCapture\n\u27e8170\u27e9 https://docs.rs/syn/latest/syn/struct.PredicateLifetime.html: struct syn::PredicateLifetime - PredicateLifetime\n\u27e8171\u27e9 https://docs.rs/syn/latest/syn/struct.PredicateType.html: struct syn::PredicateType - PredicateType\n\u27e8172\u27e9 https://docs.rs/syn/latest/syn/struct.QSelf.html: struct syn::QSelf - QSelf\n\u27e8173\u27e9 https://docs.rs/syn/latest/syn/struct.Receiver.html: struct syn::Receiver - Receiver\n\u27e8174\u27e9 https://docs.rs/syn/latest/syn/struct.Signature.html: struct syn::Signature - Signature\n\u27e8175\u27e9 https://docs.rs/syn/latest/syn/struct.StmtMacro.html: struct syn::StmtMacro - StmtMacro\n\u27e8176\u27e9 https://docs.rs/syn/latest/syn/struct.TraitBound.html: struct syn::TraitBound - TraitBound\n\u27e8177\u27e9 https://docs.rs/syn/latest/syn/struct.TraitItemConst.html: struct syn::TraitItemConst - TraitItemConst\n\u27e8178\u27e9 https://docs.rs/syn/latest/syn/struct.TraitItemFn.html: struct syn::TraitItemFn - TraitItemFn\n\u27e8179\u27e9 https://docs.rs/syn/latest/syn/struct.TraitItemMacro.html: struct syn::TraitItemMacro - TraitItemMacro\n\u27e8180\u27e9 https://docs.rs/syn/latest/syn/struct.TraitItemType.html: struct syn::TraitItemType - TraitItemType\n\u27e8181\u27e9 https://docs.rs/syn/latest/syn/struct.Turbofish.html: struct syn::Turbofish - Turbofish\n\u27e8182\u27e9 https://docs.rs/syn/latest/syn/struct.TypeArray.html: struct syn::TypeArray - TypeArray\n\u27e8183\u27e9 https://docs.rs/syn/latest/syn/struct.TypeBareFn.html: struct syn::TypeBareFn - TypeBareFn\n\u27e8184\u27e9 https://docs.rs/syn/latest/syn/struct.TypeGenerics.html: struct syn::TypeGenerics - TypeGenerics\n\u27e8185\u27e9 https://docs.rs/syn/latest/syn/struct.TypeGroup.html: struct syn::TypeGroup - TypeGroup\n\u27e8186\u27e9 https://docs.rs/syn/latest/syn/struct.TypeImplTrait.html: struct syn::TypeImplTrait - TypeImplTrait\n\u27e8187\u27e9 https://docs.rs/syn/latest/syn/struct.TypeInfer.html: struct syn::TypeInfer - TypeInfer\n\u27e8188\u27e9 https://docs.rs/syn/latest/syn/struct.TypeMacro.html: struct syn::TypeMacro - TypeMacro\n\u27e8189\u27e9 https://docs.rs/syn/latest/syn/struct.TypeNever.html: struct syn::TypeNever - TypeNever\n\u27e8190\u27e9 https://docs.rs/syn/latest/syn/struct.TypeParam.html: struct syn::TypeParam - TypeParam\n\u27e8191\u27e9 https://docs.rs/syn/latest/syn/struct.TypeParen.html: struct syn::TypeParen - TypeParen\n\u27e8192\u27e9 https://docs.rs/syn/latest/syn/struct.TypePath.html: struct syn::TypePath - TypePath\n\u27e8193\u27e9 https://docs.rs/syn/latest/syn/struct.TypePtr.html: struct syn::TypePtr - TypePtr\n\u27e8194\u27e9 https://docs.rs/syn/latest/syn/struct.TypeReference.html: struct syn::TypeReference - TypeReference\n\u27e8195\u27e9 https://docs.rs/syn/latest/syn/struct.TypeSlice.html: struct syn::TypeSlice - TypeSlice\n\u27e8196\u27e9 https://docs.rs/syn/latest/syn/struct.TypeTraitObject.html: struct syn::TypeTraitObject - TypeTraitObject\n\u27e8197\u27e9 https://docs.rs/syn/latest/syn/struct.TypeTuple.html: struct syn::TypeTuple - TypeTuple\n\u27e8198\u27e9 https://docs.rs/syn/latest/syn/struct.UseGlob.html: struct syn::UseGlob - UseGlob\n\u27e8199\u27e9 https://docs.rs/syn/latest/syn/struct.UseGroup.html: struct syn::UseGroup - UseGroup\n\u27e8200\u27e9 https://docs.rs/syn/latest/syn/struct.UseName.html: struct syn::UseName - UseName\n\u27e8201\u27e9 https://docs.rs/syn/latest/syn/struct.UsePath.html: struct syn::UsePath - UsePath\n\u27e8202\u27e9 https://docs.rs/syn/latest/syn/struct.UseRename.html: struct syn::UseRename - UseRename\n\u27e8203\u27e9 https://docs.rs/syn/latest/syn/struct.Variadic.html: struct syn::Variadic - Variadic\n\u27e8204\u27e9 https://docs.rs/syn/latest/syn/struct.Variant.html: struct syn::Variant - Variant\n\u27e8205\u27e9 https://docs.rs/syn/latest/syn/struct.VisRestricted.html: struct syn::VisRestricted - VisRestricted\n\u27e8206\u27e9 https://docs.rs/syn/latest/syn/struct.WhereClause.html: struct syn::WhereClause - WhereClause\n\u27e8207\u27e9 https://docs.rs/syn/latest/syn/#enums: \u00a7\n\u27e8208\u27e9 https://docs.rs/syn/latest/syn/enum.AttrStyle.html: enum syn::AttrStyle - AttrStyle\n\u27e8209\u27e9 https://docs.rs/syn/latest/syn/enum.BinOp.html: enum syn::BinOp - BinOp\n\u27e8210\u27e9 https://docs.rs/syn/latest/syn/enum.CapturedParam.html: enum syn::CapturedParam - CapturedParam\n\u27e8211\u27e9 https://docs.rs/syn/latest/syn/enum.Data.html: enum syn::Data - Data\n\u27e8212\u27e9 https://docs.rs/syn/latest/syn/enum.FieldMutability.html: enum syn::FieldMutability - FieldMutability\n\u27e8213\u27e9 https://docs.rs/syn/latest/syn/enum.Fields.html: enum syn::Fields - Fields\n\u27e8214\u27e9 https://docs.rs/syn/latest/syn/enum.FnArg.html: enum syn::FnArg - FnArg\n\u27e8215\u27e9 https://docs.rs/syn/latest/syn/enum.ForeignItem.html: enum syn::ForeignItem - ForeignItem\n\u27e8216\u27e9 https://docs.rs/syn/latest/syn/enum.GenericArgument.html: enum syn::GenericArgument - GenericArgument\n\u27e8217\u27e9 https://docs.rs/syn/latest/syn/enum.GenericParam.html: enum syn::GenericParam - GenericParam\n\u27e8218\u27e9 https://docs.rs/syn/latest/syn/enum.ImplItem.html: enum syn::ImplItem - ImplItem\n\u27e8219\u27e9 https://docs.rs/syn/latest/syn/enum.ImplRestriction.html: enum syn::ImplRestriction - ImplRestriction\n\u27e8220\u27e9 https://docs.rs/syn/latest/syn/enum.Lit.html: enum syn::Lit - Lit\n\u27e8221\u27e9 https://docs.rs/syn/latest/syn/enum.MacroDelimiter.html: enum syn::MacroDelimiter - MacroDelimiter\n\u27e8222\u27e9 https://docs.rs/syn/latest/syn/enum.Member.html: enum syn::Member - Member\n\u27e8223\u27e9 https://docs.rs/syn/latest/syn/enum.Meta.html: enum syn::Meta - Meta\n\u27e8224\u27e9 https://docs.rs/syn/latest/syn/enum.Pat.html: enum syn::Pat - Pat\n\u27e8225\u27e9 https://docs.rs/syn/latest/syn/enum.PathArguments.html: enum syn::PathArguments - PathArguments\n\u27e8226\u27e9 https://docs.rs/syn/latest/syn/enum.PointerMutability.html: enum syn::PointerMutability - PointerMutability\n\u27e8227\u27e9 https://docs.rs/syn/latest/syn/enum.RangeLimits.html: enum syn::RangeLimits - RangeLimits\n\u27e8228\u27e9 https://docs.rs/syn/latest/syn/enum.ReturnType.html: enum syn::ReturnType - ReturnType\n\u27e8229\u27e9 https://docs.rs/syn/latest/syn/enum.StaticMutability.html: enum syn::StaticMutability - StaticMutability\n\u27e8230\u27e9 https://docs.rs/syn/latest/syn/enum.Stmt.html: enum syn::Stmt - Stmt\n\u27e8231\u27e9 https://docs.rs/syn/latest/syn/enum.TraitBoundModifier.html: enum syn::TraitBoundModifier - TraitBoundModifier\n\u27e8232\u27e9 https://docs.rs/syn/latest/syn/enum.TraitItem.html: enum syn::TraitItem - TraitItem\n\u27e8233\u27e9 https://docs.rs/syn/latest/syn/enum.TypeParamBound.html: enum syn::TypeParamBound - TypeParamBound\n\u27e8234\u27e9 https://docs.rs/syn/latest/syn/enum.UnOp.html: enum syn::UnOp - UnOp\n\u27e8235\u27e9 https://docs.rs/syn/latest/syn/enum.UseTree.html: enum syn::UseTree - UseTree\n\u27e8236\u27e9 https://docs.rs/syn/latest/syn/enum.Visibility.html: enum syn::Visibility - Visibility\n\u27e8237\u27e9 https://docs.rs/syn/latest/syn/enum.WherePredicate.html: enum syn::WherePredicate - WherePredicate\n\u27e8238\u27e9 https://docs.rs/syn/latest/syn/#functions: \u00a7\n\u27e8239\u27e9 https://docs.rs/syn/latest/syn/fn.parse.html: fn syn::parse - parse\n\u27e8240\u27e9 https://docs.rs/syn/latest/syn/fn.parse2.html: fn syn::parse2 - parse2\n\u27e8241\u27e9 https://docs.rs/syn/latest/syn/fn.parse_file.html: fn syn::parse_file - parse_file\n\u27e8242\u27e9 https://docs.rs/syn/latest/syn/fn.parse_str.html: fn syn::parse_str - parse_str\n\u27e8243\u27e9 https://docs.rs/syn/latest/syn/#types: \u00a7\n\u27e8244\u27e9 https://docs.rs/syn/latest/syn/type.Result.html: type syn::Result - Result\n",
            "fit_markdown": "",
            "fit_html": ""
          },
          "downloads": 0,
          "github_stars": 0,
          "dependencies": [],
          "features": {},
          "code_snippets": [],
          "readme_sections": {},
          "librs_downloads": null,
          "source": "crates.io",
          "enhanced_scraping": {},
          "enhanced_features": [],
          "enhanced_dependencies": [],
          "readme_summary": "The `syn` crate is a robust parsing library for Rust that converts token streams into syntax trees, primarily for use in procedural macros. It provides comprehensive data structures to represent Rust code, supports custom syntax parsing, and includes features like span-based error reporting for precise diagnostics. Its functionality is feature-gated to optimize compile times, and it integrates well with tools like `quote` for code generation and `trybuild` for testing macro errors.",
          "feature_summary": null,
          "use_case": "DevTools",
          "score": 9.0,
          "factual_counterfactual": "### Pair 1: Parsing Capabilities  \n\u2705 Factual: The `syn` crate provides a complete syntax tree that can represent any valid Rust source code, making it suitable for parsing and analyzing Rust programs in procedural macros.  \n\u274c Counterfactual: The `syn` crate is limited to parsing only Rust source files containing procedural macros and cannot handle general Rust code.  \n\n---\n\n### Pair 2: Derive Macro Support  \n\u2705 Factual: The `syn::DeriveInput` type is specifically designed to parse the input tokens for derive macros, allowing users to implement custom traits like `HeapSize` using procedural macros.  \n\u274c Counterfactual: The `syn` crate does not support parsing derive macros and requires users to manually parse tokens for custom trait implementations.  \n\n---\n\n### Pair 3: Error Reporting  \n\u2705 Factual: The `syn` crate tracks span information for tokens, enabling precise error reporting that pinpoints the source of issues in user code during procedural macro expansion.  \n\u274c Counterfactual: The `syn` crate does not associate tokens with span information, making it impossible to provide detailed error messages in procedural macros.",
          "source_analysis": null,
          "user_behavior": null,
          "security": null
        }
      },
      "irl_score": 8.6,
      "execution_id": "exec-ed415da6-2ddfb17b-1751263681",
      "timestamp": "2025-06-30T06:08:01.345264+00:00",
      "canon_version": "1.3.0"
    },
    "rule_zero_compliant": true
  }
]