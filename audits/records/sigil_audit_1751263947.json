[
  {
    "execution_id": "exec-b99631cf-f2545de4-1751263930",
    "timestamp": "2025-06-30T06:12:10.486404+00:00",
    "sacred_chain": {
      "input_data": "derive_builder",
      "context_sources": [
        "crates.io",
        "github.com",
        "lib.rs",
        "docs.rs"
      ],
      "reasoning_steps": [
        "Input canonicalized: 'derive_builder' -> 'derive_builder'",
        "Context gathered from 4 validated sources",
        "Metadata extracted: 4 fields",
        "Documentation analyzed: quality 7.0",
        "Sentiment analyzed: positive",
        "Ecosystem analyzed: utilities",
        "Quality score synthesized: 7.50",
        "Trust decision: DEFER - Insufficient data for decision",
        "IRL confidence: 8.600"
      ],
      "suggestion": "ALLOW: Positive community sentiment",
      "verdict": "DEFER",
      "audit_info": {
        "metadata": {
          "name": "derive_builder",
          "type": "rust_crate",
          "source": "manual_input",
          "extraction_method": "irl_engine"
        },
        "sentiment": {
          "quality_score": 7.0,
          "completeness": 0.8,
          "examples_present": true,
          "api_documented": true
        },
        "ecosystem": {
          "overall": "positive",
          "positive_mentions": 10,
          "negative_mentions": 2,
          "neutral_mentions": 5,
          "total_mentions": 17
        },
        "quality_score": 7.5,
        "verdict_reason": "Insufficient data for decision",
        "sanitized_documentation": {
          "crates_io": {
            "url": "https://crates.io/crates/derive_builder",
            "title": "derive_builder v0.20.2",
            "content": {
              "raw_markdown": "#  derive_builder v0.20.2\nRust macro to automatically implement the builder pattern for arbitrary structs. \n  * [ #builder ](https://crates.io/keywords/builder)\n  * [ #derive ](https://crates.io/keywords/derive)\n  * [ #macro ](https://crates.io/keywords/macro)\n  * [ #setter ](https://crates.io/keywords/setter)\n  * [ #struct ](https://crates.io/keywords/struct)\n\n\n  * [ Readme ](https://crates.io/crates/derive_builder)\n  * [ 34 Versions ](https://crates.io/crates/derive_builder/versions)\n  * [ Dependencies ](https://crates.io/crates/derive_builder/dependencies)\n  * [ Dependents ](https://crates.io/crates/derive_builder/reverse_dependencies)\n\n\n## Metadata\n9 months ago \n2018 edition \n[ MIT ](https://choosealicense.com/licenses/mit) OR [ Apache-2.0 ](https://choosealicense.com/licenses/apache-2.0)\n35.8 KiB \n## Install\nRun the following Cargo command in your project directory:\ncargo add derive_builder\nOr add the following line to your Cargo.toml:\nderive_builder = \"0.20.2\"\n## Documentation\n[ docs.rs/derive_builder/0.20.2 ](https://docs.rs/derive_builder/0.20.2)\n## Repository\n[ github.com/colin-kiegel/rust-derive-builder ](https://github.com/colin-kiegel/rust-derive-builder)\n## Owners\n## Categories\n  * [Development tools](https://crates.io/categories/development-tools)\n  * [Rust patterns](https://crates.io/categories/rust-patterns)\n\n\n[ Report crate ](https://crates.io/support?crate=derive_builder&inquire=crate-violation)\n### Stats Overview\n56,981,414 Downloads all time\n34 Versions published\n#### Downloads over the last 90 days\nDisplay as \nStacked \n  * Stacked \n  * Unstacked \n\n\nLoading\u2026\n",
              "markdown_with_citations": "#  derive_builder v0.20.2\nRust macro to automatically implement the builder pattern for arbitrary structs. \n  *  #builder \u27e81\u27e9\n  *  #derive \u27e82\u27e9\n  *  #macro \u27e83\u27e9\n  *  #setter \u27e84\u27e9\n  *  #struct \u27e85\u27e9\n\n\n  *  Readme \u27e86\u27e9\n  *  34 Versions \u27e87\u27e9\n  *  Dependencies \u27e88\u27e9\n  *  Dependents \u27e89\u27e9\n\n\n## Metadata\n9 months ago \n2018 edition \n MIT \u27e810\u27e9 OR  Apache-2.0 \u27e811\u27e9\n35.8 KiB \n## Install\nRun the following Cargo command in your project directory:\ncargo add derive_builder\nOr add the following line to your Cargo.toml:\nderive_builder = \"0.20.2\"\n## Documentation\n docs.rs/derive_builder/0.20.2 \u27e812\u27e9\n## Repository\n github.com/colin-kiegel/rust-derive-builder \u27e813\u27e9\n## Owners\n## Categories\n  * Development tools\u27e814\u27e9\n  * Rust patterns\u27e815\u27e9\n\n\n Report crate \u27e816\u27e9\n### Stats Overview\n56,981,414 Downloads all time\n34 Versions published\n#### Downloads over the last 90 days\nDisplay as \nStacked \n  * Stacked \n  * Unstacked \n\n\nLoading\u2026\n",
              "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://crates.io/keywords/builder:  #builder \n\u27e82\u27e9 https://crates.io/keywords/derive:  #derive \n\u27e83\u27e9 https://crates.io/keywords/macro:  #macro \n\u27e84\u27e9 https://crates.io/keywords/setter:  #setter \n\u27e85\u27e9 https://crates.io/keywords/struct:  #struct \n\u27e86\u27e9 https://crates.io/crates/derive_builder:  Readme \n\u27e87\u27e9 https://crates.io/crates/derive_builder/versions:  34 Versions \n\u27e88\u27e9 https://crates.io/crates/derive_builder/dependencies:  Dependencies \n\u27e89\u27e9 https://crates.io/crates/derive_builder/reverse_dependencies:  Dependents \n\u27e810\u27e9 https://choosealicense.com/licenses/mit:  MIT \n\u27e811\u27e9 https://choosealicense.com/licenses/apache-2.0:  Apache-2.0 \n\u27e812\u27e9 https://docs.rs/derive_builder/0.20.2:  docs.rs/derive_builder/0.20.2 \n\u27e813\u27e9 https://github.com/colin-kiegel/rust-derive-builder:  github.com/colin-kiegel/rust-derive-builder \n\u27e814\u27e9 https://crates.io/categories/development-tools: Development tools\n\u27e815\u27e9 https://crates.io/categories/rust-patterns: Rust patterns\n\u27e816\u27e9 https://crates.io/support?crate=derive_builder&inquire=crate-violation:  Report crate \n",
              "fit_markdown": "",
              "fit_html": ""
            },
            "structured_data": {},
            "quality_score": 3.0,
            "extraction_method": "crawl4ai",
            "error": null,
            "metadata": {
              "doc_type": "docs",
              "content_length": 1605,
              "has_structured_data": false,
              "crawl_success": true
            },
            "timestamp": "117719.4574624"
          },
          "docs_rs": {
            "url": "https://docs.rs/derive_builder",
            "title": "Crate derive_builderCopy item path",
            "content": {
              "raw_markdown": "[](https://docs.rs/derive_builder/latest/derive_builder/all.html \"show sidebar\")\n# Crate derive_builderCopy item path\n[Settings](https://docs.rs/derive_builder/latest/settings.html)\n[Help](https://docs.rs/derive_builder/latest/help.html)\nSummary[Source](https://docs.rs/derive_builder/latest/src/derive_builder/lib.rs.html#1-717)\nExpand description\nDerive a builder for a struct\nThis crate implements the [builder pattern](https://web.archive.org/web/20170701044756/https://aturon.github.io/ownership/builders.html) for you. Just apply `#[derive(Builder)]` to a struct `Foo`, and it will derive an additional struct `FooBuilder` with **setter** -methods for all fields and a **build** -method \u2014 the way you want it.\n## [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#quick-start)Quick Start\nAdd `derive_builder` as a dependency to you `Cargo.toml`.\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#what-you-write)What you write\n```\nuse derive_builder::Builder;\n#[derive(Builder)]\nstruct Lorem {\n  ipsum: u32,\n  // ..\n}\n```\n\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#what-you-get)What you get\n```\n#[derive(Clone, Default)]\nstruct LoremBuilder {\n  ipsum: Option<u32>,\n}\n#[allow(dead_code)]\nimpl LoremBuilder {\n  pub fn ipsum(&mut self, value: u32) -> &mut Self {\n    let mut new = self;\n    new.ipsum = Some(value);\n    new\n  }\n  fn build(&self) -> Result<Lorem, LoremBuilderError> {\n    Ok(Lorem {\n      ipsum: Clone::clone(self.ipsum\n        .as_ref()\n        .ok_or(LoremBuilderError::from(UninitializedFieldError::new(\"ipsum\")))?),\n    })\n  }\n}\n```\n\nBy default all generated setter-methods take and return `&mut self` (aka _non-consuming_ builder pattern). Accordingly, the build method also takes a reference by default.\nYou can easily opt into different patterns and control many other aspects.\nThe build method returns `Result<T, E>`, where `T` is the struct you started with and E is a generated builder error type. It returns `Err` if you didn\u2019t initialize all fields and no default values were provided.\n## [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#builder-patterns)Builder Patterns\nLet\u2019s look again at the example above. You can now build structs like this:\n```\nlet x: Lorem = LoremBuilder::default().ipsum(42).build()?;\n```\n\nOk, _chaining_ method calls is nice, but what if `ipsum(42)` should only happen if `geek = true`?\nSo let\u2019s make this call conditional\n```\nlet mut builder = LoremBuilder::default();\nif geek {\n  builder.ipsum(42);\n}\nlet x: Lorem = builder.build()?;\n```\n\nNow it comes in handy that our setter methods take and return mutable references. Otherwise we would need to write something more clumsy like `builder = builder.ipsum(42)` to reassign the return value each time we have to call a setter conditionally.\nSetters with mutable references are therefore a convenient default for the builder pattern in Rust.\nBut this is a free world and the choice is still yours!\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#owned-aka-consuming)Owned, aka Consuming\nPrecede your struct (or field) with `#[builder(pattern = \"owned\")]` to opt into this pattern. Builders generated with this pattern do not automatically derive `Clone`, which allows builders to be generated for structs with fields that do not derive `Clone`.\n  * Setters take and return `self`.\n  * PRO: Setter calls and final build method can be chained.\n  * CON: If you don\u2019t chain your calls, you have to create a reference to each return value, e.g. `builder = builder.ipsum(42)`.\n\n\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#mutable-aka-non-consuming-recommended)Mutable, aka Non-Consuming (recommended)\nThis pattern is recommended and active by default if you don\u2019t specify anything else. You can precede your struct (or field) with `#[builder(pattern = \"mutable\")]` to make this choice explicit.\n  * Setters take and return `&mut self`.\n  * PRO: Setter calls and final build method can be chained.\n  * CON: The build method must clone or copy data to create something owned out of a mutable reference. Otherwise it could not be used in a chain. **(*)**\n\n\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#immutable)Immutable\nPrecede your struct (or field) with `#[builder(pattern = \"immutable\")]` to opt into this pattern.\n  * Setters take and return `&self`.\n  * PRO: Setter calls and final build method can be chained.\n  * CON: If you don\u2019t chain your calls, you have to create a reference to each return value, e.g. `builder = builder.ipsum(42)`.\n  * CON: The build method _and each setter_ must clone or copy data to create something owned out of a reference. **(*)**\n\n\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#-performance-considerations)(*) Performance Considerations\nLuckily Rust is clever enough to optimize these clone-calls away in release builds for your every-day use cases. Thats quite a safe bet - we checked this for you. ;-) Switching to consuming signatures (=`self`) is unlikely to give you any performance gain, but very likely to restrict your API for non-chained use cases.\n## [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#more-features)More Features\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#hidden-fields)Hidden Fields\nYou can hide fields by skipping their setters on (and presence in) the builder struct.\n  * Opt-out \u2014 skip setters via `#[builder(setter(skip))]` on individual fields.\n  * Opt-in \u2014 set `#[builder(setter(skip))]` on the whole struct and enable individual setters via `#[builder(setter)]`.\n\n\nThe types of skipped fields must implement `Default`.\n```\n#[derive(Builder)]\nstruct HiddenField {\n  setter_present: u32,\n  #[builder(setter(skip))]\n  setter_skipped: u32,\n}\n```\n\nAlternatively, you can use the more verbose form:\n  * `#[builder(setter(skip = true))]`\n  * `#[builder(setter(skip = false))]`\n\n\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#custom-setters-skip-autogenerated-setters)Custom setters (skip autogenerated setters)\nSimilarly to `setter(skip)`, you can say that you will provide your own setter methods. This simply suppresses the generation of the setter, leaving the field in the builder, as `Option<T>`.\n```\n#[derive(Builder)]\nstruct SetterOptOut {\n  #[builder(setter(custom))]\n  custom_setter: u32,\n}\nimpl SetterOptOutBuilder {\n  fn custom_setter(&mut self, value: u32) {\n    self.custom_setter = Some(value);\n  }\n}\n```\n\nAgain, the more verbose form is accepted:\n  * `#[builder(setter(custom = true))]`\n  * `#[builder(setter(custom = false))]`\n\n\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#setter-visibility)Setter Visibility\nSetters are public by default. You can precede your struct (or field) with `#[builder(public)]` to make this explicit.\nOtherwise precede your struct (or field) with `#[builder(private)]` to opt into private setters.\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#generated-builder-struct-name)Generated builder struct name\nBy default, the builder struct for `struct Foo` is `FooBuilder`. You can override this:\n```\n#[derive(Builder)]\n#[builder(name = \"FooConstructor\")]\nstruct Foo { }\nlet foo: Foo = FooConstructor::default().build()?;\n```\n\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#setter-nameprefix)Setter Name/Prefix\nSetter methods are named after their corresponding field by default.\n  * You can customize the setter name via `#[builder(setter(name = \"foo\"))`.\n  * Alternatively you can set a prefix via `#[builder(setter(prefix = \"xyz\"))`, which will change the method name to `xyz_foo` if the field is named `foo`. Note that an underscore is inserted, since Rust favors snake case here.\n\n\nPrefixes can also be defined on the struct level, but renames only work on fields. Renames take precedence over prefix definitions.\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#generic-setters)Generic Setters\nYou can make each setter generic over the `Into`-trait. It\u2019s as simple as adding `#[builder(setter(into))]` to either a field or the whole struct.\n```\n#[derive(Builder, Debug, PartialEq)]\nstruct Lorem {\n  #[builder(setter(into))]\n  pub ipsum: String,\n}\nfn main() {\n  // `\"foo\"` will be converted into a `String` automatically.\n  let x = LoremBuilder::default().ipsum(\"foo\").build().unwrap();\n  assert_eq!(x, Lorem {\n    ipsum: \"foo\".to_string(),\n  });\n}\n```\n\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#setters-for-option)Setters for Option\nYou can avoid wrapping values in `Some(...)` for fields of type `Option<T>`. It\u2019s as simple as adding `#[builder(setter(strip_option))]` to either a single field or the whole struct.\n```\n#[derive(Builder, Debug, PartialEq)]\nstruct Lorem {\n  #[builder(setter(into, strip_option))]\n  pub ipsum: Option<String>,\n  #[builder(setter(into, strip_option), default)]\n  pub foo: Option<String>,\n}\nfn main() {\n  // `\"foo\"` will be converted into a `String` automatically.\n  let x = LoremBuilder::default().ipsum(\"foo\").build().unwrap();\n  assert_eq!(x, Lorem {\n    ipsum: Some(\"foo\".to_string()),\n    foo: None\n  });\n}\n```\n\nIf you want to set the value to None when unset, then enable `default` on this field (or do not use `strip_option`).\nLimitation: only the `Option` type name is supported, not type alias nor `std::option::Option`.\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#fallible-setters)Fallible Setters\nAlongside the normal setter methods, you can expose fallible setters which are generic over the `TryInto` trait. TryInto is similar to `Into` with the key distinction that the conversion can fail, and therefore produces a `Result`.\nYou can only declare the `try_setter` attribute today if you\u2019re targeting nightly, and you have to add `#![feature(try_from)]` to your crate to use it.\n```\n#[derive(Builder, Debug, PartialEq)]\n#[builder(try_setter, setter(into))]\nstruct Lorem {\n  pub name: String,\n  pub ipsum: u8,\n}\n#[derive(Builder, Debug, PartialEq)]\nstruct Ipsum {\n  #[builder(try_setter, setter(into, name = \"foo\"))]\n  pub dolor: u8,\n}\nfn main() {\n  LoremBuilder::default()\n    .try_ipsum(1u16).unwrap()\n    .name(\"hello\")\n    .build()\n    .expect(\"1 fits into a u8\");\n  IpsumBuilder::default()\n    .try_foo(1u16).unwrap()\n    .build()\n    .expect(\"1 fits into a u8\");\n}\n```\n\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#default-values)Default Values\nYou can define default values for each field via annotation by `#[builder(default = \"...\")]`, where `...` stands for any Rust expression and must be string-escaped, e.g.\n  * `#[builder(default = \"42\")]`\n  * `#[builder(default)]` delegates to the [`Default`](https://doc.rust-lang.org/std/default/trait.Default.html) trait of the base type.\n\n\nThe expression will be evaluated with each call to `build`.\n```\n#[derive(Builder, Debug, PartialEq)]\nstruct Lorem {\n  #[builder(default = \"42\")]\n  pub ipsum: u32,\n}\nfn main() {\n  // If we don't set the field `ipsum`,\n  let x = LoremBuilder::default().build().unwrap();\n  // .. the custom default will be used for `ipsum`:\n  assert_eq!(x, Lorem {\n    ipsum: 42,\n  });\n}\n```\n\n#### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#tips-on-defaults)Tips on Defaults\n  * The `#[builder(default)]` annotation can be used on the struct level, too. Overrides are still possible.\n  * Delegate to a private helper method on `FooBuilder` for anything fancy. This way you will get _much better error diagnostics_ from the rust compiler and it will be _much more readable_ for other human beings. :-)\n  * Defaults will not work while using `#[builder(build_fn(skip))]`. In this case, you\u2019ll need to handle default values yourself when converting from the builder, such as by using `.unwrap_or()` and `.unwrap_or_else()`.\n\n\n```\nstruct Lorem {\n  ipsum: String,\n  // Custom defaults can delegate to helper methods\n  // and pass errors to the enclosing `build()` method via `?`.\n  #[builder(default = \"self.default_dolor()?\")]\n  dolor: String,\n}\nimpl LoremBuilder {\n  // Private helper method with access to the builder struct.\n  fn default_dolor(&self) -> Result<String, String> {\n    match self.ipsum {\n      Some(ref x) if x.chars().count() > 3 => Ok(format!(\"dolor {}\", x)),\n      _ => Err(\"ipsum must at least 3 chars to build dolor\".to_string()),\n    }\n  }\n}\n\n```\n\nYou can even reference other fields, but you have to remember that the builder struct will wrap every type in an Option ([as illustrated earlier](https://docs.rs/derive_builder/latest/derive_builder/#what-you-get)).\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#generic-structs)Generic Structs\n```\n#[derive(Builder, Debug, PartialEq, Default, Clone)]\nstruct GenLorem<T: Clone> {\n  ipsum: &'static str,\n  dolor: T,\n}\nfn main() {\n  let x = GenLoremBuilder::default().ipsum(\"sit\").dolor(42).build().unwrap();\n  assert_eq!(x, GenLorem { ipsum: \"sit\".into(), dolor: 42 });\n}\n```\n\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#build-method-customization)Build Method Customization\nYou can rename or suppress the auto-generated build method, leaving you free to implement your own version. Suppression is done using `#[builder(build_fn(skip))]` at the struct level, and renaming is done with `#[builder(build_fn(name = \"YOUR_NAME\"))]`.\nAdditionally if you want to make the build method private you can apply `#[builder(build_fn(private))]`.\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#pre-build-validation)Pre-Build Validation\nIf you\u2019re using the provided `build` method, you can declare `#[builder(build_fn(validate = \"path::to::fn\"))]` to specify a validator function which gets access to the builder before construction. The path does not need to be fully-qualified, and will consider `use` statements made at module level. It must be accessible from the scope where the target struct is declared.\nThe provided function must have the signature `(&FooBuilder) -> Result<_, String>`; the `Ok` variant is not used by the `build` method.\n```\n#[derive(Builder, Debug, PartialEq)]\n#[builder(build_fn(validate = \"Self::validate\"))]\nstruct Lorem {\n  pub ipsum: u8,\n}\nimpl LoremBuilder {\n  /// Check that `Lorem` is putting in the right amount of effort.\n  fn validate(&self) -> Result<(), String> {\n    if let Some(ref ipsum) = self.ipsum {\n      match *ipsum {\n        i if i < 20 => Err(\"Try harder\".to_string()),\n        i if i > 100 => Err(\"You'll tire yourself out\".to_string()),\n        _ => Ok(())\n      }\n    } else {\n      Ok(())\n    }\n  }\n}\nfn main() {\n  // If we're trying too hard...\n  let x = LoremBuilder::default().ipsum(120).build().unwrap_err();\n  // .. the build will fail:\n  assert_eq!(&x.to_string(), \"You'll tire yourself out\");\n}\n```\n\nNote:\n  * Default values are applied _after_ validation, and will therefore not be validated!\n\n\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#additional-trait-derivations)Additional Trait Derivations\nYou can derive additional traits on the builder, including traits defined by other crates:\n```\n#[derive(Builder, Clone)]\n#[builder(derive(Debug, PartialEq, Eq))]\npub struct Lorem {\n  foo: u8,\n  bar: String,\n}\nfn main() {\n  assert_eq!(LoremBuilder::default(), LoremBuilder::default());\n}\n```\n\nAttributes declared for those traits are _not_ forwarded to the fields on the builder.\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#documentation-comments-and-attributes)Documentation Comments and Attributes\n`#[derive(Builder)]` copies doc comments and attributes (`#[...]`) from your fields to the according builder fields and setter-methods, if it is one of the following:\n  * `/// ...`\n  * `#[doc = ...]`\n  * `#[cfg(...)]`\n  * `#[allow(...)]`\n\n\nThe whitelisting minimizes interference with other custom attributes like those used by Serde, Diesel, or others.\n```\n#[derive(Builder)]\nstruct Lorem {\n  /// `ipsum` may be any `String` (be creative).\n  ipsum: String,\n  #[doc = r\"`dolor` is the estimated amount of work.\"]\n  dolor: i32,\n  // `#[derive(Builder)]` understands conditional compilation via cfg-attributes,\n  // i.e. => \"no field = no setter\".\n  #[cfg(target_os = \"macos\")]\n  #[allow(non_snake_case)]\n  Im_a_Mac: bool,\n}\n```\n\n#### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#pass-through-attributes)Pass-through Attributes\nYou can set attributes on elements of the builder using the `builder_*_attr` attributes:\n  * `builder_struct_attr` adds attributes after `#[derive(...)]` on the builder struct.\n  * `builder_impl_attr` adds attributes on the `impl` block\n  * `builder_field_attr` adds attributes to field declarations in the builder struct.\n  * `builder_setter_attr` adds attributes to the setter in the `impl` block.\n\n\n```\n#[derive(Builder)]\n#[builder(derive(serde::Serialize))]\n#[builder_struct_attr(serde(rename_all = \"camelCase\"))]\nstruct Lorem {\n  #[builder_field_attr(serde(rename=\"dolor\"))]\n  ipsum: String,\n}\nlet mut show = LoremBuilder::default();\nshow.ipsum(\"sit\".into());\nassert_eq!(serde_json::to_string(&show).unwrap(), r#\"{\"dolor\":\"sit\"}\"#);\n```\n\n## [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#error-return-type-from-autogenerated-build-function)Error return type from autogenerated `build` function\nBy default, `build` returns an autogenerated error type:\n```\n#[doc=\"Error type for LoremBuilder\"]\n#[derive(Debug)]\n#[non_exhaustive]\npub enum LoremBuilderError { // where `LoremBuilder` is the name of the builder struct\n  /// Uninitialized field\n  UninitializedField(&'static str),\n  /// Custom validation error\n  ValidationError(String),\n}\nimpl From<String> for LoremBuilderError {\n  fn from(s: String) -> Self { Self::ValidationError(s) }\n}\nimpl From<UninitializedFieldError> for LoremBuilderError { // ...\nimpl Display for LoremBuilderError { // ...\nimpl std::error::Error for LoremBuilderError {}\n```\n\nAlternatively, you can specify your own error type:\n```\n#[derive(Builder, Debug, PartialEq)]\n#[builder(build_fn(error = \"OurLoremError\"))]\nstruct Lorem {\n  pub ipsum: u32,\n}\nstruct OurLoremError(String);\nimpl From<UninitializedFieldError> for OurLoremError {\n  fn from(ufe: UninitializedFieldError) -> OurLoremError { OurLoremError(ufe.to_string()) }\n}\nlet err: OurLoremError = LoremBuilder::default().build().unwrap_err();\nassert_eq!(&err.0, \"Field not initialized: ipsum\");\n```\n\n## [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#completely-custom-fields-in-the-builder)Completely custom fields in the builder\nInstead of having an `Option`, you can have whatever type you like:\n```\n#[derive(Debug, PartialEq, Default, Builder, Clone)]\n#[builder(derive(Debug, PartialEq))]\nstruct Lorem {\n  #[builder(setter(into), field(ty = \"u32\"))]\n  ipsum: u32,\n  #[builder(field(ty = \"String\", build = \"()\"))]\n  dolor: (),\n  #[builder(field(ty = \"&'static str\", build = \"self.amet.parse()?\"))]\n  amet: u32,\n}\nimpl From<std::num::ParseIntError> for LoremBuilderError { // ...\nlet mut builder = LoremBuilder::default();\nbuilder.ipsum(42u16).dolor(\"sit\".into()).amet(\"12\");\nassert_eq!(builder, LoremBuilder { ipsum: 42, dolor: \"sit\".into(), amet: \"12\" });\nlet lorem = builder.build().unwrap();\nassert_eq!(lorem, Lorem { ipsum: 42, dolor: (), amet: 12 });\n```\n\nThe builder field type (`ty =`) must implement `Default`.\nThe argument to `build` must be a literal string containing Rust code for the contents of a block, which must evaluate to the type of the target field. It may refer to the builder struct as `self`, use `?`, etc.\n## [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#no_std-support-on-nightly)**`#![no_std]`**Support (on Nightly)\nYou can activate support for `#![no_std]` by adding `#[builder(no_std)]` to your struct and `#![feature(alloc)] extern crate alloc` to your crate.\nThe latter requires the _nightly_ toolchain.\n## [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#troubleshooting)Troubleshooting\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#gotchas)Gotchas\n  * Tuple structs and unit structs are not supported as they have no field names.\n  * Generic setters introduce a type parameter `VALUE: Into<_>`. Therefore you can\u2019t use `VALUE` as a type parameter on a generic struct in combination with generic setters.\n  * The `try_setter` attribute and `owned` builder pattern are not compatible in practice; an error during building will consume the builder, making it impossible to continue construction.\n  * When re-exporting the underlying struct under a different name, the auto-generated documentation will not match.\n  * If derive_builder depends on your crate, and vice versa, then a cyclic dependency would occur. To break it you could try to depend on the [`derive_builder_core`](https://crates.io/crates/derive_builder_core) crate instead.\n\n\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#report-issues-and-ideas)Report Issues and Ideas\n[Open an issue on GitHub](https://github.com/colin-kiegel/rust-derive-builder/issues)\nIf possible please try to provide the debugging info if you experience unexpected compilation errors (see above).\n## Structs[\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#structs)\n\n[UninitializedFieldError](https://docs.rs/derive_builder/latest/derive_builder/struct.UninitializedFieldError.html \"struct derive_builder::UninitializedFieldError\")\n    Runtime error when a `build()` method is called and one or more required fields do not have a value.\n## Derive Macros[\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#derives)\n\n[Builder](https://docs.rs/derive_builder/latest/derive_builder/derive.Builder.html \"derive derive_builder::Builder\")\n    Create a builder struct for the deriving struct.\n",
              "markdown_with_citations": "[](https://docs.rs/derive_builder/latest/derive_builder/all.html \"show sidebar\")\n# Crate derive_builderCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nDerive a builder for a struct\nThis crate implements the builder pattern\u27e84\u27e9 for you. Just apply `#[derive(Builder)]` to a struct `Foo`, and it will derive an additional struct `FooBuilder` with **setter** -methods for all fields and a **build** -method \u2014 the way you want it.\n## \u00a7\u27e85\u27e9Quick Start\nAdd `derive_builder` as a dependency to you `Cargo.toml`.\n### \u00a7\u27e86\u27e9What you write\n```\nuse derive_builder::Builder;\n#[derive(Builder)]\nstruct Lorem {\n  ipsum: u32,\n  // ..\n}\n```\n\n### \u00a7\u27e87\u27e9What you get\n```\n#[derive(Clone, Default)]\nstruct LoremBuilder {\n  ipsum: Option<u32>,\n}\n#[allow(dead_code)]\nimpl LoremBuilder {\n  pub fn ipsum(&mut self, value: u32) -> &mut Self {\n    let mut new = self;\n    new.ipsum = Some(value);\n    new\n  }\n  fn build(&self) -> Result<Lorem, LoremBuilderError> {\n    Ok(Lorem {\n      ipsum: Clone::clone(self.ipsum\n        .as_ref()\n        .ok_or(LoremBuilderError::from(UninitializedFieldError::new(\"ipsum\")))?),\n    })\n  }\n}\n```\n\nBy default all generated setter-methods take and return `&mut self` (aka _non-consuming_ builder pattern). Accordingly, the build method also takes a reference by default.\nYou can easily opt into different patterns and control many other aspects.\nThe build method returns `Result<T, E>`, where `T` is the struct you started with and E is a generated builder error type. It returns `Err` if you didn\u2019t initialize all fields and no default values were provided.\n## \u00a7\u27e88\u27e9Builder Patterns\nLet\u2019s look again at the example above. You can now build structs like this:\n```\nlet x: Lorem = LoremBuilder::default().ipsum(42).build()?;\n```\n\nOk, _chaining_ method calls is nice, but what if `ipsum(42)` should only happen if `geek = true`?\nSo let\u2019s make this call conditional\n```\nlet mut builder = LoremBuilder::default();\nif geek {\n  builder.ipsum(42);\n}\nlet x: Lorem = builder.build()?;\n```\n\nNow it comes in handy that our setter methods take and return mutable references. Otherwise we would need to write something more clumsy like `builder = builder.ipsum(42)` to reassign the return value each time we have to call a setter conditionally.\nSetters with mutable references are therefore a convenient default for the builder pattern in Rust.\nBut this is a free world and the choice is still yours!\n### \u00a7\u27e89\u27e9Owned, aka Consuming\nPrecede your struct (or field) with `#[builder(pattern = \"owned\")]` to opt into this pattern. Builders generated with this pattern do not automatically derive `Clone`, which allows builders to be generated for structs with fields that do not derive `Clone`.\n  * Setters take and return `self`.\n  * PRO: Setter calls and final build method can be chained.\n  * CON: If you don\u2019t chain your calls, you have to create a reference to each return value, e.g. `builder = builder.ipsum(42)`.\n\n\n### \u00a7\u27e810\u27e9Mutable, aka Non-Consuming (recommended)\nThis pattern is recommended and active by default if you don\u2019t specify anything else. You can precede your struct (or field) with `#[builder(pattern = \"mutable\")]` to make this choice explicit.\n  * Setters take and return `&mut self`.\n  * PRO: Setter calls and final build method can be chained.\n  * CON: The build method must clone or copy data to create something owned out of a mutable reference. Otherwise it could not be used in a chain. **(*)**\n\n\n### \u00a7\u27e811\u27e9Immutable\nPrecede your struct (or field) with `#[builder(pattern = \"immutable\")]` to opt into this pattern.\n  * Setters take and return `&self`.\n  * PRO: Setter calls and final build method can be chained.\n  * CON: If you don\u2019t chain your calls, you have to create a reference to each return value, e.g. `builder = builder.ipsum(42)`.\n  * CON: The build method _and each setter_ must clone or copy data to create something owned out of a reference. **(*)**\n\n\n### \u00a7\u27e812\u27e9(*) Performance Considerations\nLuckily Rust is clever enough to optimize these clone-calls away in release builds for your every-day use cases. Thats quite a safe bet - we checked this for you. ;-) Switching to consuming signatures (=`self`) is unlikely to give you any performance gain, but very likely to restrict your API for non-chained use cases.\n## \u00a7\u27e813\u27e9More Features\n### \u00a7\u27e814\u27e9Hidden Fields\nYou can hide fields by skipping their setters on (and presence in) the builder struct.\n  * Opt-out \u2014 skip setters via `#[builder(setter(skip))]` on individual fields.\n  * Opt-in \u2014 set `#[builder(setter(skip))]` on the whole struct and enable individual setters via `#[builder(setter)]`.\n\n\nThe types of skipped fields must implement `Default`.\n```\n#[derive(Builder)]\nstruct HiddenField {\n  setter_present: u32,\n  #[builder(setter(skip))]\n  setter_skipped: u32,\n}\n```\n\nAlternatively, you can use the more verbose form:\n  * `#[builder(setter(skip = true))]`\n  * `#[builder(setter(skip = false))]`\n\n\n### \u00a7\u27e815\u27e9Custom setters (skip autogenerated setters)\nSimilarly to `setter(skip)`, you can say that you will provide your own setter methods. This simply suppresses the generation of the setter, leaving the field in the builder, as `Option<T>`.\n```\n#[derive(Builder)]\nstruct SetterOptOut {\n  #[builder(setter(custom))]\n  custom_setter: u32,\n}\nimpl SetterOptOutBuilder {\n  fn custom_setter(&mut self, value: u32) {\n    self.custom_setter = Some(value);\n  }\n}\n```\n\nAgain, the more verbose form is accepted:\n  * `#[builder(setter(custom = true))]`\n  * `#[builder(setter(custom = false))]`\n\n\n### \u00a7\u27e816\u27e9Setter Visibility\nSetters are public by default. You can precede your struct (or field) with `#[builder(public)]` to make this explicit.\nOtherwise precede your struct (or field) with `#[builder(private)]` to opt into private setters.\n### \u00a7\u27e817\u27e9Generated builder struct name\nBy default, the builder struct for `struct Foo` is `FooBuilder`. You can override this:\n```\n#[derive(Builder)]\n#[builder(name = \"FooConstructor\")]\nstruct Foo { }\nlet foo: Foo = FooConstructor::default().build()?;\n```\n\n### \u00a7\u27e818\u27e9Setter Name/Prefix\nSetter methods are named after their corresponding field by default.\n  * You can customize the setter name via `#builder(setter(name = \"foo\"))`.\n  * Alternatively you can set a prefix via `#[builder(setter(prefix = \"xyz\"))`, which will change the method name to `xyz_foo` if the field is named `foo`. Note that an underscore is inserted, since Rust favors snake case here.\n\n\nPrefixes can also be defined on the struct level, but renames only work on fields. Renames take precedence over prefix definitions.\n### [\u00a7\u27e819\u27e9Generic Setters\nYou can make each setter generic over the `Into`-trait. It\u2019s as simple as adding `#[builder(setter(into))]` to either a field or the whole struct.\n```\n#[derive(Builder, Debug, PartialEq)]\nstruct Lorem {\n  #[builder(setter(into))]\n  pub ipsum: String,\n}\nfn main() {\n  // `\"foo\"` will be converted into a `String` automatically.\n  let x = LoremBuilder::default().ipsum(\"foo\").build().unwrap();\n  assert_eq!(x, Lorem {\n    ipsum: \"foo\".to_string(),\n  });\n}\n```\n\n### \u00a7\u27e820\u27e9Setters for Option\nYou can avoid wrapping values in `Some(...)` for fields of type `Option<T>`. It\u2019s as simple as adding `#[builder(setter(strip_option))]` to either a single field or the whole struct.\n```\n#[derive(Builder, Debug, PartialEq)]\nstruct Lorem {\n  #[builder(setter(into, strip_option))]\n  pub ipsum: Option<String>,\n  #[builder(setter(into, strip_option), default)]\n  pub foo: Option<String>,\n}\nfn main() {\n  // `\"foo\"` will be converted into a `String` automatically.\n  let x = LoremBuilder::default().ipsum(\"foo\").build().unwrap();\n  assert_eq!(x, Lorem {\n    ipsum: Some(\"foo\".to_string()),\n    foo: None\n  });\n}\n```\n\nIf you want to set the value to None when unset, then enable `default` on this field (or do not use `strip_option`).\nLimitation: only the `Option` type name is supported, not type alias nor `std::option::Option`.\n### \u00a7\u27e821\u27e9Fallible Setters\nAlongside the normal setter methods, you can expose fallible setters which are generic over the `TryInto` trait. TryInto is similar to `Into` with the key distinction that the conversion can fail, and therefore produces a `Result`.\nYou can only declare the `try_setter` attribute today if you\u2019re targeting nightly, and you have to add `#![feature(try_from)]` to your crate to use it.\n```\n#[derive(Builder, Debug, PartialEq)]\n#[builder(try_setter, setter(into))]\nstruct Lorem {\n  pub name: String,\n  pub ipsum: u8,\n}\n#[derive(Builder, Debug, PartialEq)]\nstruct Ipsum {\n  #[builder(try_setter, setter(into, name = \"foo\"))]\n  pub dolor: u8,\n}\nfn main() {\n  LoremBuilder::default()\n    .try_ipsum(1u16).unwrap()\n    .name(\"hello\")\n    .build()\n    .expect(\"1 fits into a u8\");\n  IpsumBuilder::default()\n    .try_foo(1u16).unwrap()\n    .build()\n    .expect(\"1 fits into a u8\");\n}\n```\n\n### \u00a7\u27e822\u27e9Default Values\nYou can define default values for each field via annotation by `#[builder(default = \"...\")]`, where `...` stands for any Rust expression and must be string-escaped, e.g.\n  * `#[builder(default = \"42\")]`\n  * `#[builder(default)]` delegates to the `Default`\u27e823\u27e9 trait of the base type.\n\n\nThe expression will be evaluated with each call to `build`.\n```\n#[derive(Builder, Debug, PartialEq)]\nstruct Lorem {\n  #[builder(default = \"42\")]\n  pub ipsum: u32,\n}\nfn main() {\n  // If we don't set the field `ipsum`,\n  let x = LoremBuilder::default().build().unwrap();\n  // .. the custom default will be used for `ipsum`:\n  assert_eq!(x, Lorem {\n    ipsum: 42,\n  });\n}\n```\n\n#### \u00a7\u27e824\u27e9Tips on Defaults\n  * The `#[builder(default)]` annotation can be used on the struct level, too. Overrides are still possible.\n  * Delegate to a private helper method on `FooBuilder` for anything fancy. This way you will get _much better error diagnostics_ from the rust compiler and it will be _much more readable_ for other human beings. :-)\n  * Defaults will not work while using `#[builder(build_fn(skip))]`. In this case, you\u2019ll need to handle default values yourself when converting from the builder, such as by using `.unwrap_or()` and `.unwrap_or_else()`.\n\n\n```\nstruct Lorem {\n  ipsum: String,\n  // Custom defaults can delegate to helper methods\n  // and pass errors to the enclosing `build()` method via `?`.\n  #[builder(default = \"self.default_dolor()?\")]\n  dolor: String,\n}\nimpl LoremBuilder {\n  // Private helper method with access to the builder struct.\n  fn default_dolor(&self) -> Result<String, String> {\n    match self.ipsum {\n      Some(ref x) if x.chars().count() > 3 => Ok(format!(\"dolor {}\", x)),\n      _ => Err(\"ipsum must at least 3 chars to build dolor\".to_string()),\n    }\n  }\n}\n\n```\n\nYou can even reference other fields, but you have to remember that the builder struct will wrap every type in an Option (as illustrated earlier\u27e87\u27e9).\n### \u00a7\u27e825\u27e9Generic Structs\n```\n#[derive(Builder, Debug, PartialEq, Default, Clone)]\nstruct GenLorem<T: Clone> {\n  ipsum: &'static str,\n  dolor: T,\n}\nfn main() {\n  let x = GenLoremBuilder::default().ipsum(\"sit\").dolor(42).build().unwrap();\n  assert_eq!(x, GenLorem { ipsum: \"sit\".into(), dolor: 42 });\n}\n```\n\n### \u00a7\u27e826\u27e9Build Method Customization\nYou can rename or suppress the auto-generated build method, leaving you free to implement your own version. Suppression is done using `#[builder(build_fn(skip))]` at the struct level, and renaming is done with `#[builder(build_fn(name = \"YOUR_NAME\"))]`.\nAdditionally if you want to make the build method private you can apply `#[builder(build_fn(private))]`.\n### \u00a7\u27e827\u27e9Pre-Build Validation\nIf you\u2019re using the provided `build` method, you can declare `#[builder(build_fn(validate = \"path::to::fn\"))]` to specify a validator function which gets access to the builder before construction. The path does not need to be fully-qualified, and will consider `use` statements made at module level. It must be accessible from the scope where the target struct is declared.\nThe provided function must have the signature `(&FooBuilder) -> Result<_, String>`; the `Ok` variant is not used by the `build` method.\n```\n#[derive(Builder, Debug, PartialEq)]\n#[builder(build_fn(validate = \"Self::validate\"))]\nstruct Lorem {\n  pub ipsum: u8,\n}\nimpl LoremBuilder {\n  /// Check that `Lorem` is putting in the right amount of effort.\n  fn validate(&self) -> Result<(), String> {\n    if let Some(ref ipsum) = self.ipsum {\n      match *ipsum {\n        i if i < 20 => Err(\"Try harder\".to_string()),\n        i if i > 100 => Err(\"You'll tire yourself out\".to_string()),\n        _ => Ok(())\n      }\n    } else {\n      Ok(())\n    }\n  }\n}\nfn main() {\n  // If we're trying too hard...\n  let x = LoremBuilder::default().ipsum(120).build().unwrap_err();\n  // .. the build will fail:\n  assert_eq!(&x.to_string(), \"You'll tire yourself out\");\n}\n```\n\nNote:\n  * Default values are applied _after_ validation, and will therefore not be validated!\n\n\n### \u00a7\u27e828\u27e9Additional Trait Derivations\nYou can derive additional traits on the builder, including traits defined by other crates:\n```\n#[derive(Builder, Clone)]\n#[builder(derive(Debug, PartialEq, Eq))]\npub struct Lorem {\n  foo: u8,\n  bar: String,\n}\nfn main() {\n  assert_eq!(LoremBuilder::default(), LoremBuilder::default());\n}\n```\n\nAttributes declared for those traits are _not_ forwarded to the fields on the builder.\n### \u00a7\u27e829\u27e9Documentation Comments and Attributes\n`#[derive(Builder)]` copies doc comments and attributes (`#[...]`) from your fields to the according builder fields and setter-methods, if it is one of the following:\n  * `/// ...`\n  * `#[doc = ...]`\n  * `#[cfg(...)]`\n  * `#[allow(...)]`\n\n\nThe whitelisting minimizes interference with other custom attributes like those used by Serde, Diesel, or others.\n```\n#[derive(Builder)]\nstruct Lorem {\n  /// `ipsum` may be any `String` (be creative).\n  ipsum: String,\n  #[doc = r\"`dolor` is the estimated amount of work.\"]\n  dolor: i32,\n  // `#[derive(Builder)]` understands conditional compilation via cfg-attributes,\n  // i.e. => \"no field = no setter\".\n  #[cfg(target_os = \"macos\")]\n  #[allow(non_snake_case)]\n  Im_a_Mac: bool,\n}\n```\n\n#### \u00a7\u27e830\u27e9Pass-through Attributes\nYou can set attributes on elements of the builder using the `builder_*_attr` attributes:\n  * `builder_struct_attr` adds attributes after `#[derive(...)]` on the builder struct.\n  * `builder_impl_attr` adds attributes on the `impl` block\n  * `builder_field_attr` adds attributes to field declarations in the builder struct.\n  * `builder_setter_attr` adds attributes to the setter in the `impl` block.\n\n\n```\n#[derive(Builder)]\n#[builder(derive(serde::Serialize))]\n#[builder_struct_attr(serde(rename_all = \"camelCase\"))]\nstruct Lorem {\n  #[builder_field_attr(serde(rename=\"dolor\"))]\n  ipsum: String,\n}\nlet mut show = LoremBuilder::default();\nshow.ipsum(\"sit\".into());\nassert_eq!(serde_json::to_string(&show).unwrap(), r#\"{\"dolor\":\"sit\"}\"#);\n```\n\n## \u00a7\u27e831\u27e9Error return type from autogenerated `build` function\nBy default, `build` returns an autogenerated error type:\n```\n#[doc=\"Error type for LoremBuilder\"]\n#[derive(Debug)]\n#[non_exhaustive]\npub enum LoremBuilderError { // where `LoremBuilder` is the name of the builder struct\n  /// Uninitialized field\n  UninitializedField(&'static str),\n  /// Custom validation error\n  ValidationError(String),\n}\nimpl From<String> for LoremBuilderError {\n  fn from(s: String) -> Self { Self::ValidationError(s) }\n}\nimpl From<UninitializedFieldError> for LoremBuilderError { // ...\nimpl Display for LoremBuilderError { // ...\nimpl std::error::Error for LoremBuilderError {}\n```\n\nAlternatively, you can specify your own error type:\n```\n#[derive(Builder, Debug, PartialEq)]\n#[builder(build_fn(error = \"OurLoremError\"))]\nstruct Lorem {\n  pub ipsum: u32,\n}\nstruct OurLoremError(String);\nimpl From<UninitializedFieldError> for OurLoremError {\n  fn from(ufe: UninitializedFieldError) -> OurLoremError { OurLoremError(ufe.to_string()) }\n}\nlet err: OurLoremError = LoremBuilder::default().build().unwrap_err();\nassert_eq!(&err.0, \"Field not initialized: ipsum\");\n```\n\n## \u00a7\u27e832\u27e9Completely custom fields in the builder\nInstead of having an `Option`, you can have whatever type you like:\n```\n#[derive(Debug, PartialEq, Default, Builder, Clone)]\n#[builder(derive(Debug, PartialEq))]\nstruct Lorem {\n  #[builder(setter(into), field(ty = \"u32\"))]\n  ipsum: u32,\n  #[builder(field(ty = \"String\", build = \"()\"))]\n  dolor: (),\n  #[builder(field(ty = \"&'static str\", build = \"self.amet.parse()?\"))]\n  amet: u32,\n}\nimpl From<std::num::ParseIntError> for LoremBuilderError { // ...\nlet mut builder = LoremBuilder::default();\nbuilder.ipsum(42u16).dolor(\"sit\".into()).amet(\"12\");\nassert_eq!(builder, LoremBuilder { ipsum: 42, dolor: \"sit\".into(), amet: \"12\" });\nlet lorem = builder.build().unwrap();\nassert_eq!(lorem, Lorem { ipsum: 42, dolor: (), amet: 12 });\n```\n\nThe builder field type (`ty =`) must implement `Default`.\nThe argument to `build` must be a literal string containing Rust code for the contents of a block, which must evaluate to the type of the target field. It may refer to the builder struct as `self`, use `?`, etc.\n## \u00a7\u27e833\u27e9**`#![no_std]`**Support (on Nightly)\nYou can activate support for `#![no_std]` by adding `#[builder(no_std)]` to your struct and `#![feature(alloc)] extern crate alloc` to your crate.\nThe latter requires the _nightly_ toolchain.\n## \u00a7\u27e834\u27e9Troubleshooting\n### \u00a7\u27e835\u27e9Gotchas\n  * Tuple structs and unit structs are not supported as they have no field names.\n  * Generic setters introduce a type parameter `VALUE: Into<_>`. Therefore you can\u2019t use `VALUE` as a type parameter on a generic struct in combination with generic setters.\n  * The `try_setter` attribute and `owned` builder pattern are not compatible in practice; an error during building will consume the builder, making it impossible to continue construction.\n  * When re-exporting the underlying struct under a different name, the auto-generated documentation will not match.\n  * If derive_builder depends on your crate, and vice versa, then a cyclic dependency would occur. To break it you could try to depend on the `derive_builder_core`\u27e836\u27e9 crate instead.\n\n\n### \u00a7\u27e837\u27e9Report Issues and Ideas\nOpen an issue on GitHub\u27e838\u27e9\nIf possible please try to provide the debugging info if you experience unexpected compilation errors (see above).\n## Structs\u00a7\u27e839\u27e9\n\nUninitializedFieldError\u27e840\u27e9\n    Runtime error when a `build()` method is called and one or more required fields do not have a value.\n## Derive Macros\u00a7\u27e841\u27e9\n\nBuilder\u27e842\u27e9\n    Create a builder struct for the deriving struct.\n",
              "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/derive_builder/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/derive_builder/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/derive_builder/latest/src/derive_builder/lib.rs.html#1-717: Source\n\u27e84\u27e9 https://web.archive.org/web/20170701044756/https://aturon.github.io/ownership/builders.html: builder pattern\n\u27e85\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#quick-start: \u00a7\n\u27e86\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#what-you-write: \u00a7\n\u27e87\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#what-you-get: \u00a7\n\u27e88\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#builder-patterns: \u00a7\n\u27e89\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#owned-aka-consuming: \u00a7\n\u27e810\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#mutable-aka-non-consuming-recommended: \u00a7\n\u27e811\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#immutable: \u00a7\n\u27e812\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#-performance-considerations: \u00a7\n\u27e813\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#more-features: \u00a7\n\u27e814\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#hidden-fields: \u00a7\n\u27e815\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#custom-setters-skip-autogenerated-setters: \u00a7\n\u27e816\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#setter-visibility: \u00a7\n\u27e817\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#generated-builder-struct-name: \u00a7\n\u27e818\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#setter-nameprefix: \u00a7\n\u27e819\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#generic-setters: builder(setter(name = \"foo\"))`.\n  * Alternatively you can set a prefix via `#[builder(setter(prefix = \"xyz\"))`, which will change the method name to `xyz_foo` if the field is named `foo`. Note that an underscore is inserted, since Rust favors snake case here.\n\n\nPrefixes can also be defined on the struct level, but renames only work on fields. Renames take precedence over prefix definitions.\n### [\u00a7\n\u27e820\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#setters-for-option: \u00a7\n\u27e821\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#fallible-setters: \u00a7\n\u27e822\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#default-values: \u00a7\n\u27e823\u27e9 https://doc.rust-lang.org/std/default/trait.Default.html: `Default`\n\u27e824\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#tips-on-defaults: \u00a7\n\u27e825\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#generic-structs: \u00a7\n\u27e826\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#build-method-customization: \u00a7\n\u27e827\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#pre-build-validation: \u00a7\n\u27e828\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#additional-trait-derivations: \u00a7\n\u27e829\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#documentation-comments-and-attributes: \u00a7\n\u27e830\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#pass-through-attributes: \u00a7\n\u27e831\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#error-return-type-from-autogenerated-build-function: \u00a7\n\u27e832\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#completely-custom-fields-in-the-builder: \u00a7\n\u27e833\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#no_std-support-on-nightly: \u00a7\n\u27e834\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#troubleshooting: \u00a7\n\u27e835\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#gotchas: \u00a7\n\u27e836\u27e9 https://crates.io/crates/derive_builder_core: `derive_builder_core`\n\u27e837\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#report-issues-and-ideas: \u00a7\n\u27e838\u27e9 https://github.com/colin-kiegel/rust-derive-builder/issues: Open an issue on GitHub\n\u27e839\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#structs: \u00a7\n\u27e840\u27e9 https://docs.rs/derive_builder/latest/derive_builder/struct.UninitializedFieldError.html: struct derive_builder::UninitializedFieldError - UninitializedFieldError\n\u27e841\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#derives: \u00a7\n\u27e842\u27e9 https://docs.rs/derive_builder/latest/derive_builder/derive.Builder.html: derive derive_builder::Builder - Builder\n",
              "fit_markdown": "",
              "fit_html": ""
            },
            "structured_data": {},
            "quality_score": 4.0,
            "extraction_method": "crawl4ai",
            "error": null,
            "metadata": {
              "doc_type": "docs",
              "content_length": 21578,
              "has_structured_data": false,
              "crawl_success": true
            },
            "timestamp": "117721.1246127"
          },
          "lib_rs": {
            "url": "https://lib.rs/crates/derive_builder",
            "title": "Untitled",
            "content": {
              "raw_markdown": "###  [34 releases](https://lib.rs/crates/derive_builder/versions)\n0.20.2 |  Oct 8, 2024   \n---|---  \n0.20.0 |  Feb 14, 2024   \n0.12.0 |  Nov 28, 2022   \n0.11.2 |  Apr 20, 2022   \n0.2.1 |  Sep 24, 2016   \n#**12** in [Rust patterns](https://lib.rs/rust-patterns \"Shared solutions for particular situations specific to programming in Rust.\")\nDownload history 812726/week @ 2025-03-03 817585/week @ 2025-03-10 1025843/week @ 2025-03-17 946677/week @ 2025-03-24 942339/week @ 2025-03-31 1006197/week @ 2025-04-07 873149/week @ 2025-04-14 895158/week @ 2025-04-21 821446/week @ 2025-04-28 912621/week @ 2025-05-05 971226/week @ 2025-05-12 1001751/week @ 2025-05-19 883679/week @ 2025-05-26 1002180/week @ 2025-06-02 966014/week @ 2025-06-09 993872/week @ 2025-06-16\n**3,887,587** downloads per month Used in [**3,184** crates (964 directly)](https://lib.rs/crates/derive_builder/rev)\n**MIT/Apache**\n40KB \n![Build](https://img.gs/czjpqfbdkz/full/https://github.com/colin-kiegel/rust-derive-builder/workflows/Build/badge.svg) [![Rust version](https://img.shields.io/badge/rust-1.56+-blue.svg)](https://github.com/colin-kiegel/rust-derive-builder/blob/fc18dd236a6dc6b5b49970efdb1b78f40bb3b998/derive_builder/) [![Documentation](https://img.gs/czjpqfbdkz/full/https://docs.rs/derive_builder/badge.svg)](https://docs.rs/derive_builder) [![Latest version](https://img.shields.io/crates/v/derive_builder.svg)](https://crates.io/crates/derive_builder) [![All downloads](https://img.shields.io/crates/d/derive_builder.svg)](https://crates.io/crates/derive_builder) [![Downloads of latest version](https://img.shields.io/crates/dv/derive_builder.svg)](https://crates.io/crates/derive_builder)\n# Builder Pattern Derive\n[Rust](https://www.rust-lang.org/) macro to automatically implement the **builder pattern** for arbitrary structs. A simple ````#``[``derive```(```Builder```)```]```` will generate a ``FooBuilder`` for your struct ``Foo`` with all setter-methods and a build method.\n## How it Works\n```\n``use` `derive_builder`::``Builder`;`\n``#``[``derive```(```Default`,` Builder`,` Debug```)```]``\n``#``[``builder```(`````setter``(```into```)`````)```]``\n``struct` ```Channel` ````{`\n  `token``:` `i32`,\n  `special_info``:` `i32`,\n  ``//` .. a whole bunch of other fields ..`\n```}```\n``fn` `main`````(````)``````{`\n  ``//` builder pattern, go, go, go!...`\n  `let` ch `=` `ChannelBuilder`::``default`(``)`\n    `.``special_info``(``42``u8``)`\n    `.``token``(``19124``)`\n    `.``build``(``)`\n    `.``unwrap``(``)``;`\n  `println!``(```\"``{:?}``\"```,` ch`)``;`\n```}```\n`\n```\n\nNote that we did not write any definition or implementation of ``ChannelBuilder``. Instead the ``derive_builder`` crate acts on ````#``[``derive```(```Builder```)```]```` and generates the necessary code at compile time.\nThis is the generated boilerplate code you didn't need to write. :-)\n```\n```#``[``derive```(```Clone`,` Default```)```]``\n``struct` ```ChannelBuilder` ````{`\n  `token``:` ``Option``<``i32``>``,\n  `special_info``:` ``Option``<``i32``>``,\n```}```\n``#``[``allow```(```dead_code```)```]``\n``impl` ```ChannelBuilder` ````{`\n  ``pub` `fn` `token````<`VALUE`:` `Into``<``i32``>``>`````(``&``mut` `self`, `value``:` VALUE```)```` ``->` `&``mut` `Self`` ```{`\n    `let` `mut` new `=` `self``;`\n    new`.`token `=` `Some``(`value`.``into``(``)``)``;`\n    new\n  `}``\n  ``pub` `fn` `special_info````<`VALUE`:` `Into``<``i32``>``>`````(``&``mut` `self`, `value``:` VALUE```)```` ``->` `&``mut` `Self`` ```{`\n    `let` `mut` new `=` `self``;`\n    new`.`special_info `=` `Some``(`value`.``into``(``)``)``;`\n    new\n  `}``\n  ``fn` `build`````(`\n    `&``self`,\n  ```)```` ``->` ``Result``<`Channel, ChannelBuilderError`>``` ```{`\n    `Ok``(`Channel `{`\n      id`:` `match` `self``.`id `{`\n        `Some``(``ref` value`)` `=>` `Clone```::``clone`(`value`)``,`\n        `None` `=>` `{`\n          `return` `Err``(`\n            `Into```::``into`(`\n              ``::```derive_builder`::```UninitializedFieldError`::``from`(```\"`id`\"```)``,`\n            `)``,`\n          `)`\n        `}`\n      `}``,`\n      token`:` `match` `self``.`token `{`\n        `Some``(``ref` value`)` `=>` `Clone```::``clone`(`value`)``,`\n        `None` `=>` `{`\n          `return` `Err``(`\n            `Into```::``into`(`\n              ``::```derive_builder`::```UninitializedFieldError`::``from`(```\"`token`\"```)``,`\n            `)``,`\n          `)`\n        `}`\n      `}``,`\n      special_info`:` `match` `self``.`special_info `{`\n        `Some``(``ref` value`)` `=>` `Clone```::``clone`(`value`)``,`\n        `None` `=>` `{`\n          `return` `Err``(`\n            `Into```::``into`(`\n              ``::```derive_builder`::```UninitializedFieldError`::``from`(```\"`special_info`\"```)``,`\n            `)``,`\n          `)`\n        `}`\n      `}``,`\n    `}``)`\n  `}``\n```}```\n`\n```\n\n_Note: This is edited for readability. The generated code doesn't assume traits such as```Into``` are in-scope, and uses full paths to access them._\n## Get Started\nIt's as simple as three steps:\n  1. Add ``derive_builder`` to your ``Cargo.toml`` either manually or with [cargo-edit](https://github.com/killercup/cargo-edit):\n\n\n  * ````cargo``` add derive_builder```\n\n\n  1. Add ```use` `derive_builder`::``Builder`;```\n  2. Annotate your struct with ````#``[``derive```(```Builder```)```]````\n\n\n## Usage and Features\n  * **Chaining** : The setter calls can be chained, because they consume and return ```&``mut` `self``` by default.\n  * **Builder patterns** : You can opt into other builder patterns by preceding your struct (or field) with ````#``[``builder```(```pattern `=` ``\"`owned`\"`````)```]```` or ````#``[``builder```(```pattern `=` ``\"`immutable`\"`````)```]````.\n  * **Extensible** : You can still define your own implementations for the builder struct and define additional methods. Just make sure to name them differently than the setter and build methods.\n  * **Documentation and attributes** : Setter methods can be documented by simply documenting the corresponding field. Similarly ````#``[``cfg```(```...```)```]```` and ````#``[``allow```(```...```)```]```` attributes are also applied to the setter methods.\n  * **Hidden fields** : You can skip setters via ````#``[``builder```(`````setter``(```skip```)`````)```]```` on each field individually.\n  * **Setter visibility** : You can opt into private setter by preceding your struct with ````#``[``builder```(```private```)```]````.\n  * **Setter type conversions** : With ````#``[``builder```(`````setter``(```into```)`````)```]````, setter methods will be generic over the input types \u2013 you can then supply every argument that implements the [```Into```](https://doc.rust-lang.org/nightly/std/convert/trait.Into.html) trait for the field type.\n  * **Setter strip option** : With ````#``[``builder```(`````setter``(```strip_option```)`````)```]````, setter methods will take ``T`` as parameter'type for field of type ````Option``<`T`>````.\n  * **Collection setters** : Adding ````#``[``builder```(`````setter``(````each``(`name `=` ``\"`method_name`\"```)````)`````)```]```` to fields whose types implement ```Default``` and ```Extend``` will generate a setter which adds items to the builder collection for that field. It's possible for these setters to be generic over the ````Into``<`T`>```` trait too, like so: ````#``[``builder```(`````setter``(````each``(`name `=` ``\"`foo`\"```,` into`)````)`````)```]````.\n  * **Builder field visibility** : You can use ````#``[``builder```(`````field``(```private```)`````)```]```` or ```..``(`public`)```, to set field visibility of your builder.\n  * **Generic structs** : Are also supported, but you **must not** use a type parameter named ``VALUE``, if you also activate setter type conversions.\n  * **Default values** : You can use ````#``[``builder```(```default```)```]```` to delegate to the ```Default``` implementation or any explicit value via `` `=` ``\"`..`\"````. This works both on the struct and field level.\n  * **Pre-build validation** : You can use ````#``[``builder```(`````build_fn``(```validate `=` ``\"`path::to::fn`\"`````)`````)```]```` to add your own validation before the target struct is generated.\n  * **Build method suppression** : You can use ````#``[``builder```(`````build_fn``(```skip```)`````)```]```` to disable auto-implementation of the build method and provide your own.\n  * **Custom build method error types** : You can use ````#``[``builder```(`````build_fn``(```error `=` ``\"`path::to::Error`\"`````)`````)```]```` to have your builder return an error type of your choosing. By default, the macro will emit an error type alongside the builder.\n  * **Builder derivations** : You can use ````#``[``builder```(`````derive``(```Trait1`,` Trait2`,` ...```)`````)```]```` to have the builder derive additonal traits. All builders derive ```Default``` and ```Clone```, so you should not declare those in this attribute.\n  * **Pass-through attributes** : Use ````#``[``builder_struct_attr```(```...```)```]````, ````#``[``builder_impl_attr```(```...```)```]````, ````#``[``builder_field_attr```(```...```)```]````, and ````#``[``builder_setter_attr```(```...```)```]```` to declare attributes that will be added to the relevant part of the generated builder.\n  * **no_std support** : Just add ````#``[``builder```(```no_std```)```]```` to your struct, use feature ``alloc``, and add ```extern` `crate` alloc`` to your crate.\n  * **No alloc no_std support** : Do not use ``alloc`` feature and then either add ````#``[``builder```(```no_std`,` ``build_fn``(````error``(`validation_error `=` false`)````)`````)```]```` or ````#``[``builder```(```no_std`,` ``build_fn``(```error `=` ``\"`path::to::Error`\"`````)`````)```]```` to your struct.\n  * **Renaming and re-export support** : Use ````#``[``builder```(```crate `=` ``\"`...`\"`````)```]```` to set the root for ``derive_builder``. This is useful if you want to rename ``derive_builder`` in ``Cargo.toml`` or if your crate is re-exporting ```derive_builder`::``Builder`` and needs the generated code to not directly reference the ``derive_builder`` crate.\n\n\nFor more information and examples please take a look at our [documentation](https://colin-kiegel.github.io/rust-derive-builder).\n## Gotchas\n  * Tuple structs and unit structs are not supported as they have no field names. We do not intend to support them.\n  * When defining a generic struct, you cannot use ``VALUE`` as a generic parameter as this is what all setters are using.\n\n\n## [Documentation](https://colin-kiegel.github.io/rust-derive-builder)\nDetailed explaination of all features and tips for troubleshooting. You'll also find a discussion of different builder patterns.\n## [Changelog](https://github.com/colin-kiegel/rust-derive-builder/blob/fc18dd236a6dc6b5b49970efdb1b78f40bb3b998/derive_builder/CHANGELOG.md)\nYes, we keep a changelog.\n## License\nLicensed under either of\n  * Apache License, Version 2.0, ([LICENSE-APACHE](https://github.com/colin-kiegel/rust-derive-builder/blob/fc18dd236a6dc6b5b49970efdb1b78f40bb3b998/derive_builder/LICENSE-APACHE) or <http://www.apache.org/licenses/LICENSE-2.0>)\n  * MIT license ([LICENSE-MIT](https://github.com/colin-kiegel/rust-derive-builder/blob/fc18dd236a6dc6b5b49970efdb1b78f40bb3b998/derive_builder/LICENSE-MIT) or <http://opensource.org/licenses/MIT>)\n\n\nat your option.\n### Contribution\nUnless you explicitly state otherwise, any contribution intentionally submitted for inclusion in the work by you, as defined in the Apache-2.0 license, shall be dual licensed as above, without any additional terms or conditions.\n#### Dependencies\n~0.6\u20131.1MB  ~24K SLoC\n  * [derive_builder_macro](https://lib.rs/crates/derive_builder_macro \"new\") =0.20.2\n\n\n  * dev  [rustversion](https://lib.rs/crates/rustversion \"1.0.4\")\n  * dev  [serde](https://lib.rs/crates/serde \"1\")[+derive](https://lib.rs/crates/serde/features#feature-derive)\n  * dev  [serde_json](https://lib.rs/crates/serde_json \"1\")\n  * dev  [trybuild](https://lib.rs/crates/trybuild \"1.0.38\") compiletests\n\n\n#### [Other features](https://lib.rs/crates/derive_builder/features)\n  * [alloc](https://lib.rs/crates/derive_builder/features#feature-alloc)\n  * [clippy](https://lib.rs/crates/derive_builder/features#feature-clippy)\n  * [std](https://lib.rs/crates/derive_builder/features#feature-std)\n\n\n  *[SLoC]: approx. additional lines of code\n",
              "markdown_with_citations": "###  34 releases\u27e81\u27e9\n0.20.2 |  Oct 8, 2024   \n---|---  \n0.20.0 |  Feb 14, 2024   \n0.12.0 |  Nov 28, 2022   \n0.11.2 |  Apr 20, 2022   \n0.2.1 |  Sep 24, 2016   \n#**12** in Rust patterns\u27e82\u27e9\nDownload history 812726/week @ 2025-03-03 817585/week @ 2025-03-10 1025843/week @ 2025-03-17 946677/week @ 2025-03-24 942339/week @ 2025-03-31 1006197/week @ 2025-04-07 873149/week @ 2025-04-14 895158/week @ 2025-04-21 821446/week @ 2025-04-28 912621/week @ 2025-05-05 971226/week @ 2025-05-12 1001751/week @ 2025-05-19 883679/week @ 2025-05-26 1002180/week @ 2025-06-02 966014/week @ 2025-06-09 993872/week @ 2025-06-16\n**3,887,587** downloads per month Used in **3,184** crates (964 directly)\u27e83\u27e9\n**MIT/Apache**\n40KB \n![Build\u27e84\u27e9] ![Rust version\u27e85\u27e9](https://github.com/colin-kiegel/rust-derive-builder/blob/fc18dd236a6dc6b5b49970efdb1b78f40bb3b998/derive_builder/) ![Documentation\u27e86\u27e9](https://docs.rs/derive_builder) ![Latest version\u27e87\u27e9](https://crates.io/crates/derive_builder) ![All downloads\u27e88\u27e9](https://crates.io/crates/derive_builder) ![Downloads of latest version\u27e89\u27e9](https://crates.io/crates/derive_builder)\n# Builder Pattern Derive\nRust\u27e810\u27e9 macro to automatically implement the **builder pattern** for arbitrary structs. A simple ````#``[``derive```(```Builder```)```]```` will generate a ``FooBuilder`` for your struct ``Foo`` with all setter-methods and a build method.\n## How it Works\n```\n``use` `derive_builder`::``Builder`;`\n``#``[``derive```(```Default`,` Builder`,` Debug```)```]``\n``#``[``builder```(`````setter``(```into```)`````)```]``\n``struct` ```Channel` ````{`\n  `token``:` `i32`,\n  `special_info``:` `i32`,\n  ``//` .. a whole bunch of other fields ..`\n```}```\n``fn` `main`````(````)``````{`\n  ``//` builder pattern, go, go, go!...`\n  `let` ch `=` `ChannelBuilder`::``default`(``)`\n    `.``special_info``(``42``u8``)`\n    `.``token``(``19124``)`\n    `.``build``(``)`\n    `.``unwrap``(``)``;`\n  `println!``(```\"``{:?}``\"```,` ch`)``;`\n```}```\n`\n```\n\nNote that we did not write any definition or implementation of ``ChannelBuilder``. Instead the ``derive_builder`` crate acts on ````#``[``derive```(```Builder```)```]```` and generates the necessary code at compile time.\nThis is the generated boilerplate code you didn't need to write. :-)\n```\n```#``[``derive```(```Clone`,` Default```)```]``\n``struct` ```ChannelBuilder` ````{`\n  `token``:` ``Option``<``i32``>``,\n  `special_info``:` ``Option``<``i32``>``,\n```}```\n``#``[``allow```(```dead_code```)```]``\n``impl` ```ChannelBuilder` ````{`\n  ``pub` `fn` `token````<`VALUE`:` `Into``<``i32``>``>`````(``&``mut` `self`, `value``:` VALUE```)```` ``->` `&``mut` `Self`` ```{`\n    `let` `mut` new `=` `self``;`\n    new`.`token `=` `Some``(`value`.``into``(``)``)``;`\n    new\n  `}``\n  ``pub` `fn` `special_info````<`VALUE`:` `Into``<``i32``>``>`````(``&``mut` `self`, `value``:` VALUE```)```` ``->` `&``mut` `Self`` ```{`\n    `let` `mut` new `=` `self``;`\n    new`.`special_info `=` `Some``(`value`.``into``(``)``)``;`\n    new\n  `}``\n  ``fn` `build`````(`\n    `&``self`,\n  ```)```` ``->` ``Result``<`Channel, ChannelBuilderError`>``` ```{`\n    `Ok``(`Channel `{`\n      id`:` `match` `self``.`id `{`\n        `Some``(``ref` value`)` `=>` `Clone```::``clone`(`value`)``,`\n        `None` `=>` `{`\n          `return` `Err``(`\n            `Into```::``into`(`\n              ``::```derive_builder`::```UninitializedFieldError`::``from`(```\"`id`\"```)``,`\n            `)``,`\n          `)`\n        `}`\n      `}``,`\n      token`:` `match` `self``.`token `{`\n        `Some``(``ref` value`)` `=>` `Clone```::``clone`(`value`)``,`\n        `None` `=>` `{`\n          `return` `Err``(`\n            `Into```::``into`(`\n              ``::```derive_builder`::```UninitializedFieldError`::``from`(```\"`token`\"```)``,`\n            `)``,`\n          `)`\n        `}`\n      `}``,`\n      special_info`:` `match` `self``.`special_info `{`\n        `Some``(``ref` value`)` `=>` `Clone```::``clone`(`value`)``,`\n        `None` `=>` `{`\n          `return` `Err``(`\n            `Into```::``into`(`\n              ``::```derive_builder`::```UninitializedFieldError`::``from`(```\"`special_info`\"```)``,`\n            `)``,`\n          `)`\n        `}`\n      `}``,`\n    `}``)`\n  `}``\n```}```\n`\n```\n\n_Note: This is edited for readability. The generated code doesn't assume traits such as```Into``` are in-scope, and uses full paths to access them._\n## Get Started\nIt's as simple as three steps:\n  1. Add ``derive_builder`` to your ``Cargo.toml`` either manually or with cargo-edit\u27e811\u27e9:\n\n\n  * ````cargo``` add derive_builder```\n\n\n  1. Add ```use` `derive_builder`::``Builder`;```\n  2. Annotate your struct with ````#``[``derive```(```Builder```)```]````\n\n\n## Usage and Features\n  * **Chaining** : The setter calls can be chained, because they consume and return ```&``mut` `self``` by default.\n  * **Builder patterns** : You can opt into other builder patterns by preceding your struct (or field) with ````#``[``builder```(```pattern `=` ``\"`owned`\"`````)```]```` or ````#``[``builder```(```pattern `=` ``\"`immutable`\"`````)```]````.\n  * **Extensible** : You can still define your own implementations for the builder struct and define additional methods. Just make sure to name them differently than the setter and build methods.\n  * **Documentation and attributes** : Setter methods can be documented by simply documenting the corresponding field. Similarly ````#``[``cfg```(```...```)```]```` and ````#``[``allow```(```...```)```]```` attributes are also applied to the setter methods.\n  * **Hidden fields** : You can skip setters via ````#``[``builder```(`````setter``(```skip```)`````)```]```` on each field individually.\n  * **Setter visibility** : You can opt into private setter by preceding your struct with ````#``[``builder```(```private```)```]````.\n  * **Setter type conversions** : With ````#``[``builder```(`````setter``(```into```)`````)```]````, setter methods will be generic over the input types \u2013 you can then supply every argument that implements the ```Into```\u27e812\u27e9 trait for the field type.\n  * **Setter strip option** : With ````#``[``builder```(`````setter``(```strip_option```)`````)```]````, setter methods will take ``T`` as parameter'type for field of type ````Option``<`T`>````.\n  * **Collection setters** : Adding ````#``[``builder```(`````setter``(````each``(`name `=` ``\"`method_name`\"```)````)`````)```]```` to fields whose types implement ```Default``` and ```Extend``` will generate a setter which adds items to the builder collection for that field. It's possible for these setters to be generic over the ````Into``<`T`>```` trait too, like so: ````#``[``builder```(`````setter``(````each``(`name `=` ``\"`foo`\"```,` into`)````)`````)```]````.\n  * **Builder field visibility** : You can use ````#``[``builder```(`````field``(```private```)`````)```]```` or ```..``(`public`)```, to set field visibility of your builder.\n  * **Generic structs** : Are also supported, but you **must not** use a type parameter named ``VALUE``, if you also activate setter type conversions.\n  * **Default values** : You can use ````#``[``builder```(```default```)```]```` to delegate to the ```Default``` implementation or any explicit value via `` `=` ``\"`..`\"````. This works both on the struct and field level.\n  * **Pre-build validation** : You can use ````#``[``builder```(`````build_fn``(```validate `=` ``\"`path::to::fn`\"`````)`````)```]```` to add your own validation before the target struct is generated.\n  * **Build method suppression** : You can use ````#``[``builder```(`````build_fn``(```skip```)`````)```]```` to disable auto-implementation of the build method and provide your own.\n  * **Custom build method error types** : You can use ````#``[``builder```(`````build_fn``(```error `=` ``\"`path::to::Error`\"`````)`````)```]```` to have your builder return an error type of your choosing. By default, the macro will emit an error type alongside the builder.\n  * **Builder derivations** : You can use ````#``[``builder```(`````derive``(```Trait1`,` Trait2`,` ...```)`````)```]```` to have the builder derive additonal traits. All builders derive ```Default``` and ```Clone```, so you should not declare those in this attribute.\n  * **Pass-through attributes** : Use ````#``[``builder_struct_attr```(```...```)```]````, ````#``[``builder_impl_attr```(```...```)```]````, ````#``[``builder_field_attr```(```...```)```]````, and ````#``[``builder_setter_attr```(```...```)```]```` to declare attributes that will be added to the relevant part of the generated builder.\n  * **no_std support** : Just add ````#``[``builder```(```no_std```)```]```` to your struct, use feature ``alloc``, and add ```extern` `crate` alloc`` to your crate.\n  * **No alloc no_std support** : Do not use ``alloc`` feature and then either add ````#``[``builder```(```no_std`,` ``build_fn``(````error``(`validation_error `=` false`)````)`````)```]```` or ````#``[``builder```(```no_std`,` ``build_fn``(```error `=` ``\"`path::to::Error`\"`````)`````)```]```` to your struct.\n  * **Renaming and re-export support** : Use ````#``[``builder```(```crate `=` ``\"`...`\"`````)```]```` to set the root for ``derive_builder``. This is useful if you want to rename ``derive_builder`` in ``Cargo.toml`` or if your crate is re-exporting ```derive_builder`::``Builder`` and needs the generated code to not directly reference the ``derive_builder`` crate.\n\n\nFor more information and examples please take a look at our documentation\u27e813\u27e9.\n## Gotchas\n  * Tuple structs and unit structs are not supported as they have no field names. We do not intend to support them.\n  * When defining a generic struct, you cannot use ``VALUE`` as a generic parameter as this is what all setters are using.\n\n\n## Documentation\u27e813\u27e9\nDetailed explaination of all features and tips for troubleshooting. You'll also find a discussion of different builder patterns.\n## Changelog\u27e814\u27e9\nYes, we keep a changelog.\n## License\nLicensed under either of\n  * Apache License, Version 2.0, (LICENSE-APACHE\u27e815\u27e9 or <http://www.apache.org/licenses/LICENSE-2.0>)\n  * MIT license (LICENSE-MIT\u27e816\u27e9 or <http://opensource.org/licenses/MIT>)\n\n\nat your option.\n### Contribution\nUnless you explicitly state otherwise, any contribution intentionally submitted for inclusion in the work by you, as defined in the Apache-2.0 license, shall be dual licensed as above, without any additional terms or conditions.\n#### Dependencies\n~0.6\u20131.1MB  ~24K SLoC\n  * derive_builder_macro\u27e817\u27e9 =0.20.2\n\n\n  * dev  rustversion\u27e818\u27e9\n  * dev  serde\u27e819\u27e9+derive\u27e820\u27e9\n  * dev  serde_json\u27e821\u27e9\n  * dev  trybuild\u27e822\u27e9 compiletests\n\n\n#### Other features\u27e823\u27e9\n  * alloc\u27e824\u27e9\n  * clippy\u27e825\u27e9\n  * std\u27e826\u27e9\n\n\n  *[SLoC]: approx. additional lines of code\n",
              "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://lib.rs/crates/derive_builder/versions: 34 releases\n\u27e82\u27e9 https://lib.rs/rust-patterns: Shared solutions for particular situations specific to programming in Rust. - Rust patterns\n\u27e83\u27e9 https://lib.rs/crates/derive_builder/rev: **3,184** crates (964 directly)\n\u27e84\u27e9 https://img.gs/czjpqfbdkz/full/https://github.com/colin-kiegel/rust-derive-builder/workflows/Build/badge.svg: Build\n\u27e85\u27e9 https://img.shields.io/badge/rust-1.56+-blue.svg: ![Rust version\n\u27e86\u27e9 https://img.gs/czjpqfbdkz/full/https://docs.rs/derive_builder/badge.svg: ![Documentation\n\u27e87\u27e9 https://img.shields.io/crates/v/derive_builder.svg: ![Latest version\n\u27e88\u27e9 https://img.shields.io/crates/d/derive_builder.svg: ![All downloads\n\u27e89\u27e9 https://img.shields.io/crates/dv/derive_builder.svg: ![Downloads of latest version\n\u27e810\u27e9 https://www.rust-lang.org/: Rust\n\u27e811\u27e9 https://github.com/killercup/cargo-edit: cargo-edit\n\u27e812\u27e9 https://doc.rust-lang.org/nightly/std/convert/trait.Into.html: ```Into```\n\u27e813\u27e9 https://colin-kiegel.github.io/rust-derive-builder: documentation\n\u27e814\u27e9 https://github.com/colin-kiegel/rust-derive-builder/blob/fc18dd236a6dc6b5b49970efdb1b78f40bb3b998/derive_builder/CHANGELOG.md: Changelog\n\u27e815\u27e9 https://github.com/colin-kiegel/rust-derive-builder/blob/fc18dd236a6dc6b5b49970efdb1b78f40bb3b998/derive_builder/LICENSE-APACHE: LICENSE-APACHE\n\u27e816\u27e9 https://github.com/colin-kiegel/rust-derive-builder/blob/fc18dd236a6dc6b5b49970efdb1b78f40bb3b998/derive_builder/LICENSE-MIT: LICENSE-MIT\n\u27e817\u27e9 https://lib.rs/crates/derive_builder_macro: new - derive_builder_macro\n\u27e818\u27e9 https://lib.rs/crates/rustversion: 1.0.4 - rustversion\n\u27e819\u27e9 https://lib.rs/crates/serde: 1 - serde\n\u27e820\u27e9 https://lib.rs/crates/serde/features#feature-derive: +derive\n\u27e821\u27e9 https://lib.rs/crates/serde_json: 1 - serde_json\n\u27e822\u27e9 https://lib.rs/crates/trybuild: 1.0.38 - trybuild\n\u27e823\u27e9 https://lib.rs/crates/derive_builder/features: Other features\n\u27e824\u27e9 https://lib.rs/crates/derive_builder/features#feature-alloc: alloc\n\u27e825\u27e9 https://lib.rs/crates/derive_builder/features#feature-clippy: clippy\n\u27e826\u27e9 https://lib.rs/crates/derive_builder/features#feature-std: std\n",
              "fit_markdown": "",
              "fit_html": ""
            },
            "structured_data": {},
            "quality_score": 3.0,
            "extraction_method": "crawl4ai",
            "error": null,
            "metadata": {
              "doc_type": "docs",
              "content_length": 12300,
              "has_structured_data": false,
              "crawl_success": true
            },
            "timestamp": "117721.5965173"
          }
        },
        "crate_analysis": {
          "status": "completed",
          "check": [
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#fnv@1.0.7",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\fnv-1.0.7\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "fnv",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\fnv-1.0.7\\lib.rs",
                "edition": "2015",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "default",
                "std"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpsy1832l5\\derive_builder-0.20.2\\target\\debug\\deps\\libfnv-6a2bfe21e1772c80.rlib",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpsy1832l5\\derive_builder-0.20.2\\target\\debug\\deps\\libfnv-6a2bfe21e1772c80.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#ident_case@1.0.1",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\ident_case-1.0.1\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "ident_case",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\ident_case-1.0.1\\src\\lib.rs",
                "edition": "2015",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpsy1832l5\\derive_builder-0.20.2\\target\\debug\\deps\\libident_case-9d205211ae57ff4b.rlib",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpsy1832l5\\derive_builder-0.20.2\\target\\debug\\deps\\libident_case-9d205211ae57ff4b.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#unicode-ident@1.0.5",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\unicode-ident-1.0.5\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "unicode_ident",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\unicode-ident-1.0.5\\src\\lib.rs",
                "edition": "2018",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpsy1832l5\\derive_builder-0.20.2\\target\\debug\\deps\\libunicode_ident-3a2800596284ce2e.rlib",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpsy1832l5\\derive_builder-0.20.2\\target\\debug\\deps\\libunicode_ident-3a2800596284ce2e.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#strsim@0.11.1",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\strsim-0.11.1\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "strsim",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\strsim-0.11.1\\src\\lib.rs",
                "edition": "2015",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpsy1832l5\\derive_builder-0.20.2\\target\\debug\\deps\\libstrsim-6a19fa2c6b00c12a.rlib",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpsy1832l5\\derive_builder-0.20.2\\target\\debug\\deps\\libstrsim-6a19fa2c6b00c12a.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#proc-macro2@1.0.78",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\proc-macro2-1.0.78\\Cargo.toml",
              "target": {
                "kind": [
                  "custom-build"
                ],
                "crate_types": [
                  "bin"
                ],
                "name": "build-script-build",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\proc-macro2-1.0.78\\build.rs",
                "edition": "2021",
                "doc": false,
                "doctest": false,
                "test": false
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "default",
                "proc-macro"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpsy1832l5\\derive_builder-0.20.2\\target\\debug\\build\\proc-macro2-ff4a6618277f6cb8\\build-script-build.exe",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpsy1832l5\\derive_builder-0.20.2\\target\\debug\\build\\proc-macro2-ff4a6618277f6cb8\\build_script_build.pdb"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "build-script-executed",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#proc-macro2@1.0.78",
              "linked_libs": [],
              "linked_paths": [],
              "cfgs": [
                "wrap_proc_macro"
              ],
              "env": [],
              "out_dir": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpsy1832l5\\derive_builder-0.20.2\\target\\debug\\build\\proc-macro2-f94166a2758d4cea\\out"
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#proc-macro2@1.0.78",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\proc-macro2-1.0.78\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "proc_macro2",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\proc-macro2-1.0.78\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "default",
                "proc-macro"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpsy1832l5\\derive_builder-0.20.2\\target\\debug\\deps\\libproc_macro2-cd247ea2804c25aa.rlib",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpsy1832l5\\derive_builder-0.20.2\\target\\debug\\deps\\libproc_macro2-cd247ea2804c25aa.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#quote@1.0.35",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\quote-1.0.35\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "quote",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\quote-1.0.35\\src\\lib.rs",
                "edition": "2018",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "default",
                "proc-macro"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpsy1832l5\\derive_builder-0.20.2\\target\\debug\\deps\\libquote-8167be449c504f92.rlib",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpsy1832l5\\derive_builder-0.20.2\\target\\debug\\deps\\libquote-8167be449c504f92.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#syn@2.0.48",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.48\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "syn",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.48\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "clone-impls",
                "default",
                "derive",
                "extra-traits",
                "full",
                "parsing",
                "printing",
                "proc-macro",
                "quote"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpsy1832l5\\derive_builder-0.20.2\\target\\debug\\deps\\libsyn-c40c9b29390472cb.rlib",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpsy1832l5\\derive_builder-0.20.2\\target\\debug\\deps\\libsyn-c40c9b29390472cb.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#darling_core@0.20.10",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\darling_core-0.20.10\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "darling_core",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\darling_core-0.20.10\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "strsim",
                "suggestions"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpsy1832l5\\derive_builder-0.20.2\\target\\debug\\deps\\libdarling_core-348754d18fb35d1e.rlib",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpsy1832l5\\derive_builder-0.20.2\\target\\debug\\deps\\libdarling_core-348754d18fb35d1e.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#darling_macro@0.20.10",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\darling_macro-0.20.10\\Cargo.toml",
              "target": {
                "kind": [
                  "proc-macro"
                ],
                "crate_types": [
                  "proc-macro"
                ],
                "name": "darling_macro",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\darling_macro-0.20.10\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpsy1832l5\\derive_builder-0.20.2\\target\\debug\\deps\\darling_macro-1f31f3b4f6971d03.dll",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpsy1832l5\\derive_builder-0.20.2\\target\\debug\\deps\\darling_macro-1f31f3b4f6971d03.dll.lib",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpsy1832l5\\derive_builder-0.20.2\\target\\debug\\deps\\darling_macro-1f31f3b4f6971d03.dll.exp",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpsy1832l5\\derive_builder-0.20.2\\target\\debug\\deps\\darling_macro-1f31f3b4f6971d03.pdb"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#darling@0.20.10",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\darling-0.20.10\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "darling",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\darling-0.20.10\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "default",
                "suggestions"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpsy1832l5\\derive_builder-0.20.2\\target\\debug\\deps\\libdarling-3573af2da5665f43.rlib",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpsy1832l5\\derive_builder-0.20.2\\target\\debug\\deps\\libdarling-3573af2da5665f43.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#derive_builder_core@0.20.2",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\derive_builder_core-0.20.2\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "derive_builder_core",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\derive_builder_core-0.20.2\\src\\lib.rs",
                "edition": "2018",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "lib_has_std"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpsy1832l5\\derive_builder-0.20.2\\target\\debug\\deps\\libderive_builder_core-0f523ea1f1d89d55.rlib",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpsy1832l5\\derive_builder-0.20.2\\target\\debug\\deps\\libderive_builder_core-0f523ea1f1d89d55.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#derive_builder_macro@0.20.2",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\derive_builder_macro-0.20.2\\Cargo.toml",
              "target": {
                "kind": [
                  "proc-macro"
                ],
                "crate_types": [
                  "proc-macro"
                ],
                "name": "derive_builder_macro",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\derive_builder_macro-0.20.2\\src\\lib.rs",
                "edition": "2018",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "lib_has_std"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpsy1832l5\\derive_builder-0.20.2\\target\\debug\\deps\\derive_builder_macro-ac0ab7c41f0897fc.dll",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpsy1832l5\\derive_builder-0.20.2\\target\\debug\\deps\\derive_builder_macro-ac0ab7c41f0897fc.dll.lib",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpsy1832l5\\derive_builder-0.20.2\\target\\debug\\deps\\derive_builder_macro-ac0ab7c41f0897fc.dll.exp",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpsy1832l5\\derive_builder-0.20.2\\target\\debug\\deps\\derive_builder_macro-ac0ab7c41f0897fc.pdb"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "compiler-artifact",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpsy1832l5/derive_builder-0.20.2#derive_builder@0.20.2",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpsy1832l5\\derive_builder-0.20.2\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "derive_builder",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpsy1832l5\\derive_builder-0.20.2\\src\\lib.rs",
                "edition": "2018",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "default",
                "std"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpsy1832l5\\derive_builder-0.20.2\\target\\debug\\deps\\libderive_builder-07df40ce6e2d351d.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "build-finished",
              "success": true
            }
          ],
          "clippy": [
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#proc-macro2@1.0.78",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\proc-macro2-1.0.78\\Cargo.toml",
              "target": {
                "kind": [
                  "custom-build"
                ],
                "crate_types": [
                  "bin"
                ],
                "name": "build-script-build",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\proc-macro2-1.0.78\\build.rs",
                "edition": "2021",
                "doc": false,
                "doctest": false,
                "test": false
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "default",
                "proc-macro"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpsy1832l5\\derive_builder-0.20.2\\target\\debug\\build\\proc-macro2-ff4a6618277f6cb8\\build-script-build.exe",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpsy1832l5\\derive_builder-0.20.2\\target\\debug\\build\\proc-macro2-ff4a6618277f6cb8\\build_script_build.pdb"
              ],
              "executable": null,
              "fresh": true
            },
            {
              "reason": "build-script-executed",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#proc-macro2@1.0.78",
              "linked_libs": [],
              "linked_paths": [],
              "cfgs": [
                "wrap_proc_macro"
              ],
              "env": [],
              "out_dir": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpsy1832l5\\derive_builder-0.20.2\\target\\debug\\build\\proc-macro2-f94166a2758d4cea\\out"
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#unicode-ident@1.0.5",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\unicode-ident-1.0.5\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "unicode_ident",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\unicode-ident-1.0.5\\src\\lib.rs",
                "edition": "2018",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpsy1832l5\\derive_builder-0.20.2\\target\\debug\\deps\\libunicode_ident-3a2800596284ce2e.rlib",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpsy1832l5\\derive_builder-0.20.2\\target\\debug\\deps\\libunicode_ident-3a2800596284ce2e.rmeta"
              ],
              "executable": null,
              "fresh": true
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#strsim@0.11.1",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\strsim-0.11.1\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "strsim",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\strsim-0.11.1\\src\\lib.rs",
                "edition": "2015",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpsy1832l5\\derive_builder-0.20.2\\target\\debug\\deps\\libstrsim-6a19fa2c6b00c12a.rlib",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpsy1832l5\\derive_builder-0.20.2\\target\\debug\\deps\\libstrsim-6a19fa2c6b00c12a.rmeta"
              ],
              "executable": null,
              "fresh": true
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#ident_case@1.0.1",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\ident_case-1.0.1\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "ident_case",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\ident_case-1.0.1\\src\\lib.rs",
                "edition": "2015",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpsy1832l5\\derive_builder-0.20.2\\target\\debug\\deps\\libident_case-9d205211ae57ff4b.rlib",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpsy1832l5\\derive_builder-0.20.2\\target\\debug\\deps\\libident_case-9d205211ae57ff4b.rmeta"
              ],
              "executable": null,
              "fresh": true
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#fnv@1.0.7",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\fnv-1.0.7\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "fnv",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\fnv-1.0.7\\lib.rs",
                "edition": "2015",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "default",
                "std"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpsy1832l5\\derive_builder-0.20.2\\target\\debug\\deps\\libfnv-6a2bfe21e1772c80.rlib",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpsy1832l5\\derive_builder-0.20.2\\target\\debug\\deps\\libfnv-6a2bfe21e1772c80.rmeta"
              ],
              "executable": null,
              "fresh": true
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#proc-macro2@1.0.78",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\proc-macro2-1.0.78\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "proc_macro2",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\proc-macro2-1.0.78\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "default",
                "proc-macro"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpsy1832l5\\derive_builder-0.20.2\\target\\debug\\deps\\libproc_macro2-cd247ea2804c25aa.rlib",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpsy1832l5\\derive_builder-0.20.2\\target\\debug\\deps\\libproc_macro2-cd247ea2804c25aa.rmeta"
              ],
              "executable": null,
              "fresh": true
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#quote@1.0.35",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\quote-1.0.35\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "quote",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\quote-1.0.35\\src\\lib.rs",
                "edition": "2018",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "default",
                "proc-macro"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpsy1832l5\\derive_builder-0.20.2\\target\\debug\\deps\\libquote-8167be449c504f92.rlib",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpsy1832l5\\derive_builder-0.20.2\\target\\debug\\deps\\libquote-8167be449c504f92.rmeta"
              ],
              "executable": null,
              "fresh": true
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#syn@2.0.48",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.48\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "syn",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.48\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "clone-impls",
                "default",
                "derive",
                "extra-traits",
                "full",
                "parsing",
                "printing",
                "proc-macro",
                "quote"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpsy1832l5\\derive_builder-0.20.2\\target\\debug\\deps\\libsyn-c40c9b29390472cb.rlib",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpsy1832l5\\derive_builder-0.20.2\\target\\debug\\deps\\libsyn-c40c9b29390472cb.rmeta"
              ],
              "executable": null,
              "fresh": true
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#darling_core@0.20.10",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\darling_core-0.20.10\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "darling_core",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\darling_core-0.20.10\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "strsim",
                "suggestions"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpsy1832l5\\derive_builder-0.20.2\\target\\debug\\deps\\libdarling_core-348754d18fb35d1e.rlib",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpsy1832l5\\derive_builder-0.20.2\\target\\debug\\deps\\libdarling_core-348754d18fb35d1e.rmeta"
              ],
              "executable": null,
              "fresh": true
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#darling_macro@0.20.10",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\darling_macro-0.20.10\\Cargo.toml",
              "target": {
                "kind": [
                  "proc-macro"
                ],
                "crate_types": [
                  "proc-macro"
                ],
                "name": "darling_macro",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\darling_macro-0.20.10\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpsy1832l5\\derive_builder-0.20.2\\target\\debug\\deps\\darling_macro-1f31f3b4f6971d03.dll",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpsy1832l5\\derive_builder-0.20.2\\target\\debug\\deps\\darling_macro-1f31f3b4f6971d03.dll.lib",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpsy1832l5\\derive_builder-0.20.2\\target\\debug\\deps\\darling_macro-1f31f3b4f6971d03.dll.exp",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpsy1832l5\\derive_builder-0.20.2\\target\\debug\\deps\\darling_macro-1f31f3b4f6971d03.pdb"
              ],
              "executable": null,
              "fresh": true
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#darling@0.20.10",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\darling-0.20.10\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "darling",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\darling-0.20.10\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "default",
                "suggestions"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpsy1832l5\\derive_builder-0.20.2\\target\\debug\\deps\\libdarling-3573af2da5665f43.rlib",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpsy1832l5\\derive_builder-0.20.2\\target\\debug\\deps\\libdarling-3573af2da5665f43.rmeta"
              ],
              "executable": null,
              "fresh": true
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#derive_builder_core@0.20.2",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\derive_builder_core-0.20.2\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "derive_builder_core",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\derive_builder_core-0.20.2\\src\\lib.rs",
                "edition": "2018",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "lib_has_std"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpsy1832l5\\derive_builder-0.20.2\\target\\debug\\deps\\libderive_builder_core-0f523ea1f1d89d55.rlib",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpsy1832l5\\derive_builder-0.20.2\\target\\debug\\deps\\libderive_builder_core-0f523ea1f1d89d55.rmeta"
              ],
              "executable": null,
              "fresh": true
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#derive_builder_macro@0.20.2",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\derive_builder_macro-0.20.2\\Cargo.toml",
              "target": {
                "kind": [
                  "proc-macro"
                ],
                "crate_types": [
                  "proc-macro"
                ],
                "name": "derive_builder_macro",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\derive_builder_macro-0.20.2\\src\\lib.rs",
                "edition": "2018",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "lib_has_std"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpsy1832l5\\derive_builder-0.20.2\\target\\debug\\deps\\derive_builder_macro-ac0ab7c41f0897fc.dll",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpsy1832l5\\derive_builder-0.20.2\\target\\debug\\deps\\derive_builder_macro-ac0ab7c41f0897fc.dll.lib",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpsy1832l5\\derive_builder-0.20.2\\target\\debug\\deps\\derive_builder_macro-ac0ab7c41f0897fc.dll.exp",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpsy1832l5\\derive_builder-0.20.2\\target\\debug\\deps\\derive_builder_macro-ac0ab7c41f0897fc.pdb"
              ],
              "executable": null,
              "fresh": true
            },
            {
              "reason": "compiler-artifact",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpsy1832l5/derive_builder-0.20.2#derive_builder@0.20.2",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpsy1832l5\\derive_builder-0.20.2\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "derive_builder",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpsy1832l5\\derive_builder-0.20.2\\src\\lib.rs",
                "edition": "2018",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "default",
                "std"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpsy1832l5\\derive_builder-0.20.2\\target\\debug\\deps\\libderive_builder-d27da4a8a1727de5.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "build-finished",
              "success": true
            }
          ],
          "audit": {
            "database": {
              "advisory-count": 787,
              "last-commit": "7573f55ba337263f61167dbb0ea926cdc7c8eb5d",
              "last-updated": "2025-06-17T11:04:25+02:00"
            },
            "lockfile": {
              "dependency-count": 29
            },
            "settings": {
              "target_arch": [],
              "target_os": [],
              "severity": null,
              "ignore": [],
              "informational_warnings": [
                "unmaintained",
                "unsound",
                "notice"
              ]
            },
            "vulnerabilities": {
              "found": false,
              "count": 0,
              "list": []
            },
            "warnings": {}
          },
          "note": "Crate analysis performed with stable toolchain."
        },
        "crate_metadata": {
          "name": "derive_builder",
          "version": "0.20.2",
          "description": "ALLOW: Positive community sentiment",
          "repository": "",
          "keywords": [],
          "categories": [],
          "readme": {
            "raw_markdown": "[](https://docs.rs/derive_builder/latest/derive_builder/all.html \"show sidebar\")\n# Crate derive_builderCopy item path\n[Settings](https://docs.rs/derive_builder/latest/settings.html)\n[Help](https://docs.rs/derive_builder/latest/help.html)\nSummary[Source](https://docs.rs/derive_builder/latest/src/derive_builder/lib.rs.html#1-717)\nExpand description\nDerive a builder for a struct\nThis crate implements the [builder pattern](https://web.archive.org/web/20170701044756/https://aturon.github.io/ownership/builders.html) for you. Just apply `#[derive(Builder)]` to a struct `Foo`, and it will derive an additional struct `FooBuilder` with **setter** -methods for all fields and a **build** -method \u2014 the way you want it.\n## [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#quick-start)Quick Start\nAdd `derive_builder` as a dependency to you `Cargo.toml`.\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#what-you-write)What you write\n```\nuse derive_builder::Builder;\n#[derive(Builder)]\nstruct Lorem {\n  ipsum: u32,\n  // ..\n}\n```\n\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#what-you-get)What you get\n```\n#[derive(Clone, Default)]\nstruct LoremBuilder {\n  ipsum: Option<u32>,\n}\n#[allow(dead_code)]\nimpl LoremBuilder {\n  pub fn ipsum(&mut self, value: u32) -> &mut Self {\n    let mut new = self;\n    new.ipsum = Some(value);\n    new\n  }\n  fn build(&self) -> Result<Lorem, LoremBuilderError> {\n    Ok(Lorem {\n      ipsum: Clone::clone(self.ipsum\n        .as_ref()\n        .ok_or(LoremBuilderError::from(UninitializedFieldError::new(\"ipsum\")))?),\n    })\n  }\n}\n```\n\nBy default all generated setter-methods take and return `&mut self` (aka _non-consuming_ builder pattern). Accordingly, the build method also takes a reference by default.\nYou can easily opt into different patterns and control many other aspects.\nThe build method returns `Result<T, E>`, where `T` is the struct you started with and E is a generated builder error type. It returns `Err` if you didn\u2019t initialize all fields and no default values were provided.\n## [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#builder-patterns)Builder Patterns\nLet\u2019s look again at the example above. You can now build structs like this:\n```\nlet x: Lorem = LoremBuilder::default().ipsum(42).build()?;\n```\n\nOk, _chaining_ method calls is nice, but what if `ipsum(42)` should only happen if `geek = true`?\nSo let\u2019s make this call conditional\n```\nlet mut builder = LoremBuilder::default();\nif geek {\n  builder.ipsum(42);\n}\nlet x: Lorem = builder.build()?;\n```\n\nNow it comes in handy that our setter methods take and return mutable references. Otherwise we would need to write something more clumsy like `builder = builder.ipsum(42)` to reassign the return value each time we have to call a setter conditionally.\nSetters with mutable references are therefore a convenient default for the builder pattern in Rust.\nBut this is a free world and the choice is still yours!\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#owned-aka-consuming)Owned, aka Consuming\nPrecede your struct (or field) with `#[builder(pattern = \"owned\")]` to opt into this pattern. Builders generated with this pattern do not automatically derive `Clone`, which allows builders to be generated for structs with fields that do not derive `Clone`.\n  * Setters take and return `self`.\n  * PRO: Setter calls and final build method can be chained.\n  * CON: If you don\u2019t chain your calls, you have to create a reference to each return value, e.g. `builder = builder.ipsum(42)`.\n\n\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#mutable-aka-non-consuming-recommended)Mutable, aka Non-Consuming (recommended)\nThis pattern is recommended and active by default if you don\u2019t specify anything else. You can precede your struct (or field) with `#[builder(pattern = \"mutable\")]` to make this choice explicit.\n  * Setters take and return `&mut self`.\n  * PRO: Setter calls and final build method can be chained.\n  * CON: The build method must clone or copy data to create something owned out of a mutable reference. Otherwise it could not be used in a chain. **(*)**\n\n\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#immutable)Immutable\nPrecede your struct (or field) with `#[builder(pattern = \"immutable\")]` to opt into this pattern.\n  * Setters take and return `&self`.\n  * PRO: Setter calls and final build method can be chained.\n  * CON: If you don\u2019t chain your calls, you have to create a reference to each return value, e.g. `builder = builder.ipsum(42)`.\n  * CON: The build method _and each setter_ must clone or copy data to create something owned out of a reference. **(*)**\n\n\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#-performance-considerations)(*) Performance Considerations\nLuckily Rust is clever enough to optimize these clone-calls away in release builds for your every-day use cases. Thats quite a safe bet - we checked this for you. ;-) Switching to consuming signatures (=`self`) is unlikely to give you any performance gain, but very likely to restrict your API for non-chained use cases.\n## [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#more-features)More Features\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#hidden-fields)Hidden Fields\nYou can hide fields by skipping their setters on (and presence in) the builder struct.\n  * Opt-out \u2014 skip setters via `#[builder(setter(skip))]` on individual fields.\n  * Opt-in \u2014 set `#[builder(setter(skip))]` on the whole struct and enable individual setters via `#[builder(setter)]`.\n\n\nThe types of skipped fields must implement `Default`.\n```\n#[derive(Builder)]\nstruct HiddenField {\n  setter_present: u32,\n  #[builder(setter(skip))]\n  setter_skipped: u32,\n}\n```\n\nAlternatively, you can use the more verbose form:\n  * `#[builder(setter(skip = true))]`\n  * `#[builder(setter(skip = false))]`\n\n\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#custom-setters-skip-autogenerated-setters)Custom setters (skip autogenerated setters)\nSimilarly to `setter(skip)`, you can say that you will provide your own setter methods. This simply suppresses the generation of the setter, leaving the field in the builder, as `Option<T>`.\n```\n#[derive(Builder)]\nstruct SetterOptOut {\n  #[builder(setter(custom))]\n  custom_setter: u32,\n}\nimpl SetterOptOutBuilder {\n  fn custom_setter(&mut self, value: u32) {\n    self.custom_setter = Some(value);\n  }\n}\n```\n\nAgain, the more verbose form is accepted:\n  * `#[builder(setter(custom = true))]`\n  * `#[builder(setter(custom = false))]`\n\n\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#setter-visibility)Setter Visibility\nSetters are public by default. You can precede your struct (or field) with `#[builder(public)]` to make this explicit.\nOtherwise precede your struct (or field) with `#[builder(private)]` to opt into private setters.\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#generated-builder-struct-name)Generated builder struct name\nBy default, the builder struct for `struct Foo` is `FooBuilder`. You can override this:\n```\n#[derive(Builder)]\n#[builder(name = \"FooConstructor\")]\nstruct Foo { }\nlet foo: Foo = FooConstructor::default().build()?;\n```\n\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#setter-nameprefix)Setter Name/Prefix\nSetter methods are named after their corresponding field by default.\n  * You can customize the setter name via `#[builder(setter(name = \"foo\"))`.\n  * Alternatively you can set a prefix via `#[builder(setter(prefix = \"xyz\"))`, which will change the method name to `xyz_foo` if the field is named `foo`. Note that an underscore is inserted, since Rust favors snake case here.\n\n\nPrefixes can also be defined on the struct level, but renames only work on fields. Renames take precedence over prefix definitions.\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#generic-setters)Generic Setters\nYou can make each setter generic over the `Into`-trait. It\u2019s as simple as adding `#[builder(setter(into))]` to either a field or the whole struct.\n```\n#[derive(Builder, Debug, PartialEq)]\nstruct Lorem {\n  #[builder(setter(into))]\n  pub ipsum: String,\n}\nfn main() {\n  // `\"foo\"` will be converted into a `String` automatically.\n  let x = LoremBuilder::default().ipsum(\"foo\").build().unwrap();\n  assert_eq!(x, Lorem {\n    ipsum: \"foo\".to_string(),\n  });\n}\n```\n\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#setters-for-option)Setters for Option\nYou can avoid wrapping values in `Some(...)` for fields of type `Option<T>`. It\u2019s as simple as adding `#[builder(setter(strip_option))]` to either a single field or the whole struct.\n```\n#[derive(Builder, Debug, PartialEq)]\nstruct Lorem {\n  #[builder(setter(into, strip_option))]\n  pub ipsum: Option<String>,\n  #[builder(setter(into, strip_option), default)]\n  pub foo: Option<String>,\n}\nfn main() {\n  // `\"foo\"` will be converted into a `String` automatically.\n  let x = LoremBuilder::default().ipsum(\"foo\").build().unwrap();\n  assert_eq!(x, Lorem {\n    ipsum: Some(\"foo\".to_string()),\n    foo: None\n  });\n}\n```\n\nIf you want to set the value to None when unset, then enable `default` on this field (or do not use `strip_option`).\nLimitation: only the `Option` type name is supported, not type alias nor `std::option::Option`.\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#fallible-setters)Fallible Setters\nAlongside the normal setter methods, you can expose fallible setters which are generic over the `TryInto` trait. TryInto is similar to `Into` with the key distinction that the conversion can fail, and therefore produces a `Result`.\nYou can only declare the `try_setter` attribute today if you\u2019re targeting nightly, and you have to add `#![feature(try_from)]` to your crate to use it.\n```\n#[derive(Builder, Debug, PartialEq)]\n#[builder(try_setter, setter(into))]\nstruct Lorem {\n  pub name: String,\n  pub ipsum: u8,\n}\n#[derive(Builder, Debug, PartialEq)]\nstruct Ipsum {\n  #[builder(try_setter, setter(into, name = \"foo\"))]\n  pub dolor: u8,\n}\nfn main() {\n  LoremBuilder::default()\n    .try_ipsum(1u16).unwrap()\n    .name(\"hello\")\n    .build()\n    .expect(\"1 fits into a u8\");\n  IpsumBuilder::default()\n    .try_foo(1u16).unwrap()\n    .build()\n    .expect(\"1 fits into a u8\");\n}\n```\n\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#default-values)Default Values\nYou can define default values for each field via annotation by `#[builder(default = \"...\")]`, where `...` stands for any Rust expression and must be string-escaped, e.g.\n  * `#[builder(default = \"42\")]`\n  * `#[builder(default)]` delegates to the [`Default`](https://doc.rust-lang.org/std/default/trait.Default.html) trait of the base type.\n\n\nThe expression will be evaluated with each call to `build`.\n```\n#[derive(Builder, Debug, PartialEq)]\nstruct Lorem {\n  #[builder(default = \"42\")]\n  pub ipsum: u32,\n}\nfn main() {\n  // If we don't set the field `ipsum`,\n  let x = LoremBuilder::default().build().unwrap();\n  // .. the custom default will be used for `ipsum`:\n  assert_eq!(x, Lorem {\n    ipsum: 42,\n  });\n}\n```\n\n#### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#tips-on-defaults)Tips on Defaults\n  * The `#[builder(default)]` annotation can be used on the struct level, too. Overrides are still possible.\n  * Delegate to a private helper method on `FooBuilder` for anything fancy. This way you will get _much better error diagnostics_ from the rust compiler and it will be _much more readable_ for other human beings. :-)\n  * Defaults will not work while using `#[builder(build_fn(skip))]`. In this case, you\u2019ll need to handle default values yourself when converting from the builder, such as by using `.unwrap_or()` and `.unwrap_or_else()`.\n\n\n```\nstruct Lorem {\n  ipsum: String,\n  // Custom defaults can delegate to helper methods\n  // and pass errors to the enclosing `build()` method via `?`.\n  #[builder(default = \"self.default_dolor()?\")]\n  dolor: String,\n}\nimpl LoremBuilder {\n  // Private helper method with access to the builder struct.\n  fn default_dolor(&self) -> Result<String, String> {\n    match self.ipsum {\n      Some(ref x) if x.chars().count() > 3 => Ok(format!(\"dolor {}\", x)),\n      _ => Err(\"ipsum must at least 3 chars to build dolor\".to_string()),\n    }\n  }\n}\n\n```\n\nYou can even reference other fields, but you have to remember that the builder struct will wrap every type in an Option ([as illustrated earlier](https://docs.rs/derive_builder/latest/derive_builder/#what-you-get)).\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#generic-structs)Generic Structs\n```\n#[derive(Builder, Debug, PartialEq, Default, Clone)]\nstruct GenLorem<T: Clone> {\n  ipsum: &'static str,\n  dolor: T,\n}\nfn main() {\n  let x = GenLoremBuilder::default().ipsum(\"sit\").dolor(42).build().unwrap();\n  assert_eq!(x, GenLorem { ipsum: \"sit\".into(), dolor: 42 });\n}\n```\n\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#build-method-customization)Build Method Customization\nYou can rename or suppress the auto-generated build method, leaving you free to implement your own version. Suppression is done using `#[builder(build_fn(skip))]` at the struct level, and renaming is done with `#[builder(build_fn(name = \"YOUR_NAME\"))]`.\nAdditionally if you want to make the build method private you can apply `#[builder(build_fn(private))]`.\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#pre-build-validation)Pre-Build Validation\nIf you\u2019re using the provided `build` method, you can declare `#[builder(build_fn(validate = \"path::to::fn\"))]` to specify a validator function which gets access to the builder before construction. The path does not need to be fully-qualified, and will consider `use` statements made at module level. It must be accessible from the scope where the target struct is declared.\nThe provided function must have the signature `(&FooBuilder) -> Result<_, String>`; the `Ok` variant is not used by the `build` method.\n```\n#[derive(Builder, Debug, PartialEq)]\n#[builder(build_fn(validate = \"Self::validate\"))]\nstruct Lorem {\n  pub ipsum: u8,\n}\nimpl LoremBuilder {\n  /// Check that `Lorem` is putting in the right amount of effort.\n  fn validate(&self) -> Result<(), String> {\n    if let Some(ref ipsum) = self.ipsum {\n      match *ipsum {\n        i if i < 20 => Err(\"Try harder\".to_string()),\n        i if i > 100 => Err(\"You'll tire yourself out\".to_string()),\n        _ => Ok(())\n      }\n    } else {\n      Ok(())\n    }\n  }\n}\nfn main() {\n  // If we're trying too hard...\n  let x = LoremBuilder::default().ipsum(120).build().unwrap_err();\n  // .. the build will fail:\n  assert_eq!(&x.to_string(), \"You'll tire yourself out\");\n}\n```\n\nNote:\n  * Default values are applied _after_ validation, and will therefore not be validated!\n\n\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#additional-trait-derivations)Additional Trait Derivations\nYou can derive additional traits on the builder, including traits defined by other crates:\n```\n#[derive(Builder, Clone)]\n#[builder(derive(Debug, PartialEq, Eq))]\npub struct Lorem {\n  foo: u8,\n  bar: String,\n}\nfn main() {\n  assert_eq!(LoremBuilder::default(), LoremBuilder::default());\n}\n```\n\nAttributes declared for those traits are _not_ forwarded to the fields on the builder.\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#documentation-comments-and-attributes)Documentation Comments and Attributes\n`#[derive(Builder)]` copies doc comments and attributes (`#[...]`) from your fields to the according builder fields and setter-methods, if it is one of the following:\n  * `/// ...`\n  * `#[doc = ...]`\n  * `#[cfg(...)]`\n  * `#[allow(...)]`\n\n\nThe whitelisting minimizes interference with other custom attributes like those used by Serde, Diesel, or others.\n```\n#[derive(Builder)]\nstruct Lorem {\n  /// `ipsum` may be any `String` (be creative).\n  ipsum: String,\n  #[doc = r\"`dolor` is the estimated amount of work.\"]\n  dolor: i32,\n  // `#[derive(Builder)]` understands conditional compilation via cfg-attributes,\n  // i.e. => \"no field = no setter\".\n  #[cfg(target_os = \"macos\")]\n  #[allow(non_snake_case)]\n  Im_a_Mac: bool,\n}\n```\n\n#### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#pass-through-attributes)Pass-through Attributes\nYou can set attributes on elements of the builder using the `builder_*_attr` attributes:\n  * `builder_struct_attr` adds attributes after `#[derive(...)]` on the builder struct.\n  * `builder_impl_attr` adds attributes on the `impl` block\n  * `builder_field_attr` adds attributes to field declarations in the builder struct.\n  * `builder_setter_attr` adds attributes to the setter in the `impl` block.\n\n\n```\n#[derive(Builder)]\n#[builder(derive(serde::Serialize))]\n#[builder_struct_attr(serde(rename_all = \"camelCase\"))]\nstruct Lorem {\n  #[builder_field_attr(serde(rename=\"dolor\"))]\n  ipsum: String,\n}\nlet mut show = LoremBuilder::default();\nshow.ipsum(\"sit\".into());\nassert_eq!(serde_json::to_string(&show).unwrap(), r#\"{\"dolor\":\"sit\"}\"#);\n```\n\n## [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#error-return-type-from-autogenerated-build-function)Error return type from autogenerated `build` function\nBy default, `build` returns an autogenerated error type:\n```\n#[doc=\"Error type for LoremBuilder\"]\n#[derive(Debug)]\n#[non_exhaustive]\npub enum LoremBuilderError { // where `LoremBuilder` is the name of the builder struct\n  /// Uninitialized field\n  UninitializedField(&'static str),\n  /// Custom validation error\n  ValidationError(String),\n}\nimpl From<String> for LoremBuilderError {\n  fn from(s: String) -> Self { Self::ValidationError(s) }\n}\nimpl From<UninitializedFieldError> for LoremBuilderError { // ...\nimpl Display for LoremBuilderError { // ...\nimpl std::error::Error for LoremBuilderError {}\n```\n\nAlternatively, you can specify your own error type:\n```\n#[derive(Builder, Debug, PartialEq)]\n#[builder(build_fn(error = \"OurLoremError\"))]\nstruct Lorem {\n  pub ipsum: u32,\n}\nstruct OurLoremError(String);\nimpl From<UninitializedFieldError> for OurLoremError {\n  fn from(ufe: UninitializedFieldError) -> OurLoremError { OurLoremError(ufe.to_string()) }\n}\nlet err: OurLoremError = LoremBuilder::default().build().unwrap_err();\nassert_eq!(&err.0, \"Field not initialized: ipsum\");\n```\n\n## [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#completely-custom-fields-in-the-builder)Completely custom fields in the builder\nInstead of having an `Option`, you can have whatever type you like:\n```\n#[derive(Debug, PartialEq, Default, Builder, Clone)]\n#[builder(derive(Debug, PartialEq))]\nstruct Lorem {\n  #[builder(setter(into), field(ty = \"u32\"))]\n  ipsum: u32,\n  #[builder(field(ty = \"String\", build = \"()\"))]\n  dolor: (),\n  #[builder(field(ty = \"&'static str\", build = \"self.amet.parse()?\"))]\n  amet: u32,\n}\nimpl From<std::num::ParseIntError> for LoremBuilderError { // ...\nlet mut builder = LoremBuilder::default();\nbuilder.ipsum(42u16).dolor(\"sit\".into()).amet(\"12\");\nassert_eq!(builder, LoremBuilder { ipsum: 42, dolor: \"sit\".into(), amet: \"12\" });\nlet lorem = builder.build().unwrap();\nassert_eq!(lorem, Lorem { ipsum: 42, dolor: (), amet: 12 });\n```\n\nThe builder field type (`ty =`) must implement `Default`.\nThe argument to `build` must be a literal string containing Rust code for the contents of a block, which must evaluate to the type of the target field. It may refer to the builder struct as `self`, use `?`, etc.\n## [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#no_std-support-on-nightly)**`#![no_std]`**Support (on Nightly)\nYou can activate support for `#![no_std]` by adding `#[builder(no_std)]` to your struct and `#![feature(alloc)] extern crate alloc` to your crate.\nThe latter requires the _nightly_ toolchain.\n## [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#troubleshooting)Troubleshooting\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#gotchas)Gotchas\n  * Tuple structs and unit structs are not supported as they have no field names.\n  * Generic setters introduce a type parameter `VALUE: Into<_>`. Therefore you can\u2019t use `VALUE` as a type parameter on a generic struct in combination with generic setters.\n  * The `try_setter` attribute and `owned` builder pattern are not compatible in practice; an error during building will consume the builder, making it impossible to continue construction.\n  * When re-exporting the underlying struct under a different name, the auto-generated documentation will not match.\n  * If derive_builder depends on your crate, and vice versa, then a cyclic dependency would occur. To break it you could try to depend on the [`derive_builder_core`](https://crates.io/crates/derive_builder_core) crate instead.\n\n\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#report-issues-and-ideas)Report Issues and Ideas\n[Open an issue on GitHub](https://github.com/colin-kiegel/rust-derive-builder/issues)\nIf possible please try to provide the debugging info if you experience unexpected compilation errors (see above).\n## Structs[\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#structs)\n\n[UninitializedFieldError](https://docs.rs/derive_builder/latest/derive_builder/struct.UninitializedFieldError.html \"struct derive_builder::UninitializedFieldError\")\n    Runtime error when a `build()` method is called and one or more required fields do not have a value.\n## Derive Macros[\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#derives)\n\n[Builder](https://docs.rs/derive_builder/latest/derive_builder/derive.Builder.html \"derive derive_builder::Builder\")\n    Create a builder struct for the deriving struct.\n",
            "markdown_with_citations": "[](https://docs.rs/derive_builder/latest/derive_builder/all.html \"show sidebar\")\n# Crate derive_builderCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nDerive a builder for a struct\nThis crate implements the builder pattern\u27e84\u27e9 for you. Just apply `#[derive(Builder)]` to a struct `Foo`, and it will derive an additional struct `FooBuilder` with **setter** -methods for all fields and a **build** -method \u2014 the way you want it.\n## \u00a7\u27e85\u27e9Quick Start\nAdd `derive_builder` as a dependency to you `Cargo.toml`.\n### \u00a7\u27e86\u27e9What you write\n```\nuse derive_builder::Builder;\n#[derive(Builder)]\nstruct Lorem {\n  ipsum: u32,\n  // ..\n}\n```\n\n### \u00a7\u27e87\u27e9What you get\n```\n#[derive(Clone, Default)]\nstruct LoremBuilder {\n  ipsum: Option<u32>,\n}\n#[allow(dead_code)]\nimpl LoremBuilder {\n  pub fn ipsum(&mut self, value: u32) -> &mut Self {\n    let mut new = self;\n    new.ipsum = Some(value);\n    new\n  }\n  fn build(&self) -> Result<Lorem, LoremBuilderError> {\n    Ok(Lorem {\n      ipsum: Clone::clone(self.ipsum\n        .as_ref()\n        .ok_or(LoremBuilderError::from(UninitializedFieldError::new(\"ipsum\")))?),\n    })\n  }\n}\n```\n\nBy default all generated setter-methods take and return `&mut self` (aka _non-consuming_ builder pattern). Accordingly, the build method also takes a reference by default.\nYou can easily opt into different patterns and control many other aspects.\nThe build method returns `Result<T, E>`, where `T` is the struct you started with and E is a generated builder error type. It returns `Err` if you didn\u2019t initialize all fields and no default values were provided.\n## \u00a7\u27e88\u27e9Builder Patterns\nLet\u2019s look again at the example above. You can now build structs like this:\n```\nlet x: Lorem = LoremBuilder::default().ipsum(42).build()?;\n```\n\nOk, _chaining_ method calls is nice, but what if `ipsum(42)` should only happen if `geek = true`?\nSo let\u2019s make this call conditional\n```\nlet mut builder = LoremBuilder::default();\nif geek {\n  builder.ipsum(42);\n}\nlet x: Lorem = builder.build()?;\n```\n\nNow it comes in handy that our setter methods take and return mutable references. Otherwise we would need to write something more clumsy like `builder = builder.ipsum(42)` to reassign the return value each time we have to call a setter conditionally.\nSetters with mutable references are therefore a convenient default for the builder pattern in Rust.\nBut this is a free world and the choice is still yours!\n### \u00a7\u27e89\u27e9Owned, aka Consuming\nPrecede your struct (or field) with `#[builder(pattern = \"owned\")]` to opt into this pattern. Builders generated with this pattern do not automatically derive `Clone`, which allows builders to be generated for structs with fields that do not derive `Clone`.\n  * Setters take and return `self`.\n  * PRO: Setter calls and final build method can be chained.\n  * CON: If you don\u2019t chain your calls, you have to create a reference to each return value, e.g. `builder = builder.ipsum(42)`.\n\n\n### \u00a7\u27e810\u27e9Mutable, aka Non-Consuming (recommended)\nThis pattern is recommended and active by default if you don\u2019t specify anything else. You can precede your struct (or field) with `#[builder(pattern = \"mutable\")]` to make this choice explicit.\n  * Setters take and return `&mut self`.\n  * PRO: Setter calls and final build method can be chained.\n  * CON: The build method must clone or copy data to create something owned out of a mutable reference. Otherwise it could not be used in a chain. **(*)**\n\n\n### \u00a7\u27e811\u27e9Immutable\nPrecede your struct (or field) with `#[builder(pattern = \"immutable\")]` to opt into this pattern.\n  * Setters take and return `&self`.\n  * PRO: Setter calls and final build method can be chained.\n  * CON: If you don\u2019t chain your calls, you have to create a reference to each return value, e.g. `builder = builder.ipsum(42)`.\n  * CON: The build method _and each setter_ must clone or copy data to create something owned out of a reference. **(*)**\n\n\n### \u00a7\u27e812\u27e9(*) Performance Considerations\nLuckily Rust is clever enough to optimize these clone-calls away in release builds for your every-day use cases. Thats quite a safe bet - we checked this for you. ;-) Switching to consuming signatures (=`self`) is unlikely to give you any performance gain, but very likely to restrict your API for non-chained use cases.\n## \u00a7\u27e813\u27e9More Features\n### \u00a7\u27e814\u27e9Hidden Fields\nYou can hide fields by skipping their setters on (and presence in) the builder struct.\n  * Opt-out \u2014 skip setters via `#[builder(setter(skip))]` on individual fields.\n  * Opt-in \u2014 set `#[builder(setter(skip))]` on the whole struct and enable individual setters via `#[builder(setter)]`.\n\n\nThe types of skipped fields must implement `Default`.\n```\n#[derive(Builder)]\nstruct HiddenField {\n  setter_present: u32,\n  #[builder(setter(skip))]\n  setter_skipped: u32,\n}\n```\n\nAlternatively, you can use the more verbose form:\n  * `#[builder(setter(skip = true))]`\n  * `#[builder(setter(skip = false))]`\n\n\n### \u00a7\u27e815\u27e9Custom setters (skip autogenerated setters)\nSimilarly to `setter(skip)`, you can say that you will provide your own setter methods. This simply suppresses the generation of the setter, leaving the field in the builder, as `Option<T>`.\n```\n#[derive(Builder)]\nstruct SetterOptOut {\n  #[builder(setter(custom))]\n  custom_setter: u32,\n}\nimpl SetterOptOutBuilder {\n  fn custom_setter(&mut self, value: u32) {\n    self.custom_setter = Some(value);\n  }\n}\n```\n\nAgain, the more verbose form is accepted:\n  * `#[builder(setter(custom = true))]`\n  * `#[builder(setter(custom = false))]`\n\n\n### \u00a7\u27e816\u27e9Setter Visibility\nSetters are public by default. You can precede your struct (or field) with `#[builder(public)]` to make this explicit.\nOtherwise precede your struct (or field) with `#[builder(private)]` to opt into private setters.\n### \u00a7\u27e817\u27e9Generated builder struct name\nBy default, the builder struct for `struct Foo` is `FooBuilder`. You can override this:\n```\n#[derive(Builder)]\n#[builder(name = \"FooConstructor\")]\nstruct Foo { }\nlet foo: Foo = FooConstructor::default().build()?;\n```\n\n### \u00a7\u27e818\u27e9Setter Name/Prefix\nSetter methods are named after their corresponding field by default.\n  * You can customize the setter name via `#builder(setter(name = \"foo\"))`.\n  * Alternatively you can set a prefix via `#[builder(setter(prefix = \"xyz\"))`, which will change the method name to `xyz_foo` if the field is named `foo`. Note that an underscore is inserted, since Rust favors snake case here.\n\n\nPrefixes can also be defined on the struct level, but renames only work on fields. Renames take precedence over prefix definitions.\n### [\u00a7\u27e819\u27e9Generic Setters\nYou can make each setter generic over the `Into`-trait. It\u2019s as simple as adding `#[builder(setter(into))]` to either a field or the whole struct.\n```\n#[derive(Builder, Debug, PartialEq)]\nstruct Lorem {\n  #[builder(setter(into))]\n  pub ipsum: String,\n}\nfn main() {\n  // `\"foo\"` will be converted into a `String` automatically.\n  let x = LoremBuilder::default().ipsum(\"foo\").build().unwrap();\n  assert_eq!(x, Lorem {\n    ipsum: \"foo\".to_string(),\n  });\n}\n```\n\n### \u00a7\u27e820\u27e9Setters for Option\nYou can avoid wrapping values in `Some(...)` for fields of type `Option<T>`. It\u2019s as simple as adding `#[builder(setter(strip_option))]` to either a single field or the whole struct.\n```\n#[derive(Builder, Debug, PartialEq)]\nstruct Lorem {\n  #[builder(setter(into, strip_option))]\n  pub ipsum: Option<String>,\n  #[builder(setter(into, strip_option), default)]\n  pub foo: Option<String>,\n}\nfn main() {\n  // `\"foo\"` will be converted into a `String` automatically.\n  let x = LoremBuilder::default().ipsum(\"foo\").build().unwrap();\n  assert_eq!(x, Lorem {\n    ipsum: Some(\"foo\".to_string()),\n    foo: None\n  });\n}\n```\n\nIf you want to set the value to None when unset, then enable `default` on this field (or do not use `strip_option`).\nLimitation: only the `Option` type name is supported, not type alias nor `std::option::Option`.\n### \u00a7\u27e821\u27e9Fallible Setters\nAlongside the normal setter methods, you can expose fallible setters which are generic over the `TryInto` trait. TryInto is similar to `Into` with the key distinction that the conversion can fail, and therefore produces a `Result`.\nYou can only declare the `try_setter` attribute today if you\u2019re targeting nightly, and you have to add `#![feature(try_from)]` to your crate to use it.\n```\n#[derive(Builder, Debug, PartialEq)]\n#[builder(try_setter, setter(into))]\nstruct Lorem {\n  pub name: String,\n  pub ipsum: u8,\n}\n#[derive(Builder, Debug, PartialEq)]\nstruct Ipsum {\n  #[builder(try_setter, setter(into, name = \"foo\"))]\n  pub dolor: u8,\n}\nfn main() {\n  LoremBuilder::default()\n    .try_ipsum(1u16).unwrap()\n    .name(\"hello\")\n    .build()\n    .expect(\"1 fits into a u8\");\n  IpsumBuilder::default()\n    .try_foo(1u16).unwrap()\n    .build()\n    .expect(\"1 fits into a u8\");\n}\n```\n\n### \u00a7\u27e822\u27e9Default Values\nYou can define default values for each field via annotation by `#[builder(default = \"...\")]`, where `...` stands for any Rust expression and must be string-escaped, e.g.\n  * `#[builder(default = \"42\")]`\n  * `#[builder(default)]` delegates to the `Default`\u27e823\u27e9 trait of the base type.\n\n\nThe expression will be evaluated with each call to `build`.\n```\n#[derive(Builder, Debug, PartialEq)]\nstruct Lorem {\n  #[builder(default = \"42\")]\n  pub ipsum: u32,\n}\nfn main() {\n  // If we don't set the field `ipsum`,\n  let x = LoremBuilder::default().build().unwrap();\n  // .. the custom default will be used for `ipsum`:\n  assert_eq!(x, Lorem {\n    ipsum: 42,\n  });\n}\n```\n\n#### \u00a7\u27e824\u27e9Tips on Defaults\n  * The `#[builder(default)]` annotation can be used on the struct level, too. Overrides are still possible.\n  * Delegate to a private helper method on `FooBuilder` for anything fancy. This way you will get _much better error diagnostics_ from the rust compiler and it will be _much more readable_ for other human beings. :-)\n  * Defaults will not work while using `#[builder(build_fn(skip))]`. In this case, you\u2019ll need to handle default values yourself when converting from the builder, such as by using `.unwrap_or()` and `.unwrap_or_else()`.\n\n\n```\nstruct Lorem {\n  ipsum: String,\n  // Custom defaults can delegate to helper methods\n  // and pass errors to the enclosing `build()` method via `?`.\n  #[builder(default = \"self.default_dolor()?\")]\n  dolor: String,\n}\nimpl LoremBuilder {\n  // Private helper method with access to the builder struct.\n  fn default_dolor(&self) -> Result<String, String> {\n    match self.ipsum {\n      Some(ref x) if x.chars().count() > 3 => Ok(format!(\"dolor {}\", x)),\n      _ => Err(\"ipsum must at least 3 chars to build dolor\".to_string()),\n    }\n  }\n}\n\n```\n\nYou can even reference other fields, but you have to remember that the builder struct will wrap every type in an Option (as illustrated earlier\u27e87\u27e9).\n### \u00a7\u27e825\u27e9Generic Structs\n```\n#[derive(Builder, Debug, PartialEq, Default, Clone)]\nstruct GenLorem<T: Clone> {\n  ipsum: &'static str,\n  dolor: T,\n}\nfn main() {\n  let x = GenLoremBuilder::default().ipsum(\"sit\").dolor(42).build().unwrap();\n  assert_eq!(x, GenLorem { ipsum: \"sit\".into(), dolor: 42 });\n}\n```\n\n### \u00a7\u27e826\u27e9Build Method Customization\nYou can rename or suppress the auto-generated build method, leaving you free to implement your own version. Suppression is done using `#[builder(build_fn(skip))]` at the struct level, and renaming is done with `#[builder(build_fn(name = \"YOUR_NAME\"))]`.\nAdditionally if you want to make the build method private you can apply `#[builder(build_fn(private))]`.\n### \u00a7\u27e827\u27e9Pre-Build Validation\nIf you\u2019re using the provided `build` method, you can declare `#[builder(build_fn(validate = \"path::to::fn\"))]` to specify a validator function which gets access to the builder before construction. The path does not need to be fully-qualified, and will consider `use` statements made at module level. It must be accessible from the scope where the target struct is declared.\nThe provided function must have the signature `(&FooBuilder) -> Result<_, String>`; the `Ok` variant is not used by the `build` method.\n```\n#[derive(Builder, Debug, PartialEq)]\n#[builder(build_fn(validate = \"Self::validate\"))]\nstruct Lorem {\n  pub ipsum: u8,\n}\nimpl LoremBuilder {\n  /// Check that `Lorem` is putting in the right amount of effort.\n  fn validate(&self) -> Result<(), String> {\n    if let Some(ref ipsum) = self.ipsum {\n      match *ipsum {\n        i if i < 20 => Err(\"Try harder\".to_string()),\n        i if i > 100 => Err(\"You'll tire yourself out\".to_string()),\n        _ => Ok(())\n      }\n    } else {\n      Ok(())\n    }\n  }\n}\nfn main() {\n  // If we're trying too hard...\n  let x = LoremBuilder::default().ipsum(120).build().unwrap_err();\n  // .. the build will fail:\n  assert_eq!(&x.to_string(), \"You'll tire yourself out\");\n}\n```\n\nNote:\n  * Default values are applied _after_ validation, and will therefore not be validated!\n\n\n### \u00a7\u27e828\u27e9Additional Trait Derivations\nYou can derive additional traits on the builder, including traits defined by other crates:\n```\n#[derive(Builder, Clone)]\n#[builder(derive(Debug, PartialEq, Eq))]\npub struct Lorem {\n  foo: u8,\n  bar: String,\n}\nfn main() {\n  assert_eq!(LoremBuilder::default(), LoremBuilder::default());\n}\n```\n\nAttributes declared for those traits are _not_ forwarded to the fields on the builder.\n### \u00a7\u27e829\u27e9Documentation Comments and Attributes\n`#[derive(Builder)]` copies doc comments and attributes (`#[...]`) from your fields to the according builder fields and setter-methods, if it is one of the following:\n  * `/// ...`\n  * `#[doc = ...]`\n  * `#[cfg(...)]`\n  * `#[allow(...)]`\n\n\nThe whitelisting minimizes interference with other custom attributes like those used by Serde, Diesel, or others.\n```\n#[derive(Builder)]\nstruct Lorem {\n  /// `ipsum` may be any `String` (be creative).\n  ipsum: String,\n  #[doc = r\"`dolor` is the estimated amount of work.\"]\n  dolor: i32,\n  // `#[derive(Builder)]` understands conditional compilation via cfg-attributes,\n  // i.e. => \"no field = no setter\".\n  #[cfg(target_os = \"macos\")]\n  #[allow(non_snake_case)]\n  Im_a_Mac: bool,\n}\n```\n\n#### \u00a7\u27e830\u27e9Pass-through Attributes\nYou can set attributes on elements of the builder using the `builder_*_attr` attributes:\n  * `builder_struct_attr` adds attributes after `#[derive(...)]` on the builder struct.\n  * `builder_impl_attr` adds attributes on the `impl` block\n  * `builder_field_attr` adds attributes to field declarations in the builder struct.\n  * `builder_setter_attr` adds attributes to the setter in the `impl` block.\n\n\n```\n#[derive(Builder)]\n#[builder(derive(serde::Serialize))]\n#[builder_struct_attr(serde(rename_all = \"camelCase\"))]\nstruct Lorem {\n  #[builder_field_attr(serde(rename=\"dolor\"))]\n  ipsum: String,\n}\nlet mut show = LoremBuilder::default();\nshow.ipsum(\"sit\".into());\nassert_eq!(serde_json::to_string(&show).unwrap(), r#\"{\"dolor\":\"sit\"}\"#);\n```\n\n## \u00a7\u27e831\u27e9Error return type from autogenerated `build` function\nBy default, `build` returns an autogenerated error type:\n```\n#[doc=\"Error type for LoremBuilder\"]\n#[derive(Debug)]\n#[non_exhaustive]\npub enum LoremBuilderError { // where `LoremBuilder` is the name of the builder struct\n  /// Uninitialized field\n  UninitializedField(&'static str),\n  /// Custom validation error\n  ValidationError(String),\n}\nimpl From<String> for LoremBuilderError {\n  fn from(s: String) -> Self { Self::ValidationError(s) }\n}\nimpl From<UninitializedFieldError> for LoremBuilderError { // ...\nimpl Display for LoremBuilderError { // ...\nimpl std::error::Error for LoremBuilderError {}\n```\n\nAlternatively, you can specify your own error type:\n```\n#[derive(Builder, Debug, PartialEq)]\n#[builder(build_fn(error = \"OurLoremError\"))]\nstruct Lorem {\n  pub ipsum: u32,\n}\nstruct OurLoremError(String);\nimpl From<UninitializedFieldError> for OurLoremError {\n  fn from(ufe: UninitializedFieldError) -> OurLoremError { OurLoremError(ufe.to_string()) }\n}\nlet err: OurLoremError = LoremBuilder::default().build().unwrap_err();\nassert_eq!(&err.0, \"Field not initialized: ipsum\");\n```\n\n## \u00a7\u27e832\u27e9Completely custom fields in the builder\nInstead of having an `Option`, you can have whatever type you like:\n```\n#[derive(Debug, PartialEq, Default, Builder, Clone)]\n#[builder(derive(Debug, PartialEq))]\nstruct Lorem {\n  #[builder(setter(into), field(ty = \"u32\"))]\n  ipsum: u32,\n  #[builder(field(ty = \"String\", build = \"()\"))]\n  dolor: (),\n  #[builder(field(ty = \"&'static str\", build = \"self.amet.parse()?\"))]\n  amet: u32,\n}\nimpl From<std::num::ParseIntError> for LoremBuilderError { // ...\nlet mut builder = LoremBuilder::default();\nbuilder.ipsum(42u16).dolor(\"sit\".into()).amet(\"12\");\nassert_eq!(builder, LoremBuilder { ipsum: 42, dolor: \"sit\".into(), amet: \"12\" });\nlet lorem = builder.build().unwrap();\nassert_eq!(lorem, Lorem { ipsum: 42, dolor: (), amet: 12 });\n```\n\nThe builder field type (`ty =`) must implement `Default`.\nThe argument to `build` must be a literal string containing Rust code for the contents of a block, which must evaluate to the type of the target field. It may refer to the builder struct as `self`, use `?`, etc.\n## \u00a7\u27e833\u27e9**`#![no_std]`**Support (on Nightly)\nYou can activate support for `#![no_std]` by adding `#[builder(no_std)]` to your struct and `#![feature(alloc)] extern crate alloc` to your crate.\nThe latter requires the _nightly_ toolchain.\n## \u00a7\u27e834\u27e9Troubleshooting\n### \u00a7\u27e835\u27e9Gotchas\n  * Tuple structs and unit structs are not supported as they have no field names.\n  * Generic setters introduce a type parameter `VALUE: Into<_>`. Therefore you can\u2019t use `VALUE` as a type parameter on a generic struct in combination with generic setters.\n  * The `try_setter` attribute and `owned` builder pattern are not compatible in practice; an error during building will consume the builder, making it impossible to continue construction.\n  * When re-exporting the underlying struct under a different name, the auto-generated documentation will not match.\n  * If derive_builder depends on your crate, and vice versa, then a cyclic dependency would occur. To break it you could try to depend on the `derive_builder_core`\u27e836\u27e9 crate instead.\n\n\n### \u00a7\u27e837\u27e9Report Issues and Ideas\nOpen an issue on GitHub\u27e838\u27e9\nIf possible please try to provide the debugging info if you experience unexpected compilation errors (see above).\n## Structs\u00a7\u27e839\u27e9\n\nUninitializedFieldError\u27e840\u27e9\n    Runtime error when a `build()` method is called and one or more required fields do not have a value.\n## Derive Macros\u00a7\u27e841\u27e9\n\nBuilder\u27e842\u27e9\n    Create a builder struct for the deriving struct.\n",
            "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/derive_builder/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/derive_builder/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/derive_builder/latest/src/derive_builder/lib.rs.html#1-717: Source\n\u27e84\u27e9 https://web.archive.org/web/20170701044756/https://aturon.github.io/ownership/builders.html: builder pattern\n\u27e85\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#quick-start: \u00a7\n\u27e86\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#what-you-write: \u00a7\n\u27e87\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#what-you-get: \u00a7\n\u27e88\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#builder-patterns: \u00a7\n\u27e89\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#owned-aka-consuming: \u00a7\n\u27e810\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#mutable-aka-non-consuming-recommended: \u00a7\n\u27e811\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#immutable: \u00a7\n\u27e812\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#-performance-considerations: \u00a7\n\u27e813\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#more-features: \u00a7\n\u27e814\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#hidden-fields: \u00a7\n\u27e815\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#custom-setters-skip-autogenerated-setters: \u00a7\n\u27e816\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#setter-visibility: \u00a7\n\u27e817\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#generated-builder-struct-name: \u00a7\n\u27e818\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#setter-nameprefix: \u00a7\n\u27e819\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#generic-setters: builder(setter(name = \"foo\"))`.\n  * Alternatively you can set a prefix via `#[builder(setter(prefix = \"xyz\"))`, which will change the method name to `xyz_foo` if the field is named `foo`. Note that an underscore is inserted, since Rust favors snake case here.\n\n\nPrefixes can also be defined on the struct level, but renames only work on fields. Renames take precedence over prefix definitions.\n### [\u00a7\n\u27e820\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#setters-for-option: \u00a7\n\u27e821\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#fallible-setters: \u00a7\n\u27e822\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#default-values: \u00a7\n\u27e823\u27e9 https://doc.rust-lang.org/std/default/trait.Default.html: `Default`\n\u27e824\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#tips-on-defaults: \u00a7\n\u27e825\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#generic-structs: \u00a7\n\u27e826\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#build-method-customization: \u00a7\n\u27e827\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#pre-build-validation: \u00a7\n\u27e828\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#additional-trait-derivations: \u00a7\n\u27e829\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#documentation-comments-and-attributes: \u00a7\n\u27e830\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#pass-through-attributes: \u00a7\n\u27e831\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#error-return-type-from-autogenerated-build-function: \u00a7\n\u27e832\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#completely-custom-fields-in-the-builder: \u00a7\n\u27e833\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#no_std-support-on-nightly: \u00a7\n\u27e834\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#troubleshooting: \u00a7\n\u27e835\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#gotchas: \u00a7\n\u27e836\u27e9 https://crates.io/crates/derive_builder_core: `derive_builder_core`\n\u27e837\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#report-issues-and-ideas: \u00a7\n\u27e838\u27e9 https://github.com/colin-kiegel/rust-derive-builder/issues: Open an issue on GitHub\n\u27e839\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#structs: \u00a7\n\u27e840\u27e9 https://docs.rs/derive_builder/latest/derive_builder/struct.UninitializedFieldError.html: struct derive_builder::UninitializedFieldError - UninitializedFieldError\n\u27e841\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#derives: \u00a7\n\u27e842\u27e9 https://docs.rs/derive_builder/latest/derive_builder/derive.Builder.html: derive derive_builder::Builder - Builder\n",
            "fit_markdown": "",
            "fit_html": ""
          },
          "downloads": 0,
          "github_stars": 0,
          "dependencies": [],
          "features": {},
          "code_snippets": [],
          "readme_sections": {},
          "librs_downloads": null,
          "source": "crates.io",
          "enhanced_scraping": {},
          "enhanced_features": [],
          "enhanced_dependencies": []
        },
        "enriched_crate": {
          "name": "derive_builder",
          "version": "0.20.2",
          "description": "ALLOW: Positive community sentiment",
          "repository": "",
          "keywords": [],
          "categories": [],
          "readme": {
            "raw_markdown": "[](https://docs.rs/derive_builder/latest/derive_builder/all.html \"show sidebar\")\n# Crate derive_builderCopy item path\n[Settings](https://docs.rs/derive_builder/latest/settings.html)\n[Help](https://docs.rs/derive_builder/latest/help.html)\nSummary[Source](https://docs.rs/derive_builder/latest/src/derive_builder/lib.rs.html#1-717)\nExpand description\nDerive a builder for a struct\nThis crate implements the [builder pattern](https://web.archive.org/web/20170701044756/https://aturon.github.io/ownership/builders.html) for you. Just apply `#[derive(Builder)]` to a struct `Foo`, and it will derive an additional struct `FooBuilder` with **setter** -methods for all fields and a **build** -method \u2014 the way you want it.\n## [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#quick-start)Quick Start\nAdd `derive_builder` as a dependency to you `Cargo.toml`.\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#what-you-write)What you write\n```\nuse derive_builder::Builder;\n#[derive(Builder)]\nstruct Lorem {\n  ipsum: u32,\n  // ..\n}\n```\n\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#what-you-get)What you get\n```\n#[derive(Clone, Default)]\nstruct LoremBuilder {\n  ipsum: Option<u32>,\n}\n#[allow(dead_code)]\nimpl LoremBuilder {\n  pub fn ipsum(&mut self, value: u32) -> &mut Self {\n    let mut new = self;\n    new.ipsum = Some(value);\n    new\n  }\n  fn build(&self) -> Result<Lorem, LoremBuilderError> {\n    Ok(Lorem {\n      ipsum: Clone::clone(self.ipsum\n        .as_ref()\n        .ok_or(LoremBuilderError::from(UninitializedFieldError::new(\"ipsum\")))?),\n    })\n  }\n}\n```\n\nBy default all generated setter-methods take and return `&mut self` (aka _non-consuming_ builder pattern). Accordingly, the build method also takes a reference by default.\nYou can easily opt into different patterns and control many other aspects.\nThe build method returns `Result<T, E>`, where `T` is the struct you started with and E is a generated builder error type. It returns `Err` if you didn\u2019t initialize all fields and no default values were provided.\n## [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#builder-patterns)Builder Patterns\nLet\u2019s look again at the example above. You can now build structs like this:\n```\nlet x: Lorem = LoremBuilder::default().ipsum(42).build()?;\n```\n\nOk, _chaining_ method calls is nice, but what if `ipsum(42)` should only happen if `geek = true`?\nSo let\u2019s make this call conditional\n```\nlet mut builder = LoremBuilder::default();\nif geek {\n  builder.ipsum(42);\n}\nlet x: Lorem = builder.build()?;\n```\n\nNow it comes in handy that our setter methods take and return mutable references. Otherwise we would need to write something more clumsy like `builder = builder.ipsum(42)` to reassign the return value each time we have to call a setter conditionally.\nSetters with mutable references are therefore a convenient default for the builder pattern in Rust.\nBut this is a free world and the choice is still yours!\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#owned-aka-consuming)Owned, aka Consuming\nPrecede your struct (or field) with `#[builder(pattern = \"owned\")]` to opt into this pattern. Builders generated with this pattern do not automatically derive `Clone`, which allows builders to be generated for structs with fields that do not derive `Clone`.\n  * Setters take and return `self`.\n  * PRO: Setter calls and final build method can be chained.\n  * CON: If you don\u2019t chain your calls, you have to create a reference to each return value, e.g. `builder = builder.ipsum(42)`.\n\n\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#mutable-aka-non-consuming-recommended)Mutable, aka Non-Consuming (recommended)\nThis pattern is recommended and active by default if you don\u2019t specify anything else. You can precede your struct (or field) with `#[builder(pattern = \"mutable\")]` to make this choice explicit.\n  * Setters take and return `&mut self`.\n  * PRO: Setter calls and final build method can be chained.\n  * CON: The build method must clone or copy data to create something owned out of a mutable reference. Otherwise it could not be used in a chain. **(*)**\n\n\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#immutable)Immutable\nPrecede your struct (or field) with `#[builder(pattern = \"immutable\")]` to opt into this pattern.\n  * Setters take and return `&self`.\n  * PRO: Setter calls and final build method can be chained.\n  * CON: If you don\u2019t chain your calls, you have to create a reference to each return value, e.g. `builder = builder.ipsum(42)`.\n  * CON: The build method _and each setter_ must clone or copy data to create something owned out of a reference. **(*)**\n\n\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#-performance-considerations)(*) Performance Considerations\nLuckily Rust is clever enough to optimize these clone-calls away in release builds for your every-day use cases. Thats quite a safe bet - we checked this for you. ;-) Switching to consuming signatures (=`self`) is unlikely to give you any performance gain, but very likely to restrict your API for non-chained use cases.\n## [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#more-features)More Features\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#hidden-fields)Hidden Fields\nYou can hide fields by skipping their setters on (and presence in) the builder struct.\n  * Opt-out \u2014 skip setters via `#[builder(setter(skip))]` on individual fields.\n  * Opt-in \u2014 set `#[builder(setter(skip))]` on the whole struct and enable individual setters via `#[builder(setter)]`.\n\n\nThe types of skipped fields must implement `Default`.\n```\n#[derive(Builder)]\nstruct HiddenField {\n  setter_present: u32,\n  #[builder(setter(skip))]\n  setter_skipped: u32,\n}\n```\n\nAlternatively, you can use the more verbose form:\n  * `#[builder(setter(skip = true))]`\n  * `#[builder(setter(skip = false))]`\n\n\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#custom-setters-skip-autogenerated-setters)Custom setters (skip autogenerated setters)\nSimilarly to `setter(skip)`, you can say that you will provide your own setter methods. This simply suppresses the generation of the setter, leaving the field in the builder, as `Option<T>`.\n```\n#[derive(Builder)]\nstruct SetterOptOut {\n  #[builder(setter(custom))]\n  custom_setter: u32,\n}\nimpl SetterOptOutBuilder {\n  fn custom_setter(&mut self, value: u32) {\n    self.custom_setter = Some(value);\n  }\n}\n```\n\nAgain, the more verbose form is accepted:\n  * `#[builder(setter(custom = true))]`\n  * `#[builder(setter(custom = false))]`\n\n\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#setter-visibility)Setter Visibility\nSetters are public by default. You can precede your struct (or field) with `#[builder(public)]` to make this explicit.\nOtherwise precede your struct (or field) with `#[builder(private)]` to opt into private setters.\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#generated-builder-struct-name)Generated builder struct name\nBy default, the builder struct for `struct Foo` is `FooBuilder`. You can override this:\n```\n#[derive(Builder)]\n#[builder(name = \"FooConstructor\")]\nstruct Foo { }\nlet foo: Foo = FooConstructor::default().build()?;\n```\n\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#setter-nameprefix)Setter Name/Prefix\nSetter methods are named after their corresponding field by default.\n  * You can customize the setter name via `#[builder(setter(name = \"foo\"))`.\n  * Alternatively you can set a prefix via `#[builder(setter(prefix = \"xyz\"))`, which will change the method name to `xyz_foo` if the field is named `foo`. Note that an underscore is inserted, since Rust favors snake case here.\n\n\nPrefixes can also be defined on the struct level, but renames only work on fields. Renames take precedence over prefix definitions.\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#generic-setters)Generic Setters\nYou can make each setter generic over the `Into`-trait. It\u2019s as simple as adding `#[builder(setter(into))]` to either a field or the whole struct.\n```\n#[derive(Builder, Debug, PartialEq)]\nstruct Lorem {\n  #[builder(setter(into))]\n  pub ipsum: String,\n}\nfn main() {\n  // `\"foo\"` will be converted into a `String` automatically.\n  let x = LoremBuilder::default().ipsum(\"foo\").build().unwrap();\n  assert_eq!(x, Lorem {\n    ipsum: \"foo\".to_string(),\n  });\n}\n```\n\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#setters-for-option)Setters for Option\nYou can avoid wrapping values in `Some(...)` for fields of type `Option<T>`. It\u2019s as simple as adding `#[builder(setter(strip_option))]` to either a single field or the whole struct.\n```\n#[derive(Builder, Debug, PartialEq)]\nstruct Lorem {\n  #[builder(setter(into, strip_option))]\n  pub ipsum: Option<String>,\n  #[builder(setter(into, strip_option), default)]\n  pub foo: Option<String>,\n}\nfn main() {\n  // `\"foo\"` will be converted into a `String` automatically.\n  let x = LoremBuilder::default().ipsum(\"foo\").build().unwrap();\n  assert_eq!(x, Lorem {\n    ipsum: Some(\"foo\".to_string()),\n    foo: None\n  });\n}\n```\n\nIf you want to set the value to None when unset, then enable `default` on this field (or do not use `strip_option`).\nLimitation: only the `Option` type name is supported, not type alias nor `std::option::Option`.\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#fallible-setters)Fallible Setters\nAlongside the normal setter methods, you can expose fallible setters which are generic over the `TryInto` trait. TryInto is similar to `Into` with the key distinction that the conversion can fail, and therefore produces a `Result`.\nYou can only declare the `try_setter` attribute today if you\u2019re targeting nightly, and you have to add `#![feature(try_from)]` to your crate to use it.\n```\n#[derive(Builder, Debug, PartialEq)]\n#[builder(try_setter, setter(into))]\nstruct Lorem {\n  pub name: String,\n  pub ipsum: u8,\n}\n#[derive(Builder, Debug, PartialEq)]\nstruct Ipsum {\n  #[builder(try_setter, setter(into, name = \"foo\"))]\n  pub dolor: u8,\n}\nfn main() {\n  LoremBuilder::default()\n    .try_ipsum(1u16).unwrap()\n    .name(\"hello\")\n    .build()\n    .expect(\"1 fits into a u8\");\n  IpsumBuilder::default()\n    .try_foo(1u16).unwrap()\n    .build()\n    .expect(\"1 fits into a u8\");\n}\n```\n\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#default-values)Default Values\nYou can define default values for each field via annotation by `#[builder(default = \"...\")]`, where `...` stands for any Rust expression and must be string-escaped, e.g.\n  * `#[builder(default = \"42\")]`\n  * `#[builder(default)]` delegates to the [`Default`](https://doc.rust-lang.org/std/default/trait.Default.html) trait of the base type.\n\n\nThe expression will be evaluated with each call to `build`.\n```\n#[derive(Builder, Debug, PartialEq)]\nstruct Lorem {\n  #[builder(default = \"42\")]\n  pub ipsum: u32,\n}\nfn main() {\n  // If we don't set the field `ipsum`,\n  let x = LoremBuilder::default().build().unwrap();\n  // .. the custom default will be used for `ipsum`:\n  assert_eq!(x, Lorem {\n    ipsum: 42,\n  });\n}\n```\n\n#### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#tips-on-defaults)Tips on Defaults\n  * The `#[builder(default)]` annotation can be used on the struct level, too. Overrides are still possible.\n  * Delegate to a private helper method on `FooBuilder` for anything fancy. This way you will get _much better error diagnostics_ from the rust compiler and it will be _much more readable_ for other human beings. :-)\n  * Defaults will not work while using `#[builder(build_fn(skip))]`. In this case, you\u2019ll need to handle default values yourself when converting from the builder, such as by using `.unwrap_or()` and `.unwrap_or_else()`.\n\n\n```\nstruct Lorem {\n  ipsum: String,\n  // Custom defaults can delegate to helper methods\n  // and pass errors to the enclosing `build()` method via `?`.\n  #[builder(default = \"self.default_dolor()?\")]\n  dolor: String,\n}\nimpl LoremBuilder {\n  // Private helper method with access to the builder struct.\n  fn default_dolor(&self) -> Result<String, String> {\n    match self.ipsum {\n      Some(ref x) if x.chars().count() > 3 => Ok(format!(\"dolor {}\", x)),\n      _ => Err(\"ipsum must at least 3 chars to build dolor\".to_string()),\n    }\n  }\n}\n\n```\n\nYou can even reference other fields, but you have to remember that the builder struct will wrap every type in an Option ([as illustrated earlier](https://docs.rs/derive_builder/latest/derive_builder/#what-you-get)).\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#generic-structs)Generic Structs\n```\n#[derive(Builder, Debug, PartialEq, Default, Clone)]\nstruct GenLorem<T: Clone> {\n  ipsum: &'static str,\n  dolor: T,\n}\nfn main() {\n  let x = GenLoremBuilder::default().ipsum(\"sit\").dolor(42).build().unwrap();\n  assert_eq!(x, GenLorem { ipsum: \"sit\".into(), dolor: 42 });\n}\n```\n\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#build-method-customization)Build Method Customization\nYou can rename or suppress the auto-generated build method, leaving you free to implement your own version. Suppression is done using `#[builder(build_fn(skip))]` at the struct level, and renaming is done with `#[builder(build_fn(name = \"YOUR_NAME\"))]`.\nAdditionally if you want to make the build method private you can apply `#[builder(build_fn(private))]`.\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#pre-build-validation)Pre-Build Validation\nIf you\u2019re using the provided `build` method, you can declare `#[builder(build_fn(validate = \"path::to::fn\"))]` to specify a validator function which gets access to the builder before construction. The path does not need to be fully-qualified, and will consider `use` statements made at module level. It must be accessible from the scope where the target struct is declared.\nThe provided function must have the signature `(&FooBuilder) -> Result<_, String>`; the `Ok` variant is not used by the `build` method.\n```\n#[derive(Builder, Debug, PartialEq)]\n#[builder(build_fn(validate = \"Self::validate\"))]\nstruct Lorem {\n  pub ipsum: u8,\n}\nimpl LoremBuilder {\n  /// Check that `Lorem` is putting in the right amount of effort.\n  fn validate(&self) -> Result<(), String> {\n    if let Some(ref ipsum) = self.ipsum {\n      match *ipsum {\n        i if i < 20 => Err(\"Try harder\".to_string()),\n        i if i > 100 => Err(\"You'll tire yourself out\".to_string()),\n        _ => Ok(())\n      }\n    } else {\n      Ok(())\n    }\n  }\n}\nfn main() {\n  // If we're trying too hard...\n  let x = LoremBuilder::default().ipsum(120).build().unwrap_err();\n  // .. the build will fail:\n  assert_eq!(&x.to_string(), \"You'll tire yourself out\");\n}\n```\n\nNote:\n  * Default values are applied _after_ validation, and will therefore not be validated!\n\n\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#additional-trait-derivations)Additional Trait Derivations\nYou can derive additional traits on the builder, including traits defined by other crates:\n```\n#[derive(Builder, Clone)]\n#[builder(derive(Debug, PartialEq, Eq))]\npub struct Lorem {\n  foo: u8,\n  bar: String,\n}\nfn main() {\n  assert_eq!(LoremBuilder::default(), LoremBuilder::default());\n}\n```\n\nAttributes declared for those traits are _not_ forwarded to the fields on the builder.\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#documentation-comments-and-attributes)Documentation Comments and Attributes\n`#[derive(Builder)]` copies doc comments and attributes (`#[...]`) from your fields to the according builder fields and setter-methods, if it is one of the following:\n  * `/// ...`\n  * `#[doc = ...]`\n  * `#[cfg(...)]`\n  * `#[allow(...)]`\n\n\nThe whitelisting minimizes interference with other custom attributes like those used by Serde, Diesel, or others.\n```\n#[derive(Builder)]\nstruct Lorem {\n  /// `ipsum` may be any `String` (be creative).\n  ipsum: String,\n  #[doc = r\"`dolor` is the estimated amount of work.\"]\n  dolor: i32,\n  // `#[derive(Builder)]` understands conditional compilation via cfg-attributes,\n  // i.e. => \"no field = no setter\".\n  #[cfg(target_os = \"macos\")]\n  #[allow(non_snake_case)]\n  Im_a_Mac: bool,\n}\n```\n\n#### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#pass-through-attributes)Pass-through Attributes\nYou can set attributes on elements of the builder using the `builder_*_attr` attributes:\n  * `builder_struct_attr` adds attributes after `#[derive(...)]` on the builder struct.\n  * `builder_impl_attr` adds attributes on the `impl` block\n  * `builder_field_attr` adds attributes to field declarations in the builder struct.\n  * `builder_setter_attr` adds attributes to the setter in the `impl` block.\n\n\n```\n#[derive(Builder)]\n#[builder(derive(serde::Serialize))]\n#[builder_struct_attr(serde(rename_all = \"camelCase\"))]\nstruct Lorem {\n  #[builder_field_attr(serde(rename=\"dolor\"))]\n  ipsum: String,\n}\nlet mut show = LoremBuilder::default();\nshow.ipsum(\"sit\".into());\nassert_eq!(serde_json::to_string(&show).unwrap(), r#\"{\"dolor\":\"sit\"}\"#);\n```\n\n## [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#error-return-type-from-autogenerated-build-function)Error return type from autogenerated `build` function\nBy default, `build` returns an autogenerated error type:\n```\n#[doc=\"Error type for LoremBuilder\"]\n#[derive(Debug)]\n#[non_exhaustive]\npub enum LoremBuilderError { // where `LoremBuilder` is the name of the builder struct\n  /// Uninitialized field\n  UninitializedField(&'static str),\n  /// Custom validation error\n  ValidationError(String),\n}\nimpl From<String> for LoremBuilderError {\n  fn from(s: String) -> Self { Self::ValidationError(s) }\n}\nimpl From<UninitializedFieldError> for LoremBuilderError { // ...\nimpl Display for LoremBuilderError { // ...\nimpl std::error::Error for LoremBuilderError {}\n```\n\nAlternatively, you can specify your own error type:\n```\n#[derive(Builder, Debug, PartialEq)]\n#[builder(build_fn(error = \"OurLoremError\"))]\nstruct Lorem {\n  pub ipsum: u32,\n}\nstruct OurLoremError(String);\nimpl From<UninitializedFieldError> for OurLoremError {\n  fn from(ufe: UninitializedFieldError) -> OurLoremError { OurLoremError(ufe.to_string()) }\n}\nlet err: OurLoremError = LoremBuilder::default().build().unwrap_err();\nassert_eq!(&err.0, \"Field not initialized: ipsum\");\n```\n\n## [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#completely-custom-fields-in-the-builder)Completely custom fields in the builder\nInstead of having an `Option`, you can have whatever type you like:\n```\n#[derive(Debug, PartialEq, Default, Builder, Clone)]\n#[builder(derive(Debug, PartialEq))]\nstruct Lorem {\n  #[builder(setter(into), field(ty = \"u32\"))]\n  ipsum: u32,\n  #[builder(field(ty = \"String\", build = \"()\"))]\n  dolor: (),\n  #[builder(field(ty = \"&'static str\", build = \"self.amet.parse()?\"))]\n  amet: u32,\n}\nimpl From<std::num::ParseIntError> for LoremBuilderError { // ...\nlet mut builder = LoremBuilder::default();\nbuilder.ipsum(42u16).dolor(\"sit\".into()).amet(\"12\");\nassert_eq!(builder, LoremBuilder { ipsum: 42, dolor: \"sit\".into(), amet: \"12\" });\nlet lorem = builder.build().unwrap();\nassert_eq!(lorem, Lorem { ipsum: 42, dolor: (), amet: 12 });\n```\n\nThe builder field type (`ty =`) must implement `Default`.\nThe argument to `build` must be a literal string containing Rust code for the contents of a block, which must evaluate to the type of the target field. It may refer to the builder struct as `self`, use `?`, etc.\n## [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#no_std-support-on-nightly)**`#![no_std]`**Support (on Nightly)\nYou can activate support for `#![no_std]` by adding `#[builder(no_std)]` to your struct and `#![feature(alloc)] extern crate alloc` to your crate.\nThe latter requires the _nightly_ toolchain.\n## [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#troubleshooting)Troubleshooting\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#gotchas)Gotchas\n  * Tuple structs and unit structs are not supported as they have no field names.\n  * Generic setters introduce a type parameter `VALUE: Into<_>`. Therefore you can\u2019t use `VALUE` as a type parameter on a generic struct in combination with generic setters.\n  * The `try_setter` attribute and `owned` builder pattern are not compatible in practice; an error during building will consume the builder, making it impossible to continue construction.\n  * When re-exporting the underlying struct under a different name, the auto-generated documentation will not match.\n  * If derive_builder depends on your crate, and vice versa, then a cyclic dependency would occur. To break it you could try to depend on the [`derive_builder_core`](https://crates.io/crates/derive_builder_core) crate instead.\n\n\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#report-issues-and-ideas)Report Issues and Ideas\n[Open an issue on GitHub](https://github.com/colin-kiegel/rust-derive-builder/issues)\nIf possible please try to provide the debugging info if you experience unexpected compilation errors (see above).\n## Structs[\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#structs)\n\n[UninitializedFieldError](https://docs.rs/derive_builder/latest/derive_builder/struct.UninitializedFieldError.html \"struct derive_builder::UninitializedFieldError\")\n    Runtime error when a `build()` method is called and one or more required fields do not have a value.\n## Derive Macros[\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#derives)\n\n[Builder](https://docs.rs/derive_builder/latest/derive_builder/derive.Builder.html \"derive derive_builder::Builder\")\n    Create a builder struct for the deriving struct.\n",
            "markdown_with_citations": "[](https://docs.rs/derive_builder/latest/derive_builder/all.html \"show sidebar\")\n# Crate derive_builderCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nDerive a builder for a struct\nThis crate implements the builder pattern\u27e84\u27e9 for you. Just apply `#[derive(Builder)]` to a struct `Foo`, and it will derive an additional struct `FooBuilder` with **setter** -methods for all fields and a **build** -method \u2014 the way you want it.\n## \u00a7\u27e85\u27e9Quick Start\nAdd `derive_builder` as a dependency to you `Cargo.toml`.\n### \u00a7\u27e86\u27e9What you write\n```\nuse derive_builder::Builder;\n#[derive(Builder)]\nstruct Lorem {\n  ipsum: u32,\n  // ..\n}\n```\n\n### \u00a7\u27e87\u27e9What you get\n```\n#[derive(Clone, Default)]\nstruct LoremBuilder {\n  ipsum: Option<u32>,\n}\n#[allow(dead_code)]\nimpl LoremBuilder {\n  pub fn ipsum(&mut self, value: u32) -> &mut Self {\n    let mut new = self;\n    new.ipsum = Some(value);\n    new\n  }\n  fn build(&self) -> Result<Lorem, LoremBuilderError> {\n    Ok(Lorem {\n      ipsum: Clone::clone(self.ipsum\n        .as_ref()\n        .ok_or(LoremBuilderError::from(UninitializedFieldError::new(\"ipsum\")))?),\n    })\n  }\n}\n```\n\nBy default all generated setter-methods take and return `&mut self` (aka _non-consuming_ builder pattern). Accordingly, the build method also takes a reference by default.\nYou can easily opt into different patterns and control many other aspects.\nThe build method returns `Result<T, E>`, where `T` is the struct you started with and E is a generated builder error type. It returns `Err` if you didn\u2019t initialize all fields and no default values were provided.\n## \u00a7\u27e88\u27e9Builder Patterns\nLet\u2019s look again at the example above. You can now build structs like this:\n```\nlet x: Lorem = LoremBuilder::default().ipsum(42).build()?;\n```\n\nOk, _chaining_ method calls is nice, but what if `ipsum(42)` should only happen if `geek = true`?\nSo let\u2019s make this call conditional\n```\nlet mut builder = LoremBuilder::default();\nif geek {\n  builder.ipsum(42);\n}\nlet x: Lorem = builder.build()?;\n```\n\nNow it comes in handy that our setter methods take and return mutable references. Otherwise we would need to write something more clumsy like `builder = builder.ipsum(42)` to reassign the return value each time we have to call a setter conditionally.\nSetters with mutable references are therefore a convenient default for the builder pattern in Rust.\nBut this is a free world and the choice is still yours!\n### \u00a7\u27e89\u27e9Owned, aka Consuming\nPrecede your struct (or field) with `#[builder(pattern = \"owned\")]` to opt into this pattern. Builders generated with this pattern do not automatically derive `Clone`, which allows builders to be generated for structs with fields that do not derive `Clone`.\n  * Setters take and return `self`.\n  * PRO: Setter calls and final build method can be chained.\n  * CON: If you don\u2019t chain your calls, you have to create a reference to each return value, e.g. `builder = builder.ipsum(42)`.\n\n\n### \u00a7\u27e810\u27e9Mutable, aka Non-Consuming (recommended)\nThis pattern is recommended and active by default if you don\u2019t specify anything else. You can precede your struct (or field) with `#[builder(pattern = \"mutable\")]` to make this choice explicit.\n  * Setters take and return `&mut self`.\n  * PRO: Setter calls and final build method can be chained.\n  * CON: The build method must clone or copy data to create something owned out of a mutable reference. Otherwise it could not be used in a chain. **(*)**\n\n\n### \u00a7\u27e811\u27e9Immutable\nPrecede your struct (or field) with `#[builder(pattern = \"immutable\")]` to opt into this pattern.\n  * Setters take and return `&self`.\n  * PRO: Setter calls and final build method can be chained.\n  * CON: If you don\u2019t chain your calls, you have to create a reference to each return value, e.g. `builder = builder.ipsum(42)`.\n  * CON: The build method _and each setter_ must clone or copy data to create something owned out of a reference. **(*)**\n\n\n### \u00a7\u27e812\u27e9(*) Performance Considerations\nLuckily Rust is clever enough to optimize these clone-calls away in release builds for your every-day use cases. Thats quite a safe bet - we checked this for you. ;-) Switching to consuming signatures (=`self`) is unlikely to give you any performance gain, but very likely to restrict your API for non-chained use cases.\n## \u00a7\u27e813\u27e9More Features\n### \u00a7\u27e814\u27e9Hidden Fields\nYou can hide fields by skipping their setters on (and presence in) the builder struct.\n  * Opt-out \u2014 skip setters via `#[builder(setter(skip))]` on individual fields.\n  * Opt-in \u2014 set `#[builder(setter(skip))]` on the whole struct and enable individual setters via `#[builder(setter)]`.\n\n\nThe types of skipped fields must implement `Default`.\n```\n#[derive(Builder)]\nstruct HiddenField {\n  setter_present: u32,\n  #[builder(setter(skip))]\n  setter_skipped: u32,\n}\n```\n\nAlternatively, you can use the more verbose form:\n  * `#[builder(setter(skip = true))]`\n  * `#[builder(setter(skip = false))]`\n\n\n### \u00a7\u27e815\u27e9Custom setters (skip autogenerated setters)\nSimilarly to `setter(skip)`, you can say that you will provide your own setter methods. This simply suppresses the generation of the setter, leaving the field in the builder, as `Option<T>`.\n```\n#[derive(Builder)]\nstruct SetterOptOut {\n  #[builder(setter(custom))]\n  custom_setter: u32,\n}\nimpl SetterOptOutBuilder {\n  fn custom_setter(&mut self, value: u32) {\n    self.custom_setter = Some(value);\n  }\n}\n```\n\nAgain, the more verbose form is accepted:\n  * `#[builder(setter(custom = true))]`\n  * `#[builder(setter(custom = false))]`\n\n\n### \u00a7\u27e816\u27e9Setter Visibility\nSetters are public by default. You can precede your struct (or field) with `#[builder(public)]` to make this explicit.\nOtherwise precede your struct (or field) with `#[builder(private)]` to opt into private setters.\n### \u00a7\u27e817\u27e9Generated builder struct name\nBy default, the builder struct for `struct Foo` is `FooBuilder`. You can override this:\n```\n#[derive(Builder)]\n#[builder(name = \"FooConstructor\")]\nstruct Foo { }\nlet foo: Foo = FooConstructor::default().build()?;\n```\n\n### \u00a7\u27e818\u27e9Setter Name/Prefix\nSetter methods are named after their corresponding field by default.\n  * You can customize the setter name via `#builder(setter(name = \"foo\"))`.\n  * Alternatively you can set a prefix via `#[builder(setter(prefix = \"xyz\"))`, which will change the method name to `xyz_foo` if the field is named `foo`. Note that an underscore is inserted, since Rust favors snake case here.\n\n\nPrefixes can also be defined on the struct level, but renames only work on fields. Renames take precedence over prefix definitions.\n### [\u00a7\u27e819\u27e9Generic Setters\nYou can make each setter generic over the `Into`-trait. It\u2019s as simple as adding `#[builder(setter(into))]` to either a field or the whole struct.\n```\n#[derive(Builder, Debug, PartialEq)]\nstruct Lorem {\n  #[builder(setter(into))]\n  pub ipsum: String,\n}\nfn main() {\n  // `\"foo\"` will be converted into a `String` automatically.\n  let x = LoremBuilder::default().ipsum(\"foo\").build().unwrap();\n  assert_eq!(x, Lorem {\n    ipsum: \"foo\".to_string(),\n  });\n}\n```\n\n### \u00a7\u27e820\u27e9Setters for Option\nYou can avoid wrapping values in `Some(...)` for fields of type `Option<T>`. It\u2019s as simple as adding `#[builder(setter(strip_option))]` to either a single field or the whole struct.\n```\n#[derive(Builder, Debug, PartialEq)]\nstruct Lorem {\n  #[builder(setter(into, strip_option))]\n  pub ipsum: Option<String>,\n  #[builder(setter(into, strip_option), default)]\n  pub foo: Option<String>,\n}\nfn main() {\n  // `\"foo\"` will be converted into a `String` automatically.\n  let x = LoremBuilder::default().ipsum(\"foo\").build().unwrap();\n  assert_eq!(x, Lorem {\n    ipsum: Some(\"foo\".to_string()),\n    foo: None\n  });\n}\n```\n\nIf you want to set the value to None when unset, then enable `default` on this field (or do not use `strip_option`).\nLimitation: only the `Option` type name is supported, not type alias nor `std::option::Option`.\n### \u00a7\u27e821\u27e9Fallible Setters\nAlongside the normal setter methods, you can expose fallible setters which are generic over the `TryInto` trait. TryInto is similar to `Into` with the key distinction that the conversion can fail, and therefore produces a `Result`.\nYou can only declare the `try_setter` attribute today if you\u2019re targeting nightly, and you have to add `#![feature(try_from)]` to your crate to use it.\n```\n#[derive(Builder, Debug, PartialEq)]\n#[builder(try_setter, setter(into))]\nstruct Lorem {\n  pub name: String,\n  pub ipsum: u8,\n}\n#[derive(Builder, Debug, PartialEq)]\nstruct Ipsum {\n  #[builder(try_setter, setter(into, name = \"foo\"))]\n  pub dolor: u8,\n}\nfn main() {\n  LoremBuilder::default()\n    .try_ipsum(1u16).unwrap()\n    .name(\"hello\")\n    .build()\n    .expect(\"1 fits into a u8\");\n  IpsumBuilder::default()\n    .try_foo(1u16).unwrap()\n    .build()\n    .expect(\"1 fits into a u8\");\n}\n```\n\n### \u00a7\u27e822\u27e9Default Values\nYou can define default values for each field via annotation by `#[builder(default = \"...\")]`, where `...` stands for any Rust expression and must be string-escaped, e.g.\n  * `#[builder(default = \"42\")]`\n  * `#[builder(default)]` delegates to the `Default`\u27e823\u27e9 trait of the base type.\n\n\nThe expression will be evaluated with each call to `build`.\n```\n#[derive(Builder, Debug, PartialEq)]\nstruct Lorem {\n  #[builder(default = \"42\")]\n  pub ipsum: u32,\n}\nfn main() {\n  // If we don't set the field `ipsum`,\n  let x = LoremBuilder::default().build().unwrap();\n  // .. the custom default will be used for `ipsum`:\n  assert_eq!(x, Lorem {\n    ipsum: 42,\n  });\n}\n```\n\n#### \u00a7\u27e824\u27e9Tips on Defaults\n  * The `#[builder(default)]` annotation can be used on the struct level, too. Overrides are still possible.\n  * Delegate to a private helper method on `FooBuilder` for anything fancy. This way you will get _much better error diagnostics_ from the rust compiler and it will be _much more readable_ for other human beings. :-)\n  * Defaults will not work while using `#[builder(build_fn(skip))]`. In this case, you\u2019ll need to handle default values yourself when converting from the builder, such as by using `.unwrap_or()` and `.unwrap_or_else()`.\n\n\n```\nstruct Lorem {\n  ipsum: String,\n  // Custom defaults can delegate to helper methods\n  // and pass errors to the enclosing `build()` method via `?`.\n  #[builder(default = \"self.default_dolor()?\")]\n  dolor: String,\n}\nimpl LoremBuilder {\n  // Private helper method with access to the builder struct.\n  fn default_dolor(&self) -> Result<String, String> {\n    match self.ipsum {\n      Some(ref x) if x.chars().count() > 3 => Ok(format!(\"dolor {}\", x)),\n      _ => Err(\"ipsum must at least 3 chars to build dolor\".to_string()),\n    }\n  }\n}\n\n```\n\nYou can even reference other fields, but you have to remember that the builder struct will wrap every type in an Option (as illustrated earlier\u27e87\u27e9).\n### \u00a7\u27e825\u27e9Generic Structs\n```\n#[derive(Builder, Debug, PartialEq, Default, Clone)]\nstruct GenLorem<T: Clone> {\n  ipsum: &'static str,\n  dolor: T,\n}\nfn main() {\n  let x = GenLoremBuilder::default().ipsum(\"sit\").dolor(42).build().unwrap();\n  assert_eq!(x, GenLorem { ipsum: \"sit\".into(), dolor: 42 });\n}\n```\n\n### \u00a7\u27e826\u27e9Build Method Customization\nYou can rename or suppress the auto-generated build method, leaving you free to implement your own version. Suppression is done using `#[builder(build_fn(skip))]` at the struct level, and renaming is done with `#[builder(build_fn(name = \"YOUR_NAME\"))]`.\nAdditionally if you want to make the build method private you can apply `#[builder(build_fn(private))]`.\n### \u00a7\u27e827\u27e9Pre-Build Validation\nIf you\u2019re using the provided `build` method, you can declare `#[builder(build_fn(validate = \"path::to::fn\"))]` to specify a validator function which gets access to the builder before construction. The path does not need to be fully-qualified, and will consider `use` statements made at module level. It must be accessible from the scope where the target struct is declared.\nThe provided function must have the signature `(&FooBuilder) -> Result<_, String>`; the `Ok` variant is not used by the `build` method.\n```\n#[derive(Builder, Debug, PartialEq)]\n#[builder(build_fn(validate = \"Self::validate\"))]\nstruct Lorem {\n  pub ipsum: u8,\n}\nimpl LoremBuilder {\n  /// Check that `Lorem` is putting in the right amount of effort.\n  fn validate(&self) -> Result<(), String> {\n    if let Some(ref ipsum) = self.ipsum {\n      match *ipsum {\n        i if i < 20 => Err(\"Try harder\".to_string()),\n        i if i > 100 => Err(\"You'll tire yourself out\".to_string()),\n        _ => Ok(())\n      }\n    } else {\n      Ok(())\n    }\n  }\n}\nfn main() {\n  // If we're trying too hard...\n  let x = LoremBuilder::default().ipsum(120).build().unwrap_err();\n  // .. the build will fail:\n  assert_eq!(&x.to_string(), \"You'll tire yourself out\");\n}\n```\n\nNote:\n  * Default values are applied _after_ validation, and will therefore not be validated!\n\n\n### \u00a7\u27e828\u27e9Additional Trait Derivations\nYou can derive additional traits on the builder, including traits defined by other crates:\n```\n#[derive(Builder, Clone)]\n#[builder(derive(Debug, PartialEq, Eq))]\npub struct Lorem {\n  foo: u8,\n  bar: String,\n}\nfn main() {\n  assert_eq!(LoremBuilder::default(), LoremBuilder::default());\n}\n```\n\nAttributes declared for those traits are _not_ forwarded to the fields on the builder.\n### \u00a7\u27e829\u27e9Documentation Comments and Attributes\n`#[derive(Builder)]` copies doc comments and attributes (`#[...]`) from your fields to the according builder fields and setter-methods, if it is one of the following:\n  * `/// ...`\n  * `#[doc = ...]`\n  * `#[cfg(...)]`\n  * `#[allow(...)]`\n\n\nThe whitelisting minimizes interference with other custom attributes like those used by Serde, Diesel, or others.\n```\n#[derive(Builder)]\nstruct Lorem {\n  /// `ipsum` may be any `String` (be creative).\n  ipsum: String,\n  #[doc = r\"`dolor` is the estimated amount of work.\"]\n  dolor: i32,\n  // `#[derive(Builder)]` understands conditional compilation via cfg-attributes,\n  // i.e. => \"no field = no setter\".\n  #[cfg(target_os = \"macos\")]\n  #[allow(non_snake_case)]\n  Im_a_Mac: bool,\n}\n```\n\n#### \u00a7\u27e830\u27e9Pass-through Attributes\nYou can set attributes on elements of the builder using the `builder_*_attr` attributes:\n  * `builder_struct_attr` adds attributes after `#[derive(...)]` on the builder struct.\n  * `builder_impl_attr` adds attributes on the `impl` block\n  * `builder_field_attr` adds attributes to field declarations in the builder struct.\n  * `builder_setter_attr` adds attributes to the setter in the `impl` block.\n\n\n```\n#[derive(Builder)]\n#[builder(derive(serde::Serialize))]\n#[builder_struct_attr(serde(rename_all = \"camelCase\"))]\nstruct Lorem {\n  #[builder_field_attr(serde(rename=\"dolor\"))]\n  ipsum: String,\n}\nlet mut show = LoremBuilder::default();\nshow.ipsum(\"sit\".into());\nassert_eq!(serde_json::to_string(&show).unwrap(), r#\"{\"dolor\":\"sit\"}\"#);\n```\n\n## \u00a7\u27e831\u27e9Error return type from autogenerated `build` function\nBy default, `build` returns an autogenerated error type:\n```\n#[doc=\"Error type for LoremBuilder\"]\n#[derive(Debug)]\n#[non_exhaustive]\npub enum LoremBuilderError { // where `LoremBuilder` is the name of the builder struct\n  /// Uninitialized field\n  UninitializedField(&'static str),\n  /// Custom validation error\n  ValidationError(String),\n}\nimpl From<String> for LoremBuilderError {\n  fn from(s: String) -> Self { Self::ValidationError(s) }\n}\nimpl From<UninitializedFieldError> for LoremBuilderError { // ...\nimpl Display for LoremBuilderError { // ...\nimpl std::error::Error for LoremBuilderError {}\n```\n\nAlternatively, you can specify your own error type:\n```\n#[derive(Builder, Debug, PartialEq)]\n#[builder(build_fn(error = \"OurLoremError\"))]\nstruct Lorem {\n  pub ipsum: u32,\n}\nstruct OurLoremError(String);\nimpl From<UninitializedFieldError> for OurLoremError {\n  fn from(ufe: UninitializedFieldError) -> OurLoremError { OurLoremError(ufe.to_string()) }\n}\nlet err: OurLoremError = LoremBuilder::default().build().unwrap_err();\nassert_eq!(&err.0, \"Field not initialized: ipsum\");\n```\n\n## \u00a7\u27e832\u27e9Completely custom fields in the builder\nInstead of having an `Option`, you can have whatever type you like:\n```\n#[derive(Debug, PartialEq, Default, Builder, Clone)]\n#[builder(derive(Debug, PartialEq))]\nstruct Lorem {\n  #[builder(setter(into), field(ty = \"u32\"))]\n  ipsum: u32,\n  #[builder(field(ty = \"String\", build = \"()\"))]\n  dolor: (),\n  #[builder(field(ty = \"&'static str\", build = \"self.amet.parse()?\"))]\n  amet: u32,\n}\nimpl From<std::num::ParseIntError> for LoremBuilderError { // ...\nlet mut builder = LoremBuilder::default();\nbuilder.ipsum(42u16).dolor(\"sit\".into()).amet(\"12\");\nassert_eq!(builder, LoremBuilder { ipsum: 42, dolor: \"sit\".into(), amet: \"12\" });\nlet lorem = builder.build().unwrap();\nassert_eq!(lorem, Lorem { ipsum: 42, dolor: (), amet: 12 });\n```\n\nThe builder field type (`ty =`) must implement `Default`.\nThe argument to `build` must be a literal string containing Rust code for the contents of a block, which must evaluate to the type of the target field. It may refer to the builder struct as `self`, use `?`, etc.\n## \u00a7\u27e833\u27e9**`#![no_std]`**Support (on Nightly)\nYou can activate support for `#![no_std]` by adding `#[builder(no_std)]` to your struct and `#![feature(alloc)] extern crate alloc` to your crate.\nThe latter requires the _nightly_ toolchain.\n## \u00a7\u27e834\u27e9Troubleshooting\n### \u00a7\u27e835\u27e9Gotchas\n  * Tuple structs and unit structs are not supported as they have no field names.\n  * Generic setters introduce a type parameter `VALUE: Into<_>`. Therefore you can\u2019t use `VALUE` as a type parameter on a generic struct in combination with generic setters.\n  * The `try_setter` attribute and `owned` builder pattern are not compatible in practice; an error during building will consume the builder, making it impossible to continue construction.\n  * When re-exporting the underlying struct under a different name, the auto-generated documentation will not match.\n  * If derive_builder depends on your crate, and vice versa, then a cyclic dependency would occur. To break it you could try to depend on the `derive_builder_core`\u27e836\u27e9 crate instead.\n\n\n### \u00a7\u27e837\u27e9Report Issues and Ideas\nOpen an issue on GitHub\u27e838\u27e9\nIf possible please try to provide the debugging info if you experience unexpected compilation errors (see above).\n## Structs\u00a7\u27e839\u27e9\n\nUninitializedFieldError\u27e840\u27e9\n    Runtime error when a `build()` method is called and one or more required fields do not have a value.\n## Derive Macros\u00a7\u27e841\u27e9\n\nBuilder\u27e842\u27e9\n    Create a builder struct for the deriving struct.\n",
            "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/derive_builder/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/derive_builder/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/derive_builder/latest/src/derive_builder/lib.rs.html#1-717: Source\n\u27e84\u27e9 https://web.archive.org/web/20170701044756/https://aturon.github.io/ownership/builders.html: builder pattern\n\u27e85\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#quick-start: \u00a7\n\u27e86\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#what-you-write: \u00a7\n\u27e87\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#what-you-get: \u00a7\n\u27e88\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#builder-patterns: \u00a7\n\u27e89\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#owned-aka-consuming: \u00a7\n\u27e810\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#mutable-aka-non-consuming-recommended: \u00a7\n\u27e811\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#immutable: \u00a7\n\u27e812\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#-performance-considerations: \u00a7\n\u27e813\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#more-features: \u00a7\n\u27e814\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#hidden-fields: \u00a7\n\u27e815\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#custom-setters-skip-autogenerated-setters: \u00a7\n\u27e816\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#setter-visibility: \u00a7\n\u27e817\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#generated-builder-struct-name: \u00a7\n\u27e818\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#setter-nameprefix: \u00a7\n\u27e819\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#generic-setters: builder(setter(name = \"foo\"))`.\n  * Alternatively you can set a prefix via `#[builder(setter(prefix = \"xyz\"))`, which will change the method name to `xyz_foo` if the field is named `foo`. Note that an underscore is inserted, since Rust favors snake case here.\n\n\nPrefixes can also be defined on the struct level, but renames only work on fields. Renames take precedence over prefix definitions.\n### [\u00a7\n\u27e820\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#setters-for-option: \u00a7\n\u27e821\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#fallible-setters: \u00a7\n\u27e822\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#default-values: \u00a7\n\u27e823\u27e9 https://doc.rust-lang.org/std/default/trait.Default.html: `Default`\n\u27e824\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#tips-on-defaults: \u00a7\n\u27e825\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#generic-structs: \u00a7\n\u27e826\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#build-method-customization: \u00a7\n\u27e827\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#pre-build-validation: \u00a7\n\u27e828\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#additional-trait-derivations: \u00a7\n\u27e829\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#documentation-comments-and-attributes: \u00a7\n\u27e830\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#pass-through-attributes: \u00a7\n\u27e831\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#error-return-type-from-autogenerated-build-function: \u00a7\n\u27e832\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#completely-custom-fields-in-the-builder: \u00a7\n\u27e833\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#no_std-support-on-nightly: \u00a7\n\u27e834\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#troubleshooting: \u00a7\n\u27e835\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#gotchas: \u00a7\n\u27e836\u27e9 https://crates.io/crates/derive_builder_core: `derive_builder_core`\n\u27e837\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#report-issues-and-ideas: \u00a7\n\u27e838\u27e9 https://github.com/colin-kiegel/rust-derive-builder/issues: Open an issue on GitHub\n\u27e839\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#structs: \u00a7\n\u27e840\u27e9 https://docs.rs/derive_builder/latest/derive_builder/struct.UninitializedFieldError.html: struct derive_builder::UninitializedFieldError - UninitializedFieldError\n\u27e841\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#derives: \u00a7\n\u27e842\u27e9 https://docs.rs/derive_builder/latest/derive_builder/derive.Builder.html: derive derive_builder::Builder - Builder\n",
            "fit_markdown": "",
            "fit_html": ""
          },
          "downloads": 0,
          "github_stars": 0,
          "dependencies": [],
          "features": {},
          "code_snippets": [],
          "readme_sections": {},
          "librs_downloads": null,
          "source": "crates.io",
          "enhanced_scraping": {},
          "enhanced_features": [],
          "enhanced_dependencies": [],
          "readme_summary": "The `derive_builder` crate automates the implementation of the builder pattern for structs in Rust, generating a `FooBuilder` with setter methods for fields and a `build` method to construct the original struct. It supports customizable builder patterns (`mutable`, `owned`, `immutable`), conditional field initialization, hidden fields, and custom setters. The crate ensures ergonomic chaining of method calls and provides error handling for uninitialized fields.",
          "feature_summary": null,
          "use_case": "Utilities",
          "score": 7.0,
          "factual_counterfactual": "### Pair 1: Builder Pattern and Setter Methods\n\u2705 **Factual**: The `derive_builder` crate generates setter methods that take and return `&mut self` by default, enabling a non-consuming builder pattern where method calls can be chained or applied conditionally without reassigning the builder object.  \n\u274c **Counterfactual**: The `derive_builder` crate only supports consuming setter methods that take and return `self`, making chaining method calls mandatory and disallowing conditional setter calls without reassignment.\n\n---\n\n### Pair 2: Error Handling in Build Method\n\u2705 **Factual**: The `build` method generated by `derive_builder` returns a `Result<T, E>`, where `E` is a custom error type that indicates uninitialized fields, allowing for safe construction of structs.  \n\u274c **Counterfactual**: The `build` method generated by `derive_builder` always panics if a required field is uninitialized, and does not provide an error type for handling these cases programmatically.\n\n---\n\n### Pair 3: Performance Optimization for Clone Calls\n\u2705 **Factual**: Rust's compiler optimizes away unnecessary `clone` calls in release builds for common use cases with the `derive_builder` crate, ensuring efficient performance even when using non-consuming patterns.  \n\u274c **Counterfactual**: The `derive_builder` crate's reliance on `clone` calls in the build method leads to significant runtime overhead in release builds, making",
          "source_analysis": null,
          "user_behavior": null,
          "security": null
        }
      },
      "irl_score": 8.6,
      "execution_id": "exec-b99631cf-f2545de4-1751263930",
      "timestamp": "2025-06-30T06:12:10.486404+00:00",
      "canon_version": "1.3.0"
    },
    "rule_zero_compliant": true
  }
]