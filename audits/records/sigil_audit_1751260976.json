[
  {
    "execution_id": "exec-efacd25c-c8be97ae-1751260969",
    "timestamp": "2025-06-30T05:22:49.120028+00:00",
    "sacred_chain": {
      "input_data": "seahash",
      "context_sources": [
        "crates.io",
        "github.com",
        "lib.rs",
        "docs.rs"
      ],
      "reasoning_steps": [
        "Input canonicalized: 'seahash' -> 'seahash'",
        "Context gathered from 4 validated sources",
        "Metadata extracted: 4 fields",
        "Documentation analyzed: quality 7.0",
        "Sentiment analyzed: positive",
        "Ecosystem analyzed: utilities",
        "Quality score synthesized: 7.50",
        "Trust decision: DEFER - Insufficient data for decision",
        "IRL confidence: 8.600"
      ],
      "suggestion": "ALLOW: Positive community sentiment",
      "verdict": "DEFER",
      "audit_info": {
        "metadata": {
          "name": "seahash",
          "type": "rust_crate",
          "source": "manual_input",
          "extraction_method": "irl_engine"
        },
        "sentiment": {
          "quality_score": 7.0,
          "completeness": 0.8,
          "examples_present": true,
          "api_documented": true
        },
        "ecosystem": {
          "overall": "positive",
          "positive_mentions": 10,
          "negative_mentions": 2,
          "neutral_mentions": 5,
          "total_mentions": 17
        },
        "quality_score": 7.5,
        "verdict_reason": "Insufficient data for decision",
        "sanitized_documentation": {
          "crates_io": {
            "url": "https://crates.io/crates/seahash",
            "title": "seahash v4.1.0",
            "content": {
              "raw_markdown": "#  seahash v4.1.0\nA blazingly fast, portable hash function with proven statistical guarantees. \n  * [ #checksumming ](https://crates.io/keywords/checksumming)\n  * [ #checksum ](https://crates.io/keywords/checksum)\n  * [ #hashing ](https://crates.io/keywords/hashing)\n  * [ #hash ](https://crates.io/keywords/hash)\n  * [ #portable ](https://crates.io/keywords/portable)\n\n\n  * [ Readme ](https://crates.io/crates/seahash)\n  * [ 20 Versions ](https://crates.io/crates/seahash/versions)\n  * [ Dependencies ](https://crates.io/crates/seahash/dependencies)\n  * [ Dependents ](https://crates.io/crates/seahash/reverse_dependencies)\n\n\n## Metadata\nover 4 years ago \n[ MIT ](https://choosealicense.com/licenses/mit)\n31.2 KiB \n## Install\nRun the following Cargo command in your project directory:\ncargo add seahash\nOr add the following line to your Cargo.toml:\nseahash = \"4.1.0\"\n## Documentation\n[ docs.rs/seahash ](https://docs.rs/seahash)\n## Repository\n[ gitlab.redox-os.org/redox-os/seahash ](https://gitlab.redox-os.org/redox-os/seahash)\n## Owners\n[ Report crate ](https://crates.io/support?crate=seahash&inquire=crate-violation)\n### Stats Overview\n50,390,963 Downloads all time\n20 Versions published\n#### Downloads over the last 90 days\nDisplay as \nStacked \n  * Stacked \n  * Unstacked \n\n\nLoading\u2026\n",
              "markdown_with_citations": "#  seahash v4.1.0\nA blazingly fast, portable hash function with proven statistical guarantees. \n  *  #checksumming \u27e81\u27e9\n  *  #checksum \u27e82\u27e9\n  *  #hashing \u27e83\u27e9\n  *  #hash \u27e84\u27e9\n  *  #portable \u27e85\u27e9\n\n\n  *  Readme \u27e86\u27e9\n  *  20 Versions \u27e87\u27e9\n  *  Dependencies \u27e88\u27e9\n  *  Dependents \u27e89\u27e9\n\n\n## Metadata\nover 4 years ago \n MIT \u27e810\u27e9\n31.2 KiB \n## Install\nRun the following Cargo command in your project directory:\ncargo add seahash\nOr add the following line to your Cargo.toml:\nseahash = \"4.1.0\"\n## Documentation\n docs.rs/seahash \u27e811\u27e9\n## Repository\n gitlab.redox-os.org/redox-os/seahash \u27e812\u27e9\n## Owners\n Report crate \u27e813\u27e9\n### Stats Overview\n50,390,963 Downloads all time\n20 Versions published\n#### Downloads over the last 90 days\nDisplay as \nStacked \n  * Stacked \n  * Unstacked \n\n\nLoading\u2026\n",
              "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://crates.io/keywords/checksumming:  #checksumming \n\u27e82\u27e9 https://crates.io/keywords/checksum:  #checksum \n\u27e83\u27e9 https://crates.io/keywords/hashing:  #hashing \n\u27e84\u27e9 https://crates.io/keywords/hash:  #hash \n\u27e85\u27e9 https://crates.io/keywords/portable:  #portable \n\u27e86\u27e9 https://crates.io/crates/seahash:  Readme \n\u27e87\u27e9 https://crates.io/crates/seahash/versions:  20 Versions \n\u27e88\u27e9 https://crates.io/crates/seahash/dependencies:  Dependencies \n\u27e89\u27e9 https://crates.io/crates/seahash/reverse_dependencies:  Dependents \n\u27e810\u27e9 https://choosealicense.com/licenses/mit:  MIT \n\u27e811\u27e9 https://docs.rs/seahash:  docs.rs/seahash \n\u27e812\u27e9 https://gitlab.redox-os.org/redox-os/seahash:  gitlab.redox-os.org/redox-os/seahash \n\u27e813\u27e9 https://crates.io/support?crate=seahash&inquire=crate-violation:  Report crate \n",
              "fit_markdown": "",
              "fit_html": ""
            },
            "structured_data": {},
            "quality_score": 3.0,
            "extraction_method": "crawl4ai",
            "error": null,
            "metadata": {
              "doc_type": "docs",
              "content_length": 1291,
              "has_structured_data": false,
              "crawl_success": true
            },
            "timestamp": "114758.8951592"
          },
          "docs_rs": {
            "url": "https://docs.rs/seahash",
            "title": "Crate seahashCopy item path",
            "content": {
              "raw_markdown": "[](https://docs.rs/seahash/latest/seahash/all.html \"show sidebar\")\n# Crate seahashCopy item path\n[Settings](https://docs.rs/seahash/latest/settings.html)\n[Help](https://docs.rs/seahash/latest/help.html)\nSummary[Source](https://docs.rs/seahash/latest/src/seahash/lib.rs.html#1-168)\nExpand description\nSeaHash: A blazingly fast, portable hash function with proven statistical guarantees.\nSeaHash is a hash function with performance better than (around 3-20% improvement) xxHash and MetroHash. Furthermore, SeaHash has mathematically provable statistical guarantees.\nSeaHash is a portable hash function, meaning that the output is not dependent on the hosting architecture, and makes no assumptions on endianness or the alike. This stable layout allows it to be used for on-disk/permanent storage (e.g. checksums).\n## [\u00a7](https://docs.rs/seahash/latest/seahash/#design-advantages-and-features)Design, advantages, and features\n  * **High quality** : It beats most other general purpose hash functions because it provides full avalanche inbetween state updates.\n  * **Performance** : SeaHash beats every high-quality (grading 10/10 in smhasher) hash function that I know of.\n  * **Provable quality guarantees** : Contrary to most other non-cryptographic hash function, SeaHash can be proved to satisfy the avalanche criterion as well as BIC.\n  * **Parallelizable** : Consists of multiple, independent states to take advantage of ILP and/or software threads.\n  * **Bulk reads** : Reads 8 or 4 bytes a time.\n  * **Stable and portable** : Does not depend on the target architecture, and produces a stable value, which is only changed in major version bumps.\n  * **Keyed** : Designed to not leak the seed/key. Note that it has not gone through cryptoanalysis yet, so the keyed version shouldn\u2019t be relied on when security is needed.\n  * **Hardware accelerateable** : SeaHash is designed such that ASICs can implement it with really high performance.\n\n\n## [\u00a7](https://docs.rs/seahash/latest/seahash/#a-word-of-warning)A word of warning!\nThis is **not** a cryptographic function, and it certainly should not be used as one. If you want a good cryptographic hash function, you should use SHA-3 (Keccak) or BLAKE2.\nIt is not secure, nor does it aim to be. It aims to have high quality pseudorandom output and few collisions, as well as being fast.\n## [\u00a7](https://docs.rs/seahash/latest/seahash/#benchmark)Benchmark\nOn normal hardware, it is expected to run with a rate around 5.9-6.7 GB/S on a 2.5 GHz CPU. Further improvement can be seen when hashing very big buffers in parallel.\nFunction| Quality| Cycles per byte (lower is better)| Author  \n---|---|---|---  \n**SeaHash**| **Excellent**| **0.24**| **Ticki**  \nxxHash| Excellent| 0.31| Collet  \nMetroHash| Excellent| 0.35| Rogers  \nMurmur| Excellent| 0.64| Appleby  \nRabin| Medium| 1.51| Rabin  \nCityHash| Excellent| 1.62| Pike, Alakuijala  \nLoseLose| Terrible| 2.01| Kernighan, Ritchie  \nFNV| Poor| 3.12| Fowler, Noll, Vo  \nSipHash| Pseudorandom| 3.21| Aumasson, Bernstein  \nCRC| Good| 3.91| Peterson  \nDJB2| Poor| 4.13| Bernstein  \n### [\u00a7](https://docs.rs/seahash/latest/seahash/#ideal-architecture)Ideal architecture\nSeaHash is designed and optimized for the most common architecture in use:\n  * Little-endian\n  * 64-bit\n  * 64 or more bytes cache lines\n  * 4 or more instruction pipelines\n  * 4 or more 64-bit registers\n\n\nAnything that does not hold the above requirements will perform worse by up to 30-40%. Note that this means it is still faster than CityHash (~1 GB/S), MurMurHash (~2.6 GB/S), FNV (~0.5 GB/S), etc.\n## [\u00a7](https://docs.rs/seahash/latest/seahash/#achieving-the-performance)Achieving the performance\nLike any good general-purpose hash function, SeaHash reads 8 bytes at once effectively reducing the running time by an order of ~5.\nSecondly, SeaHash achieves the performance by heavily exploiting Instruction-Level Parallelism. In particular, it fetches 4 integers in every round and independently diffuses them. This yields four different states, which are finally combined.\n## [\u00a7](https://docs.rs/seahash/latest/seahash/#statistical-guarantees)Statistical guarantees\nSeaHash comes with certain proven guarantees about the statistical properties of the output:\n  1. Pick some _n_ -byte sequence, _s_. The number of _n_ -byte sequence colliding with _s_ is independent of the choice of _s_ (all equivalence class have equal size).\n  2. If you flip any bit in the input, the probability for any bit in the output to be flipped is 0.5.\n  3. The hash value of a sequence of uniformly distributed bytes is itself uniformly distributed.\n\n\nThe first guarantee can be derived through deduction, by proving that the diffusion function is bijective (reverse the XORs and find the congruence inverses to the primes).\nThe second guarantee requires more complex calculations: Construct a matrix of probabilities and set one to certain (1), then apply transformations through the respective operations. The proof is a bit long, but relatively simple.\nThe third guarantee requires proving that the hash value is a tree, such that:\n  * Leafs represents the input values.\n  * Single-child nodes reduce to the diffusion of the child.\n  * Multiple-child nodes reduce to the sum of the children.\n\n\nThen simply show that each of these reductions transform uniformly distributed variables to uniformly distributed variables.\n## [\u00a7](https://docs.rs/seahash/latest/seahash/#inner-workings)Inner workings\nIn technical terms, SeaHash follows a alternating 4-state length-padded Merkle\u2013Damg\u00e5rd construction with an XOR-diffuse compression function (click to enlarge):\n[![A diagram.](http://ticki.github.io/img/seahash_construction_diagram.svg)] (http://ticki.github.io/img/seahash_construction_diagram.svg)\nIt starts with 4 initial states, then it alternates between them (increment, wrap on 4) and does XOR with the respective block. When a state has been visited the diffusion function (f) is applied. The very last block is padded with zeros.\nAfter all the blocks have been gone over, all the states are XOR\u2019d to the number of bytes written. The sum is then passed through the diffusion function, which produces the final hash value.\nThe diffusion function is drawn below.\n```\nx \u2190 px\nx \u2190 x \u2295 ((x \u226b 32) \u226b (x \u226b 60))\nx \u2190 px\n```\n\nThe advantage of having four completely segregated (note that there is no mix round, so they\u2019re entirely independent) states is that fast parallelism is possible. For example, if I were to hash 1 TB, I can spawn up four threads which can run independently without _any_ intercommunication or synchronization before the last round.\nIf the diffusion function (f) was cryptographically secure, it would pass cryptoanalysis trivially. This might seem irrelevant, as it clearly isn\u2019t cryptographically secure, but it tells us something about the inner semantics. In particular, any diffusion function with sufficient statistical quality will make up a good hash function in this construction.\nRead [the blog post](http://ticki.github.io/blog/seahash-explained/) for more details.\n## [\u00a7](https://docs.rs/seahash/latest/seahash/#asic-version)ASIC version\nSeaHash is specifically designed such that it can be efficiently implemented in the form of ASIC while only using very few transistors.\n## [\u00a7](https://docs.rs/seahash/latest/seahash/#specification)Specification\nSee the [`reference`](https://docs.rs/seahash/latest/seahash/reference) module.\n## [\u00a7](https://docs.rs/seahash/latest/seahash/#credits)Credits\nAside for myself (@ticki), there are couple of other people who have helped creating this. Joshua Landau suggested using the [PCG family of diffusions](http://www.pcg-random.org/), created by Melissa E. O\u2019Neill. Sokolov Yura spotted multiple bugs in SeaHash.\n## Modules[\u00a7](https://docs.rs/seahash/latest/seahash/#modules)\n\n[reference](https://docs.rs/seahash/latest/seahash/reference/index.html \"mod seahash::reference\")\n    A slow, but clear reference implementation of SeaHash.\n## Structs[\u00a7](https://docs.rs/seahash/latest/seahash/#structs)\n\n[SeaHasher](https://docs.rs/seahash/latest/seahash/struct.SeaHasher.html \"struct seahash::SeaHasher\")\n    The streaming version of the algorithm.\n\n[State](https://docs.rs/seahash/latest/seahash/struct.State.html \"struct seahash::State\")\n    A SeaHash state.\n## Functions[\u00a7](https://docs.rs/seahash/latest/seahash/#functions)\n\n[hash](https://docs.rs/seahash/latest/seahash/fn.hash.html \"fn seahash::hash\")\n    Hash some buffer.\n\n[hash_seeded](https://docs.rs/seahash/latest/seahash/fn.hash_seeded.html \"fn seahash::hash_seeded\")\n    Hash some buffer according to a chosen seed.\n",
              "markdown_with_citations": "[](https://docs.rs/seahash/latest/seahash/all.html \"show sidebar\")\n# Crate seahashCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nSeaHash: A blazingly fast, portable hash function with proven statistical guarantees.\nSeaHash is a hash function with performance better than (around 3-20% improvement) xxHash and MetroHash. Furthermore, SeaHash has mathematically provable statistical guarantees.\nSeaHash is a portable hash function, meaning that the output is not dependent on the hosting architecture, and makes no assumptions on endianness or the alike. This stable layout allows it to be used for on-disk/permanent storage (e.g. checksums).\n## \u00a7\u27e84\u27e9Design, advantages, and features\n  * **High quality** : It beats most other general purpose hash functions because it provides full avalanche inbetween state updates.\n  * **Performance** : SeaHash beats every high-quality (grading 10/10 in smhasher) hash function that I know of.\n  * **Provable quality guarantees** : Contrary to most other non-cryptographic hash function, SeaHash can be proved to satisfy the avalanche criterion as well as BIC.\n  * **Parallelizable** : Consists of multiple, independent states to take advantage of ILP and/or software threads.\n  * **Bulk reads** : Reads 8 or 4 bytes a time.\n  * **Stable and portable** : Does not depend on the target architecture, and produces a stable value, which is only changed in major version bumps.\n  * **Keyed** : Designed to not leak the seed/key. Note that it has not gone through cryptoanalysis yet, so the keyed version shouldn\u2019t be relied on when security is needed.\n  * **Hardware accelerateable** : SeaHash is designed such that ASICs can implement it with really high performance.\n\n\n## \u00a7\u27e85\u27e9A word of warning!\nThis is **not** a cryptographic function, and it certainly should not be used as one. If you want a good cryptographic hash function, you should use SHA-3 (Keccak) or BLAKE2.\nIt is not secure, nor does it aim to be. It aims to have high quality pseudorandom output and few collisions, as well as being fast.\n## \u00a7\u27e86\u27e9Benchmark\nOn normal hardware, it is expected to run with a rate around 5.9-6.7 GB/S on a 2.5 GHz CPU. Further improvement can be seen when hashing very big buffers in parallel.\nFunction| Quality| Cycles per byte (lower is better)| Author  \n---|---|---|---  \n**SeaHash**| **Excellent**| **0.24**| **Ticki**  \nxxHash| Excellent| 0.31| Collet  \nMetroHash| Excellent| 0.35| Rogers  \nMurmur| Excellent| 0.64| Appleby  \nRabin| Medium| 1.51| Rabin  \nCityHash| Excellent| 1.62| Pike, Alakuijala  \nLoseLose| Terrible| 2.01| Kernighan, Ritchie  \nFNV| Poor| 3.12| Fowler, Noll, Vo  \nSipHash| Pseudorandom| 3.21| Aumasson, Bernstein  \nCRC| Good| 3.91| Peterson  \nDJB2| Poor| 4.13| Bernstein  \n### \u00a7\u27e87\u27e9Ideal architecture\nSeaHash is designed and optimized for the most common architecture in use:\n  * Little-endian\n  * 64-bit\n  * 64 or more bytes cache lines\n  * 4 or more instruction pipelines\n  * 4 or more 64-bit registers\n\n\nAnything that does not hold the above requirements will perform worse by up to 30-40%. Note that this means it is still faster than CityHash (~1 GB/S), MurMurHash (~2.6 GB/S), FNV (~0.5 GB/S), etc.\n## \u00a7\u27e88\u27e9Achieving the performance\nLike any good general-purpose hash function, SeaHash reads 8 bytes at once effectively reducing the running time by an order of ~5.\nSecondly, SeaHash achieves the performance by heavily exploiting Instruction-Level Parallelism. In particular, it fetches 4 integers in every round and independently diffuses them. This yields four different states, which are finally combined.\n## \u00a7\u27e89\u27e9Statistical guarantees\nSeaHash comes with certain proven guarantees about the statistical properties of the output:\n  1. Pick some _n_ -byte sequence, _s_. The number of _n_ -byte sequence colliding with _s_ is independent of the choice of _s_ (all equivalence class have equal size).\n  2. If you flip any bit in the input, the probability for any bit in the output to be flipped is 0.5.\n  3. The hash value of a sequence of uniformly distributed bytes is itself uniformly distributed.\n\n\nThe first guarantee can be derived through deduction, by proving that the diffusion function is bijective (reverse the XORs and find the congruence inverses to the primes).\nThe second guarantee requires more complex calculations: Construct a matrix of probabilities and set one to certain (1), then apply transformations through the respective operations. The proof is a bit long, but relatively simple.\nThe third guarantee requires proving that the hash value is a tree, such that:\n  * Leafs represents the input values.\n  * Single-child nodes reduce to the diffusion of the child.\n  * Multiple-child nodes reduce to the sum of the children.\n\n\nThen simply show that each of these reductions transform uniformly distributed variables to uniformly distributed variables.\n## \u00a7\u27e810\u27e9Inner workings\nIn technical terms, SeaHash follows a alternating 4-state length-padded Merkle\u2013Damg\u00e5rd construction with an XOR-diffuse compression function (click to enlarge):\n![A diagram.\u27e811\u27e9] (http://ticki.github.io/img/seahash_construction_diagram.svg)\nIt starts with 4 initial states, then it alternates between them (increment, wrap on 4) and does XOR with the respective block. When a state has been visited the diffusion function (f) is applied. The very last block is padded with zeros.\nAfter all the blocks have been gone over, all the states are XOR\u2019d to the number of bytes written. The sum is then passed through the diffusion function, which produces the final hash value.\nThe diffusion function is drawn below.\n```\nx \u2190 px\nx \u2190 x \u2295 ((x \u226b 32) \u226b (x \u226b 60))\nx \u2190 px\n```\n\nThe advantage of having four completely segregated (note that there is no mix round, so they\u2019re entirely independent) states is that fast parallelism is possible. For example, if I were to hash 1 TB, I can spawn up four threads which can run independently without _any_ intercommunication or synchronization before the last round.\nIf the diffusion function (f) was cryptographically secure, it would pass cryptoanalysis trivially. This might seem irrelevant, as it clearly isn\u2019t cryptographically secure, but it tells us something about the inner semantics. In particular, any diffusion function with sufficient statistical quality will make up a good hash function in this construction.\nRead the blog post\u27e812\u27e9 for more details.\n## \u00a7\u27e813\u27e9ASIC version\nSeaHash is specifically designed such that it can be efficiently implemented in the form of ASIC while only using very few transistors.\n## \u00a7\u27e814\u27e9Specification\nSee the `reference`\u27e815\u27e9 module.\n## \u00a7\u27e816\u27e9Credits\nAside for myself (@ticki), there are couple of other people who have helped creating this. Joshua Landau suggested using the PCG family of diffusions\u27e817\u27e9, created by Melissa E. O\u2019Neill. Sokolov Yura spotted multiple bugs in SeaHash.\n## Modules\u00a7\u27e818\u27e9\n\nreference\u27e819\u27e9\n    A slow, but clear reference implementation of SeaHash.\n## Structs\u00a7\u27e820\u27e9\n\nSeaHasher\u27e821\u27e9\n    The streaming version of the algorithm.\n\nState\u27e822\u27e9\n    A SeaHash state.\n## Functions\u00a7\u27e823\u27e9\n\nhash\u27e824\u27e9\n    Hash some buffer.\n\nhash_seeded\u27e825\u27e9\n    Hash some buffer according to a chosen seed.\n",
              "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/seahash/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/seahash/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/seahash/latest/src/seahash/lib.rs.html#1-168: Source\n\u27e84\u27e9 https://docs.rs/seahash/latest/seahash/#design-advantages-and-features: \u00a7\n\u27e85\u27e9 https://docs.rs/seahash/latest/seahash/#a-word-of-warning: \u00a7\n\u27e86\u27e9 https://docs.rs/seahash/latest/seahash/#benchmark: \u00a7\n\u27e87\u27e9 https://docs.rs/seahash/latest/seahash/#ideal-architecture: \u00a7\n\u27e88\u27e9 https://docs.rs/seahash/latest/seahash/#achieving-the-performance: \u00a7\n\u27e89\u27e9 https://docs.rs/seahash/latest/seahash/#statistical-guarantees: \u00a7\n\u27e810\u27e9 https://docs.rs/seahash/latest/seahash/#inner-workings: \u00a7\n\u27e811\u27e9 http://ticki.github.io/img/seahash_construction_diagram.svg: ![A diagram.\n\u27e812\u27e9 http://ticki.github.io/blog/seahash-explained/: the blog post\n\u27e813\u27e9 https://docs.rs/seahash/latest/seahash/#asic-version: \u00a7\n\u27e814\u27e9 https://docs.rs/seahash/latest/seahash/#specification: \u00a7\n\u27e815\u27e9 https://docs.rs/seahash/latest/seahash/reference: `reference`\n\u27e816\u27e9 https://docs.rs/seahash/latest/seahash/#credits: \u00a7\n\u27e817\u27e9 http://www.pcg-random.org/: PCG family of diffusions\n\u27e818\u27e9 https://docs.rs/seahash/latest/seahash/#modules: \u00a7\n\u27e819\u27e9 https://docs.rs/seahash/latest/seahash/reference/index.html: mod seahash::reference - reference\n\u27e820\u27e9 https://docs.rs/seahash/latest/seahash/#structs: \u00a7\n\u27e821\u27e9 https://docs.rs/seahash/latest/seahash/struct.SeaHasher.html: struct seahash::SeaHasher - SeaHasher\n\u27e822\u27e9 https://docs.rs/seahash/latest/seahash/struct.State.html: struct seahash::State - State\n\u27e823\u27e9 https://docs.rs/seahash/latest/seahash/#functions: \u00a7\n\u27e824\u27e9 https://docs.rs/seahash/latest/seahash/fn.hash.html: fn seahash::hash - hash\n\u27e825\u27e9 https://docs.rs/seahash/latest/seahash/fn.hash_seeded.html: fn seahash::hash_seeded - hash_seeded\n",
              "fit_markdown": "",
              "fit_html": ""
            },
            "structured_data": {},
            "quality_score": 4.0,
            "extraction_method": "crawl4ai",
            "error": null,
            "metadata": {
              "doc_type": "docs",
              "content_length": 8588,
              "has_structured_data": false,
              "crawl_success": true
            },
            "timestamp": "114759.8078312"
          },
          "lib_rs": {
            "url": "https://lib.rs/crates/seahash",
            "title": "Untitled",
            "content": {
              "raw_markdown": "###  [18 stable releases](https://lib.rs/crates/seahash/versions) (4 major)\nUses old Rust 2015\n4.1.0 |  Jan 16, 2021   \n---|---  \n4.0.1 |  Jun 27, 2020   \n4.0.0 |  Jan 31, 2020   \n3.0.7 |  Jan 28, 2020   \n0.2.0 |  Nov 20, 2016   \n#**63** in [Algorithms](https://lib.rs/algorithms \"Rust implementations of core algorithms such as hashing, sorting, searching, and more.\")\nDownload history 770694/week @ 2025-03-07 757966/week @ 2025-03-14 714664/week @ 2025-03-21 706110/week @ 2025-03-28 730511/week @ 2025-04-04 710768/week @ 2025-04-11 671683/week @ 2025-04-18 641742/week @ 2025-04-25 640562/week @ 2025-05-02 696840/week @ 2025-05-09 718311/week @ 2025-05-16 623902/week @ 2025-05-23 703197/week @ 2025-05-30 728283/week @ 2025-06-06 761792/week @ 2025-06-13 775770/week @ 2025-06-20\n**3,090,068** downloads per month Used in [**1,628** crates (120 directly)](https://lib.rs/crates/seahash/rev)\n**MIT** license \n44KB  689 lines\n![Logo](https://img.gs/czjpqfbdkz/200,2x/https://gitlab.redox-os.org/redox-os/logo.png)\n=================== \nSeaHash: A bizarrely fast hash function.\nSeaHash is a hash function with performance better than (around 3-20% improvement) xxHash and MetroHash. Furthermore, SeaHash has mathematically provable statistical guarantees.\nIn action:\n[![The hash function in action.](https://img.gs/czjpqfbdkz/800/http://ticki.github.io/img/seahash_construction_diagram.svg)](http://ticki.github.io/img/seahash_construction_diagram.svg)\n###  [`lib.rs`](https://docs.rs/seahash): \nSeaHash: A blazingly fast, portable hash function with proven statistical guarantees.\nSeaHash is a hash function with performance better than (around 3-20% improvement) xxHash and MetroHash. Furthermore, SeaHash has mathematically provable statistical guarantees.\nSeaHash is a portable hash function, meaning that the output is not dependent on the hosting architecture, and makes no assumptions on endianness or the alike. This stable layout allows it to be used for on-disk/permanent storage (e.g. checksums).\n# Design, advantages, and features\n  * **High quality** : It beats most other general purpose hash functions because it provides full avalanche inbetween state updates.\n  * **Performance** : SeaHash beats every high-quality (grading 10/10 in smhasher) hash function that I know of.\n  * **Provable quality guarantees** : Contrary to most other non-cryptographic hash function, SeaHash can be proved to satisfy the avalanche criterion as well as BIC.\n  * **Parallelizable** : Consists of multiple, independent states to take advantage of ILP and/or software threads.\n  * **Bulk reads** : Reads 8 or 4 bytes a time.\n  * **Stable and portable** : Does not depend on the target architecture, and produces a stable value, which is only changed in major version bumps.\n  * **Keyed** : Designed to not leak the seed/key. Note that it has not gone through cryptoanalysis yet, so the keyed version shouldn't be relied on when security is needed.\n  * **Hardware accelerateable** : SeaHash is designed such that ASICs can implement it with really high performance.\n\n\n# A word of warning!\nThis is **not** a cryptographic function, and it certainly should not be used as one. If you want a good cryptographic hash function, you should use SHA-3 (Keccak) or BLAKE2.\nIt is not secure, nor does it aim to be. It aims to have high quality pseudorandom output and few collisions, as well as being fast.\n# Benchmark\nOn normal hardware, it is expected to run with a rate around 5.9-6.7 GB/S on a 2.5 GHz CPU. Further improvement can be seen when hashing very big buffers in parallel.\nFunction | Quality | Cycles per byte (lower is better) | Author  \n---|---|---|---  \n**SeaHash** | **Excellent** | **0.24** | **Ticki**  \nxxHash | Excellent | 0.31 | Collet  \nMetroHash | Excellent | 0.35 | Rogers  \nMurmur | Excellent | 0.64 | Appleby  \nRabin | Medium | 1.51 | Rabin  \nCityHash | Excellent | 1.62 | Pike, Alakuijala  \nLoseLose | Terrible | 2.01 | Kernighan, Ritchie  \nFNV | Poor | 3.12 | Fowler, Noll, Vo  \nSipHash | Pseudorandom | 3.21 | Aumasson, Bernstein  \nCRC | Good | 3.91 | Peterson  \nDJB2 | Poor | 4.13 | Bernstein  \n## Ideal architecture\nSeaHash is designed and optimized for the most common architecture in use:\n  * Little-endian\n  * 64-bit\n  * 64 or more bytes cache lines\n  * 4 or more instruction pipelines\n  * 4 or more 64-bit registers\n\n\nAnything that does not hold the above requirements will perform worse by up to 30-40%. Note that this means it is still faster than CityHash (~1 GB/S), MurMurHash (~2.6 GB/S), FNV (~0.5 GB/S), etc.\n# Achieving the performance\nLike any good general-purpose hash function, SeaHash reads 8 bytes at once effectively reducing the running time by an order of ~5.\nSecondly, SeaHash achieves the performance by heavily exploiting Instruction-Level Parallelism. In particular, it fetches 4 integers in every round and independently diffuses them. This yields four different states, which are finally combined.\n# Statistical guarantees\nSeaHash comes with certain proven guarantees about the statistical properties of the output:\n  1. Pick some _n_ -byte sequence, _s_. The number of _n_ -byte sequence colliding with _s_ is independent of the choice of _s_ (all equivalence class have equal size).\n  2. If you flip any bit in the input, the probability for any bit in the output to be flipped is 0.5.\n  3. The hash value of a sequence of uniformly distributed bytes is itself uniformly distributed.\n\n\nThe first guarantee can be derived through deduction, by proving that the diffusion function is bijective (reverse the XORs and find the congruence inverses to the primes).\nThe second guarantee requires more complex calculations: Construct a matrix of probabilities and set one to certain (1), then apply transformations through the respective operations. The proof is a bit long, but relatively simple.\nThe third guarantee requires proving that the hash value is a tree, such that:\n  * Leafs represents the input values.\n  * Single-child nodes reduce to the diffusion of the child.\n  * Multiple-child nodes reduce to the sum of the children.\n\n\nThen simply show that each of these reductions transform uniformly distributed variables to uniformly distributed variables.\n# Inner workings\nIn technical terms, SeaHash follows a alternating 4-state length-padded Merkle\u2013Damg\u00e5rd construction with an XOR-diffuse compression function (click to enlarge):\n[![A diagram.](https://img.gs/czjpqfbdkz/800/http://ticki.github.io/img/seahash_construction_diagram.svg)] (<http://ticki.github.io/img/seahash_construction_diagram.svg>)\nIt starts with 4 initial states, then it alternates between them (increment, wrap on 4) and does XOR with the respective block. When a state has been visited the diffusion function (f) is applied. The very last block is padded with zeros.\nAfter all the blocks have been gone over, all the states are XOR'd to the number of bytes written. The sum is then passed through the diffusion function, which produces the final hash value.\nThe diffusion function is drawn below.\n```\n`x \u2190 px\nx \u2190 x \u2295 `(``(`x \u226b `32``)` \u226b `(`x \u226b `60``)``)`\nx \u2190 px\n`\n```\n\nThe advantage of having four completely segregated (note that there is no mix round, so they're entirely independent) states is that fast parallelism is possible. For example, if I were to hash 1 TB, I can spawn up four threads which can run independently without _any_ intercommunication or synchronization before the last round.\nIf the diffusion function (f) was cryptographically secure, it would pass cryptoanalysis trivially. This might seem irrelevant, as it clearly isn't cryptographically secure, but it tells us something about the inner semantics. In particular, any diffusion function with sufficient statistical quality will make up a good hash function in this construction.\nRead [the blog post](http://ticki.github.io/blog/seahash-explained/) for more details.\n# ASIC version\nSeaHash is specifically designed such that it can be efficiently implemented in the form of ASIC while only using very few transistors.\n# Specification\nSee the [``reference``](https://docs.rs/seahash/4.1.0/reference) module.\n# Credits\nAside for myself (@ticki), there are couple of other people who have helped creating this. Joshua Landau suggested using the [PCG family of diffusions](http://www.pcg-random.org/), created by Melissa E. O'Neill. Sokolov Yura spotted multiple bugs in SeaHash.\n#### No runtime deps\n  * dev  [criterion](https://lib.rs/crates/criterion \"obsolete\") 0.3\n  * dev  [quickcheck](https://lib.rs/crates/quickcheck \"obsolete\") 0.9.2\n\n\n#### [Other feature](https://lib.rs/crates/seahash/features)\n  * [use_std](https://lib.rs/crates/seahash/features#feature-use_std)\n\n\n",
              "markdown_with_citations": "###  18 stable releases\u27e81\u27e9 (4 major)\nUses old Rust 2015\n4.1.0 |  Jan 16, 2021   \n---|---  \n4.0.1 |  Jun 27, 2020   \n4.0.0 |  Jan 31, 2020   \n3.0.7 |  Jan 28, 2020   \n0.2.0 |  Nov 20, 2016   \n#**63** in Algorithms\u27e82\u27e9\nDownload history 770694/week @ 2025-03-07 757966/week @ 2025-03-14 714664/week @ 2025-03-21 706110/week @ 2025-03-28 730511/week @ 2025-04-04 710768/week @ 2025-04-11 671683/week @ 2025-04-18 641742/week @ 2025-04-25 640562/week @ 2025-05-02 696840/week @ 2025-05-09 718311/week @ 2025-05-16 623902/week @ 2025-05-23 703197/week @ 2025-05-30 728283/week @ 2025-06-06 761792/week @ 2025-06-13 775770/week @ 2025-06-20\n**3,090,068** downloads per month Used in **1,628** crates (120 directly)\u27e83\u27e9\n**MIT** license \n44KB  689 lines\n![Logo\u27e84\u27e9]\n=================== \nSeaHash: A bizarrely fast hash function.\nSeaHash is a hash function with performance better than (around 3-20% improvement) xxHash and MetroHash. Furthermore, SeaHash has mathematically provable statistical guarantees.\nIn action:\n![The hash function in action.\u27e85\u27e9](http://ticki.github.io/img/seahash_construction_diagram.svg)\n###  `lib.rs`\u27e86\u27e9: \nSeaHash: A blazingly fast, portable hash function with proven statistical guarantees.\nSeaHash is a hash function with performance better than (around 3-20% improvement) xxHash and MetroHash. Furthermore, SeaHash has mathematically provable statistical guarantees.\nSeaHash is a portable hash function, meaning that the output is not dependent on the hosting architecture, and makes no assumptions on endianness or the alike. This stable layout allows it to be used for on-disk/permanent storage (e.g. checksums).\n# Design, advantages, and features\n  * **High quality** : It beats most other general purpose hash functions because it provides full avalanche inbetween state updates.\n  * **Performance** : SeaHash beats every high-quality (grading 10/10 in smhasher) hash function that I know of.\n  * **Provable quality guarantees** : Contrary to most other non-cryptographic hash function, SeaHash can be proved to satisfy the avalanche criterion as well as BIC.\n  * **Parallelizable** : Consists of multiple, independent states to take advantage of ILP and/or software threads.\n  * **Bulk reads** : Reads 8 or 4 bytes a time.\n  * **Stable and portable** : Does not depend on the target architecture, and produces a stable value, which is only changed in major version bumps.\n  * **Keyed** : Designed to not leak the seed/key. Note that it has not gone through cryptoanalysis yet, so the keyed version shouldn't be relied on when security is needed.\n  * **Hardware accelerateable** : SeaHash is designed such that ASICs can implement it with really high performance.\n\n\n# A word of warning!\nThis is **not** a cryptographic function, and it certainly should not be used as one. If you want a good cryptographic hash function, you should use SHA-3 (Keccak) or BLAKE2.\nIt is not secure, nor does it aim to be. It aims to have high quality pseudorandom output and few collisions, as well as being fast.\n# Benchmark\nOn normal hardware, it is expected to run with a rate around 5.9-6.7 GB/S on a 2.5 GHz CPU. Further improvement can be seen when hashing very big buffers in parallel.\nFunction | Quality | Cycles per byte (lower is better) | Author  \n---|---|---|---  \n**SeaHash** | **Excellent** | **0.24** | **Ticki**  \nxxHash | Excellent | 0.31 | Collet  \nMetroHash | Excellent | 0.35 | Rogers  \nMurmur | Excellent | 0.64 | Appleby  \nRabin | Medium | 1.51 | Rabin  \nCityHash | Excellent | 1.62 | Pike, Alakuijala  \nLoseLose | Terrible | 2.01 | Kernighan, Ritchie  \nFNV | Poor | 3.12 | Fowler, Noll, Vo  \nSipHash | Pseudorandom | 3.21 | Aumasson, Bernstein  \nCRC | Good | 3.91 | Peterson  \nDJB2 | Poor | 4.13 | Bernstein  \n## Ideal architecture\nSeaHash is designed and optimized for the most common architecture in use:\n  * Little-endian\n  * 64-bit\n  * 64 or more bytes cache lines\n  * 4 or more instruction pipelines\n  * 4 or more 64-bit registers\n\n\nAnything that does not hold the above requirements will perform worse by up to 30-40%. Note that this means it is still faster than CityHash (~1 GB/S), MurMurHash (~2.6 GB/S), FNV (~0.5 GB/S), etc.\n# Achieving the performance\nLike any good general-purpose hash function, SeaHash reads 8 bytes at once effectively reducing the running time by an order of ~5.\nSecondly, SeaHash achieves the performance by heavily exploiting Instruction-Level Parallelism. In particular, it fetches 4 integers in every round and independently diffuses them. This yields four different states, which are finally combined.\n# Statistical guarantees\nSeaHash comes with certain proven guarantees about the statistical properties of the output:\n  1. Pick some _n_ -byte sequence, _s_. The number of _n_ -byte sequence colliding with _s_ is independent of the choice of _s_ (all equivalence class have equal size).\n  2. If you flip any bit in the input, the probability for any bit in the output to be flipped is 0.5.\n  3. The hash value of a sequence of uniformly distributed bytes is itself uniformly distributed.\n\n\nThe first guarantee can be derived through deduction, by proving that the diffusion function is bijective (reverse the XORs and find the congruence inverses to the primes).\nThe second guarantee requires more complex calculations: Construct a matrix of probabilities and set one to certain (1), then apply transformations through the respective operations. The proof is a bit long, but relatively simple.\nThe third guarantee requires proving that the hash value is a tree, such that:\n  * Leafs represents the input values.\n  * Single-child nodes reduce to the diffusion of the child.\n  * Multiple-child nodes reduce to the sum of the children.\n\n\nThen simply show that each of these reductions transform uniformly distributed variables to uniformly distributed variables.\n# Inner workings\nIn technical terms, SeaHash follows a alternating 4-state length-padded Merkle\u2013Damg\u00e5rd construction with an XOR-diffuse compression function (click to enlarge):\n![A diagram.\u27e85\u27e9] (<http://ticki.github.io/img/seahash_construction_diagram.svg>)\nIt starts with 4 initial states, then it alternates between them (increment, wrap on 4) and does XOR with the respective block. When a state has been visited the diffusion function (f) is applied. The very last block is padded with zeros.\nAfter all the blocks have been gone over, all the states are XOR'd to the number of bytes written. The sum is then passed through the diffusion function, which produces the final hash value.\nThe diffusion function is drawn below.\n```\n`x \u2190 px\nx \u2190 x \u2295 `(``(`x \u226b `32``)` \u226b `(`x \u226b `60``)``)`\nx \u2190 px\n`\n```\n\nThe advantage of having four completely segregated (note that there is no mix round, so they're entirely independent) states is that fast parallelism is possible. For example, if I were to hash 1 TB, I can spawn up four threads which can run independently without _any_ intercommunication or synchronization before the last round.\nIf the diffusion function (f) was cryptographically secure, it would pass cryptoanalysis trivially. This might seem irrelevant, as it clearly isn't cryptographically secure, but it tells us something about the inner semantics. In particular, any diffusion function with sufficient statistical quality will make up a good hash function in this construction.\nRead the blog post\u27e87\u27e9 for more details.\n# ASIC version\nSeaHash is specifically designed such that it can be efficiently implemented in the form of ASIC while only using very few transistors.\n# Specification\nSee the ``reference``\u27e88\u27e9 module.\n# Credits\nAside for myself (@ticki), there are couple of other people who have helped creating this. Joshua Landau suggested using the PCG family of diffusions\u27e89\u27e9, created by Melissa E. O'Neill. Sokolov Yura spotted multiple bugs in SeaHash.\n#### No runtime deps\n  * dev  criterion\u27e810\u27e9 0.3\n  * dev  quickcheck\u27e811\u27e9 0.9.2\n\n\n#### Other feature\u27e812\u27e9\n  * use_std\u27e813\u27e9\n\n\n",
              "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://lib.rs/crates/seahash/versions: 18 stable releases\n\u27e82\u27e9 https://lib.rs/algorithms: Rust implementations of core algorithms such as hashing, sorting, searching, and more. - Algorithms\n\u27e83\u27e9 https://lib.rs/crates/seahash/rev: **1,628** crates (120 directly)\n\u27e84\u27e9 https://img.gs/czjpqfbdkz/200,2x/https://gitlab.redox-os.org/redox-os/logo.png: Logo\n\u27e85\u27e9 https://img.gs/czjpqfbdkz/800/http://ticki.github.io/img/seahash_construction_diagram.svg: ![The hash function in action.\n\u27e86\u27e9 https://docs.rs/seahash: `lib.rs`\n\u27e87\u27e9 http://ticki.github.io/blog/seahash-explained/: the blog post\n\u27e88\u27e9 https://docs.rs/seahash/4.1.0/reference: ``reference``\n\u27e89\u27e9 http://www.pcg-random.org/: PCG family of diffusions\n\u27e810\u27e9 https://lib.rs/crates/criterion: obsolete - criterion\n\u27e811\u27e9 https://lib.rs/crates/quickcheck: obsolete - quickcheck\n\u27e812\u27e9 https://lib.rs/crates/seahash/features: Other feature\n\u27e813\u27e9 https://lib.rs/crates/seahash/features#feature-use_std: use_std\n",
              "fit_markdown": "",
              "fit_html": ""
            },
            "structured_data": {},
            "quality_score": 3.0,
            "extraction_method": "crawl4ai",
            "error": null,
            "metadata": {
              "doc_type": "docs",
              "content_length": 8676,
              "has_structured_data": false,
              "crawl_success": true
            },
            "timestamp": "114760.199001"
          }
        },
        "crate_analysis": {
          "status": "completed",
          "check": [
            {
              "reason": "compiler-artifact",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpbw4llget/seahash-4.1.0#seahash@4.1.0",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpbw4llget\\seahash-4.1.0\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "seahash",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpbw4llget\\seahash-4.1.0\\src\\lib.rs",
                "edition": "2015",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "default"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpbw4llget\\seahash-4.1.0\\target\\debug\\deps\\libseahash-d242bf2e7b142983.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "build-finished",
              "success": true
            }
          ],
          "clippy": [
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpbw4llget/seahash-4.1.0#seahash@4.1.0",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpbw4llget\\seahash-4.1.0\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "seahash",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpbw4llget\\seahash-4.1.0\\src\\lib.rs",
                "edition": "2015",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: redundant field names in struct initialization\n  --> src\\buffer.rs:26:13\n   |\n26 |             a: a,\n   |             ^^^^ help: replace it with: `a`\n   |\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#redundant_field_names\n   = note: `#[warn(clippy::redundant_field_names)]` on by default\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#redundant_field_names",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "note",
                    "message": "`#[warn(clippy::redundant_field_names)]` on by default",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "replace it with",
                    "rendered": null,
                    "spans": [
                      {
                        "byte_end": 448,
                        "byte_start": 444,
                        "column_end": 17,
                        "column_start": 13,
                        "expansion": null,
                        "file_name": "src\\buffer.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 26,
                        "line_start": 26,
                        "suggested_replacement": "a",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 17,
                            "highlight_start": 13,
                            "text": "            a: a,"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "code": {
                  "code": "clippy::redundant_field_names",
                  "explanation": null
                },
                "level": "warning",
                "message": "redundant field names in struct initialization",
                "spans": [
                  {
                    "byte_end": 448,
                    "byte_start": 444,
                    "column_end": 17,
                    "column_start": 13,
                    "expansion": null,
                    "file_name": "src\\buffer.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 26,
                    "line_start": 26,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 17,
                        "highlight_start": 13,
                        "text": "            a: a,"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpbw4llget/seahash-4.1.0#seahash@4.1.0",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpbw4llget\\seahash-4.1.0\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "seahash",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpbw4llget\\seahash-4.1.0\\src\\lib.rs",
                "edition": "2015",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: redundant field names in struct initialization\n  --> src\\buffer.rs:27:13\n   |\n27 |             b: b,\n   |             ^^^^ help: replace it with: `b`\n   |\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#redundant_field_names\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#redundant_field_names",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "replace it with",
                    "rendered": null,
                    "spans": [
                      {
                        "byte_end": 466,
                        "byte_start": 462,
                        "column_end": 17,
                        "column_start": 13,
                        "expansion": null,
                        "file_name": "src\\buffer.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 27,
                        "line_start": 27,
                        "suggested_replacement": "b",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 17,
                            "highlight_start": 13,
                            "text": "            b: b,"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "code": {
                  "code": "clippy::redundant_field_names",
                  "explanation": null
                },
                "level": "warning",
                "message": "redundant field names in struct initialization",
                "spans": [
                  {
                    "byte_end": 466,
                    "byte_start": 462,
                    "column_end": 17,
                    "column_start": 13,
                    "expansion": null,
                    "file_name": "src\\buffer.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 27,
                    "line_start": 27,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 17,
                        "highlight_start": 13,
                        "text": "            b: b,"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpbw4llget/seahash-4.1.0#seahash@4.1.0",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpbw4llget\\seahash-4.1.0\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "seahash",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpbw4llget\\seahash-4.1.0\\src\\lib.rs",
                "edition": "2015",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: redundant field names in struct initialization\n  --> src\\buffer.rs:28:13\n   |\n28 |             c: c,\n   |             ^^^^ help: replace it with: `c`\n   |\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#redundant_field_names\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#redundant_field_names",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "replace it with",
                    "rendered": null,
                    "spans": [
                      {
                        "byte_end": 484,
                        "byte_start": 480,
                        "column_end": 17,
                        "column_start": 13,
                        "expansion": null,
                        "file_name": "src\\buffer.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 28,
                        "line_start": 28,
                        "suggested_replacement": "c",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 17,
                            "highlight_start": 13,
                            "text": "            c: c,"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "code": {
                  "code": "clippy::redundant_field_names",
                  "explanation": null
                },
                "level": "warning",
                "message": "redundant field names in struct initialization",
                "spans": [
                  {
                    "byte_end": 484,
                    "byte_start": 480,
                    "column_end": 17,
                    "column_start": 13,
                    "expansion": null,
                    "file_name": "src\\buffer.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 28,
                    "line_start": 28,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 17,
                        "highlight_start": 13,
                        "text": "            c: c,"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpbw4llget/seahash-4.1.0#seahash@4.1.0",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpbw4llget\\seahash-4.1.0\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "seahash",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpbw4llget\\seahash-4.1.0\\src\\lib.rs",
                "edition": "2015",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: redundant field names in struct initialization\n  --> src\\buffer.rs:29:13\n   |\n29 |             d: d,\n   |             ^^^^ help: replace it with: `d`\n   |\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#redundant_field_names\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#redundant_field_names",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "replace it with",
                    "rendered": null,
                    "spans": [
                      {
                        "byte_end": 502,
                        "byte_start": 498,
                        "column_end": 17,
                        "column_start": 13,
                        "expansion": null,
                        "file_name": "src\\buffer.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 29,
                        "line_start": 29,
                        "suggested_replacement": "d",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 17,
                            "highlight_start": 13,
                            "text": "            d: d,"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "code": {
                  "code": "clippy::redundant_field_names",
                  "explanation": null
                },
                "level": "warning",
                "message": "redundant field names in struct initialization",
                "spans": [
                  {
                    "byte_end": 502,
                    "byte_start": 498,
                    "column_end": 17,
                    "column_start": 13,
                    "expansion": null,
                    "file_name": "src\\buffer.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 29,
                    "line_start": 29,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 17,
                        "highlight_start": 13,
                        "text": "            d: d,"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpbw4llget/seahash-4.1.0#seahash@4.1.0",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpbw4llget\\seahash-4.1.0\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "seahash",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpbw4llget\\seahash-4.1.0\\src\\lib.rs",
                "edition": "2015",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: redundant field names in struct initialization\n   --> src\\buffer.rs:162:13\n    |\n162 |             a: a,\n    |             ^^^^ help: replace it with: `a`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#redundant_field_names\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#redundant_field_names",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "replace it with",
                    "rendered": null,
                    "spans": [
                      {
                        "byte_end": 5540,
                        "byte_start": 5536,
                        "column_end": 17,
                        "column_start": 13,
                        "expansion": null,
                        "file_name": "src\\buffer.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 162,
                        "line_start": 162,
                        "suggested_replacement": "a",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 17,
                            "highlight_start": 13,
                            "text": "            a: a,"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "code": {
                  "code": "clippy::redundant_field_names",
                  "explanation": null
                },
                "level": "warning",
                "message": "redundant field names in struct initialization",
                "spans": [
                  {
                    "byte_end": 5540,
                    "byte_start": 5536,
                    "column_end": 17,
                    "column_start": 13,
                    "expansion": null,
                    "file_name": "src\\buffer.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 162,
                    "line_start": 162,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 17,
                        "highlight_start": 13,
                        "text": "            a: a,"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpbw4llget/seahash-4.1.0#seahash@4.1.0",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpbw4llget\\seahash-4.1.0\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "seahash",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpbw4llget\\seahash-4.1.0\\src\\lib.rs",
                "edition": "2015",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: redundant field names in struct initialization\n   --> src\\buffer.rs:163:13\n    |\n163 |             b: b,\n    |             ^^^^ help: replace it with: `b`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#redundant_field_names\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#redundant_field_names",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "replace it with",
                    "rendered": null,
                    "spans": [
                      {
                        "byte_end": 5558,
                        "byte_start": 5554,
                        "column_end": 17,
                        "column_start": 13,
                        "expansion": null,
                        "file_name": "src\\buffer.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 163,
                        "line_start": 163,
                        "suggested_replacement": "b",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 17,
                            "highlight_start": 13,
                            "text": "            b: b,"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "code": {
                  "code": "clippy::redundant_field_names",
                  "explanation": null
                },
                "level": "warning",
                "message": "redundant field names in struct initialization",
                "spans": [
                  {
                    "byte_end": 5558,
                    "byte_start": 5554,
                    "column_end": 17,
                    "column_start": 13,
                    "expansion": null,
                    "file_name": "src\\buffer.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 163,
                    "line_start": 163,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 17,
                        "highlight_start": 13,
                        "text": "            b: b,"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpbw4llget/seahash-4.1.0#seahash@4.1.0",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpbw4llget\\seahash-4.1.0\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "seahash",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpbw4llget\\seahash-4.1.0\\src\\lib.rs",
                "edition": "2015",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: redundant field names in struct initialization\n   --> src\\buffer.rs:164:13\n    |\n164 |             c: c,\n    |             ^^^^ help: replace it with: `c`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#redundant_field_names\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#redundant_field_names",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "replace it with",
                    "rendered": null,
                    "spans": [
                      {
                        "byte_end": 5576,
                        "byte_start": 5572,
                        "column_end": 17,
                        "column_start": 13,
                        "expansion": null,
                        "file_name": "src\\buffer.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 164,
                        "line_start": 164,
                        "suggested_replacement": "c",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 17,
                            "highlight_start": 13,
                            "text": "            c: c,"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "code": {
                  "code": "clippy::redundant_field_names",
                  "explanation": null
                },
                "level": "warning",
                "message": "redundant field names in struct initialization",
                "spans": [
                  {
                    "byte_end": 5576,
                    "byte_start": 5572,
                    "column_end": 17,
                    "column_start": 13,
                    "expansion": null,
                    "file_name": "src\\buffer.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 164,
                    "line_start": 164,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 17,
                        "highlight_start": 13,
                        "text": "            c: c,"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpbw4llget/seahash-4.1.0#seahash@4.1.0",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpbw4llget\\seahash-4.1.0\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "seahash",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpbw4llget\\seahash-4.1.0\\src\\lib.rs",
                "edition": "2015",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: redundant field names in struct initialization\n   --> src\\buffer.rs:165:13\n    |\n165 |             d: d,\n    |             ^^^^ help: replace it with: `d`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#redundant_field_names\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#redundant_field_names",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "replace it with",
                    "rendered": null,
                    "spans": [
                      {
                        "byte_end": 5594,
                        "byte_start": 5590,
                        "column_end": 17,
                        "column_start": 13,
                        "expansion": null,
                        "file_name": "src\\buffer.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 165,
                        "line_start": 165,
                        "suggested_replacement": "d",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 17,
                            "highlight_start": 13,
                            "text": "            d: d,"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "code": {
                  "code": "clippy::redundant_field_names",
                  "explanation": null
                },
                "level": "warning",
                "message": "redundant field names in struct initialization",
                "spans": [
                  {
                    "byte_end": 5594,
                    "byte_start": 5590,
                    "column_end": 17,
                    "column_start": 13,
                    "expansion": null,
                    "file_name": "src\\buffer.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 165,
                    "line_start": 165,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 17,
                        "highlight_start": 13,
                        "text": "            d: d,"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpbw4llget/seahash-4.1.0#seahash@4.1.0",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpbw4llget\\seahash-4.1.0\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "seahash",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpbw4llget\\seahash-4.1.0\\src\\lib.rs",
                "edition": "2015",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: operator precedence might not be obvious\n   --> src\\stream.rs:174:13\n    |\n174 |             a ^ self.state.1 ^ self.state.2 ^ self.state.3 ^ self.written + self.ntail as u64,\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider parenthesizing your expression: `a ^ self.state.1 ^ self.state.2 ^ self.state.3 ^ (self.written + self.ntail as u64)`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence\n    = note: `#[warn(clippy::precedence)]` on by default\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#precedence",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "note",
                    "message": "`#[warn(clippy::precedence)]` on by default",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "consider parenthesizing your expression",
                    "rendered": null,
                    "spans": [
                      {
                        "byte_end": 7043,
                        "byte_start": 6962,
                        "column_end": 94,
                        "column_start": 13,
                        "expansion": null,
                        "file_name": "src\\stream.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 174,
                        "line_start": 174,
                        "suggested_replacement": "a ^ self.state.1 ^ self.state.2 ^ self.state.3 ^ (self.written + self.ntail as u64)",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 94,
                            "highlight_start": 13,
                            "text": "            a ^ self.state.1 ^ self.state.2 ^ self.state.3 ^ self.written + self.ntail as u64,"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "code": {
                  "code": "clippy::precedence",
                  "explanation": null
                },
                "level": "warning",
                "message": "operator precedence might not be obvious",
                "spans": [
                  {
                    "byte_end": 7043,
                    "byte_start": 6962,
                    "column_end": 94,
                    "column_start": 13,
                    "expansion": null,
                    "file_name": "src\\stream.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 174,
                    "line_start": 174,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 94,
                        "highlight_start": 13,
                        "text": "            a ^ self.state.1 ^ self.state.2 ^ self.state.3 ^ self.written + self.ntail as u64,"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpbw4llget/seahash-4.1.0#seahash@4.1.0",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpbw4llget\\seahash-4.1.0\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "seahash",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpbw4llget\\seahash-4.1.0\\src\\lib.rs",
                "edition": "2015",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: doc list item overindented\n  --> src\\lib.rs:15:5\n   |\n15 | //!    that I know of.\n   |     ^^^ help: try using `  ` (2 spaces)\n   |\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#doc_overindented_list_items\n   = note: `#[warn(clippy::doc_overindented_list_items)]` on by default\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#doc_overindented_list_items",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "note",
                    "message": "`#[warn(clippy::doc_overindented_list_items)]` on by default",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "try using `  ` (2 spaces)",
                    "rendered": null,
                    "spans": [
                      {
                        "byte_end": 837,
                        "byte_start": 834,
                        "column_end": 8,
                        "column_start": 5,
                        "expansion": null,
                        "file_name": "src\\lib.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 15,
                        "line_start": 15,
                        "suggested_replacement": "  ",
                        "suggestion_applicability": "MaybeIncorrect",
                        "text": [
                          {
                            "highlight_end": 8,
                            "highlight_start": 5,
                            "text": "//!    that I know of."
                          }
                        ]
                      }
                    ]
                  }
                ],
                "code": {
                  "code": "clippy::doc_overindented_list_items",
                  "explanation": null
                },
                "level": "warning",
                "message": "doc list item overindented",
                "spans": [
                  {
                    "byte_end": 837,
                    "byte_start": 834,
                    "column_end": 8,
                    "column_start": 5,
                    "expansion": null,
                    "file_name": "src\\lib.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 15,
                    "line_start": 15,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 8,
                        "highlight_start": 5,
                        "text": "//!    that I know of."
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpbw4llget/seahash-4.1.0#seahash@4.1.0",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpbw4llget\\seahash-4.1.0\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "seahash",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpbw4llget\\seahash-4.1.0\\src\\lib.rs",
                "edition": "2015",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: casting to the same type is unnecessary (`usize` -> `usize`)\n  --> src\\buffer.rs:68:33\n   |\n68 |             let mut excessive = buf.len() as usize + buf.as_ptr() as usize - end_ptr as usize;\n   |                                 ^^^^^^^^^^^^^^^^^^ help: try: `buf.len()`\n   |\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n   = note: `#[warn(clippy::unnecessary_cast)]` on by default\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "note",
                    "message": "`#[warn(clippy::unnecessary_cast)]` on by default",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "try",
                    "rendered": null,
                    "spans": [
                      {
                        "byte_end": 2133,
                        "byte_start": 2115,
                        "column_end": 51,
                        "column_start": 33,
                        "expansion": null,
                        "file_name": "src\\buffer.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 68,
                        "line_start": 68,
                        "suggested_replacement": "buf.len()",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 51,
                            "highlight_start": 33,
                            "text": "            let mut excessive = buf.len() as usize + buf.as_ptr() as usize - end_ptr as usize;"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "code": {
                  "code": "clippy::unnecessary_cast",
                  "explanation": null
                },
                "level": "warning",
                "message": "casting to the same type is unnecessary (`usize` -> `usize`)",
                "spans": [
                  {
                    "byte_end": 2133,
                    "byte_start": 2115,
                    "column_end": 51,
                    "column_start": 33,
                    "expansion": null,
                    "file_name": "src\\buffer.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 68,
                    "line_start": 68,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 51,
                        "highlight_start": 33,
                        "text": "            let mut excessive = buf.len() as usize + buf.as_ptr() as usize - end_ptr as usize;"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpbw4llget/seahash-4.1.0#seahash@4.1.0",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpbw4llget\\seahash-4.1.0\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "seahash",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpbw4llget\\seahash-4.1.0\\src\\lib.rs",
                "edition": "2015",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: casting raw pointers to the same type and constness is unnecessary (`*const u8` -> `*const u8`)\n  --> src\\buffer.rs:76:65\n   |\n76 |                     a ^= helper::read_int(slice::from_raw_parts(ptr as *const u8, excessive));\n   |                                                                 ^^^^^^^^^^^^^^^^ help: try: `ptr`\n   |\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "try",
                    "rendered": null,
                    "spans": [
                      {
                        "byte_end": 2493,
                        "byte_start": 2477,
                        "column_end": 81,
                        "column_start": 65,
                        "expansion": null,
                        "file_name": "src\\buffer.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 76,
                        "line_start": 76,
                        "suggested_replacement": "ptr",
                        "suggestion_applicability": "MaybeIncorrect",
                        "text": [
                          {
                            "highlight_end": 81,
                            "highlight_start": 65,
                            "text": "                    a ^= helper::read_int(slice::from_raw_parts(ptr as *const u8, excessive));"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "code": {
                  "code": "clippy::unnecessary_cast",
                  "explanation": null
                },
                "level": "warning",
                "message": "casting raw pointers to the same type and constness is unnecessary (`*const u8` -> `*const u8`)",
                "spans": [
                  {
                    "byte_end": 2493,
                    "byte_start": 2477,
                    "column_end": 81,
                    "column_start": 65,
                    "expansion": null,
                    "file_name": "src\\buffer.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 76,
                    "line_start": 76,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 81,
                        "highlight_start": 65,
                        "text": "                    a ^= helper::read_int(slice::from_raw_parts(ptr as *const u8, excessive));"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpbw4llget/seahash-4.1.0#seahash@4.1.0",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpbw4llget\\seahash-4.1.0\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "seahash",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpbw4llget\\seahash-4.1.0\\src\\lib.rs",
                "edition": "2015",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: manual implementation of an assign operation\n  --> src\\buffer.rs:97:21\n   |\n97 |                     excessive = excessive - 8;\n   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `excessive -= 8`\n   |\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#assign_op_pattern\n   = note: `#[warn(clippy::assign_op_pattern)]` on by default\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#assign_op_pattern",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "note",
                    "message": "`#[warn(clippy::assign_op_pattern)]` on by default",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "replace it with",
                    "rendered": null,
                    "spans": [
                      {
                        "byte_end": 3151,
                        "byte_start": 3126,
                        "column_end": 46,
                        "column_start": 21,
                        "expansion": null,
                        "file_name": "src\\buffer.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 97,
                        "line_start": 97,
                        "suggested_replacement": "excessive -= 8",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 46,
                            "highlight_start": 21,
                            "text": "                    excessive = excessive - 8;"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "code": {
                  "code": "clippy::assign_op_pattern",
                  "explanation": null
                },
                "level": "warning",
                "message": "manual implementation of an assign operation",
                "spans": [
                  {
                    "byte_end": 3151,
                    "byte_start": 3126,
                    "column_end": 46,
                    "column_start": 21,
                    "expansion": null,
                    "file_name": "src\\buffer.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 97,
                    "line_start": 97,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 46,
                        "highlight_start": 21,
                        "text": "                    excessive = excessive - 8;"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpbw4llget/seahash-4.1.0#seahash@4.1.0",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpbw4llget\\seahash-4.1.0\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "seahash",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpbw4llget\\seahash-4.1.0\\src\\lib.rs",
                "edition": "2015",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: manual implementation of an assign operation\n   --> src\\buffer.rs:119:21\n    |\n119 |                     excessive = excessive - 16;\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `excessive -= 16`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#assign_op_pattern\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#assign_op_pattern",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "replace it with",
                    "rendered": null,
                    "spans": [
                      {
                        "byte_end": 4014,
                        "byte_start": 3988,
                        "column_end": 47,
                        "column_start": 21,
                        "expansion": null,
                        "file_name": "src\\buffer.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 119,
                        "line_start": 119,
                        "suggested_replacement": "excessive -= 16",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 47,
                            "highlight_start": 21,
                            "text": "                    excessive = excessive - 16;"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "code": {
                  "code": "clippy::assign_op_pattern",
                  "explanation": null
                },
                "level": "warning",
                "message": "manual implementation of an assign operation",
                "spans": [
                  {
                    "byte_end": 4014,
                    "byte_start": 3988,
                    "column_end": 47,
                    "column_start": 21,
                    "expansion": null,
                    "file_name": "src\\buffer.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 119,
                    "line_start": 119,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 47,
                        "highlight_start": 21,
                        "text": "                    excessive = excessive - 16;"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpbw4llget/seahash-4.1.0#seahash@4.1.0",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpbw4llget\\seahash-4.1.0\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "seahash",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpbw4llget\\seahash-4.1.0\\src\\lib.rs",
                "edition": "2015",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: manual implementation of an assign operation\n   --> src\\buffer.rs:149:21\n    |\n149 |                     excessive = excessive - 24;\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `excessive -= 24`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#assign_op_pattern\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#assign_op_pattern",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "replace it with",
                    "rendered": null,
                    "spans": [
                      {
                        "byte_end": 5161,
                        "byte_start": 5135,
                        "column_end": 47,
                        "column_start": 21,
                        "expansion": null,
                        "file_name": "src\\buffer.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 149,
                        "line_start": 149,
                        "suggested_replacement": "excessive -= 24",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 47,
                            "highlight_start": 21,
                            "text": "                    excessive = excessive - 24;"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "code": {
                  "code": "clippy::assign_op_pattern",
                  "explanation": null
                },
                "level": "warning",
                "message": "manual implementation of an assign operation",
                "spans": [
                  {
                    "byte_end": 5161,
                    "byte_start": 5135,
                    "column_end": 47,
                    "column_start": 21,
                    "expansion": null,
                    "file_name": "src\\buffer.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 149,
                    "line_start": 149,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 47,
                        "highlight_start": 21,
                        "text": "                    excessive = excessive - 24;"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpbw4llget/seahash-4.1.0#seahash@4.1.0",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpbw4llget\\seahash-4.1.0\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "seahash",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpbw4llget\\seahash-4.1.0\\src\\lib.rs",
                "edition": "2015",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: use of `offset` with a `usize` casted to an `isize`\n  --> src\\stream.rs:76:23\n   |\n76 |                 ptr = ptr.offset(copied as isize);\n   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `ptr.add(copied)`\n   |\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#ptr_offset_with_cast\n   = note: `#[warn(clippy::ptr_offset_with_cast)]` on by default\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#ptr_offset_with_cast",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "note",
                    "message": "`#[warn(clippy::ptr_offset_with_cast)]` on by default",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "try",
                    "rendered": null,
                    "spans": [
                      {
                        "byte_end": 2205,
                        "byte_start": 2178,
                        "column_end": 50,
                        "column_start": 23,
                        "expansion": null,
                        "file_name": "src\\stream.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 76,
                        "line_start": 76,
                        "suggested_replacement": "ptr.add(copied)",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 50,
                            "highlight_start": 23,
                            "text": "                ptr = ptr.offset(copied as isize);"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "code": {
                  "code": "clippy::ptr_offset_with_cast",
                  "explanation": null
                },
                "level": "warning",
                "message": "use of `offset` with a `usize` casted to an `isize`",
                "spans": [
                  {
                    "byte_end": 2205,
                    "byte_start": 2178,
                    "column_end": 50,
                    "column_start": 23,
                    "expansion": null,
                    "file_name": "src\\stream.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 76,
                    "line_start": 76,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 50,
                        "highlight_start": 23,
                        "text": "                ptr = ptr.offset(copied as isize);"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpbw4llget/seahash-4.1.0#seahash@4.1.0",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpbw4llget\\seahash-4.1.0\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "seahash",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpbw4llget\\seahash-4.1.0\\src\\lib.rs",
                "edition": "2015",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: casting raw pointers to the same type and constness is unnecessary (`*const u8` -> `*const u8`)\n  --> src\\stream.rs:94:68\n   |\n94 | ...                   helper::read_int(slice::from_raw_parts(ptr as *const u8, excessive));\n   |                                                              ^^^^^^^^^^^^^^^^ help: try: `ptr`\n   |\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "try",
                    "rendered": null,
                    "spans": [
                      {
                        "byte_end": 3234,
                        "byte_start": 3218,
                        "column_end": 84,
                        "column_start": 68,
                        "expansion": null,
                        "file_name": "src\\stream.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 94,
                        "line_start": 94,
                        "suggested_replacement": "ptr",
                        "suggestion_applicability": "MaybeIncorrect",
                        "text": [
                          {
                            "highlight_end": 84,
                            "highlight_start": 68,
                            "text": "                            helper::read_int(slice::from_raw_parts(ptr as *const u8, excessive));"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "code": {
                  "code": "clippy::unnecessary_cast",
                  "explanation": null
                },
                "level": "warning",
                "message": "casting raw pointers to the same type and constness is unnecessary (`*const u8` -> `*const u8`)",
                "spans": [
                  {
                    "byte_end": 3234,
                    "byte_start": 3218,
                    "column_end": 84,
                    "column_start": 68,
                    "expansion": null,
                    "file_name": "src\\stream.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 94,
                    "line_start": 94,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 84,
                        "highlight_start": 68,
                        "text": "                            helper::read_int(slice::from_raw_parts(ptr as *const u8, excessive));"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-artifact",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpbw4llget/seahash-4.1.0#seahash@4.1.0",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpbw4llget\\seahash-4.1.0\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "seahash",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpbw4llget\\seahash-4.1.0\\src\\lib.rs",
                "edition": "2015",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "default"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpbw4llget\\seahash-4.1.0\\target\\debug\\deps\\libseahash-371cdbeee6134e6f.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "build-finished",
              "success": true
            }
          ],
          "audit": {
            "database": {
              "advisory-count": 787,
              "last-commit": "7573f55ba337263f61167dbb0ea926cdc7c8eb5d",
              "last-updated": "2025-06-17T11:04:25+02:00"
            },
            "lockfile": {
              "dependency-count": 83
            },
            "settings": {
              "target_arch": [],
              "target_os": [],
              "severity": null,
              "ignore": [],
              "informational_warnings": [
                "unmaintained",
                "unsound",
                "notice"
              ]
            },
            "vulnerabilities": {
              "found": false,
              "count": 0,
              "list": []
            },
            "warnings": {
              "unmaintained": [
                {
                  "kind": "unmaintained",
                  "package": {
                    "name": "atty",
                    "version": "0.2.14",
                    "source": "registry+https://github.com/rust-lang/crates.io-index",
                    "checksum": "d9b39be18770d11421cdb1b9947a45dd3f37e93092cbf377614828a319d5fee8",
                    "dependencies": [
                      {
                        "name": "hermit-abi",
                        "version": "0.1.19",
                        "source": "registry+https://github.com/rust-lang/crates.io-index"
                      },
                      {
                        "name": "libc",
                        "version": "0.2.174",
                        "source": "registry+https://github.com/rust-lang/crates.io-index"
                      },
                      {
                        "name": "winapi",
                        "version": "0.3.9",
                        "source": "registry+https://github.com/rust-lang/crates.io-index"
                      }
                    ],
                    "replace": null
                  },
                  "advisory": {
                    "id": "RUSTSEC-2024-0375",
                    "package": "atty",
                    "title": "`atty` is unmaintained",
                    "description": "The maintainer of `atty` has [published](https://github.com/softprops/atty/commit/5bfdbe9e48c6ca6a4909e8d5b04f5e843a257e93) an official notice that the crate is no longer\nunder development, and that users should instead rely on the functionality in the standard library's [`IsTerminal`](https://doc.rust-lang.org/std/io/trait.IsTerminal.html) trait.\n\n## Alternative(s)\n\n- [std::io::IsTerminal](https://doc.rust-lang.org/stable/std/io/trait.IsTerminal.html) - Stable since Rust 1.70.0 and the recommended replacement per the `atty` maintainer.\n- [is-terminal](https://crates.io/crates/is-terminal) - Standalone crate supporting Rust older than 1.70.0",
                    "date": "2024-09-25",
                    "aliases": [],
                    "related": [],
                    "collection": "crates",
                    "categories": [],
                    "keywords": [],
                    "cvss": null,
                    "informational": "unmaintained",
                    "references": [],
                    "source": null,
                    "url": "https://github.com/softprops/atty/issues/57",
                    "withdrawn": null,
                    "license": "CC0-1.0"
                  },
                  "affected": null,
                  "versions": {
                    "patched": [],
                    "unaffected": []
                  }
                },
                {
                  "kind": "unmaintained",
                  "package": {
                    "name": "serde_cbor",
                    "version": "0.11.2",
                    "source": "registry+https://github.com/rust-lang/crates.io-index",
                    "checksum": "2bef2ebfde456fb76bbcf9f59315333decc4fda0b2b44b420243c11e0f5ec1f5",
                    "dependencies": [
                      {
                        "name": "half",
                        "version": "1.8.3",
                        "source": "registry+https://github.com/rust-lang/crates.io-index"
                      },
                      {
                        "name": "serde",
                        "version": "1.0.219",
                        "source": "registry+https://github.com/rust-lang/crates.io-index"
                      }
                    ],
                    "replace": null
                  },
                  "advisory": {
                    "id": "RUSTSEC-2021-0127",
                    "package": "serde_cbor",
                    "title": "serde_cbor is unmaintained",
                    "description": "The `serde_cbor` crate is unmaintained. The author has archived the github repository.\n\nAlternatives proposed by the author:\n\n * [`ciborium`](https://crates.io/crates/ciborium)\n * [`minicbor`](https://crates.io/crates/minicbor)",
                    "date": "2021-08-15",
                    "aliases": [],
                    "related": [],
                    "collection": "crates",
                    "categories": [],
                    "keywords": [],
                    "cvss": null,
                    "informational": "unmaintained",
                    "references": [],
                    "source": null,
                    "url": "https://github.com/pyfisch/cbor",
                    "withdrawn": null,
                    "license": "CC0-1.0"
                  },
                  "affected": null,
                  "versions": {
                    "patched": [],
                    "unaffected": []
                  }
                }
              ],
              "unsound": [
                {
                  "kind": "unsound",
                  "package": {
                    "name": "atty",
                    "version": "0.2.14",
                    "source": "registry+https://github.com/rust-lang/crates.io-index",
                    "checksum": "d9b39be18770d11421cdb1b9947a45dd3f37e93092cbf377614828a319d5fee8",
                    "dependencies": [
                      {
                        "name": "hermit-abi",
                        "version": "0.1.19",
                        "source": "registry+https://github.com/rust-lang/crates.io-index"
                      },
                      {
                        "name": "libc",
                        "version": "0.2.174",
                        "source": "registry+https://github.com/rust-lang/crates.io-index"
                      },
                      {
                        "name": "winapi",
                        "version": "0.3.9",
                        "source": "registry+https://github.com/rust-lang/crates.io-index"
                      }
                    ],
                    "replace": null
                  },
                  "advisory": {
                    "id": "RUSTSEC-2021-0145",
                    "package": "atty",
                    "title": "Potential unaligned read",
                    "description": "On windows, `atty` dereferences a potentially unaligned pointer.\n\nIn practice however, the pointer won't be unaligned unless a custom global allocator is used.\n\nIn particular, the `System` allocator on windows uses `HeapAlloc`, which guarantees a large enough alignment.\n\n# atty is Unmaintained\n\nA Pull Request with a fix has been provided over a year ago but the maintainer seems to be unreachable.\n\nLast release of `atty` was almost 3 years ago.\n\n## Possible Alternative(s)\n\nThe below list has not been vetted in any way and may or may not contain alternatives;\n\n - [std::io::IsTerminal](https://doc.rust-lang.org/stable/std/io/trait.IsTerminal.html) - Stable since Rust 1.70.0\n - [is-terminal](https://crates.io/crates/is-terminal) - Standalone crate supporting Rust older than 1.70.0",
                    "date": "2021-07-04",
                    "aliases": [
                      "GHSA-g98v-hv3f-hcfr"
                    ],
                    "related": [],
                    "collection": "crates",
                    "categories": [],
                    "keywords": [
                      "unaligned-read"
                    ],
                    "cvss": null,
                    "informational": "unsound",
                    "references": [
                      "https://github.com/softprops/atty/pull/51",
                      "https://github.com/softprops/atty/issues/57"
                    ],
                    "source": null,
                    "url": "https://github.com/softprops/atty/issues/50",
                    "withdrawn": null,
                    "license": "CC0-1.0"
                  },
                  "affected": {
                    "arch": [],
                    "os": [
                      "windows"
                    ],
                    "functions": {}
                  },
                  "versions": {
                    "patched": [],
                    "unaffected": []
                  }
                }
              ]
            }
          },
          "note": "Crate analysis performed with stable toolchain."
        },
        "crate_metadata": {
          "name": "seahash",
          "version": "4.1.0",
          "description": "ALLOW: Positive community sentiment",
          "repository": "",
          "keywords": [],
          "categories": [],
          "readme": {
            "raw_markdown": "[](https://docs.rs/seahash/latest/seahash/all.html \"show sidebar\")\n# Crate seahashCopy item path\n[Settings](https://docs.rs/seahash/latest/settings.html)\n[Help](https://docs.rs/seahash/latest/help.html)\nSummary[Source](https://docs.rs/seahash/latest/src/seahash/lib.rs.html#1-168)\nExpand description\nSeaHash: A blazingly fast, portable hash function with proven statistical guarantees.\nSeaHash is a hash function with performance better than (around 3-20% improvement) xxHash and MetroHash. Furthermore, SeaHash has mathematically provable statistical guarantees.\nSeaHash is a portable hash function, meaning that the output is not dependent on the hosting architecture, and makes no assumptions on endianness or the alike. This stable layout allows it to be used for on-disk/permanent storage (e.g. checksums).\n## [\u00a7](https://docs.rs/seahash/latest/seahash/#design-advantages-and-features)Design, advantages, and features\n  * **High quality** : It beats most other general purpose hash functions because it provides full avalanche inbetween state updates.\n  * **Performance** : SeaHash beats every high-quality (grading 10/10 in smhasher) hash function that I know of.\n  * **Provable quality guarantees** : Contrary to most other non-cryptographic hash function, SeaHash can be proved to satisfy the avalanche criterion as well as BIC.\n  * **Parallelizable** : Consists of multiple, independent states to take advantage of ILP and/or software threads.\n  * **Bulk reads** : Reads 8 or 4 bytes a time.\n  * **Stable and portable** : Does not depend on the target architecture, and produces a stable value, which is only changed in major version bumps.\n  * **Keyed** : Designed to not leak the seed/key. Note that it has not gone through cryptoanalysis yet, so the keyed version shouldn\u2019t be relied on when security is needed.\n  * **Hardware accelerateable** : SeaHash is designed such that ASICs can implement it with really high performance.\n\n\n## [\u00a7](https://docs.rs/seahash/latest/seahash/#a-word-of-warning)A word of warning!\nThis is **not** a cryptographic function, and it certainly should not be used as one. If you want a good cryptographic hash function, you should use SHA-3 (Keccak) or BLAKE2.\nIt is not secure, nor does it aim to be. It aims to have high quality pseudorandom output and few collisions, as well as being fast.\n## [\u00a7](https://docs.rs/seahash/latest/seahash/#benchmark)Benchmark\nOn normal hardware, it is expected to run with a rate around 5.9-6.7 GB/S on a 2.5 GHz CPU. Further improvement can be seen when hashing very big buffers in parallel.\nFunction| Quality| Cycles per byte (lower is better)| Author  \n---|---|---|---  \n**SeaHash**| **Excellent**| **0.24**| **Ticki**  \nxxHash| Excellent| 0.31| Collet  \nMetroHash| Excellent| 0.35| Rogers  \nMurmur| Excellent| 0.64| Appleby  \nRabin| Medium| 1.51| Rabin  \nCityHash| Excellent| 1.62| Pike, Alakuijala  \nLoseLose| Terrible| 2.01| Kernighan, Ritchie  \nFNV| Poor| 3.12| Fowler, Noll, Vo  \nSipHash| Pseudorandom| 3.21| Aumasson, Bernstein  \nCRC| Good| 3.91| Peterson  \nDJB2| Poor| 4.13| Bernstein  \n### [\u00a7](https://docs.rs/seahash/latest/seahash/#ideal-architecture)Ideal architecture\nSeaHash is designed and optimized for the most common architecture in use:\n  * Little-endian\n  * 64-bit\n  * 64 or more bytes cache lines\n  * 4 or more instruction pipelines\n  * 4 or more 64-bit registers\n\n\nAnything that does not hold the above requirements will perform worse by up to 30-40%. Note that this means it is still faster than CityHash (~1 GB/S), MurMurHash (~2.6 GB/S), FNV (~0.5 GB/S), etc.\n## [\u00a7](https://docs.rs/seahash/latest/seahash/#achieving-the-performance)Achieving the performance\nLike any good general-purpose hash function, SeaHash reads 8 bytes at once effectively reducing the running time by an order of ~5.\nSecondly, SeaHash achieves the performance by heavily exploiting Instruction-Level Parallelism. In particular, it fetches 4 integers in every round and independently diffuses them. This yields four different states, which are finally combined.\n## [\u00a7](https://docs.rs/seahash/latest/seahash/#statistical-guarantees)Statistical guarantees\nSeaHash comes with certain proven guarantees about the statistical properties of the output:\n  1. Pick some _n_ -byte sequence, _s_. The number of _n_ -byte sequence colliding with _s_ is independent of the choice of _s_ (all equivalence class have equal size).\n  2. If you flip any bit in the input, the probability for any bit in the output to be flipped is 0.5.\n  3. The hash value of a sequence of uniformly distributed bytes is itself uniformly distributed.\n\n\nThe first guarantee can be derived through deduction, by proving that the diffusion function is bijective (reverse the XORs and find the congruence inverses to the primes).\nThe second guarantee requires more complex calculations: Construct a matrix of probabilities and set one to certain (1), then apply transformations through the respective operations. The proof is a bit long, but relatively simple.\nThe third guarantee requires proving that the hash value is a tree, such that:\n  * Leafs represents the input values.\n  * Single-child nodes reduce to the diffusion of the child.\n  * Multiple-child nodes reduce to the sum of the children.\n\n\nThen simply show that each of these reductions transform uniformly distributed variables to uniformly distributed variables.\n## [\u00a7](https://docs.rs/seahash/latest/seahash/#inner-workings)Inner workings\nIn technical terms, SeaHash follows a alternating 4-state length-padded Merkle\u2013Damg\u00e5rd construction with an XOR-diffuse compression function (click to enlarge):\n[![A diagram.](http://ticki.github.io/img/seahash_construction_diagram.svg)] (http://ticki.github.io/img/seahash_construction_diagram.svg)\nIt starts with 4 initial states, then it alternates between them (increment, wrap on 4) and does XOR with the respective block. When a state has been visited the diffusion function (f) is applied. The very last block is padded with zeros.\nAfter all the blocks have been gone over, all the states are XOR\u2019d to the number of bytes written. The sum is then passed through the diffusion function, which produces the final hash value.\nThe diffusion function is drawn below.\n```\nx \u2190 px\nx \u2190 x \u2295 ((x \u226b 32) \u226b (x \u226b 60))\nx \u2190 px\n```\n\nThe advantage of having four completely segregated (note that there is no mix round, so they\u2019re entirely independent) states is that fast parallelism is possible. For example, if I were to hash 1 TB, I can spawn up four threads which can run independently without _any_ intercommunication or synchronization before the last round.\nIf the diffusion function (f) was cryptographically secure, it would pass cryptoanalysis trivially. This might seem irrelevant, as it clearly isn\u2019t cryptographically secure, but it tells us something about the inner semantics. In particular, any diffusion function with sufficient statistical quality will make up a good hash function in this construction.\nRead [the blog post](http://ticki.github.io/blog/seahash-explained/) for more details.\n## [\u00a7](https://docs.rs/seahash/latest/seahash/#asic-version)ASIC version\nSeaHash is specifically designed such that it can be efficiently implemented in the form of ASIC while only using very few transistors.\n## [\u00a7](https://docs.rs/seahash/latest/seahash/#specification)Specification\nSee the [`reference`](https://docs.rs/seahash/latest/seahash/reference) module.\n## [\u00a7](https://docs.rs/seahash/latest/seahash/#credits)Credits\nAside for myself (@ticki), there are couple of other people who have helped creating this. Joshua Landau suggested using the [PCG family of diffusions](http://www.pcg-random.org/), created by Melissa E. O\u2019Neill. Sokolov Yura spotted multiple bugs in SeaHash.\n## Modules[\u00a7](https://docs.rs/seahash/latest/seahash/#modules)\n\n[reference](https://docs.rs/seahash/latest/seahash/reference/index.html \"mod seahash::reference\")\n    A slow, but clear reference implementation of SeaHash.\n## Structs[\u00a7](https://docs.rs/seahash/latest/seahash/#structs)\n\n[SeaHasher](https://docs.rs/seahash/latest/seahash/struct.SeaHasher.html \"struct seahash::SeaHasher\")\n    The streaming version of the algorithm.\n\n[State](https://docs.rs/seahash/latest/seahash/struct.State.html \"struct seahash::State\")\n    A SeaHash state.\n## Functions[\u00a7](https://docs.rs/seahash/latest/seahash/#functions)\n\n[hash](https://docs.rs/seahash/latest/seahash/fn.hash.html \"fn seahash::hash\")\n    Hash some buffer.\n\n[hash_seeded](https://docs.rs/seahash/latest/seahash/fn.hash_seeded.html \"fn seahash::hash_seeded\")\n    Hash some buffer according to a chosen seed.\n",
            "markdown_with_citations": "[](https://docs.rs/seahash/latest/seahash/all.html \"show sidebar\")\n# Crate seahashCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nSeaHash: A blazingly fast, portable hash function with proven statistical guarantees.\nSeaHash is a hash function with performance better than (around 3-20% improvement) xxHash and MetroHash. Furthermore, SeaHash has mathematically provable statistical guarantees.\nSeaHash is a portable hash function, meaning that the output is not dependent on the hosting architecture, and makes no assumptions on endianness or the alike. This stable layout allows it to be used for on-disk/permanent storage (e.g. checksums).\n## \u00a7\u27e84\u27e9Design, advantages, and features\n  * **High quality** : It beats most other general purpose hash functions because it provides full avalanche inbetween state updates.\n  * **Performance** : SeaHash beats every high-quality (grading 10/10 in smhasher) hash function that I know of.\n  * **Provable quality guarantees** : Contrary to most other non-cryptographic hash function, SeaHash can be proved to satisfy the avalanche criterion as well as BIC.\n  * **Parallelizable** : Consists of multiple, independent states to take advantage of ILP and/or software threads.\n  * **Bulk reads** : Reads 8 or 4 bytes a time.\n  * **Stable and portable** : Does not depend on the target architecture, and produces a stable value, which is only changed in major version bumps.\n  * **Keyed** : Designed to not leak the seed/key. Note that it has not gone through cryptoanalysis yet, so the keyed version shouldn\u2019t be relied on when security is needed.\n  * **Hardware accelerateable** : SeaHash is designed such that ASICs can implement it with really high performance.\n\n\n## \u00a7\u27e85\u27e9A word of warning!\nThis is **not** a cryptographic function, and it certainly should not be used as one. If you want a good cryptographic hash function, you should use SHA-3 (Keccak) or BLAKE2.\nIt is not secure, nor does it aim to be. It aims to have high quality pseudorandom output and few collisions, as well as being fast.\n## \u00a7\u27e86\u27e9Benchmark\nOn normal hardware, it is expected to run with a rate around 5.9-6.7 GB/S on a 2.5 GHz CPU. Further improvement can be seen when hashing very big buffers in parallel.\nFunction| Quality| Cycles per byte (lower is better)| Author  \n---|---|---|---  \n**SeaHash**| **Excellent**| **0.24**| **Ticki**  \nxxHash| Excellent| 0.31| Collet  \nMetroHash| Excellent| 0.35| Rogers  \nMurmur| Excellent| 0.64| Appleby  \nRabin| Medium| 1.51| Rabin  \nCityHash| Excellent| 1.62| Pike, Alakuijala  \nLoseLose| Terrible| 2.01| Kernighan, Ritchie  \nFNV| Poor| 3.12| Fowler, Noll, Vo  \nSipHash| Pseudorandom| 3.21| Aumasson, Bernstein  \nCRC| Good| 3.91| Peterson  \nDJB2| Poor| 4.13| Bernstein  \n### \u00a7\u27e87\u27e9Ideal architecture\nSeaHash is designed and optimized for the most common architecture in use:\n  * Little-endian\n  * 64-bit\n  * 64 or more bytes cache lines\n  * 4 or more instruction pipelines\n  * 4 or more 64-bit registers\n\n\nAnything that does not hold the above requirements will perform worse by up to 30-40%. Note that this means it is still faster than CityHash (~1 GB/S), MurMurHash (~2.6 GB/S), FNV (~0.5 GB/S), etc.\n## \u00a7\u27e88\u27e9Achieving the performance\nLike any good general-purpose hash function, SeaHash reads 8 bytes at once effectively reducing the running time by an order of ~5.\nSecondly, SeaHash achieves the performance by heavily exploiting Instruction-Level Parallelism. In particular, it fetches 4 integers in every round and independently diffuses them. This yields four different states, which are finally combined.\n## \u00a7\u27e89\u27e9Statistical guarantees\nSeaHash comes with certain proven guarantees about the statistical properties of the output:\n  1. Pick some _n_ -byte sequence, _s_. The number of _n_ -byte sequence colliding with _s_ is independent of the choice of _s_ (all equivalence class have equal size).\n  2. If you flip any bit in the input, the probability for any bit in the output to be flipped is 0.5.\n  3. The hash value of a sequence of uniformly distributed bytes is itself uniformly distributed.\n\n\nThe first guarantee can be derived through deduction, by proving that the diffusion function is bijective (reverse the XORs and find the congruence inverses to the primes).\nThe second guarantee requires more complex calculations: Construct a matrix of probabilities and set one to certain (1), then apply transformations through the respective operations. The proof is a bit long, but relatively simple.\nThe third guarantee requires proving that the hash value is a tree, such that:\n  * Leafs represents the input values.\n  * Single-child nodes reduce to the diffusion of the child.\n  * Multiple-child nodes reduce to the sum of the children.\n\n\nThen simply show that each of these reductions transform uniformly distributed variables to uniformly distributed variables.\n## \u00a7\u27e810\u27e9Inner workings\nIn technical terms, SeaHash follows a alternating 4-state length-padded Merkle\u2013Damg\u00e5rd construction with an XOR-diffuse compression function (click to enlarge):\n![A diagram.\u27e811\u27e9] (http://ticki.github.io/img/seahash_construction_diagram.svg)\nIt starts with 4 initial states, then it alternates between them (increment, wrap on 4) and does XOR with the respective block. When a state has been visited the diffusion function (f) is applied. The very last block is padded with zeros.\nAfter all the blocks have been gone over, all the states are XOR\u2019d to the number of bytes written. The sum is then passed through the diffusion function, which produces the final hash value.\nThe diffusion function is drawn below.\n```\nx \u2190 px\nx \u2190 x \u2295 ((x \u226b 32) \u226b (x \u226b 60))\nx \u2190 px\n```\n\nThe advantage of having four completely segregated (note that there is no mix round, so they\u2019re entirely independent) states is that fast parallelism is possible. For example, if I were to hash 1 TB, I can spawn up four threads which can run independently without _any_ intercommunication or synchronization before the last round.\nIf the diffusion function (f) was cryptographically secure, it would pass cryptoanalysis trivially. This might seem irrelevant, as it clearly isn\u2019t cryptographically secure, but it tells us something about the inner semantics. In particular, any diffusion function with sufficient statistical quality will make up a good hash function in this construction.\nRead the blog post\u27e812\u27e9 for more details.\n## \u00a7\u27e813\u27e9ASIC version\nSeaHash is specifically designed such that it can be efficiently implemented in the form of ASIC while only using very few transistors.\n## \u00a7\u27e814\u27e9Specification\nSee the `reference`\u27e815\u27e9 module.\n## \u00a7\u27e816\u27e9Credits\nAside for myself (@ticki), there are couple of other people who have helped creating this. Joshua Landau suggested using the PCG family of diffusions\u27e817\u27e9, created by Melissa E. O\u2019Neill. Sokolov Yura spotted multiple bugs in SeaHash.\n## Modules\u00a7\u27e818\u27e9\n\nreference\u27e819\u27e9\n    A slow, but clear reference implementation of SeaHash.\n## Structs\u00a7\u27e820\u27e9\n\nSeaHasher\u27e821\u27e9\n    The streaming version of the algorithm.\n\nState\u27e822\u27e9\n    A SeaHash state.\n## Functions\u00a7\u27e823\u27e9\n\nhash\u27e824\u27e9\n    Hash some buffer.\n\nhash_seeded\u27e825\u27e9\n    Hash some buffer according to a chosen seed.\n",
            "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/seahash/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/seahash/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/seahash/latest/src/seahash/lib.rs.html#1-168: Source\n\u27e84\u27e9 https://docs.rs/seahash/latest/seahash/#design-advantages-and-features: \u00a7\n\u27e85\u27e9 https://docs.rs/seahash/latest/seahash/#a-word-of-warning: \u00a7\n\u27e86\u27e9 https://docs.rs/seahash/latest/seahash/#benchmark: \u00a7\n\u27e87\u27e9 https://docs.rs/seahash/latest/seahash/#ideal-architecture: \u00a7\n\u27e88\u27e9 https://docs.rs/seahash/latest/seahash/#achieving-the-performance: \u00a7\n\u27e89\u27e9 https://docs.rs/seahash/latest/seahash/#statistical-guarantees: \u00a7\n\u27e810\u27e9 https://docs.rs/seahash/latest/seahash/#inner-workings: \u00a7\n\u27e811\u27e9 http://ticki.github.io/img/seahash_construction_diagram.svg: ![A diagram.\n\u27e812\u27e9 http://ticki.github.io/blog/seahash-explained/: the blog post\n\u27e813\u27e9 https://docs.rs/seahash/latest/seahash/#asic-version: \u00a7\n\u27e814\u27e9 https://docs.rs/seahash/latest/seahash/#specification: \u00a7\n\u27e815\u27e9 https://docs.rs/seahash/latest/seahash/reference: `reference`\n\u27e816\u27e9 https://docs.rs/seahash/latest/seahash/#credits: \u00a7\n\u27e817\u27e9 http://www.pcg-random.org/: PCG family of diffusions\n\u27e818\u27e9 https://docs.rs/seahash/latest/seahash/#modules: \u00a7\n\u27e819\u27e9 https://docs.rs/seahash/latest/seahash/reference/index.html: mod seahash::reference - reference\n\u27e820\u27e9 https://docs.rs/seahash/latest/seahash/#structs: \u00a7\n\u27e821\u27e9 https://docs.rs/seahash/latest/seahash/struct.SeaHasher.html: struct seahash::SeaHasher - SeaHasher\n\u27e822\u27e9 https://docs.rs/seahash/latest/seahash/struct.State.html: struct seahash::State - State\n\u27e823\u27e9 https://docs.rs/seahash/latest/seahash/#functions: \u00a7\n\u27e824\u27e9 https://docs.rs/seahash/latest/seahash/fn.hash.html: fn seahash::hash - hash\n\u27e825\u27e9 https://docs.rs/seahash/latest/seahash/fn.hash_seeded.html: fn seahash::hash_seeded - hash_seeded\n",
            "fit_markdown": "",
            "fit_html": ""
          },
          "downloads": 0,
          "github_stars": 0,
          "dependencies": [],
          "features": {},
          "code_snippets": [],
          "readme_sections": {},
          "librs_downloads": null,
          "source": "crates.io",
          "enhanced_scraping": {},
          "enhanced_features": [],
          "enhanced_dependencies": []
        },
        "enriched_crate": {
          "name": "seahash",
          "version": "4.1.0",
          "description": "ALLOW: Positive community sentiment",
          "repository": "",
          "keywords": [],
          "categories": [],
          "readme": {
            "raw_markdown": "[](https://docs.rs/seahash/latest/seahash/all.html \"show sidebar\")\n# Crate seahashCopy item path\n[Settings](https://docs.rs/seahash/latest/settings.html)\n[Help](https://docs.rs/seahash/latest/help.html)\nSummary[Source](https://docs.rs/seahash/latest/src/seahash/lib.rs.html#1-168)\nExpand description\nSeaHash: A blazingly fast, portable hash function with proven statistical guarantees.\nSeaHash is a hash function with performance better than (around 3-20% improvement) xxHash and MetroHash. Furthermore, SeaHash has mathematically provable statistical guarantees.\nSeaHash is a portable hash function, meaning that the output is not dependent on the hosting architecture, and makes no assumptions on endianness or the alike. This stable layout allows it to be used for on-disk/permanent storage (e.g. checksums).\n## [\u00a7](https://docs.rs/seahash/latest/seahash/#design-advantages-and-features)Design, advantages, and features\n  * **High quality** : It beats most other general purpose hash functions because it provides full avalanche inbetween state updates.\n  * **Performance** : SeaHash beats every high-quality (grading 10/10 in smhasher) hash function that I know of.\n  * **Provable quality guarantees** : Contrary to most other non-cryptographic hash function, SeaHash can be proved to satisfy the avalanche criterion as well as BIC.\n  * **Parallelizable** : Consists of multiple, independent states to take advantage of ILP and/or software threads.\n  * **Bulk reads** : Reads 8 or 4 bytes a time.\n  * **Stable and portable** : Does not depend on the target architecture, and produces a stable value, which is only changed in major version bumps.\n  * **Keyed** : Designed to not leak the seed/key. Note that it has not gone through cryptoanalysis yet, so the keyed version shouldn\u2019t be relied on when security is needed.\n  * **Hardware accelerateable** : SeaHash is designed such that ASICs can implement it with really high performance.\n\n\n## [\u00a7](https://docs.rs/seahash/latest/seahash/#a-word-of-warning)A word of warning!\nThis is **not** a cryptographic function, and it certainly should not be used as one. If you want a good cryptographic hash function, you should use SHA-3 (Keccak) or BLAKE2.\nIt is not secure, nor does it aim to be. It aims to have high quality pseudorandom output and few collisions, as well as being fast.\n## [\u00a7](https://docs.rs/seahash/latest/seahash/#benchmark)Benchmark\nOn normal hardware, it is expected to run with a rate around 5.9-6.7 GB/S on a 2.5 GHz CPU. Further improvement can be seen when hashing very big buffers in parallel.\nFunction| Quality| Cycles per byte (lower is better)| Author  \n---|---|---|---  \n**SeaHash**| **Excellent**| **0.24**| **Ticki**  \nxxHash| Excellent| 0.31| Collet  \nMetroHash| Excellent| 0.35| Rogers  \nMurmur| Excellent| 0.64| Appleby  \nRabin| Medium| 1.51| Rabin  \nCityHash| Excellent| 1.62| Pike, Alakuijala  \nLoseLose| Terrible| 2.01| Kernighan, Ritchie  \nFNV| Poor| 3.12| Fowler, Noll, Vo  \nSipHash| Pseudorandom| 3.21| Aumasson, Bernstein  \nCRC| Good| 3.91| Peterson  \nDJB2| Poor| 4.13| Bernstein  \n### [\u00a7](https://docs.rs/seahash/latest/seahash/#ideal-architecture)Ideal architecture\nSeaHash is designed and optimized for the most common architecture in use:\n  * Little-endian\n  * 64-bit\n  * 64 or more bytes cache lines\n  * 4 or more instruction pipelines\n  * 4 or more 64-bit registers\n\n\nAnything that does not hold the above requirements will perform worse by up to 30-40%. Note that this means it is still faster than CityHash (~1 GB/S), MurMurHash (~2.6 GB/S), FNV (~0.5 GB/S), etc.\n## [\u00a7](https://docs.rs/seahash/latest/seahash/#achieving-the-performance)Achieving the performance\nLike any good general-purpose hash function, SeaHash reads 8 bytes at once effectively reducing the running time by an order of ~5.\nSecondly, SeaHash achieves the performance by heavily exploiting Instruction-Level Parallelism. In particular, it fetches 4 integers in every round and independently diffuses them. This yields four different states, which are finally combined.\n## [\u00a7](https://docs.rs/seahash/latest/seahash/#statistical-guarantees)Statistical guarantees\nSeaHash comes with certain proven guarantees about the statistical properties of the output:\n  1. Pick some _n_ -byte sequence, _s_. The number of _n_ -byte sequence colliding with _s_ is independent of the choice of _s_ (all equivalence class have equal size).\n  2. If you flip any bit in the input, the probability for any bit in the output to be flipped is 0.5.\n  3. The hash value of a sequence of uniformly distributed bytes is itself uniformly distributed.\n\n\nThe first guarantee can be derived through deduction, by proving that the diffusion function is bijective (reverse the XORs and find the congruence inverses to the primes).\nThe second guarantee requires more complex calculations: Construct a matrix of probabilities and set one to certain (1), then apply transformations through the respective operations. The proof is a bit long, but relatively simple.\nThe third guarantee requires proving that the hash value is a tree, such that:\n  * Leafs represents the input values.\n  * Single-child nodes reduce to the diffusion of the child.\n  * Multiple-child nodes reduce to the sum of the children.\n\n\nThen simply show that each of these reductions transform uniformly distributed variables to uniformly distributed variables.\n## [\u00a7](https://docs.rs/seahash/latest/seahash/#inner-workings)Inner workings\nIn technical terms, SeaHash follows a alternating 4-state length-padded Merkle\u2013Damg\u00e5rd construction with an XOR-diffuse compression function (click to enlarge):\n[![A diagram.](http://ticki.github.io/img/seahash_construction_diagram.svg)] (http://ticki.github.io/img/seahash_construction_diagram.svg)\nIt starts with 4 initial states, then it alternates between them (increment, wrap on 4) and does XOR with the respective block. When a state has been visited the diffusion function (f) is applied. The very last block is padded with zeros.\nAfter all the blocks have been gone over, all the states are XOR\u2019d to the number of bytes written. The sum is then passed through the diffusion function, which produces the final hash value.\nThe diffusion function is drawn below.\n```\nx \u2190 px\nx \u2190 x \u2295 ((x \u226b 32) \u226b (x \u226b 60))\nx \u2190 px\n```\n\nThe advantage of having four completely segregated (note that there is no mix round, so they\u2019re entirely independent) states is that fast parallelism is possible. For example, if I were to hash 1 TB, I can spawn up four threads which can run independently without _any_ intercommunication or synchronization before the last round.\nIf the diffusion function (f) was cryptographically secure, it would pass cryptoanalysis trivially. This might seem irrelevant, as it clearly isn\u2019t cryptographically secure, but it tells us something about the inner semantics. In particular, any diffusion function with sufficient statistical quality will make up a good hash function in this construction.\nRead [the blog post](http://ticki.github.io/blog/seahash-explained/) for more details.\n## [\u00a7](https://docs.rs/seahash/latest/seahash/#asic-version)ASIC version\nSeaHash is specifically designed such that it can be efficiently implemented in the form of ASIC while only using very few transistors.\n## [\u00a7](https://docs.rs/seahash/latest/seahash/#specification)Specification\nSee the [`reference`](https://docs.rs/seahash/latest/seahash/reference) module.\n## [\u00a7](https://docs.rs/seahash/latest/seahash/#credits)Credits\nAside for myself (@ticki), there are couple of other people who have helped creating this. Joshua Landau suggested using the [PCG family of diffusions](http://www.pcg-random.org/), created by Melissa E. O\u2019Neill. Sokolov Yura spotted multiple bugs in SeaHash.\n## Modules[\u00a7](https://docs.rs/seahash/latest/seahash/#modules)\n\n[reference](https://docs.rs/seahash/latest/seahash/reference/index.html \"mod seahash::reference\")\n    A slow, but clear reference implementation of SeaHash.\n## Structs[\u00a7](https://docs.rs/seahash/latest/seahash/#structs)\n\n[SeaHasher](https://docs.rs/seahash/latest/seahash/struct.SeaHasher.html \"struct seahash::SeaHasher\")\n    The streaming version of the algorithm.\n\n[State](https://docs.rs/seahash/latest/seahash/struct.State.html \"struct seahash::State\")\n    A SeaHash state.\n## Functions[\u00a7](https://docs.rs/seahash/latest/seahash/#functions)\n\n[hash](https://docs.rs/seahash/latest/seahash/fn.hash.html \"fn seahash::hash\")\n    Hash some buffer.\n\n[hash_seeded](https://docs.rs/seahash/latest/seahash/fn.hash_seeded.html \"fn seahash::hash_seeded\")\n    Hash some buffer according to a chosen seed.\n",
            "markdown_with_citations": "[](https://docs.rs/seahash/latest/seahash/all.html \"show sidebar\")\n# Crate seahashCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nSeaHash: A blazingly fast, portable hash function with proven statistical guarantees.\nSeaHash is a hash function with performance better than (around 3-20% improvement) xxHash and MetroHash. Furthermore, SeaHash has mathematically provable statistical guarantees.\nSeaHash is a portable hash function, meaning that the output is not dependent on the hosting architecture, and makes no assumptions on endianness or the alike. This stable layout allows it to be used for on-disk/permanent storage (e.g. checksums).\n## \u00a7\u27e84\u27e9Design, advantages, and features\n  * **High quality** : It beats most other general purpose hash functions because it provides full avalanche inbetween state updates.\n  * **Performance** : SeaHash beats every high-quality (grading 10/10 in smhasher) hash function that I know of.\n  * **Provable quality guarantees** : Contrary to most other non-cryptographic hash function, SeaHash can be proved to satisfy the avalanche criterion as well as BIC.\n  * **Parallelizable** : Consists of multiple, independent states to take advantage of ILP and/or software threads.\n  * **Bulk reads** : Reads 8 or 4 bytes a time.\n  * **Stable and portable** : Does not depend on the target architecture, and produces a stable value, which is only changed in major version bumps.\n  * **Keyed** : Designed to not leak the seed/key. Note that it has not gone through cryptoanalysis yet, so the keyed version shouldn\u2019t be relied on when security is needed.\n  * **Hardware accelerateable** : SeaHash is designed such that ASICs can implement it with really high performance.\n\n\n## \u00a7\u27e85\u27e9A word of warning!\nThis is **not** a cryptographic function, and it certainly should not be used as one. If you want a good cryptographic hash function, you should use SHA-3 (Keccak) or BLAKE2.\nIt is not secure, nor does it aim to be. It aims to have high quality pseudorandom output and few collisions, as well as being fast.\n## \u00a7\u27e86\u27e9Benchmark\nOn normal hardware, it is expected to run with a rate around 5.9-6.7 GB/S on a 2.5 GHz CPU. Further improvement can be seen when hashing very big buffers in parallel.\nFunction| Quality| Cycles per byte (lower is better)| Author  \n---|---|---|---  \n**SeaHash**| **Excellent**| **0.24**| **Ticki**  \nxxHash| Excellent| 0.31| Collet  \nMetroHash| Excellent| 0.35| Rogers  \nMurmur| Excellent| 0.64| Appleby  \nRabin| Medium| 1.51| Rabin  \nCityHash| Excellent| 1.62| Pike, Alakuijala  \nLoseLose| Terrible| 2.01| Kernighan, Ritchie  \nFNV| Poor| 3.12| Fowler, Noll, Vo  \nSipHash| Pseudorandom| 3.21| Aumasson, Bernstein  \nCRC| Good| 3.91| Peterson  \nDJB2| Poor| 4.13| Bernstein  \n### \u00a7\u27e87\u27e9Ideal architecture\nSeaHash is designed and optimized for the most common architecture in use:\n  * Little-endian\n  * 64-bit\n  * 64 or more bytes cache lines\n  * 4 or more instruction pipelines\n  * 4 or more 64-bit registers\n\n\nAnything that does not hold the above requirements will perform worse by up to 30-40%. Note that this means it is still faster than CityHash (~1 GB/S), MurMurHash (~2.6 GB/S), FNV (~0.5 GB/S), etc.\n## \u00a7\u27e88\u27e9Achieving the performance\nLike any good general-purpose hash function, SeaHash reads 8 bytes at once effectively reducing the running time by an order of ~5.\nSecondly, SeaHash achieves the performance by heavily exploiting Instruction-Level Parallelism. In particular, it fetches 4 integers in every round and independently diffuses them. This yields four different states, which are finally combined.\n## \u00a7\u27e89\u27e9Statistical guarantees\nSeaHash comes with certain proven guarantees about the statistical properties of the output:\n  1. Pick some _n_ -byte sequence, _s_. The number of _n_ -byte sequence colliding with _s_ is independent of the choice of _s_ (all equivalence class have equal size).\n  2. If you flip any bit in the input, the probability for any bit in the output to be flipped is 0.5.\n  3. The hash value of a sequence of uniformly distributed bytes is itself uniformly distributed.\n\n\nThe first guarantee can be derived through deduction, by proving that the diffusion function is bijective (reverse the XORs and find the congruence inverses to the primes).\nThe second guarantee requires more complex calculations: Construct a matrix of probabilities and set one to certain (1), then apply transformations through the respective operations. The proof is a bit long, but relatively simple.\nThe third guarantee requires proving that the hash value is a tree, such that:\n  * Leafs represents the input values.\n  * Single-child nodes reduce to the diffusion of the child.\n  * Multiple-child nodes reduce to the sum of the children.\n\n\nThen simply show that each of these reductions transform uniformly distributed variables to uniformly distributed variables.\n## \u00a7\u27e810\u27e9Inner workings\nIn technical terms, SeaHash follows a alternating 4-state length-padded Merkle\u2013Damg\u00e5rd construction with an XOR-diffuse compression function (click to enlarge):\n![A diagram.\u27e811\u27e9] (http://ticki.github.io/img/seahash_construction_diagram.svg)\nIt starts with 4 initial states, then it alternates between them (increment, wrap on 4) and does XOR with the respective block. When a state has been visited the diffusion function (f) is applied. The very last block is padded with zeros.\nAfter all the blocks have been gone over, all the states are XOR\u2019d to the number of bytes written. The sum is then passed through the diffusion function, which produces the final hash value.\nThe diffusion function is drawn below.\n```\nx \u2190 px\nx \u2190 x \u2295 ((x \u226b 32) \u226b (x \u226b 60))\nx \u2190 px\n```\n\nThe advantage of having four completely segregated (note that there is no mix round, so they\u2019re entirely independent) states is that fast parallelism is possible. For example, if I were to hash 1 TB, I can spawn up four threads which can run independently without _any_ intercommunication or synchronization before the last round.\nIf the diffusion function (f) was cryptographically secure, it would pass cryptoanalysis trivially. This might seem irrelevant, as it clearly isn\u2019t cryptographically secure, but it tells us something about the inner semantics. In particular, any diffusion function with sufficient statistical quality will make up a good hash function in this construction.\nRead the blog post\u27e812\u27e9 for more details.\n## \u00a7\u27e813\u27e9ASIC version\nSeaHash is specifically designed such that it can be efficiently implemented in the form of ASIC while only using very few transistors.\n## \u00a7\u27e814\u27e9Specification\nSee the `reference`\u27e815\u27e9 module.\n## \u00a7\u27e816\u27e9Credits\nAside for myself (@ticki), there are couple of other people who have helped creating this. Joshua Landau suggested using the PCG family of diffusions\u27e817\u27e9, created by Melissa E. O\u2019Neill. Sokolov Yura spotted multiple bugs in SeaHash.\n## Modules\u00a7\u27e818\u27e9\n\nreference\u27e819\u27e9\n    A slow, but clear reference implementation of SeaHash.\n## Structs\u00a7\u27e820\u27e9\n\nSeaHasher\u27e821\u27e9\n    The streaming version of the algorithm.\n\nState\u27e822\u27e9\n    A SeaHash state.\n## Functions\u00a7\u27e823\u27e9\n\nhash\u27e824\u27e9\n    Hash some buffer.\n\nhash_seeded\u27e825\u27e9\n    Hash some buffer according to a chosen seed.\n",
            "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/seahash/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/seahash/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/seahash/latest/src/seahash/lib.rs.html#1-168: Source\n\u27e84\u27e9 https://docs.rs/seahash/latest/seahash/#design-advantages-and-features: \u00a7\n\u27e85\u27e9 https://docs.rs/seahash/latest/seahash/#a-word-of-warning: \u00a7\n\u27e86\u27e9 https://docs.rs/seahash/latest/seahash/#benchmark: \u00a7\n\u27e87\u27e9 https://docs.rs/seahash/latest/seahash/#ideal-architecture: \u00a7\n\u27e88\u27e9 https://docs.rs/seahash/latest/seahash/#achieving-the-performance: \u00a7\n\u27e89\u27e9 https://docs.rs/seahash/latest/seahash/#statistical-guarantees: \u00a7\n\u27e810\u27e9 https://docs.rs/seahash/latest/seahash/#inner-workings: \u00a7\n\u27e811\u27e9 http://ticki.github.io/img/seahash_construction_diagram.svg: ![A diagram.\n\u27e812\u27e9 http://ticki.github.io/blog/seahash-explained/: the blog post\n\u27e813\u27e9 https://docs.rs/seahash/latest/seahash/#asic-version: \u00a7\n\u27e814\u27e9 https://docs.rs/seahash/latest/seahash/#specification: \u00a7\n\u27e815\u27e9 https://docs.rs/seahash/latest/seahash/reference: `reference`\n\u27e816\u27e9 https://docs.rs/seahash/latest/seahash/#credits: \u00a7\n\u27e817\u27e9 http://www.pcg-random.org/: PCG family of diffusions\n\u27e818\u27e9 https://docs.rs/seahash/latest/seahash/#modules: \u00a7\n\u27e819\u27e9 https://docs.rs/seahash/latest/seahash/reference/index.html: mod seahash::reference - reference\n\u27e820\u27e9 https://docs.rs/seahash/latest/seahash/#structs: \u00a7\n\u27e821\u27e9 https://docs.rs/seahash/latest/seahash/struct.SeaHasher.html: struct seahash::SeaHasher - SeaHasher\n\u27e822\u27e9 https://docs.rs/seahash/latest/seahash/struct.State.html: struct seahash::State - State\n\u27e823\u27e9 https://docs.rs/seahash/latest/seahash/#functions: \u00a7\n\u27e824\u27e9 https://docs.rs/seahash/latest/seahash/fn.hash.html: fn seahash::hash - hash\n\u27e825\u27e9 https://docs.rs/seahash/latest/seahash/fn.hash_seeded.html: fn seahash::hash_seeded - hash_seeded\n",
            "fit_markdown": "",
            "fit_html": ""
          },
          "downloads": 0,
          "github_stars": 0,
          "dependencies": [],
          "features": {},
          "code_snippets": [],
          "readme_sections": {},
          "librs_downloads": null,
          "source": "crates.io",
          "enhanced_scraping": {},
          "enhanced_features": [],
          "enhanced_dependencies": [],
          "readme_summary": "The `seahash` crate provides a fast, portable, and high-quality non-cryptographic hash function with proven statistical guarantees, outperforming other popular hash functions like xxHash and MetroHash. It features architecture-independent output, parallelizable design, bulk reads, and keyed hashing (not for security purposes). Optimized for modern hardware, it achieves exceptional performance through instruction-level parallelism and is suitable for tasks like checksums or on-disk storage.",
          "feature_summary": null,
          "use_case": "Utilities",
          "score": 6.0,
          "factual_counterfactual": "### Pair 1: Statistical Guarantees  \n\u2705 **Factual:** SeaHash provides mathematically proven statistical guarantees, including uniform distribution of hash values for uniformly distributed input bytes.  \n\u274c **Counterfactual:** SeaHash guarantees cryptographic security and resistance against all known attack vectors, making it suitable for secure password hashing.  \n\n---\n\n### Pair 2: Performance  \n\u2705 **Factual:** SeaHash achieves superior performance compared to xxHash and MetroHash, with a cycle-per-byte rate of 0.24, making it one of the fastest general-purpose hash functions.  \n\u274c **Counterfactual:** SeaHash sacrifices performance for statistical guarantees, resulting in slower hashing speeds compared to xxHash and MetroHash.  \n\n---\n\n### Pair 3: Portability  \n\u2705 **Factual:** SeaHash is portable and produces consistent outputs across different architectures, making it suitable for on-disk storage and checksums.  \n\u274c **Counterfactual:** SeaHash's output varies depending on the host architecture, making it unsuitable for applications requiring stable, cross-platform hash values.",
          "source_analysis": null,
          "user_behavior": null,
          "security": null
        }
      },
      "irl_score": 8.6,
      "execution_id": "exec-efacd25c-c8be97ae-1751260969",
      "timestamp": "2025-06-30T05:22:49.120028+00:00",
      "canon_version": "1.3.0"
    },
    "rule_zero_compliant": true
  }
]