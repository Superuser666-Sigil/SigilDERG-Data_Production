[
  {
    "execution_id": "exec-d007f64e-8fd8e95b-1751261038",
    "timestamp": "2025-06-30T05:23:58.598423+00:00",
    "sacred_chain": {
      "input_data": "getrandom",
      "context_sources": [
        "crates.io",
        "github.com",
        "lib.rs",
        "docs.rs"
      ],
      "reasoning_steps": [
        "Input canonicalized: 'getrandom' -> 'getrandom'",
        "Context gathered from 4 validated sources",
        "Metadata extracted: 4 fields",
        "Documentation analyzed: quality 7.0",
        "Sentiment analyzed: positive",
        "Ecosystem analyzed: utilities",
        "Quality score synthesized: 7.50",
        "Trust decision: DEFER - Insufficient data for decision",
        "IRL confidence: 8.600"
      ],
      "suggestion": "ALLOW: Positive community sentiment",
      "verdict": "DEFER",
      "audit_info": {
        "metadata": {
          "name": "getrandom",
          "type": "rust_crate",
          "source": "manual_input",
          "extraction_method": "irl_engine"
        },
        "sentiment": {
          "quality_score": 7.0,
          "completeness": 0.8,
          "examples_present": true,
          "api_documented": true
        },
        "ecosystem": {
          "overall": "positive",
          "positive_mentions": 10,
          "negative_mentions": 2,
          "neutral_mentions": 5,
          "total_mentions": 17
        },
        "quality_score": 7.5,
        "verdict_reason": "Insufficient data for decision",
        "sanitized_documentation": {
          "crates_io": {
            "url": "https://crates.io/crates/getrandom",
            "title": "getrandom v0.3.3",
            "content": {
              "raw_markdown": "#  getrandom v0.3.3\nA small cross-platform library for retrieving random data from system source \n  * [ Readme ](https://crates.io/crates/getrandom)\n  * [ 40 Versions ](https://crates.io/crates/getrandom/versions)\n  * [ Dependencies ](https://crates.io/crates/getrandom/dependencies)\n  * [ Dependents ](https://crates.io/crates/getrandom/reverse_dependencies)\n\n\n## Metadata\nabout 2 months ago \nv1.63.0 \n[ MIT ](https://choosealicense.com/licenses/mit) OR [ Apache-2.0 ](https://choosealicense.com/licenses/apache-2.0)\n48.3 KiB \n## Install\nRun the following Cargo command in your project directory:\ncargo add getrandom\nOr add the following line to your Cargo.toml:\ngetrandom = \"0.3.3\"\n## Documentation\n[ docs.rs/getrandom ](https://docs.rs/getrandom)\n## Repository\n[ github.com/rust-random/getrandom ](https://github.com/rust-random/getrandom)\n## Owners\n## Categories\n  * [No standard library](https://crates.io/categories/no-std)\n  * [Operating systems](https://crates.io/categories/os)\n\n\n[ Report crate ](https://crates.io/support?crate=getrandom&inquire=crate-violation)\n### Stats Overview\n552,338,205 Downloads all time\n40 Versions published\n#### Downloads over the last 90 days\nDisplay as \nStacked \n  * Stacked \n  * Unstacked \n\n\nLoading\u2026\n",
              "markdown_with_citations": "#  getrandom v0.3.3\nA small cross-platform library for retrieving random data from system source \n  *  Readme \u27e81\u27e9\n  *  40 Versions \u27e82\u27e9\n  *  Dependencies \u27e83\u27e9\n  *  Dependents \u27e84\u27e9\n\n\n## Metadata\nabout 2 months ago \nv1.63.0 \n MIT \u27e85\u27e9 OR  Apache-2.0 \u27e86\u27e9\n48.3 KiB \n## Install\nRun the following Cargo command in your project directory:\ncargo add getrandom\nOr add the following line to your Cargo.toml:\ngetrandom = \"0.3.3\"\n## Documentation\n docs.rs/getrandom \u27e87\u27e9\n## Repository\n github.com/rust-random/getrandom \u27e88\u27e9\n## Owners\n## Categories\n  * No standard library\u27e89\u27e9\n  * Operating systems\u27e810\u27e9\n\n\n Report crate \u27e811\u27e9\n### Stats Overview\n552,338,205 Downloads all time\n40 Versions published\n#### Downloads over the last 90 days\nDisplay as \nStacked \n  * Stacked \n  * Unstacked \n\n\nLoading\u2026\n",
              "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://crates.io/crates/getrandom:  Readme \n\u27e82\u27e9 https://crates.io/crates/getrandom/versions:  40 Versions \n\u27e83\u27e9 https://crates.io/crates/getrandom/dependencies:  Dependencies \n\u27e84\u27e9 https://crates.io/crates/getrandom/reverse_dependencies:  Dependents \n\u27e85\u27e9 https://choosealicense.com/licenses/mit:  MIT \n\u27e86\u27e9 https://choosealicense.com/licenses/apache-2.0:  Apache-2.0 \n\u27e87\u27e9 https://docs.rs/getrandom:  docs.rs/getrandom \n\u27e88\u27e9 https://github.com/rust-random/getrandom:  github.com/rust-random/getrandom \n\u27e89\u27e9 https://crates.io/categories/no-std: No standard library\n\u27e810\u27e9 https://crates.io/categories/os: Operating systems\n\u27e811\u27e9 https://crates.io/support?crate=getrandom&inquire=crate-violation:  Report crate \n",
              "fit_markdown": "",
              "fit_html": ""
            },
            "structured_data": {},
            "quality_score": 3.0,
            "extraction_method": "crawl4ai",
            "error": null,
            "metadata": {
              "doc_type": "docs",
              "content_length": 1242,
              "has_structured_data": false,
              "crawl_success": true
            },
            "timestamp": "114828.4766475"
          },
          "docs_rs": {
            "url": "https://docs.rs/getrandom",
            "title": "Crate getrandomCopy item path",
            "content": {
              "raw_markdown": "[](https://docs.rs/getrandom/latest/getrandom/all.html \"show sidebar\")\n# Crate getrandomCopy item path\n[Settings](https://docs.rs/getrandom/latest/settings.html)\n[Help](https://docs.rs/getrandom/latest/help.html)\nSummary[Source](https://docs.rs/getrandom/latest/src/getrandom/lib.rs.html#2-143)\nExpand description\n## [\u00a7](https://docs.rs/getrandom/latest/getrandom/#getrandom-systems-random-number-generator)getrandom: system\u2019s random number generator\n[![Build Status](https://github.com/rust-random/getrandom/actions/workflows/tests.yml/badge.svg?branch=master)](https://github.com/rust-random/getrandom/actions?query=branch:master) [![Crate](https://img.shields.io/crates/v/getrandom)](https://crates.io/crates/getrandom) [![Documentation](https://docs.rs/getrandom/badge.svg)](https://docs.rs/getrandom) [![Dependency Status](https://deps.rs/repo/github/rust-random/getrandom/status.svg)](https://deps.rs/repo/github/rust-random/getrandom) [![Downloads](https://img.shields.io/crates/d/getrandom)](https://crates.io/crates/getrandom) [![License](https://img.shields.io/crates/l/getrandom)](https://github.com/rust-random/getrandom/blob/master/LICENSE-MIT)\n`getrandom` is a Rust library for retrieving random data from (operating) system sources.\nIt is assumed that the system always provides high-quality, cryptographically secure random data, ideally backed by hardware entropy sources. This crate derives its name from the Linux `getrandom` syscall but is cross-platform, roughly supporting the same set of platforms as Rust\u2019s `std` library.\nThis is a low-level API. Most users should prefer using a higher-level random-number library like [`rand`](https://crates.io/crates/rand).\n### [\u00a7](https://docs.rs/getrandom/latest/getrandom/#usage)Usage\nAdd the `getrandom` dependency to your `Cargo.toml` file:\n```\n[dependencies]\ngetrandom = \"0.3\"\n```\n\nThen invoke the `fill` function on a byte buffer to fill it with random data:\n```\nfn get_random_u128() -> Result<u128, getrandom::Error> {\n  let mut buf = [0u8; 16];\n  getrandom::fill(&mut buf)?;\n  Ok(u128::from_ne_bytes(buf))\n}\n```\n\n### [\u00a7](https://docs.rs/getrandom/latest/getrandom/#supported-targets)Supported targets\nTarget| Target Triple| Implementation  \n---|---|---  \nLinux, Android| `*\u2011linux\u2011*`| [`getrandom`](https://manned.org/getrandom.2) system call if available, otherwise [`/dev/urandom`](https://manned.org/urandom.4) after successfully polling `/dev/random`  \nWindows 10+| `*\u2011windows\u2011*`| [`ProcessPrng`](https://learn.microsoft.com/en-us/windows/win32/seccng/processprng) on Rust 1.78+, [`RtlGenRandom`](https://learn.microsoft.com/en-us/windows/win32/api/ntsecapi/nf-ntsecapi-rtlgenrandom) otherwise  \nWindows 7, 8| `*-win7\u2011windows\u2011*`| [`RtlGenRandom`](https://learn.microsoft.com/en-us/windows/win32/api/ntsecapi/nf-ntsecapi-rtlgenrandom)  \nmacOS| `*\u2011apple\u2011darwin`| [`getentropy`](https://www.unix.com/man-page/mojave/2/getentropy/)  \niOS, tvOS, watchOS| `*\u2011apple\u2011{ios,tvos,watchos}`| [`CCRandomGenerateBytes`](https://opensource.apple.com/source/CommonCrypto/CommonCrypto-60074/include/CommonRandom.h.auto.html)  \nFreeBSD| `*\u2011freebsd`| [`getrandom`](https://www.freebsd.org/cgi/man.cgi?query=getrandom&manpath=FreeBSD+12.0-stable)  \nOpenBSD| `*\u2011openbsd`| [`getentropy`](https://man.openbsd.org/getentropy.2)  \nNetBSD| `*\u2011netbsd`| [`getrandom`](https://man.netbsd.org/getrandom.2) if available, otherwise [`kern.arandom`](https://man.netbsd.org/sysctl.7)  \nDragonfly BSD| `*\u2011dragonfly`| [`getrandom`](https://leaf.dragonflybsd.org/cgi/web-man?command=getrandom)  \nSolaris| `*\u2011solaris`| [`getrandom`](https://docs.oracle.com/cd/E88353_01/html/E37841/getrandom-2.html) with `GRND_RANDOM`  \nillumos| `*\u2011illumos`| [`getrandom`](https://illumos.org/man/2/getrandom)  \nFuchsia OS| `*\u2011fuchsia`| [`cprng_draw`](https://fuchsia.dev/fuchsia-src/zircon/syscalls/cprng_draw)  \nRedox| `*\u2011redox`| `/dev/urandom`  \nHaiku| `*\u2011haiku`| `/dev/urandom` (identical to `/dev/random`)  \nHermit| `*-hermit`| [`sys_read_entropy`](https://github.com/hermit-os/kernel/blob/315f58ff5efc81d9bf0618af85a59963ff55f8b1/src/syscalls/entropy.rs#L47-L55)  \nHurd| `*-hurd-*`| [`getrandom`](https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-getrandom)  \nSGX| `x86_64\u2011*\u2011sgx`| [`RDRAND`](https://software.intel.com/en-us/articles/intel-digital-random-number-generator-drng-software-implementation-guide)  \nVxWorks| `*\u2011wrs\u2011vxworks\u2011*`| `randABytes` after checking entropy pool initialization with `randSecure`  \nEmscripten| `*\u2011emscripten`| [`getentropy`](https://github.com/emscripten-core/emscripten/pull/12240)  \nWASI 0.1| `wasm32\u2011wasip1`| [`random_get`](https://github.com/WebAssembly/WASI/blob/snapshot-01/phases/snapshot/docs.md#-random_getbuf-pointeru8-buf_len-size---errno)  \nWASI 0.2| `wasm32\u2011wasip2`| [`get-random-u64`](https://github.com/WebAssembly/WASI/blob/v0.2.1/wasip2/random/random.wit#L23-L28)  \nSOLID| `*-kmc-solid_*`| `SOLID_RNG_SampleRandomBytes`  \nNintendo 3DS| `*-nintendo-3ds`| [`getrandom`](https://github.com/rust3ds/shim-3ds/commit/b01d2568836dea2a65d05d662f8e5f805c64389d)  \nESP-IDF| `*\u2011espidf`| [`esp_fill_random`](https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-reference/system/random.html#functions) WARNING: see \u201cEarly Boot\u201d section below  \nPS Vita| `*-vita-*`| [`getentropy`](https://github.com/vitasdk/newlib/blob/2d869fe47aaf02b8e52d04e9a2b79d5b210fd016/newlib/libc/sys/vita/getentropy.c)  \nQNX Neutrino| `*\u2011nto-qnx*`| [`/dev/urandom`](https://www.qnx.com/developers/docs/7.1/index.html#com.qnx.doc.neutrino.utilities/topic/r/random.html) (identical to `/dev/random`)  \nAIX| `*-ibm-aix`| [`/dev/urandom`](https://www.ibm.com/docs/en/aix/7.3?topic=files-random-urandom-devices)  \nCygwin| `*-cygwin`| [`getrandom`](https://github.com/cygwin/cygwin/blob/main/winsup/cygwin/libc/getentropy.cc) (based on [`RtlGenRandom`](https://learn.microsoft.com/en-us/windows/win32/api/ntsecapi/nf-ntsecapi-rtlgenrandom))  \nPull Requests that add support for new targets to `getrandom` are always welcome.\n#### [\u00a7](https://docs.rs/getrandom/latest/getrandom/#opt-in-backends)Opt-in backends\n`getrandom` also provides optional (opt-in) backends, which allow users to customize the source of randomness based on their specific needs:\nBackend name| Target| Target Triple| Implementation  \n---|---|---|---  \n`linux_getrandom`| Linux, Android| `*\u2011linux\u2011*`| [`getrandom`](https://manned.org/getrandom.2) system call (without `/dev/urandom` fallback). Bumps minimum supported Linux kernel version to 3.17 and Android API level to 23 (Marshmallow).  \n`linux_raw`| Linux, Android| `*\u2011linux\u2011*`| Same as `linux_getrandom`, but uses raw `asm!`-based syscalls instead of `libc`.  \n`rdrand`| x86, x86-64| `x86_64-*`, `i686-*`| [`RDRAND`](https://software.intel.com/en-us/articles/intel-digital-random-number-generator-drng-software-implementation-guide) instruction  \n`rndr`| AArch64| `aarch64-*`| [`RNDR`](https://developer.arm.com/documentation/ddi0601/2024-06/AArch64-Registers/RNDR--Random-Number) register  \n`wasm_js`| Web Browser, Node.js| `wasm32\u2011unknown\u2011unknown`, `wasm32v1-none`| [`Crypto.getRandomValues`](https://www.w3.org/TR/WebCryptoAPI/#Crypto-method-getRandomValues). Requires feature `wasm_js` ([see below](https://docs.rs/getrandom/latest/getrandom/#webassembly-support)).  \n`efi_rng`| UEFI| `*-unknown\u2011uefi`| [`EFI_RNG_PROTOCOL`](https://uefi.org/specs/UEFI/2.10/37_Secure_Technologies.html#efi-rng-protocol) with `EFI_RNG_ALGORITHM_RAW` (requires `std` and Nigthly compiler)  \n`custom`| All targets| `*`| User-provided custom implementation (see [custom backend](https://docs.rs/getrandom/latest/getrandom/#custom-backend))  \nOpt-in backends can be enabled using the `getrandom_backend` configuration flag. The flag can be set either by specifying the `rustflags` field in [`.cargo/config.toml`](https://doc.rust-lang.org/cargo/reference/config.html):\n```\n# It's recommended to set the flag on a per-target basis:\n[target.wasm32-unknown-unknown]\nrustflags = ['--cfg', 'getrandom_backend=\"wasm_js\"']\n```\n\nOr by using the `RUSTFLAGS` environment variable:\n```\nRUSTFLAGS='--cfg getrandom_backend=\"linux_getrandom\"' cargo build\n```\n\nEnabling an opt-in backend will replace the backend used by default. Doing this for an incorrect target (e.g. using `linux_getrandom` while compiling for a Windows target) will result in a compilation error. Be extremely careful while using opt-in backends, as incorrect configuration may result in vulnerable applications or applications that always panic.\nNote that using an opt-in backend in a library (e.g. for tests or benchmarks) WILL NOT have any effect on its downstream users.\n#### [\u00a7](https://docs.rs/getrandom/latest/getrandom/#raw-linux-syscall-support)Raw Linux syscall support\nCurrently the `linux_raw` backend supports only targets with stabilized `asm!` macro, i.e. `arm`, `aarch64`, `loongarch64`, `riscv32`, `riscv64`, `s390x`, `x86`, and `x86_64`.\nNote that the raw syscall backend may be slower than backends based on `libc::getrandom`, e.g. it does not implement vDSO optimizations and on `x86` it uses the infamously slow `int 0x80` instruction to perform syscall.\n#### [\u00a7](https://docs.rs/getrandom/latest/getrandom/#webassembly-support)WebAssembly support\nThis crate fully supports the [WASI](https://github.com/WebAssembly/WASI) and [Emscripten](https://emscripten.org) targets. However, the `wasm32-unknown-unknown` target (i.e. the target used by `wasm-pack`) is not automatically supported since, from the target name alone, we cannot deduce which JavaScript interface should be used (or if JavaScript is available at all).\nTo enable `getrandom`\u2019s functionality on `wasm32-unknown-unknown` using the Web Crypto methods [described above](https://docs.rs/getrandom/latest/getrandom/#opt-in-backends) via [`wasm-bindgen`](https://github.com/rustwasm/wasm-bindgen), do _both_ of the following:\n  * Use the `wasm_js` feature flag, i.e. `getrandom = { version = \"0.3\", features = [\"wasm_js\"] }`. On its own, this only makes the backend available. (As a side effect this will make your `Cargo.lock` significantly larger if you are not already using [`wasm-bindgen`](https://github.com/rustwasm/wasm-bindgen), but otherwise enabling this feature is harmless.)\n  * Set `RUSTFLAGS='--cfg getrandom_backend=\"wasm_js\"'` ([see above](https://docs.rs/getrandom/latest/getrandom/#opt-in-backends)).\n\n\nThis backend supports both web browsers (main window and Web Workers) and Node.js (v19 or later) environments.\nWARNING: It is highly recommended to enable the `wasm_js` feature only for binary crates and tests, i.e. avoid unconditionally enabling it in library crates.\n#### [\u00a7](https://docs.rs/getrandom/latest/getrandom/#custom-backend)Custom backend\nIf this crate does not support your target out of the box or you have to use a non-default entropy source, then you can provide a custom implementation. You need to enable the custom backend as described in the [opt-in backends](https://docs.rs/getrandom/latest/getrandom/#opt-in-backends) section.\nNext, you need to define an `extern` function with the following signature:\n```\nuse getrandom::Error;\n#[no_mangle]\nunsafe extern \"Rust\" fn __getrandom_v03_custom(\n  dest: *mut u8,\n  len: usize,\n) -> Result<(), Error> {\n  todo!()\n}\n```\n\nThis function should, ideally, be defined in the root crate of your project, e.g. in your `main.rs`. This function MUST be defined only once for your project, i.e. upstream library crates SHOULD NOT define it outside of tests and benchmarks. Improper configuration of this backend may result in linking errors.\nThe function accepts a pointer to a buffer that should be filled with random data and its length in bytes. Note that the buffer MAY be uninitialized. On success, the function should return `Ok(())` and fully fill the input buffer; otherwise, it should return an error value.\nWhile wrapping functions which work with byte slices you should fully initialize the buffer before passing it to the function:\n```\nuse getrandom::Error;\nfn my_entropy_source(buf: &mut [u8]) -> Result<(), getrandom::Error> {\n  // ...\n  Ok(())\n}\n#[no_mangle]\nunsafe extern \"Rust\" fn __getrandom_v03_custom(\n  dest: *mut u8,\n  len: usize,\n) -> Result<(), Error> {\n  let buf = unsafe {\n    // fill the buffer with zeros\n    core::ptr::write_bytes(dest, 0, len);\n    // create mutable byte slice\n    core::slice::from_raw_parts_mut(dest, len)\n  };\n  my_entropy_source(buf)\n}\n```\n\nIf you are confident that `getrandom` is not used in your project, but it gets pulled nevertheless by one of your dependencies, then you can use the following custom backend, which always returns the \u201cunsupported\u201d error:\n```\nuse getrandom::Error;\n#[no_mangle]\nunsafe extern \"Rust\" fn __getrandom_v03_custom(\n  dest: *mut u8,\n  len: usize,\n) -> Result<(), Error> {\n  Err(Error::UNSUPPORTED)\n}\n```\n\n#### [\u00a7](https://docs.rs/getrandom/latest/getrandom/#platform-support)Platform Support\nThis crate generally supports the same operating system and platform versions that the Rust standard library does. Additional targets may be supported using the opt-in custom backend.\nThis means that as Rust drops support for old versions of operating systems (such as old Linux kernel versions, Android API levels, etc.) in stable releases, `getrandom` may create new patch releases that remove support for outdated platform versions.\n#### [\u00a7](https://docs.rs/getrandom/latest/getrandom/#devurandom-fallback-on-linux-and-android)`/dev/urandom` fallback on Linux and Android\nOn Linux targets, the `/dev/urandom` fallback is present only if either `target_env` is `musl`, or `target_arch` is one of the following: `aarch64`, `arm`, `powerpc`, `powerpc64`, `s390x`, `x86`, `x86_64`. Other supported targets [require](https://doc.rust-lang.org/stable/rustc/platform-support.html) kernel versions that support the `getrandom` system call, so the fallback is not needed.\nOn Android targets the fallback is present only for the following `target_arch`es: `aarch64`, `arm`, `x86`, `x86_64`. Other `target_arch`es (e.g. RISC-V) require sufficiently high API levels.\nThe fallback can be disabled by enabling the `linux_getrandom` opt-in backend. Note that doing so will bump minimum supported Linux kernel version to 3.17 and Android API level to 23 (Marshmallow).\n#### [\u00a7](https://docs.rs/getrandom/latest/getrandom/#early-boot)Early boot\nSometimes, early in the boot process, the OS has not collected enough entropy to securely seed its RNG. This is especially common on virtual machines, where standard \u201crandom\u201d events are hard to come by.\nSome operating system interfaces always block until the RNG is securely seeded. This can take anywhere from a few seconds to more than a minute. A few (Linux, NetBSD and Solaris) offer a choice between blocking and getting an error; in these cases, we always choose to block.\nOn Linux (when the `getrandom` system call is not available), reading from `/dev/urandom` never blocks, even when the OS hasn\u2019t collected enough entropy yet. To avoid returning low-entropy bytes, we first poll `/dev/random` and only switch to `/dev/urandom` once this has succeeded.\nOn OpenBSD, this kind of entropy accounting isn\u2019t available, and on NetBSD, blocking on it is discouraged. On these platforms, nonblocking interfaces are used, even when reliable entropy may not be available. On the platforms where it is used, the reliability of entropy accounting itself isn\u2019t free from controversy. This library provides randomness sourced according to the platform\u2019s best practices, but each platform has its own limits on the grade of randomness it can promise in environments with few sources of entropy.\nOn ESP-IDF, if `esp_fill_random` is used before enabling WiFi, BT, or the voltage noise entropy source (SAR ADC), the Hardware RNG will only be seeded via RC_FAST_CLK. This can occur during early boot unless `bootloader_random_enable()` is called. For more information see the [ESP-IDF RNG Docs](https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-reference/system/random.html) or the [RNG section of the ESP32 Technical Reference Manual](https://www.espressif.com/sites/default/files/documentation/esp32_technical_reference_manual_en.pdf#rng).\n### [\u00a7](https://docs.rs/getrandom/latest/getrandom/#error-handling)Error handling\nWe always prioritize failure over returning known insecure \u201crandom\u201d bytes. Generally, on supported platforms, failure is highly unlikely, though not impossible. If an error does occur, it is likely that it will occur on every call to `getrandom`. Therefore, after the first successful call, one can be reasonably confident that no errors will occur.\n### [\u00a7](https://docs.rs/getrandom/latest/getrandom/#panic-handling)Panic handling\nWe strive to eliminate all potential panics from our backend implementations. In other words, when compiled with optimizations enabled, the generated binary code for `getrandom` functions should not contain any panic branches. Even if the platform misbehaves and returns an unexpected result, our code should correctly handle it and return an error, e.g. [`Error::UNEXPECTED`](https://docs.rs/getrandom/latest/getrandom/struct.Error.html#associatedconstant.UNEXPECTED \"associated constant getrandom::Error::UNEXPECTED\").\n### [\u00a7](https://docs.rs/getrandom/latest/getrandom/#sanitizer-support)Sanitizer support\nIf your code uses [`fill_uninit`](https://docs.rs/getrandom/latest/getrandom/fn.fill_uninit.html \"fn getrandom::fill_uninit\") and you enable [MemorySanitizer](https://doc.rust-lang.org/beta/unstable-book/compiler-flags/sanitizer.html#memorysanitizer) (i.e. `-Zsanitizer=memory`), we will automatically handle unpoisoning of the destination buffer filled by `fill_uninit`.\nYou can run sanitizer tests for your crate dependent on `getrandom` like this:\n```\nRUSTFLAGS=\"-Zsanitizer=memory\" cargo test -Zbuild-std --target=x86_64-unknown-linux-gnu\n```\n\n### [\u00a7](https://docs.rs/getrandom/latest/getrandom/#minimum-supported-rust-version)Minimum Supported Rust Version\nThis crate requires Rust 1.63 or later.\n### [\u00a7](https://docs.rs/getrandom/latest/getrandom/#license)License\nThe `getrandom` library is distributed under either of\n  * [Apache License, Version 2.0](https://github.com/rust-random/getrandom/blob/master/LICENSE-APACHE)\n  * [MIT license](https://github.com/rust-random/getrandom/blob/master/LICENSE-MIT)\n\n\nat your option.\n#### [\u00a7](https://docs.rs/getrandom/latest/getrandom/#contribution)Contribution\nUnless you explicitly state otherwise, any contribution intentionally submitted for inclusion in the work by you, as defined in the Apache-2.0 license, shall be dual licensed as above, without any additional terms or conditions.\n## Structs[\u00a7](https://docs.rs/getrandom/latest/getrandom/#structs)\n\n[Error](https://docs.rs/getrandom/latest/getrandom/struct.Error.html \"struct getrandom::Error\")\n    A small and `no_std` compatible error type\n## Functions[\u00a7](https://docs.rs/getrandom/latest/getrandom/#functions)\n\n[fill](https://docs.rs/getrandom/latest/getrandom/fn.fill.html \"fn getrandom::fill\")\n    Fill `dest` with random bytes from the system\u2019s preferred random number source.\n\n[fill_uninit](https://docs.rs/getrandom/latest/getrandom/fn.fill_uninit.html \"fn getrandom::fill_uninit\")\n    Fill potentially uninitialized buffer `dest` with random bytes from the system\u2019s preferred random number source and return a mutable reference to those bytes.\n\n[u32](https://docs.rs/getrandom/latest/getrandom/fn.u32.html \"fn getrandom::u32\")\n    Get random `u32` from the system\u2019s preferred random number source.\n\n[u64](https://docs.rs/getrandom/latest/getrandom/fn.u64.html \"fn getrandom::u64\")\n    Get random `u64` from the system\u2019s preferred random number source.\n",
              "markdown_with_citations": "[](https://docs.rs/getrandom/latest/getrandom/all.html \"show sidebar\")\n# Crate getrandomCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\n## \u00a7\u27e84\u27e9getrandom: system\u2019s random number generator\n![Build Status\u27e85\u27e9](https://github.com/rust-random/getrandom/actions?query=branch:master) ![Crate\u27e86\u27e9](https://crates.io/crates/getrandom) ![Documentation\u27e87\u27e9](https://docs.rs/getrandom) ![Dependency Status\u27e88\u27e9](https://deps.rs/repo/github/rust-random/getrandom) ![Downloads\u27e89\u27e9](https://crates.io/crates/getrandom) ![License\u27e810\u27e9](https://github.com/rust-random/getrandom/blob/master/LICENSE-MIT)\n`getrandom` is a Rust library for retrieving random data from (operating) system sources.\nIt is assumed that the system always provides high-quality, cryptographically secure random data, ideally backed by hardware entropy sources. This crate derives its name from the Linux `getrandom` syscall but is cross-platform, roughly supporting the same set of platforms as Rust\u2019s `std` library.\nThis is a low-level API. Most users should prefer using a higher-level random-number library like `rand`\u27e811\u27e9.\n### \u00a7\u27e812\u27e9Usage\nAdd the `getrandom` dependency to your `Cargo.toml` file:\n```\n[dependencies]\ngetrandom = \"0.3\"\n```\n\nThen invoke the `fill` function on a byte buffer to fill it with random data:\n```\nfn get_random_u128() -> Result<u128, getrandom::Error> {\n  let mut buf = [0u8; 16];\n  getrandom::fill(&mut buf)?;\n  Ok(u128::from_ne_bytes(buf))\n}\n```\n\n### \u00a7\u27e813\u27e9Supported targets\nTarget| Target Triple| Implementation  \n---|---|---  \nLinux, Android| `*\u2011linux\u2011*`| `getrandom`\u27e814\u27e9 system call if available, otherwise `/dev/urandom`\u27e815\u27e9 after successfully polling `/dev/random`  \nWindows 10+| `*\u2011windows\u2011*`| `ProcessPrng`\u27e816\u27e9 on Rust 1.78+, `RtlGenRandom`\u27e817\u27e9 otherwise  \nWindows 7, 8| `*-win7\u2011windows\u2011*`| `RtlGenRandom`\u27e817\u27e9  \nmacOS| `*\u2011apple\u2011darwin`| `getentropy`\u27e818\u27e9  \niOS, tvOS, watchOS| `*\u2011apple\u2011{ios,tvos,watchos}`| `CCRandomGenerateBytes`\u27e819\u27e9  \nFreeBSD| `*\u2011freebsd`| `getrandom`\u27e820\u27e9  \nOpenBSD| `*\u2011openbsd`| `getentropy`\u27e821\u27e9  \nNetBSD| `*\u2011netbsd`| `getrandom`\u27e822\u27e9 if available, otherwise `kern.arandom`\u27e823\u27e9  \nDragonfly BSD| `*\u2011dragonfly`| `getrandom`\u27e824\u27e9  \nSolaris| `*\u2011solaris`| `getrandom`\u27e825\u27e9 with `GRND_RANDOM`  \nillumos| `*\u2011illumos`| `getrandom`\u27e826\u27e9  \nFuchsia OS| `*\u2011fuchsia`| `cprng_draw`\u27e827\u27e9  \nRedox| `*\u2011redox`| `/dev/urandom`  \nHaiku| `*\u2011haiku`| `/dev/urandom` (identical to `/dev/random`)  \nHermit| `*-hermit`| `sys_read_entropy`\u27e828\u27e9  \nHurd| `*-hurd-*`| `getrandom`\u27e829\u27e9  \nSGX| `x86_64\u2011*\u2011sgx`| `RDRAND`\u27e830\u27e9  \nVxWorks| `*\u2011wrs\u2011vxworks\u2011*`| `randABytes` after checking entropy pool initialization with `randSecure`  \nEmscripten| `*\u2011emscripten`| `getentropy`\u27e831\u27e9  \nWASI 0.1| `wasm32\u2011wasip1`| `random_get`\u27e832\u27e9  \nWASI 0.2| `wasm32\u2011wasip2`| `get-random-u64`\u27e833\u27e9  \nSOLID| `*-kmc-solid_*`| `SOLID_RNG_SampleRandomBytes`  \nNintendo 3DS| `*-nintendo-3ds`| `getrandom`\u27e834\u27e9  \nESP-IDF| `*\u2011espidf`| `esp_fill_random`\u27e835\u27e9 WARNING: see \u201cEarly Boot\u201d section below  \nPS Vita| `*-vita-*`| `getentropy`\u27e836\u27e9  \nQNX Neutrino| `*\u2011nto-qnx*`| `/dev/urandom`\u27e837\u27e9 (identical to `/dev/random`)  \nAIX| `*-ibm-aix`| `/dev/urandom`\u27e838\u27e9  \nCygwin| `*-cygwin`| `getrandom`\u27e839\u27e9 (based on `RtlGenRandom`\u27e817\u27e9)  \nPull Requests that add support for new targets to `getrandom` are always welcome.\n#### \u00a7\u27e840\u27e9Opt-in backends\n`getrandom` also provides optional (opt-in) backends, which allow users to customize the source of randomness based on their specific needs:\nBackend name| Target| Target Triple| Implementation  \n---|---|---|---  \n`linux_getrandom`| Linux, Android| `*\u2011linux\u2011*`| `getrandom`\u27e814\u27e9 system call (without `/dev/urandom` fallback). Bumps minimum supported Linux kernel version to 3.17 and Android API level to 23 (Marshmallow).  \n`linux_raw`| Linux, Android| `*\u2011linux\u2011*`| Same as `linux_getrandom`, but uses raw `asm!`-based syscalls instead of `libc`.  \n`rdrand`| x86, x86-64| `x86_64-*`, `i686-*`| `RDRAND`\u27e830\u27e9 instruction  \n`rndr`| AArch64| `aarch64-*`| `RNDR`\u27e841\u27e9 register  \n`wasm_js`| Web Browser, Node.js| `wasm32\u2011unknown\u2011unknown`, `wasm32v1-none`| `Crypto.getRandomValues`\u27e842\u27e9. Requires feature `wasm_js` (see below\u27e843\u27e9).  \n`efi_rng`| UEFI| `*-unknown\u2011uefi`| `EFI_RNG_PROTOCOL`\u27e844\u27e9 with `EFI_RNG_ALGORITHM_RAW` (requires `std` and Nigthly compiler)  \n`custom`| All targets| `*`| User-provided custom implementation (see custom backend\u27e845\u27e9)  \nOpt-in backends can be enabled using the `getrandom_backend` configuration flag. The flag can be set either by specifying the `rustflags` field in `.cargo/config.toml`\u27e846\u27e9:\n```\n# It's recommended to set the flag on a per-target basis:\n[target.wasm32-unknown-unknown]\nrustflags = ['--cfg', 'getrandom_backend=\"wasm_js\"']\n```\n\nOr by using the `RUSTFLAGS` environment variable:\n```\nRUSTFLAGS='--cfg getrandom_backend=\"linux_getrandom\"' cargo build\n```\n\nEnabling an opt-in backend will replace the backend used by default. Doing this for an incorrect target (e.g. using `linux_getrandom` while compiling for a Windows target) will result in a compilation error. Be extremely careful while using opt-in backends, as incorrect configuration may result in vulnerable applications or applications that always panic.\nNote that using an opt-in backend in a library (e.g. for tests or benchmarks) WILL NOT have any effect on its downstream users.\n#### \u00a7\u27e847\u27e9Raw Linux syscall support\nCurrently the `linux_raw` backend supports only targets with stabilized `asm!` macro, i.e. `arm`, `aarch64`, `loongarch64`, `riscv32`, `riscv64`, `s390x`, `x86`, and `x86_64`.\nNote that the raw syscall backend may be slower than backends based on `libc::getrandom`, e.g. it does not implement vDSO optimizations and on `x86` it uses the infamously slow `int 0x80` instruction to perform syscall.\n#### \u00a7\u27e843\u27e9WebAssembly support\nThis crate fully supports the WASI\u27e848\u27e9 and Emscripten\u27e849\u27e9 targets. However, the `wasm32-unknown-unknown` target (i.e. the target used by `wasm-pack`) is not automatically supported since, from the target name alone, we cannot deduce which JavaScript interface should be used (or if JavaScript is available at all).\nTo enable `getrandom`\u2019s functionality on `wasm32-unknown-unknown` using the Web Crypto methods described above\u27e840\u27e9 via `wasm-bindgen`\u27e850\u27e9, do _both_ of the following:\n  * Use the `wasm_js` feature flag, i.e. `getrandom = { version = \"0.3\", features = [\"wasm_js\"] }`. On its own, this only makes the backend available. (As a side effect this will make your `Cargo.lock` significantly larger if you are not already using `wasm-bindgen`\u27e850\u27e9, but otherwise enabling this feature is harmless.)\n  * Set `RUSTFLAGS='--cfg getrandom_backend=\"wasm_js\"'` (see above\u27e840\u27e9).\n\n\nThis backend supports both web browsers (main window and Web Workers) and Node.js (v19 or later) environments.\nWARNING: It is highly recommended to enable the `wasm_js` feature only for binary crates and tests, i.e. avoid unconditionally enabling it in library crates.\n#### \u00a7\u27e845\u27e9Custom backend\nIf this crate does not support your target out of the box or you have to use a non-default entropy source, then you can provide a custom implementation. You need to enable the custom backend as described in the opt-in backends\u27e840\u27e9 section.\nNext, you need to define an `extern` function with the following signature:\n```\nuse getrandom::Error;\n#[no_mangle]\nunsafe extern \"Rust\" fn __getrandom_v03_custom(\n  dest: *mut u8,\n  len: usize,\n) -> Result<(), Error> {\n  todo!()\n}\n```\n\nThis function should, ideally, be defined in the root crate of your project, e.g. in your `main.rs`. This function MUST be defined only once for your project, i.e. upstream library crates SHOULD NOT define it outside of tests and benchmarks. Improper configuration of this backend may result in linking errors.\nThe function accepts a pointer to a buffer that should be filled with random data and its length in bytes. Note that the buffer MAY be uninitialized. On success, the function should return `Ok(())` and fully fill the input buffer; otherwise, it should return an error value.\nWhile wrapping functions which work with byte slices you should fully initialize the buffer before passing it to the function:\n```\nuse getrandom::Error;\nfn my_entropy_source(buf: &mut [u8]) -> Result<(), getrandom::Error> {\n  // ...\n  Ok(())\n}\n#[no_mangle]\nunsafe extern \"Rust\" fn __getrandom_v03_custom(\n  dest: *mut u8,\n  len: usize,\n) -> Result<(), Error> {\n  let buf = unsafe {\n    // fill the buffer with zeros\n    core::ptr::write_bytes(dest, 0, len);\n    // create mutable byte slice\n    core::slice::from_raw_parts_mut(dest, len)\n  };\n  my_entropy_source(buf)\n}\n```\n\nIf you are confident that `getrandom` is not used in your project, but it gets pulled nevertheless by one of your dependencies, then you can use the following custom backend, which always returns the \u201cunsupported\u201d error:\n```\nuse getrandom::Error;\n#[no_mangle]\nunsafe extern \"Rust\" fn __getrandom_v03_custom(\n  dest: *mut u8,\n  len: usize,\n) -> Result<(), Error> {\n  Err(Error::UNSUPPORTED)\n}\n```\n\n#### \u00a7\u27e851\u27e9Platform Support\nThis crate generally supports the same operating system and platform versions that the Rust standard library does. Additional targets may be supported using the opt-in custom backend.\nThis means that as Rust drops support for old versions of operating systems (such as old Linux kernel versions, Android API levels, etc.) in stable releases, `getrandom` may create new patch releases that remove support for outdated platform versions.\n#### \u00a7\u27e852\u27e9`/dev/urandom` fallback on Linux and Android\nOn Linux targets, the `/dev/urandom` fallback is present only if either `target_env` is `musl`, or `target_arch` is one of the following: `aarch64`, `arm`, `powerpc`, `powerpc64`, `s390x`, `x86`, `x86_64`. Other supported targets require\u27e853\u27e9 kernel versions that support the `getrandom` system call, so the fallback is not needed.\nOn Android targets the fallback is present only for the following `target_arch`es: `aarch64`, `arm`, `x86`, `x86_64`. Other `target_arch`es (e.g. RISC-V) require sufficiently high API levels.\nThe fallback can be disabled by enabling the `linux_getrandom` opt-in backend. Note that doing so will bump minimum supported Linux kernel version to 3.17 and Android API level to 23 (Marshmallow).\n#### \u00a7\u27e854\u27e9Early boot\nSometimes, early in the boot process, the OS has not collected enough entropy to securely seed its RNG. This is especially common on virtual machines, where standard \u201crandom\u201d events are hard to come by.\nSome operating system interfaces always block until the RNG is securely seeded. This can take anywhere from a few seconds to more than a minute. A few (Linux, NetBSD and Solaris) offer a choice between blocking and getting an error; in these cases, we always choose to block.\nOn Linux (when the `getrandom` system call is not available), reading from `/dev/urandom` never blocks, even when the OS hasn\u2019t collected enough entropy yet. To avoid returning low-entropy bytes, we first poll `/dev/random` and only switch to `/dev/urandom` once this has succeeded.\nOn OpenBSD, this kind of entropy accounting isn\u2019t available, and on NetBSD, blocking on it is discouraged. On these platforms, nonblocking interfaces are used, even when reliable entropy may not be available. On the platforms where it is used, the reliability of entropy accounting itself isn\u2019t free from controversy. This library provides randomness sourced according to the platform\u2019s best practices, but each platform has its own limits on the grade of randomness it can promise in environments with few sources of entropy.\nOn ESP-IDF, if `esp_fill_random` is used before enabling WiFi, BT, or the voltage noise entropy source (SAR ADC), the Hardware RNG will only be seeded via RC_FAST_CLK. This can occur during early boot unless `bootloader_random_enable()` is called. For more information see the ESP-IDF RNG Docs\u27e855\u27e9 or the RNG section of the ESP32 Technical Reference Manual\u27e856\u27e9.\n### \u00a7\u27e857\u27e9Error handling\nWe always prioritize failure over returning known insecure \u201crandom\u201d bytes. Generally, on supported platforms, failure is highly unlikely, though not impossible. If an error does occur, it is likely that it will occur on every call to `getrandom`. Therefore, after the first successful call, one can be reasonably confident that no errors will occur.\n### \u00a7\u27e858\u27e9Panic handling\nWe strive to eliminate all potential panics from our backend implementations. In other words, when compiled with optimizations enabled, the generated binary code for `getrandom` functions should not contain any panic branches. Even if the platform misbehaves and returns an unexpected result, our code should correctly handle it and return an error, e.g. `Error::UNEXPECTED`\u27e859\u27e9.\n### \u00a7\u27e860\u27e9Sanitizer support\nIf your code uses `fill_uninit`\u27e861\u27e9 and you enable MemorySanitizer\u27e862\u27e9 (i.e. `-Zsanitizer=memory`), we will automatically handle unpoisoning of the destination buffer filled by `fill_uninit`.\nYou can run sanitizer tests for your crate dependent on `getrandom` like this:\n```\nRUSTFLAGS=\"-Zsanitizer=memory\" cargo test -Zbuild-std --target=x86_64-unknown-linux-gnu\n```\n\n### \u00a7\u27e863\u27e9Minimum Supported Rust Version\nThis crate requires Rust 1.63 or later.\n### \u00a7\u27e864\u27e9License\nThe `getrandom` library is distributed under either of\n  * Apache License, Version 2.0\u27e865\u27e9\n  * MIT license\u27e866\u27e9\n\n\nat your option.\n#### \u00a7\u27e867\u27e9Contribution\nUnless you explicitly state otherwise, any contribution intentionally submitted for inclusion in the work by you, as defined in the Apache-2.0 license, shall be dual licensed as above, without any additional terms or conditions.\n## Structs\u00a7\u27e868\u27e9\n\nError\u27e869\u27e9\n    A small and `no_std` compatible error type\n## Functions\u00a7\u27e870\u27e9\n\nfill\u27e871\u27e9\n    Fill `dest` with random bytes from the system\u2019s preferred random number source.\n\nfill_uninit\u27e861\u27e9\n    Fill potentially uninitialized buffer `dest` with random bytes from the system\u2019s preferred random number source and return a mutable reference to those bytes.\n\nu32\u27e872\u27e9\n    Get random `u32` from the system\u2019s preferred random number source.\n\nu64\u27e873\u27e9\n    Get random `u64` from the system\u2019s preferred random number source.\n",
              "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/getrandom/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/getrandom/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/getrandom/latest/src/getrandom/lib.rs.html#2-143: Source\n\u27e84\u27e9 https://docs.rs/getrandom/latest/getrandom/#getrandom-systems-random-number-generator: \u00a7\n\u27e85\u27e9 https://github.com/rust-random/getrandom/actions/workflows/tests.yml/badge.svg?branch=master: ![Build Status\n\u27e86\u27e9 https://img.shields.io/crates/v/getrandom: ![Crate\n\u27e87\u27e9 https://docs.rs/getrandom/badge.svg: ![Documentation\n\u27e88\u27e9 https://deps.rs/repo/github/rust-random/getrandom/status.svg: ![Dependency Status\n\u27e89\u27e9 https://img.shields.io/crates/d/getrandom: ![Downloads\n\u27e810\u27e9 https://img.shields.io/crates/l/getrandom: ![License\n\u27e811\u27e9 https://crates.io/crates/rand: `rand`\n\u27e812\u27e9 https://docs.rs/getrandom/latest/getrandom/#usage: \u00a7\n\u27e813\u27e9 https://docs.rs/getrandom/latest/getrandom/#supported-targets: \u00a7\n\u27e814\u27e9 https://manned.org/getrandom.2: `getrandom`\n\u27e815\u27e9 https://manned.org/urandom.4: `/dev/urandom`\n\u27e816\u27e9 https://learn.microsoft.com/en-us/windows/win32/seccng/processprng: `ProcessPrng`\n\u27e817\u27e9 https://learn.microsoft.com/en-us/windows/win32/api/ntsecapi/nf-ntsecapi-rtlgenrandom: `RtlGenRandom`\n\u27e818\u27e9 https://www.unix.com/man-page/mojave/2/getentropy/: `getentropy`\n\u27e819\u27e9 https://opensource.apple.com/source/CommonCrypto/CommonCrypto-60074/include/CommonRandom.h.auto.html: `CCRandomGenerateBytes`\n\u27e820\u27e9 https://www.freebsd.org/cgi/man.cgi?query=getrandom&manpath=FreeBSD+12.0-stable: `getrandom`\n\u27e821\u27e9 https://man.openbsd.org/getentropy.2: `getentropy`\n\u27e822\u27e9 https://man.netbsd.org/getrandom.2: `getrandom`\n\u27e823\u27e9 https://man.netbsd.org/sysctl.7: `kern.arandom`\n\u27e824\u27e9 https://leaf.dragonflybsd.org/cgi/web-man?command=getrandom: `getrandom`\n\u27e825\u27e9 https://docs.oracle.com/cd/E88353_01/html/E37841/getrandom-2.html: `getrandom`\n\u27e826\u27e9 https://illumos.org/man/2/getrandom: `getrandom`\n\u27e827\u27e9 https://fuchsia.dev/fuchsia-src/zircon/syscalls/cprng_draw: `cprng_draw`\n\u27e828\u27e9 https://github.com/hermit-os/kernel/blob/315f58ff5efc81d9bf0618af85a59963ff55f8b1/src/syscalls/entropy.rs#L47-L55: `sys_read_entropy`\n\u27e829\u27e9 https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-getrandom: `getrandom`\n\u27e830\u27e9 https://software.intel.com/en-us/articles/intel-digital-random-number-generator-drng-software-implementation-guide: `RDRAND`\n\u27e831\u27e9 https://github.com/emscripten-core/emscripten/pull/12240: `getentropy`\n\u27e832\u27e9 https://github.com/WebAssembly/WASI/blob/snapshot-01/phases/snapshot/docs.md#-random_getbuf-pointeru8-buf_len-size---errno: `random_get`\n\u27e833\u27e9 https://github.com/WebAssembly/WASI/blob/v0.2.1/wasip2/random/random.wit#L23-L28: `get-random-u64`\n\u27e834\u27e9 https://github.com/rust3ds/shim-3ds/commit/b01d2568836dea2a65d05d662f8e5f805c64389d: `getrandom`\n\u27e835\u27e9 https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-reference/system/random.html#functions: `esp_fill_random`\n\u27e836\u27e9 https://github.com/vitasdk/newlib/blob/2d869fe47aaf02b8e52d04e9a2b79d5b210fd016/newlib/libc/sys/vita/getentropy.c: `getentropy`\n\u27e837\u27e9 https://www.qnx.com/developers/docs/7.1/index.html#com.qnx.doc.neutrino.utilities/topic/r/random.html: `/dev/urandom`\n\u27e838\u27e9 https://www.ibm.com/docs/en/aix/7.3?topic=files-random-urandom-devices: `/dev/urandom`\n\u27e839\u27e9 https://github.com/cygwin/cygwin/blob/main/winsup/cygwin/libc/getentropy.cc: `getrandom`\n\u27e840\u27e9 https://docs.rs/getrandom/latest/getrandom/#opt-in-backends: \u00a7\n\u27e841\u27e9 https://developer.arm.com/documentation/ddi0601/2024-06/AArch64-Registers/RNDR--Random-Number: `RNDR`\n\u27e842\u27e9 https://www.w3.org/TR/WebCryptoAPI/#Crypto-method-getRandomValues: `Crypto.getRandomValues`\n\u27e843\u27e9 https://docs.rs/getrandom/latest/getrandom/#webassembly-support: see below\n\u27e844\u27e9 https://uefi.org/specs/UEFI/2.10/37_Secure_Technologies.html#efi-rng-protocol: `EFI_RNG_PROTOCOL`\n\u27e845\u27e9 https://docs.rs/getrandom/latest/getrandom/#custom-backend: custom backend\n\u27e846\u27e9 https://doc.rust-lang.org/cargo/reference/config.html: `.cargo/config.toml`\n\u27e847\u27e9 https://docs.rs/getrandom/latest/getrandom/#raw-linux-syscall-support: \u00a7\n\u27e848\u27e9 https://github.com/WebAssembly/WASI: WASI\n\u27e849\u27e9 https://emscripten.org: Emscripten\n\u27e850\u27e9 https://github.com/rustwasm/wasm-bindgen: `wasm-bindgen`\n\u27e851\u27e9 https://docs.rs/getrandom/latest/getrandom/#platform-support: \u00a7\n\u27e852\u27e9 https://docs.rs/getrandom/latest/getrandom/#devurandom-fallback-on-linux-and-android: \u00a7\n\u27e853\u27e9 https://doc.rust-lang.org/stable/rustc/platform-support.html: require\n\u27e854\u27e9 https://docs.rs/getrandom/latest/getrandom/#early-boot: \u00a7\n\u27e855\u27e9 https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-reference/system/random.html: ESP-IDF RNG Docs\n\u27e856\u27e9 https://www.espressif.com/sites/default/files/documentation/esp32_technical_reference_manual_en.pdf#rng: RNG section of the ESP32 Technical Reference Manual\n\u27e857\u27e9 https://docs.rs/getrandom/latest/getrandom/#error-handling: \u00a7\n\u27e858\u27e9 https://docs.rs/getrandom/latest/getrandom/#panic-handling: \u00a7\n\u27e859\u27e9 https://docs.rs/getrandom/latest/getrandom/struct.Error.html#associatedconstant.UNEXPECTED: associated constant getrandom::Error::UNEXPECTED - `Error::UNEXPECTED`\n\u27e860\u27e9 https://docs.rs/getrandom/latest/getrandom/#sanitizer-support: \u00a7\n\u27e861\u27e9 https://docs.rs/getrandom/latest/getrandom/fn.fill_uninit.html: fn getrandom::fill_uninit - `fill_uninit`\n\u27e862\u27e9 https://doc.rust-lang.org/beta/unstable-book/compiler-flags/sanitizer.html#memorysanitizer: MemorySanitizer\n\u27e863\u27e9 https://docs.rs/getrandom/latest/getrandom/#minimum-supported-rust-version: \u00a7\n\u27e864\u27e9 https://docs.rs/getrandom/latest/getrandom/#license: \u00a7\n\u27e865\u27e9 https://github.com/rust-random/getrandom/blob/master/LICENSE-APACHE: Apache License, Version 2.0\n\u27e866\u27e9 https://github.com/rust-random/getrandom/blob/master/LICENSE-MIT: MIT license\n\u27e867\u27e9 https://docs.rs/getrandom/latest/getrandom/#contribution: \u00a7\n\u27e868\u27e9 https://docs.rs/getrandom/latest/getrandom/#structs: \u00a7\n\u27e869\u27e9 https://docs.rs/getrandom/latest/getrandom/struct.Error.html: struct getrandom::Error - Error\n\u27e870\u27e9 https://docs.rs/getrandom/latest/getrandom/#functions: \u00a7\n\u27e871\u27e9 https://docs.rs/getrandom/latest/getrandom/fn.fill.html: fn getrandom::fill - fill\n\u27e872\u27e9 https://docs.rs/getrandom/latest/getrandom/fn.u32.html: fn getrandom::u32 - u32\n\u27e873\u27e9 https://docs.rs/getrandom/latest/getrandom/fn.u64.html: fn getrandom::u64 - u64\n",
              "fit_markdown": "",
              "fit_html": ""
            },
            "structured_data": {},
            "quality_score": 4.0,
            "extraction_method": "crawl4ai",
            "error": null,
            "metadata": {
              "doc_type": "docs",
              "content_length": 19627,
              "has_structured_data": false,
              "crawl_success": true
            },
            "timestamp": "114829.1866828"
          },
          "lib_rs": {
            "url": "https://lib.rs/crates/getrandom",
            "title": "Untitled",
            "content": {
              "raw_markdown": "###  [38 releases](https://lib.rs/crates/getrandom/versions)\n0.3.3 |  May 9, 2025   \n---|---  \n0.3.2 |  Mar 17, 2025   \n0.3.1 |  Jan 28, 2025   \n0.3.0-rc.0 |  Nov 29, 2024   \n0.1.0 |  Mar 23, 2019   \n#**1** in [Operating systems](https://lib.rs/os \"Bindings to operating system-specific APIs.\")\nDownload history 7501644/week @ 2025-03-09 8543643/week @ 2025-03-16 8989904/week @ 2025-03-23 7610306/week @ 2025-03-30 8318055/week @ 2025-04-06 7581459/week @ 2025-04-13 7448467/week @ 2025-04-20 7549602/week @ 2025-04-27 7634671/week @ 2025-05-04 8095338/week @ 2025-05-11 8352561/week @ 2025-05-18 7152378/week @ 2025-05-25 7797735/week @ 2025-06-01 8253229/week @ 2025-06-08 9167874/week @ 2025-06-15 8970272/week @ 2025-06-22\n**34,709,894** downloads per month Used in [**49,050** crates (1,394 directly)](https://lib.rs/crates/getrandom/rev)\n**MIT/Apache**\n115KB  1.5K  SLoC\n# getrandom: system's random number generator\n[![Build Status](https://img.gs/czjpqfbdkz/full/https://github.com/rust-random/getrandom/actions/workflows/tests.yml/badge.svg?branch=master)](https://github.com/rust-random/getrandom/actions?query=branch:master) [![Crate](https://img.shields.io/crates/v/getrandom)](https://crates.io/crates/getrandom) [![Documentation](https://img.gs/czjpqfbdkz/full/https://docs.rs/getrandom/badge.svg)](https://docs.rs/getrandom) [![Dependency Status](https://img.gs/czjpqfbdkz/full/https://deps.rs/repo/github/rust-random/getrandom/status.svg)](https://deps.rs/repo/github/rust-random/getrandom) [![Downloads](https://img.shields.io/crates/d/getrandom)](https://crates.io/crates/getrandom) [![License](https://img.shields.io/crates/l/getrandom)](https://github.com/rust-random/getrandom/blob/master/LICENSE-MIT)\n``getrandom`` is a Rust library for retrieving random data from (operating) system sources.\nIt is assumed that the system always provides high-quality, cryptographically secure random data, ideally backed by hardware entropy sources. This crate derives its name from the Linux ``getrandom`` syscall but is cross-platform, roughly supporting the same set of platforms as Rust's ``std`` library.\nThis is a low-level API. Most users should prefer using a higher-level random-number library like [``rand``](https://lib.rs/crates/rand).\n## Usage\nAdd the ``getrandom`` dependency to your ``Cargo.toml`` file:\n```\n```[``dependencies``]`\n`getrandom ``=` ``\"`0.3`\"``\n``\n```\n\nThen invoke the ``fill`` function on a byte buffer to fill it with random data:\n```\n```fn` `get_random_u128`````(````)```` ``->` ``Result``<``u128`, `getrandom`::``Error`>``` ````{`\n  `let` `mut` buf `=` `[``0``u8``;` `16``]``;`\n  `getrandom`::``fill`(``&``mut` buf`)``?``;`\n  `Ok``(``u128```::``from_ne_bytes`(`buf`)``)`\n```}```\n`\n```\n\n## Supported targets\nTarget | Target Triple | Implementation  \n---|---|---  \nLinux, Android | ```*`\u2011linux\u2011`*``` | [``getrandom``](https://manned.org/getrandom.2) system call if available, otherwise [``/dev/urandom``](https://manned.org/urandom.4) after successfully polling ``/dev/random``  \nWindows 10+ | ```*`\u2011windows\u2011`*``` | [``ProcessPrng``](https://learn.microsoft.com/en-us/windows/win32/seccng/processprng) on Rust 1.78+, [``RtlGenRandom``](https://learn.microsoft.com/en-us/windows/win32/api/ntsecapi/nf-ntsecapi-rtlgenrandom) otherwise  \nWindows 7, 8 | ```*``-`win7\u2011windows\u2011`*``` | [``RtlGenRandom``](https://learn.microsoft.com/en-us/windows/win32/api/ntsecapi/nf-ntsecapi-rtlgenrandom)  \nmacOS | ```*`\u2011apple\u2011darwin`` | [``getentropy``](https://www.unix.com/man-page/mojave/2/getentropy/)  \niOS, tvOS, watchOS | ```*`\u2011apple\u2011``{`ios`,`tvos`,`watchos```}```` | [``CCRandomGenerateBytes``](https://opensource.apple.com/source/CommonCrypto/CommonCrypto-60074/include/CommonRandom.h.auto.html)  \nFreeBSD | ```*`\u2011freebsd`` | [``getrandom``](https://www.freebsd.org/cgi/man.cgi?query=getrandom&manpath=FreeBSD+12.0-stable)  \nOpenBSD | ```*`\u2011openbsd`` | [``getentropy``](https://man.openbsd.org/getentropy.2)  \nNetBSD | ```*`\u2011netbsd`` | [``getrandom``](https://man.netbsd.org/getrandom.2) if available, otherwise [``kern`.`arandom``](https://man.netbsd.org/sysctl.7)  \nDragonfly BSD | ```*`\u2011dragonfly`` | [``getrandom``](https://leaf.dragonflybsd.org/cgi/web-man?command=getrandom)  \nSolaris | ```*`\u2011solaris`` | [``getrandom``](https://docs.oracle.com/cd/E88353_01/html/E37841/getrandom-2.html) with ``GRND_RANDOM``  \nillumos | ```*`\u2011illumos`` | [``getrandom``](https://illumos.org/man/2/getrandom)  \nFuchsia OS | ```*`\u2011fuchsia`` | [``cprng_draw``](https://fuchsia.dev/fuchsia-src/zircon/syscalls/cprng_draw)  \nRedox | ```*`\u2011redox`` | ``/dev/urandom``  \nHaiku | ```*`\u2011haiku`` | ``/dev/urandom`` (identical to ``/dev/random``)  \nHermit | ```*``-`hermit`` | [``sys_read_entropy``](https://github.com/hermit-os/kernel/blob/315f58ff5efc81d9bf0618af85a59963ff55f8b1/src/syscalls/entropy.rs#L47-L55)  \nHurd | ```*``-`hurd`-``*``` | [``getrandom``](https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-getrandom)  \nSGX | ``x86_64\u2011`*`\u2011sgx`` | [``RDRAND``](https://software.intel.com/en-us/articles/intel-digital-random-number-generator-drng-software-implementation-guide)  \nVxWorks | ```*`\u2011wrs\u2011vxworks\u2011`*``` | ``randABytes`` after checking entropy pool initialization with ``randSecure``  \nEmscripten | ```*`\u2011emscripten`` | [``getentropy``](https://github.com/emscripten-core/emscripten/pull/12240)  \nWASI 0.1 | ``wasm32\u2011wasip1`` | [``random_get``](https://github.com/WebAssembly/WASI/blob/snapshot-01/phases/snapshot/docs.md#-random_getbuf-pointeru8-buf_len-size---errno)  \nWASI 0.2 | ``wasm32\u2011wasip2`` | [``get-random-u64``](https://github.com/WebAssembly/WASI/blob/v0.2.1/wasip2/random/random.wit#L23-L28)  \nSOLID | ```*``-`kmc`-`solid_`*``` | ``SOLID_RNG_SampleRandomBytes``  \nNintendo 3DS | ```*``-`nintendo`-`3ds`` | [``getrandom``](https://github.com/rust3ds/shim-3ds/commit/b01d2568836dea2a65d05d662f8e5f805c64389d)  \nESP-IDF | ```*`\u2011espidf`` | [``esp_fill_random``](https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-reference/system/random.html#functions) WARNING: see \"Early Boot\" section below  \nPS Vita | ```*``-`vita`-``*``` | [``getentropy``](https://github.com/vitasdk/newlib/blob/2d869fe47aaf02b8e52d04e9a2b79d5b210fd016/newlib/libc/sys/vita/getentropy.c)  \nQNX Neutrino | ```*`\u2011nto`-`qnx`*``` | [``/dev/urandom``](https://www.qnx.com/developers/docs/7.1/index.html#com.qnx.doc.neutrino.utilities/topic/r/random.html) (identical to ``/dev/random``)  \nAIX | ```*``-`ibm`-`aix`` | [``/dev/urandom``](https://www.ibm.com/docs/en/aix/7.3?topic=files-random-urandom-devices)  \nCygwin | ```*``-`cygwin`` | [``getrandom``](https://github.com/cygwin/cygwin/blob/main/winsup/cygwin/libc/getentropy.cc) (based on [``RtlGenRandom``](https://learn.microsoft.com/en-us/windows/win32/api/ntsecapi/nf-ntsecapi-rtlgenrandom))  \nPull Requests that add support for new targets to ``getrandom`` are always welcome.\n### Opt-in backends\n``getrandom`` also provides optional (opt-in) backends, which allow users to customize the source of randomness based on their specific needs:\nBackend name | Target | Target Triple | Implementation  \n---|---|---|---  \n``linux_getrandom`` | Linux, Android | ```*`\u2011linux\u2011`*``` | [``getrandom``](https://manned.org/getrandom.2) system call (without ``/dev/urandom`` fallback). Bumps minimum supported Linux kernel version to 3.17 and Android API level to 23 (Marshmallow).  \n``linux_raw`` | Linux, Android | ```*`\u2011linux\u2011`*``` | Same as ``linux_getrandom``, but uses raw ``asm!``-based syscalls instead of ``libc``.  \n``rdrand`` | x86, x86-64 | ``x86_64`-``*```, ``i686`-``*``` | [``RDRAND``](https://software.intel.com/en-us/articles/intel-digital-random-number-generator-drng-software-implementation-guide) instruction  \n``rndr`` | AArch64 | ``aarch64`-``*``` | [``RNDR``](https://developer.arm.com/documentation/ddi0601/2024-06/AArch64-Registers/RNDR--Random-Number) register  \n``wasm_js`` | Web Browser, Node.js | ``wasm32\u2011unknown\u2011unknown``, ``wasm32v1-none`` | [``Crypto`.`getRandomValues``](https://www.w3.org/TR/WebCryptoAPI/#Crypto-method-getRandomValues). Requires feature ``wasm_js`` ([see below](https://lib.rs/crates/getrandom#readme-webassembly-support)).  \n``efi_rng`` | UEFI | ```*``-`unknown\u2011uefi`` | [``EFI_RNG_PROTOCOL``](https://uefi.org/specs/UEFI/2.10/37_Secure_Technologies.html#efi-rng-protocol) with ``EFI_RNG_ALGORITHM_RAW`` (requires ``std`` and Nigthly compiler)  \n``custom`` | All targets | ```*``` | User-provided custom implementation (see [custom backend](https://lib.rs/crates/getrandom#readme-custom-backend))  \nOpt-in backends can be enabled using the ``getrandom_backend`` configuration flag. The flag can be set either by specifying the ``rustflags`` field in [``.cargo/config.toml``](https://doc.rust-lang.org/cargo/reference/config.html):\n```\n```# It's recommended to set the flag on a per-target basis:``\n``[``target.wasm32-unknown-unknown``]`\n`rustflags ``=` ``[```'`--cfg`'``, ``'`getrandom_backend=\"wasm_js\"`'```]``\n``\n```\n\nOr by using the ``RUSTFLAGS`` environment variable:\n```\n``RUSTFLAGS``=````'`--cfg getrandom_backend=\"linux_getrandom\"`'``` ``cargo``` build`\n`\n```\n\nEnabling an opt-in backend will replace the backend used by default. Doing this for an incorrect target (e.g. using ``linux_getrandom`` while compiling for a Windows target) will result in a compilation error. Be extremely careful while using opt-in backends, as incorrect configuration may result in vulnerable applications or applications that always panic.\nNote that using an opt-in backend in a library (e.g. for tests or benchmarks) WILL NOT have any effect on its downstream users.\n### Raw Linux syscall support\nCurrently the ``linux_raw`` backend supports only targets with stabilized ``asm!`` macro, i.e. ``arm``, ``aarch64``, ``loongarch64``, ``riscv32``, ``riscv64``, ``s390x``, ``x86``, and ``x86_64``.\nNote that the raw syscall backend may be slower than backends based on ```libc`::``getrandom``, e.g. it does not implement vDSO optimizations and on ``x86`` it uses the infamously slow ``int `0x80``` instruction to perform syscall.\n### WebAssembly support\nThis crate fully supports the [WASI](https://github.com/WebAssembly/WASI) and [Emscripten](https://emscripten.org) targets. However, the ``wasm32-unknown-unknown`` target (i.e. the target used by ``wasm-pack``) is not automatically supported since, from the target name alone, we cannot deduce which JavaScript interface should be used (or if JavaScript is available at all).\nTo enable ``getrandom``'s functionality on ``wasm32-unknown-unknown`` using the Web Crypto methods [described above](https://lib.rs/crates/getrandom#readme-opt-in-backends) via [``wasm-bindgen``](https://github.com/rustwasm/wasm-bindgen), do _both_ of the following:\n  * Use the ``wasm_js`` feature flag, i.e. ``getrandom `=` ``{` version `=` ``\"`0.3`\"```,` features `=` `[```\"`wasm_js`\"```]` ```}````. On its own, this only makes the backend available. (As a side effect this will make your ``Cargo`.`lock`` significantly larger if you are not already using [``wasm-bindgen``](https://github.com/rustwasm/wasm-bindgen), but otherwise enabling this feature is harmless.)\n  * Set ```RUSTFLAGS``=````'`--cfg getrandom_backend=\"wasm_js\"`'````` ([see above](https://lib.rs/crates/getrandom#readme-opt-in-backends)).\n\n\nThis backend supports both web browsers (main window and Web Workers) and Node.js (v19 or later) environments.\nWARNING: It is highly recommended to enable the ``wasm_js`` feature only for binary crates and tests, i.e. avoid unconditionally enabling it in library crates.\n### Custom backend\nIf this crate does not support your target out of the box or you have to use a non-default entropy source, then you can provide a custom implementation. You need to enable the custom backend as described in the [opt-in backends](https://lib.rs/crates/getrandom#readme-opt-in-backends) section.\nNext, you need to define an ```extern``` function with the following signature:\n```\n``use` `getrandom`::``Error`;`\n``#``[``no_mangle``]``\n`unsafe` `extern` ``\"`Rust`\"`` ``fn` `__getrandom_v03_custom`````(`\n  `dest``:` `*mut` `u8`,\n  `len``:` `usize`,\n```)```` ``->` ``Result``<``(``)`, Error`>``` ````{`\n  `todo!``(``)`\n```}```\n`\n```\n\nThis function should, ideally, be defined in the root crate of your project, e.g. in your ``main.rs``. This function MUST be defined only once for your project, i.e. upstream library crates SHOULD NOT define it outside of tests and benchmarks. Improper configuration of this backend may result in linking errors.\nThe function accepts a pointer to a buffer that should be filled with random data and its length in bytes. Note that the buffer MAY be uninitialized. On success, the function should return ```Ok``(``(``)``)``` and fully fill the input buffer; otherwise, it should return an error value.\nWhile wrapping functions which work with byte slices you should fully initialize the buffer before passing it to the function:\n```\n``use` `getrandom`::``Error`;`\n``fn` `my_entropy_source`````(``buf``:` `&``mut` [`u8`]```)```` ``->` ``Result``<``(``)`, `getrandom`::``Error`>``` ````{`\n  ``//` ...`\n  `Ok``(``(``)``)`\n```}```\n``#``[``no_mangle``]``\n`unsafe` `extern` ``\"`Rust`\"`` ``fn` `__getrandom_v03_custom`````(`\n  `dest``:` `*mut` `u8`,\n  `len``:` `usize`,\n```)```` ``->` ``Result``<``(``)`, Error`>``` ````{`\n  `let` buf `=` `unsafe` `{`\n    ``//` fill the buffer with zeros`\n    `core`::```ptr`::``write_bytes`(`dest`,` `0``,` len`)``;`\n    ``//` create mutable byte slice`\n    `core`::```slice`::``from_raw_parts_mut`(`dest`,` len`)`\n  `}``;`\n  `my_entropy_source``(`buf`)`\n```}```\n`\n```\n\nIf you are confident that ``getrandom`` is not used in your project, but it gets pulled nevertheless by one of your dependencies, then you can use the following custom backend, which always returns the \"unsupported\" error:\n```\n``use` `getrandom`::``Error`;`\n``#``[``no_mangle``]``\n`unsafe` `extern` ``\"`Rust`\"`` ``fn` `__getrandom_v03_custom`````(`\n  `dest``:` `*mut` `u8`,\n  `len``:` `usize`,\n```)```` ``->` ``Result``<``(``)`, Error`>``` ````{`\n  `Err``(``Error`::```UNSUPPORTED``)`\n```}```\n`\n```\n\n### Platform Support\nThis crate generally supports the same operating system and platform versions that the Rust standard library does. Additional targets may be supported using the opt-in custom backend.\nThis means that as Rust drops support for old versions of operating systems (such as old Linux kernel versions, Android API levels, etc.) in stable releases, ``getrandom`` may create new patch releases that remove support for outdated platform versions.\n### ``/dev/urandom`` fallback on Linux and Android\nOn Linux targets, the ``/dev/urandom`` fallback is present only if either ``target_env`` is ``musl``, or ``target_arch`` is one of the following: ``aarch64``, ``arm``, ``powerpc``, ``powerpc64``, ``s390x``, ``x86``, ``x86_64``. Other supported targets [require](https://doc.rust-lang.org/stable/rustc/platform-support.html) kernel versions that support the ``getrandom`` system call, so the fallback is not needed.\nOn Android targets the fallback is present only for the following ``target_arch``es: ``aarch64``, ``arm``, ``x86``, ``x86_64``. Other ``target_arch``es (e.g. RISC-V) require sufficiently high API levels.\nThe fallback can be disabled by enabling the ``linux_getrandom`` opt-in backend. Note that doing so will bump minimum supported Linux kernel version to 3.17 and Android API level to 23 (Marshmallow).\n### Early boot\nSometimes, early in the boot process, the OS has not collected enough entropy to securely seed its RNG. This is especially common on virtual machines, where standard \"random\" events are hard to come by.\nSome operating system interfaces always block until the RNG is securely seeded. This can take anywhere from a few seconds to more than a minute. A few (Linux, NetBSD and Solaris) offer a choice between blocking and getting an error; in these cases, we always choose to block.\nOn Linux (when the ``getrandom`` system call is not available), reading from ``/dev/urandom`` never blocks, even when the OS hasn't collected enough entropy yet. To avoid returning low-entropy bytes, we first poll ``/dev/random`` and only switch to ``/dev/urandom`` once this has succeeded.\nOn OpenBSD, this kind of entropy accounting isn't available, and on NetBSD, blocking on it is discouraged. On these platforms, nonblocking interfaces are used, even when reliable entropy may not be available. On the platforms where it is used, the reliability of entropy accounting itself isn't free from controversy. This library provides randomness sourced according to the platform's best practices, but each platform has its own limits on the grade of randomness it can promise in environments with few sources of entropy.\nOn ESP-IDF, if ``esp_fill_random`` is used before enabling WiFi, BT, or the voltage noise entropy source (SAR ADC), the Hardware RNG will only be seeded via RC_FAST_CLK. This can occur during early boot unless ```bootloader_random_enable``(``)``` is called. For more information see the [ESP-IDF RNG Docs](https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-reference/system/random.html) or the [RNG section of the ESP32 Technical Reference Manual](https://www.espressif.com/sites/default/files/documentation/esp32_technical_reference_manual_en.pdf#rng).\n## Error handling\nWe always prioritize failure over returning known insecure \"random\" bytes. Generally, on supported platforms, failure is highly unlikely, though not impossible. If an error does occur, it is likely that it will occur on every call to ``getrandom``. Therefore, after the first successful call, one can be reasonably confident that no errors will occur.\n## Panic handling\nWe strive to eliminate all potential panics from our backend implementations. In other words, when compiled with optimizations enabled, the generated binary code for ``getrandom`` functions should not contain any panic branches. Even if the platform misbehaves and returns an unexpected result, our code should correctly handle it and return an error, e.g. [```Error`::```UNEXPECTED```](https://docs.rs/getrandom/latest/getrandom/struct.Error.html#associatedconstant.UNEXPECTED).\n## Sanitizer support\nIf your code uses [``fill_uninit``](https://docs.rs/getrandom/latest/getrandom/fn.fill_uninit.html) and you enable [MemorySanitizer](https://doc.rust-lang.org/beta/unstable-book/compiler-flags/sanitizer.html#memorysanitizer) (i.e. ```-`Zsanitizer`=`memory``), we will automatically handle unpoisoning of the destination buffer filled by ``fill_uninit``.\nYou can run sanitizer tests for your crate dependent on ``getrandom`` like this:\n```\n``RUSTFLAGS``=````\"`-Zsanitizer=memory`\"``` ``cargo``` test`` -`Zbuild-std``` --`target``=`x86_64-unknown-linux-gnu`\n`\n```\n\n## Minimum Supported Rust Version\nThis crate requires Rust 1.63 or later.\n## License\nThe ``getrandom`` library is distributed under either of\n  * [Apache License, Version 2.0](https://github.com/rust-random/getrandom/blob/master/LICENSE-APACHE)\n  * [MIT license](https://github.com/rust-random/getrandom/blob/master/LICENSE-MIT)\n\n\nat your option.\n### Contribution\nUnless you explicitly state otherwise, any contribution intentionally submitted for inclusion in the work by you, as defined in the Apache-2.0 license, shall be dual licensed as above, without any additional terms or conditions.\n#### Dependencies\n~0\u20130.8MB  ~16K SLoC\n  * [cfg-if](https://lib.rs/crates/cfg-if \"1\")\n  * [rustc-dep-of-std?](https://lib.rs/crates/getrandom/features#feature-rustc-dep-of-std \"optional feature\") [compiler_builtins](https://lib.rs/crates/compiler_builtins \"new\") 0.1\n  * [rustc-dep-of-std?](https://lib.rs/crates/getrandom/features#feature-rustc-dep-of-std \"optional feature\") [rustc-std-workspace-core](https://lib.rs/crates/rustc-std-workspace-core \"renamed core, 1.0\")\n  * [wasm_js?](https://lib.rs/crates/getrandom/features#feature-wasm_js \"optional feature\") [js-sys](https://lib.rs/crates/js-sys \"0.3.77\") wasm32 unknown none atomics\n  * [wasm_js?](https://lib.rs/crates/getrandom/features#feature-wasm_js \"optional feature\") [wasm-bindgen](https://lib.rs/crates/wasm-bindgen \"0.2.98\") wasm32 unknown none\n  * [wasi](https://lib.rs/crates/wasi \"new\") 0.14 wasm32 wasi p2\n  * [libc](https://lib.rs/crates/libc \"0.2.154\") cfg(all(any(target_o\u2026 dragonfly freebsd hurd illumos cygwin horizon arm haiku redox nto aix ios visionos watchos tvos mac openbsd vita emscripten netbsd solaris vxworks\n  * [r-efi](https://lib.rs/crates/r-efi \"5.1\") uefi efi_rng\n\n\n  * build `build.rs`\n  * dev  [wasm-bindgen-test](https://lib.rs/crates/wasm-bindgen-test \"0.3\") wasm32 unknown none\n\n\n#### [Other feature](https://lib.rs/crates/getrandom/features)\n  * [std](https://lib.rs/crates/getrandom/features#feature-std)\n\n\n  *[SLoC]: approx. additional lines of code\n",
              "markdown_with_citations": "###  38 releases\u27e81\u27e9\n0.3.3 |  May 9, 2025   \n---|---  \n0.3.2 |  Mar 17, 2025   \n0.3.1 |  Jan 28, 2025   \n0.3.0-rc.0 |  Nov 29, 2024   \n0.1.0 |  Mar 23, 2019   \n#**1** in Operating systems\u27e82\u27e9\nDownload history 7501644/week @ 2025-03-09 8543643/week @ 2025-03-16 8989904/week @ 2025-03-23 7610306/week @ 2025-03-30 8318055/week @ 2025-04-06 7581459/week @ 2025-04-13 7448467/week @ 2025-04-20 7549602/week @ 2025-04-27 7634671/week @ 2025-05-04 8095338/week @ 2025-05-11 8352561/week @ 2025-05-18 7152378/week @ 2025-05-25 7797735/week @ 2025-06-01 8253229/week @ 2025-06-08 9167874/week @ 2025-06-15 8970272/week @ 2025-06-22\n**34,709,894** downloads per month Used in **49,050** crates (1,394 directly)\u27e83\u27e9\n**MIT/Apache**\n115KB  1.5K  SLoC\n# getrandom: system's random number generator\n![Build Status\u27e84\u27e9](https://github.com/rust-random/getrandom/actions?query=branch:master) ![Crate\u27e85\u27e9](https://crates.io/crates/getrandom) ![Documentation\u27e86\u27e9](https://docs.rs/getrandom) ![Dependency Status\u27e87\u27e9](https://deps.rs/repo/github/rust-random/getrandom) ![Downloads\u27e88\u27e9](https://crates.io/crates/getrandom) ![License\u27e89\u27e9](https://github.com/rust-random/getrandom/blob/master/LICENSE-MIT)\n``getrandom`` is a Rust library for retrieving random data from (operating) system sources.\nIt is assumed that the system always provides high-quality, cryptographically secure random data, ideally backed by hardware entropy sources. This crate derives its name from the Linux ``getrandom`` syscall but is cross-platform, roughly supporting the same set of platforms as Rust's ``std`` library.\nThis is a low-level API. Most users should prefer using a higher-level random-number library like ``rand``\u27e810\u27e9.\n## Usage\nAdd the ``getrandom`` dependency to your ``Cargo.toml`` file:\n```\n```[``dependencies``]`\n`getrandom ``=` ``\"`0.3`\"``\n``\n```\n\nThen invoke the ``fill`` function on a byte buffer to fill it with random data:\n```\n```fn` `get_random_u128`````(````)```` ``->` ``Result``<``u128`, `getrandom`::``Error`>``` ````{`\n  `let` `mut` buf `=` `[``0``u8``;` `16``]``;`\n  `getrandom`::``fill`(``&``mut` buf`)``?``;`\n  `Ok``(``u128```::``from_ne_bytes`(`buf`)``)`\n```}```\n`\n```\n\n## Supported targets\nTarget | Target Triple | Implementation  \n---|---|---  \nLinux, Android | ```*`\u2011linux\u2011`*``` | ``getrandom``\u27e811\u27e9 system call if available, otherwise ``/dev/urandom``\u27e812\u27e9 after successfully polling ``/dev/random``  \nWindows 10+ | ```*`\u2011windows\u2011`*``` | ``ProcessPrng``\u27e813\u27e9 on Rust 1.78+, ``RtlGenRandom``\u27e814\u27e9 otherwise  \nWindows 7, 8 | ```*``-`win7\u2011windows\u2011`*``` | ``RtlGenRandom``\u27e814\u27e9  \nmacOS | ```*`\u2011apple\u2011darwin`` | ``getentropy``\u27e815\u27e9  \niOS, tvOS, watchOS | ```*`\u2011apple\u2011``{`ios`,`tvos`,`watchos```}```` | ``CCRandomGenerateBytes``\u27e816\u27e9  \nFreeBSD | ```*`\u2011freebsd`` | ``getrandom``\u27e817\u27e9  \nOpenBSD | ```*`\u2011openbsd`` | ``getentropy``\u27e818\u27e9  \nNetBSD | ```*`\u2011netbsd`` | ``getrandom``\u27e819\u27e9 if available, otherwise ``kern`.`arandom``\u27e820\u27e9  \nDragonfly BSD | ```*`\u2011dragonfly`` | ``getrandom``\u27e821\u27e9  \nSolaris | ```*`\u2011solaris`` | ``getrandom``\u27e822\u27e9 with ``GRND_RANDOM``  \nillumos | ```*`\u2011illumos`` | ``getrandom``\u27e823\u27e9  \nFuchsia OS | ```*`\u2011fuchsia`` | ``cprng_draw``\u27e824\u27e9  \nRedox | ```*`\u2011redox`` | ``/dev/urandom``  \nHaiku | ```*`\u2011haiku`` | ``/dev/urandom`` (identical to ``/dev/random``)  \nHermit | ```*``-`hermit`` | ``sys_read_entropy``\u27e825\u27e9  \nHurd | ```*``-`hurd`-``*``` | ``getrandom``\u27e826\u27e9  \nSGX | ``x86_64\u2011`*`\u2011sgx`` | ``RDRAND``\u27e827\u27e9  \nVxWorks | ```*`\u2011wrs\u2011vxworks\u2011`*``` | ``randABytes`` after checking entropy pool initialization with ``randSecure``  \nEmscripten | ```*`\u2011emscripten`` | ``getentropy``\u27e828\u27e9  \nWASI 0.1 | ``wasm32\u2011wasip1`` | ``random_get``\u27e829\u27e9  \nWASI 0.2 | ``wasm32\u2011wasip2`` | ``get-random-u64``\u27e830\u27e9  \nSOLID | ```*``-`kmc`-`solid_`*``` | ``SOLID_RNG_SampleRandomBytes``  \nNintendo 3DS | ```*``-`nintendo`-`3ds`` | ``getrandom``\u27e831\u27e9  \nESP-IDF | ```*`\u2011espidf`` | ``esp_fill_random``\u27e832\u27e9 WARNING: see \"Early Boot\" section below  \nPS Vita | ```*``-`vita`-``*``` | ``getentropy``\u27e833\u27e9  \nQNX Neutrino | ```*`\u2011nto`-`qnx`*``` | ``/dev/urandom``\u27e834\u27e9 (identical to ``/dev/random``)  \nAIX | ```*``-`ibm`-`aix`` | ``/dev/urandom``\u27e835\u27e9  \nCygwin | ```*``-`cygwin`` | ``getrandom``\u27e836\u27e9 (based on ``RtlGenRandom``\u27e814\u27e9)  \nPull Requests that add support for new targets to ``getrandom`` are always welcome.\n### Opt-in backends\n``getrandom`` also provides optional (opt-in) backends, which allow users to customize the source of randomness based on their specific needs:\nBackend name | Target | Target Triple | Implementation  \n---|---|---|---  \n``linux_getrandom`` | Linux, Android | ```*`\u2011linux\u2011`*``` | ``getrandom``\u27e811\u27e9 system call (without ``/dev/urandom`` fallback). Bumps minimum supported Linux kernel version to 3.17 and Android API level to 23 (Marshmallow).  \n``linux_raw`` | Linux, Android | ```*`\u2011linux\u2011`*``` | Same as ``linux_getrandom``, but uses raw ``asm!``-based syscalls instead of ``libc``.  \n``rdrand`` | x86, x86-64 | ``x86_64`-``*```, ``i686`-``*``` | ``RDRAND``\u27e827\u27e9 instruction  \n``rndr`` | AArch64 | ``aarch64`-``*``` | ``RNDR``\u27e837\u27e9 register  \n``wasm_js`` | Web Browser, Node.js | ``wasm32\u2011unknown\u2011unknown``, ``wasm32v1-none`` | ``Crypto`.`getRandomValues``\u27e838\u27e9. Requires feature ``wasm_js`` (see below\u27e839\u27e9).  \n``efi_rng`` | UEFI | ```*``-`unknown\u2011uefi`` | ``EFI_RNG_PROTOCOL``\u27e840\u27e9 with ``EFI_RNG_ALGORITHM_RAW`` (requires ``std`` and Nigthly compiler)  \n``custom`` | All targets | ```*``` | User-provided custom implementation (see custom backend\u27e841\u27e9)  \nOpt-in backends can be enabled using the ``getrandom_backend`` configuration flag. The flag can be set either by specifying the ``rustflags`` field in ``.cargo/config.toml``\u27e842\u27e9:\n```\n```# It's recommended to set the flag on a per-target basis:``\n``[``target.wasm32-unknown-unknown``]`\n`rustflags ``=` ``[```'`--cfg`'``, ``'`getrandom_backend=\"wasm_js\"`'```]``\n``\n```\n\nOr by using the ``RUSTFLAGS`` environment variable:\n```\n``RUSTFLAGS``=````'`--cfg getrandom_backend=\"linux_getrandom\"`'``` ``cargo``` build`\n`\n```\n\nEnabling an opt-in backend will replace the backend used by default. Doing this for an incorrect target (e.g. using ``linux_getrandom`` while compiling for a Windows target) will result in a compilation error. Be extremely careful while using opt-in backends, as incorrect configuration may result in vulnerable applications or applications that always panic.\nNote that using an opt-in backend in a library (e.g. for tests or benchmarks) WILL NOT have any effect on its downstream users.\n### Raw Linux syscall support\nCurrently the ``linux_raw`` backend supports only targets with stabilized ``asm!`` macro, i.e. ``arm``, ``aarch64``, ``loongarch64``, ``riscv32``, ``riscv64``, ``s390x``, ``x86``, and ``x86_64``.\nNote that the raw syscall backend may be slower than backends based on ```libc`::``getrandom``, e.g. it does not implement vDSO optimizations and on ``x86`` it uses the infamously slow ``int `0x80``` instruction to perform syscall.\n### WebAssembly support\nThis crate fully supports the WASI\u27e843\u27e9 and Emscripten\u27e844\u27e9 targets. However, the ``wasm32-unknown-unknown`` target (i.e. the target used by ``wasm-pack``) is not automatically supported since, from the target name alone, we cannot deduce which JavaScript interface should be used (or if JavaScript is available at all).\nTo enable ``getrandom``'s functionality on ``wasm32-unknown-unknown`` using the Web Crypto methods described above\u27e845\u27e9 via ``wasm-bindgen``\u27e846\u27e9, do _both_ of the following:\n  * Use the ``wasm_js`` feature flag, i.e. ``getrandom `=` ``{` version `=` ``\"`0.3`\"```,` features `=` `[```\"`wasm_js`\"```]` ```}````. On its own, this only makes the backend available. (As a side effect this will make your ``Cargo`.`lock`` significantly larger if you are not already using ``wasm-bindgen``\u27e846\u27e9, but otherwise enabling this feature is harmless.)\n  * Set ```RUSTFLAGS``=````'`--cfg getrandom_backend=\"wasm_js\"`'````` (see above\u27e845\u27e9).\n\n\nThis backend supports both web browsers (main window and Web Workers) and Node.js (v19 or later) environments.\nWARNING: It is highly recommended to enable the ``wasm_js`` feature only for binary crates and tests, i.e. avoid unconditionally enabling it in library crates.\n### Custom backend\nIf this crate does not support your target out of the box or you have to use a non-default entropy source, then you can provide a custom implementation. You need to enable the custom backend as described in the opt-in backends\u27e845\u27e9 section.\nNext, you need to define an ```extern``` function with the following signature:\n```\n``use` `getrandom`::``Error`;`\n``#``[``no_mangle``]``\n`unsafe` `extern` ``\"`Rust`\"`` ``fn` `__getrandom_v03_custom`````(`\n  `dest``:` `*mut` `u8`,\n  `len``:` `usize`,\n```)```` ``->` ``Result``<``(``)`, Error`>``` ````{`\n  `todo!``(``)`\n```}```\n`\n```\n\nThis function should, ideally, be defined in the root crate of your project, e.g. in your ``main.rs``. This function MUST be defined only once for your project, i.e. upstream library crates SHOULD NOT define it outside of tests and benchmarks. Improper configuration of this backend may result in linking errors.\nThe function accepts a pointer to a buffer that should be filled with random data and its length in bytes. Note that the buffer MAY be uninitialized. On success, the function should return ```Ok``(``(``)``)``` and fully fill the input buffer; otherwise, it should return an error value.\nWhile wrapping functions which work with byte slices you should fully initialize the buffer before passing it to the function:\n```\n``use` `getrandom`::``Error`;`\n``fn` `my_entropy_source`````(``buf``:` `&``mut` [`u8`]```)```` ``->` ``Result``<``(``)`, `getrandom`::``Error`>``` ````{`\n  ``//` ...`\n  `Ok``(``(``)``)`\n```}```\n``#``[``no_mangle``]``\n`unsafe` `extern` ``\"`Rust`\"`` ``fn` `__getrandom_v03_custom`````(`\n  `dest``:` `*mut` `u8`,\n  `len``:` `usize`,\n```)```` ``->` ``Result``<``(``)`, Error`>``` ````{`\n  `let` buf `=` `unsafe` `{`\n    ``//` fill the buffer with zeros`\n    `core`::```ptr`::``write_bytes`(`dest`,` `0``,` len`)``;`\n    ``//` create mutable byte slice`\n    `core`::```slice`::``from_raw_parts_mut`(`dest`,` len`)`\n  `}``;`\n  `my_entropy_source``(`buf`)`\n```}```\n`\n```\n\nIf you are confident that ``getrandom`` is not used in your project, but it gets pulled nevertheless by one of your dependencies, then you can use the following custom backend, which always returns the \"unsupported\" error:\n```\n``use` `getrandom`::``Error`;`\n``#``[``no_mangle``]``\n`unsafe` `extern` ``\"`Rust`\"`` ``fn` `__getrandom_v03_custom`````(`\n  `dest``:` `*mut` `u8`,\n  `len``:` `usize`,\n```)```` ``->` ``Result``<``(``)`, Error`>``` ````{`\n  `Err``(``Error`::```UNSUPPORTED``)`\n```}```\n`\n```\n\n### Platform Support\nThis crate generally supports the same operating system and platform versions that the Rust standard library does. Additional targets may be supported using the opt-in custom backend.\nThis means that as Rust drops support for old versions of operating systems (such as old Linux kernel versions, Android API levels, etc.) in stable releases, ``getrandom`` may create new patch releases that remove support for outdated platform versions.\n### ``/dev/urandom`` fallback on Linux and Android\nOn Linux targets, the ``/dev/urandom`` fallback is present only if either ``target_env`` is ``musl``, or ``target_arch`` is one of the following: ``aarch64``, ``arm``, ``powerpc``, ``powerpc64``, ``s390x``, ``x86``, ``x86_64``. Other supported targets require\u27e847\u27e9 kernel versions that support the ``getrandom`` system call, so the fallback is not needed.\nOn Android targets the fallback is present only for the following ``target_arch``es: ``aarch64``, ``arm``, ``x86``, ``x86_64``. Other ``target_arch``es (e.g. RISC-V) require sufficiently high API levels.\nThe fallback can be disabled by enabling the ``linux_getrandom`` opt-in backend. Note that doing so will bump minimum supported Linux kernel version to 3.17 and Android API level to 23 (Marshmallow).\n### Early boot\nSometimes, early in the boot process, the OS has not collected enough entropy to securely seed its RNG. This is especially common on virtual machines, where standard \"random\" events are hard to come by.\nSome operating system interfaces always block until the RNG is securely seeded. This can take anywhere from a few seconds to more than a minute. A few (Linux, NetBSD and Solaris) offer a choice between blocking and getting an error; in these cases, we always choose to block.\nOn Linux (when the ``getrandom`` system call is not available), reading from ``/dev/urandom`` never blocks, even when the OS hasn't collected enough entropy yet. To avoid returning low-entropy bytes, we first poll ``/dev/random`` and only switch to ``/dev/urandom`` once this has succeeded.\nOn OpenBSD, this kind of entropy accounting isn't available, and on NetBSD, blocking on it is discouraged. On these platforms, nonblocking interfaces are used, even when reliable entropy may not be available. On the platforms where it is used, the reliability of entropy accounting itself isn't free from controversy. This library provides randomness sourced according to the platform's best practices, but each platform has its own limits on the grade of randomness it can promise in environments with few sources of entropy.\nOn ESP-IDF, if ``esp_fill_random`` is used before enabling WiFi, BT, or the voltage noise entropy source (SAR ADC), the Hardware RNG will only be seeded via RC_FAST_CLK. This can occur during early boot unless ```bootloader_random_enable``(``)``` is called. For more information see the ESP-IDF RNG Docs\u27e848\u27e9 or the RNG section of the ESP32 Technical Reference Manual\u27e849\u27e9.\n## Error handling\nWe always prioritize failure over returning known insecure \"random\" bytes. Generally, on supported platforms, failure is highly unlikely, though not impossible. If an error does occur, it is likely that it will occur on every call to ``getrandom``. Therefore, after the first successful call, one can be reasonably confident that no errors will occur.\n## Panic handling\nWe strive to eliminate all potential panics from our backend implementations. In other words, when compiled with optimizations enabled, the generated binary code for ``getrandom`` functions should not contain any panic branches. Even if the platform misbehaves and returns an unexpected result, our code should correctly handle it and return an error, e.g. ```Error`::```UNEXPECTED```\u27e850\u27e9.\n## Sanitizer support\nIf your code uses ``fill_uninit``\u27e851\u27e9 and you enable MemorySanitizer\u27e852\u27e9 (i.e. ```-`Zsanitizer`=`memory``), we will automatically handle unpoisoning of the destination buffer filled by ``fill_uninit``.\nYou can run sanitizer tests for your crate dependent on ``getrandom`` like this:\n```\n``RUSTFLAGS``=````\"`-Zsanitizer=memory`\"``` ``cargo``` test`` -`Zbuild-std``` --`target``=`x86_64-unknown-linux-gnu`\n`\n```\n\n## Minimum Supported Rust Version\nThis crate requires Rust 1.63 or later.\n## License\nThe ``getrandom`` library is distributed under either of\n  * Apache License, Version 2.0\u27e853\u27e9\n  * MIT license\u27e854\u27e9\n\n\nat your option.\n### Contribution\nUnless you explicitly state otherwise, any contribution intentionally submitted for inclusion in the work by you, as defined in the Apache-2.0 license, shall be dual licensed as above, without any additional terms or conditions.\n#### Dependencies\n~0\u20130.8MB  ~16K SLoC\n  * cfg-if\u27e855\u27e9\n  * rustc-dep-of-std?\u27e856\u27e9 compiler_builtins\u27e857\u27e9 0.1\n  * rustc-dep-of-std?\u27e856\u27e9 rustc-std-workspace-core\u27e858\u27e9\n  * wasm_js?\u27e859\u27e9 js-sys\u27e860\u27e9 wasm32 unknown none atomics\n  * wasm_js?\u27e859\u27e9 wasm-bindgen\u27e861\u27e9 wasm32 unknown none\n  * wasi\u27e862\u27e9 0.14 wasm32 wasi p2\n  * libc\u27e863\u27e9 cfg(all(any(target_o\u2026 dragonfly freebsd hurd illumos cygwin horizon arm haiku redox nto aix ios visionos watchos tvos mac openbsd vita emscripten netbsd solaris vxworks\n  * r-efi\u27e864\u27e9 uefi efi_rng\n\n\n  * build `build.rs`\n  * dev  wasm-bindgen-test\u27e865\u27e9 wasm32 unknown none\n\n\n#### Other feature\u27e866\u27e9\n  * std\u27e867\u27e9\n\n\n  *[SLoC]: approx. additional lines of code\n",
              "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://lib.rs/crates/getrandom/versions: 38 releases\n\u27e82\u27e9 https://lib.rs/os: Bindings to operating system-specific APIs. - Operating systems\n\u27e83\u27e9 https://lib.rs/crates/getrandom/rev: **49,050** crates (1,394 directly)\n\u27e84\u27e9 https://img.gs/czjpqfbdkz/full/https://github.com/rust-random/getrandom/actions/workflows/tests.yml/badge.svg?branch=master: ![Build Status\n\u27e85\u27e9 https://img.shields.io/crates/v/getrandom: ![Crate\n\u27e86\u27e9 https://img.gs/czjpqfbdkz/full/https://docs.rs/getrandom/badge.svg: ![Documentation\n\u27e87\u27e9 https://img.gs/czjpqfbdkz/full/https://deps.rs/repo/github/rust-random/getrandom/status.svg: ![Dependency Status\n\u27e88\u27e9 https://img.shields.io/crates/d/getrandom: ![Downloads\n\u27e89\u27e9 https://img.shields.io/crates/l/getrandom: ![License\n\u27e810\u27e9 https://lib.rs/crates/rand: ``rand``\n\u27e811\u27e9 https://manned.org/getrandom.2: ``getrandom``\n\u27e812\u27e9 https://manned.org/urandom.4: ``/dev/urandom``\n\u27e813\u27e9 https://learn.microsoft.com/en-us/windows/win32/seccng/processprng: ``ProcessPrng``\n\u27e814\u27e9 https://learn.microsoft.com/en-us/windows/win32/api/ntsecapi/nf-ntsecapi-rtlgenrandom: ``RtlGenRandom``\n\u27e815\u27e9 https://www.unix.com/man-page/mojave/2/getentropy/: ``getentropy``\n\u27e816\u27e9 https://opensource.apple.com/source/CommonCrypto/CommonCrypto-60074/include/CommonRandom.h.auto.html: ``CCRandomGenerateBytes``\n\u27e817\u27e9 https://www.freebsd.org/cgi/man.cgi?query=getrandom&manpath=FreeBSD+12.0-stable: ``getrandom``\n\u27e818\u27e9 https://man.openbsd.org/getentropy.2: ``getentropy``\n\u27e819\u27e9 https://man.netbsd.org/getrandom.2: ``getrandom``\n\u27e820\u27e9 https://man.netbsd.org/sysctl.7: ``kern`.`arandom``\n\u27e821\u27e9 https://leaf.dragonflybsd.org/cgi/web-man?command=getrandom: ``getrandom``\n\u27e822\u27e9 https://docs.oracle.com/cd/E88353_01/html/E37841/getrandom-2.html: ``getrandom``\n\u27e823\u27e9 https://illumos.org/man/2/getrandom: ``getrandom``\n\u27e824\u27e9 https://fuchsia.dev/fuchsia-src/zircon/syscalls/cprng_draw: ``cprng_draw``\n\u27e825\u27e9 https://github.com/hermit-os/kernel/blob/315f58ff5efc81d9bf0618af85a59963ff55f8b1/src/syscalls/entropy.rs#L47-L55: ``sys_read_entropy``\n\u27e826\u27e9 https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-getrandom: ``getrandom``\n\u27e827\u27e9 https://software.intel.com/en-us/articles/intel-digital-random-number-generator-drng-software-implementation-guide: ``RDRAND``\n\u27e828\u27e9 https://github.com/emscripten-core/emscripten/pull/12240: ``getentropy``\n\u27e829\u27e9 https://github.com/WebAssembly/WASI/blob/snapshot-01/phases/snapshot/docs.md#-random_getbuf-pointeru8-buf_len-size---errno: ``random_get``\n\u27e830\u27e9 https://github.com/WebAssembly/WASI/blob/v0.2.1/wasip2/random/random.wit#L23-L28: ``get-random-u64``\n\u27e831\u27e9 https://github.com/rust3ds/shim-3ds/commit/b01d2568836dea2a65d05d662f8e5f805c64389d: ``getrandom``\n\u27e832\u27e9 https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-reference/system/random.html#functions: ``esp_fill_random``\n\u27e833\u27e9 https://github.com/vitasdk/newlib/blob/2d869fe47aaf02b8e52d04e9a2b79d5b210fd016/newlib/libc/sys/vita/getentropy.c: ``getentropy``\n\u27e834\u27e9 https://www.qnx.com/developers/docs/7.1/index.html#com.qnx.doc.neutrino.utilities/topic/r/random.html: ``/dev/urandom``\n\u27e835\u27e9 https://www.ibm.com/docs/en/aix/7.3?topic=files-random-urandom-devices: ``/dev/urandom``\n\u27e836\u27e9 https://github.com/cygwin/cygwin/blob/main/winsup/cygwin/libc/getentropy.cc: ``getrandom``\n\u27e837\u27e9 https://developer.arm.com/documentation/ddi0601/2024-06/AArch64-Registers/RNDR--Random-Number: ``RNDR``\n\u27e838\u27e9 https://www.w3.org/TR/WebCryptoAPI/#Crypto-method-getRandomValues: ``Crypto`.`getRandomValues``\n\u27e839\u27e9 https://lib.rs/crates/getrandom#readme-webassembly-support: see below\n\u27e840\u27e9 https://uefi.org/specs/UEFI/2.10/37_Secure_Technologies.html#efi-rng-protocol: ``EFI_RNG_PROTOCOL``\n\u27e841\u27e9 https://lib.rs/crates/getrandom#readme-custom-backend: custom backend\n\u27e842\u27e9 https://doc.rust-lang.org/cargo/reference/config.html: ``.cargo/config.toml``\n\u27e843\u27e9 https://github.com/WebAssembly/WASI: WASI\n\u27e844\u27e9 https://emscripten.org: Emscripten\n\u27e845\u27e9 https://lib.rs/crates/getrandom#readme-opt-in-backends: described above\n\u27e846\u27e9 https://github.com/rustwasm/wasm-bindgen: ``wasm-bindgen``\n\u27e847\u27e9 https://doc.rust-lang.org/stable/rustc/platform-support.html: require\n\u27e848\u27e9 https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-reference/system/random.html: ESP-IDF RNG Docs\n\u27e849\u27e9 https://www.espressif.com/sites/default/files/documentation/esp32_technical_reference_manual_en.pdf#rng: RNG section of the ESP32 Technical Reference Manual\n\u27e850\u27e9 https://docs.rs/getrandom/latest/getrandom/struct.Error.html#associatedconstant.UNEXPECTED: ```Error`::```UNEXPECTED```\n\u27e851\u27e9 https://docs.rs/getrandom/latest/getrandom/fn.fill_uninit.html: ``fill_uninit``\n\u27e852\u27e9 https://doc.rust-lang.org/beta/unstable-book/compiler-flags/sanitizer.html#memorysanitizer: MemorySanitizer\n\u27e853\u27e9 https://github.com/rust-random/getrandom/blob/master/LICENSE-APACHE: Apache License, Version 2.0\n\u27e854\u27e9 https://github.com/rust-random/getrandom/blob/master/LICENSE-MIT: MIT license\n\u27e855\u27e9 https://lib.rs/crates/cfg-if: 1 - cfg-if\n\u27e856\u27e9 https://lib.rs/crates/getrandom/features#feature-rustc-dep-of-std: optional feature - rustc-dep-of-std?\n\u27e857\u27e9 https://lib.rs/crates/compiler_builtins: new - compiler_builtins\n\u27e858\u27e9 https://lib.rs/crates/rustc-std-workspace-core: renamed core, 1.0 - rustc-std-workspace-core\n\u27e859\u27e9 https://lib.rs/crates/getrandom/features#feature-wasm_js: optional feature - wasm_js?\n\u27e860\u27e9 https://lib.rs/crates/js-sys: 0.3.77 - js-sys\n\u27e861\u27e9 https://lib.rs/crates/wasm-bindgen: 0.2.98 - wasm-bindgen\n\u27e862\u27e9 https://lib.rs/crates/wasi: new - wasi\n\u27e863\u27e9 https://lib.rs/crates/libc: 0.2.154 - libc\n\u27e864\u27e9 https://lib.rs/crates/r-efi: 5.1 - r-efi\n\u27e865\u27e9 https://lib.rs/crates/wasm-bindgen-test: 0.3 - wasm-bindgen-test\n\u27e866\u27e9 https://lib.rs/crates/getrandom/features: Other feature\n\u27e867\u27e9 https://lib.rs/crates/getrandom/features#feature-std: std\n",
              "fit_markdown": "",
              "fit_html": ""
            },
            "structured_data": {},
            "quality_score": 3.0,
            "extraction_method": "crawl4ai",
            "error": null,
            "metadata": {
              "doc_type": "docs",
              "content_length": 20767,
              "has_structured_data": false,
              "crawl_success": true
            },
            "timestamp": "114829.678132"
          }
        },
        "crate_analysis": {
          "status": "completed",
          "check": [
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#cfg-if@1.0.0",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\cfg-if-1.0.0\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "cfg_if",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\cfg-if-1.0.0\\src\\lib.rs",
                "edition": "2018",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpe9bsfubp\\getrandom-0.3.3\\target\\debug\\deps\\libcfg_if-f755e379589b9030.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "compiler-artifact",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpe9bsfubp/getrandom-0.3.3#getrandom@0.3.3",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpe9bsfubp\\getrandom-0.3.3\\Cargo.toml",
              "target": {
                "kind": [
                  "custom-build"
                ],
                "crate_types": [
                  "bin"
                ],
                "name": "build-script-build",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpe9bsfubp\\getrandom-0.3.3\\build.rs",
                "edition": "2021",
                "doc": false,
                "doctest": false,
                "test": false
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpe9bsfubp\\getrandom-0.3.3\\target\\debug\\build\\getrandom-3a1bcd92205d7957\\build-script-build.exe",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpe9bsfubp\\getrandom-0.3.3\\target\\debug\\build\\getrandom-3a1bcd92205d7957\\build_script_build.pdb"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "build-script-executed",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpe9bsfubp/getrandom-0.3.3#getrandom@0.3.3",
              "linked_libs": [],
              "linked_paths": [],
              "cfgs": [],
              "env": [],
              "out_dir": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpe9bsfubp\\getrandom-0.3.3\\target\\debug\\build\\getrandom-8d848930a3b8640e\\out"
            },
            {
              "reason": "compiler-artifact",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpe9bsfubp/getrandom-0.3.3#getrandom@0.3.3",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpe9bsfubp\\getrandom-0.3.3\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "getrandom",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpe9bsfubp\\getrandom-0.3.3\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpe9bsfubp\\getrandom-0.3.3\\target\\debug\\deps\\libgetrandom-58ecf2d8c86693ca.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "build-finished",
              "success": true
            }
          ],
          "clippy": [
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#cfg-if@1.0.0",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\cfg-if-1.0.0\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "cfg_if",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\cfg-if-1.0.0\\src\\lib.rs",
                "edition": "2018",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpe9bsfubp\\getrandom-0.3.3\\target\\debug\\deps\\libcfg_if-f755e379589b9030.rmeta"
              ],
              "executable": null,
              "fresh": true
            },
            {
              "reason": "compiler-artifact",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpe9bsfubp/getrandom-0.3.3#getrandom@0.3.3",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpe9bsfubp\\getrandom-0.3.3\\Cargo.toml",
              "target": {
                "kind": [
                  "custom-build"
                ],
                "crate_types": [
                  "bin"
                ],
                "name": "build-script-build",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpe9bsfubp\\getrandom-0.3.3\\build.rs",
                "edition": "2021",
                "doc": false,
                "doctest": false,
                "test": false
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpe9bsfubp\\getrandom-0.3.3\\target\\debug\\build\\getrandom-c9c7b2d2ee628bad\\build-script-build.exe",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpe9bsfubp\\getrandom-0.3.3\\target\\debug\\build\\getrandom-c9c7b2d2ee628bad\\build_script_build.pdb"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "build-script-executed",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpe9bsfubp/getrandom-0.3.3#getrandom@0.3.3",
              "linked_libs": [],
              "linked_paths": [],
              "cfgs": [],
              "env": [],
              "out_dir": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpe9bsfubp\\getrandom-0.3.3\\target\\debug\\build\\getrandom-8210e79d2b775ba7\\out"
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpe9bsfubp/getrandom-0.3.3#getrandom@0.3.3",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpe9bsfubp\\getrandom-0.3.3\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "getrandom",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpe9bsfubp\\getrandom-0.3.3\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: variables can be used directly in the `format!` string\n   --> src\\error.rs:203:21\n    |\n203 |                     write!(f, \"OS Error: {}\", errno)\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#uninlined_format_args\n    = note: `#[warn(clippy::uninlined_format_args)]` on by default\nhelp: change this to\n    |\n203 -                     write!(f, \"OS Error: {}\", errno)\n203 +                     write!(f, \"OS Error: {errno}\")\n    |\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#uninlined_format_args",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "note",
                    "message": "`#[warn(clippy::uninlined_format_args)]` on by default",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "change this to",
                    "rendered": null,
                    "spans": [
                      {
                        "byte_end": 8616,
                        "byte_start": 8616,
                        "column_end": 43,
                        "column_start": 43,
                        "expansion": null,
                        "file_name": "src\\error.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 203,
                        "line_start": 203,
                        "suggested_replacement": "errno",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 43,
                            "highlight_start": 43,
                            "text": "                    write!(f, \"OS Error: {}\", errno)"
                          }
                        ]
                      },
                      {
                        "byte_end": 8625,
                        "byte_start": 8618,
                        "column_end": 52,
                        "column_start": 45,
                        "expansion": null,
                        "file_name": "src\\error.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 203,
                        "line_start": 203,
                        "suggested_replacement": "",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 52,
                            "highlight_start": 45,
                            "text": "                    write!(f, \"OS Error: {}\", errno)"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "code": {
                  "code": "clippy::uninlined_format_args",
                  "explanation": null
                },
                "level": "warning",
                "message": "variables can be used directly in the `format!` string",
                "spans": [
                  {
                    "byte_end": 8626,
                    "byte_start": 8594,
                    "column_end": 53,
                    "column_start": 21,
                    "expansion": null,
                    "file_name": "src\\error.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 203,
                    "line_start": 203,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 53,
                        "highlight_start": 21,
                        "text": "                    write!(f, \"OS Error: {}\", errno)"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-artifact",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpe9bsfubp/getrandom-0.3.3#getrandom@0.3.3",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpe9bsfubp\\getrandom-0.3.3\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "getrandom",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpe9bsfubp\\getrandom-0.3.3\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpe9bsfubp\\getrandom-0.3.3\\target\\debug\\deps\\libgetrandom-9d85e833be226ef9.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "build-finished",
              "success": true
            }
          ],
          "audit": {
            "database": {
              "advisory-count": 787,
              "last-commit": "7573f55ba337263f61167dbb0ea926cdc7c8eb5d",
              "last-updated": "2025-06-17T11:04:25+02:00"
            },
            "lockfile": {
              "dependency-count": 42
            },
            "settings": {
              "target_arch": [],
              "target_os": [],
              "severity": null,
              "ignore": [],
              "informational_warnings": [
                "unmaintained",
                "unsound",
                "notice"
              ]
            },
            "vulnerabilities": {
              "found": false,
              "count": 0,
              "list": []
            },
            "warnings": {}
          },
          "note": "Crate analysis performed with stable toolchain."
        },
        "crate_metadata": {
          "name": "getrandom",
          "version": "0.3.3",
          "description": "ALLOW: Positive community sentiment",
          "repository": "",
          "keywords": [],
          "categories": [],
          "readme": {
            "raw_markdown": "[](https://docs.rs/getrandom/latest/getrandom/all.html \"show sidebar\")\n# Crate getrandomCopy item path\n[Settings](https://docs.rs/getrandom/latest/settings.html)\n[Help](https://docs.rs/getrandom/latest/help.html)\nSummary[Source](https://docs.rs/getrandom/latest/src/getrandom/lib.rs.html#2-143)\nExpand description\n## [\u00a7](https://docs.rs/getrandom/latest/getrandom/#getrandom-systems-random-number-generator)getrandom: system\u2019s random number generator\n[![Build Status](https://github.com/rust-random/getrandom/actions/workflows/tests.yml/badge.svg?branch=master)](https://github.com/rust-random/getrandom/actions?query=branch:master) [![Crate](https://img.shields.io/crates/v/getrandom)](https://crates.io/crates/getrandom) [![Documentation](https://docs.rs/getrandom/badge.svg)](https://docs.rs/getrandom) [![Dependency Status](https://deps.rs/repo/github/rust-random/getrandom/status.svg)](https://deps.rs/repo/github/rust-random/getrandom) [![Downloads](https://img.shields.io/crates/d/getrandom)](https://crates.io/crates/getrandom) [![License](https://img.shields.io/crates/l/getrandom)](https://github.com/rust-random/getrandom/blob/master/LICENSE-MIT)\n`getrandom` is a Rust library for retrieving random data from (operating) system sources.\nIt is assumed that the system always provides high-quality, cryptographically secure random data, ideally backed by hardware entropy sources. This crate derives its name from the Linux `getrandom` syscall but is cross-platform, roughly supporting the same set of platforms as Rust\u2019s `std` library.\nThis is a low-level API. Most users should prefer using a higher-level random-number library like [`rand`](https://crates.io/crates/rand).\n### [\u00a7](https://docs.rs/getrandom/latest/getrandom/#usage)Usage\nAdd the `getrandom` dependency to your `Cargo.toml` file:\n```\n[dependencies]\ngetrandom = \"0.3\"\n```\n\nThen invoke the `fill` function on a byte buffer to fill it with random data:\n```\nfn get_random_u128() -> Result<u128, getrandom::Error> {\n  let mut buf = [0u8; 16];\n  getrandom::fill(&mut buf)?;\n  Ok(u128::from_ne_bytes(buf))\n}\n```\n\n### [\u00a7](https://docs.rs/getrandom/latest/getrandom/#supported-targets)Supported targets\nTarget| Target Triple| Implementation  \n---|---|---  \nLinux, Android| `*\u2011linux\u2011*`| [`getrandom`](https://manned.org/getrandom.2) system call if available, otherwise [`/dev/urandom`](https://manned.org/urandom.4) after successfully polling `/dev/random`  \nWindows 10+| `*\u2011windows\u2011*`| [`ProcessPrng`](https://learn.microsoft.com/en-us/windows/win32/seccng/processprng) on Rust 1.78+, [`RtlGenRandom`](https://learn.microsoft.com/en-us/windows/win32/api/ntsecapi/nf-ntsecapi-rtlgenrandom) otherwise  \nWindows 7, 8| `*-win7\u2011windows\u2011*`| [`RtlGenRandom`](https://learn.microsoft.com/en-us/windows/win32/api/ntsecapi/nf-ntsecapi-rtlgenrandom)  \nmacOS| `*\u2011apple\u2011darwin`| [`getentropy`](https://www.unix.com/man-page/mojave/2/getentropy/)  \niOS, tvOS, watchOS| `*\u2011apple\u2011{ios,tvos,watchos}`| [`CCRandomGenerateBytes`](https://opensource.apple.com/source/CommonCrypto/CommonCrypto-60074/include/CommonRandom.h.auto.html)  \nFreeBSD| `*\u2011freebsd`| [`getrandom`](https://www.freebsd.org/cgi/man.cgi?query=getrandom&manpath=FreeBSD+12.0-stable)  \nOpenBSD| `*\u2011openbsd`| [`getentropy`](https://man.openbsd.org/getentropy.2)  \nNetBSD| `*\u2011netbsd`| [`getrandom`](https://man.netbsd.org/getrandom.2) if available, otherwise [`kern.arandom`](https://man.netbsd.org/sysctl.7)  \nDragonfly BSD| `*\u2011dragonfly`| [`getrandom`](https://leaf.dragonflybsd.org/cgi/web-man?command=getrandom)  \nSolaris| `*\u2011solaris`| [`getrandom`](https://docs.oracle.com/cd/E88353_01/html/E37841/getrandom-2.html) with `GRND_RANDOM`  \nillumos| `*\u2011illumos`| [`getrandom`](https://illumos.org/man/2/getrandom)  \nFuchsia OS| `*\u2011fuchsia`| [`cprng_draw`](https://fuchsia.dev/fuchsia-src/zircon/syscalls/cprng_draw)  \nRedox| `*\u2011redox`| `/dev/urandom`  \nHaiku| `*\u2011haiku`| `/dev/urandom` (identical to `/dev/random`)  \nHermit| `*-hermit`| [`sys_read_entropy`](https://github.com/hermit-os/kernel/blob/315f58ff5efc81d9bf0618af85a59963ff55f8b1/src/syscalls/entropy.rs#L47-L55)  \nHurd| `*-hurd-*`| [`getrandom`](https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-getrandom)  \nSGX| `x86_64\u2011*\u2011sgx`| [`RDRAND`](https://software.intel.com/en-us/articles/intel-digital-random-number-generator-drng-software-implementation-guide)  \nVxWorks| `*\u2011wrs\u2011vxworks\u2011*`| `randABytes` after checking entropy pool initialization with `randSecure`  \nEmscripten| `*\u2011emscripten`| [`getentropy`](https://github.com/emscripten-core/emscripten/pull/12240)  \nWASI 0.1| `wasm32\u2011wasip1`| [`random_get`](https://github.com/WebAssembly/WASI/blob/snapshot-01/phases/snapshot/docs.md#-random_getbuf-pointeru8-buf_len-size---errno)  \nWASI 0.2| `wasm32\u2011wasip2`| [`get-random-u64`](https://github.com/WebAssembly/WASI/blob/v0.2.1/wasip2/random/random.wit#L23-L28)  \nSOLID| `*-kmc-solid_*`| `SOLID_RNG_SampleRandomBytes`  \nNintendo 3DS| `*-nintendo-3ds`| [`getrandom`](https://github.com/rust3ds/shim-3ds/commit/b01d2568836dea2a65d05d662f8e5f805c64389d)  \nESP-IDF| `*\u2011espidf`| [`esp_fill_random`](https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-reference/system/random.html#functions) WARNING: see \u201cEarly Boot\u201d section below  \nPS Vita| `*-vita-*`| [`getentropy`](https://github.com/vitasdk/newlib/blob/2d869fe47aaf02b8e52d04e9a2b79d5b210fd016/newlib/libc/sys/vita/getentropy.c)  \nQNX Neutrino| `*\u2011nto-qnx*`| [`/dev/urandom`](https://www.qnx.com/developers/docs/7.1/index.html#com.qnx.doc.neutrino.utilities/topic/r/random.html) (identical to `/dev/random`)  \nAIX| `*-ibm-aix`| [`/dev/urandom`](https://www.ibm.com/docs/en/aix/7.3?topic=files-random-urandom-devices)  \nCygwin| `*-cygwin`| [`getrandom`](https://github.com/cygwin/cygwin/blob/main/winsup/cygwin/libc/getentropy.cc) (based on [`RtlGenRandom`](https://learn.microsoft.com/en-us/windows/win32/api/ntsecapi/nf-ntsecapi-rtlgenrandom))  \nPull Requests that add support for new targets to `getrandom` are always welcome.\n#### [\u00a7](https://docs.rs/getrandom/latest/getrandom/#opt-in-backends)Opt-in backends\n`getrandom` also provides optional (opt-in) backends, which allow users to customize the source of randomness based on their specific needs:\nBackend name| Target| Target Triple| Implementation  \n---|---|---|---  \n`linux_getrandom`| Linux, Android| `*\u2011linux\u2011*`| [`getrandom`](https://manned.org/getrandom.2) system call (without `/dev/urandom` fallback). Bumps minimum supported Linux kernel version to 3.17 and Android API level to 23 (Marshmallow).  \n`linux_raw`| Linux, Android| `*\u2011linux\u2011*`| Same as `linux_getrandom`, but uses raw `asm!`-based syscalls instead of `libc`.  \n`rdrand`| x86, x86-64| `x86_64-*`, `i686-*`| [`RDRAND`](https://software.intel.com/en-us/articles/intel-digital-random-number-generator-drng-software-implementation-guide) instruction  \n`rndr`| AArch64| `aarch64-*`| [`RNDR`](https://developer.arm.com/documentation/ddi0601/2024-06/AArch64-Registers/RNDR--Random-Number) register  \n`wasm_js`| Web Browser, Node.js| `wasm32\u2011unknown\u2011unknown`, `wasm32v1-none`| [`Crypto.getRandomValues`](https://www.w3.org/TR/WebCryptoAPI/#Crypto-method-getRandomValues). Requires feature `wasm_js` ([see below](https://docs.rs/getrandom/latest/getrandom/#webassembly-support)).  \n`efi_rng`| UEFI| `*-unknown\u2011uefi`| [`EFI_RNG_PROTOCOL`](https://uefi.org/specs/UEFI/2.10/37_Secure_Technologies.html#efi-rng-protocol) with `EFI_RNG_ALGORITHM_RAW` (requires `std` and Nigthly compiler)  \n`custom`| All targets| `*`| User-provided custom implementation (see [custom backend](https://docs.rs/getrandom/latest/getrandom/#custom-backend))  \nOpt-in backends can be enabled using the `getrandom_backend` configuration flag. The flag can be set either by specifying the `rustflags` field in [`.cargo/config.toml`](https://doc.rust-lang.org/cargo/reference/config.html):\n```\n# It's recommended to set the flag on a per-target basis:\n[target.wasm32-unknown-unknown]\nrustflags = ['--cfg', 'getrandom_backend=\"wasm_js\"']\n```\n\nOr by using the `RUSTFLAGS` environment variable:\n```\nRUSTFLAGS='--cfg getrandom_backend=\"linux_getrandom\"' cargo build\n```\n\nEnabling an opt-in backend will replace the backend used by default. Doing this for an incorrect target (e.g. using `linux_getrandom` while compiling for a Windows target) will result in a compilation error. Be extremely careful while using opt-in backends, as incorrect configuration may result in vulnerable applications or applications that always panic.\nNote that using an opt-in backend in a library (e.g. for tests or benchmarks) WILL NOT have any effect on its downstream users.\n#### [\u00a7](https://docs.rs/getrandom/latest/getrandom/#raw-linux-syscall-support)Raw Linux syscall support\nCurrently the `linux_raw` backend supports only targets with stabilized `asm!` macro, i.e. `arm`, `aarch64`, `loongarch64`, `riscv32`, `riscv64`, `s390x`, `x86`, and `x86_64`.\nNote that the raw syscall backend may be slower than backends based on `libc::getrandom`, e.g. it does not implement vDSO optimizations and on `x86` it uses the infamously slow `int 0x80` instruction to perform syscall.\n#### [\u00a7](https://docs.rs/getrandom/latest/getrandom/#webassembly-support)WebAssembly support\nThis crate fully supports the [WASI](https://github.com/WebAssembly/WASI) and [Emscripten](https://emscripten.org) targets. However, the `wasm32-unknown-unknown` target (i.e. the target used by `wasm-pack`) is not automatically supported since, from the target name alone, we cannot deduce which JavaScript interface should be used (or if JavaScript is available at all).\nTo enable `getrandom`\u2019s functionality on `wasm32-unknown-unknown` using the Web Crypto methods [described above](https://docs.rs/getrandom/latest/getrandom/#opt-in-backends) via [`wasm-bindgen`](https://github.com/rustwasm/wasm-bindgen), do _both_ of the following:\n  * Use the `wasm_js` feature flag, i.e. `getrandom = { version = \"0.3\", features = [\"wasm_js\"] }`. On its own, this only makes the backend available. (As a side effect this will make your `Cargo.lock` significantly larger if you are not already using [`wasm-bindgen`](https://github.com/rustwasm/wasm-bindgen), but otherwise enabling this feature is harmless.)\n  * Set `RUSTFLAGS='--cfg getrandom_backend=\"wasm_js\"'` ([see above](https://docs.rs/getrandom/latest/getrandom/#opt-in-backends)).\n\n\nThis backend supports both web browsers (main window and Web Workers) and Node.js (v19 or later) environments.\nWARNING: It is highly recommended to enable the `wasm_js` feature only for binary crates and tests, i.e. avoid unconditionally enabling it in library crates.\n#### [\u00a7](https://docs.rs/getrandom/latest/getrandom/#custom-backend)Custom backend\nIf this crate does not support your target out of the box or you have to use a non-default entropy source, then you can provide a custom implementation. You need to enable the custom backend as described in the [opt-in backends](https://docs.rs/getrandom/latest/getrandom/#opt-in-backends) section.\nNext, you need to define an `extern` function with the following signature:\n```\nuse getrandom::Error;\n#[no_mangle]\nunsafe extern \"Rust\" fn __getrandom_v03_custom(\n  dest: *mut u8,\n  len: usize,\n) -> Result<(), Error> {\n  todo!()\n}\n```\n\nThis function should, ideally, be defined in the root crate of your project, e.g. in your `main.rs`. This function MUST be defined only once for your project, i.e. upstream library crates SHOULD NOT define it outside of tests and benchmarks. Improper configuration of this backend may result in linking errors.\nThe function accepts a pointer to a buffer that should be filled with random data and its length in bytes. Note that the buffer MAY be uninitialized. On success, the function should return `Ok(())` and fully fill the input buffer; otherwise, it should return an error value.\nWhile wrapping functions which work with byte slices you should fully initialize the buffer before passing it to the function:\n```\nuse getrandom::Error;\nfn my_entropy_source(buf: &mut [u8]) -> Result<(), getrandom::Error> {\n  // ...\n  Ok(())\n}\n#[no_mangle]\nunsafe extern \"Rust\" fn __getrandom_v03_custom(\n  dest: *mut u8,\n  len: usize,\n) -> Result<(), Error> {\n  let buf = unsafe {\n    // fill the buffer with zeros\n    core::ptr::write_bytes(dest, 0, len);\n    // create mutable byte slice\n    core::slice::from_raw_parts_mut(dest, len)\n  };\n  my_entropy_source(buf)\n}\n```\n\nIf you are confident that `getrandom` is not used in your project, but it gets pulled nevertheless by one of your dependencies, then you can use the following custom backend, which always returns the \u201cunsupported\u201d error:\n```\nuse getrandom::Error;\n#[no_mangle]\nunsafe extern \"Rust\" fn __getrandom_v03_custom(\n  dest: *mut u8,\n  len: usize,\n) -> Result<(), Error> {\n  Err(Error::UNSUPPORTED)\n}\n```\n\n#### [\u00a7](https://docs.rs/getrandom/latest/getrandom/#platform-support)Platform Support\nThis crate generally supports the same operating system and platform versions that the Rust standard library does. Additional targets may be supported using the opt-in custom backend.\nThis means that as Rust drops support for old versions of operating systems (such as old Linux kernel versions, Android API levels, etc.) in stable releases, `getrandom` may create new patch releases that remove support for outdated platform versions.\n#### [\u00a7](https://docs.rs/getrandom/latest/getrandom/#devurandom-fallback-on-linux-and-android)`/dev/urandom` fallback on Linux and Android\nOn Linux targets, the `/dev/urandom` fallback is present only if either `target_env` is `musl`, or `target_arch` is one of the following: `aarch64`, `arm`, `powerpc`, `powerpc64`, `s390x`, `x86`, `x86_64`. Other supported targets [require](https://doc.rust-lang.org/stable/rustc/platform-support.html) kernel versions that support the `getrandom` system call, so the fallback is not needed.\nOn Android targets the fallback is present only for the following `target_arch`es: `aarch64`, `arm`, `x86`, `x86_64`. Other `target_arch`es (e.g. RISC-V) require sufficiently high API levels.\nThe fallback can be disabled by enabling the `linux_getrandom` opt-in backend. Note that doing so will bump minimum supported Linux kernel version to 3.17 and Android API level to 23 (Marshmallow).\n#### [\u00a7](https://docs.rs/getrandom/latest/getrandom/#early-boot)Early boot\nSometimes, early in the boot process, the OS has not collected enough entropy to securely seed its RNG. This is especially common on virtual machines, where standard \u201crandom\u201d events are hard to come by.\nSome operating system interfaces always block until the RNG is securely seeded. This can take anywhere from a few seconds to more than a minute. A few (Linux, NetBSD and Solaris) offer a choice between blocking and getting an error; in these cases, we always choose to block.\nOn Linux (when the `getrandom` system call is not available), reading from `/dev/urandom` never blocks, even when the OS hasn\u2019t collected enough entropy yet. To avoid returning low-entropy bytes, we first poll `/dev/random` and only switch to `/dev/urandom` once this has succeeded.\nOn OpenBSD, this kind of entropy accounting isn\u2019t available, and on NetBSD, blocking on it is discouraged. On these platforms, nonblocking interfaces are used, even when reliable entropy may not be available. On the platforms where it is used, the reliability of entropy accounting itself isn\u2019t free from controversy. This library provides randomness sourced according to the platform\u2019s best practices, but each platform has its own limits on the grade of randomness it can promise in environments with few sources of entropy.\nOn ESP-IDF, if `esp_fill_random` is used before enabling WiFi, BT, or the voltage noise entropy source (SAR ADC), the Hardware RNG will only be seeded via RC_FAST_CLK. This can occur during early boot unless `bootloader_random_enable()` is called. For more information see the [ESP-IDF RNG Docs](https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-reference/system/random.html) or the [RNG section of the ESP32 Technical Reference Manual](https://www.espressif.com/sites/default/files/documentation/esp32_technical_reference_manual_en.pdf#rng).\n### [\u00a7](https://docs.rs/getrandom/latest/getrandom/#error-handling)Error handling\nWe always prioritize failure over returning known insecure \u201crandom\u201d bytes. Generally, on supported platforms, failure is highly unlikely, though not impossible. If an error does occur, it is likely that it will occur on every call to `getrandom`. Therefore, after the first successful call, one can be reasonably confident that no errors will occur.\n### [\u00a7](https://docs.rs/getrandom/latest/getrandom/#panic-handling)Panic handling\nWe strive to eliminate all potential panics from our backend implementations. In other words, when compiled with optimizations enabled, the generated binary code for `getrandom` functions should not contain any panic branches. Even if the platform misbehaves and returns an unexpected result, our code should correctly handle it and return an error, e.g. [`Error::UNEXPECTED`](https://docs.rs/getrandom/latest/getrandom/struct.Error.html#associatedconstant.UNEXPECTED \"associated constant getrandom::Error::UNEXPECTED\").\n### [\u00a7](https://docs.rs/getrandom/latest/getrandom/#sanitizer-support)Sanitizer support\nIf your code uses [`fill_uninit`](https://docs.rs/getrandom/latest/getrandom/fn.fill_uninit.html \"fn getrandom::fill_uninit\") and you enable [MemorySanitizer](https://doc.rust-lang.org/beta/unstable-book/compiler-flags/sanitizer.html#memorysanitizer) (i.e. `-Zsanitizer=memory`), we will automatically handle unpoisoning of the destination buffer filled by `fill_uninit`.\nYou can run sanitizer tests for your crate dependent on `getrandom` like this:\n```\nRUSTFLAGS=\"-Zsanitizer=memory\" cargo test -Zbuild-std --target=x86_64-unknown-linux-gnu\n```\n\n### [\u00a7](https://docs.rs/getrandom/latest/getrandom/#minimum-supported-rust-version)Minimum Supported Rust Version\nThis crate requires Rust 1.63 or later.\n### [\u00a7](https://docs.rs/getrandom/latest/getrandom/#license)License\nThe `getrandom` library is distributed under either of\n  * [Apache License, Version 2.0](https://github.com/rust-random/getrandom/blob/master/LICENSE-APACHE)\n  * [MIT license](https://github.com/rust-random/getrandom/blob/master/LICENSE-MIT)\n\n\nat your option.\n#### [\u00a7](https://docs.rs/getrandom/latest/getrandom/#contribution)Contribution\nUnless you explicitly state otherwise, any contribution intentionally submitted for inclusion in the work by you, as defined in the Apache-2.0 license, shall be dual licensed as above, without any additional terms or conditions.\n## Structs[\u00a7](https://docs.rs/getrandom/latest/getrandom/#structs)\n\n[Error](https://docs.rs/getrandom/latest/getrandom/struct.Error.html \"struct getrandom::Error\")\n    A small and `no_std` compatible error type\n## Functions[\u00a7](https://docs.rs/getrandom/latest/getrandom/#functions)\n\n[fill](https://docs.rs/getrandom/latest/getrandom/fn.fill.html \"fn getrandom::fill\")\n    Fill `dest` with random bytes from the system\u2019s preferred random number source.\n\n[fill_uninit](https://docs.rs/getrandom/latest/getrandom/fn.fill_uninit.html \"fn getrandom::fill_uninit\")\n    Fill potentially uninitialized buffer `dest` with random bytes from the system\u2019s preferred random number source and return a mutable reference to those bytes.\n\n[u32](https://docs.rs/getrandom/latest/getrandom/fn.u32.html \"fn getrandom::u32\")\n    Get random `u32` from the system\u2019s preferred random number source.\n\n[u64](https://docs.rs/getrandom/latest/getrandom/fn.u64.html \"fn getrandom::u64\")\n    Get random `u64` from the system\u2019s preferred random number source.\n",
            "markdown_with_citations": "[](https://docs.rs/getrandom/latest/getrandom/all.html \"show sidebar\")\n# Crate getrandomCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\n## \u00a7\u27e84\u27e9getrandom: system\u2019s random number generator\n![Build Status\u27e85\u27e9](https://github.com/rust-random/getrandom/actions?query=branch:master) ![Crate\u27e86\u27e9](https://crates.io/crates/getrandom) ![Documentation\u27e87\u27e9](https://docs.rs/getrandom) ![Dependency Status\u27e88\u27e9](https://deps.rs/repo/github/rust-random/getrandom) ![Downloads\u27e89\u27e9](https://crates.io/crates/getrandom) ![License\u27e810\u27e9](https://github.com/rust-random/getrandom/blob/master/LICENSE-MIT)\n`getrandom` is a Rust library for retrieving random data from (operating) system sources.\nIt is assumed that the system always provides high-quality, cryptographically secure random data, ideally backed by hardware entropy sources. This crate derives its name from the Linux `getrandom` syscall but is cross-platform, roughly supporting the same set of platforms as Rust\u2019s `std` library.\nThis is a low-level API. Most users should prefer using a higher-level random-number library like `rand`\u27e811\u27e9.\n### \u00a7\u27e812\u27e9Usage\nAdd the `getrandom` dependency to your `Cargo.toml` file:\n```\n[dependencies]\ngetrandom = \"0.3\"\n```\n\nThen invoke the `fill` function on a byte buffer to fill it with random data:\n```\nfn get_random_u128() -> Result<u128, getrandom::Error> {\n  let mut buf = [0u8; 16];\n  getrandom::fill(&mut buf)?;\n  Ok(u128::from_ne_bytes(buf))\n}\n```\n\n### \u00a7\u27e813\u27e9Supported targets\nTarget| Target Triple| Implementation  \n---|---|---  \nLinux, Android| `*\u2011linux\u2011*`| `getrandom`\u27e814\u27e9 system call if available, otherwise `/dev/urandom`\u27e815\u27e9 after successfully polling `/dev/random`  \nWindows 10+| `*\u2011windows\u2011*`| `ProcessPrng`\u27e816\u27e9 on Rust 1.78+, `RtlGenRandom`\u27e817\u27e9 otherwise  \nWindows 7, 8| `*-win7\u2011windows\u2011*`| `RtlGenRandom`\u27e817\u27e9  \nmacOS| `*\u2011apple\u2011darwin`| `getentropy`\u27e818\u27e9  \niOS, tvOS, watchOS| `*\u2011apple\u2011{ios,tvos,watchos}`| `CCRandomGenerateBytes`\u27e819\u27e9  \nFreeBSD| `*\u2011freebsd`| `getrandom`\u27e820\u27e9  \nOpenBSD| `*\u2011openbsd`| `getentropy`\u27e821\u27e9  \nNetBSD| `*\u2011netbsd`| `getrandom`\u27e822\u27e9 if available, otherwise `kern.arandom`\u27e823\u27e9  \nDragonfly BSD| `*\u2011dragonfly`| `getrandom`\u27e824\u27e9  \nSolaris| `*\u2011solaris`| `getrandom`\u27e825\u27e9 with `GRND_RANDOM`  \nillumos| `*\u2011illumos`| `getrandom`\u27e826\u27e9  \nFuchsia OS| `*\u2011fuchsia`| `cprng_draw`\u27e827\u27e9  \nRedox| `*\u2011redox`| `/dev/urandom`  \nHaiku| `*\u2011haiku`| `/dev/urandom` (identical to `/dev/random`)  \nHermit| `*-hermit`| `sys_read_entropy`\u27e828\u27e9  \nHurd| `*-hurd-*`| `getrandom`\u27e829\u27e9  \nSGX| `x86_64\u2011*\u2011sgx`| `RDRAND`\u27e830\u27e9  \nVxWorks| `*\u2011wrs\u2011vxworks\u2011*`| `randABytes` after checking entropy pool initialization with `randSecure`  \nEmscripten| `*\u2011emscripten`| `getentropy`\u27e831\u27e9  \nWASI 0.1| `wasm32\u2011wasip1`| `random_get`\u27e832\u27e9  \nWASI 0.2| `wasm32\u2011wasip2`| `get-random-u64`\u27e833\u27e9  \nSOLID| `*-kmc-solid_*`| `SOLID_RNG_SampleRandomBytes`  \nNintendo 3DS| `*-nintendo-3ds`| `getrandom`\u27e834\u27e9  \nESP-IDF| `*\u2011espidf`| `esp_fill_random`\u27e835\u27e9 WARNING: see \u201cEarly Boot\u201d section below  \nPS Vita| `*-vita-*`| `getentropy`\u27e836\u27e9  \nQNX Neutrino| `*\u2011nto-qnx*`| `/dev/urandom`\u27e837\u27e9 (identical to `/dev/random`)  \nAIX| `*-ibm-aix`| `/dev/urandom`\u27e838\u27e9  \nCygwin| `*-cygwin`| `getrandom`\u27e839\u27e9 (based on `RtlGenRandom`\u27e817\u27e9)  \nPull Requests that add support for new targets to `getrandom` are always welcome.\n#### \u00a7\u27e840\u27e9Opt-in backends\n`getrandom` also provides optional (opt-in) backends, which allow users to customize the source of randomness based on their specific needs:\nBackend name| Target| Target Triple| Implementation  \n---|---|---|---  \n`linux_getrandom`| Linux, Android| `*\u2011linux\u2011*`| `getrandom`\u27e814\u27e9 system call (without `/dev/urandom` fallback). Bumps minimum supported Linux kernel version to 3.17 and Android API level to 23 (Marshmallow).  \n`linux_raw`| Linux, Android| `*\u2011linux\u2011*`| Same as `linux_getrandom`, but uses raw `asm!`-based syscalls instead of `libc`.  \n`rdrand`| x86, x86-64| `x86_64-*`, `i686-*`| `RDRAND`\u27e830\u27e9 instruction  \n`rndr`| AArch64| `aarch64-*`| `RNDR`\u27e841\u27e9 register  \n`wasm_js`| Web Browser, Node.js| `wasm32\u2011unknown\u2011unknown`, `wasm32v1-none`| `Crypto.getRandomValues`\u27e842\u27e9. Requires feature `wasm_js` (see below\u27e843\u27e9).  \n`efi_rng`| UEFI| `*-unknown\u2011uefi`| `EFI_RNG_PROTOCOL`\u27e844\u27e9 with `EFI_RNG_ALGORITHM_RAW` (requires `std` and Nigthly compiler)  \n`custom`| All targets| `*`| User-provided custom implementation (see custom backend\u27e845\u27e9)  \nOpt-in backends can be enabled using the `getrandom_backend` configuration flag. The flag can be set either by specifying the `rustflags` field in `.cargo/config.toml`\u27e846\u27e9:\n```\n# It's recommended to set the flag on a per-target basis:\n[target.wasm32-unknown-unknown]\nrustflags = ['--cfg', 'getrandom_backend=\"wasm_js\"']\n```\n\nOr by using the `RUSTFLAGS` environment variable:\n```\nRUSTFLAGS='--cfg getrandom_backend=\"linux_getrandom\"' cargo build\n```\n\nEnabling an opt-in backend will replace the backend used by default. Doing this for an incorrect target (e.g. using `linux_getrandom` while compiling for a Windows target) will result in a compilation error. Be extremely careful while using opt-in backends, as incorrect configuration may result in vulnerable applications or applications that always panic.\nNote that using an opt-in backend in a library (e.g. for tests or benchmarks) WILL NOT have any effect on its downstream users.\n#### \u00a7\u27e847\u27e9Raw Linux syscall support\nCurrently the `linux_raw` backend supports only targets with stabilized `asm!` macro, i.e. `arm`, `aarch64`, `loongarch64`, `riscv32`, `riscv64`, `s390x`, `x86`, and `x86_64`.\nNote that the raw syscall backend may be slower than backends based on `libc::getrandom`, e.g. it does not implement vDSO optimizations and on `x86` it uses the infamously slow `int 0x80` instruction to perform syscall.\n#### \u00a7\u27e843\u27e9WebAssembly support\nThis crate fully supports the WASI\u27e848\u27e9 and Emscripten\u27e849\u27e9 targets. However, the `wasm32-unknown-unknown` target (i.e. the target used by `wasm-pack`) is not automatically supported since, from the target name alone, we cannot deduce which JavaScript interface should be used (or if JavaScript is available at all).\nTo enable `getrandom`\u2019s functionality on `wasm32-unknown-unknown` using the Web Crypto methods described above\u27e840\u27e9 via `wasm-bindgen`\u27e850\u27e9, do _both_ of the following:\n  * Use the `wasm_js` feature flag, i.e. `getrandom = { version = \"0.3\", features = [\"wasm_js\"] }`. On its own, this only makes the backend available. (As a side effect this will make your `Cargo.lock` significantly larger if you are not already using `wasm-bindgen`\u27e850\u27e9, but otherwise enabling this feature is harmless.)\n  * Set `RUSTFLAGS='--cfg getrandom_backend=\"wasm_js\"'` (see above\u27e840\u27e9).\n\n\nThis backend supports both web browsers (main window and Web Workers) and Node.js (v19 or later) environments.\nWARNING: It is highly recommended to enable the `wasm_js` feature only for binary crates and tests, i.e. avoid unconditionally enabling it in library crates.\n#### \u00a7\u27e845\u27e9Custom backend\nIf this crate does not support your target out of the box or you have to use a non-default entropy source, then you can provide a custom implementation. You need to enable the custom backend as described in the opt-in backends\u27e840\u27e9 section.\nNext, you need to define an `extern` function with the following signature:\n```\nuse getrandom::Error;\n#[no_mangle]\nunsafe extern \"Rust\" fn __getrandom_v03_custom(\n  dest: *mut u8,\n  len: usize,\n) -> Result<(), Error> {\n  todo!()\n}\n```\n\nThis function should, ideally, be defined in the root crate of your project, e.g. in your `main.rs`. This function MUST be defined only once for your project, i.e. upstream library crates SHOULD NOT define it outside of tests and benchmarks. Improper configuration of this backend may result in linking errors.\nThe function accepts a pointer to a buffer that should be filled with random data and its length in bytes. Note that the buffer MAY be uninitialized. On success, the function should return `Ok(())` and fully fill the input buffer; otherwise, it should return an error value.\nWhile wrapping functions which work with byte slices you should fully initialize the buffer before passing it to the function:\n```\nuse getrandom::Error;\nfn my_entropy_source(buf: &mut [u8]) -> Result<(), getrandom::Error> {\n  // ...\n  Ok(())\n}\n#[no_mangle]\nunsafe extern \"Rust\" fn __getrandom_v03_custom(\n  dest: *mut u8,\n  len: usize,\n) -> Result<(), Error> {\n  let buf = unsafe {\n    // fill the buffer with zeros\n    core::ptr::write_bytes(dest, 0, len);\n    // create mutable byte slice\n    core::slice::from_raw_parts_mut(dest, len)\n  };\n  my_entropy_source(buf)\n}\n```\n\nIf you are confident that `getrandom` is not used in your project, but it gets pulled nevertheless by one of your dependencies, then you can use the following custom backend, which always returns the \u201cunsupported\u201d error:\n```\nuse getrandom::Error;\n#[no_mangle]\nunsafe extern \"Rust\" fn __getrandom_v03_custom(\n  dest: *mut u8,\n  len: usize,\n) -> Result<(), Error> {\n  Err(Error::UNSUPPORTED)\n}\n```\n\n#### \u00a7\u27e851\u27e9Platform Support\nThis crate generally supports the same operating system and platform versions that the Rust standard library does. Additional targets may be supported using the opt-in custom backend.\nThis means that as Rust drops support for old versions of operating systems (such as old Linux kernel versions, Android API levels, etc.) in stable releases, `getrandom` may create new patch releases that remove support for outdated platform versions.\n#### \u00a7\u27e852\u27e9`/dev/urandom` fallback on Linux and Android\nOn Linux targets, the `/dev/urandom` fallback is present only if either `target_env` is `musl`, or `target_arch` is one of the following: `aarch64`, `arm`, `powerpc`, `powerpc64`, `s390x`, `x86`, `x86_64`. Other supported targets require\u27e853\u27e9 kernel versions that support the `getrandom` system call, so the fallback is not needed.\nOn Android targets the fallback is present only for the following `target_arch`es: `aarch64`, `arm`, `x86`, `x86_64`. Other `target_arch`es (e.g. RISC-V) require sufficiently high API levels.\nThe fallback can be disabled by enabling the `linux_getrandom` opt-in backend. Note that doing so will bump minimum supported Linux kernel version to 3.17 and Android API level to 23 (Marshmallow).\n#### \u00a7\u27e854\u27e9Early boot\nSometimes, early in the boot process, the OS has not collected enough entropy to securely seed its RNG. This is especially common on virtual machines, where standard \u201crandom\u201d events are hard to come by.\nSome operating system interfaces always block until the RNG is securely seeded. This can take anywhere from a few seconds to more than a minute. A few (Linux, NetBSD and Solaris) offer a choice between blocking and getting an error; in these cases, we always choose to block.\nOn Linux (when the `getrandom` system call is not available), reading from `/dev/urandom` never blocks, even when the OS hasn\u2019t collected enough entropy yet. To avoid returning low-entropy bytes, we first poll `/dev/random` and only switch to `/dev/urandom` once this has succeeded.\nOn OpenBSD, this kind of entropy accounting isn\u2019t available, and on NetBSD, blocking on it is discouraged. On these platforms, nonblocking interfaces are used, even when reliable entropy may not be available. On the platforms where it is used, the reliability of entropy accounting itself isn\u2019t free from controversy. This library provides randomness sourced according to the platform\u2019s best practices, but each platform has its own limits on the grade of randomness it can promise in environments with few sources of entropy.\nOn ESP-IDF, if `esp_fill_random` is used before enabling WiFi, BT, or the voltage noise entropy source (SAR ADC), the Hardware RNG will only be seeded via RC_FAST_CLK. This can occur during early boot unless `bootloader_random_enable()` is called. For more information see the ESP-IDF RNG Docs\u27e855\u27e9 or the RNG section of the ESP32 Technical Reference Manual\u27e856\u27e9.\n### \u00a7\u27e857\u27e9Error handling\nWe always prioritize failure over returning known insecure \u201crandom\u201d bytes. Generally, on supported platforms, failure is highly unlikely, though not impossible. If an error does occur, it is likely that it will occur on every call to `getrandom`. Therefore, after the first successful call, one can be reasonably confident that no errors will occur.\n### \u00a7\u27e858\u27e9Panic handling\nWe strive to eliminate all potential panics from our backend implementations. In other words, when compiled with optimizations enabled, the generated binary code for `getrandom` functions should not contain any panic branches. Even if the platform misbehaves and returns an unexpected result, our code should correctly handle it and return an error, e.g. `Error::UNEXPECTED`\u27e859\u27e9.\n### \u00a7\u27e860\u27e9Sanitizer support\nIf your code uses `fill_uninit`\u27e861\u27e9 and you enable MemorySanitizer\u27e862\u27e9 (i.e. `-Zsanitizer=memory`), we will automatically handle unpoisoning of the destination buffer filled by `fill_uninit`.\nYou can run sanitizer tests for your crate dependent on `getrandom` like this:\n```\nRUSTFLAGS=\"-Zsanitizer=memory\" cargo test -Zbuild-std --target=x86_64-unknown-linux-gnu\n```\n\n### \u00a7\u27e863\u27e9Minimum Supported Rust Version\nThis crate requires Rust 1.63 or later.\n### \u00a7\u27e864\u27e9License\nThe `getrandom` library is distributed under either of\n  * Apache License, Version 2.0\u27e865\u27e9\n  * MIT license\u27e866\u27e9\n\n\nat your option.\n#### \u00a7\u27e867\u27e9Contribution\nUnless you explicitly state otherwise, any contribution intentionally submitted for inclusion in the work by you, as defined in the Apache-2.0 license, shall be dual licensed as above, without any additional terms or conditions.\n## Structs\u00a7\u27e868\u27e9\n\nError\u27e869\u27e9\n    A small and `no_std` compatible error type\n## Functions\u00a7\u27e870\u27e9\n\nfill\u27e871\u27e9\n    Fill `dest` with random bytes from the system\u2019s preferred random number source.\n\nfill_uninit\u27e861\u27e9\n    Fill potentially uninitialized buffer `dest` with random bytes from the system\u2019s preferred random number source and return a mutable reference to those bytes.\n\nu32\u27e872\u27e9\n    Get random `u32` from the system\u2019s preferred random number source.\n\nu64\u27e873\u27e9\n    Get random `u64` from the system\u2019s preferred random number source.\n",
            "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/getrandom/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/getrandom/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/getrandom/latest/src/getrandom/lib.rs.html#2-143: Source\n\u27e84\u27e9 https://docs.rs/getrandom/latest/getrandom/#getrandom-systems-random-number-generator: \u00a7\n\u27e85\u27e9 https://github.com/rust-random/getrandom/actions/workflows/tests.yml/badge.svg?branch=master: ![Build Status\n\u27e86\u27e9 https://img.shields.io/crates/v/getrandom: ![Crate\n\u27e87\u27e9 https://docs.rs/getrandom/badge.svg: ![Documentation\n\u27e88\u27e9 https://deps.rs/repo/github/rust-random/getrandom/status.svg: ![Dependency Status\n\u27e89\u27e9 https://img.shields.io/crates/d/getrandom: ![Downloads\n\u27e810\u27e9 https://img.shields.io/crates/l/getrandom: ![License\n\u27e811\u27e9 https://crates.io/crates/rand: `rand`\n\u27e812\u27e9 https://docs.rs/getrandom/latest/getrandom/#usage: \u00a7\n\u27e813\u27e9 https://docs.rs/getrandom/latest/getrandom/#supported-targets: \u00a7\n\u27e814\u27e9 https://manned.org/getrandom.2: `getrandom`\n\u27e815\u27e9 https://manned.org/urandom.4: `/dev/urandom`\n\u27e816\u27e9 https://learn.microsoft.com/en-us/windows/win32/seccng/processprng: `ProcessPrng`\n\u27e817\u27e9 https://learn.microsoft.com/en-us/windows/win32/api/ntsecapi/nf-ntsecapi-rtlgenrandom: `RtlGenRandom`\n\u27e818\u27e9 https://www.unix.com/man-page/mojave/2/getentropy/: `getentropy`\n\u27e819\u27e9 https://opensource.apple.com/source/CommonCrypto/CommonCrypto-60074/include/CommonRandom.h.auto.html: `CCRandomGenerateBytes`\n\u27e820\u27e9 https://www.freebsd.org/cgi/man.cgi?query=getrandom&manpath=FreeBSD+12.0-stable: `getrandom`\n\u27e821\u27e9 https://man.openbsd.org/getentropy.2: `getentropy`\n\u27e822\u27e9 https://man.netbsd.org/getrandom.2: `getrandom`\n\u27e823\u27e9 https://man.netbsd.org/sysctl.7: `kern.arandom`\n\u27e824\u27e9 https://leaf.dragonflybsd.org/cgi/web-man?command=getrandom: `getrandom`\n\u27e825\u27e9 https://docs.oracle.com/cd/E88353_01/html/E37841/getrandom-2.html: `getrandom`\n\u27e826\u27e9 https://illumos.org/man/2/getrandom: `getrandom`\n\u27e827\u27e9 https://fuchsia.dev/fuchsia-src/zircon/syscalls/cprng_draw: `cprng_draw`\n\u27e828\u27e9 https://github.com/hermit-os/kernel/blob/315f58ff5efc81d9bf0618af85a59963ff55f8b1/src/syscalls/entropy.rs#L47-L55: `sys_read_entropy`\n\u27e829\u27e9 https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-getrandom: `getrandom`\n\u27e830\u27e9 https://software.intel.com/en-us/articles/intel-digital-random-number-generator-drng-software-implementation-guide: `RDRAND`\n\u27e831\u27e9 https://github.com/emscripten-core/emscripten/pull/12240: `getentropy`\n\u27e832\u27e9 https://github.com/WebAssembly/WASI/blob/snapshot-01/phases/snapshot/docs.md#-random_getbuf-pointeru8-buf_len-size---errno: `random_get`\n\u27e833\u27e9 https://github.com/WebAssembly/WASI/blob/v0.2.1/wasip2/random/random.wit#L23-L28: `get-random-u64`\n\u27e834\u27e9 https://github.com/rust3ds/shim-3ds/commit/b01d2568836dea2a65d05d662f8e5f805c64389d: `getrandom`\n\u27e835\u27e9 https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-reference/system/random.html#functions: `esp_fill_random`\n\u27e836\u27e9 https://github.com/vitasdk/newlib/blob/2d869fe47aaf02b8e52d04e9a2b79d5b210fd016/newlib/libc/sys/vita/getentropy.c: `getentropy`\n\u27e837\u27e9 https://www.qnx.com/developers/docs/7.1/index.html#com.qnx.doc.neutrino.utilities/topic/r/random.html: `/dev/urandom`\n\u27e838\u27e9 https://www.ibm.com/docs/en/aix/7.3?topic=files-random-urandom-devices: `/dev/urandom`\n\u27e839\u27e9 https://github.com/cygwin/cygwin/blob/main/winsup/cygwin/libc/getentropy.cc: `getrandom`\n\u27e840\u27e9 https://docs.rs/getrandom/latest/getrandom/#opt-in-backends: \u00a7\n\u27e841\u27e9 https://developer.arm.com/documentation/ddi0601/2024-06/AArch64-Registers/RNDR--Random-Number: `RNDR`\n\u27e842\u27e9 https://www.w3.org/TR/WebCryptoAPI/#Crypto-method-getRandomValues: `Crypto.getRandomValues`\n\u27e843\u27e9 https://docs.rs/getrandom/latest/getrandom/#webassembly-support: see below\n\u27e844\u27e9 https://uefi.org/specs/UEFI/2.10/37_Secure_Technologies.html#efi-rng-protocol: `EFI_RNG_PROTOCOL`\n\u27e845\u27e9 https://docs.rs/getrandom/latest/getrandom/#custom-backend: custom backend\n\u27e846\u27e9 https://doc.rust-lang.org/cargo/reference/config.html: `.cargo/config.toml`\n\u27e847\u27e9 https://docs.rs/getrandom/latest/getrandom/#raw-linux-syscall-support: \u00a7\n\u27e848\u27e9 https://github.com/WebAssembly/WASI: WASI\n\u27e849\u27e9 https://emscripten.org: Emscripten\n\u27e850\u27e9 https://github.com/rustwasm/wasm-bindgen: `wasm-bindgen`\n\u27e851\u27e9 https://docs.rs/getrandom/latest/getrandom/#platform-support: \u00a7\n\u27e852\u27e9 https://docs.rs/getrandom/latest/getrandom/#devurandom-fallback-on-linux-and-android: \u00a7\n\u27e853\u27e9 https://doc.rust-lang.org/stable/rustc/platform-support.html: require\n\u27e854\u27e9 https://docs.rs/getrandom/latest/getrandom/#early-boot: \u00a7\n\u27e855\u27e9 https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-reference/system/random.html: ESP-IDF RNG Docs\n\u27e856\u27e9 https://www.espressif.com/sites/default/files/documentation/esp32_technical_reference_manual_en.pdf#rng: RNG section of the ESP32 Technical Reference Manual\n\u27e857\u27e9 https://docs.rs/getrandom/latest/getrandom/#error-handling: \u00a7\n\u27e858\u27e9 https://docs.rs/getrandom/latest/getrandom/#panic-handling: \u00a7\n\u27e859\u27e9 https://docs.rs/getrandom/latest/getrandom/struct.Error.html#associatedconstant.UNEXPECTED: associated constant getrandom::Error::UNEXPECTED - `Error::UNEXPECTED`\n\u27e860\u27e9 https://docs.rs/getrandom/latest/getrandom/#sanitizer-support: \u00a7\n\u27e861\u27e9 https://docs.rs/getrandom/latest/getrandom/fn.fill_uninit.html: fn getrandom::fill_uninit - `fill_uninit`\n\u27e862\u27e9 https://doc.rust-lang.org/beta/unstable-book/compiler-flags/sanitizer.html#memorysanitizer: MemorySanitizer\n\u27e863\u27e9 https://docs.rs/getrandom/latest/getrandom/#minimum-supported-rust-version: \u00a7\n\u27e864\u27e9 https://docs.rs/getrandom/latest/getrandom/#license: \u00a7\n\u27e865\u27e9 https://github.com/rust-random/getrandom/blob/master/LICENSE-APACHE: Apache License, Version 2.0\n\u27e866\u27e9 https://github.com/rust-random/getrandom/blob/master/LICENSE-MIT: MIT license\n\u27e867\u27e9 https://docs.rs/getrandom/latest/getrandom/#contribution: \u00a7\n\u27e868\u27e9 https://docs.rs/getrandom/latest/getrandom/#structs: \u00a7\n\u27e869\u27e9 https://docs.rs/getrandom/latest/getrandom/struct.Error.html: struct getrandom::Error - Error\n\u27e870\u27e9 https://docs.rs/getrandom/latest/getrandom/#functions: \u00a7\n\u27e871\u27e9 https://docs.rs/getrandom/latest/getrandom/fn.fill.html: fn getrandom::fill - fill\n\u27e872\u27e9 https://docs.rs/getrandom/latest/getrandom/fn.u32.html: fn getrandom::u32 - u32\n\u27e873\u27e9 https://docs.rs/getrandom/latest/getrandom/fn.u64.html: fn getrandom::u64 - u64\n",
            "fit_markdown": "",
            "fit_html": ""
          },
          "downloads": 0,
          "github_stars": 0,
          "dependencies": [],
          "features": {},
          "code_snippets": [],
          "readme_sections": {},
          "librs_downloads": null,
          "source": "crates.io",
          "enhanced_scraping": {},
          "enhanced_features": [],
          "enhanced_dependencies": []
        },
        "enriched_crate": {
          "name": "getrandom",
          "version": "0.3.3",
          "description": "ALLOW: Positive community sentiment",
          "repository": "",
          "keywords": [],
          "categories": [],
          "readme": {
            "raw_markdown": "[](https://docs.rs/getrandom/latest/getrandom/all.html \"show sidebar\")\n# Crate getrandomCopy item path\n[Settings](https://docs.rs/getrandom/latest/settings.html)\n[Help](https://docs.rs/getrandom/latest/help.html)\nSummary[Source](https://docs.rs/getrandom/latest/src/getrandom/lib.rs.html#2-143)\nExpand description\n## [\u00a7](https://docs.rs/getrandom/latest/getrandom/#getrandom-systems-random-number-generator)getrandom: system\u2019s random number generator\n[![Build Status](https://github.com/rust-random/getrandom/actions/workflows/tests.yml/badge.svg?branch=master)](https://github.com/rust-random/getrandom/actions?query=branch:master) [![Crate](https://img.shields.io/crates/v/getrandom)](https://crates.io/crates/getrandom) [![Documentation](https://docs.rs/getrandom/badge.svg)](https://docs.rs/getrandom) [![Dependency Status](https://deps.rs/repo/github/rust-random/getrandom/status.svg)](https://deps.rs/repo/github/rust-random/getrandom) [![Downloads](https://img.shields.io/crates/d/getrandom)](https://crates.io/crates/getrandom) [![License](https://img.shields.io/crates/l/getrandom)](https://github.com/rust-random/getrandom/blob/master/LICENSE-MIT)\n`getrandom` is a Rust library for retrieving random data from (operating) system sources.\nIt is assumed that the system always provides high-quality, cryptographically secure random data, ideally backed by hardware entropy sources. This crate derives its name from the Linux `getrandom` syscall but is cross-platform, roughly supporting the same set of platforms as Rust\u2019s `std` library.\nThis is a low-level API. Most users should prefer using a higher-level random-number library like [`rand`](https://crates.io/crates/rand).\n### [\u00a7](https://docs.rs/getrandom/latest/getrandom/#usage)Usage\nAdd the `getrandom` dependency to your `Cargo.toml` file:\n```\n[dependencies]\ngetrandom = \"0.3\"\n```\n\nThen invoke the `fill` function on a byte buffer to fill it with random data:\n```\nfn get_random_u128() -> Result<u128, getrandom::Error> {\n  let mut buf = [0u8; 16];\n  getrandom::fill(&mut buf)?;\n  Ok(u128::from_ne_bytes(buf))\n}\n```\n\n### [\u00a7](https://docs.rs/getrandom/latest/getrandom/#supported-targets)Supported targets\nTarget| Target Triple| Implementation  \n---|---|---  \nLinux, Android| `*\u2011linux\u2011*`| [`getrandom`](https://manned.org/getrandom.2) system call if available, otherwise [`/dev/urandom`](https://manned.org/urandom.4) after successfully polling `/dev/random`  \nWindows 10+| `*\u2011windows\u2011*`| [`ProcessPrng`](https://learn.microsoft.com/en-us/windows/win32/seccng/processprng) on Rust 1.78+, [`RtlGenRandom`](https://learn.microsoft.com/en-us/windows/win32/api/ntsecapi/nf-ntsecapi-rtlgenrandom) otherwise  \nWindows 7, 8| `*-win7\u2011windows\u2011*`| [`RtlGenRandom`](https://learn.microsoft.com/en-us/windows/win32/api/ntsecapi/nf-ntsecapi-rtlgenrandom)  \nmacOS| `*\u2011apple\u2011darwin`| [`getentropy`](https://www.unix.com/man-page/mojave/2/getentropy/)  \niOS, tvOS, watchOS| `*\u2011apple\u2011{ios,tvos,watchos}`| [`CCRandomGenerateBytes`](https://opensource.apple.com/source/CommonCrypto/CommonCrypto-60074/include/CommonRandom.h.auto.html)  \nFreeBSD| `*\u2011freebsd`| [`getrandom`](https://www.freebsd.org/cgi/man.cgi?query=getrandom&manpath=FreeBSD+12.0-stable)  \nOpenBSD| `*\u2011openbsd`| [`getentropy`](https://man.openbsd.org/getentropy.2)  \nNetBSD| `*\u2011netbsd`| [`getrandom`](https://man.netbsd.org/getrandom.2) if available, otherwise [`kern.arandom`](https://man.netbsd.org/sysctl.7)  \nDragonfly BSD| `*\u2011dragonfly`| [`getrandom`](https://leaf.dragonflybsd.org/cgi/web-man?command=getrandom)  \nSolaris| `*\u2011solaris`| [`getrandom`](https://docs.oracle.com/cd/E88353_01/html/E37841/getrandom-2.html) with `GRND_RANDOM`  \nillumos| `*\u2011illumos`| [`getrandom`](https://illumos.org/man/2/getrandom)  \nFuchsia OS| `*\u2011fuchsia`| [`cprng_draw`](https://fuchsia.dev/fuchsia-src/zircon/syscalls/cprng_draw)  \nRedox| `*\u2011redox`| `/dev/urandom`  \nHaiku| `*\u2011haiku`| `/dev/urandom` (identical to `/dev/random`)  \nHermit| `*-hermit`| [`sys_read_entropy`](https://github.com/hermit-os/kernel/blob/315f58ff5efc81d9bf0618af85a59963ff55f8b1/src/syscalls/entropy.rs#L47-L55)  \nHurd| `*-hurd-*`| [`getrandom`](https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-getrandom)  \nSGX| `x86_64\u2011*\u2011sgx`| [`RDRAND`](https://software.intel.com/en-us/articles/intel-digital-random-number-generator-drng-software-implementation-guide)  \nVxWorks| `*\u2011wrs\u2011vxworks\u2011*`| `randABytes` after checking entropy pool initialization with `randSecure`  \nEmscripten| `*\u2011emscripten`| [`getentropy`](https://github.com/emscripten-core/emscripten/pull/12240)  \nWASI 0.1| `wasm32\u2011wasip1`| [`random_get`](https://github.com/WebAssembly/WASI/blob/snapshot-01/phases/snapshot/docs.md#-random_getbuf-pointeru8-buf_len-size---errno)  \nWASI 0.2| `wasm32\u2011wasip2`| [`get-random-u64`](https://github.com/WebAssembly/WASI/blob/v0.2.1/wasip2/random/random.wit#L23-L28)  \nSOLID| `*-kmc-solid_*`| `SOLID_RNG_SampleRandomBytes`  \nNintendo 3DS| `*-nintendo-3ds`| [`getrandom`](https://github.com/rust3ds/shim-3ds/commit/b01d2568836dea2a65d05d662f8e5f805c64389d)  \nESP-IDF| `*\u2011espidf`| [`esp_fill_random`](https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-reference/system/random.html#functions) WARNING: see \u201cEarly Boot\u201d section below  \nPS Vita| `*-vita-*`| [`getentropy`](https://github.com/vitasdk/newlib/blob/2d869fe47aaf02b8e52d04e9a2b79d5b210fd016/newlib/libc/sys/vita/getentropy.c)  \nQNX Neutrino| `*\u2011nto-qnx*`| [`/dev/urandom`](https://www.qnx.com/developers/docs/7.1/index.html#com.qnx.doc.neutrino.utilities/topic/r/random.html) (identical to `/dev/random`)  \nAIX| `*-ibm-aix`| [`/dev/urandom`](https://www.ibm.com/docs/en/aix/7.3?topic=files-random-urandom-devices)  \nCygwin| `*-cygwin`| [`getrandom`](https://github.com/cygwin/cygwin/blob/main/winsup/cygwin/libc/getentropy.cc) (based on [`RtlGenRandom`](https://learn.microsoft.com/en-us/windows/win32/api/ntsecapi/nf-ntsecapi-rtlgenrandom))  \nPull Requests that add support for new targets to `getrandom` are always welcome.\n#### [\u00a7](https://docs.rs/getrandom/latest/getrandom/#opt-in-backends)Opt-in backends\n`getrandom` also provides optional (opt-in) backends, which allow users to customize the source of randomness based on their specific needs:\nBackend name| Target| Target Triple| Implementation  \n---|---|---|---  \n`linux_getrandom`| Linux, Android| `*\u2011linux\u2011*`| [`getrandom`](https://manned.org/getrandom.2) system call (without `/dev/urandom` fallback). Bumps minimum supported Linux kernel version to 3.17 and Android API level to 23 (Marshmallow).  \n`linux_raw`| Linux, Android| `*\u2011linux\u2011*`| Same as `linux_getrandom`, but uses raw `asm!`-based syscalls instead of `libc`.  \n`rdrand`| x86, x86-64| `x86_64-*`, `i686-*`| [`RDRAND`](https://software.intel.com/en-us/articles/intel-digital-random-number-generator-drng-software-implementation-guide) instruction  \n`rndr`| AArch64| `aarch64-*`| [`RNDR`](https://developer.arm.com/documentation/ddi0601/2024-06/AArch64-Registers/RNDR--Random-Number) register  \n`wasm_js`| Web Browser, Node.js| `wasm32\u2011unknown\u2011unknown`, `wasm32v1-none`| [`Crypto.getRandomValues`](https://www.w3.org/TR/WebCryptoAPI/#Crypto-method-getRandomValues). Requires feature `wasm_js` ([see below](https://docs.rs/getrandom/latest/getrandom/#webassembly-support)).  \n`efi_rng`| UEFI| `*-unknown\u2011uefi`| [`EFI_RNG_PROTOCOL`](https://uefi.org/specs/UEFI/2.10/37_Secure_Technologies.html#efi-rng-protocol) with `EFI_RNG_ALGORITHM_RAW` (requires `std` and Nigthly compiler)  \n`custom`| All targets| `*`| User-provided custom implementation (see [custom backend](https://docs.rs/getrandom/latest/getrandom/#custom-backend))  \nOpt-in backends can be enabled using the `getrandom_backend` configuration flag. The flag can be set either by specifying the `rustflags` field in [`.cargo/config.toml`](https://doc.rust-lang.org/cargo/reference/config.html):\n```\n# It's recommended to set the flag on a per-target basis:\n[target.wasm32-unknown-unknown]\nrustflags = ['--cfg', 'getrandom_backend=\"wasm_js\"']\n```\n\nOr by using the `RUSTFLAGS` environment variable:\n```\nRUSTFLAGS='--cfg getrandom_backend=\"linux_getrandom\"' cargo build\n```\n\nEnabling an opt-in backend will replace the backend used by default. Doing this for an incorrect target (e.g. using `linux_getrandom` while compiling for a Windows target) will result in a compilation error. Be extremely careful while using opt-in backends, as incorrect configuration may result in vulnerable applications or applications that always panic.\nNote that using an opt-in backend in a library (e.g. for tests or benchmarks) WILL NOT have any effect on its downstream users.\n#### [\u00a7](https://docs.rs/getrandom/latest/getrandom/#raw-linux-syscall-support)Raw Linux syscall support\nCurrently the `linux_raw` backend supports only targets with stabilized `asm!` macro, i.e. `arm`, `aarch64`, `loongarch64`, `riscv32`, `riscv64`, `s390x`, `x86`, and `x86_64`.\nNote that the raw syscall backend may be slower than backends based on `libc::getrandom`, e.g. it does not implement vDSO optimizations and on `x86` it uses the infamously slow `int 0x80` instruction to perform syscall.\n#### [\u00a7](https://docs.rs/getrandom/latest/getrandom/#webassembly-support)WebAssembly support\nThis crate fully supports the [WASI](https://github.com/WebAssembly/WASI) and [Emscripten](https://emscripten.org) targets. However, the `wasm32-unknown-unknown` target (i.e. the target used by `wasm-pack`) is not automatically supported since, from the target name alone, we cannot deduce which JavaScript interface should be used (or if JavaScript is available at all).\nTo enable `getrandom`\u2019s functionality on `wasm32-unknown-unknown` using the Web Crypto methods [described above](https://docs.rs/getrandom/latest/getrandom/#opt-in-backends) via [`wasm-bindgen`](https://github.com/rustwasm/wasm-bindgen), do _both_ of the following:\n  * Use the `wasm_js` feature flag, i.e. `getrandom = { version = \"0.3\", features = [\"wasm_js\"] }`. On its own, this only makes the backend available. (As a side effect this will make your `Cargo.lock` significantly larger if you are not already using [`wasm-bindgen`](https://github.com/rustwasm/wasm-bindgen), but otherwise enabling this feature is harmless.)\n  * Set `RUSTFLAGS='--cfg getrandom_backend=\"wasm_js\"'` ([see above](https://docs.rs/getrandom/latest/getrandom/#opt-in-backends)).\n\n\nThis backend supports both web browsers (main window and Web Workers) and Node.js (v19 or later) environments.\nWARNING: It is highly recommended to enable the `wasm_js` feature only for binary crates and tests, i.e. avoid unconditionally enabling it in library crates.\n#### [\u00a7](https://docs.rs/getrandom/latest/getrandom/#custom-backend)Custom backend\nIf this crate does not support your target out of the box or you have to use a non-default entropy source, then you can provide a custom implementation. You need to enable the custom backend as described in the [opt-in backends](https://docs.rs/getrandom/latest/getrandom/#opt-in-backends) section.\nNext, you need to define an `extern` function with the following signature:\n```\nuse getrandom::Error;\n#[no_mangle]\nunsafe extern \"Rust\" fn __getrandom_v03_custom(\n  dest: *mut u8,\n  len: usize,\n) -> Result<(), Error> {\n  todo!()\n}\n```\n\nThis function should, ideally, be defined in the root crate of your project, e.g. in your `main.rs`. This function MUST be defined only once for your project, i.e. upstream library crates SHOULD NOT define it outside of tests and benchmarks. Improper configuration of this backend may result in linking errors.\nThe function accepts a pointer to a buffer that should be filled with random data and its length in bytes. Note that the buffer MAY be uninitialized. On success, the function should return `Ok(())` and fully fill the input buffer; otherwise, it should return an error value.\nWhile wrapping functions which work with byte slices you should fully initialize the buffer before passing it to the function:\n```\nuse getrandom::Error;\nfn my_entropy_source(buf: &mut [u8]) -> Result<(), getrandom::Error> {\n  // ...\n  Ok(())\n}\n#[no_mangle]\nunsafe extern \"Rust\" fn __getrandom_v03_custom(\n  dest: *mut u8,\n  len: usize,\n) -> Result<(), Error> {\n  let buf = unsafe {\n    // fill the buffer with zeros\n    core::ptr::write_bytes(dest, 0, len);\n    // create mutable byte slice\n    core::slice::from_raw_parts_mut(dest, len)\n  };\n  my_entropy_source(buf)\n}\n```\n\nIf you are confident that `getrandom` is not used in your project, but it gets pulled nevertheless by one of your dependencies, then you can use the following custom backend, which always returns the \u201cunsupported\u201d error:\n```\nuse getrandom::Error;\n#[no_mangle]\nunsafe extern \"Rust\" fn __getrandom_v03_custom(\n  dest: *mut u8,\n  len: usize,\n) -> Result<(), Error> {\n  Err(Error::UNSUPPORTED)\n}\n```\n\n#### [\u00a7](https://docs.rs/getrandom/latest/getrandom/#platform-support)Platform Support\nThis crate generally supports the same operating system and platform versions that the Rust standard library does. Additional targets may be supported using the opt-in custom backend.\nThis means that as Rust drops support for old versions of operating systems (such as old Linux kernel versions, Android API levels, etc.) in stable releases, `getrandom` may create new patch releases that remove support for outdated platform versions.\n#### [\u00a7](https://docs.rs/getrandom/latest/getrandom/#devurandom-fallback-on-linux-and-android)`/dev/urandom` fallback on Linux and Android\nOn Linux targets, the `/dev/urandom` fallback is present only if either `target_env` is `musl`, or `target_arch` is one of the following: `aarch64`, `arm`, `powerpc`, `powerpc64`, `s390x`, `x86`, `x86_64`. Other supported targets [require](https://doc.rust-lang.org/stable/rustc/platform-support.html) kernel versions that support the `getrandom` system call, so the fallback is not needed.\nOn Android targets the fallback is present only for the following `target_arch`es: `aarch64`, `arm`, `x86`, `x86_64`. Other `target_arch`es (e.g. RISC-V) require sufficiently high API levels.\nThe fallback can be disabled by enabling the `linux_getrandom` opt-in backend. Note that doing so will bump minimum supported Linux kernel version to 3.17 and Android API level to 23 (Marshmallow).\n#### [\u00a7](https://docs.rs/getrandom/latest/getrandom/#early-boot)Early boot\nSometimes, early in the boot process, the OS has not collected enough entropy to securely seed its RNG. This is especially common on virtual machines, where standard \u201crandom\u201d events are hard to come by.\nSome operating system interfaces always block until the RNG is securely seeded. This can take anywhere from a few seconds to more than a minute. A few (Linux, NetBSD and Solaris) offer a choice between blocking and getting an error; in these cases, we always choose to block.\nOn Linux (when the `getrandom` system call is not available), reading from `/dev/urandom` never blocks, even when the OS hasn\u2019t collected enough entropy yet. To avoid returning low-entropy bytes, we first poll `/dev/random` and only switch to `/dev/urandom` once this has succeeded.\nOn OpenBSD, this kind of entropy accounting isn\u2019t available, and on NetBSD, blocking on it is discouraged. On these platforms, nonblocking interfaces are used, even when reliable entropy may not be available. On the platforms where it is used, the reliability of entropy accounting itself isn\u2019t free from controversy. This library provides randomness sourced according to the platform\u2019s best practices, but each platform has its own limits on the grade of randomness it can promise in environments with few sources of entropy.\nOn ESP-IDF, if `esp_fill_random` is used before enabling WiFi, BT, or the voltage noise entropy source (SAR ADC), the Hardware RNG will only be seeded via RC_FAST_CLK. This can occur during early boot unless `bootloader_random_enable()` is called. For more information see the [ESP-IDF RNG Docs](https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-reference/system/random.html) or the [RNG section of the ESP32 Technical Reference Manual](https://www.espressif.com/sites/default/files/documentation/esp32_technical_reference_manual_en.pdf#rng).\n### [\u00a7](https://docs.rs/getrandom/latest/getrandom/#error-handling)Error handling\nWe always prioritize failure over returning known insecure \u201crandom\u201d bytes. Generally, on supported platforms, failure is highly unlikely, though not impossible. If an error does occur, it is likely that it will occur on every call to `getrandom`. Therefore, after the first successful call, one can be reasonably confident that no errors will occur.\n### [\u00a7](https://docs.rs/getrandom/latest/getrandom/#panic-handling)Panic handling\nWe strive to eliminate all potential panics from our backend implementations. In other words, when compiled with optimizations enabled, the generated binary code for `getrandom` functions should not contain any panic branches. Even if the platform misbehaves and returns an unexpected result, our code should correctly handle it and return an error, e.g. [`Error::UNEXPECTED`](https://docs.rs/getrandom/latest/getrandom/struct.Error.html#associatedconstant.UNEXPECTED \"associated constant getrandom::Error::UNEXPECTED\").\n### [\u00a7](https://docs.rs/getrandom/latest/getrandom/#sanitizer-support)Sanitizer support\nIf your code uses [`fill_uninit`](https://docs.rs/getrandom/latest/getrandom/fn.fill_uninit.html \"fn getrandom::fill_uninit\") and you enable [MemorySanitizer](https://doc.rust-lang.org/beta/unstable-book/compiler-flags/sanitizer.html#memorysanitizer) (i.e. `-Zsanitizer=memory`), we will automatically handle unpoisoning of the destination buffer filled by `fill_uninit`.\nYou can run sanitizer tests for your crate dependent on `getrandom` like this:\n```\nRUSTFLAGS=\"-Zsanitizer=memory\" cargo test -Zbuild-std --target=x86_64-unknown-linux-gnu\n```\n\n### [\u00a7](https://docs.rs/getrandom/latest/getrandom/#minimum-supported-rust-version)Minimum Supported Rust Version\nThis crate requires Rust 1.63 or later.\n### [\u00a7](https://docs.rs/getrandom/latest/getrandom/#license)License\nThe `getrandom` library is distributed under either of\n  * [Apache License, Version 2.0](https://github.com/rust-random/getrandom/blob/master/LICENSE-APACHE)\n  * [MIT license](https://github.com/rust-random/getrandom/blob/master/LICENSE-MIT)\n\n\nat your option.\n#### [\u00a7](https://docs.rs/getrandom/latest/getrandom/#contribution)Contribution\nUnless you explicitly state otherwise, any contribution intentionally submitted for inclusion in the work by you, as defined in the Apache-2.0 license, shall be dual licensed as above, without any additional terms or conditions.\n## Structs[\u00a7](https://docs.rs/getrandom/latest/getrandom/#structs)\n\n[Error](https://docs.rs/getrandom/latest/getrandom/struct.Error.html \"struct getrandom::Error\")\n    A small and `no_std` compatible error type\n## Functions[\u00a7](https://docs.rs/getrandom/latest/getrandom/#functions)\n\n[fill](https://docs.rs/getrandom/latest/getrandom/fn.fill.html \"fn getrandom::fill\")\n    Fill `dest` with random bytes from the system\u2019s preferred random number source.\n\n[fill_uninit](https://docs.rs/getrandom/latest/getrandom/fn.fill_uninit.html \"fn getrandom::fill_uninit\")\n    Fill potentially uninitialized buffer `dest` with random bytes from the system\u2019s preferred random number source and return a mutable reference to those bytes.\n\n[u32](https://docs.rs/getrandom/latest/getrandom/fn.u32.html \"fn getrandom::u32\")\n    Get random `u32` from the system\u2019s preferred random number source.\n\n[u64](https://docs.rs/getrandom/latest/getrandom/fn.u64.html \"fn getrandom::u64\")\n    Get random `u64` from the system\u2019s preferred random number source.\n",
            "markdown_with_citations": "[](https://docs.rs/getrandom/latest/getrandom/all.html \"show sidebar\")\n# Crate getrandomCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\n## \u00a7\u27e84\u27e9getrandom: system\u2019s random number generator\n![Build Status\u27e85\u27e9](https://github.com/rust-random/getrandom/actions?query=branch:master) ![Crate\u27e86\u27e9](https://crates.io/crates/getrandom) ![Documentation\u27e87\u27e9](https://docs.rs/getrandom) ![Dependency Status\u27e88\u27e9](https://deps.rs/repo/github/rust-random/getrandom) ![Downloads\u27e89\u27e9](https://crates.io/crates/getrandom) ![License\u27e810\u27e9](https://github.com/rust-random/getrandom/blob/master/LICENSE-MIT)\n`getrandom` is a Rust library for retrieving random data from (operating) system sources.\nIt is assumed that the system always provides high-quality, cryptographically secure random data, ideally backed by hardware entropy sources. This crate derives its name from the Linux `getrandom` syscall but is cross-platform, roughly supporting the same set of platforms as Rust\u2019s `std` library.\nThis is a low-level API. Most users should prefer using a higher-level random-number library like `rand`\u27e811\u27e9.\n### \u00a7\u27e812\u27e9Usage\nAdd the `getrandom` dependency to your `Cargo.toml` file:\n```\n[dependencies]\ngetrandom = \"0.3\"\n```\n\nThen invoke the `fill` function on a byte buffer to fill it with random data:\n```\nfn get_random_u128() -> Result<u128, getrandom::Error> {\n  let mut buf = [0u8; 16];\n  getrandom::fill(&mut buf)?;\n  Ok(u128::from_ne_bytes(buf))\n}\n```\n\n### \u00a7\u27e813\u27e9Supported targets\nTarget| Target Triple| Implementation  \n---|---|---  \nLinux, Android| `*\u2011linux\u2011*`| `getrandom`\u27e814\u27e9 system call if available, otherwise `/dev/urandom`\u27e815\u27e9 after successfully polling `/dev/random`  \nWindows 10+| `*\u2011windows\u2011*`| `ProcessPrng`\u27e816\u27e9 on Rust 1.78+, `RtlGenRandom`\u27e817\u27e9 otherwise  \nWindows 7, 8| `*-win7\u2011windows\u2011*`| `RtlGenRandom`\u27e817\u27e9  \nmacOS| `*\u2011apple\u2011darwin`| `getentropy`\u27e818\u27e9  \niOS, tvOS, watchOS| `*\u2011apple\u2011{ios,tvos,watchos}`| `CCRandomGenerateBytes`\u27e819\u27e9  \nFreeBSD| `*\u2011freebsd`| `getrandom`\u27e820\u27e9  \nOpenBSD| `*\u2011openbsd`| `getentropy`\u27e821\u27e9  \nNetBSD| `*\u2011netbsd`| `getrandom`\u27e822\u27e9 if available, otherwise `kern.arandom`\u27e823\u27e9  \nDragonfly BSD| `*\u2011dragonfly`| `getrandom`\u27e824\u27e9  \nSolaris| `*\u2011solaris`| `getrandom`\u27e825\u27e9 with `GRND_RANDOM`  \nillumos| `*\u2011illumos`| `getrandom`\u27e826\u27e9  \nFuchsia OS| `*\u2011fuchsia`| `cprng_draw`\u27e827\u27e9  \nRedox| `*\u2011redox`| `/dev/urandom`  \nHaiku| `*\u2011haiku`| `/dev/urandom` (identical to `/dev/random`)  \nHermit| `*-hermit`| `sys_read_entropy`\u27e828\u27e9  \nHurd| `*-hurd-*`| `getrandom`\u27e829\u27e9  \nSGX| `x86_64\u2011*\u2011sgx`| `RDRAND`\u27e830\u27e9  \nVxWorks| `*\u2011wrs\u2011vxworks\u2011*`| `randABytes` after checking entropy pool initialization with `randSecure`  \nEmscripten| `*\u2011emscripten`| `getentropy`\u27e831\u27e9  \nWASI 0.1| `wasm32\u2011wasip1`| `random_get`\u27e832\u27e9  \nWASI 0.2| `wasm32\u2011wasip2`| `get-random-u64`\u27e833\u27e9  \nSOLID| `*-kmc-solid_*`| `SOLID_RNG_SampleRandomBytes`  \nNintendo 3DS| `*-nintendo-3ds`| `getrandom`\u27e834\u27e9  \nESP-IDF| `*\u2011espidf`| `esp_fill_random`\u27e835\u27e9 WARNING: see \u201cEarly Boot\u201d section below  \nPS Vita| `*-vita-*`| `getentropy`\u27e836\u27e9  \nQNX Neutrino| `*\u2011nto-qnx*`| `/dev/urandom`\u27e837\u27e9 (identical to `/dev/random`)  \nAIX| `*-ibm-aix`| `/dev/urandom`\u27e838\u27e9  \nCygwin| `*-cygwin`| `getrandom`\u27e839\u27e9 (based on `RtlGenRandom`\u27e817\u27e9)  \nPull Requests that add support for new targets to `getrandom` are always welcome.\n#### \u00a7\u27e840\u27e9Opt-in backends\n`getrandom` also provides optional (opt-in) backends, which allow users to customize the source of randomness based on their specific needs:\nBackend name| Target| Target Triple| Implementation  \n---|---|---|---  \n`linux_getrandom`| Linux, Android| `*\u2011linux\u2011*`| `getrandom`\u27e814\u27e9 system call (without `/dev/urandom` fallback). Bumps minimum supported Linux kernel version to 3.17 and Android API level to 23 (Marshmallow).  \n`linux_raw`| Linux, Android| `*\u2011linux\u2011*`| Same as `linux_getrandom`, but uses raw `asm!`-based syscalls instead of `libc`.  \n`rdrand`| x86, x86-64| `x86_64-*`, `i686-*`| `RDRAND`\u27e830\u27e9 instruction  \n`rndr`| AArch64| `aarch64-*`| `RNDR`\u27e841\u27e9 register  \n`wasm_js`| Web Browser, Node.js| `wasm32\u2011unknown\u2011unknown`, `wasm32v1-none`| `Crypto.getRandomValues`\u27e842\u27e9. Requires feature `wasm_js` (see below\u27e843\u27e9).  \n`efi_rng`| UEFI| `*-unknown\u2011uefi`| `EFI_RNG_PROTOCOL`\u27e844\u27e9 with `EFI_RNG_ALGORITHM_RAW` (requires `std` and Nigthly compiler)  \n`custom`| All targets| `*`| User-provided custom implementation (see custom backend\u27e845\u27e9)  \nOpt-in backends can be enabled using the `getrandom_backend` configuration flag. The flag can be set either by specifying the `rustflags` field in `.cargo/config.toml`\u27e846\u27e9:\n```\n# It's recommended to set the flag on a per-target basis:\n[target.wasm32-unknown-unknown]\nrustflags = ['--cfg', 'getrandom_backend=\"wasm_js\"']\n```\n\nOr by using the `RUSTFLAGS` environment variable:\n```\nRUSTFLAGS='--cfg getrandom_backend=\"linux_getrandom\"' cargo build\n```\n\nEnabling an opt-in backend will replace the backend used by default. Doing this for an incorrect target (e.g. using `linux_getrandom` while compiling for a Windows target) will result in a compilation error. Be extremely careful while using opt-in backends, as incorrect configuration may result in vulnerable applications or applications that always panic.\nNote that using an opt-in backend in a library (e.g. for tests or benchmarks) WILL NOT have any effect on its downstream users.\n#### \u00a7\u27e847\u27e9Raw Linux syscall support\nCurrently the `linux_raw` backend supports only targets with stabilized `asm!` macro, i.e. `arm`, `aarch64`, `loongarch64`, `riscv32`, `riscv64`, `s390x`, `x86`, and `x86_64`.\nNote that the raw syscall backend may be slower than backends based on `libc::getrandom`, e.g. it does not implement vDSO optimizations and on `x86` it uses the infamously slow `int 0x80` instruction to perform syscall.\n#### \u00a7\u27e843\u27e9WebAssembly support\nThis crate fully supports the WASI\u27e848\u27e9 and Emscripten\u27e849\u27e9 targets. However, the `wasm32-unknown-unknown` target (i.e. the target used by `wasm-pack`) is not automatically supported since, from the target name alone, we cannot deduce which JavaScript interface should be used (or if JavaScript is available at all).\nTo enable `getrandom`\u2019s functionality on `wasm32-unknown-unknown` using the Web Crypto methods described above\u27e840\u27e9 via `wasm-bindgen`\u27e850\u27e9, do _both_ of the following:\n  * Use the `wasm_js` feature flag, i.e. `getrandom = { version = \"0.3\", features = [\"wasm_js\"] }`. On its own, this only makes the backend available. (As a side effect this will make your `Cargo.lock` significantly larger if you are not already using `wasm-bindgen`\u27e850\u27e9, but otherwise enabling this feature is harmless.)\n  * Set `RUSTFLAGS='--cfg getrandom_backend=\"wasm_js\"'` (see above\u27e840\u27e9).\n\n\nThis backend supports both web browsers (main window and Web Workers) and Node.js (v19 or later) environments.\nWARNING: It is highly recommended to enable the `wasm_js` feature only for binary crates and tests, i.e. avoid unconditionally enabling it in library crates.\n#### \u00a7\u27e845\u27e9Custom backend\nIf this crate does not support your target out of the box or you have to use a non-default entropy source, then you can provide a custom implementation. You need to enable the custom backend as described in the opt-in backends\u27e840\u27e9 section.\nNext, you need to define an `extern` function with the following signature:\n```\nuse getrandom::Error;\n#[no_mangle]\nunsafe extern \"Rust\" fn __getrandom_v03_custom(\n  dest: *mut u8,\n  len: usize,\n) -> Result<(), Error> {\n  todo!()\n}\n```\n\nThis function should, ideally, be defined in the root crate of your project, e.g. in your `main.rs`. This function MUST be defined only once for your project, i.e. upstream library crates SHOULD NOT define it outside of tests and benchmarks. Improper configuration of this backend may result in linking errors.\nThe function accepts a pointer to a buffer that should be filled with random data and its length in bytes. Note that the buffer MAY be uninitialized. On success, the function should return `Ok(())` and fully fill the input buffer; otherwise, it should return an error value.\nWhile wrapping functions which work with byte slices you should fully initialize the buffer before passing it to the function:\n```\nuse getrandom::Error;\nfn my_entropy_source(buf: &mut [u8]) -> Result<(), getrandom::Error> {\n  // ...\n  Ok(())\n}\n#[no_mangle]\nunsafe extern \"Rust\" fn __getrandom_v03_custom(\n  dest: *mut u8,\n  len: usize,\n) -> Result<(), Error> {\n  let buf = unsafe {\n    // fill the buffer with zeros\n    core::ptr::write_bytes(dest, 0, len);\n    // create mutable byte slice\n    core::slice::from_raw_parts_mut(dest, len)\n  };\n  my_entropy_source(buf)\n}\n```\n\nIf you are confident that `getrandom` is not used in your project, but it gets pulled nevertheless by one of your dependencies, then you can use the following custom backend, which always returns the \u201cunsupported\u201d error:\n```\nuse getrandom::Error;\n#[no_mangle]\nunsafe extern \"Rust\" fn __getrandom_v03_custom(\n  dest: *mut u8,\n  len: usize,\n) -> Result<(), Error> {\n  Err(Error::UNSUPPORTED)\n}\n```\n\n#### \u00a7\u27e851\u27e9Platform Support\nThis crate generally supports the same operating system and platform versions that the Rust standard library does. Additional targets may be supported using the opt-in custom backend.\nThis means that as Rust drops support for old versions of operating systems (such as old Linux kernel versions, Android API levels, etc.) in stable releases, `getrandom` may create new patch releases that remove support for outdated platform versions.\n#### \u00a7\u27e852\u27e9`/dev/urandom` fallback on Linux and Android\nOn Linux targets, the `/dev/urandom` fallback is present only if either `target_env` is `musl`, or `target_arch` is one of the following: `aarch64`, `arm`, `powerpc`, `powerpc64`, `s390x`, `x86`, `x86_64`. Other supported targets require\u27e853\u27e9 kernel versions that support the `getrandom` system call, so the fallback is not needed.\nOn Android targets the fallback is present only for the following `target_arch`es: `aarch64`, `arm`, `x86`, `x86_64`. Other `target_arch`es (e.g. RISC-V) require sufficiently high API levels.\nThe fallback can be disabled by enabling the `linux_getrandom` opt-in backend. Note that doing so will bump minimum supported Linux kernel version to 3.17 and Android API level to 23 (Marshmallow).\n#### \u00a7\u27e854\u27e9Early boot\nSometimes, early in the boot process, the OS has not collected enough entropy to securely seed its RNG. This is especially common on virtual machines, where standard \u201crandom\u201d events are hard to come by.\nSome operating system interfaces always block until the RNG is securely seeded. This can take anywhere from a few seconds to more than a minute. A few (Linux, NetBSD and Solaris) offer a choice between blocking and getting an error; in these cases, we always choose to block.\nOn Linux (when the `getrandom` system call is not available), reading from `/dev/urandom` never blocks, even when the OS hasn\u2019t collected enough entropy yet. To avoid returning low-entropy bytes, we first poll `/dev/random` and only switch to `/dev/urandom` once this has succeeded.\nOn OpenBSD, this kind of entropy accounting isn\u2019t available, and on NetBSD, blocking on it is discouraged. On these platforms, nonblocking interfaces are used, even when reliable entropy may not be available. On the platforms where it is used, the reliability of entropy accounting itself isn\u2019t free from controversy. This library provides randomness sourced according to the platform\u2019s best practices, but each platform has its own limits on the grade of randomness it can promise in environments with few sources of entropy.\nOn ESP-IDF, if `esp_fill_random` is used before enabling WiFi, BT, or the voltage noise entropy source (SAR ADC), the Hardware RNG will only be seeded via RC_FAST_CLK. This can occur during early boot unless `bootloader_random_enable()` is called. For more information see the ESP-IDF RNG Docs\u27e855\u27e9 or the RNG section of the ESP32 Technical Reference Manual\u27e856\u27e9.\n### \u00a7\u27e857\u27e9Error handling\nWe always prioritize failure over returning known insecure \u201crandom\u201d bytes. Generally, on supported platforms, failure is highly unlikely, though not impossible. If an error does occur, it is likely that it will occur on every call to `getrandom`. Therefore, after the first successful call, one can be reasonably confident that no errors will occur.\n### \u00a7\u27e858\u27e9Panic handling\nWe strive to eliminate all potential panics from our backend implementations. In other words, when compiled with optimizations enabled, the generated binary code for `getrandom` functions should not contain any panic branches. Even if the platform misbehaves and returns an unexpected result, our code should correctly handle it and return an error, e.g. `Error::UNEXPECTED`\u27e859\u27e9.\n### \u00a7\u27e860\u27e9Sanitizer support\nIf your code uses `fill_uninit`\u27e861\u27e9 and you enable MemorySanitizer\u27e862\u27e9 (i.e. `-Zsanitizer=memory`), we will automatically handle unpoisoning of the destination buffer filled by `fill_uninit`.\nYou can run sanitizer tests for your crate dependent on `getrandom` like this:\n```\nRUSTFLAGS=\"-Zsanitizer=memory\" cargo test -Zbuild-std --target=x86_64-unknown-linux-gnu\n```\n\n### \u00a7\u27e863\u27e9Minimum Supported Rust Version\nThis crate requires Rust 1.63 or later.\n### \u00a7\u27e864\u27e9License\nThe `getrandom` library is distributed under either of\n  * Apache License, Version 2.0\u27e865\u27e9\n  * MIT license\u27e866\u27e9\n\n\nat your option.\n#### \u00a7\u27e867\u27e9Contribution\nUnless you explicitly state otherwise, any contribution intentionally submitted for inclusion in the work by you, as defined in the Apache-2.0 license, shall be dual licensed as above, without any additional terms or conditions.\n## Structs\u00a7\u27e868\u27e9\n\nError\u27e869\u27e9\n    A small and `no_std` compatible error type\n## Functions\u00a7\u27e870\u27e9\n\nfill\u27e871\u27e9\n    Fill `dest` with random bytes from the system\u2019s preferred random number source.\n\nfill_uninit\u27e861\u27e9\n    Fill potentially uninitialized buffer `dest` with random bytes from the system\u2019s preferred random number source and return a mutable reference to those bytes.\n\nu32\u27e872\u27e9\n    Get random `u32` from the system\u2019s preferred random number source.\n\nu64\u27e873\u27e9\n    Get random `u64` from the system\u2019s preferred random number source.\n",
            "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/getrandom/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/getrandom/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/getrandom/latest/src/getrandom/lib.rs.html#2-143: Source\n\u27e84\u27e9 https://docs.rs/getrandom/latest/getrandom/#getrandom-systems-random-number-generator: \u00a7\n\u27e85\u27e9 https://github.com/rust-random/getrandom/actions/workflows/tests.yml/badge.svg?branch=master: ![Build Status\n\u27e86\u27e9 https://img.shields.io/crates/v/getrandom: ![Crate\n\u27e87\u27e9 https://docs.rs/getrandom/badge.svg: ![Documentation\n\u27e88\u27e9 https://deps.rs/repo/github/rust-random/getrandom/status.svg: ![Dependency Status\n\u27e89\u27e9 https://img.shields.io/crates/d/getrandom: ![Downloads\n\u27e810\u27e9 https://img.shields.io/crates/l/getrandom: ![License\n\u27e811\u27e9 https://crates.io/crates/rand: `rand`\n\u27e812\u27e9 https://docs.rs/getrandom/latest/getrandom/#usage: \u00a7\n\u27e813\u27e9 https://docs.rs/getrandom/latest/getrandom/#supported-targets: \u00a7\n\u27e814\u27e9 https://manned.org/getrandom.2: `getrandom`\n\u27e815\u27e9 https://manned.org/urandom.4: `/dev/urandom`\n\u27e816\u27e9 https://learn.microsoft.com/en-us/windows/win32/seccng/processprng: `ProcessPrng`\n\u27e817\u27e9 https://learn.microsoft.com/en-us/windows/win32/api/ntsecapi/nf-ntsecapi-rtlgenrandom: `RtlGenRandom`\n\u27e818\u27e9 https://www.unix.com/man-page/mojave/2/getentropy/: `getentropy`\n\u27e819\u27e9 https://opensource.apple.com/source/CommonCrypto/CommonCrypto-60074/include/CommonRandom.h.auto.html: `CCRandomGenerateBytes`\n\u27e820\u27e9 https://www.freebsd.org/cgi/man.cgi?query=getrandom&manpath=FreeBSD+12.0-stable: `getrandom`\n\u27e821\u27e9 https://man.openbsd.org/getentropy.2: `getentropy`\n\u27e822\u27e9 https://man.netbsd.org/getrandom.2: `getrandom`\n\u27e823\u27e9 https://man.netbsd.org/sysctl.7: `kern.arandom`\n\u27e824\u27e9 https://leaf.dragonflybsd.org/cgi/web-man?command=getrandom: `getrandom`\n\u27e825\u27e9 https://docs.oracle.com/cd/E88353_01/html/E37841/getrandom-2.html: `getrandom`\n\u27e826\u27e9 https://illumos.org/man/2/getrandom: `getrandom`\n\u27e827\u27e9 https://fuchsia.dev/fuchsia-src/zircon/syscalls/cprng_draw: `cprng_draw`\n\u27e828\u27e9 https://github.com/hermit-os/kernel/blob/315f58ff5efc81d9bf0618af85a59963ff55f8b1/src/syscalls/entropy.rs#L47-L55: `sys_read_entropy`\n\u27e829\u27e9 https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-getrandom: `getrandom`\n\u27e830\u27e9 https://software.intel.com/en-us/articles/intel-digital-random-number-generator-drng-software-implementation-guide: `RDRAND`\n\u27e831\u27e9 https://github.com/emscripten-core/emscripten/pull/12240: `getentropy`\n\u27e832\u27e9 https://github.com/WebAssembly/WASI/blob/snapshot-01/phases/snapshot/docs.md#-random_getbuf-pointeru8-buf_len-size---errno: `random_get`\n\u27e833\u27e9 https://github.com/WebAssembly/WASI/blob/v0.2.1/wasip2/random/random.wit#L23-L28: `get-random-u64`\n\u27e834\u27e9 https://github.com/rust3ds/shim-3ds/commit/b01d2568836dea2a65d05d662f8e5f805c64389d: `getrandom`\n\u27e835\u27e9 https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-reference/system/random.html#functions: `esp_fill_random`\n\u27e836\u27e9 https://github.com/vitasdk/newlib/blob/2d869fe47aaf02b8e52d04e9a2b79d5b210fd016/newlib/libc/sys/vita/getentropy.c: `getentropy`\n\u27e837\u27e9 https://www.qnx.com/developers/docs/7.1/index.html#com.qnx.doc.neutrino.utilities/topic/r/random.html: `/dev/urandom`\n\u27e838\u27e9 https://www.ibm.com/docs/en/aix/7.3?topic=files-random-urandom-devices: `/dev/urandom`\n\u27e839\u27e9 https://github.com/cygwin/cygwin/blob/main/winsup/cygwin/libc/getentropy.cc: `getrandom`\n\u27e840\u27e9 https://docs.rs/getrandom/latest/getrandom/#opt-in-backends: \u00a7\n\u27e841\u27e9 https://developer.arm.com/documentation/ddi0601/2024-06/AArch64-Registers/RNDR--Random-Number: `RNDR`\n\u27e842\u27e9 https://www.w3.org/TR/WebCryptoAPI/#Crypto-method-getRandomValues: `Crypto.getRandomValues`\n\u27e843\u27e9 https://docs.rs/getrandom/latest/getrandom/#webassembly-support: see below\n\u27e844\u27e9 https://uefi.org/specs/UEFI/2.10/37_Secure_Technologies.html#efi-rng-protocol: `EFI_RNG_PROTOCOL`\n\u27e845\u27e9 https://docs.rs/getrandom/latest/getrandom/#custom-backend: custom backend\n\u27e846\u27e9 https://doc.rust-lang.org/cargo/reference/config.html: `.cargo/config.toml`\n\u27e847\u27e9 https://docs.rs/getrandom/latest/getrandom/#raw-linux-syscall-support: \u00a7\n\u27e848\u27e9 https://github.com/WebAssembly/WASI: WASI\n\u27e849\u27e9 https://emscripten.org: Emscripten\n\u27e850\u27e9 https://github.com/rustwasm/wasm-bindgen: `wasm-bindgen`\n\u27e851\u27e9 https://docs.rs/getrandom/latest/getrandom/#platform-support: \u00a7\n\u27e852\u27e9 https://docs.rs/getrandom/latest/getrandom/#devurandom-fallback-on-linux-and-android: \u00a7\n\u27e853\u27e9 https://doc.rust-lang.org/stable/rustc/platform-support.html: require\n\u27e854\u27e9 https://docs.rs/getrandom/latest/getrandom/#early-boot: \u00a7\n\u27e855\u27e9 https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-reference/system/random.html: ESP-IDF RNG Docs\n\u27e856\u27e9 https://www.espressif.com/sites/default/files/documentation/esp32_technical_reference_manual_en.pdf#rng: RNG section of the ESP32 Technical Reference Manual\n\u27e857\u27e9 https://docs.rs/getrandom/latest/getrandom/#error-handling: \u00a7\n\u27e858\u27e9 https://docs.rs/getrandom/latest/getrandom/#panic-handling: \u00a7\n\u27e859\u27e9 https://docs.rs/getrandom/latest/getrandom/struct.Error.html#associatedconstant.UNEXPECTED: associated constant getrandom::Error::UNEXPECTED - `Error::UNEXPECTED`\n\u27e860\u27e9 https://docs.rs/getrandom/latest/getrandom/#sanitizer-support: \u00a7\n\u27e861\u27e9 https://docs.rs/getrandom/latest/getrandom/fn.fill_uninit.html: fn getrandom::fill_uninit - `fill_uninit`\n\u27e862\u27e9 https://doc.rust-lang.org/beta/unstable-book/compiler-flags/sanitizer.html#memorysanitizer: MemorySanitizer\n\u27e863\u27e9 https://docs.rs/getrandom/latest/getrandom/#minimum-supported-rust-version: \u00a7\n\u27e864\u27e9 https://docs.rs/getrandom/latest/getrandom/#license: \u00a7\n\u27e865\u27e9 https://github.com/rust-random/getrandom/blob/master/LICENSE-APACHE: Apache License, Version 2.0\n\u27e866\u27e9 https://github.com/rust-random/getrandom/blob/master/LICENSE-MIT: MIT license\n\u27e867\u27e9 https://docs.rs/getrandom/latest/getrandom/#contribution: \u00a7\n\u27e868\u27e9 https://docs.rs/getrandom/latest/getrandom/#structs: \u00a7\n\u27e869\u27e9 https://docs.rs/getrandom/latest/getrandom/struct.Error.html: struct getrandom::Error - Error\n\u27e870\u27e9 https://docs.rs/getrandom/latest/getrandom/#functions: \u00a7\n\u27e871\u27e9 https://docs.rs/getrandom/latest/getrandom/fn.fill.html: fn getrandom::fill - fill\n\u27e872\u27e9 https://docs.rs/getrandom/latest/getrandom/fn.u32.html: fn getrandom::u32 - u32\n\u27e873\u27e9 https://docs.rs/getrandom/latest/getrandom/fn.u64.html: fn getrandom::u64 - u64\n",
            "fit_markdown": "",
            "fit_html": ""
          },
          "downloads": 0,
          "github_stars": 0,
          "dependencies": [],
          "features": {},
          "code_snippets": [],
          "readme_sections": {},
          "librs_downloads": null,
          "source": "crates.io",
          "enhanced_scraping": {},
          "enhanced_features": [],
          "enhanced_dependencies": [],
          "readme_summary": "The `getrandom` crate provides a low-level API for securely generating random data from the operating system's entropy sources, ensuring cryptographic quality. It supports a wide range of platforms, including Linux, Windows, macOS, BSDs, WebAssembly, and embedded systems, with platform-specific implementations. Additionally, it offers opt-in backends for customization and supports user-defined randomness sources.",
          "feature_summary": null,
          "use_case": "Cryptography",
          "score": 8.0,
          "factual_counterfactual": "### Pair 1: Supported Platforms  \n\u2705 **Factual**: The `getrandom` crate supports a wide range of platforms, including Linux, Windows, macOS, FreeBSD, and WASI, among others, using platform-specific APIs to retrieve cryptographically secure random data.  \n\u274c **Counterfactual**: The `getrandom` crate is limited to Unix-based systems and does not support Windows or WASI platforms.  \n\n---\n\n### Pair 2: API Design  \n\u2705 **Factual**: The `getrandom` crate provides a low-level API for directly filling a byte buffer with random data, making it suitable for cryptographic applications or custom random number generation.  \n\u274c **Counterfactual**: The `getrandom` crate includes high-level random number generation utilities, such as directly generating integers or floats, similar to the `rand` crate.  \n\n---\n\n### Pair 3: Entropy Sources  \n\u2705 **Factual**: On Linux systems, `getrandom` uses the `getrandom` syscall if available, falling back to `/dev/urandom` after polling `/dev/random` for sufficient entropy.  \n\u274c **Counterfactual**: On Linux systems, `getrandom` exclusively uses `/dev/random` as its entropy source, ignoring the `getrandom` syscall or `/dev/urandom`.",
          "source_analysis": null,
          "user_behavior": null,
          "security": null
        }
      },
      "irl_score": 8.6,
      "execution_id": "exec-d007f64e-8fd8e95b-1751261038",
      "timestamp": "2025-06-30T05:23:58.598423+00:00",
      "canon_version": "1.3.0"
    },
    "rule_zero_compliant": true
  }
]