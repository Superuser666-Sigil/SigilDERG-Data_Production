[
  {
    "execution_id": "exec-e4aa25e5-91ef105d-1751261108",
    "timestamp": "2025-06-30T05:25:08.018327+00:00",
    "sacred_chain": {
      "input_data": "nanorand",
      "context_sources": [
        "crates.io",
        "github.com",
        "lib.rs",
        "docs.rs"
      ],
      "reasoning_steps": [
        "Input canonicalized: 'nanorand' -> 'nanorand'",
        "Context gathered from 4 validated sources",
        "Metadata extracted: 4 fields",
        "Documentation analyzed: quality 7.0",
        "Sentiment analyzed: positive",
        "Ecosystem analyzed: utilities",
        "Quality score synthesized: 7.50",
        "Trust decision: DEFER - Insufficient data for decision",
        "IRL confidence: 8.600"
      ],
      "suggestion": "ALLOW: Positive community sentiment",
      "verdict": "DEFER",
      "audit_info": {
        "metadata": {
          "name": "nanorand",
          "type": "rust_crate",
          "source": "manual_input",
          "extraction_method": "irl_engine"
        },
        "sentiment": {
          "quality_score": 7.0,
          "completeness": 0.8,
          "examples_present": true,
          "api_documented": true
        },
        "ecosystem": {
          "overall": "positive",
          "positive_mentions": 10,
          "negative_mentions": 2,
          "neutral_mentions": 5,
          "total_mentions": 17
        },
        "quality_score": 7.5,
        "verdict_reason": "Insufficient data for decision",
        "sanitized_documentation": {
          "crates_io": {
            "url": "https://crates.io/crates/nanorand",
            "title": "nanorand v0.8.0",
            "content": {
              "raw_markdown": "#  nanorand v0.8.0\nA tiny, fast, zero-dep library for random number generation. \n  * [ #entropy ](https://crates.io/keywords/entropy)\n  * [ #no-std ](https://crates.io/keywords/no-std)\n  * [ #rand ](https://crates.io/keywords/rand)\n  * [ #random ](https://crates.io/keywords/random)\n\n\n  * [ Readme ](https://crates.io/crates/nanorand)\n  * [ 18 Versions ](https://crates.io/crates/nanorand/versions)\n  * [ Dependencies ](https://crates.io/crates/nanorand/dependencies)\n  * [ Dependents ](https://crates.io/crates/nanorand/reverse_dependencies)\n\n\n## Metadata\n22 days ago \nv1.56.0 \n[ Zlib ](https://choosealicense.com/licenses/zlib)\n20.3 KiB \n## Install\nRun the following Cargo command in your project directory:\ncargo add nanorand\nOr add the following line to your Cargo.toml:\nnanorand = \"0.8.0\"\n## Repository\n[ github.com/Absolucy/nanorand-rs ](https://github.com/Absolucy/nanorand-rs)\n## Owners\n## Categories\n  * [No standard library](https://crates.io/categories/no-std)\n  * [Algorithms](https://crates.io/categories/algorithms)\n\n\n[ Report crate ](https://crates.io/support?crate=nanorand&inquire=crate-violation)\n### Stats Overview\n35,068,962 Downloads all time\n18 Versions published\n#### Downloads over the last 90 days\nDisplay as \nStacked \n  * Stacked \n  * Unstacked \n\n\nLoading\u2026\n",
              "markdown_with_citations": "#  nanorand v0.8.0\nA tiny, fast, zero-dep library for random number generation. \n  *  #entropy \u27e81\u27e9\n  *  #no-std \u27e82\u27e9\n  *  #rand \u27e83\u27e9\n  *  #random \u27e84\u27e9\n\n\n  *  Readme \u27e85\u27e9\n  *  18 Versions \u27e86\u27e9\n  *  Dependencies \u27e87\u27e9\n  *  Dependents \u27e88\u27e9\n\n\n## Metadata\n22 days ago \nv1.56.0 \n Zlib \u27e89\u27e9\n20.3 KiB \n## Install\nRun the following Cargo command in your project directory:\ncargo add nanorand\nOr add the following line to your Cargo.toml:\nnanorand = \"0.8.0\"\n## Repository\n github.com/Absolucy/nanorand-rs \u27e810\u27e9\n## Owners\n## Categories\n  * No standard library\u27e811\u27e9\n  * Algorithms\u27e812\u27e9\n\n\n Report crate \u27e813\u27e9\n### Stats Overview\n35,068,962 Downloads all time\n18 Versions published\n#### Downloads over the last 90 days\nDisplay as \nStacked \n  * Stacked \n  * Unstacked \n\n\nLoading\u2026\n",
              "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://crates.io/keywords/entropy:  #entropy \n\u27e82\u27e9 https://crates.io/keywords/no-std:  #no-std \n\u27e83\u27e9 https://crates.io/keywords/rand:  #rand \n\u27e84\u27e9 https://crates.io/keywords/random:  #random \n\u27e85\u27e9 https://crates.io/crates/nanorand:  Readme \n\u27e86\u27e9 https://crates.io/crates/nanorand/versions:  18 Versions \n\u27e87\u27e9 https://crates.io/crates/nanorand/dependencies:  Dependencies \n\u27e88\u27e9 https://crates.io/crates/nanorand/reverse_dependencies:  Dependents \n\u27e89\u27e9 https://choosealicense.com/licenses/zlib:  Zlib \n\u27e810\u27e9 https://github.com/Absolucy/nanorand-rs:  github.com/Absolucy/nanorand-rs \n\u27e811\u27e9 https://crates.io/categories/no-std: No standard library\n\u27e812\u27e9 https://crates.io/categories/algorithms: Algorithms\n\u27e813\u27e9 https://crates.io/support?crate=nanorand&inquire=crate-violation:  Report crate \n",
              "fit_markdown": "",
              "fit_html": ""
            },
            "structured_data": {},
            "quality_score": 3.0,
            "extraction_method": "crawl4ai",
            "error": null,
            "metadata": {
              "doc_type": "docs",
              "content_length": 1283,
              "has_structured_data": false,
              "crawl_success": true
            },
            "timestamp": "114897.7092318"
          },
          "docs_rs": {
            "url": "https://docs.rs/nanorand",
            "title": "Crate nanorandCopy item path",
            "content": {
              "raw_markdown": "[](https://docs.rs/nanorand/latest/nanorand/all.html \"show sidebar\")\n# Crate nanorandCopy item path\n[Settings](https://docs.rs/nanorand/latest/settings.html)\n[Help](https://docs.rs/nanorand/latest/help.html)\nSummary[Source](https://docs.rs/nanorand/latest/src/nanorand/lib.rs.html#1-126)\nExpand description\nA library meant for fast, random number generation with quick compile time, and minimal dependencies.\n## [\u00a7](https://docs.rs/nanorand/latest/nanorand/#examples)Examples\n### [\u00a7](https://docs.rs/nanorand/latest/nanorand/#generating-a-number-with-an-initialized-rng)Generating a number with an initialized RNG\n```\nuse nanorand::{Rng, WyRand};\nlet mut rng = WyRand::new();\nprintln!(\"Random number: {}\", rng.generate::<u64>());\n```\n\n### [\u00a7](https://docs.rs/nanorand/latest/nanorand/#generating-a-number-with-a-thread-local-rng)Generating a number with a thread-local RNG\n```\nuse nanorand::Rng;\nlet mut rng = nanorand::tls_rng();\nprintln!(\"Random number: {}\", rng.generate::<u64>());\n```\n\n### [\u00a7](https://docs.rs/nanorand/latest/nanorand/#generating-a-number-in-a-range)Generating a number in a range\n```\nuse nanorand::{Rng, WyRand};\nlet mut rng = WyRand::new();\nprintln!(\"Random number between 1 and 100: {}\", rng.generate_range(1_u64..=100));\nprintln!(\"Random number between -100 and 50: {}\", rng.generate_range(-100_i64..=50));\n```\n\n#### [\u00a7](https://docs.rs/nanorand/latest/nanorand/#buffering-random-bytes)Buffering random bytes\n```\nuse nanorand::{Rng, BufferedRng, WyRand};\nlet mut thingy = [0u8; 5];\nlet mut rng = BufferedRng::new(WyRand::new());\nrng.fill(&mut thingy);\n// As WyRand generates 8 bytes of output, and our target is only 5 bytes,\n// 3 bytes will remain in the buffer.\nassert_eq!(rng.buffered(), 3);\n```\n\n### [\u00a7](https://docs.rs/nanorand/latest/nanorand/#shuffling-a-vec)Shuffling a Vec\n```\nuse nanorand::{Rng, WyRand};\nlet mut rng = WyRand::new();\nlet mut items = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nrng.shuffle(&mut items);\n```\n\n### [\u00a7](https://docs.rs/nanorand/latest/nanorand/#why-should-i-use-this-over)Why should I use this over\u2026\n  * `rand` - The standard rand crate is a complex beast. It contains unsafe code in the core implementations, and while it has much more options than we do, that\u2019s kind of the point. We\u2019re straight to the point, while rand is everything and the kitchen sink.\n  * `fastrand`, `oorandom`, `random-fast-rng`, or `randomize` - These are all minimal, zero-dep implementations of the PCG family of RNGs (Pcg32 and Pcg64). While these are decent, they are _much_ slower than wyrand (which beats the speed of these Pcg32 implementations while providing 64 random bits), and do not provide CSPRNGs.\n  * `getrandom` - The getrandom crate just provides OS entropy sources. It is not meant for random number generation. In fact, we provide it as an optional entropy source.\n\n\n### [\u00a7](https://docs.rs/nanorand/latest/nanorand/#rng-implementations)RNG Implementations\n**RNG**| **nanorand type**| **Output Size**| **Cryptographically Secure**| **Speed** 1| **Notes**| **Original Implementation**  \n---|---|---|---|---|---|---  \nwyrand| [`nanorand::WyRand`](https://docs.rs/nanorand/latest/nanorand/rand/wyrand/struct.WyRand.html), [`nanorand::tls::TlsWyRand`](https://docs.rs/nanorand/latest/nanorand/tls/fn.tls_rng.html)| 64 bits (`u64`)| \ud83d\udeab| 14 GB/s| | <https://github.com/lemire/testingRNG/blob/master/source/wyrand.h>  \nPcg64| [`nanorand::Pcg64`](https://docs.rs/nanorand/latest/nanorand/rand/pcg64/struct.Pcg64.html)| 64 bits (`u64`)| \ud83d\udeab| 1.6 GB/s| | <https://github.com/rkern/pcg64>  \nChaCha| [`nanorand::ChaCha`](https://docs.rs/nanorand/latest/nanorand/rand/chacha/struct.ChaCha.html)| 512 bits (`[u32; 16]`)| \u2705| 980 MB/s (ChaCha8), 749 MB/s (ChaCha12), 505 MB/s (ChaCha20)| | <https://cr.yp.to/chacha.html>  \n1. Speed benchmarked on an M1 Macbook Air\n### [\u00a7](https://docs.rs/nanorand/latest/nanorand/#entropy-sources)Entropy Sources\n_Listed in order of priority_\n  * If the `getrandom` feature is enabled, then [`getrandom::getrandom`](https://docs.rs/getrandom/*/getrandom/fn.getrandom.html) will be called, and no other entropy sources will be used.\n  * If the `rdseed` feature is enabled, and is running on an x86(-64) system with the [RDSEED](https://en.wikipedia.org/wiki/RDRAND) instruction, then we will attempt to source as much entropy as possible via our [`rdseed_entropy`](entropy::rdseed_entropy) function\n  * Linux and Android will attempt to use the [`getrandom`](https://man7.org/linux/man-pages/man2/getrandom.2.html) syscall.\n  * macOS and iOS (Darwin-based systems) will use Security.framework\u2019s [`SecRandomCopyBytes`](https://developer.apple.com/documentation/security/1399291-secrandomcopybytes).\n  * OpenBSD will attempt to use the [`arc4random_buf`](https://man.openbsd.org/arc4random.3) function.\n  * Windows \n    * If we\u2019re targeting UWP, then the [`BCryptGenRandom`](https://docs.microsoft.com/en-us/windows/win32/api/bcrypt/nf-bcrypt-bcryptgenrandom) is used with system-preferred RNG (`BCRYPT_USE_SYSTEM_PREFERRED_RNG`).\n    * Otherwise, we\u2019ll use [`RtlGenRandom`](https://docs.microsoft.com/en-us/windows/win32/api/ntsecapi/nf-ntsecapi-rtlgenrandom).\n\n\n### [\u00a7](https://docs.rs/nanorand/latest/nanorand/#feature-flags)Feature Flags\n  * `alloc` (default) - Enables Rust `alloc` lib features, such as a buffering Rng wrapper.\n  * `entropy` (default) - Allows sourcing entropy from the system. Implied by `getrandom`, too.\n  * `std` (default) - Enables Rust `std` lib features, such as seeding from OS entropy sources. Requires `alloc` to be enabled.\n  * `tls` (default) - Enables a thread-local [`WyRand`](https://docs.rs/nanorand/latest/nanorand/rand/wyrand/struct.WyRand.html) RNG (see below). Requires `std` to be enabled.\n  * `wyrand` (default) - Enable the [`WyRand`](https://docs.rs/nanorand/latest/nanorand/rand/wyrand/struct.WyRand.html) RNG.\n  * `pcg64` (default) - Enable the [`Pcg64`](https://docs.rs/nanorand/latest/nanorand/rand/pcg64/struct.Pcg64.html) RNG.\n  * `chacha` - Enable the [`ChaCha`](https://docs.rs/nanorand/latest/nanorand/rand/chacha/struct.ChaCha.html) RNG. Requires Rust 1.47 or later.\n  * `rdseed` - On x86 and x86-64 platforms, the `rdseed` intrinsic will be used when OS entropy isn\u2019t available.\n  * `zeroize` - Implement the [Zeroize](https://crates.io/crates/zeroize) trait for all RNGs.\n  * `getrandom` - Use the [`getrandom`](https://crates.io/crates/getrandom) crate as an entropy source. Works on most systems, optional due to the fact that it brings in more dependencies.\n\n\n### [\u00a7](https://docs.rs/nanorand/latest/nanorand/#msrv)MSRV\nThe minimum supported Rust version for the latest version of nanorand is **Rust 1.56.0** , released October 21st, 2021.\n## Re-exports[\u00a7](https://docs.rs/nanorand/latest/nanorand/#reexports)\n\n`pub use buffer::BufferedRng[](https://docs.rs/nanorand/latest/nanorand/buffer/struct.BufferedRng.html \"struct nanorand::buffer::BufferedRng\");``alloc`\n\n\n`pub use tls::tls_rng[](https://docs.rs/nanorand/latest/nanorand/tls/fn.tls_rng.html \"fn nanorand::tls::tls_rng\");``tls`\n\n\n`pub use gen[](https://docs.rs/nanorand/latest/nanorand/gen/index.html \"mod nanorand::gen\")::*;`\n\n\n`pub use rand[](https://docs.rs/nanorand/latest/nanorand/rand/index.html \"mod nanorand::rand\")::*;`\n\n## Modules[\u00a7](https://docs.rs/nanorand/latest/nanorand/#modules)\n\n[buffer](https://docs.rs/nanorand/latest/nanorand/buffer/index.html \"mod nanorand::buffer\")`alloc`\n    Provides a buffered wrapper for RNGs, preventing bits from being wasted.\n\n[crypto](https://docs.rs/nanorand/latest/nanorand/crypto/index.html \"mod nanorand::crypto\")\n    Implementation of cryptography, for CSPRNGs.\n\n[entropy](https://docs.rs/nanorand/latest/nanorand/entropy/index.html \"mod nanorand::entropy\")`entropy` or `getrandom`\n    Sources for obtaining entropy.\n\n[gen](https://docs.rs/nanorand/latest/nanorand/gen/index.html \"mod nanorand::gen\")\n    Traits for generating types from an RNG.\n\n[rand](https://docs.rs/nanorand/latest/nanorand/rand/index.html \"mod nanorand::rand\")\n    RNG algorithms.\n\n[tls](https://docs.rs/nanorand/latest/nanorand/tls/index.html \"mod nanorand::tls\")`tls`\n    Provides a thread-local [`WyRand`](https://docs.rs/nanorand/latest/nanorand/rand/wyrand/struct.WyRand.html \"struct nanorand::rand::wyrand::WyRand\") RNG.\n",
              "markdown_with_citations": "[](https://docs.rs/nanorand/latest/nanorand/all.html \"show sidebar\")\n# Crate nanorandCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nA library meant for fast, random number generation with quick compile time, and minimal dependencies.\n## \u00a7\u27e84\u27e9Examples\n### \u00a7\u27e85\u27e9Generating a number with an initialized RNG\n```\nuse nanorand::{Rng, WyRand};\nlet mut rng = WyRand::new();\nprintln!(\"Random number: {}\", rng.generate::<u64>());\n```\n\n### \u00a7\u27e86\u27e9Generating a number with a thread-local RNG\n```\nuse nanorand::Rng;\nlet mut rng = nanorand::tls_rng();\nprintln!(\"Random number: {}\", rng.generate::<u64>());\n```\n\n### \u00a7\u27e87\u27e9Generating a number in a range\n```\nuse nanorand::{Rng, WyRand};\nlet mut rng = WyRand::new();\nprintln!(\"Random number between 1 and 100: {}\", rng.generate_range(1_u64..=100));\nprintln!(\"Random number between -100 and 50: {}\", rng.generate_range(-100_i64..=50));\n```\n\n#### \u00a7\u27e88\u27e9Buffering random bytes\n```\nuse nanorand::{Rng, BufferedRng, WyRand};\nlet mut thingy = [0u8; 5];\nlet mut rng = BufferedRng::new(WyRand::new());\nrng.fill(&mut thingy);\n// As WyRand generates 8 bytes of output, and our target is only 5 bytes,\n// 3 bytes will remain in the buffer.\nassert_eq!(rng.buffered(), 3);\n```\n\n### \u00a7\u27e89\u27e9Shuffling a Vec\n```\nuse nanorand::{Rng, WyRand};\nlet mut rng = WyRand::new();\nlet mut items = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nrng.shuffle(&mut items);\n```\n\n### \u00a7\u27e810\u27e9Why should I use this over\u2026\n  * `rand` - The standard rand crate is a complex beast. It contains unsafe code in the core implementations, and while it has much more options than we do, that\u2019s kind of the point. We\u2019re straight to the point, while rand is everything and the kitchen sink.\n  * `fastrand`, `oorandom`, `random-fast-rng`, or `randomize` - These are all minimal, zero-dep implementations of the PCG family of RNGs (Pcg32 and Pcg64). While these are decent, they are _much_ slower than wyrand (which beats the speed of these Pcg32 implementations while providing 64 random bits), and do not provide CSPRNGs.\n  * `getrandom` - The getrandom crate just provides OS entropy sources. It is not meant for random number generation. In fact, we provide it as an optional entropy source.\n\n\n### \u00a7\u27e811\u27e9RNG Implementations\n**RNG**| **nanorand type**| **Output Size**| **Cryptographically Secure**| **Speed** 1| **Notes**| **Original Implementation**  \n---|---|---|---|---|---|---  \nwyrand| `nanorand::WyRand`\u27e812\u27e9, `nanorand::tls::TlsWyRand`\u27e813\u27e9| 64 bits (`u64`)| \ud83d\udeab| 14 GB/s| | <https://github.com/lemire/testingRNG/blob/master/source/wyrand.h>  \nPcg64| `nanorand::Pcg64`\u27e814\u27e9| 64 bits (`u64`)| \ud83d\udeab| 1.6 GB/s| | <https://github.com/rkern/pcg64>  \nChaCha| `nanorand::ChaCha`\u27e815\u27e9| 512 bits (`[u32; 16]`)| \u2705| 980 MB/s (ChaCha8), 749 MB/s (ChaCha12), 505 MB/s (ChaCha20)| | <https://cr.yp.to/chacha.html>  \n1. Speed benchmarked on an M1 Macbook Air\n### \u00a7\u27e816\u27e9Entropy Sources\n_Listed in order of priority_\n  * If the `getrandom` feature is enabled, then `getrandom::getrandom`\u27e817\u27e9 will be called, and no other entropy sources will be used.\n  * If the `rdseed` feature is enabled, and is running on an x86(-64) system with the RDSEED\u27e818\u27e9 instruction, then we will attempt to source as much entropy as possible via our `rdseed_entropy`\u27e819\u27e9 function\n  * Linux and Android will attempt to use the `getrandom`\u27e820\u27e9 syscall.\n  * macOS and iOS (Darwin-based systems) will use Security.framework\u2019s `SecRandomCopyBytes`\u27e821\u27e9.\n  * OpenBSD will attempt to use the `arc4random_buf`\u27e822\u27e9 function.\n  * Windows \n    * If we\u2019re targeting UWP, then the `BCryptGenRandom`\u27e823\u27e9 is used with system-preferred RNG (`BCRYPT_USE_SYSTEM_PREFERRED_RNG`).\n    * Otherwise, we\u2019ll use `RtlGenRandom`\u27e824\u27e9.\n\n\n### \u00a7\u27e825\u27e9Feature Flags\n  * `alloc` (default) - Enables Rust `alloc` lib features, such as a buffering Rng wrapper.\n  * `entropy` (default) - Allows sourcing entropy from the system. Implied by `getrandom`, too.\n  * `std` (default) - Enables Rust `std` lib features, such as seeding from OS entropy sources. Requires `alloc` to be enabled.\n  * `tls` (default) - Enables a thread-local `WyRand`\u27e812\u27e9 RNG (see below). Requires `std` to be enabled.\n  * `wyrand` (default) - Enable the `WyRand`\u27e812\u27e9 RNG.\n  * `pcg64` (default) - Enable the `Pcg64`\u27e814\u27e9 RNG.\n  * `chacha` - Enable the `ChaCha`\u27e815\u27e9 RNG. Requires Rust 1.47 or later.\n  * `rdseed` - On x86 and x86-64 platforms, the `rdseed` intrinsic will be used when OS entropy isn\u2019t available.\n  * `zeroize` - Implement the Zeroize\u27e826\u27e9 trait for all RNGs.\n  * `getrandom` - Use the `getrandom`\u27e827\u27e9 crate as an entropy source. Works on most systems, optional due to the fact that it brings in more dependencies.\n\n\n### \u00a7\u27e828\u27e9MSRV\nThe minimum supported Rust version for the latest version of nanorand is **Rust 1.56.0** , released October 21st, 2021.\n## Re-exports\u00a7\u27e829\u27e9\n\n`pub use buffer::BufferedRng[](https://docs.rs/nanorand/latest/nanorand/buffer/struct.BufferedRng.html \"struct nanorand::buffer::BufferedRng\");``alloc`\n\n\n`pub use tls::tls_rng[](https://docs.rs/nanorand/latest/nanorand/tls/fn.tls_rng.html \"fn nanorand::tls::tls_rng\");``tls`\n\n\n`pub use gen[](https://docs.rs/nanorand/latest/nanorand/gen/index.html \"mod nanorand::gen\")::*;`\n\n\n`pub use rand[](https://docs.rs/nanorand/latest/nanorand/rand/index.html \"mod nanorand::rand\")::*;`\n\n## Modules\u00a7\u27e830\u27e9\n\nbuffer\u27e831\u27e9`alloc`\n    Provides a buffered wrapper for RNGs, preventing bits from being wasted.\n\ncrypto\u27e832\u27e9\n    Implementation of cryptography, for CSPRNGs.\n\nentropy\u27e833\u27e9`entropy` or `getrandom`\n    Sources for obtaining entropy.\n\ngen\u27e834\u27e9\n    Traits for generating types from an RNG.\n\nrand\u27e835\u27e9\n    RNG algorithms.\n\ntls\u27e836\u27e9`tls`\n    Provides a thread-local `WyRand`\u27e812\u27e9 RNG.\n",
              "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/nanorand/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/nanorand/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/nanorand/latest/src/nanorand/lib.rs.html#1-126: Source\n\u27e84\u27e9 https://docs.rs/nanorand/latest/nanorand/#examples: \u00a7\n\u27e85\u27e9 https://docs.rs/nanorand/latest/nanorand/#generating-a-number-with-an-initialized-rng: \u00a7\n\u27e86\u27e9 https://docs.rs/nanorand/latest/nanorand/#generating-a-number-with-a-thread-local-rng: \u00a7\n\u27e87\u27e9 https://docs.rs/nanorand/latest/nanorand/#generating-a-number-in-a-range: \u00a7\n\u27e88\u27e9 https://docs.rs/nanorand/latest/nanorand/#buffering-random-bytes: \u00a7\n\u27e89\u27e9 https://docs.rs/nanorand/latest/nanorand/#shuffling-a-vec: \u00a7\n\u27e810\u27e9 https://docs.rs/nanorand/latest/nanorand/#why-should-i-use-this-over: \u00a7\n\u27e811\u27e9 https://docs.rs/nanorand/latest/nanorand/#rng-implementations: \u00a7\n\u27e812\u27e9 https://docs.rs/nanorand/latest/nanorand/rand/wyrand/struct.WyRand.html: `nanorand::WyRand`\n\u27e813\u27e9 https://docs.rs/nanorand/latest/nanorand/tls/fn.tls_rng.html: `nanorand::tls::TlsWyRand`\n\u27e814\u27e9 https://docs.rs/nanorand/latest/nanorand/rand/pcg64/struct.Pcg64.html: `nanorand::Pcg64`\n\u27e815\u27e9 https://docs.rs/nanorand/latest/nanorand/rand/chacha/struct.ChaCha.html: `nanorand::ChaCha`\n\u27e816\u27e9 https://docs.rs/nanorand/latest/nanorand/#entropy-sources: \u00a7\n\u27e817\u27e9 https://docs.rs/getrandom/*/getrandom/fn.getrandom.html: `getrandom::getrandom`\n\u27e818\u27e9 https://en.wikipedia.org/wiki/RDRAND: RDSEED\n\u27e819\u27e9 entropy::rdseed_entropy: `rdseed_entropy`\n\u27e820\u27e9 https://man7.org/linux/man-pages/man2/getrandom.2.html: `getrandom`\n\u27e821\u27e9 https://developer.apple.com/documentation/security/1399291-secrandomcopybytes: `SecRandomCopyBytes`\n\u27e822\u27e9 https://man.openbsd.org/arc4random.3: `arc4random_buf`\n\u27e823\u27e9 https://docs.microsoft.com/en-us/windows/win32/api/bcrypt/nf-bcrypt-bcryptgenrandom: `BCryptGenRandom`\n\u27e824\u27e9 https://docs.microsoft.com/en-us/windows/win32/api/ntsecapi/nf-ntsecapi-rtlgenrandom: `RtlGenRandom`\n\u27e825\u27e9 https://docs.rs/nanorand/latest/nanorand/#feature-flags: \u00a7\n\u27e826\u27e9 https://crates.io/crates/zeroize: Zeroize\n\u27e827\u27e9 https://crates.io/crates/getrandom: `getrandom`\n\u27e828\u27e9 https://docs.rs/nanorand/latest/nanorand/#msrv: \u00a7\n\u27e829\u27e9 https://docs.rs/nanorand/latest/nanorand/#reexports: \u00a7\n\u27e830\u27e9 https://docs.rs/nanorand/latest/nanorand/#modules: \u00a7\n\u27e831\u27e9 https://docs.rs/nanorand/latest/nanorand/buffer/index.html: mod nanorand::buffer - buffer\n\u27e832\u27e9 https://docs.rs/nanorand/latest/nanorand/crypto/index.html: mod nanorand::crypto - crypto\n\u27e833\u27e9 https://docs.rs/nanorand/latest/nanorand/entropy/index.html: mod nanorand::entropy - entropy\n\u27e834\u27e9 https://docs.rs/nanorand/latest/nanorand/gen/index.html: mod nanorand::gen - gen\n\u27e835\u27e9 https://docs.rs/nanorand/latest/nanorand/rand/index.html: mod nanorand::rand - rand\n\u27e836\u27e9 https://docs.rs/nanorand/latest/nanorand/tls/index.html: mod nanorand::tls - tls\n",
              "fit_markdown": "",
              "fit_html": ""
            },
            "structured_data": {},
            "quality_score": 4.0,
            "extraction_method": "crawl4ai",
            "error": null,
            "metadata": {
              "doc_type": "docs",
              "content_length": 8237,
              "has_structured_data": false,
              "crawl_success": true
            },
            "timestamp": "114898.5808006"
          },
          "lib_rs": {
            "url": "https://lib.rs/crates/nanorand",
            "title": "Untitled",
            "content": {
              "raw_markdown": "###  [16 unstable releases](https://lib.rs/crates/nanorand/versions) (7 breaking)\n0.7.0 |  Mar 9, 2022   \n---|---  \n0.6.1 |  Jul 24, 2021   \n0.5.2 |  Dec 30, 2020   \n0.4.4 |  Sep 23, 2020   \n0.0.0 |  Sep 6, 2020   \n#**153** in [Algorithms](https://lib.rs/algorithms \"Rust implementations of core algorithms such as hashing, sorting, searching, and more.\")\nDownload history 386889/week @ 2024-12-08 317200/week @ 2024-12-15 105147/week @ 2024-12-22 171839/week @ 2024-12-29 329037/week @ 2025-01-05 366419/week @ 2025-01-12 298162/week @ 2025-01-19 346859/week @ 2025-01-26 368270/week @ 2025-02-02 478612/week @ 2025-02-09 447174/week @ 2025-02-16 553883/week @ 2025-02-23 580931/week @ 2025-03-02 588213/week @ 2025-03-09 537872/week @ 2025-03-16 528677/week @ 2025-03-23\n**2,268,795** downloads per month Used in [**284** crates (67 directly)](https://lib.rs/crates/nanorand/rev)\n**Zlib** license \n50KB  875 lines\n[![crates.io](https://img.shields.io/crates/v/nanorand.svg)](https://crates.io/crates/nanorand) [![docs.rs](https://img.gs/czjpqfbdkz/full/https://docs.rs/nanorand/badge.svg)](https://docs.rs/nanorand) [![License: Zlib](https://img.shields.io/badge/License-Zlib-brightgreen.svg)](https://opensource.org/licenses/Zlib) [![Tests](https://img.gs/czjpqfbdkz/full/https://github.com/Absolucy/nanorand-rs/workflows/Tests/badge.svg?event=push&branch=master)](https://github.com/Absolucy/nanorand-rs/actions?query=workflow%3A%22Run+Tests%22) [![Average time to resolve an issue](https://img.gs/czjpqfbdkz/full/https://isitmaintained.com/badge/resolution/Absolucy/nanorand-rs.svg)](https://isitmaintained.com/project/Absolucy/nanorand-rs \"Average time to resolve an issue\") [![Percentage of issues still open](https://img.gs/czjpqfbdkz/full/https://isitmaintained.com/badge/open/Absolucy/nanorand-rs.svg)](https://isitmaintained.com/project/Absolucy/nanorand-rs \"Percentage of issues still open\") ![Maintenance](https://img.shields.io/badge/maintenance-activly--developed-brightgreen.svg)\n# nanorand\nCurrent version: **0.7.0**\nA library meant for fast, random number generation with quick compile time, and minimal dependencies.\n## Examples\n### Generating a number with an initialized RNG\n```\n``use` `nanorand`::````{`Rng`,` WyRand```}```;`\n`let` `mut` rng `=` `WyRand`::``new`(``)``;`\n`println!``(```\"`Random number: `{}``\"```,` rng`.``generate`::````<``u64``>```(``)``)``;`\n`\n```\n\n### Generating a number with a thread-local RNG\n```\n``use` `nanorand`::``Rng`;`\n`let` `mut` rng `=` `nanorand`::``tls_rng`(``)``;`\n`println!``(```\"`Random number: `{}``\"```,` rng`.``generate`::````<``u64``>```(``)``)``;`\n`\n```\n\n### Generating a number in a range\n```\n``use` `nanorand`::````{`Rng`,` WyRand```}```;`\n`let` `mut` rng `=` `WyRand`::``new`(``)``;`\n`println!``(```\"`Random number between 1 and 100: `{}``\"```,` rng`.``generate_range``(``1_``u64``..``=``100``)``)``;`\n`println!``(```\"`Random number between -100 and 50: `{}``\"```,` rng`.``generate_range``(``-``100_``i64``..``=``50``)``)``;`\n`\n```\n\n#### Buffering random bytes\n```\n``use` `nanorand`::````{`Rng`,` BufferedRng`,` WyRand```}```;`\n`let` `mut` thingy `=` `[``0``u8``;` `5``]``;`\n`let` `mut` rng `=` `BufferedRng`::``new`(``WyRand`::``new`(``)``)``;`\nrng`.``fill``(``&``mut` thingy`)``;`\n``//` As WyRand generates 8 bytes of output, and our target is only 5 bytes,`\n``//` 3 bytes will remain in the buffer.`\n`assert_eq!``(`rng`.``buffered``(``)``,` `3``)``;`\n`\n```\n\n### Shuffling a Vec\n```\n``use` `nanorand`::````{`Rng`,` WyRand```}```;`\n`let` `mut` rng `=` `WyRand`::``new`(``)``;`\n`let` `mut` items `=` `vec!``[``1``,` `2``,` `3``,` `4``,` `5``,` `6``,` `7``,` `8``,` `9``,` `10``]``;`\nrng`.``shuffle``(``&``mut` items`)``;`\n`\n```\n\n### Why should I use this over...\n  * ``rand`` - The standard rand crate is a complex beast. It contains unsafe code in the core implementations, and while it has much more options than we do, that's kind of the point. We're straight to the point, while rand is everything and the kitchen sink.\n  * ``fastrand``, ``oorandom``, ``random-fast-rng``, or ``randomize`` - These are all minimal, zero-dep implementations of the PCG family of RNGs (Pcg32 and Pcg64). While these are decent, they are _much_ slower than wyrand (which beats the speed of these Pcg32 implementations while providing 64 random bits), and do not provide CSPRNGs.\n  * ``getrandom`` - The getrandom crate just provides OS entropy sources. It is not meant for random number generation. In fact, we provide it as an optional entropy source.\n\n\n### RNG Implementations\n**RNG** | **nanorand type** | **Output Size** | **Cryptographically Secure** | **Speed** 1 | **Notes** | **Original Implementation**  \n---|---|---|---|---|---|---  \nwyrand | [```nanorand`::``WyRand``](https://github.com/absolucy/nanorand-rs/blob/f7c67967cb78dde9629f78e4d8ece384089c2446/rand/wyrand/struct.WyRand.html), [```nanorand`::```tls`::``TlsWyRand``](https://github.com/absolucy/nanorand-rs/blob/f7c67967cb78dde9629f78e4d8ece384089c2446/tls/fn.tls_rng.html) | 64 bits (```u64```) | \u2261\u0192\u00dc\u00bd | 16.4 GB/s |  | <https://github.com/lemire/testingRNG/blob/master/source/wyrand.h>  \nPcg64 | [```nanorand`::``Pcg64``](https://github.com/absolucy/nanorand-rs/blob/f7c67967cb78dde9629f78e4d8ece384089c2446/rand/pcg64/struct.Pcg64.html) | 64 bits (```u64```) | \u2261\u0192\u00dc\u00bd | 1.6 GB/s |  | <https://github.com/rkern/pcg64>  \nChaCha | [```nanorand`::``ChaCha``](https://github.com/absolucy/nanorand-rs/blob/f7c67967cb78dde9629f78e4d8ece384089c2446/rand/chacha/struct.ChaCha.html) | 512 bits (```[``u32``;` `16``]```) | \u0393\u00a3\u00e0 | 204 MB/s (ChaCha8), 79 MB/s (ChaCha20) | Only works in Rust 1.47 or above | <https://cr.yp.to/chacha.html>  \n1. Speed benchmarked on an M1 Macbook Air\n### Entropy Sources\n_Listed in order of priority_\n  * If the ``getrandom`` feature is enabled, then [```getrandom`::``getrandom``](https://docs.rs/getrandom/*/getrandom/fn.getrandom.html) will be called.\n  * If the ``rdseed`` feature is enabled, and is running on an x86(-64) system with the [RDSEED](https://en.wikipedia.org/wiki/RDRAND) instruction, then we will attempt to source as much entropy as possible via our ``rdseed_entropy`` function\n  * Linux and Android will attempt to use the [``getrandom``](https://man7.org/linux/man-pages/man2/getrandom.2.html) syscall.\n  * macOS and iOS (Darwin-based systems) will use Security.framework's [``SecRandomCopyBytes``](https://developer.apple.com/documentation/security/1399291-secrandomcopybytes).\n  * Windows \n    * If we're targeting UWP, then the [``BCryptGenRandom``](https://docs.microsoft.com/en-us/windows/win32/api/bcrypt/nf-bcrypt-bcryptgenrandom) is used with system-preferred RNG (``BCRYPT_USE_SYSTEM_PREFERRED_RNG``).\n    * Otherwise, we'll use [``RtlGenRandom``](https://docs.microsoft.com/en-us/windows/win32/api/ntsecapi/nf-ntsecapi-rtlgenrandom).\n\n\n### Feature Flags\n  * ``alloc`` (default) - Enables Rust ``alloc`` lib features, such as a buffering Rng wrapper.\n  * ``std`` (default) - Enables Rust ``std`` lib features, such as seeding from OS entropy sources. Requires ``alloc`` to be enabled.\n  * ``tls`` (default) - Enables a thread-local [``WyRand``](https://github.com/absolucy/nanorand-rs/blob/f7c67967cb78dde9629f78e4d8ece384089c2446/rand/wyrand/struct.WyRand.html) RNG (see below). Requires ``std`` to be enabled.\n  * ``wyrand`` (default) - Enable the [``WyRand``](https://github.com/absolucy/nanorand-rs/blob/f7c67967cb78dde9629f78e4d8ece384089c2446/rand/wyrand/struct.WyRand.html) RNG.\n  * ``pcg64`` (default) - Enable the [``Pcg64``](https://github.com/absolucy/nanorand-rs/blob/f7c67967cb78dde9629f78e4d8ece384089c2446/rand/pcg64/struct.Pcg64.html) RNG.\n  * ``chacha`` - Enable the [``ChaCha``](https://github.com/absolucy/nanorand-rs/blob/f7c67967cb78dde9629f78e4d8ece384089c2446/rand/chacha/struct.ChaCha.html) RNG. Requires Rust 1.47 or later.\n  * ``rdseed`` - On x86 and x86-64 platforms, the ``rdseed`` intrinsic will be used when OS entropy isn't available.\n  * ``zeroize`` - Implement the [Zeroize](https://lib.rs/crates/zeroize) trait for all RNGs.\n  * ``getrandom`` - Use the [``getrandom``](https://lib.rs/crates/getrandom) crate as an entropy source. Works on most systems, optional due to the fact that it brings in more dependencies.\n\n\n## License\nThe zlib/libpng License\nCopyright (c) 2022 Lucy lucy@absolucy.moe\nThis software is provided 'as-is', without any express or implied warranty. In no event will the authors be held liable for any damages arising from the use of this software.\nPermission is granted to anyone to use this software for any purpose, including commercial applications, and to alter it and redistribute it freely, subject to the following restrictions:\n  1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n\n\n#### Dependencies\n~0\u2013380KB \n  * [ optional ](https://lib.rs/crates/nanorand/features#feature-getrandom \"getrandom is optional feature\") [getrandom](https://lib.rs/crates/getrandom \"outdated\") 0.2.5[+rdrand](https://lib.rs/crates/getrandom/features#feature-rdrand)[+js](https://lib.rs/crates/getrandom/features#feature-js)\n  * [ optional ](https://lib.rs/crates/nanorand/features#feature-zeroize \"zeroize is optional feature\") [zeroize](https://lib.rs/crates/zeroize \"1.5.3\")[+zeroize_derive](https://lib.rs/crates/zeroize/features#feature-zeroize_derive)\n\n\n  * dev  [hex](https://lib.rs/crates/hex \"0.4.3\")\n\n\n#### [Other features](https://lib.rs/crates/nanorand/features)\n  * [alloc](https://lib.rs/crates/nanorand/features#feature-alloc)\n  * [chacha](https://lib.rs/crates/nanorand/features#feature-chacha)\n  * [pcg64](https://lib.rs/crates/nanorand/features#feature-pcg64)\n  * [rdseed](https://lib.rs/crates/nanorand/features#feature-rdseed)\n  * [std](https://lib.rs/crates/nanorand/features#feature-std)\n  * [tls](https://lib.rs/crates/nanorand/features#feature-tls)\n  * [wyrand](https://lib.rs/crates/nanorand/features#feature-wyrand)\n\n\n",
              "markdown_with_citations": "###  16 unstable releases\u27e81\u27e9 (7 breaking)\n0.7.0 |  Mar 9, 2022   \n---|---  \n0.6.1 |  Jul 24, 2021   \n0.5.2 |  Dec 30, 2020   \n0.4.4 |  Sep 23, 2020   \n0.0.0 |  Sep 6, 2020   \n#**153** in Algorithms\u27e82\u27e9\nDownload history 386889/week @ 2024-12-08 317200/week @ 2024-12-15 105147/week @ 2024-12-22 171839/week @ 2024-12-29 329037/week @ 2025-01-05 366419/week @ 2025-01-12 298162/week @ 2025-01-19 346859/week @ 2025-01-26 368270/week @ 2025-02-02 478612/week @ 2025-02-09 447174/week @ 2025-02-16 553883/week @ 2025-02-23 580931/week @ 2025-03-02 588213/week @ 2025-03-09 537872/week @ 2025-03-16 528677/week @ 2025-03-23\n**2,268,795** downloads per month Used in **284** crates (67 directly)\u27e83\u27e9\n**Zlib** license \n50KB  875 lines\n![crates.io\u27e84\u27e9](https://crates.io/crates/nanorand) ![docs.rs\u27e85\u27e9](https://docs.rs/nanorand) ![License: Zlib\u27e86\u27e9](https://opensource.org/licenses/Zlib) ![Tests\u27e87\u27e9](https://github.com/Absolucy/nanorand-rs/actions?query=workflow%3A%22Run+Tests%22) ![Average time to resolve an issue\u27e88\u27e9](https://isitmaintained.com/project/Absolucy/nanorand-rs \"Average time to resolve an issue\") ![Percentage of issues still open\u27e89\u27e9](https://isitmaintained.com/project/Absolucy/nanorand-rs \"Percentage of issues still open\") ![Maintenance\u27e810\u27e9]\n# nanorand\nCurrent version: **0.7.0**\nA library meant for fast, random number generation with quick compile time, and minimal dependencies.\n## Examples\n### Generating a number with an initialized RNG\n```\n``use` `nanorand`::````{`Rng`,` WyRand```}```;`\n`let` `mut` rng `=` `WyRand`::``new`(``)``;`\n`println!``(```\"`Random number: `{}``\"```,` rng`.``generate`::````<``u64``>```(``)``)``;`\n`\n```\n\n### Generating a number with a thread-local RNG\n```\n``use` `nanorand`::``Rng`;`\n`let` `mut` rng `=` `nanorand`::``tls_rng`(``)``;`\n`println!``(```\"`Random number: `{}``\"```,` rng`.``generate`::````<``u64``>```(``)``)``;`\n`\n```\n\n### Generating a number in a range\n```\n``use` `nanorand`::````{`Rng`,` WyRand```}```;`\n`let` `mut` rng `=` `WyRand`::``new`(``)``;`\n`println!``(```\"`Random number between 1 and 100: `{}``\"```,` rng`.``generate_range``(``1_``u64``..``=``100``)``)``;`\n`println!``(```\"`Random number between -100 and 50: `{}``\"```,` rng`.``generate_range``(``-``100_``i64``..``=``50``)``)``;`\n`\n```\n\n#### Buffering random bytes\n```\n``use` `nanorand`::````{`Rng`,` BufferedRng`,` WyRand```}```;`\n`let` `mut` thingy `=` `[``0``u8``;` `5``]``;`\n`let` `mut` rng `=` `BufferedRng`::``new`(``WyRand`::``new`(``)``)``;`\nrng`.``fill``(``&``mut` thingy`)``;`\n``//` As WyRand generates 8 bytes of output, and our target is only 5 bytes,`\n``//` 3 bytes will remain in the buffer.`\n`assert_eq!``(`rng`.``buffered``(``)``,` `3``)``;`\n`\n```\n\n### Shuffling a Vec\n```\n``use` `nanorand`::````{`Rng`,` WyRand```}```;`\n`let` `mut` rng `=` `WyRand`::``new`(``)``;`\n`let` `mut` items `=` `vec!``[``1``,` `2``,` `3``,` `4``,` `5``,` `6``,` `7``,` `8``,` `9``,` `10``]``;`\nrng`.``shuffle``(``&``mut` items`)``;`\n`\n```\n\n### Why should I use this over...\n  * ``rand`` - The standard rand crate is a complex beast. It contains unsafe code in the core implementations, and while it has much more options than we do, that's kind of the point. We're straight to the point, while rand is everything and the kitchen sink.\n  * ``fastrand``, ``oorandom``, ``random-fast-rng``, or ``randomize`` - These are all minimal, zero-dep implementations of the PCG family of RNGs (Pcg32 and Pcg64). While these are decent, they are _much_ slower than wyrand (which beats the speed of these Pcg32 implementations while providing 64 random bits), and do not provide CSPRNGs.\n  * ``getrandom`` - The getrandom crate just provides OS entropy sources. It is not meant for random number generation. In fact, we provide it as an optional entropy source.\n\n\n### RNG Implementations\n**RNG** | **nanorand type** | **Output Size** | **Cryptographically Secure** | **Speed** 1 | **Notes** | **Original Implementation**  \n---|---|---|---|---|---|---  \nwyrand | ```nanorand`::``WyRand``\u27e811\u27e9, ```nanorand`::```tls`::``TlsWyRand``\u27e812\u27e9 | 64 bits (```u64```) | \u2261\u0192\u00dc\u00bd | 16.4 GB/s |  | <https://github.com/lemire/testingRNG/blob/master/source/wyrand.h>  \nPcg64 | ```nanorand`::``Pcg64``\u27e813\u27e9 | 64 bits (```u64```) | \u2261\u0192\u00dc\u00bd | 1.6 GB/s |  | <https://github.com/rkern/pcg64>  \nChaCha | ```nanorand`::``ChaCha``\u27e814\u27e9 | 512 bits (```[``u32``;` `16``]```) | \u0393\u00a3\u00e0 | 204 MB/s (ChaCha8), 79 MB/s (ChaCha20) | Only works in Rust 1.47 or above | <https://cr.yp.to/chacha.html>  \n1. Speed benchmarked on an M1 Macbook Air\n### Entropy Sources\n_Listed in order of priority_\n  * If the ``getrandom`` feature is enabled, then ```getrandom`::``getrandom``\u27e815\u27e9 will be called.\n  * If the ``rdseed`` feature is enabled, and is running on an x86(-64) system with the RDSEED\u27e816\u27e9 instruction, then we will attempt to source as much entropy as possible via our ``rdseed_entropy`` function\n  * Linux and Android will attempt to use the ``getrandom``\u27e817\u27e9 syscall.\n  * macOS and iOS (Darwin-based systems) will use Security.framework's ``SecRandomCopyBytes``\u27e818\u27e9.\n  * Windows \n    * If we're targeting UWP, then the ``BCryptGenRandom``\u27e819\u27e9 is used with system-preferred RNG (``BCRYPT_USE_SYSTEM_PREFERRED_RNG``).\n    * Otherwise, we'll use ``RtlGenRandom``\u27e820\u27e9.\n\n\n### Feature Flags\n  * ``alloc`` (default) - Enables Rust ``alloc`` lib features, such as a buffering Rng wrapper.\n  * ``std`` (default) - Enables Rust ``std`` lib features, such as seeding from OS entropy sources. Requires ``alloc`` to be enabled.\n  * ``tls`` (default) - Enables a thread-local ``WyRand``\u27e811\u27e9 RNG (see below). Requires ``std`` to be enabled.\n  * ``wyrand`` (default) - Enable the ``WyRand``\u27e811\u27e9 RNG.\n  * ``pcg64`` (default) - Enable the ``Pcg64``\u27e813\u27e9 RNG.\n  * ``chacha`` - Enable the ``ChaCha``\u27e814\u27e9 RNG. Requires Rust 1.47 or later.\n  * ``rdseed`` - On x86 and x86-64 platforms, the ``rdseed`` intrinsic will be used when OS entropy isn't available.\n  * ``zeroize`` - Implement the Zeroize\u27e821\u27e9 trait for all RNGs.\n  * ``getrandom`` - Use the ``getrandom``\u27e822\u27e9 crate as an entropy source. Works on most systems, optional due to the fact that it brings in more dependencies.\n\n\n## License\nThe zlib/libpng License\nCopyright (c) 2022 Lucy lucy@absolucy.moe\nThis software is provided 'as-is', without any express or implied warranty. In no event will the authors be held liable for any damages arising from the use of this software.\nPermission is granted to anyone to use this software for any purpose, including commercial applications, and to alter it and redistribute it freely, subject to the following restrictions:\n  1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n\n\n#### Dependencies\n~0\u2013380KB \n  *  optional \u27e823\u27e9 getrandom\u27e822\u27e9 0.2.5+rdrand\u27e824\u27e9+js\u27e825\u27e9\n  *  optional \u27e826\u27e9 zeroize\u27e821\u27e9+zeroize_derive\u27e827\u27e9\n\n\n  * dev  hex\u27e828\u27e9\n\n\n#### Other features\u27e829\u27e9\n  * alloc\u27e830\u27e9\n  * chacha\u27e831\u27e9\n  * pcg64\u27e832\u27e9\n  * rdseed\u27e833\u27e9\n  * std\u27e834\u27e9\n  * tls\u27e835\u27e9\n  * wyrand\u27e836\u27e9\n\n\n",
              "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://lib.rs/crates/nanorand/versions: 16 unstable releases\n\u27e82\u27e9 https://lib.rs/algorithms: Rust implementations of core algorithms such as hashing, sorting, searching, and more. - Algorithms\n\u27e83\u27e9 https://lib.rs/crates/nanorand/rev: **284** crates (67 directly)\n\u27e84\u27e9 https://img.shields.io/crates/v/nanorand.svg: ![crates.io\n\u27e85\u27e9 https://img.gs/czjpqfbdkz/full/https://docs.rs/nanorand/badge.svg: ![docs.rs\n\u27e86\u27e9 https://img.shields.io/badge/License-Zlib-brightgreen.svg: ![License: Zlib\n\u27e87\u27e9 https://img.gs/czjpqfbdkz/full/https://github.com/Absolucy/nanorand-rs/workflows/Tests/badge.svg?event=push&branch=master: ![Tests\n\u27e88\u27e9 https://img.gs/czjpqfbdkz/full/https://isitmaintained.com/badge/resolution/Absolucy/nanorand-rs.svg: ![Average time to resolve an issue\n\u27e89\u27e9 https://img.gs/czjpqfbdkz/full/https://isitmaintained.com/badge/open/Absolucy/nanorand-rs.svg: ![Percentage of issues still open\n\u27e810\u27e9 https://img.shields.io/badge/maintenance-activly--developed-brightgreen.svg: Maintenance\n\u27e811\u27e9 https://github.com/absolucy/nanorand-rs/blob/f7c67967cb78dde9629f78e4d8ece384089c2446/rand/wyrand/struct.WyRand.html: ```nanorand`::``WyRand``\n\u27e812\u27e9 https://github.com/absolucy/nanorand-rs/blob/f7c67967cb78dde9629f78e4d8ece384089c2446/tls/fn.tls_rng.html: ```nanorand`::```tls`::``TlsWyRand``\n\u27e813\u27e9 https://github.com/absolucy/nanorand-rs/blob/f7c67967cb78dde9629f78e4d8ece384089c2446/rand/pcg64/struct.Pcg64.html: ```nanorand`::``Pcg64``\n\u27e814\u27e9 https://github.com/absolucy/nanorand-rs/blob/f7c67967cb78dde9629f78e4d8ece384089c2446/rand/chacha/struct.ChaCha.html: ```nanorand`::``ChaCha``\n\u27e815\u27e9 https://docs.rs/getrandom/*/getrandom/fn.getrandom.html: ```getrandom`::``getrandom``\n\u27e816\u27e9 https://en.wikipedia.org/wiki/RDRAND: RDSEED\n\u27e817\u27e9 https://man7.org/linux/man-pages/man2/getrandom.2.html: ``getrandom``\n\u27e818\u27e9 https://developer.apple.com/documentation/security/1399291-secrandomcopybytes: ``SecRandomCopyBytes``\n\u27e819\u27e9 https://docs.microsoft.com/en-us/windows/win32/api/bcrypt/nf-bcrypt-bcryptgenrandom: ``BCryptGenRandom``\n\u27e820\u27e9 https://docs.microsoft.com/en-us/windows/win32/api/ntsecapi/nf-ntsecapi-rtlgenrandom: ``RtlGenRandom``\n\u27e821\u27e9 https://lib.rs/crates/zeroize: Zeroize\n\u27e822\u27e9 https://lib.rs/crates/getrandom: ``getrandom``\n\u27e823\u27e9 https://lib.rs/crates/nanorand/features#feature-getrandom: getrandom is optional feature -  optional \n\u27e824\u27e9 https://lib.rs/crates/getrandom/features#feature-rdrand: +rdrand\n\u27e825\u27e9 https://lib.rs/crates/getrandom/features#feature-js: +js\n\u27e826\u27e9 https://lib.rs/crates/nanorand/features#feature-zeroize: zeroize is optional feature -  optional \n\u27e827\u27e9 https://lib.rs/crates/zeroize/features#feature-zeroize_derive: +zeroize_derive\n\u27e828\u27e9 https://lib.rs/crates/hex: 0.4.3 - hex\n\u27e829\u27e9 https://lib.rs/crates/nanorand/features: Other features\n\u27e830\u27e9 https://lib.rs/crates/nanorand/features#feature-alloc: alloc\n\u27e831\u27e9 https://lib.rs/crates/nanorand/features#feature-chacha: chacha\n\u27e832\u27e9 https://lib.rs/crates/nanorand/features#feature-pcg64: pcg64\n\u27e833\u27e9 https://lib.rs/crates/nanorand/features#feature-rdseed: rdseed\n\u27e834\u27e9 https://lib.rs/crates/nanorand/features#feature-std: std\n\u27e835\u27e9 https://lib.rs/crates/nanorand/features#feature-tls: tls\n\u27e836\u27e9 https://lib.rs/crates/nanorand/features#feature-wyrand: wyrand\n",
              "fit_markdown": "",
              "fit_html": ""
            },
            "structured_data": {},
            "quality_score": 3.0,
            "extraction_method": "crawl4ai",
            "error": null,
            "metadata": {
              "doc_type": "docs",
              "content_length": 10251,
              "has_structured_data": false,
              "crawl_success": true
            },
            "timestamp": "114899.0987667"
          }
        },
        "crate_analysis": {
          "status": "completed",
          "check": [
            {
              "reason": "compiler-artifact",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpagi11nio/nanorand-0.8.0#nanorand@0.8.0",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpagi11nio\\nanorand-0.8.0\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "nanorand",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpagi11nio\\nanorand-0.8.0\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "alloc",
                "chacha",
                "default",
                "entropy",
                "pcg64",
                "std",
                "tls",
                "wyrand"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpagi11nio\\nanorand-0.8.0\\target\\debug\\deps\\libnanorand-5340587418e81042.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "build-finished",
              "success": true
            }
          ],
          "clippy": [
            {
              "reason": "compiler-artifact",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpagi11nio/nanorand-0.8.0#nanorand@0.8.0",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpagi11nio\\nanorand-0.8.0\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "nanorand",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpagi11nio\\nanorand-0.8.0\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "alloc",
                "chacha",
                "default",
                "entropy",
                "pcg64",
                "std",
                "tls",
                "wyrand"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpagi11nio\\nanorand-0.8.0\\target\\debug\\deps\\libnanorand-9918618c5e5f7259.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "build-finished",
              "success": true
            }
          ],
          "audit": {
            "database": {
              "advisory-count": 787,
              "last-commit": "7573f55ba337263f61167dbb0ea926cdc7c8eb5d",
              "last-updated": "2025-06-17T11:04:25+02:00"
            },
            "lockfile": {
              "dependency-count": 24
            },
            "settings": {
              "target_arch": [],
              "target_os": [],
              "severity": null,
              "ignore": [],
              "informational_warnings": [
                "unmaintained",
                "unsound",
                "notice"
              ]
            },
            "vulnerabilities": {
              "found": false,
              "count": 0,
              "list": []
            },
            "warnings": {}
          },
          "note": "Crate analysis performed with stable toolchain."
        },
        "crate_metadata": {
          "name": "nanorand",
          "version": "0.8.0",
          "description": "ALLOW: Positive community sentiment",
          "repository": "",
          "keywords": [],
          "categories": [],
          "readme": {
            "raw_markdown": "[](https://docs.rs/nanorand/latest/nanorand/all.html \"show sidebar\")\n# Crate nanorandCopy item path\n[Settings](https://docs.rs/nanorand/latest/settings.html)\n[Help](https://docs.rs/nanorand/latest/help.html)\nSummary[Source](https://docs.rs/nanorand/latest/src/nanorand/lib.rs.html#1-126)\nExpand description\nA library meant for fast, random number generation with quick compile time, and minimal dependencies.\n## [\u00a7](https://docs.rs/nanorand/latest/nanorand/#examples)Examples\n### [\u00a7](https://docs.rs/nanorand/latest/nanorand/#generating-a-number-with-an-initialized-rng)Generating a number with an initialized RNG\n```\nuse nanorand::{Rng, WyRand};\nlet mut rng = WyRand::new();\nprintln!(\"Random number: {}\", rng.generate::<u64>());\n```\n\n### [\u00a7](https://docs.rs/nanorand/latest/nanorand/#generating-a-number-with-a-thread-local-rng)Generating a number with a thread-local RNG\n```\nuse nanorand::Rng;\nlet mut rng = nanorand::tls_rng();\nprintln!(\"Random number: {}\", rng.generate::<u64>());\n```\n\n### [\u00a7](https://docs.rs/nanorand/latest/nanorand/#generating-a-number-in-a-range)Generating a number in a range\n```\nuse nanorand::{Rng, WyRand};\nlet mut rng = WyRand::new();\nprintln!(\"Random number between 1 and 100: {}\", rng.generate_range(1_u64..=100));\nprintln!(\"Random number between -100 and 50: {}\", rng.generate_range(-100_i64..=50));\n```\n\n#### [\u00a7](https://docs.rs/nanorand/latest/nanorand/#buffering-random-bytes)Buffering random bytes\n```\nuse nanorand::{Rng, BufferedRng, WyRand};\nlet mut thingy = [0u8; 5];\nlet mut rng = BufferedRng::new(WyRand::new());\nrng.fill(&mut thingy);\n// As WyRand generates 8 bytes of output, and our target is only 5 bytes,\n// 3 bytes will remain in the buffer.\nassert_eq!(rng.buffered(), 3);\n```\n\n### [\u00a7](https://docs.rs/nanorand/latest/nanorand/#shuffling-a-vec)Shuffling a Vec\n```\nuse nanorand::{Rng, WyRand};\nlet mut rng = WyRand::new();\nlet mut items = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nrng.shuffle(&mut items);\n```\n\n### [\u00a7](https://docs.rs/nanorand/latest/nanorand/#why-should-i-use-this-over)Why should I use this over\u2026\n  * `rand` - The standard rand crate is a complex beast. It contains unsafe code in the core implementations, and while it has much more options than we do, that\u2019s kind of the point. We\u2019re straight to the point, while rand is everything and the kitchen sink.\n  * `fastrand`, `oorandom`, `random-fast-rng`, or `randomize` - These are all minimal, zero-dep implementations of the PCG family of RNGs (Pcg32 and Pcg64). While these are decent, they are _much_ slower than wyrand (which beats the speed of these Pcg32 implementations while providing 64 random bits), and do not provide CSPRNGs.\n  * `getrandom` - The getrandom crate just provides OS entropy sources. It is not meant for random number generation. In fact, we provide it as an optional entropy source.\n\n\n### [\u00a7](https://docs.rs/nanorand/latest/nanorand/#rng-implementations)RNG Implementations\n**RNG**| **nanorand type**| **Output Size**| **Cryptographically Secure**| **Speed** 1| **Notes**| **Original Implementation**  \n---|---|---|---|---|---|---  \nwyrand| [`nanorand::WyRand`](https://docs.rs/nanorand/latest/nanorand/rand/wyrand/struct.WyRand.html), [`nanorand::tls::TlsWyRand`](https://docs.rs/nanorand/latest/nanorand/tls/fn.tls_rng.html)| 64 bits (`u64`)| \ud83d\udeab| 14 GB/s| | <https://github.com/lemire/testingRNG/blob/master/source/wyrand.h>  \nPcg64| [`nanorand::Pcg64`](https://docs.rs/nanorand/latest/nanorand/rand/pcg64/struct.Pcg64.html)| 64 bits (`u64`)| \ud83d\udeab| 1.6 GB/s| | <https://github.com/rkern/pcg64>  \nChaCha| [`nanorand::ChaCha`](https://docs.rs/nanorand/latest/nanorand/rand/chacha/struct.ChaCha.html)| 512 bits (`[u32; 16]`)| \u2705| 980 MB/s (ChaCha8), 749 MB/s (ChaCha12), 505 MB/s (ChaCha20)| | <https://cr.yp.to/chacha.html>  \n1. Speed benchmarked on an M1 Macbook Air\n### [\u00a7](https://docs.rs/nanorand/latest/nanorand/#entropy-sources)Entropy Sources\n_Listed in order of priority_\n  * If the `getrandom` feature is enabled, then [`getrandom::getrandom`](https://docs.rs/getrandom/*/getrandom/fn.getrandom.html) will be called, and no other entropy sources will be used.\n  * If the `rdseed` feature is enabled, and is running on an x86(-64) system with the [RDSEED](https://en.wikipedia.org/wiki/RDRAND) instruction, then we will attempt to source as much entropy as possible via our [`rdseed_entropy`](entropy::rdseed_entropy) function\n  * Linux and Android will attempt to use the [`getrandom`](https://man7.org/linux/man-pages/man2/getrandom.2.html) syscall.\n  * macOS and iOS (Darwin-based systems) will use Security.framework\u2019s [`SecRandomCopyBytes`](https://developer.apple.com/documentation/security/1399291-secrandomcopybytes).\n  * OpenBSD will attempt to use the [`arc4random_buf`](https://man.openbsd.org/arc4random.3) function.\n  * Windows \n    * If we\u2019re targeting UWP, then the [`BCryptGenRandom`](https://docs.microsoft.com/en-us/windows/win32/api/bcrypt/nf-bcrypt-bcryptgenrandom) is used with system-preferred RNG (`BCRYPT_USE_SYSTEM_PREFERRED_RNG`).\n    * Otherwise, we\u2019ll use [`RtlGenRandom`](https://docs.microsoft.com/en-us/windows/win32/api/ntsecapi/nf-ntsecapi-rtlgenrandom).\n\n\n### [\u00a7](https://docs.rs/nanorand/latest/nanorand/#feature-flags)Feature Flags\n  * `alloc` (default) - Enables Rust `alloc` lib features, such as a buffering Rng wrapper.\n  * `entropy` (default) - Allows sourcing entropy from the system. Implied by `getrandom`, too.\n  * `std` (default) - Enables Rust `std` lib features, such as seeding from OS entropy sources. Requires `alloc` to be enabled.\n  * `tls` (default) - Enables a thread-local [`WyRand`](https://docs.rs/nanorand/latest/nanorand/rand/wyrand/struct.WyRand.html) RNG (see below). Requires `std` to be enabled.\n  * `wyrand` (default) - Enable the [`WyRand`](https://docs.rs/nanorand/latest/nanorand/rand/wyrand/struct.WyRand.html) RNG.\n  * `pcg64` (default) - Enable the [`Pcg64`](https://docs.rs/nanorand/latest/nanorand/rand/pcg64/struct.Pcg64.html) RNG.\n  * `chacha` - Enable the [`ChaCha`](https://docs.rs/nanorand/latest/nanorand/rand/chacha/struct.ChaCha.html) RNG. Requires Rust 1.47 or later.\n  * `rdseed` - On x86 and x86-64 platforms, the `rdseed` intrinsic will be used when OS entropy isn\u2019t available.\n  * `zeroize` - Implement the [Zeroize](https://crates.io/crates/zeroize) trait for all RNGs.\n  * `getrandom` - Use the [`getrandom`](https://crates.io/crates/getrandom) crate as an entropy source. Works on most systems, optional due to the fact that it brings in more dependencies.\n\n\n### [\u00a7](https://docs.rs/nanorand/latest/nanorand/#msrv)MSRV\nThe minimum supported Rust version for the latest version of nanorand is **Rust 1.56.0** , released October 21st, 2021.\n## Re-exports[\u00a7](https://docs.rs/nanorand/latest/nanorand/#reexports)\n\n`pub use buffer::BufferedRng[](https://docs.rs/nanorand/latest/nanorand/buffer/struct.BufferedRng.html \"struct nanorand::buffer::BufferedRng\");``alloc`\n\n\n`pub use tls::tls_rng[](https://docs.rs/nanorand/latest/nanorand/tls/fn.tls_rng.html \"fn nanorand::tls::tls_rng\");``tls`\n\n\n`pub use gen[](https://docs.rs/nanorand/latest/nanorand/gen/index.html \"mod nanorand::gen\")::*;`\n\n\n`pub use rand[](https://docs.rs/nanorand/latest/nanorand/rand/index.html \"mod nanorand::rand\")::*;`\n\n## Modules[\u00a7](https://docs.rs/nanorand/latest/nanorand/#modules)\n\n[buffer](https://docs.rs/nanorand/latest/nanorand/buffer/index.html \"mod nanorand::buffer\")`alloc`\n    Provides a buffered wrapper for RNGs, preventing bits from being wasted.\n\n[crypto](https://docs.rs/nanorand/latest/nanorand/crypto/index.html \"mod nanorand::crypto\")\n    Implementation of cryptography, for CSPRNGs.\n\n[entropy](https://docs.rs/nanorand/latest/nanorand/entropy/index.html \"mod nanorand::entropy\")`entropy` or `getrandom`\n    Sources for obtaining entropy.\n\n[gen](https://docs.rs/nanorand/latest/nanorand/gen/index.html \"mod nanorand::gen\")\n    Traits for generating types from an RNG.\n\n[rand](https://docs.rs/nanorand/latest/nanorand/rand/index.html \"mod nanorand::rand\")\n    RNG algorithms.\n\n[tls](https://docs.rs/nanorand/latest/nanorand/tls/index.html \"mod nanorand::tls\")`tls`\n    Provides a thread-local [`WyRand`](https://docs.rs/nanorand/latest/nanorand/rand/wyrand/struct.WyRand.html \"struct nanorand::rand::wyrand::WyRand\") RNG.\n",
            "markdown_with_citations": "[](https://docs.rs/nanorand/latest/nanorand/all.html \"show sidebar\")\n# Crate nanorandCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nA library meant for fast, random number generation with quick compile time, and minimal dependencies.\n## \u00a7\u27e84\u27e9Examples\n### \u00a7\u27e85\u27e9Generating a number with an initialized RNG\n```\nuse nanorand::{Rng, WyRand};\nlet mut rng = WyRand::new();\nprintln!(\"Random number: {}\", rng.generate::<u64>());\n```\n\n### \u00a7\u27e86\u27e9Generating a number with a thread-local RNG\n```\nuse nanorand::Rng;\nlet mut rng = nanorand::tls_rng();\nprintln!(\"Random number: {}\", rng.generate::<u64>());\n```\n\n### \u00a7\u27e87\u27e9Generating a number in a range\n```\nuse nanorand::{Rng, WyRand};\nlet mut rng = WyRand::new();\nprintln!(\"Random number between 1 and 100: {}\", rng.generate_range(1_u64..=100));\nprintln!(\"Random number between -100 and 50: {}\", rng.generate_range(-100_i64..=50));\n```\n\n#### \u00a7\u27e88\u27e9Buffering random bytes\n```\nuse nanorand::{Rng, BufferedRng, WyRand};\nlet mut thingy = [0u8; 5];\nlet mut rng = BufferedRng::new(WyRand::new());\nrng.fill(&mut thingy);\n// As WyRand generates 8 bytes of output, and our target is only 5 bytes,\n// 3 bytes will remain in the buffer.\nassert_eq!(rng.buffered(), 3);\n```\n\n### \u00a7\u27e89\u27e9Shuffling a Vec\n```\nuse nanorand::{Rng, WyRand};\nlet mut rng = WyRand::new();\nlet mut items = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nrng.shuffle(&mut items);\n```\n\n### \u00a7\u27e810\u27e9Why should I use this over\u2026\n  * `rand` - The standard rand crate is a complex beast. It contains unsafe code in the core implementations, and while it has much more options than we do, that\u2019s kind of the point. We\u2019re straight to the point, while rand is everything and the kitchen sink.\n  * `fastrand`, `oorandom`, `random-fast-rng`, or `randomize` - These are all minimal, zero-dep implementations of the PCG family of RNGs (Pcg32 and Pcg64). While these are decent, they are _much_ slower than wyrand (which beats the speed of these Pcg32 implementations while providing 64 random bits), and do not provide CSPRNGs.\n  * `getrandom` - The getrandom crate just provides OS entropy sources. It is not meant for random number generation. In fact, we provide it as an optional entropy source.\n\n\n### \u00a7\u27e811\u27e9RNG Implementations\n**RNG**| **nanorand type**| **Output Size**| **Cryptographically Secure**| **Speed** 1| **Notes**| **Original Implementation**  \n---|---|---|---|---|---|---  \nwyrand| `nanorand::WyRand`\u27e812\u27e9, `nanorand::tls::TlsWyRand`\u27e813\u27e9| 64 bits (`u64`)| \ud83d\udeab| 14 GB/s| | <https://github.com/lemire/testingRNG/blob/master/source/wyrand.h>  \nPcg64| `nanorand::Pcg64`\u27e814\u27e9| 64 bits (`u64`)| \ud83d\udeab| 1.6 GB/s| | <https://github.com/rkern/pcg64>  \nChaCha| `nanorand::ChaCha`\u27e815\u27e9| 512 bits (`[u32; 16]`)| \u2705| 980 MB/s (ChaCha8), 749 MB/s (ChaCha12), 505 MB/s (ChaCha20)| | <https://cr.yp.to/chacha.html>  \n1. Speed benchmarked on an M1 Macbook Air\n### \u00a7\u27e816\u27e9Entropy Sources\n_Listed in order of priority_\n  * If the `getrandom` feature is enabled, then `getrandom::getrandom`\u27e817\u27e9 will be called, and no other entropy sources will be used.\n  * If the `rdseed` feature is enabled, and is running on an x86(-64) system with the RDSEED\u27e818\u27e9 instruction, then we will attempt to source as much entropy as possible via our `rdseed_entropy`\u27e819\u27e9 function\n  * Linux and Android will attempt to use the `getrandom`\u27e820\u27e9 syscall.\n  * macOS and iOS (Darwin-based systems) will use Security.framework\u2019s `SecRandomCopyBytes`\u27e821\u27e9.\n  * OpenBSD will attempt to use the `arc4random_buf`\u27e822\u27e9 function.\n  * Windows \n    * If we\u2019re targeting UWP, then the `BCryptGenRandom`\u27e823\u27e9 is used with system-preferred RNG (`BCRYPT_USE_SYSTEM_PREFERRED_RNG`).\n    * Otherwise, we\u2019ll use `RtlGenRandom`\u27e824\u27e9.\n\n\n### \u00a7\u27e825\u27e9Feature Flags\n  * `alloc` (default) - Enables Rust `alloc` lib features, such as a buffering Rng wrapper.\n  * `entropy` (default) - Allows sourcing entropy from the system. Implied by `getrandom`, too.\n  * `std` (default) - Enables Rust `std` lib features, such as seeding from OS entropy sources. Requires `alloc` to be enabled.\n  * `tls` (default) - Enables a thread-local `WyRand`\u27e812\u27e9 RNG (see below). Requires `std` to be enabled.\n  * `wyrand` (default) - Enable the `WyRand`\u27e812\u27e9 RNG.\n  * `pcg64` (default) - Enable the `Pcg64`\u27e814\u27e9 RNG.\n  * `chacha` - Enable the `ChaCha`\u27e815\u27e9 RNG. Requires Rust 1.47 or later.\n  * `rdseed` - On x86 and x86-64 platforms, the `rdseed` intrinsic will be used when OS entropy isn\u2019t available.\n  * `zeroize` - Implement the Zeroize\u27e826\u27e9 trait for all RNGs.\n  * `getrandom` - Use the `getrandom`\u27e827\u27e9 crate as an entropy source. Works on most systems, optional due to the fact that it brings in more dependencies.\n\n\n### \u00a7\u27e828\u27e9MSRV\nThe minimum supported Rust version for the latest version of nanorand is **Rust 1.56.0** , released October 21st, 2021.\n## Re-exports\u00a7\u27e829\u27e9\n\n`pub use buffer::BufferedRng[](https://docs.rs/nanorand/latest/nanorand/buffer/struct.BufferedRng.html \"struct nanorand::buffer::BufferedRng\");``alloc`\n\n\n`pub use tls::tls_rng[](https://docs.rs/nanorand/latest/nanorand/tls/fn.tls_rng.html \"fn nanorand::tls::tls_rng\");``tls`\n\n\n`pub use gen[](https://docs.rs/nanorand/latest/nanorand/gen/index.html \"mod nanorand::gen\")::*;`\n\n\n`pub use rand[](https://docs.rs/nanorand/latest/nanorand/rand/index.html \"mod nanorand::rand\")::*;`\n\n## Modules\u00a7\u27e830\u27e9\n\nbuffer\u27e831\u27e9`alloc`\n    Provides a buffered wrapper for RNGs, preventing bits from being wasted.\n\ncrypto\u27e832\u27e9\n    Implementation of cryptography, for CSPRNGs.\n\nentropy\u27e833\u27e9`entropy` or `getrandom`\n    Sources for obtaining entropy.\n\ngen\u27e834\u27e9\n    Traits for generating types from an RNG.\n\nrand\u27e835\u27e9\n    RNG algorithms.\n\ntls\u27e836\u27e9`tls`\n    Provides a thread-local `WyRand`\u27e812\u27e9 RNG.\n",
            "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/nanorand/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/nanorand/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/nanorand/latest/src/nanorand/lib.rs.html#1-126: Source\n\u27e84\u27e9 https://docs.rs/nanorand/latest/nanorand/#examples: \u00a7\n\u27e85\u27e9 https://docs.rs/nanorand/latest/nanorand/#generating-a-number-with-an-initialized-rng: \u00a7\n\u27e86\u27e9 https://docs.rs/nanorand/latest/nanorand/#generating-a-number-with-a-thread-local-rng: \u00a7\n\u27e87\u27e9 https://docs.rs/nanorand/latest/nanorand/#generating-a-number-in-a-range: \u00a7\n\u27e88\u27e9 https://docs.rs/nanorand/latest/nanorand/#buffering-random-bytes: \u00a7\n\u27e89\u27e9 https://docs.rs/nanorand/latest/nanorand/#shuffling-a-vec: \u00a7\n\u27e810\u27e9 https://docs.rs/nanorand/latest/nanorand/#why-should-i-use-this-over: \u00a7\n\u27e811\u27e9 https://docs.rs/nanorand/latest/nanorand/#rng-implementations: \u00a7\n\u27e812\u27e9 https://docs.rs/nanorand/latest/nanorand/rand/wyrand/struct.WyRand.html: `nanorand::WyRand`\n\u27e813\u27e9 https://docs.rs/nanorand/latest/nanorand/tls/fn.tls_rng.html: `nanorand::tls::TlsWyRand`\n\u27e814\u27e9 https://docs.rs/nanorand/latest/nanorand/rand/pcg64/struct.Pcg64.html: `nanorand::Pcg64`\n\u27e815\u27e9 https://docs.rs/nanorand/latest/nanorand/rand/chacha/struct.ChaCha.html: `nanorand::ChaCha`\n\u27e816\u27e9 https://docs.rs/nanorand/latest/nanorand/#entropy-sources: \u00a7\n\u27e817\u27e9 https://docs.rs/getrandom/*/getrandom/fn.getrandom.html: `getrandom::getrandom`\n\u27e818\u27e9 https://en.wikipedia.org/wiki/RDRAND: RDSEED\n\u27e819\u27e9 entropy::rdseed_entropy: `rdseed_entropy`\n\u27e820\u27e9 https://man7.org/linux/man-pages/man2/getrandom.2.html: `getrandom`\n\u27e821\u27e9 https://developer.apple.com/documentation/security/1399291-secrandomcopybytes: `SecRandomCopyBytes`\n\u27e822\u27e9 https://man.openbsd.org/arc4random.3: `arc4random_buf`\n\u27e823\u27e9 https://docs.microsoft.com/en-us/windows/win32/api/bcrypt/nf-bcrypt-bcryptgenrandom: `BCryptGenRandom`\n\u27e824\u27e9 https://docs.microsoft.com/en-us/windows/win32/api/ntsecapi/nf-ntsecapi-rtlgenrandom: `RtlGenRandom`\n\u27e825\u27e9 https://docs.rs/nanorand/latest/nanorand/#feature-flags: \u00a7\n\u27e826\u27e9 https://crates.io/crates/zeroize: Zeroize\n\u27e827\u27e9 https://crates.io/crates/getrandom: `getrandom`\n\u27e828\u27e9 https://docs.rs/nanorand/latest/nanorand/#msrv: \u00a7\n\u27e829\u27e9 https://docs.rs/nanorand/latest/nanorand/#reexports: \u00a7\n\u27e830\u27e9 https://docs.rs/nanorand/latest/nanorand/#modules: \u00a7\n\u27e831\u27e9 https://docs.rs/nanorand/latest/nanorand/buffer/index.html: mod nanorand::buffer - buffer\n\u27e832\u27e9 https://docs.rs/nanorand/latest/nanorand/crypto/index.html: mod nanorand::crypto - crypto\n\u27e833\u27e9 https://docs.rs/nanorand/latest/nanorand/entropy/index.html: mod nanorand::entropy - entropy\n\u27e834\u27e9 https://docs.rs/nanorand/latest/nanorand/gen/index.html: mod nanorand::gen - gen\n\u27e835\u27e9 https://docs.rs/nanorand/latest/nanorand/rand/index.html: mod nanorand::rand - rand\n\u27e836\u27e9 https://docs.rs/nanorand/latest/nanorand/tls/index.html: mod nanorand::tls - tls\n",
            "fit_markdown": "",
            "fit_html": ""
          },
          "downloads": 0,
          "github_stars": 0,
          "dependencies": [],
          "features": {},
          "code_snippets": [],
          "readme_sections": {},
          "librs_downloads": null,
          "source": "crates.io",
          "enhanced_scraping": {},
          "enhanced_features": [],
          "enhanced_dependencies": []
        },
        "enriched_crate": {
          "name": "nanorand",
          "version": "0.8.0",
          "description": "ALLOW: Positive community sentiment",
          "repository": "",
          "keywords": [],
          "categories": [],
          "readme": {
            "raw_markdown": "[](https://docs.rs/nanorand/latest/nanorand/all.html \"show sidebar\")\n# Crate nanorandCopy item path\n[Settings](https://docs.rs/nanorand/latest/settings.html)\n[Help](https://docs.rs/nanorand/latest/help.html)\nSummary[Source](https://docs.rs/nanorand/latest/src/nanorand/lib.rs.html#1-126)\nExpand description\nA library meant for fast, random number generation with quick compile time, and minimal dependencies.\n## [\u00a7](https://docs.rs/nanorand/latest/nanorand/#examples)Examples\n### [\u00a7](https://docs.rs/nanorand/latest/nanorand/#generating-a-number-with-an-initialized-rng)Generating a number with an initialized RNG\n```\nuse nanorand::{Rng, WyRand};\nlet mut rng = WyRand::new();\nprintln!(\"Random number: {}\", rng.generate::<u64>());\n```\n\n### [\u00a7](https://docs.rs/nanorand/latest/nanorand/#generating-a-number-with-a-thread-local-rng)Generating a number with a thread-local RNG\n```\nuse nanorand::Rng;\nlet mut rng = nanorand::tls_rng();\nprintln!(\"Random number: {}\", rng.generate::<u64>());\n```\n\n### [\u00a7](https://docs.rs/nanorand/latest/nanorand/#generating-a-number-in-a-range)Generating a number in a range\n```\nuse nanorand::{Rng, WyRand};\nlet mut rng = WyRand::new();\nprintln!(\"Random number between 1 and 100: {}\", rng.generate_range(1_u64..=100));\nprintln!(\"Random number between -100 and 50: {}\", rng.generate_range(-100_i64..=50));\n```\n\n#### [\u00a7](https://docs.rs/nanorand/latest/nanorand/#buffering-random-bytes)Buffering random bytes\n```\nuse nanorand::{Rng, BufferedRng, WyRand};\nlet mut thingy = [0u8; 5];\nlet mut rng = BufferedRng::new(WyRand::new());\nrng.fill(&mut thingy);\n// As WyRand generates 8 bytes of output, and our target is only 5 bytes,\n// 3 bytes will remain in the buffer.\nassert_eq!(rng.buffered(), 3);\n```\n\n### [\u00a7](https://docs.rs/nanorand/latest/nanorand/#shuffling-a-vec)Shuffling a Vec\n```\nuse nanorand::{Rng, WyRand};\nlet mut rng = WyRand::new();\nlet mut items = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nrng.shuffle(&mut items);\n```\n\n### [\u00a7](https://docs.rs/nanorand/latest/nanorand/#why-should-i-use-this-over)Why should I use this over\u2026\n  * `rand` - The standard rand crate is a complex beast. It contains unsafe code in the core implementations, and while it has much more options than we do, that\u2019s kind of the point. We\u2019re straight to the point, while rand is everything and the kitchen sink.\n  * `fastrand`, `oorandom`, `random-fast-rng`, or `randomize` - These are all minimal, zero-dep implementations of the PCG family of RNGs (Pcg32 and Pcg64). While these are decent, they are _much_ slower than wyrand (which beats the speed of these Pcg32 implementations while providing 64 random bits), and do not provide CSPRNGs.\n  * `getrandom` - The getrandom crate just provides OS entropy sources. It is not meant for random number generation. In fact, we provide it as an optional entropy source.\n\n\n### [\u00a7](https://docs.rs/nanorand/latest/nanorand/#rng-implementations)RNG Implementations\n**RNG**| **nanorand type**| **Output Size**| **Cryptographically Secure**| **Speed** 1| **Notes**| **Original Implementation**  \n---|---|---|---|---|---|---  \nwyrand| [`nanorand::WyRand`](https://docs.rs/nanorand/latest/nanorand/rand/wyrand/struct.WyRand.html), [`nanorand::tls::TlsWyRand`](https://docs.rs/nanorand/latest/nanorand/tls/fn.tls_rng.html)| 64 bits (`u64`)| \ud83d\udeab| 14 GB/s| | <https://github.com/lemire/testingRNG/blob/master/source/wyrand.h>  \nPcg64| [`nanorand::Pcg64`](https://docs.rs/nanorand/latest/nanorand/rand/pcg64/struct.Pcg64.html)| 64 bits (`u64`)| \ud83d\udeab| 1.6 GB/s| | <https://github.com/rkern/pcg64>  \nChaCha| [`nanorand::ChaCha`](https://docs.rs/nanorand/latest/nanorand/rand/chacha/struct.ChaCha.html)| 512 bits (`[u32; 16]`)| \u2705| 980 MB/s (ChaCha8), 749 MB/s (ChaCha12), 505 MB/s (ChaCha20)| | <https://cr.yp.to/chacha.html>  \n1. Speed benchmarked on an M1 Macbook Air\n### [\u00a7](https://docs.rs/nanorand/latest/nanorand/#entropy-sources)Entropy Sources\n_Listed in order of priority_\n  * If the `getrandom` feature is enabled, then [`getrandom::getrandom`](https://docs.rs/getrandom/*/getrandom/fn.getrandom.html) will be called, and no other entropy sources will be used.\n  * If the `rdseed` feature is enabled, and is running on an x86(-64) system with the [RDSEED](https://en.wikipedia.org/wiki/RDRAND) instruction, then we will attempt to source as much entropy as possible via our [`rdseed_entropy`](entropy::rdseed_entropy) function\n  * Linux and Android will attempt to use the [`getrandom`](https://man7.org/linux/man-pages/man2/getrandom.2.html) syscall.\n  * macOS and iOS (Darwin-based systems) will use Security.framework\u2019s [`SecRandomCopyBytes`](https://developer.apple.com/documentation/security/1399291-secrandomcopybytes).\n  * OpenBSD will attempt to use the [`arc4random_buf`](https://man.openbsd.org/arc4random.3) function.\n  * Windows \n    * If we\u2019re targeting UWP, then the [`BCryptGenRandom`](https://docs.microsoft.com/en-us/windows/win32/api/bcrypt/nf-bcrypt-bcryptgenrandom) is used with system-preferred RNG (`BCRYPT_USE_SYSTEM_PREFERRED_RNG`).\n    * Otherwise, we\u2019ll use [`RtlGenRandom`](https://docs.microsoft.com/en-us/windows/win32/api/ntsecapi/nf-ntsecapi-rtlgenrandom).\n\n\n### [\u00a7](https://docs.rs/nanorand/latest/nanorand/#feature-flags)Feature Flags\n  * `alloc` (default) - Enables Rust `alloc` lib features, such as a buffering Rng wrapper.\n  * `entropy` (default) - Allows sourcing entropy from the system. Implied by `getrandom`, too.\n  * `std` (default) - Enables Rust `std` lib features, such as seeding from OS entropy sources. Requires `alloc` to be enabled.\n  * `tls` (default) - Enables a thread-local [`WyRand`](https://docs.rs/nanorand/latest/nanorand/rand/wyrand/struct.WyRand.html) RNG (see below). Requires `std` to be enabled.\n  * `wyrand` (default) - Enable the [`WyRand`](https://docs.rs/nanorand/latest/nanorand/rand/wyrand/struct.WyRand.html) RNG.\n  * `pcg64` (default) - Enable the [`Pcg64`](https://docs.rs/nanorand/latest/nanorand/rand/pcg64/struct.Pcg64.html) RNG.\n  * `chacha` - Enable the [`ChaCha`](https://docs.rs/nanorand/latest/nanorand/rand/chacha/struct.ChaCha.html) RNG. Requires Rust 1.47 or later.\n  * `rdseed` - On x86 and x86-64 platforms, the `rdseed` intrinsic will be used when OS entropy isn\u2019t available.\n  * `zeroize` - Implement the [Zeroize](https://crates.io/crates/zeroize) trait for all RNGs.\n  * `getrandom` - Use the [`getrandom`](https://crates.io/crates/getrandom) crate as an entropy source. Works on most systems, optional due to the fact that it brings in more dependencies.\n\n\n### [\u00a7](https://docs.rs/nanorand/latest/nanorand/#msrv)MSRV\nThe minimum supported Rust version for the latest version of nanorand is **Rust 1.56.0** , released October 21st, 2021.\n## Re-exports[\u00a7](https://docs.rs/nanorand/latest/nanorand/#reexports)\n\n`pub use buffer::BufferedRng[](https://docs.rs/nanorand/latest/nanorand/buffer/struct.BufferedRng.html \"struct nanorand::buffer::BufferedRng\");``alloc`\n\n\n`pub use tls::tls_rng[](https://docs.rs/nanorand/latest/nanorand/tls/fn.tls_rng.html \"fn nanorand::tls::tls_rng\");``tls`\n\n\n`pub use gen[](https://docs.rs/nanorand/latest/nanorand/gen/index.html \"mod nanorand::gen\")::*;`\n\n\n`pub use rand[](https://docs.rs/nanorand/latest/nanorand/rand/index.html \"mod nanorand::rand\")::*;`\n\n## Modules[\u00a7](https://docs.rs/nanorand/latest/nanorand/#modules)\n\n[buffer](https://docs.rs/nanorand/latest/nanorand/buffer/index.html \"mod nanorand::buffer\")`alloc`\n    Provides a buffered wrapper for RNGs, preventing bits from being wasted.\n\n[crypto](https://docs.rs/nanorand/latest/nanorand/crypto/index.html \"mod nanorand::crypto\")\n    Implementation of cryptography, for CSPRNGs.\n\n[entropy](https://docs.rs/nanorand/latest/nanorand/entropy/index.html \"mod nanorand::entropy\")`entropy` or `getrandom`\n    Sources for obtaining entropy.\n\n[gen](https://docs.rs/nanorand/latest/nanorand/gen/index.html \"mod nanorand::gen\")\n    Traits for generating types from an RNG.\n\n[rand](https://docs.rs/nanorand/latest/nanorand/rand/index.html \"mod nanorand::rand\")\n    RNG algorithms.\n\n[tls](https://docs.rs/nanorand/latest/nanorand/tls/index.html \"mod nanorand::tls\")`tls`\n    Provides a thread-local [`WyRand`](https://docs.rs/nanorand/latest/nanorand/rand/wyrand/struct.WyRand.html \"struct nanorand::rand::wyrand::WyRand\") RNG.\n",
            "markdown_with_citations": "[](https://docs.rs/nanorand/latest/nanorand/all.html \"show sidebar\")\n# Crate nanorandCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nA library meant for fast, random number generation with quick compile time, and minimal dependencies.\n## \u00a7\u27e84\u27e9Examples\n### \u00a7\u27e85\u27e9Generating a number with an initialized RNG\n```\nuse nanorand::{Rng, WyRand};\nlet mut rng = WyRand::new();\nprintln!(\"Random number: {}\", rng.generate::<u64>());\n```\n\n### \u00a7\u27e86\u27e9Generating a number with a thread-local RNG\n```\nuse nanorand::Rng;\nlet mut rng = nanorand::tls_rng();\nprintln!(\"Random number: {}\", rng.generate::<u64>());\n```\n\n### \u00a7\u27e87\u27e9Generating a number in a range\n```\nuse nanorand::{Rng, WyRand};\nlet mut rng = WyRand::new();\nprintln!(\"Random number between 1 and 100: {}\", rng.generate_range(1_u64..=100));\nprintln!(\"Random number between -100 and 50: {}\", rng.generate_range(-100_i64..=50));\n```\n\n#### \u00a7\u27e88\u27e9Buffering random bytes\n```\nuse nanorand::{Rng, BufferedRng, WyRand};\nlet mut thingy = [0u8; 5];\nlet mut rng = BufferedRng::new(WyRand::new());\nrng.fill(&mut thingy);\n// As WyRand generates 8 bytes of output, and our target is only 5 bytes,\n// 3 bytes will remain in the buffer.\nassert_eq!(rng.buffered(), 3);\n```\n\n### \u00a7\u27e89\u27e9Shuffling a Vec\n```\nuse nanorand::{Rng, WyRand};\nlet mut rng = WyRand::new();\nlet mut items = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nrng.shuffle(&mut items);\n```\n\n### \u00a7\u27e810\u27e9Why should I use this over\u2026\n  * `rand` - The standard rand crate is a complex beast. It contains unsafe code in the core implementations, and while it has much more options than we do, that\u2019s kind of the point. We\u2019re straight to the point, while rand is everything and the kitchen sink.\n  * `fastrand`, `oorandom`, `random-fast-rng`, or `randomize` - These are all minimal, zero-dep implementations of the PCG family of RNGs (Pcg32 and Pcg64). While these are decent, they are _much_ slower than wyrand (which beats the speed of these Pcg32 implementations while providing 64 random bits), and do not provide CSPRNGs.\n  * `getrandom` - The getrandom crate just provides OS entropy sources. It is not meant for random number generation. In fact, we provide it as an optional entropy source.\n\n\n### \u00a7\u27e811\u27e9RNG Implementations\n**RNG**| **nanorand type**| **Output Size**| **Cryptographically Secure**| **Speed** 1| **Notes**| **Original Implementation**  \n---|---|---|---|---|---|---  \nwyrand| `nanorand::WyRand`\u27e812\u27e9, `nanorand::tls::TlsWyRand`\u27e813\u27e9| 64 bits (`u64`)| \ud83d\udeab| 14 GB/s| | <https://github.com/lemire/testingRNG/blob/master/source/wyrand.h>  \nPcg64| `nanorand::Pcg64`\u27e814\u27e9| 64 bits (`u64`)| \ud83d\udeab| 1.6 GB/s| | <https://github.com/rkern/pcg64>  \nChaCha| `nanorand::ChaCha`\u27e815\u27e9| 512 bits (`[u32; 16]`)| \u2705| 980 MB/s (ChaCha8), 749 MB/s (ChaCha12), 505 MB/s (ChaCha20)| | <https://cr.yp.to/chacha.html>  \n1. Speed benchmarked on an M1 Macbook Air\n### \u00a7\u27e816\u27e9Entropy Sources\n_Listed in order of priority_\n  * If the `getrandom` feature is enabled, then `getrandom::getrandom`\u27e817\u27e9 will be called, and no other entropy sources will be used.\n  * If the `rdseed` feature is enabled, and is running on an x86(-64) system with the RDSEED\u27e818\u27e9 instruction, then we will attempt to source as much entropy as possible via our `rdseed_entropy`\u27e819\u27e9 function\n  * Linux and Android will attempt to use the `getrandom`\u27e820\u27e9 syscall.\n  * macOS and iOS (Darwin-based systems) will use Security.framework\u2019s `SecRandomCopyBytes`\u27e821\u27e9.\n  * OpenBSD will attempt to use the `arc4random_buf`\u27e822\u27e9 function.\n  * Windows \n    * If we\u2019re targeting UWP, then the `BCryptGenRandom`\u27e823\u27e9 is used with system-preferred RNG (`BCRYPT_USE_SYSTEM_PREFERRED_RNG`).\n    * Otherwise, we\u2019ll use `RtlGenRandom`\u27e824\u27e9.\n\n\n### \u00a7\u27e825\u27e9Feature Flags\n  * `alloc` (default) - Enables Rust `alloc` lib features, such as a buffering Rng wrapper.\n  * `entropy` (default) - Allows sourcing entropy from the system. Implied by `getrandom`, too.\n  * `std` (default) - Enables Rust `std` lib features, such as seeding from OS entropy sources. Requires `alloc` to be enabled.\n  * `tls` (default) - Enables a thread-local `WyRand`\u27e812\u27e9 RNG (see below). Requires `std` to be enabled.\n  * `wyrand` (default) - Enable the `WyRand`\u27e812\u27e9 RNG.\n  * `pcg64` (default) - Enable the `Pcg64`\u27e814\u27e9 RNG.\n  * `chacha` - Enable the `ChaCha`\u27e815\u27e9 RNG. Requires Rust 1.47 or later.\n  * `rdseed` - On x86 and x86-64 platforms, the `rdseed` intrinsic will be used when OS entropy isn\u2019t available.\n  * `zeroize` - Implement the Zeroize\u27e826\u27e9 trait for all RNGs.\n  * `getrandom` - Use the `getrandom`\u27e827\u27e9 crate as an entropy source. Works on most systems, optional due to the fact that it brings in more dependencies.\n\n\n### \u00a7\u27e828\u27e9MSRV\nThe minimum supported Rust version for the latest version of nanorand is **Rust 1.56.0** , released October 21st, 2021.\n## Re-exports\u00a7\u27e829\u27e9\n\n`pub use buffer::BufferedRng[](https://docs.rs/nanorand/latest/nanorand/buffer/struct.BufferedRng.html \"struct nanorand::buffer::BufferedRng\");``alloc`\n\n\n`pub use tls::tls_rng[](https://docs.rs/nanorand/latest/nanorand/tls/fn.tls_rng.html \"fn nanorand::tls::tls_rng\");``tls`\n\n\n`pub use gen[](https://docs.rs/nanorand/latest/nanorand/gen/index.html \"mod nanorand::gen\")::*;`\n\n\n`pub use rand[](https://docs.rs/nanorand/latest/nanorand/rand/index.html \"mod nanorand::rand\")::*;`\n\n## Modules\u00a7\u27e830\u27e9\n\nbuffer\u27e831\u27e9`alloc`\n    Provides a buffered wrapper for RNGs, preventing bits from being wasted.\n\ncrypto\u27e832\u27e9\n    Implementation of cryptography, for CSPRNGs.\n\nentropy\u27e833\u27e9`entropy` or `getrandom`\n    Sources for obtaining entropy.\n\ngen\u27e834\u27e9\n    Traits for generating types from an RNG.\n\nrand\u27e835\u27e9\n    RNG algorithms.\n\ntls\u27e836\u27e9`tls`\n    Provides a thread-local `WyRand`\u27e812\u27e9 RNG.\n",
            "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/nanorand/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/nanorand/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/nanorand/latest/src/nanorand/lib.rs.html#1-126: Source\n\u27e84\u27e9 https://docs.rs/nanorand/latest/nanorand/#examples: \u00a7\n\u27e85\u27e9 https://docs.rs/nanorand/latest/nanorand/#generating-a-number-with-an-initialized-rng: \u00a7\n\u27e86\u27e9 https://docs.rs/nanorand/latest/nanorand/#generating-a-number-with-a-thread-local-rng: \u00a7\n\u27e87\u27e9 https://docs.rs/nanorand/latest/nanorand/#generating-a-number-in-a-range: \u00a7\n\u27e88\u27e9 https://docs.rs/nanorand/latest/nanorand/#buffering-random-bytes: \u00a7\n\u27e89\u27e9 https://docs.rs/nanorand/latest/nanorand/#shuffling-a-vec: \u00a7\n\u27e810\u27e9 https://docs.rs/nanorand/latest/nanorand/#why-should-i-use-this-over: \u00a7\n\u27e811\u27e9 https://docs.rs/nanorand/latest/nanorand/#rng-implementations: \u00a7\n\u27e812\u27e9 https://docs.rs/nanorand/latest/nanorand/rand/wyrand/struct.WyRand.html: `nanorand::WyRand`\n\u27e813\u27e9 https://docs.rs/nanorand/latest/nanorand/tls/fn.tls_rng.html: `nanorand::tls::TlsWyRand`\n\u27e814\u27e9 https://docs.rs/nanorand/latest/nanorand/rand/pcg64/struct.Pcg64.html: `nanorand::Pcg64`\n\u27e815\u27e9 https://docs.rs/nanorand/latest/nanorand/rand/chacha/struct.ChaCha.html: `nanorand::ChaCha`\n\u27e816\u27e9 https://docs.rs/nanorand/latest/nanorand/#entropy-sources: \u00a7\n\u27e817\u27e9 https://docs.rs/getrandom/*/getrandom/fn.getrandom.html: `getrandom::getrandom`\n\u27e818\u27e9 https://en.wikipedia.org/wiki/RDRAND: RDSEED\n\u27e819\u27e9 entropy::rdseed_entropy: `rdseed_entropy`\n\u27e820\u27e9 https://man7.org/linux/man-pages/man2/getrandom.2.html: `getrandom`\n\u27e821\u27e9 https://developer.apple.com/documentation/security/1399291-secrandomcopybytes: `SecRandomCopyBytes`\n\u27e822\u27e9 https://man.openbsd.org/arc4random.3: `arc4random_buf`\n\u27e823\u27e9 https://docs.microsoft.com/en-us/windows/win32/api/bcrypt/nf-bcrypt-bcryptgenrandom: `BCryptGenRandom`\n\u27e824\u27e9 https://docs.microsoft.com/en-us/windows/win32/api/ntsecapi/nf-ntsecapi-rtlgenrandom: `RtlGenRandom`\n\u27e825\u27e9 https://docs.rs/nanorand/latest/nanorand/#feature-flags: \u00a7\n\u27e826\u27e9 https://crates.io/crates/zeroize: Zeroize\n\u27e827\u27e9 https://crates.io/crates/getrandom: `getrandom`\n\u27e828\u27e9 https://docs.rs/nanorand/latest/nanorand/#msrv: \u00a7\n\u27e829\u27e9 https://docs.rs/nanorand/latest/nanorand/#reexports: \u00a7\n\u27e830\u27e9 https://docs.rs/nanorand/latest/nanorand/#modules: \u00a7\n\u27e831\u27e9 https://docs.rs/nanorand/latest/nanorand/buffer/index.html: mod nanorand::buffer - buffer\n\u27e832\u27e9 https://docs.rs/nanorand/latest/nanorand/crypto/index.html: mod nanorand::crypto - crypto\n\u27e833\u27e9 https://docs.rs/nanorand/latest/nanorand/entropy/index.html: mod nanorand::entropy - entropy\n\u27e834\u27e9 https://docs.rs/nanorand/latest/nanorand/gen/index.html: mod nanorand::gen - gen\n\u27e835\u27e9 https://docs.rs/nanorand/latest/nanorand/rand/index.html: mod nanorand::rand - rand\n\u27e836\u27e9 https://docs.rs/nanorand/latest/nanorand/tls/index.html: mod nanorand::tls - tls\n",
            "fit_markdown": "",
            "fit_html": ""
          },
          "downloads": 0,
          "github_stars": 0,
          "dependencies": [],
          "features": {},
          "code_snippets": [],
          "readme_sections": {},
          "librs_downloads": null,
          "source": "crates.io",
          "enhanced_scraping": {},
          "enhanced_features": [],
          "enhanced_dependencies": [],
          "readme_summary": "The `nanorand` crate is a lightweight, fast random number generation library with minimal dependencies and quick compile times. It supports multiple RNG implementations, including `WyRand`, `Pcg64`, and `ChaCha`, with options for cryptographically secure generation and thread-local RNGs. Key features include range-based generation, buffered random bytes, vector shuffling, and configurable entropy sources via feature flags like `getrandom` and `rdseed`.",
          "feature_summary": null,
          "use_case": "Utilities",
          "score": 6.0,
          "factual_counterfactual": "### Pair 1: Feature Flags and Entropy Sources  \n\u2705 Factual: The `nanorand` crate provides an optional `getrandom` feature flag, allowing it to use the `getrandom` crate as an entropy source for randomness.  \n\u274c Counterfactual: The `nanorand` crate requires the `getrandom` feature flag to function, as it depends entirely on OS entropy sources.  \n\n---\n\n### Pair 2: RNG Implementations and Cryptographic Security  \n\u2705 Factual: The `ChaCha` RNG provided by `nanorand` is cryptographically secure and outputs 512 bits of random data, making it suitable for security-sensitive applications.  \n\u274c Counterfactual: The `WyRand` RNG provided by `nanorand` is cryptographically secure and outputs 512 bits of random data, making it ideal for cryptographic use cases.  \n\n---\n\n### Pair 3: Performance Characteristics  \n\u2705 Factual: The `WyRand` RNG in `nanorand` achieves an impressive speed of 14 GB/s, making it one of the fastest RNGs in the crate.  \n\u274c Counterfactual: The `Pcg64` RNG in `nanorand` achieves a speed of 14 GB/s, outperforming the `WyRand` RNG in terms of raw performance.",
          "source_analysis": null,
          "user_behavior": null,
          "security": null
        }
      },
      "irl_score": 8.6,
      "execution_id": "exec-e4aa25e5-91ef105d-1751261108",
      "timestamp": "2025-06-30T05:25:08.018327+00:00",
      "canon_version": "1.3.0"
    },
    "rule_zero_compliant": true
  }
]