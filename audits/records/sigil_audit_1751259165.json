[
  {
    "execution_id": "exec-bd8dc2d9-1631cfa6-1751259154",
    "timestamp": "2025-06-30T04:52:34.265623+00:00",
    "sacred_chain": {
      "input_data": "quick-xml",
      "context_sources": [
        "crates.io",
        "github.com",
        "lib.rs",
        "docs.rs"
      ],
      "reasoning_steps": [
        "Input canonicalized: 'quick-xml' -> 'quick-xml'",
        "Context gathered from 4 validated sources",
        "Metadata extracted: 4 fields",
        "Documentation analyzed: quality 7.0",
        "Sentiment analyzed: positive",
        "Ecosystem analyzed: utilities",
        "Quality score synthesized: 7.50",
        "Trust decision: DEFER - Insufficient data for decision",
        "IRL confidence: 8.600"
      ],
      "suggestion": "ALLOW: Positive community sentiment",
      "verdict": "DEFER",
      "audit_info": {
        "metadata": {
          "name": "quick-xml",
          "type": "rust_crate",
          "source": "manual_input",
          "extraction_method": "irl_engine"
        },
        "sentiment": {
          "quality_score": 7.0,
          "completeness": 0.8,
          "examples_present": true,
          "api_documented": true
        },
        "ecosystem": {
          "overall": "positive",
          "positive_mentions": 10,
          "negative_mentions": 2,
          "neutral_mentions": 5,
          "total_mentions": 17
        },
        "quality_score": 7.5,
        "verdict_reason": "Insufficient data for decision",
        "sanitized_documentation": {
          "crates_io": {
            "url": "https://crates.io/crates/quick-xml",
            "title": "quick-xml v0.38.0",
            "content": {
              "raw_markdown": "#  quick-xml v0.38.0\nHigh performance xml reader and writer \n  * [ #html ](https://crates.io/keywords/html)\n  * [ #parser ](https://crates.io/keywords/parser)\n  * [ #serde ](https://crates.io/keywords/serde)\n  * [ #writer ](https://crates.io/keywords/writer)\n  * [ #xml ](https://crates.io/keywords/xml)\n\n\n  * [ Readme ](https://crates.io/crates/quick-xml)\n  * [ 91 Versions ](https://crates.io/crates/quick-xml/versions)\n  * [ Dependencies ](https://crates.io/crates/quick-xml/dependencies)\n  * [ Dependents ](https://crates.io/crates/quick-xml/reverse_dependencies)\n\n\n## Metadata\n1 day ago \nv1.56.0 \n[ MIT ](https://choosealicense.com/licenses/mit)\n192 KiB \n## Install\nRun the following Cargo command in your project directory:\ncargo add quick-xml\nOr add the following line to your Cargo.toml:\nquick-xml = \"0.38.0\"\n## Documentation\n[ docs.rs/quick-xml ](https://docs.rs/quick-xml)\n## Repository\n[ github.com/tafia/quick-xml ](https://github.com/tafia/quick-xml)\n## Owners\n## Categories\n  * [Asynchronous](https://crates.io/categories/asynchronous)\n  * [Encoding](https://crates.io/categories/encoding)\n  * [Parsing tools](https://crates.io/categories/parsing)\n  * [Parser implementations](https://crates.io/categories/parser-implementations)\n\n\n[ Report crate ](https://crates.io/support?crate=quick-xml&inquire=crate-violation)\n### Stats Overview\n115,688,455 Downloads all time\n91 Versions published\n#### Downloads over the last 90 days\nDisplay as \nStacked \n  * Stacked \n  * Unstacked \n\n\nLoading\u2026\n",
              "markdown_with_citations": "#  quick-xml v0.38.0\nHigh performance xml reader and writer \n  *  #html \u27e81\u27e9\n  *  #parser \u27e82\u27e9\n  *  #serde \u27e83\u27e9\n  *  #writer \u27e84\u27e9\n  *  #xml \u27e85\u27e9\n\n\n  *  Readme \u27e86\u27e9\n  *  91 Versions \u27e87\u27e9\n  *  Dependencies \u27e88\u27e9\n  *  Dependents \u27e89\u27e9\n\n\n## Metadata\n1 day ago \nv1.56.0 \n MIT \u27e810\u27e9\n192 KiB \n## Install\nRun the following Cargo command in your project directory:\ncargo add quick-xml\nOr add the following line to your Cargo.toml:\nquick-xml = \"0.38.0\"\n## Documentation\n docs.rs/quick-xml \u27e811\u27e9\n## Repository\n github.com/tafia/quick-xml \u27e812\u27e9\n## Owners\n## Categories\n  * Asynchronous\u27e813\u27e9\n  * Encoding\u27e814\u27e9\n  * Parsing tools\u27e815\u27e9\n  * Parser implementations\u27e816\u27e9\n\n\n Report crate \u27e817\u27e9\n### Stats Overview\n115,688,455 Downloads all time\n91 Versions published\n#### Downloads over the last 90 days\nDisplay as \nStacked \n  * Stacked \n  * Unstacked \n\n\nLoading\u2026\n",
              "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://crates.io/keywords/html:  #html \n\u27e82\u27e9 https://crates.io/keywords/parser:  #parser \n\u27e83\u27e9 https://crates.io/keywords/serde:  #serde \n\u27e84\u27e9 https://crates.io/keywords/writer:  #writer \n\u27e85\u27e9 https://crates.io/keywords/xml:  #xml \n\u27e86\u27e9 https://crates.io/crates/quick-xml:  Readme \n\u27e87\u27e9 https://crates.io/crates/quick-xml/versions:  91 Versions \n\u27e88\u27e9 https://crates.io/crates/quick-xml/dependencies:  Dependencies \n\u27e89\u27e9 https://crates.io/crates/quick-xml/reverse_dependencies:  Dependents \n\u27e810\u27e9 https://choosealicense.com/licenses/mit:  MIT \n\u27e811\u27e9 https://docs.rs/quick-xml:  docs.rs/quick-xml \n\u27e812\u27e9 https://github.com/tafia/quick-xml:  github.com/tafia/quick-xml \n\u27e813\u27e9 https://crates.io/categories/asynchronous: Asynchronous\n\u27e814\u27e9 https://crates.io/categories/encoding: Encoding\n\u27e815\u27e9 https://crates.io/categories/parsing: Parsing tools\n\u27e816\u27e9 https://crates.io/categories/parser-implementations: Parser implementations\n\u27e817\u27e9 https://crates.io/support?crate=quick-xml&inquire=crate-violation:  Report crate \n",
              "fit_markdown": "",
              "fit_html": ""
            },
            "structured_data": {},
            "quality_score": 3.0,
            "extraction_method": "crawl4ai",
            "error": null,
            "metadata": {
              "doc_type": "docs",
              "content_length": 1499,
              "has_structured_data": false,
              "crawl_success": true
            },
            "timestamp": "112944.007288"
          },
          "docs_rs": {
            "url": "https://docs.rs/quick-xml",
            "title": "Crate quick_xmlCopy item path",
            "content": {
              "raw_markdown": "[](https://docs.rs/quick-xml/latest/quick_xml/all.html \"show sidebar\")\n# Crate quick_xmlCopy item path\n[Settings](https://docs.rs/quick-xml/latest/settings.html)\n[Help](https://docs.rs/quick-xml/latest/help.html)\nSummary[Source](https://docs.rs/quick-xml/latest/src/quick_xml/lib.rs.html#1-79)\nExpand description\nHigh performance XML reader/writer.\n## [\u00a7](https://docs.rs/quick-xml/latest/quick_xml/#description)Description\nquick-xml contains two modes of operation:\nA streaming API based on the [StAX](https://en.wikipedia.org/wiki/StAX) model. This is suited for larger XML documents which cannot completely read into memory at once.\nThe user has to explicitly _ask_ for the next XML event, similar to a database cursor. This is achieved by the following two structs:\n  * [`Reader`](https://docs.rs/quick-xml/latest/quick_xml/reader/struct.Reader.html \"struct quick_xml::reader::Reader\"): A low level XML pull-reader where buffer allocation/clearing is left to user.\n  * [`Writer`](https://docs.rs/quick-xml/latest/quick_xml/writer/struct.Writer.html \"struct quick_xml::writer::Writer\"): A XML writer. Can be nested with readers if you want to transform XMLs.\n\n\nEspecially for nested XML elements, the user must keep track _where_ (how deep) in the XML document the current event is located.\nquick-xml contains optional support of asynchronous reading and writing using [tokio](https://tokio.rs/). To get it enable the [`async-tokio`](https://docs.rs/quick-xml/latest/quick_xml/#async-tokio) feature.\nFurthermore, quick-xml also contains optional [Serde](https://serde.rs/) support to directly serialize and deserialize from structs, without having to deal with the XML events. To get it enable the [`serialize`](https://docs.rs/quick-xml/latest/quick_xml/#serialize) feature. Read more about mapping Rust types to XML in the documentation of [`de`](https://docs.rs/quick-xml/latest/quick_xml/de/index.html) module. Also check [`serde_helpers`](https://docs.rs/quick-xml/latest/quick_xml/serde_helpers/index.html \"mod quick_xml::serde_helpers\") module.\n## [\u00a7](https://docs.rs/quick-xml/latest/quick_xml/#examples)Examples\n  * For a reading example see [`Reader`](https://docs.rs/quick-xml/latest/quick_xml/reader/struct.Reader.html \"struct quick_xml::reader::Reader\")\n  * For a writing example see [`Writer`](https://docs.rs/quick-xml/latest/quick_xml/writer/struct.Writer.html \"struct quick_xml::writer::Writer\")\n\n\n## [\u00a7](https://docs.rs/quick-xml/latest/quick_xml/#features)Features\n`quick-xml` supports the following features:\n  * [**`async-tokio`**](https://docs.rs/quick-xml/latest/quick_xml/#async-tokio)\u2014 Enables support for asynchronous reading and writing from`tokio`\u2019s IO-Traits by enabling [reading events](https://docs.rs/quick-xml/latest/quick_xml/reader/struct.Reader.html#method.read_event_into_async \"method quick_xml::reader::Reader::read_event_into_async\") from types implementing [`tokio::io::AsyncBufRead`](https://docs.rs/tokio/1.45.1/x86_64-unknown-linux-gnu/tokio/io/async_buf_read/trait.AsyncBufRead.html \"trait tokio::io::async_buf_read::AsyncBufRead\").\n  * [**`encoding`**](https://docs.rs/quick-xml/latest/quick_xml/#encoding)\u2014 Enables support of non-UTF-8 encoded documents. Encoding will be inferred from the XML declaration if it is found, otherwise UTF-8 is assumed.\nCurrently, only ASCII-compatible encodings are supported. For example, UTF-16 will not work (therefore, `quick-xml` is not [standard compliant](https://www.w3.org/TR/xml11/#charencoding)).\nThus, quick-xml supports all encodings of [`encoding_rs`](https://docs.rs/encoding_rs/0.8.35/x86_64-unknown-linux-gnu/encoding_rs/index.html \"mod encoding_rs\") except these:\n    * [UTF-16BE](https://docs.rs/encoding_rs/0.8.35/x86_64-unknown-linux-gnu/encoding_rs/static.UTF_16BE.html \"static encoding_rs::UTF_16BE\")\n    * [UTF-16LE](https://docs.rs/encoding_rs/0.8.35/x86_64-unknown-linux-gnu/encoding_rs/static.UTF_16LE.html \"static encoding_rs::UTF_16LE\")\n    * [ISO-2022-JP](https://docs.rs/encoding_rs/0.8.35/x86_64-unknown-linux-gnu/encoding_rs/static.ISO_2022_JP.html \"static encoding_rs::ISO_2022_JP\")\nYou should stop processing a document when one of these encodings is detected, because generated events can be wrong and do not reflect a real document structure!\nBecause these are the only supported encodings that are not ASCII compatible, you can check for them:\n```\nuse quick_xml::events::Event;\nuse quick_xml::reader::Reader;\nlet xml = to_utf16le_with_bom(r#\"<?xml encoding='UTF-16'><element/>\"#);\nlet mut reader = Reader::from_reader(xml.as_ref());\nreader.config_mut().trim_text(true);\nlet mut buf = Vec::new();\nlet mut unsupported = false;\nloop {\n  if !reader.decoder().encoding().is_ascii_compatible() {\n    unsupported = true;\n    break;\n  }\n  buf.clear();\n  match reader.read_event_into(&mut buf).unwrap() {\n    Event::Eof => break,\n    _ => {}\n  }\n}\nassert_eq!(unsupported, true);\n```\n\nThis restriction will be eliminated once issue [#158](https://github.com/tafia/quick-xml/issues/158) is resolved.\n  * [**`escape-html`**](https://docs.rs/quick-xml/latest/quick_xml/#escape-html)\u2014 Enables support for recognizing all[HTML 5 entities](https://dev.w3.org/html5/html-author/charref) in [`unescape`](https://docs.rs/quick-xml/latest/quick_xml/escape/fn.unescape.html \"fn quick_xml::escape::unescape\") function. The full list of entities also can be found in <https://html.spec.whatwg.org/entities.json>.\n  * [**`overlapped-lists`**](https://docs.rs/quick-xml/latest/quick_xml/#overlapped-lists)\u2014 This feature is for the Serde deserializer that enables support for deserializing lists where tags are overlapped with tags that do not correspond to the list.\nWhen this feature is enabled, the XML:\n```\n<any-name>\n <item/>\n <another-item/>\n <item/>\n <item/>\n</any-name>\n```\n\ncould be deserialized to a struct:\n```\n#[derive(Deserialize)]\n#[serde(rename_all = \"kebab-case\")]\nstruct AnyName {\n item: Vec<()>,\n another_item: (),\n}\n```\n\nWhen this feature is not enabled (default), only the first element will be associated with the field, and the deserialized type will report an error (duplicated field) when the deserializer encounters a second `<item/>`.\nNote, that enabling this feature can lead to high and even unlimited memory consumption, because deserializer needs to check all events up to the end of a container tag (`</any-name>` in this example) to figure out that there are no more items for a field. If `</any-name>` or even EOF is not encountered, the parsing will never end which can lead to a denial-of-service (DoS) scenario.\nHaving several lists and overlapped elements for them in XML could also lead to quadratic parsing time, because the deserializer must check the list of events as many times as the number of sequence fields present in the schema.\nTo reduce negative consequences, always [limit](https://docs.rs/quick-xml/latest/quick_xml/de/struct.Deserializer.html#method.event_buffer_size \"method quick_xml::de::Deserializer::event_buffer_size\") the maximum number of events that [`Deserializer`](https://docs.rs/quick-xml/latest/quick_xml/de/struct.Deserializer.html \"struct quick_xml::de::Deserializer\") will buffer.\nThis feature works only with `serialize` feature and has no effect if `serialize` is not enabled.\n  * [**`serde-types`**](https://docs.rs/quick-xml/latest/quick_xml/#serde-types)\u2014 Enables serialization of some quick-xml types using[`serde`](https://docs.rs/serde/1.0.219/x86_64-unknown-linux-gnu/serde/index.html \"mod serde\"). This feature is rarely needed.\nThis feature does NOT provide XML serializer or deserializer. You should use the `serialize` feature for that instead.\n  * [**`serialize`**](https://docs.rs/quick-xml/latest/quick_xml/#serialize)\u2014 Enables support for[`serde`](https://docs.rs/serde/1.0.219/x86_64-unknown-linux-gnu/serde/index.html \"mod serde\") serialization and deserialization. When this feature is enabled, quick-xml provides serializer and deserializer for XML.\nThis feature does NOT enables serializaton of the types inside quick-xml. If you need that, use the `serde-types` feature.\n\n\n## Re-exports[\u00a7](https://docs.rs/quick-xml/latest/quick_xml/#reexports)\n\n`pub use crate::encoding::Decoder[](https://docs.rs/quick-xml/latest/quick_xml/encoding/struct.Decoder.html \"struct quick_xml::encoding::Decoder\");`\n\n\n`pub use crate::errors::serialize::DeError[](https://docs.rs/quick-xml/latest/quick_xml/errors/serialize/enum.DeError.html \"enum quick_xml::errors::serialize::DeError\");``serialize`\n\n\n`pub use crate::errors::serialize::SeError[](https://docs.rs/quick-xml/latest/quick_xml/errors/serialize/enum.SeError.html \"enum quick_xml::errors::serialize::SeError\");``serialize`\n\n\n`pub use crate::errors::Error[](https://docs.rs/quick-xml/latest/quick_xml/errors/enum.Error.html \"enum quick_xml::errors::Error\");`\n\n\n`pub use crate::errors::Result[](https://docs.rs/quick-xml/latest/quick_xml/errors/type.Result.html \"type quick_xml::errors::Result\");`\n\n\n`pub use crate::reader::NsReader[](https://docs.rs/quick-xml/latest/quick_xml/reader/struct.NsReader.html \"struct quick_xml::reader::NsReader\");`\n\n\n`pub use crate::reader::Reader[](https://docs.rs/quick-xml/latest/quick_xml/reader/struct.Reader.html \"struct quick_xml::reader::Reader\");`\n\n\n`pub use crate::writer::ElementWriter[](https://docs.rs/quick-xml/latest/quick_xml/writer/struct.ElementWriter.html \"struct quick_xml::writer::ElementWriter\");`\n\n\n`pub use crate::writer::Writer[](https://docs.rs/quick-xml/latest/quick_xml/writer/struct.Writer.html \"struct quick_xml::writer::Writer\");`\n\n## Modules[\u00a7](https://docs.rs/quick-xml/latest/quick_xml/#modules)\n\n[de](https://docs.rs/quick-xml/latest/quick_xml/de/index.html \"mod quick_xml::de\")`serialize`\n    Serde `Deserializer` module.\n\n[encoding](https://docs.rs/quick-xml/latest/quick_xml/encoding/index.html \"mod quick_xml::encoding\")\n    A module for wrappers that encode / decode data.\n\n[errors](https://docs.rs/quick-xml/latest/quick_xml/errors/index.html \"mod quick_xml::errors\")\n    Error management module\n\n[escape](https://docs.rs/quick-xml/latest/quick_xml/escape/index.html \"mod quick_xml::escape\")\n    Manage xml character escapes\n\n[events](https://docs.rs/quick-xml/latest/quick_xml/events/index.html \"mod quick_xml::events\")\n    Defines zero-copy XML events used throughout this library.\n\n[name](https://docs.rs/quick-xml/latest/quick_xml/name/index.html \"mod quick_xml::name\")\n    Module for handling names according to the W3C [Namespaces in XML 1.1 (Second Edition)](https://www.w3.org/TR/xml-names11) specification\n\n[parser](https://docs.rs/quick-xml/latest/quick_xml/parser/index.html \"mod quick_xml::parser\")\n    Contains low-level parsers of different XML pieces.\n\n[reader](https://docs.rs/quick-xml/latest/quick_xml/reader/index.html \"mod quick_xml::reader\")\n    Contains high-level interface for a pull-based XML parser.\n\n[se](https://docs.rs/quick-xml/latest/quick_xml/se/index.html \"mod quick_xml::se\")`serialize`\n    Module to handle custom serde `Serializer`\n\n[serde_helpers](https://docs.rs/quick-xml/latest/quick_xml/serde_helpers/index.html \"mod quick_xml::serde_helpers\")`serde-types`\n    Provides helper functions to glue an XML with a serde content model.\n\n[writer](https://docs.rs/quick-xml/latest/quick_xml/writer/index.html \"mod quick_xml::writer\")\n    Contains high-level interface for an events-based XML emitter.\n## Macros[\u00a7](https://docs.rs/quick-xml/latest/quick_xml/#macros)\n\n[impl_deserialize_for_internally_tagged_enum](https://docs.rs/quick-xml/latest/quick_xml/macro.impl_deserialize_for_internally_tagged_enum.html \"macro quick_xml::impl_deserialize_for_internally_tagged_enum\")`serde-types`\n    A helper to implement [`Deserialize`](https://docs.rs/serde/1.0.219/x86_64-unknown-linux-gnu/serde/de/trait.Deserialize.html \"trait serde::de::Deserialize\") for [internally tagged](https://serde.rs/enum-representations.html#internally-tagged) enums which does not use [`Deserializer::deserialize_any`](https://docs.rs/serde/1.0.219/x86_64-unknown-linux-gnu/serde/de/trait.Deserializer.html#tymethod.deserialize_any \"method serde::de::Deserializer::deserialize_any\") that produces wrong results with XML because of [serde#1183](https://github.com/serde-rs/serde/issues/1183).\n",
              "markdown_with_citations": "[](https://docs.rs/quick-xml/latest/quick_xml/all.html \"show sidebar\")\n# Crate quick_xmlCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nHigh performance XML reader/writer.\n## \u00a7\u27e84\u27e9Description\nquick-xml contains two modes of operation:\nA streaming API based on the StAX\u27e85\u27e9 model. This is suited for larger XML documents which cannot completely read into memory at once.\nThe user has to explicitly _ask_ for the next XML event, similar to a database cursor. This is achieved by the following two structs:\n  * `Reader`\u27e86\u27e9: A low level XML pull-reader where buffer allocation/clearing is left to user.\n  * `Writer`\u27e87\u27e9: A XML writer. Can be nested with readers if you want to transform XMLs.\n\n\nEspecially for nested XML elements, the user must keep track _where_ (how deep) in the XML document the current event is located.\nquick-xml contains optional support of asynchronous reading and writing using tokio\u27e88\u27e9. To get it enable the `async-tokio`\u27e89\u27e9 feature.\nFurthermore, quick-xml also contains optional Serde\u27e810\u27e9 support to directly serialize and deserialize from structs, without having to deal with the XML events. To get it enable the `serialize`\u27e811\u27e9 feature. Read more about mapping Rust types to XML in the documentation of `de`\u27e812\u27e9 module. Also check `serde_helpers`\u27e813\u27e9 module.\n## \u00a7\u27e814\u27e9Examples\n  * For a reading example see `Reader`\u27e86\u27e9\n  * For a writing example see `Writer`\u27e87\u27e9\n\n\n## \u00a7\u27e815\u27e9Features\n`quick-xml` supports the following features:\n  * **`async-tokio`**\u27e89\u27e9\u2014 Enables support for asynchronous reading and writing from`tokio`\u2019s IO-Traits by enabling reading events\u27e816\u27e9 from types implementing `tokio::io::AsyncBufRead`\u27e817\u27e9.\n  * **`encoding`**\u27e818\u27e9\u2014 Enables support of non-UTF-8 encoded documents. Encoding will be inferred from the XML declaration if it is found, otherwise UTF-8 is assumed.\nCurrently, only ASCII-compatible encodings are supported. For example, UTF-16 will not work (therefore, `quick-xml` is not standard compliant\u27e819\u27e9).\nThus, quick-xml supports all encodings of `encoding_rs`\u27e820\u27e9 except these:\n    * UTF-16BE\u27e821\u27e9\n    * UTF-16LE\u27e822\u27e9\n    * ISO-2022-JP\u27e823\u27e9\nYou should stop processing a document when one of these encodings is detected, because generated events can be wrong and do not reflect a real document structure!\nBecause these are the only supported encodings that are not ASCII compatible, you can check for them:\n```\nuse quick_xml::events::Event;\nuse quick_xml::reader::Reader;\nlet xml = to_utf16le_with_bom(r#\"<?xml encoding='UTF-16'><element/>\"#);\nlet mut reader = Reader::from_reader(xml.as_ref());\nreader.config_mut().trim_text(true);\nlet mut buf = Vec::new();\nlet mut unsupported = false;\nloop {\n  if !reader.decoder().encoding().is_ascii_compatible() {\n    unsupported = true;\n    break;\n  }\n  buf.clear();\n  match reader.read_event_into(&mut buf).unwrap() {\n    Event::Eof => break,\n    _ => {}\n  }\n}\nassert_eq!(unsupported, true);\n```\n\nThis restriction will be eliminated once issue #158\u27e824\u27e9 is resolved.\n  * **`escape-html`**\u27e825\u27e9\u2014 Enables support for recognizing allHTML 5 entities\u27e826\u27e9 in `unescape`\u27e827\u27e9 function. The full list of entities also can be found in <https://html.spec.whatwg.org/entities.json>.\n  * **`overlapped-lists`**\u27e828\u27e9\u2014 This feature is for the Serde deserializer that enables support for deserializing lists where tags are overlapped with tags that do not correspond to the list.\nWhen this feature is enabled, the XML:\n```\n<any-name>\n <item/>\n <another-item/>\n <item/>\n <item/>\n</any-name>\n```\n\ncould be deserialized to a struct:\n```\n#[derive(Deserialize)]\n#[serde(rename_all = \"kebab-case\")]\nstruct AnyName {\n item: Vec<()>,\n another_item: (),\n}\n```\n\nWhen this feature is not enabled (default), only the first element will be associated with the field, and the deserialized type will report an error (duplicated field) when the deserializer encounters a second `<item/>`.\nNote, that enabling this feature can lead to high and even unlimited memory consumption, because deserializer needs to check all events up to the end of a container tag (`</any-name>` in this example) to figure out that there are no more items for a field. If `</any-name>` or even EOF is not encountered, the parsing will never end which can lead to a denial-of-service (DoS) scenario.\nHaving several lists and overlapped elements for them in XML could also lead to quadratic parsing time, because the deserializer must check the list of events as many times as the number of sequence fields present in the schema.\nTo reduce negative consequences, always limit\u27e829\u27e9 the maximum number of events that `Deserializer`\u27e830\u27e9 will buffer.\nThis feature works only with `serialize` feature and has no effect if `serialize` is not enabled.\n  * **`serde-types`**\u27e831\u27e9\u2014 Enables serialization of some quick-xml types using`serde`\u27e832\u27e9. This feature is rarely needed.\nThis feature does NOT provide XML serializer or deserializer. You should use the `serialize` feature for that instead.\n  * **`serialize`**\u27e811\u27e9\u2014 Enables support for`serde`\u27e832\u27e9 serialization and deserialization. When this feature is enabled, quick-xml provides serializer and deserializer for XML.\nThis feature does NOT enables serializaton of the types inside quick-xml. If you need that, use the `serde-types` feature.\n\n\n## Re-exports\u00a7\u27e833\u27e9\n\n`pub use crate::encoding::Decoder[](https://docs.rs/quick-xml/latest/quick_xml/encoding/struct.Decoder.html \"struct quick_xml::encoding::Decoder\");`\n\n\n`pub use crate::errors::serialize::DeError[](https://docs.rs/quick-xml/latest/quick_xml/errors/serialize/enum.DeError.html \"enum quick_xml::errors::serialize::DeError\");``serialize`\n\n\n`pub use crate::errors::serialize::SeError[](https://docs.rs/quick-xml/latest/quick_xml/errors/serialize/enum.SeError.html \"enum quick_xml::errors::serialize::SeError\");``serialize`\n\n\n`pub use crate::errors::Error[](https://docs.rs/quick-xml/latest/quick_xml/errors/enum.Error.html \"enum quick_xml::errors::Error\");`\n\n\n`pub use crate::errors::Result[](https://docs.rs/quick-xml/latest/quick_xml/errors/type.Result.html \"type quick_xml::errors::Result\");`\n\n\n`pub use crate::reader::NsReader[](https://docs.rs/quick-xml/latest/quick_xml/reader/struct.NsReader.html \"struct quick_xml::reader::NsReader\");`\n\n\n`pub use crate::reader::Reader[](https://docs.rs/quick-xml/latest/quick_xml/reader/struct.Reader.html \"struct quick_xml::reader::Reader\");`\n\n\n`pub use crate::writer::ElementWriter[](https://docs.rs/quick-xml/latest/quick_xml/writer/struct.ElementWriter.html \"struct quick_xml::writer::ElementWriter\");`\n\n\n`pub use crate::writer::Writer[](https://docs.rs/quick-xml/latest/quick_xml/writer/struct.Writer.html \"struct quick_xml::writer::Writer\");`\n\n## Modules\u00a7\u27e834\u27e9\n\nde\u27e812\u27e9`serialize`\n    Serde `Deserializer` module.\n\nencoding\u27e835\u27e9\n    A module for wrappers that encode / decode data.\n\nerrors\u27e836\u27e9\n    Error management module\n\nescape\u27e837\u27e9\n    Manage xml character escapes\n\nevents\u27e838\u27e9\n    Defines zero-copy XML events used throughout this library.\n\nname\u27e839\u27e9\n    Module for handling names according to the W3C Namespaces in XML 1.1 (Second Edition)\u27e840\u27e9 specification\n\nparser\u27e841\u27e9\n    Contains low-level parsers of different XML pieces.\n\nreader\u27e842\u27e9\n    Contains high-level interface for a pull-based XML parser.\n\nse\u27e843\u27e9`serialize`\n    Module to handle custom serde `Serializer`\n\nserde_helpers\u27e813\u27e9`serde-types`\n    Provides helper functions to glue an XML with a serde content model.\n\nwriter\u27e844\u27e9\n    Contains high-level interface for an events-based XML emitter.\n## Macros\u00a7\u27e845\u27e9\n\nimpl_deserialize_for_internally_tagged_enum\u27e846\u27e9`serde-types`\n    A helper to implement `Deserialize`\u27e847\u27e9 for internally tagged\u27e848\u27e9 enums which does not use `Deserializer::deserialize_any`\u27e849\u27e9 that produces wrong results with XML because of serde#1183\u27e850\u27e9.\n",
              "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/quick-xml/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/quick-xml/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/quick-xml/latest/src/quick_xml/lib.rs.html#1-79: Source\n\u27e84\u27e9 https://docs.rs/quick-xml/latest/quick_xml/#description: \u00a7\n\u27e85\u27e9 https://en.wikipedia.org/wiki/StAX: StAX\n\u27e86\u27e9 https://docs.rs/quick-xml/latest/quick_xml/reader/struct.Reader.html: struct quick_xml::reader::Reader - `Reader`\n\u27e87\u27e9 https://docs.rs/quick-xml/latest/quick_xml/writer/struct.Writer.html: struct quick_xml::writer::Writer - `Writer`\n\u27e88\u27e9 https://tokio.rs/: tokio\n\u27e89\u27e9 https://docs.rs/quick-xml/latest/quick_xml/#async-tokio: `async-tokio`\n\u27e810\u27e9 https://serde.rs/: Serde\n\u27e811\u27e9 https://docs.rs/quick-xml/latest/quick_xml/#serialize: `serialize`\n\u27e812\u27e9 https://docs.rs/quick-xml/latest/quick_xml/de/index.html: `de`\n\u27e813\u27e9 https://docs.rs/quick-xml/latest/quick_xml/serde_helpers/index.html: mod quick_xml::serde_helpers - `serde_helpers`\n\u27e814\u27e9 https://docs.rs/quick-xml/latest/quick_xml/#examples: \u00a7\n\u27e815\u27e9 https://docs.rs/quick-xml/latest/quick_xml/#features: \u00a7\n\u27e816\u27e9 https://docs.rs/quick-xml/latest/quick_xml/reader/struct.Reader.html#method.read_event_into_async: method quick_xml::reader::Reader::read_event_into_async - reading events\n\u27e817\u27e9 https://docs.rs/tokio/1.45.1/x86_64-unknown-linux-gnu/tokio/io/async_buf_read/trait.AsyncBufRead.html: trait tokio::io::async_buf_read::AsyncBufRead - `tokio::io::AsyncBufRead`\n\u27e818\u27e9 https://docs.rs/quick-xml/latest/quick_xml/#encoding: **`encoding`**\n\u27e819\u27e9 https://www.w3.org/TR/xml11/#charencoding: standard compliant\n\u27e820\u27e9 https://docs.rs/encoding_rs/0.8.35/x86_64-unknown-linux-gnu/encoding_rs/index.html: mod encoding_rs - `encoding_rs`\n\u27e821\u27e9 https://docs.rs/encoding_rs/0.8.35/x86_64-unknown-linux-gnu/encoding_rs/static.UTF_16BE.html: static encoding_rs::UTF_16BE - UTF-16BE\n\u27e822\u27e9 https://docs.rs/encoding_rs/0.8.35/x86_64-unknown-linux-gnu/encoding_rs/static.UTF_16LE.html: static encoding_rs::UTF_16LE - UTF-16LE\n\u27e823\u27e9 https://docs.rs/encoding_rs/0.8.35/x86_64-unknown-linux-gnu/encoding_rs/static.ISO_2022_JP.html: static encoding_rs::ISO_2022_JP - ISO-2022-JP\n\u27e824\u27e9 https://github.com/tafia/quick-xml/issues/158: #158\n\u27e825\u27e9 https://docs.rs/quick-xml/latest/quick_xml/#escape-html: **`escape-html`**\n\u27e826\u27e9 https://dev.w3.org/html5/html-author/charref: HTML 5 entities\n\u27e827\u27e9 https://docs.rs/quick-xml/latest/quick_xml/escape/fn.unescape.html: fn quick_xml::escape::unescape - `unescape`\n\u27e828\u27e9 https://docs.rs/quick-xml/latest/quick_xml/#overlapped-lists: **`overlapped-lists`**\n\u27e829\u27e9 https://docs.rs/quick-xml/latest/quick_xml/de/struct.Deserializer.html#method.event_buffer_size: method quick_xml::de::Deserializer::event_buffer_size - limit\n\u27e830\u27e9 https://docs.rs/quick-xml/latest/quick_xml/de/struct.Deserializer.html: struct quick_xml::de::Deserializer - `Deserializer`\n\u27e831\u27e9 https://docs.rs/quick-xml/latest/quick_xml/#serde-types: **`serde-types`**\n\u27e832\u27e9 https://docs.rs/serde/1.0.219/x86_64-unknown-linux-gnu/serde/index.html: mod serde - `serde`\n\u27e833\u27e9 https://docs.rs/quick-xml/latest/quick_xml/#reexports: \u00a7\n\u27e834\u27e9 https://docs.rs/quick-xml/latest/quick_xml/#modules: \u00a7\n\u27e835\u27e9 https://docs.rs/quick-xml/latest/quick_xml/encoding/index.html: mod quick_xml::encoding - encoding\n\u27e836\u27e9 https://docs.rs/quick-xml/latest/quick_xml/errors/index.html: mod quick_xml::errors - errors\n\u27e837\u27e9 https://docs.rs/quick-xml/latest/quick_xml/escape/index.html: mod quick_xml::escape - escape\n\u27e838\u27e9 https://docs.rs/quick-xml/latest/quick_xml/events/index.html: mod quick_xml::events - events\n\u27e839\u27e9 https://docs.rs/quick-xml/latest/quick_xml/name/index.html: mod quick_xml::name - name\n\u27e840\u27e9 https://www.w3.org/TR/xml-names11: Namespaces in XML 1.1 (Second Edition)\n\u27e841\u27e9 https://docs.rs/quick-xml/latest/quick_xml/parser/index.html: mod quick_xml::parser - parser\n\u27e842\u27e9 https://docs.rs/quick-xml/latest/quick_xml/reader/index.html: mod quick_xml::reader - reader\n\u27e843\u27e9 https://docs.rs/quick-xml/latest/quick_xml/se/index.html: mod quick_xml::se - se\n\u27e844\u27e9 https://docs.rs/quick-xml/latest/quick_xml/writer/index.html: mod quick_xml::writer - writer\n\u27e845\u27e9 https://docs.rs/quick-xml/latest/quick_xml/#macros: \u00a7\n\u27e846\u27e9 https://docs.rs/quick-xml/latest/quick_xml/macro.impl_deserialize_for_internally_tagged_enum.html: macro quick_xml::impl_deserialize_for_internally_tagged_enum - impl_deserialize_for_internally_tagged_enum\n\u27e847\u27e9 https://docs.rs/serde/1.0.219/x86_64-unknown-linux-gnu/serde/de/trait.Deserialize.html: trait serde::de::Deserialize - `Deserialize`\n\u27e848\u27e9 https://serde.rs/enum-representations.html#internally-tagged: internally tagged\n\u27e849\u27e9 https://docs.rs/serde/1.0.219/x86_64-unknown-linux-gnu/serde/de/trait.Deserializer.html#tymethod.deserialize_any: method serde::de::Deserializer::deserialize_any - `Deserializer::deserialize_any`\n\u27e850\u27e9 https://github.com/serde-rs/serde/issues/1183: serde#1183\n",
              "fit_markdown": "",
              "fit_html": ""
            },
            "structured_data": {},
            "quality_score": 4.0,
            "extraction_method": "crawl4ai",
            "error": null,
            "metadata": {
              "doc_type": "docs",
              "content_length": 12196,
              "has_structured_data": false,
              "crawl_success": true
            },
            "timestamp": "112944.655564"
          },
          "lib_rs": {
            "url": "https://lib.rs/crates/quick-xml",
            "title": "Untitled",
            "content": {
              "raw_markdown": "###  [87 releases](https://lib.rs/crates/quick-xml/versions)\n[ new 0.38.0 ](https://github.com/tafia/quick-xml/releases) |  Jun 28, 2025   \n---|---  \n0.37.3 |  Mar 25, 2025   \n0.37.2 |  Dec 29, 2024   \n0.37.1 |  Nov 17, 2024   \n0.1.8 |  Mar 29, 2016   \n#**1** in [Parser implementations](https://lib.rs/parser-implementations \"Parsers implemented for particular formats or languages.\")\nDownload history 2080553/week @ 2025-03-09 3196483/week @ 2025-03-16 3945652/week @ 2025-03-23 2251577/week @ 2025-03-30 2326886/week @ 2025-04-06 1907331/week @ 2025-04-13 1824497/week @ 2025-04-20 1696965/week @ 2025-04-27 1883117/week @ 2025-05-04 1861779/week @ 2025-05-11 1894163/week @ 2025-05-18 1701553/week @ 2025-05-25 1927011/week @ 2025-06-01 1859484/week @ 2025-06-08 1891739/week @ 2025-06-15 2124377/week @ 2025-06-22\n**7,903,412** downloads per month Used in [**4,703** crates (746 directly)](https://lib.rs/crates/quick-xml/rev)\n**MIT** license \n1MB  18K  SLoC\n# quick-xml\n![status](https://img.gs/czjpqfbdkz/full/https://github.com/tafia/quick-xml/actions/workflows/rust.yml/badge.svg) [![Crate](https://img.shields.io/crates/v/quick-xml.svg)](https://crates.io/crates/quick-xml) [![docs.rs](https://img.gs/czjpqfbdkz/full/https://docs.rs/quick-xml/badge.svg)](https://docs.rs/quick-xml) [![codecov](https://img.shields.io/codecov/c/github/tafia/quick-xml)](https://codecov.io/gh/tafia/quick-xml) [![MSRV](https://img.shields.io/badge/rustc-1.56.0+-ab6000.svg)](https://blog.rust-lang.org/2021/10/21/Rust-1.56.0.html)\nHigh performance xml pull reader/writer.\nThe reader:\n  * is almost zero-copy (use of ``Cow`` whenever possible)\n  * is easy on memory allocation (the API provides a way to reuse buffers)\n  * support various encoding (with ``encoding`` feature), namespaces resolution, special characters.\n\n\nSyntax is inspired by [xml-rs](https://github.com/netvl/xml-rs).\n## Example\n### Reader\n```\n``use` `quick_xml`::```events`::``Event`;`\n`use` `quick_xml`::```reader`::``Reader`;`\n`let` xml `=` ``r``#\"`<tag1 att1 = \"test\">\n        <tag2><!--Test comment-->Test</tag2>\n        <tag2>Test 2</tag2>\n       </tag1>`\"#```;`\n`let` `mut` reader `=` `Reader`::``from_str`(`xml`)``;`\nreader`.``config_mut``(``)``.``trim_text``(``true``)``;`\n`let` `mut` count `=` `0``;`\n`let` `mut` txt `=` `Vec```::``new`(``)``;`\n`let` `mut` buf `=` `Vec```::``new`(``)``;`\n``//` The `Reader` does not implement `Iterator` because it outputs borrowed data (`Cow`s)`\n`loop` ``{`\n  ``//` NOTE: this is the generic case when we don't know about the input BufRead.`\n  ``//` when the input is a &str or a &[u8], we don't actually need to use another`\n  ``//` buffer, we could directly call `reader.read_event()``\n  `match` reader`.``read_event_into``(``&``mut` buf`)` `{`\n    `Err``(`e`)` `=>` `panic!``(```\"`Error at position {}: {:?}`\"```,` reader`.``error_position``(``)``,` e`)``,`\n    ``//` exits the loop when reaching end of file`\n    `Ok``(``Event`::``Eof`)` `=>` `break``,`\n    `Ok``(``Event`::``Start`(`e`)``)` `=>` `{`\n      `match` e`.``name``(``)``.``as_ref``(``)` `{`\n        ``b``\"`tag1`\"`` `=>` `println!``(```\"`attributes values: `{:?}``\"```,`\n                  e`.``attributes``(``)``.``map``(````|``````a``|`` ``a`.``unwrap``(``)``.`value``)`\n                  `.``collect`::````<``Vec``<``_``>``>```(``)``)``,`\n        ``b``\"`tag2`\"`` `=>` count `+=` `1``,`\n        `_` `=>` `(``)``,`\n      `}`\n    `}`\n    `Ok``(``Event`::``Text`(`e`)``)` `=>` txt`.``push``(`e`.``unescape``(``)``.``unwrap``(``)``.``into_owned``(``)``)``,`\n    ``//` There are several other `Event`s we do not consider here`\n    `_` `=>` `(``)``,`\n  `}`\n  ``//` if we don't keep a borrow elsewhere, we can clear the buffer to keep memory usage low`\n  buf`.``clear``(``)``;`\n```}``\n`\n```\n\n### Writer\n```\n``use` `quick_xml`::```events`::````{`Event`,` BytesEnd`,` BytesStart```}```;`\n`use` `quick_xml`::```reader`::``Reader`;`\n`use` `quick_xml`::```writer`::``Writer`;`\n`use` `std`::```io`::``Cursor`;`\n`let` xml `=` ``r``#\"`<this_tag k1=\"v1\" k2=\"v2\"><child>text</child></this_tag>`\"#```;`\n`let` `mut` reader `=` `Reader`::``from_str`(`xml`)``;`\nreader`.``config_mut``(``)``.``trim_text``(``true``)``;`\n`let` `mut` writer `=` `Writer`::``new`(``Cursor`::``new`(``Vec```::``new`(``)``)``)``;`\n`loop` ``{`\n  `match` reader`.``read_event``(``)` `{`\n    `Ok``(``Event`::``Start`(`e`)``)` `if` e`.``name``(``)``.``as_ref``(``)` `==` ``b``\"`this_tag`\"`` `=>` `{`\n      ``//` crates a new element ... alternatively we could reuse `e` by calling`\n      ``//` `e.into_owned()``\n      `let` `mut` elem `=` `BytesStart`::``new`(```\"`my_elem`\"```)``;`\n      ``//` collect existing attributes`\n      elem`.``extend_attributes``(`e`.``attributes``(``)``.``map``(````|``````attr``|`` ``attr`.``unwrap``(``)```)``)``;`\n      ``//` copy existing attributes, adds a new my-key=\"some value\" attribute`\n      elem`.``push_attribute``(``(```\"`my-key`\"```,` ``\"`some value`\"```)``)``;`\n      ``//` writes the event to the writer`\n      `assert!``(`writer`.``write_event``(``Event`::``Start`(`elem`)``)``.``is_ok``(``)``)``;`\n    `}``,`\n    `Ok``(``Event`::``End`(`e`)``)` `if` e`.``name``(``)``.``as_ref``(``)` `==` ``b``\"`this_tag`\"`` `=>` `{`\n      `assert!``(`writer`.``write_event``(``Event`::``End`(``BytesEnd`::``new`(```\"`my_elem`\"```)``)``)``.``is_ok``(``)``)``;`\n    `}``,`\n    `Ok``(``Event`::``Eof`)` `=>` `break``,`\n    ``//` we can either move or borrow the event to write, depending on your use-case`\n    `Ok``(`e`)` `=>` `assert!``(`writer`.``write_event``(`e`)``.``is_ok``(``)``)``,`\n    `Err``(`e`)` `=>` `panic!``(```\"`Error at position {}: {:?}`\"```,` reader`.``error_position``(``)``,` e`)``,`\n  `}`\n```}``\n`let` result `=` writer`.``into_inner``(``)``.``into_inner``(``)``;`\n`let` expected `=` ``r``#\"`<my_elem k1=\"v1\" k2=\"v2\" my-key=\"some value\"><child>text</child></my_elem>`\"#```;`\n`assert_eq!``(`result`,` expected`.``as_bytes``(``)``)``;`\n`\n```\n\n## Serde\nWhen using the ``serialize`` feature, quick-xml can be used with serde's ``Serialize``/``Deserialize`` traits. The mapping between XML and Rust types, and in particular the syntax that allows you to specify the distinction between _elements_ and _attributes_ , is described in detail in the documentation for [deserialization](https://docs.rs/quick-xml/latest/quick_xml/de/).\n### Credits\nThis has largely been inspired by [serde-xml-rs](https://github.com/RReverser/serde-xml-rs). quick-xml follows its convention for deserialization, including the [```$value```](https://github.com/RReverser/serde-xml-rs#parsing-the-value-of-a-tag) special name.\n### Parsing the \"value\" of a tag\nIf you have an input of the form ```<`foo abc`=```\"`xyz`\"```>``bar`<``/``foo`>```, and you want to get at the ``bar``, you can use either the special name ```$text```, or the special name ```$value```:\n```\n```struct` ```Foo` ````{`\n  ``#``[``serde```(```rename `=` ``\"`@abc`\"`````)```]``\n  `pub` `abc``:` String,\n  ``#``[``serde```(```rename `=` ``\"`$text`\"`````)```]``\n  `pub` `body``:` String,\n```}```\n`\n```\n\nRead about the difference in the [documentation](https://docs.rs/quick-xml/latest/quick_xml/de/index.html#difference-between-text-and-value-special-names).\n### Performance\nNote that despite not focusing on performance (there are several unnecessary copies), it remains about 10x faster than serde-xml-rs.\n# Features\n  * ``encoding``: support non utf8 xmls\n  * ``serialize``: support serde ``Serialize``/``Deserialize``\n\n\n## Performance\nBenchmarking is hard and the results depend on your input file and your machine.\nHere on my particular file, quick-xml is around **50 times faster** than [xml-rs](https://lib.rs/crates/xml-rs) crate.\n```\n`// quick-xml benches\ntest bench_quick_xml      ... bench:   198,866 ns/iter (+/- 9,663)\ntest bench_quick_xml_escaped  ... bench:   282,740 ns/iter (+/- 61,625)\ntest bench_quick_xml_namespaced ... bench:   389,977 ns/iter (+/- 32,045)\n// same bench with xml-rs\ntest bench_xml_rs        ... bench: 14,468,930 ns/iter (+/- 321,171)\n// serde-xml-rs vs serialize feature\ntest bench_serde_quick_xml   ... bench:  1,181,198 ns/iter (+/- 138,290)\ntest bench_serde_xml_rs     ... bench: 15,039,564 ns/iter (+/- 783,485)\n`\n```\n\nFor a feature and performance comparison, you can also have a look at RazrFalcon's [parser comparison table](https://github.com/RazrFalcon/roxmltree#parsing).\n## Contribute\nAny PR is welcomed!\n## License\nMIT\n#### Dependencies\n~0.1\u20137MB  ~56K SLoC\n  * [ optional ](https://lib.rs/crates/quick-xml/features#feature-arbitrary \"arbitrary is optional feature\") [arbitrary](https://lib.rs/crates/arbitrary \"1\")[+derive](https://lib.rs/crates/arbitrary/features#feature-derive)\n  * [ optional ](https://lib.rs/crates/quick-xml/features#feature-document-features \"document-features is optional feature\") [document-features](https://lib.rs/crates/document-features \"0.2\")\n  * [encoding?](https://lib.rs/crates/quick-xml/features#feature-encoding \"optional feature\") [encoding_rs](https://lib.rs/crates/encoding_rs \"0.8\")\n  * [memchr](https://lib.rs/crates/memchr \"2.1\")\n  * [serde-types?](https://lib.rs/crates/quick-xml/features#feature-serde-types \"optional feature\") [serde](https://lib.rs/crates/serde \">=1.0.139\")\n  * [async-tokio?](https://lib.rs/crates/quick-xml/features#feature-async-tokio \"optional feature\") [tokio](https://lib.rs/crates/tokio \"1.10\")[+io-util](https://lib.rs/crates/tokio/features#feature-io-util)\n\n\n  * dev  [criterion](https://lib.rs/crates/criterion \"new\") >=0.4,<0.7\n  * dev  [pretty_assertions](https://lib.rs/crates/pretty_assertions \"1.4\")\n  * dev  [regex](https://lib.rs/crates/regex \"1\")\n  * dev  [serde-value](https://lib.rs/crates/serde-value \"0.7\")\n  * dev  [serde_derive](https://lib.rs/crates/serde_derive \"1.0.206\")\n  * dev  [tokio-test](https://lib.rs/crates/tokio-test \"0.4\")\n\n\n#### [Other features](https://lib.rs/crates/quick-xml/features)\n  * [escape-html](https://lib.rs/crates/quick-xml/features#feature-escape-html)\n  * [overlapped-lists](https://lib.rs/crates/quick-xml/features#feature-overlapped-lists)\n  * [serialize](https://lib.rs/crates/quick-xml/features#feature-serialize)\n\n\n  *[SLoC]: approx. additional lines of code\n",
              "markdown_with_citations": "###  87 releases\u27e81\u27e9\n new 0.38.0 \u27e82\u27e9 |  Jun 28, 2025   \n---|---  \n0.37.3 |  Mar 25, 2025   \n0.37.2 |  Dec 29, 2024   \n0.37.1 |  Nov 17, 2024   \n0.1.8 |  Mar 29, 2016   \n#**1** in Parser implementations\u27e83\u27e9\nDownload history 2080553/week @ 2025-03-09 3196483/week @ 2025-03-16 3945652/week @ 2025-03-23 2251577/week @ 2025-03-30 2326886/week @ 2025-04-06 1907331/week @ 2025-04-13 1824497/week @ 2025-04-20 1696965/week @ 2025-04-27 1883117/week @ 2025-05-04 1861779/week @ 2025-05-11 1894163/week @ 2025-05-18 1701553/week @ 2025-05-25 1927011/week @ 2025-06-01 1859484/week @ 2025-06-08 1891739/week @ 2025-06-15 2124377/week @ 2025-06-22\n**7,903,412** downloads per month Used in **4,703** crates (746 directly)\u27e84\u27e9\n**MIT** license \n1MB  18K  SLoC\n# quick-xml\n![status\u27e85\u27e9] ![Crate\u27e86\u27e9](https://crates.io/crates/quick-xml) ![docs.rs\u27e87\u27e9](https://docs.rs/quick-xml) ![codecov\u27e88\u27e9](https://codecov.io/gh/tafia/quick-xml) ![MSRV\u27e89\u27e9](https://blog.rust-lang.org/2021/10/21/Rust-1.56.0.html)\nHigh performance xml pull reader/writer.\nThe reader:\n  * is almost zero-copy (use of ``Cow`` whenever possible)\n  * is easy on memory allocation (the API provides a way to reuse buffers)\n  * support various encoding (with ``encoding`` feature), namespaces resolution, special characters.\n\n\nSyntax is inspired by xml-rs\u27e810\u27e9.\n## Example\n### Reader\n```\n``use` `quick_xml`::```events`::``Event`;`\n`use` `quick_xml`::```reader`::``Reader`;`\n`let` xml `=` ``r``#\"`<tag1 att1 = \"test\">\n        <tag2><!--Test comment-->Test</tag2>\n        <tag2>Test 2</tag2>\n       </tag1>`\"#```;`\n`let` `mut` reader `=` `Reader`::``from_str`(`xml`)``;`\nreader`.``config_mut``(``)``.``trim_text``(``true``)``;`\n`let` `mut` count `=` `0``;`\n`let` `mut` txt `=` `Vec```::``new`(``)``;`\n`let` `mut` buf `=` `Vec```::``new`(``)``;`\n``//` The `Reader` does not implement `Iterator` because it outputs borrowed data (`Cow`s)`\n`loop` ``{`\n  ``//` NOTE: this is the generic case when we don't know about the input BufRead.`\n  ``//` when the input is a &str or a &[u8], we don't actually need to use another`\n  ``//` buffer, we could directly call `reader.read_event()``\n  `match` reader`.``read_event_into``(``&``mut` buf`)` `{`\n    `Err``(`e`)` `=>` `panic!``(```\"`Error at position {}: {:?}`\"```,` reader`.``error_position``(``)``,` e`)``,`\n    ``//` exits the loop when reaching end of file`\n    `Ok``(``Event`::``Eof`)` `=>` `break``,`\n    `Ok``(``Event`::``Start`(`e`)``)` `=>` `{`\n      `match` e`.``name``(``)``.``as_ref``(``)` `{`\n        ``b``\"`tag1`\"`` `=>` `println!``(```\"`attributes values: `{:?}``\"```,`\n                  e`.``attributes``(``)``.``map``(````|``````a``|`` ``a`.``unwrap``(``)``.`value``)`\n                  `.``collect`::````<``Vec``<``_``>``>```(``)``)``,`\n        ``b``\"`tag2`\"`` `=>` count `+=` `1``,`\n        `_` `=>` `(``)``,`\n      `}`\n    `}`\n    `Ok``(``Event`::``Text`(`e`)``)` `=>` txt`.``push``(`e`.``unescape``(``)``.``unwrap``(``)``.``into_owned``(``)``)``,`\n    ``//` There are several other `Event`s we do not consider here`\n    `_` `=>` `(``)``,`\n  `}`\n  ``//` if we don't keep a borrow elsewhere, we can clear the buffer to keep memory usage low`\n  buf`.``clear``(``)``;`\n```}``\n`\n```\n\n### Writer\n```\n``use` `quick_xml`::```events`::````{`Event`,` BytesEnd`,` BytesStart```}```;`\n`use` `quick_xml`::```reader`::``Reader`;`\n`use` `quick_xml`::```writer`::``Writer`;`\n`use` `std`::```io`::``Cursor`;`\n`let` xml `=` ``r``#\"`<this_tag k1=\"v1\" k2=\"v2\"><child>text</child></this_tag>`\"#```;`\n`let` `mut` reader `=` `Reader`::``from_str`(`xml`)``;`\nreader`.``config_mut``(``)``.``trim_text``(``true``)``;`\n`let` `mut` writer `=` `Writer`::``new`(``Cursor`::``new`(``Vec```::``new`(``)``)``)``;`\n`loop` ``{`\n  `match` reader`.``read_event``(``)` `{`\n    `Ok``(``Event`::``Start`(`e`)``)` `if` e`.``name``(``)``.``as_ref``(``)` `==` ``b``\"`this_tag`\"`` `=>` `{`\n      ``//` crates a new element ... alternatively we could reuse `e` by calling`\n      ``//` `e.into_owned()``\n      `let` `mut` elem `=` `BytesStart`::``new`(```\"`my_elem`\"```)``;`\n      ``//` collect existing attributes`\n      elem`.``extend_attributes``(`e`.``attributes``(``)``.``map``(````|``````attr``|`` ``attr`.``unwrap``(``)```)``)``;`\n      ``//` copy existing attributes, adds a new my-key=\"some value\" attribute`\n      elem`.``push_attribute``(``(```\"`my-key`\"```,` ``\"`some value`\"```)``)``;`\n      ``//` writes the event to the writer`\n      `assert!``(`writer`.``write_event``(``Event`::``Start`(`elem`)``)``.``is_ok``(``)``)``;`\n    `}``,`\n    `Ok``(``Event`::``End`(`e`)``)` `if` e`.``name``(``)``.``as_ref``(``)` `==` ``b``\"`this_tag`\"`` `=>` `{`\n      `assert!``(`writer`.``write_event``(``Event`::``End`(``BytesEnd`::``new`(```\"`my_elem`\"```)``)``)``.``is_ok``(``)``)``;`\n    `}``,`\n    `Ok``(``Event`::``Eof`)` `=>` `break``,`\n    ``//` we can either move or borrow the event to write, depending on your use-case`\n    `Ok``(`e`)` `=>` `assert!``(`writer`.``write_event``(`e`)``.``is_ok``(``)``)``,`\n    `Err``(`e`)` `=>` `panic!``(```\"`Error at position {}: {:?}`\"```,` reader`.``error_position``(``)``,` e`)``,`\n  `}`\n```}``\n`let` result `=` writer`.``into_inner``(``)``.``into_inner``(``)``;`\n`let` expected `=` ``r``#\"`<my_elem k1=\"v1\" k2=\"v2\" my-key=\"some value\"><child>text</child></my_elem>`\"#```;`\n`assert_eq!``(`result`,` expected`.``as_bytes``(``)``)``;`\n`\n```\n\n## Serde\nWhen using the ``serialize`` feature, quick-xml can be used with serde's ``Serialize``/``Deserialize`` traits. The mapping between XML and Rust types, and in particular the syntax that allows you to specify the distinction between _elements_ and _attributes_ , is described in detail in the documentation for deserialization\u27e811\u27e9.\n### Credits\nThis has largely been inspired by serde-xml-rs\u27e812\u27e9. quick-xml follows its convention for deserialization, including the ```$value```\u27e813\u27e9 special name.\n### Parsing the \"value\" of a tag\nIf you have an input of the form ```<`foo abc`=```\"`xyz`\"```>``bar`<``/``foo`>```, and you want to get at the ``bar``, you can use either the special name ```$text```, or the special name ```$value```:\n```\n```struct` ```Foo` ````{`\n  ``#``[``serde```(```rename `=` ``\"`@abc`\"`````)```]``\n  `pub` `abc``:` String,\n  ``#``[``serde```(```rename `=` ``\"`$text`\"`````)```]``\n  `pub` `body``:` String,\n```}```\n`\n```\n\nRead about the difference in the documentation\u27e814\u27e9.\n### Performance\nNote that despite not focusing on performance (there are several unnecessary copies), it remains about 10x faster than serde-xml-rs.\n# Features\n  * ``encoding``: support non utf8 xmls\n  * ``serialize``: support serde ``Serialize``/``Deserialize``\n\n\n## Performance\nBenchmarking is hard and the results depend on your input file and your machine.\nHere on my particular file, quick-xml is around **50 times faster** than xml-rs\u27e815\u27e9 crate.\n```\n`// quick-xml benches\ntest bench_quick_xml      ... bench:   198,866 ns/iter (+/- 9,663)\ntest bench_quick_xml_escaped  ... bench:   282,740 ns/iter (+/- 61,625)\ntest bench_quick_xml_namespaced ... bench:   389,977 ns/iter (+/- 32,045)\n// same bench with xml-rs\ntest bench_xml_rs        ... bench: 14,468,930 ns/iter (+/- 321,171)\n// serde-xml-rs vs serialize feature\ntest bench_serde_quick_xml   ... bench:  1,181,198 ns/iter (+/- 138,290)\ntest bench_serde_xml_rs     ... bench: 15,039,564 ns/iter (+/- 783,485)\n`\n```\n\nFor a feature and performance comparison, you can also have a look at RazrFalcon's parser comparison table\u27e816\u27e9.\n## Contribute\nAny PR is welcomed!\n## License\nMIT\n#### Dependencies\n~0.1\u20137MB  ~56K SLoC\n  *  optional \u27e817\u27e9 arbitrary\u27e818\u27e9+derive\u27e819\u27e9\n  *  optional \u27e820\u27e9 document-features\u27e821\u27e9\n  * encoding?\u27e822\u27e9 encoding_rs\u27e823\u27e9\n  * memchr\u27e824\u27e9\n  * serde-types?\u27e825\u27e9 serde\u27e826\u27e9\n  * async-tokio?\u27e827\u27e9 tokio\u27e828\u27e9+io-util\u27e829\u27e9\n\n\n  * dev  criterion\u27e830\u27e9 >=0.4,<0.7\n  * dev  pretty_assertions\u27e831\u27e9\n  * dev  regex\u27e832\u27e9\n  * dev  serde-value\u27e833\u27e9\n  * dev  serde_derive\u27e834\u27e9\n  * dev  tokio-test\u27e835\u27e9\n\n\n#### Other features\u27e836\u27e9\n  * escape-html\u27e837\u27e9\n  * overlapped-lists\u27e838\u27e9\n  * serialize\u27e839\u27e9\n\n\n  *[SLoC]: approx. additional lines of code\n",
              "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://lib.rs/crates/quick-xml/versions: 87 releases\n\u27e82\u27e9 https://github.com/tafia/quick-xml/releases:  new 0.38.0 \n\u27e83\u27e9 https://lib.rs/parser-implementations: Parsers implemented for particular formats or languages. - Parser implementations\n\u27e84\u27e9 https://lib.rs/crates/quick-xml/rev: **4,703** crates (746 directly)\n\u27e85\u27e9 https://img.gs/czjpqfbdkz/full/https://github.com/tafia/quick-xml/actions/workflows/rust.yml/badge.svg: status\n\u27e86\u27e9 https://img.shields.io/crates/v/quick-xml.svg: ![Crate\n\u27e87\u27e9 https://img.gs/czjpqfbdkz/full/https://docs.rs/quick-xml/badge.svg: ![docs.rs\n\u27e88\u27e9 https://img.shields.io/codecov/c/github/tafia/quick-xml: ![codecov\n\u27e89\u27e9 https://img.shields.io/badge/rustc-1.56.0+-ab6000.svg: ![MSRV\n\u27e810\u27e9 https://github.com/netvl/xml-rs: xml-rs\n\u27e811\u27e9 https://docs.rs/quick-xml/latest/quick_xml/de/: deserialization\n\u27e812\u27e9 https://github.com/RReverser/serde-xml-rs: serde-xml-rs\n\u27e813\u27e9 https://github.com/RReverser/serde-xml-rs#parsing-the-value-of-a-tag: ```$value```\n\u27e814\u27e9 https://docs.rs/quick-xml/latest/quick_xml/de/index.html#difference-between-text-and-value-special-names: documentation\n\u27e815\u27e9 https://lib.rs/crates/xml-rs: xml-rs\n\u27e816\u27e9 https://github.com/RazrFalcon/roxmltree#parsing: parser comparison table\n\u27e817\u27e9 https://lib.rs/crates/quick-xml/features#feature-arbitrary: arbitrary is optional feature -  optional \n\u27e818\u27e9 https://lib.rs/crates/arbitrary: 1 - arbitrary\n\u27e819\u27e9 https://lib.rs/crates/arbitrary/features#feature-derive: +derive\n\u27e820\u27e9 https://lib.rs/crates/quick-xml/features#feature-document-features: document-features is optional feature -  optional \n\u27e821\u27e9 https://lib.rs/crates/document-features: 0.2 - document-features\n\u27e822\u27e9 https://lib.rs/crates/quick-xml/features#feature-encoding: optional feature - encoding?\n\u27e823\u27e9 https://lib.rs/crates/encoding_rs: 0.8 - encoding_rs\n\u27e824\u27e9 https://lib.rs/crates/memchr: 2.1 - memchr\n\u27e825\u27e9 https://lib.rs/crates/quick-xml/features#feature-serde-types: optional feature - serde-types?\n\u27e826\u27e9 https://lib.rs/crates/serde: >=1.0.139 - serde\n\u27e827\u27e9 https://lib.rs/crates/quick-xml/features#feature-async-tokio: optional feature - async-tokio?\n\u27e828\u27e9 https://lib.rs/crates/tokio: 1.10 - tokio\n\u27e829\u27e9 https://lib.rs/crates/tokio/features#feature-io-util: +io-util\n\u27e830\u27e9 https://lib.rs/crates/criterion: new - criterion\n\u27e831\u27e9 https://lib.rs/crates/pretty_assertions: 1.4 - pretty_assertions\n\u27e832\u27e9 https://lib.rs/crates/regex: 1 - regex\n\u27e833\u27e9 https://lib.rs/crates/serde-value: 0.7 - serde-value\n\u27e834\u27e9 https://lib.rs/crates/serde_derive: 1.0.206 - serde_derive\n\u27e835\u27e9 https://lib.rs/crates/tokio-test: 0.4 - tokio-test\n\u27e836\u27e9 https://lib.rs/crates/quick-xml/features: Other features\n\u27e837\u27e9 https://lib.rs/crates/quick-xml/features#feature-escape-html: escape-html\n\u27e838\u27e9 https://lib.rs/crates/quick-xml/features#feature-overlapped-lists: overlapped-lists\n\u27e839\u27e9 https://lib.rs/crates/quick-xml/features#feature-serialize: serialize\n",
              "fit_markdown": "",
              "fit_html": ""
            },
            "structured_data": {},
            "quality_score": 3.0,
            "extraction_method": "crawl4ai",
            "error": null,
            "metadata": {
              "doc_type": "docs",
              "content_length": 10145,
              "has_structured_data": false,
              "crawl_success": true
            },
            "timestamp": "112945.324802"
          }
        },
        "crate_analysis": {
          "status": "completed",
          "check": [
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#memchr@2.7.5",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\memchr-2.7.5\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "memchr",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\memchr-2.7.5\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "alloc",
                "default",
                "std"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpfftusy5e\\quick-xml-0.38.0\\target\\debug\\deps\\libmemchr-cb1427129dde067c.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "compiler-artifact",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpfftusy5e/quick-xml-0.38.0#quick-xml@0.38.0",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpfftusy5e\\quick-xml-0.38.0\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "quick_xml",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpfftusy5e\\quick-xml-0.38.0\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "default"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpfftusy5e\\quick-xml-0.38.0\\target\\debug\\deps\\libquick_xml-941e21bc6fbb85c6.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "build-finished",
              "success": true
            }
          ],
          "clippy": [
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#memchr@2.7.5",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\memchr-2.7.5\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "memchr",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\memchr-2.7.5\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "alloc",
                "default",
                "std"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpfftusy5e\\quick-xml-0.38.0\\target\\debug\\deps\\libmemchr-cb1427129dde067c.rmeta"
              ],
              "executable": null,
              "fresh": true
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpfftusy5e/quick-xml-0.38.0#quick-xml@0.38.0",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpfftusy5e\\quick-xml-0.38.0\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "quick_xml",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpfftusy5e\\quick-xml-0.38.0\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: this expression creates a reference which is immediately dereferenced by the compiler\n   --> src\\events\\attributes.rs:435:36\n    |\n435 |             .field(\"bytes\", &Bytes(&self.bytes))\n    |                                    ^^^^^^^^^^^ help: change this to: `self.bytes`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#needless_borrow\n    = note: `#[warn(clippy::needless_borrow)]` on by default\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#needless_borrow",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "note",
                    "message": "`#[warn(clippy::needless_borrow)]` on by default",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "change this to",
                    "rendered": null,
                    "spans": [
                      {
                        "byte_end": 17070,
                        "byte_start": 17059,
                        "column_end": 47,
                        "column_start": 36,
                        "expansion": null,
                        "file_name": "src\\events\\attributes.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 435,
                        "line_start": 435,
                        "suggested_replacement": "self.bytes",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 47,
                            "highlight_start": 36,
                            "text": "            .field(\"bytes\", &Bytes(&self.bytes))"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "code": {
                  "code": "clippy::needless_borrow",
                  "explanation": null
                },
                "level": "warning",
                "message": "this expression creates a reference which is immediately dereferenced by the compiler",
                "spans": [
                  {
                    "byte_end": 17070,
                    "byte_start": 17059,
                    "column_end": 47,
                    "column_start": 36,
                    "expansion": null,
                    "file_name": "src\\events\\attributes.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 435,
                    "line_start": 435,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 47,
                        "highlight_start": 36,
                        "text": "            .field(\"bytes\", &Bytes(&self.bytes))"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpfftusy5e/quick-xml-0.38.0#quick-xml@0.38.0",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpfftusy5e\\quick-xml-0.38.0\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "quick_xml",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpfftusy5e\\quick-xml-0.38.0\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: enclosing `Ok` and `?` operator are unneeded\n   --> src\\events\\mod.rs:831:9\n    |\n831 |         Ok(self.decoder.decode_cow(&self.content)?)\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#needless_question_mark\n    = note: `#[warn(clippy::needless_question_mark)]` on by default\nhelp: remove the enclosing `Ok` and `?` operator\n    |\n831 -         Ok(self.decoder.decode_cow(&self.content)?)\n831 +         self.decoder.decode_cow(&self.content)\n    |\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#needless_question_mark",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "note",
                    "message": "`#[warn(clippy::needless_question_mark)]` on by default",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "remove the enclosing `Ok` and `?` operator",
                    "rendered": null,
                    "spans": [
                      {
                        "byte_end": 28340,
                        "byte_start": 28337,
                        "column_end": 12,
                        "column_start": 9,
                        "expansion": null,
                        "file_name": "src\\events\\mod.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 831,
                        "line_start": 831,
                        "suggested_replacement": "",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 12,
                            "highlight_start": 9,
                            "text": "        Ok(self.decoder.decode_cow(&self.content)?)"
                          }
                        ]
                      },
                      {
                        "byte_end": 28380,
                        "byte_start": 28378,
                        "column_end": 52,
                        "column_start": 50,
                        "expansion": null,
                        "file_name": "src\\events\\mod.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 831,
                        "line_start": 831,
                        "suggested_replacement": "",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 52,
                            "highlight_start": 50,
                            "text": "        Ok(self.decoder.decode_cow(&self.content)?)"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "code": {
                  "code": "clippy::needless_question_mark",
                  "explanation": null
                },
                "level": "warning",
                "message": "enclosing `Ok` and `?` operator are unneeded",
                "spans": [
                  {
                    "byte_end": 28380,
                    "byte_start": 28337,
                    "column_end": 52,
                    "column_start": 9,
                    "expansion": null,
                    "file_name": "src\\events\\mod.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 831,
                    "line_start": 831,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 52,
                        "highlight_start": 9,
                        "text": "        Ok(self.decoder.decode_cow(&self.content)?)"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpfftusy5e/quick-xml-0.38.0#quick-xml@0.38.0",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpfftusy5e\\quick-xml-0.38.0\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "quick_xml",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpfftusy5e\\quick-xml-0.38.0\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: useless conversion to the same type: `events::BytesStart<'_>`\n   --> src\\events\\mod.rs:966:22\n    |\n966 |             content: self.content.into_owned().into(),\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider removing `.into()`: `self.content.into_owned()`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#useless_conversion\n    = note: `#[warn(clippy::useless_conversion)]` on by default\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#useless_conversion",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "note",
                    "message": "`#[warn(clippy::useless_conversion)]` on by default",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "consider removing `.into()`",
                    "rendered": null,
                    "spans": [
                      {
                        "byte_end": 32650,
                        "byte_start": 32618,
                        "column_end": 54,
                        "column_start": 22,
                        "expansion": null,
                        "file_name": "src\\events\\mod.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 966,
                        "line_start": 966,
                        "suggested_replacement": "self.content.into_owned()",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 54,
                            "highlight_start": 22,
                            "text": "            content: self.content.into_owned().into(),"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "code": {
                  "code": "clippy::useless_conversion",
                  "explanation": null
                },
                "level": "warning",
                "message": "useless conversion to the same type: `events::BytesStart<'_>`",
                "spans": [
                  {
                    "byte_end": 32650,
                    "byte_start": 32618,
                    "column_end": 54,
                    "column_start": 22,
                    "expansion": null,
                    "file_name": "src\\events\\mod.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 966,
                    "line_start": 966,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 54,
                        "highlight_start": 22,
                        "text": "            content: self.content.into_owned().into(),"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpfftusy5e/quick-xml-0.38.0#quick-xml@0.38.0",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpfftusy5e\\quick-xml-0.38.0\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "quick_xml",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpfftusy5e\\quick-xml-0.38.0\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: unneeded `return` statement\n   --> src\\reader\\state.rs:159:25\n    |\n159 |                         return Err(Error::IllFormed(IllFormedError::MissingDoctypeName));\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#needless_return\n    = note: `#[warn(clippy::needless_return)]` on by default\nhelp: remove `return`\n    |\n159 -                         return Err(Error::IllFormed(IllFormedError::MissingDoctypeName));\n159 +                         Err(Error::IllFormed(IllFormedError::MissingDoctypeName))\n    |\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#needless_return",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "note",
                    "message": "`#[warn(clippy::needless_return)]` on by default",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "remove `return`",
                    "rendered": null,
                    "spans": [
                      {
                        "byte_end": 7266,
                        "byte_start": 7202,
                        "column_end": 89,
                        "column_start": 25,
                        "expansion": null,
                        "file_name": "src\\reader\\state.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 159,
                        "line_start": 159,
                        "suggested_replacement": "Err(Error::IllFormed(IllFormedError::MissingDoctypeName))",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 89,
                            "highlight_start": 25,
                            "text": "                        return Err(Error::IllFormed(IllFormedError::MissingDoctypeName));"
                          }
                        ]
                      },
                      {
                        "byte_end": 7267,
                        "byte_start": 7266,
                        "column_end": 90,
                        "column_start": 89,
                        "expansion": null,
                        "file_name": "src\\reader\\state.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 159,
                        "line_start": 159,
                        "suggested_replacement": "",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 90,
                            "highlight_start": 89,
                            "text": "                        return Err(Error::IllFormed(IllFormedError::MissingDoctypeName));"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "code": {
                  "code": "clippy::needless_return",
                  "explanation": null
                },
                "level": "warning",
                "message": "unneeded `return` statement",
                "spans": [
                  {
                    "byte_end": 7266,
                    "byte_start": 7202,
                    "column_end": 89,
                    "column_start": 25,
                    "expansion": null,
                    "file_name": "src\\reader\\state.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 159,
                    "line_start": 159,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 89,
                        "highlight_start": 25,
                        "text": "                        return Err(Error::IllFormed(IllFormedError::MissingDoctypeName));"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpfftusy5e/quick-xml-0.38.0#quick-xml@0.38.0",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpfftusy5e\\quick-xml-0.38.0\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "quick_xml",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpfftusy5e\\quick-xml-0.38.0\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: length comparison to zero\n   --> src\\reader\\state.rs:242:23\n    |\n242 |         debug_assert!(buf.len() > 0);\n    |                       ^^^^^^^^^^^^^ help: using `!is_empty` is clearer and more explicit: `!buf.is_empty()`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#len_zero\n    = note: `#[warn(clippy::len_zero)]` on by default\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#len_zero",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "note",
                    "message": "`#[warn(clippy::len_zero)]` on by default",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "using `!is_empty` is clearer and more explicit",
                    "rendered": null,
                    "spans": [
                      {
                        "byte_end": 10857,
                        "byte_start": 10844,
                        "column_end": 36,
                        "column_start": 23,
                        "expansion": null,
                        "file_name": "src\\reader\\state.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 242,
                        "line_start": 242,
                        "suggested_replacement": "!buf.is_empty()",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 36,
                            "highlight_start": 23,
                            "text": "        debug_assert!(buf.len() > 0);"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "code": {
                  "code": "clippy::len_zero",
                  "explanation": null
                },
                "level": "warning",
                "message": "length comparison to zero",
                "spans": [
                  {
                    "byte_end": 10857,
                    "byte_start": 10844,
                    "column_end": 36,
                    "column_start": 23,
                    "expansion": null,
                    "file_name": "src\\reader\\state.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 242,
                    "line_start": 242,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 36,
                        "highlight_start": 23,
                        "text": "        debug_assert!(buf.len() > 0);"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpfftusy5e/quick-xml-0.38.0#quick-xml@0.38.0",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpfftusy5e\\quick-xml-0.38.0\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "quick_xml",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpfftusy5e\\quick-xml-0.38.0\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: useless conversion to the same type: `std::io::Error`\n   --> src\\writer.rs:236:37\n    |\n236 |           self.writer.write_all(value).map_err(Into::into)\n    |  _____________________________________-^^^^^^^^^^^^^^^^^^^\n237 | |     }\n    | |____- help: consider removing\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#useless_conversion\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#useless_conversion",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "consider removing",
                    "rendered": null,
                    "spans": [
                      {
                        "byte_end": 8564,
                        "byte_start": 8538,
                        "column_end": 5,
                        "column_start": 37,
                        "expansion": null,
                        "file_name": "src\\writer.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 237,
                        "line_start": 236,
                        "suggested_replacement": "",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 57,
                            "highlight_start": 37,
                            "text": "        self.writer.write_all(value).map_err(Into::into)"
                          },
                          {
                            "highlight_end": 5,
                            "highlight_start": 1,
                            "text": "    }"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "code": {
                  "code": "clippy::useless_conversion",
                  "explanation": null
                },
                "level": "warning",
                "message": "useless conversion to the same type: `std::io::Error`",
                "spans": [
                  {
                    "byte_end": 8558,
                    "byte_start": 8538,
                    "column_end": 57,
                    "column_start": 37,
                    "expansion": null,
                    "file_name": "src\\writer.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 236,
                    "line_start": 236,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 57,
                        "highlight_start": 37,
                        "text": "        self.writer.write_all(value).map_err(Into::into)"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpfftusy5e/quick-xml-0.38.0#quick-xml@0.38.0",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpfftusy5e\\quick-xml-0.38.0\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "quick_xml",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpfftusy5e\\quick-xml-0.38.0\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: useless conversion to the same type: `events::attributes::Attribute<'_>`\n   --> src\\writer.rs:500:46\n    |\n500 |                     self.start_tag.push_attr(attr.into());\n    |                                              ^^^^^^^^^^^ help: consider removing `.into()`: `attr`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#useless_conversion\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#useless_conversion",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "consider removing `.into()`",
                    "rendered": null,
                    "spans": [
                      {
                        "byte_end": 18216,
                        "byte_start": 18205,
                        "column_end": 57,
                        "column_start": 46,
                        "expansion": null,
                        "file_name": "src\\writer.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 500,
                        "line_start": 500,
                        "suggested_replacement": "attr",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 57,
                            "highlight_start": 46,
                            "text": "                    self.start_tag.push_attr(attr.into());"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "code": {
                  "code": "clippy::useless_conversion",
                  "explanation": null
                },
                "level": "warning",
                "message": "useless conversion to the same type: `events::attributes::Attribute<'_>`",
                "spans": [
                  {
                    "byte_end": 18216,
                    "byte_start": 18205,
                    "column_end": 57,
                    "column_start": 46,
                    "expansion": null,
                    "file_name": "src\\writer.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 500,
                    "line_start": 500,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 57,
                        "highlight_start": 46,
                        "text": "                    self.start_tag.push_attr(attr.into());"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpfftusy5e/quick-xml-0.38.0#quick-xml@0.38.0",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpfftusy5e\\quick-xml-0.38.0\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "quick_xml",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpfftusy5e\\quick-xml-0.38.0\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: useless conversion to the same type: `events::attributes::Attribute<'_>`\n   --> src\\writer.rs:514:46\n    |\n514 |                     self.start_tag.push_attr(attr.into());\n    |                                              ^^^^^^^^^^^ help: consider removing `.into()`: `attr`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#useless_conversion\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#useless_conversion",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "consider removing `.into()`",
                    "rendered": null,
                    "spans": [
                      {
                        "byte_end": 18932,
                        "byte_start": 18921,
                        "column_end": 57,
                        "column_start": 46,
                        "expansion": null,
                        "file_name": "src\\writer.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 514,
                        "line_start": 514,
                        "suggested_replacement": "attr",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 57,
                            "highlight_start": 46,
                            "text": "                    self.start_tag.push_attr(attr.into());"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "code": {
                  "code": "clippy::useless_conversion",
                  "explanation": null
                },
                "level": "warning",
                "message": "useless conversion to the same type: `events::attributes::Attribute<'_>`",
                "spans": [
                  {
                    "byte_end": 18932,
                    "byte_start": 18921,
                    "column_end": 57,
                    "column_start": 46,
                    "expansion": null,
                    "file_name": "src\\writer.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 514,
                    "line_start": 514,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 57,
                        "highlight_start": 46,
                        "text": "                    self.start_tag.push_attr(attr.into());"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-artifact",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpfftusy5e/quick-xml-0.38.0#quick-xml@0.38.0",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpfftusy5e\\quick-xml-0.38.0\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "quick_xml",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpfftusy5e\\quick-xml-0.38.0\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "default"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpfftusy5e\\quick-xml-0.38.0\\target\\debug\\deps\\libquick_xml-59df39ff9e47c396.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "build-finished",
              "success": true
            }
          ],
          "audit": {
            "database": {
              "advisory-count": 787,
              "last-commit": "7573f55ba337263f61167dbb0ea926cdc7c8eb5d",
              "last-updated": "2025-06-17T11:04:25+02:00"
            },
            "lockfile": {
              "dependency-count": 95
            },
            "settings": {
              "target_arch": [],
              "target_os": [],
              "severity": null,
              "ignore": [],
              "informational_warnings": [
                "unmaintained",
                "unsound",
                "notice"
              ]
            },
            "vulnerabilities": {
              "found": false,
              "count": 0,
              "list": []
            },
            "warnings": {}
          },
          "note": "Crate analysis performed with stable toolchain."
        },
        "crate_metadata": {
          "name": "quick-xml",
          "version": "0.38.0",
          "description": "ALLOW: Positive community sentiment",
          "repository": "",
          "keywords": [],
          "categories": [],
          "readme": {
            "raw_markdown": "[](https://docs.rs/quick-xml/latest/quick_xml/all.html \"show sidebar\")\n# Crate quick_xmlCopy item path\n[Settings](https://docs.rs/quick-xml/latest/settings.html)\n[Help](https://docs.rs/quick-xml/latest/help.html)\nSummary[Source](https://docs.rs/quick-xml/latest/src/quick_xml/lib.rs.html#1-79)\nExpand description\nHigh performance XML reader/writer.\n## [\u00a7](https://docs.rs/quick-xml/latest/quick_xml/#description)Description\nquick-xml contains two modes of operation:\nA streaming API based on the [StAX](https://en.wikipedia.org/wiki/StAX) model. This is suited for larger XML documents which cannot completely read into memory at once.\nThe user has to explicitly _ask_ for the next XML event, similar to a database cursor. This is achieved by the following two structs:\n  * [`Reader`](https://docs.rs/quick-xml/latest/quick_xml/reader/struct.Reader.html \"struct quick_xml::reader::Reader\"): A low level XML pull-reader where buffer allocation/clearing is left to user.\n  * [`Writer`](https://docs.rs/quick-xml/latest/quick_xml/writer/struct.Writer.html \"struct quick_xml::writer::Writer\"): A XML writer. Can be nested with readers if you want to transform XMLs.\n\n\nEspecially for nested XML elements, the user must keep track _where_ (how deep) in the XML document the current event is located.\nquick-xml contains optional support of asynchronous reading and writing using [tokio](https://tokio.rs/). To get it enable the [`async-tokio`](https://docs.rs/quick-xml/latest/quick_xml/#async-tokio) feature.\nFurthermore, quick-xml also contains optional [Serde](https://serde.rs/) support to directly serialize and deserialize from structs, without having to deal with the XML events. To get it enable the [`serialize`](https://docs.rs/quick-xml/latest/quick_xml/#serialize) feature. Read more about mapping Rust types to XML in the documentation of [`de`](https://docs.rs/quick-xml/latest/quick_xml/de/index.html) module. Also check [`serde_helpers`](https://docs.rs/quick-xml/latest/quick_xml/serde_helpers/index.html \"mod quick_xml::serde_helpers\") module.\n## [\u00a7](https://docs.rs/quick-xml/latest/quick_xml/#examples)Examples\n  * For a reading example see [`Reader`](https://docs.rs/quick-xml/latest/quick_xml/reader/struct.Reader.html \"struct quick_xml::reader::Reader\")\n  * For a writing example see [`Writer`](https://docs.rs/quick-xml/latest/quick_xml/writer/struct.Writer.html \"struct quick_xml::writer::Writer\")\n\n\n## [\u00a7](https://docs.rs/quick-xml/latest/quick_xml/#features)Features\n`quick-xml` supports the following features:\n  * [**`async-tokio`**](https://docs.rs/quick-xml/latest/quick_xml/#async-tokio)\u2014 Enables support for asynchronous reading and writing from`tokio`\u2019s IO-Traits by enabling [reading events](https://docs.rs/quick-xml/latest/quick_xml/reader/struct.Reader.html#method.read_event_into_async \"method quick_xml::reader::Reader::read_event_into_async\") from types implementing [`tokio::io::AsyncBufRead`](https://docs.rs/tokio/1.45.1/x86_64-unknown-linux-gnu/tokio/io/async_buf_read/trait.AsyncBufRead.html \"trait tokio::io::async_buf_read::AsyncBufRead\").\n  * [**`encoding`**](https://docs.rs/quick-xml/latest/quick_xml/#encoding)\u2014 Enables support of non-UTF-8 encoded documents. Encoding will be inferred from the XML declaration if it is found, otherwise UTF-8 is assumed.\nCurrently, only ASCII-compatible encodings are supported. For example, UTF-16 will not work (therefore, `quick-xml` is not [standard compliant](https://www.w3.org/TR/xml11/#charencoding)).\nThus, quick-xml supports all encodings of [`encoding_rs`](https://docs.rs/encoding_rs/0.8.35/x86_64-unknown-linux-gnu/encoding_rs/index.html \"mod encoding_rs\") except these:\n    * [UTF-16BE](https://docs.rs/encoding_rs/0.8.35/x86_64-unknown-linux-gnu/encoding_rs/static.UTF_16BE.html \"static encoding_rs::UTF_16BE\")\n    * [UTF-16LE](https://docs.rs/encoding_rs/0.8.35/x86_64-unknown-linux-gnu/encoding_rs/static.UTF_16LE.html \"static encoding_rs::UTF_16LE\")\n    * [ISO-2022-JP](https://docs.rs/encoding_rs/0.8.35/x86_64-unknown-linux-gnu/encoding_rs/static.ISO_2022_JP.html \"static encoding_rs::ISO_2022_JP\")\nYou should stop processing a document when one of these encodings is detected, because generated events can be wrong and do not reflect a real document structure!\nBecause these are the only supported encodings that are not ASCII compatible, you can check for them:\n```\nuse quick_xml::events::Event;\nuse quick_xml::reader::Reader;\nlet xml = to_utf16le_with_bom(r#\"<?xml encoding='UTF-16'><element/>\"#);\nlet mut reader = Reader::from_reader(xml.as_ref());\nreader.config_mut().trim_text(true);\nlet mut buf = Vec::new();\nlet mut unsupported = false;\nloop {\n  if !reader.decoder().encoding().is_ascii_compatible() {\n    unsupported = true;\n    break;\n  }\n  buf.clear();\n  match reader.read_event_into(&mut buf).unwrap() {\n    Event::Eof => break,\n    _ => {}\n  }\n}\nassert_eq!(unsupported, true);\n```\n\nThis restriction will be eliminated once issue [#158](https://github.com/tafia/quick-xml/issues/158) is resolved.\n  * [**`escape-html`**](https://docs.rs/quick-xml/latest/quick_xml/#escape-html)\u2014 Enables support for recognizing all[HTML 5 entities](https://dev.w3.org/html5/html-author/charref) in [`unescape`](https://docs.rs/quick-xml/latest/quick_xml/escape/fn.unescape.html \"fn quick_xml::escape::unescape\") function. The full list of entities also can be found in <https://html.spec.whatwg.org/entities.json>.\n  * [**`overlapped-lists`**](https://docs.rs/quick-xml/latest/quick_xml/#overlapped-lists)\u2014 This feature is for the Serde deserializer that enables support for deserializing lists where tags are overlapped with tags that do not correspond to the list.\nWhen this feature is enabled, the XML:\n```\n<any-name>\n <item/>\n <another-item/>\n <item/>\n <item/>\n</any-name>\n```\n\ncould be deserialized to a struct:\n```\n#[derive(Deserialize)]\n#[serde(rename_all = \"kebab-case\")]\nstruct AnyName {\n item: Vec<()>,\n another_item: (),\n}\n```\n\nWhen this feature is not enabled (default), only the first element will be associated with the field, and the deserialized type will report an error (duplicated field) when the deserializer encounters a second `<item/>`.\nNote, that enabling this feature can lead to high and even unlimited memory consumption, because deserializer needs to check all events up to the end of a container tag (`</any-name>` in this example) to figure out that there are no more items for a field. If `</any-name>` or even EOF is not encountered, the parsing will never end which can lead to a denial-of-service (DoS) scenario.\nHaving several lists and overlapped elements for them in XML could also lead to quadratic parsing time, because the deserializer must check the list of events as many times as the number of sequence fields present in the schema.\nTo reduce negative consequences, always [limit](https://docs.rs/quick-xml/latest/quick_xml/de/struct.Deserializer.html#method.event_buffer_size \"method quick_xml::de::Deserializer::event_buffer_size\") the maximum number of events that [`Deserializer`](https://docs.rs/quick-xml/latest/quick_xml/de/struct.Deserializer.html \"struct quick_xml::de::Deserializer\") will buffer.\nThis feature works only with `serialize` feature and has no effect if `serialize` is not enabled.\n  * [**`serde-types`**](https://docs.rs/quick-xml/latest/quick_xml/#serde-types)\u2014 Enables serialization of some quick-xml types using[`serde`](https://docs.rs/serde/1.0.219/x86_64-unknown-linux-gnu/serde/index.html \"mod serde\"). This feature is rarely needed.\nThis feature does NOT provide XML serializer or deserializer. You should use the `serialize` feature for that instead.\n  * [**`serialize`**](https://docs.rs/quick-xml/latest/quick_xml/#serialize)\u2014 Enables support for[`serde`](https://docs.rs/serde/1.0.219/x86_64-unknown-linux-gnu/serde/index.html \"mod serde\") serialization and deserialization. When this feature is enabled, quick-xml provides serializer and deserializer for XML.\nThis feature does NOT enables serializaton of the types inside quick-xml. If you need that, use the `serde-types` feature.\n\n\n## Re-exports[\u00a7](https://docs.rs/quick-xml/latest/quick_xml/#reexports)\n\n`pub use crate::encoding::Decoder[](https://docs.rs/quick-xml/latest/quick_xml/encoding/struct.Decoder.html \"struct quick_xml::encoding::Decoder\");`\n\n\n`pub use crate::errors::serialize::DeError[](https://docs.rs/quick-xml/latest/quick_xml/errors/serialize/enum.DeError.html \"enum quick_xml::errors::serialize::DeError\");``serialize`\n\n\n`pub use crate::errors::serialize::SeError[](https://docs.rs/quick-xml/latest/quick_xml/errors/serialize/enum.SeError.html \"enum quick_xml::errors::serialize::SeError\");``serialize`\n\n\n`pub use crate::errors::Error[](https://docs.rs/quick-xml/latest/quick_xml/errors/enum.Error.html \"enum quick_xml::errors::Error\");`\n\n\n`pub use crate::errors::Result[](https://docs.rs/quick-xml/latest/quick_xml/errors/type.Result.html \"type quick_xml::errors::Result\");`\n\n\n`pub use crate::reader::NsReader[](https://docs.rs/quick-xml/latest/quick_xml/reader/struct.NsReader.html \"struct quick_xml::reader::NsReader\");`\n\n\n`pub use crate::reader::Reader[](https://docs.rs/quick-xml/latest/quick_xml/reader/struct.Reader.html \"struct quick_xml::reader::Reader\");`\n\n\n`pub use crate::writer::ElementWriter[](https://docs.rs/quick-xml/latest/quick_xml/writer/struct.ElementWriter.html \"struct quick_xml::writer::ElementWriter\");`\n\n\n`pub use crate::writer::Writer[](https://docs.rs/quick-xml/latest/quick_xml/writer/struct.Writer.html \"struct quick_xml::writer::Writer\");`\n\n## Modules[\u00a7](https://docs.rs/quick-xml/latest/quick_xml/#modules)\n\n[de](https://docs.rs/quick-xml/latest/quick_xml/de/index.html \"mod quick_xml::de\")`serialize`\n    Serde `Deserializer` module.\n\n[encoding](https://docs.rs/quick-xml/latest/quick_xml/encoding/index.html \"mod quick_xml::encoding\")\n    A module for wrappers that encode / decode data.\n\n[errors](https://docs.rs/quick-xml/latest/quick_xml/errors/index.html \"mod quick_xml::errors\")\n    Error management module\n\n[escape](https://docs.rs/quick-xml/latest/quick_xml/escape/index.html \"mod quick_xml::escape\")\n    Manage xml character escapes\n\n[events](https://docs.rs/quick-xml/latest/quick_xml/events/index.html \"mod quick_xml::events\")\n    Defines zero-copy XML events used throughout this library.\n\n[name](https://docs.rs/quick-xml/latest/quick_xml/name/index.html \"mod quick_xml::name\")\n    Module for handling names according to the W3C [Namespaces in XML 1.1 (Second Edition)](https://www.w3.org/TR/xml-names11) specification\n\n[parser](https://docs.rs/quick-xml/latest/quick_xml/parser/index.html \"mod quick_xml::parser\")\n    Contains low-level parsers of different XML pieces.\n\n[reader](https://docs.rs/quick-xml/latest/quick_xml/reader/index.html \"mod quick_xml::reader\")\n    Contains high-level interface for a pull-based XML parser.\n\n[se](https://docs.rs/quick-xml/latest/quick_xml/se/index.html \"mod quick_xml::se\")`serialize`\n    Module to handle custom serde `Serializer`\n\n[serde_helpers](https://docs.rs/quick-xml/latest/quick_xml/serde_helpers/index.html \"mod quick_xml::serde_helpers\")`serde-types`\n    Provides helper functions to glue an XML with a serde content model.\n\n[writer](https://docs.rs/quick-xml/latest/quick_xml/writer/index.html \"mod quick_xml::writer\")\n    Contains high-level interface for an events-based XML emitter.\n## Macros[\u00a7](https://docs.rs/quick-xml/latest/quick_xml/#macros)\n\n[impl_deserialize_for_internally_tagged_enum](https://docs.rs/quick-xml/latest/quick_xml/macro.impl_deserialize_for_internally_tagged_enum.html \"macro quick_xml::impl_deserialize_for_internally_tagged_enum\")`serde-types`\n    A helper to implement [`Deserialize`](https://docs.rs/serde/1.0.219/x86_64-unknown-linux-gnu/serde/de/trait.Deserialize.html \"trait serde::de::Deserialize\") for [internally tagged](https://serde.rs/enum-representations.html#internally-tagged) enums which does not use [`Deserializer::deserialize_any`](https://docs.rs/serde/1.0.219/x86_64-unknown-linux-gnu/serde/de/trait.Deserializer.html#tymethod.deserialize_any \"method serde::de::Deserializer::deserialize_any\") that produces wrong results with XML because of [serde#1183](https://github.com/serde-rs/serde/issues/1183).\n",
            "markdown_with_citations": "[](https://docs.rs/quick-xml/latest/quick_xml/all.html \"show sidebar\")\n# Crate quick_xmlCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nHigh performance XML reader/writer.\n## \u00a7\u27e84\u27e9Description\nquick-xml contains two modes of operation:\nA streaming API based on the StAX\u27e85\u27e9 model. This is suited for larger XML documents which cannot completely read into memory at once.\nThe user has to explicitly _ask_ for the next XML event, similar to a database cursor. This is achieved by the following two structs:\n  * `Reader`\u27e86\u27e9: A low level XML pull-reader where buffer allocation/clearing is left to user.\n  * `Writer`\u27e87\u27e9: A XML writer. Can be nested with readers if you want to transform XMLs.\n\n\nEspecially for nested XML elements, the user must keep track _where_ (how deep) in the XML document the current event is located.\nquick-xml contains optional support of asynchronous reading and writing using tokio\u27e88\u27e9. To get it enable the `async-tokio`\u27e89\u27e9 feature.\nFurthermore, quick-xml also contains optional Serde\u27e810\u27e9 support to directly serialize and deserialize from structs, without having to deal with the XML events. To get it enable the `serialize`\u27e811\u27e9 feature. Read more about mapping Rust types to XML in the documentation of `de`\u27e812\u27e9 module. Also check `serde_helpers`\u27e813\u27e9 module.\n## \u00a7\u27e814\u27e9Examples\n  * For a reading example see `Reader`\u27e86\u27e9\n  * For a writing example see `Writer`\u27e87\u27e9\n\n\n## \u00a7\u27e815\u27e9Features\n`quick-xml` supports the following features:\n  * **`async-tokio`**\u27e89\u27e9\u2014 Enables support for asynchronous reading and writing from`tokio`\u2019s IO-Traits by enabling reading events\u27e816\u27e9 from types implementing `tokio::io::AsyncBufRead`\u27e817\u27e9.\n  * **`encoding`**\u27e818\u27e9\u2014 Enables support of non-UTF-8 encoded documents. Encoding will be inferred from the XML declaration if it is found, otherwise UTF-8 is assumed.\nCurrently, only ASCII-compatible encodings are supported. For example, UTF-16 will not work (therefore, `quick-xml` is not standard compliant\u27e819\u27e9).\nThus, quick-xml supports all encodings of `encoding_rs`\u27e820\u27e9 except these:\n    * UTF-16BE\u27e821\u27e9\n    * UTF-16LE\u27e822\u27e9\n    * ISO-2022-JP\u27e823\u27e9\nYou should stop processing a document when one of these encodings is detected, because generated events can be wrong and do not reflect a real document structure!\nBecause these are the only supported encodings that are not ASCII compatible, you can check for them:\n```\nuse quick_xml::events::Event;\nuse quick_xml::reader::Reader;\nlet xml = to_utf16le_with_bom(r#\"<?xml encoding='UTF-16'><element/>\"#);\nlet mut reader = Reader::from_reader(xml.as_ref());\nreader.config_mut().trim_text(true);\nlet mut buf = Vec::new();\nlet mut unsupported = false;\nloop {\n  if !reader.decoder().encoding().is_ascii_compatible() {\n    unsupported = true;\n    break;\n  }\n  buf.clear();\n  match reader.read_event_into(&mut buf).unwrap() {\n    Event::Eof => break,\n    _ => {}\n  }\n}\nassert_eq!(unsupported, true);\n```\n\nThis restriction will be eliminated once issue #158\u27e824\u27e9 is resolved.\n  * **`escape-html`**\u27e825\u27e9\u2014 Enables support for recognizing allHTML 5 entities\u27e826\u27e9 in `unescape`\u27e827\u27e9 function. The full list of entities also can be found in <https://html.spec.whatwg.org/entities.json>.\n  * **`overlapped-lists`**\u27e828\u27e9\u2014 This feature is for the Serde deserializer that enables support for deserializing lists where tags are overlapped with tags that do not correspond to the list.\nWhen this feature is enabled, the XML:\n```\n<any-name>\n <item/>\n <another-item/>\n <item/>\n <item/>\n</any-name>\n```\n\ncould be deserialized to a struct:\n```\n#[derive(Deserialize)]\n#[serde(rename_all = \"kebab-case\")]\nstruct AnyName {\n item: Vec<()>,\n another_item: (),\n}\n```\n\nWhen this feature is not enabled (default), only the first element will be associated with the field, and the deserialized type will report an error (duplicated field) when the deserializer encounters a second `<item/>`.\nNote, that enabling this feature can lead to high and even unlimited memory consumption, because deserializer needs to check all events up to the end of a container tag (`</any-name>` in this example) to figure out that there are no more items for a field. If `</any-name>` or even EOF is not encountered, the parsing will never end which can lead to a denial-of-service (DoS) scenario.\nHaving several lists and overlapped elements for them in XML could also lead to quadratic parsing time, because the deserializer must check the list of events as many times as the number of sequence fields present in the schema.\nTo reduce negative consequences, always limit\u27e829\u27e9 the maximum number of events that `Deserializer`\u27e830\u27e9 will buffer.\nThis feature works only with `serialize` feature and has no effect if `serialize` is not enabled.\n  * **`serde-types`**\u27e831\u27e9\u2014 Enables serialization of some quick-xml types using`serde`\u27e832\u27e9. This feature is rarely needed.\nThis feature does NOT provide XML serializer or deserializer. You should use the `serialize` feature for that instead.\n  * **`serialize`**\u27e811\u27e9\u2014 Enables support for`serde`\u27e832\u27e9 serialization and deserialization. When this feature is enabled, quick-xml provides serializer and deserializer for XML.\nThis feature does NOT enables serializaton of the types inside quick-xml. If you need that, use the `serde-types` feature.\n\n\n## Re-exports\u00a7\u27e833\u27e9\n\n`pub use crate::encoding::Decoder[](https://docs.rs/quick-xml/latest/quick_xml/encoding/struct.Decoder.html \"struct quick_xml::encoding::Decoder\");`\n\n\n`pub use crate::errors::serialize::DeError[](https://docs.rs/quick-xml/latest/quick_xml/errors/serialize/enum.DeError.html \"enum quick_xml::errors::serialize::DeError\");``serialize`\n\n\n`pub use crate::errors::serialize::SeError[](https://docs.rs/quick-xml/latest/quick_xml/errors/serialize/enum.SeError.html \"enum quick_xml::errors::serialize::SeError\");``serialize`\n\n\n`pub use crate::errors::Error[](https://docs.rs/quick-xml/latest/quick_xml/errors/enum.Error.html \"enum quick_xml::errors::Error\");`\n\n\n`pub use crate::errors::Result[](https://docs.rs/quick-xml/latest/quick_xml/errors/type.Result.html \"type quick_xml::errors::Result\");`\n\n\n`pub use crate::reader::NsReader[](https://docs.rs/quick-xml/latest/quick_xml/reader/struct.NsReader.html \"struct quick_xml::reader::NsReader\");`\n\n\n`pub use crate::reader::Reader[](https://docs.rs/quick-xml/latest/quick_xml/reader/struct.Reader.html \"struct quick_xml::reader::Reader\");`\n\n\n`pub use crate::writer::ElementWriter[](https://docs.rs/quick-xml/latest/quick_xml/writer/struct.ElementWriter.html \"struct quick_xml::writer::ElementWriter\");`\n\n\n`pub use crate::writer::Writer[](https://docs.rs/quick-xml/latest/quick_xml/writer/struct.Writer.html \"struct quick_xml::writer::Writer\");`\n\n## Modules\u00a7\u27e834\u27e9\n\nde\u27e812\u27e9`serialize`\n    Serde `Deserializer` module.\n\nencoding\u27e835\u27e9\n    A module for wrappers that encode / decode data.\n\nerrors\u27e836\u27e9\n    Error management module\n\nescape\u27e837\u27e9\n    Manage xml character escapes\n\nevents\u27e838\u27e9\n    Defines zero-copy XML events used throughout this library.\n\nname\u27e839\u27e9\n    Module for handling names according to the W3C Namespaces in XML 1.1 (Second Edition)\u27e840\u27e9 specification\n\nparser\u27e841\u27e9\n    Contains low-level parsers of different XML pieces.\n\nreader\u27e842\u27e9\n    Contains high-level interface for a pull-based XML parser.\n\nse\u27e843\u27e9`serialize`\n    Module to handle custom serde `Serializer`\n\nserde_helpers\u27e813\u27e9`serde-types`\n    Provides helper functions to glue an XML with a serde content model.\n\nwriter\u27e844\u27e9\n    Contains high-level interface for an events-based XML emitter.\n## Macros\u00a7\u27e845\u27e9\n\nimpl_deserialize_for_internally_tagged_enum\u27e846\u27e9`serde-types`\n    A helper to implement `Deserialize`\u27e847\u27e9 for internally tagged\u27e848\u27e9 enums which does not use `Deserializer::deserialize_any`\u27e849\u27e9 that produces wrong results with XML because of serde#1183\u27e850\u27e9.\n",
            "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/quick-xml/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/quick-xml/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/quick-xml/latest/src/quick_xml/lib.rs.html#1-79: Source\n\u27e84\u27e9 https://docs.rs/quick-xml/latest/quick_xml/#description: \u00a7\n\u27e85\u27e9 https://en.wikipedia.org/wiki/StAX: StAX\n\u27e86\u27e9 https://docs.rs/quick-xml/latest/quick_xml/reader/struct.Reader.html: struct quick_xml::reader::Reader - `Reader`\n\u27e87\u27e9 https://docs.rs/quick-xml/latest/quick_xml/writer/struct.Writer.html: struct quick_xml::writer::Writer - `Writer`\n\u27e88\u27e9 https://tokio.rs/: tokio\n\u27e89\u27e9 https://docs.rs/quick-xml/latest/quick_xml/#async-tokio: `async-tokio`\n\u27e810\u27e9 https://serde.rs/: Serde\n\u27e811\u27e9 https://docs.rs/quick-xml/latest/quick_xml/#serialize: `serialize`\n\u27e812\u27e9 https://docs.rs/quick-xml/latest/quick_xml/de/index.html: `de`\n\u27e813\u27e9 https://docs.rs/quick-xml/latest/quick_xml/serde_helpers/index.html: mod quick_xml::serde_helpers - `serde_helpers`\n\u27e814\u27e9 https://docs.rs/quick-xml/latest/quick_xml/#examples: \u00a7\n\u27e815\u27e9 https://docs.rs/quick-xml/latest/quick_xml/#features: \u00a7\n\u27e816\u27e9 https://docs.rs/quick-xml/latest/quick_xml/reader/struct.Reader.html#method.read_event_into_async: method quick_xml::reader::Reader::read_event_into_async - reading events\n\u27e817\u27e9 https://docs.rs/tokio/1.45.1/x86_64-unknown-linux-gnu/tokio/io/async_buf_read/trait.AsyncBufRead.html: trait tokio::io::async_buf_read::AsyncBufRead - `tokio::io::AsyncBufRead`\n\u27e818\u27e9 https://docs.rs/quick-xml/latest/quick_xml/#encoding: **`encoding`**\n\u27e819\u27e9 https://www.w3.org/TR/xml11/#charencoding: standard compliant\n\u27e820\u27e9 https://docs.rs/encoding_rs/0.8.35/x86_64-unknown-linux-gnu/encoding_rs/index.html: mod encoding_rs - `encoding_rs`\n\u27e821\u27e9 https://docs.rs/encoding_rs/0.8.35/x86_64-unknown-linux-gnu/encoding_rs/static.UTF_16BE.html: static encoding_rs::UTF_16BE - UTF-16BE\n\u27e822\u27e9 https://docs.rs/encoding_rs/0.8.35/x86_64-unknown-linux-gnu/encoding_rs/static.UTF_16LE.html: static encoding_rs::UTF_16LE - UTF-16LE\n\u27e823\u27e9 https://docs.rs/encoding_rs/0.8.35/x86_64-unknown-linux-gnu/encoding_rs/static.ISO_2022_JP.html: static encoding_rs::ISO_2022_JP - ISO-2022-JP\n\u27e824\u27e9 https://github.com/tafia/quick-xml/issues/158: #158\n\u27e825\u27e9 https://docs.rs/quick-xml/latest/quick_xml/#escape-html: **`escape-html`**\n\u27e826\u27e9 https://dev.w3.org/html5/html-author/charref: HTML 5 entities\n\u27e827\u27e9 https://docs.rs/quick-xml/latest/quick_xml/escape/fn.unescape.html: fn quick_xml::escape::unescape - `unescape`\n\u27e828\u27e9 https://docs.rs/quick-xml/latest/quick_xml/#overlapped-lists: **`overlapped-lists`**\n\u27e829\u27e9 https://docs.rs/quick-xml/latest/quick_xml/de/struct.Deserializer.html#method.event_buffer_size: method quick_xml::de::Deserializer::event_buffer_size - limit\n\u27e830\u27e9 https://docs.rs/quick-xml/latest/quick_xml/de/struct.Deserializer.html: struct quick_xml::de::Deserializer - `Deserializer`\n\u27e831\u27e9 https://docs.rs/quick-xml/latest/quick_xml/#serde-types: **`serde-types`**\n\u27e832\u27e9 https://docs.rs/serde/1.0.219/x86_64-unknown-linux-gnu/serde/index.html: mod serde - `serde`\n\u27e833\u27e9 https://docs.rs/quick-xml/latest/quick_xml/#reexports: \u00a7\n\u27e834\u27e9 https://docs.rs/quick-xml/latest/quick_xml/#modules: \u00a7\n\u27e835\u27e9 https://docs.rs/quick-xml/latest/quick_xml/encoding/index.html: mod quick_xml::encoding - encoding\n\u27e836\u27e9 https://docs.rs/quick-xml/latest/quick_xml/errors/index.html: mod quick_xml::errors - errors\n\u27e837\u27e9 https://docs.rs/quick-xml/latest/quick_xml/escape/index.html: mod quick_xml::escape - escape\n\u27e838\u27e9 https://docs.rs/quick-xml/latest/quick_xml/events/index.html: mod quick_xml::events - events\n\u27e839\u27e9 https://docs.rs/quick-xml/latest/quick_xml/name/index.html: mod quick_xml::name - name\n\u27e840\u27e9 https://www.w3.org/TR/xml-names11: Namespaces in XML 1.1 (Second Edition)\n\u27e841\u27e9 https://docs.rs/quick-xml/latest/quick_xml/parser/index.html: mod quick_xml::parser - parser\n\u27e842\u27e9 https://docs.rs/quick-xml/latest/quick_xml/reader/index.html: mod quick_xml::reader - reader\n\u27e843\u27e9 https://docs.rs/quick-xml/latest/quick_xml/se/index.html: mod quick_xml::se - se\n\u27e844\u27e9 https://docs.rs/quick-xml/latest/quick_xml/writer/index.html: mod quick_xml::writer - writer\n\u27e845\u27e9 https://docs.rs/quick-xml/latest/quick_xml/#macros: \u00a7\n\u27e846\u27e9 https://docs.rs/quick-xml/latest/quick_xml/macro.impl_deserialize_for_internally_tagged_enum.html: macro quick_xml::impl_deserialize_for_internally_tagged_enum - impl_deserialize_for_internally_tagged_enum\n\u27e847\u27e9 https://docs.rs/serde/1.0.219/x86_64-unknown-linux-gnu/serde/de/trait.Deserialize.html: trait serde::de::Deserialize - `Deserialize`\n\u27e848\u27e9 https://serde.rs/enum-representations.html#internally-tagged: internally tagged\n\u27e849\u27e9 https://docs.rs/serde/1.0.219/x86_64-unknown-linux-gnu/serde/de/trait.Deserializer.html#tymethod.deserialize_any: method serde::de::Deserializer::deserialize_any - `Deserializer::deserialize_any`\n\u27e850\u27e9 https://github.com/serde-rs/serde/issues/1183: serde#1183\n",
            "fit_markdown": "",
            "fit_html": ""
          },
          "downloads": 0,
          "github_stars": 0,
          "dependencies": [],
          "features": {},
          "code_snippets": [],
          "readme_sections": {},
          "librs_downloads": null,
          "source": "crates.io",
          "enhanced_scraping": {},
          "enhanced_features": [],
          "enhanced_dependencies": []
        },
        "enriched_crate": {
          "name": "quick-xml",
          "version": "0.38.0",
          "description": "ALLOW: Positive community sentiment",
          "repository": "",
          "keywords": [],
          "categories": [],
          "readme": {
            "raw_markdown": "[](https://docs.rs/quick-xml/latest/quick_xml/all.html \"show sidebar\")\n# Crate quick_xmlCopy item path\n[Settings](https://docs.rs/quick-xml/latest/settings.html)\n[Help](https://docs.rs/quick-xml/latest/help.html)\nSummary[Source](https://docs.rs/quick-xml/latest/src/quick_xml/lib.rs.html#1-79)\nExpand description\nHigh performance XML reader/writer.\n## [\u00a7](https://docs.rs/quick-xml/latest/quick_xml/#description)Description\nquick-xml contains two modes of operation:\nA streaming API based on the [StAX](https://en.wikipedia.org/wiki/StAX) model. This is suited for larger XML documents which cannot completely read into memory at once.\nThe user has to explicitly _ask_ for the next XML event, similar to a database cursor. This is achieved by the following two structs:\n  * [`Reader`](https://docs.rs/quick-xml/latest/quick_xml/reader/struct.Reader.html \"struct quick_xml::reader::Reader\"): A low level XML pull-reader where buffer allocation/clearing is left to user.\n  * [`Writer`](https://docs.rs/quick-xml/latest/quick_xml/writer/struct.Writer.html \"struct quick_xml::writer::Writer\"): A XML writer. Can be nested with readers if you want to transform XMLs.\n\n\nEspecially for nested XML elements, the user must keep track _where_ (how deep) in the XML document the current event is located.\nquick-xml contains optional support of asynchronous reading and writing using [tokio](https://tokio.rs/). To get it enable the [`async-tokio`](https://docs.rs/quick-xml/latest/quick_xml/#async-tokio) feature.\nFurthermore, quick-xml also contains optional [Serde](https://serde.rs/) support to directly serialize and deserialize from structs, without having to deal with the XML events. To get it enable the [`serialize`](https://docs.rs/quick-xml/latest/quick_xml/#serialize) feature. Read more about mapping Rust types to XML in the documentation of [`de`](https://docs.rs/quick-xml/latest/quick_xml/de/index.html) module. Also check [`serde_helpers`](https://docs.rs/quick-xml/latest/quick_xml/serde_helpers/index.html \"mod quick_xml::serde_helpers\") module.\n## [\u00a7](https://docs.rs/quick-xml/latest/quick_xml/#examples)Examples\n  * For a reading example see [`Reader`](https://docs.rs/quick-xml/latest/quick_xml/reader/struct.Reader.html \"struct quick_xml::reader::Reader\")\n  * For a writing example see [`Writer`](https://docs.rs/quick-xml/latest/quick_xml/writer/struct.Writer.html \"struct quick_xml::writer::Writer\")\n\n\n## [\u00a7](https://docs.rs/quick-xml/latest/quick_xml/#features)Features\n`quick-xml` supports the following features:\n  * [**`async-tokio`**](https://docs.rs/quick-xml/latest/quick_xml/#async-tokio)\u2014 Enables support for asynchronous reading and writing from`tokio`\u2019s IO-Traits by enabling [reading events](https://docs.rs/quick-xml/latest/quick_xml/reader/struct.Reader.html#method.read_event_into_async \"method quick_xml::reader::Reader::read_event_into_async\") from types implementing [`tokio::io::AsyncBufRead`](https://docs.rs/tokio/1.45.1/x86_64-unknown-linux-gnu/tokio/io/async_buf_read/trait.AsyncBufRead.html \"trait tokio::io::async_buf_read::AsyncBufRead\").\n  * [**`encoding`**](https://docs.rs/quick-xml/latest/quick_xml/#encoding)\u2014 Enables support of non-UTF-8 encoded documents. Encoding will be inferred from the XML declaration if it is found, otherwise UTF-8 is assumed.\nCurrently, only ASCII-compatible encodings are supported. For example, UTF-16 will not work (therefore, `quick-xml` is not [standard compliant](https://www.w3.org/TR/xml11/#charencoding)).\nThus, quick-xml supports all encodings of [`encoding_rs`](https://docs.rs/encoding_rs/0.8.35/x86_64-unknown-linux-gnu/encoding_rs/index.html \"mod encoding_rs\") except these:\n    * [UTF-16BE](https://docs.rs/encoding_rs/0.8.35/x86_64-unknown-linux-gnu/encoding_rs/static.UTF_16BE.html \"static encoding_rs::UTF_16BE\")\n    * [UTF-16LE](https://docs.rs/encoding_rs/0.8.35/x86_64-unknown-linux-gnu/encoding_rs/static.UTF_16LE.html \"static encoding_rs::UTF_16LE\")\n    * [ISO-2022-JP](https://docs.rs/encoding_rs/0.8.35/x86_64-unknown-linux-gnu/encoding_rs/static.ISO_2022_JP.html \"static encoding_rs::ISO_2022_JP\")\nYou should stop processing a document when one of these encodings is detected, because generated events can be wrong and do not reflect a real document structure!\nBecause these are the only supported encodings that are not ASCII compatible, you can check for them:\n```\nuse quick_xml::events::Event;\nuse quick_xml::reader::Reader;\nlet xml = to_utf16le_with_bom(r#\"<?xml encoding='UTF-16'><element/>\"#);\nlet mut reader = Reader::from_reader(xml.as_ref());\nreader.config_mut().trim_text(true);\nlet mut buf = Vec::new();\nlet mut unsupported = false;\nloop {\n  if !reader.decoder().encoding().is_ascii_compatible() {\n    unsupported = true;\n    break;\n  }\n  buf.clear();\n  match reader.read_event_into(&mut buf).unwrap() {\n    Event::Eof => break,\n    _ => {}\n  }\n}\nassert_eq!(unsupported, true);\n```\n\nThis restriction will be eliminated once issue [#158](https://github.com/tafia/quick-xml/issues/158) is resolved.\n  * [**`escape-html`**](https://docs.rs/quick-xml/latest/quick_xml/#escape-html)\u2014 Enables support for recognizing all[HTML 5 entities](https://dev.w3.org/html5/html-author/charref) in [`unescape`](https://docs.rs/quick-xml/latest/quick_xml/escape/fn.unescape.html \"fn quick_xml::escape::unescape\") function. The full list of entities also can be found in <https://html.spec.whatwg.org/entities.json>.\n  * [**`overlapped-lists`**](https://docs.rs/quick-xml/latest/quick_xml/#overlapped-lists)\u2014 This feature is for the Serde deserializer that enables support for deserializing lists where tags are overlapped with tags that do not correspond to the list.\nWhen this feature is enabled, the XML:\n```\n<any-name>\n <item/>\n <another-item/>\n <item/>\n <item/>\n</any-name>\n```\n\ncould be deserialized to a struct:\n```\n#[derive(Deserialize)]\n#[serde(rename_all = \"kebab-case\")]\nstruct AnyName {\n item: Vec<()>,\n another_item: (),\n}\n```\n\nWhen this feature is not enabled (default), only the first element will be associated with the field, and the deserialized type will report an error (duplicated field) when the deserializer encounters a second `<item/>`.\nNote, that enabling this feature can lead to high and even unlimited memory consumption, because deserializer needs to check all events up to the end of a container tag (`</any-name>` in this example) to figure out that there are no more items for a field. If `</any-name>` or even EOF is not encountered, the parsing will never end which can lead to a denial-of-service (DoS) scenario.\nHaving several lists and overlapped elements for them in XML could also lead to quadratic parsing time, because the deserializer must check the list of events as many times as the number of sequence fields present in the schema.\nTo reduce negative consequences, always [limit](https://docs.rs/quick-xml/latest/quick_xml/de/struct.Deserializer.html#method.event_buffer_size \"method quick_xml::de::Deserializer::event_buffer_size\") the maximum number of events that [`Deserializer`](https://docs.rs/quick-xml/latest/quick_xml/de/struct.Deserializer.html \"struct quick_xml::de::Deserializer\") will buffer.\nThis feature works only with `serialize` feature and has no effect if `serialize` is not enabled.\n  * [**`serde-types`**](https://docs.rs/quick-xml/latest/quick_xml/#serde-types)\u2014 Enables serialization of some quick-xml types using[`serde`](https://docs.rs/serde/1.0.219/x86_64-unknown-linux-gnu/serde/index.html \"mod serde\"). This feature is rarely needed.\nThis feature does NOT provide XML serializer or deserializer. You should use the `serialize` feature for that instead.\n  * [**`serialize`**](https://docs.rs/quick-xml/latest/quick_xml/#serialize)\u2014 Enables support for[`serde`](https://docs.rs/serde/1.0.219/x86_64-unknown-linux-gnu/serde/index.html \"mod serde\") serialization and deserialization. When this feature is enabled, quick-xml provides serializer and deserializer for XML.\nThis feature does NOT enables serializaton of the types inside quick-xml. If you need that, use the `serde-types` feature.\n\n\n## Re-exports[\u00a7](https://docs.rs/quick-xml/latest/quick_xml/#reexports)\n\n`pub use crate::encoding::Decoder[](https://docs.rs/quick-xml/latest/quick_xml/encoding/struct.Decoder.html \"struct quick_xml::encoding::Decoder\");`\n\n\n`pub use crate::errors::serialize::DeError[](https://docs.rs/quick-xml/latest/quick_xml/errors/serialize/enum.DeError.html \"enum quick_xml::errors::serialize::DeError\");``serialize`\n\n\n`pub use crate::errors::serialize::SeError[](https://docs.rs/quick-xml/latest/quick_xml/errors/serialize/enum.SeError.html \"enum quick_xml::errors::serialize::SeError\");``serialize`\n\n\n`pub use crate::errors::Error[](https://docs.rs/quick-xml/latest/quick_xml/errors/enum.Error.html \"enum quick_xml::errors::Error\");`\n\n\n`pub use crate::errors::Result[](https://docs.rs/quick-xml/latest/quick_xml/errors/type.Result.html \"type quick_xml::errors::Result\");`\n\n\n`pub use crate::reader::NsReader[](https://docs.rs/quick-xml/latest/quick_xml/reader/struct.NsReader.html \"struct quick_xml::reader::NsReader\");`\n\n\n`pub use crate::reader::Reader[](https://docs.rs/quick-xml/latest/quick_xml/reader/struct.Reader.html \"struct quick_xml::reader::Reader\");`\n\n\n`pub use crate::writer::ElementWriter[](https://docs.rs/quick-xml/latest/quick_xml/writer/struct.ElementWriter.html \"struct quick_xml::writer::ElementWriter\");`\n\n\n`pub use crate::writer::Writer[](https://docs.rs/quick-xml/latest/quick_xml/writer/struct.Writer.html \"struct quick_xml::writer::Writer\");`\n\n## Modules[\u00a7](https://docs.rs/quick-xml/latest/quick_xml/#modules)\n\n[de](https://docs.rs/quick-xml/latest/quick_xml/de/index.html \"mod quick_xml::de\")`serialize`\n    Serde `Deserializer` module.\n\n[encoding](https://docs.rs/quick-xml/latest/quick_xml/encoding/index.html \"mod quick_xml::encoding\")\n    A module for wrappers that encode / decode data.\n\n[errors](https://docs.rs/quick-xml/latest/quick_xml/errors/index.html \"mod quick_xml::errors\")\n    Error management module\n\n[escape](https://docs.rs/quick-xml/latest/quick_xml/escape/index.html \"mod quick_xml::escape\")\n    Manage xml character escapes\n\n[events](https://docs.rs/quick-xml/latest/quick_xml/events/index.html \"mod quick_xml::events\")\n    Defines zero-copy XML events used throughout this library.\n\n[name](https://docs.rs/quick-xml/latest/quick_xml/name/index.html \"mod quick_xml::name\")\n    Module for handling names according to the W3C [Namespaces in XML 1.1 (Second Edition)](https://www.w3.org/TR/xml-names11) specification\n\n[parser](https://docs.rs/quick-xml/latest/quick_xml/parser/index.html \"mod quick_xml::parser\")\n    Contains low-level parsers of different XML pieces.\n\n[reader](https://docs.rs/quick-xml/latest/quick_xml/reader/index.html \"mod quick_xml::reader\")\n    Contains high-level interface for a pull-based XML parser.\n\n[se](https://docs.rs/quick-xml/latest/quick_xml/se/index.html \"mod quick_xml::se\")`serialize`\n    Module to handle custom serde `Serializer`\n\n[serde_helpers](https://docs.rs/quick-xml/latest/quick_xml/serde_helpers/index.html \"mod quick_xml::serde_helpers\")`serde-types`\n    Provides helper functions to glue an XML with a serde content model.\n\n[writer](https://docs.rs/quick-xml/latest/quick_xml/writer/index.html \"mod quick_xml::writer\")\n    Contains high-level interface for an events-based XML emitter.\n## Macros[\u00a7](https://docs.rs/quick-xml/latest/quick_xml/#macros)\n\n[impl_deserialize_for_internally_tagged_enum](https://docs.rs/quick-xml/latest/quick_xml/macro.impl_deserialize_for_internally_tagged_enum.html \"macro quick_xml::impl_deserialize_for_internally_tagged_enum\")`serde-types`\n    A helper to implement [`Deserialize`](https://docs.rs/serde/1.0.219/x86_64-unknown-linux-gnu/serde/de/trait.Deserialize.html \"trait serde::de::Deserialize\") for [internally tagged](https://serde.rs/enum-representations.html#internally-tagged) enums which does not use [`Deserializer::deserialize_any`](https://docs.rs/serde/1.0.219/x86_64-unknown-linux-gnu/serde/de/trait.Deserializer.html#tymethod.deserialize_any \"method serde::de::Deserializer::deserialize_any\") that produces wrong results with XML because of [serde#1183](https://github.com/serde-rs/serde/issues/1183).\n",
            "markdown_with_citations": "[](https://docs.rs/quick-xml/latest/quick_xml/all.html \"show sidebar\")\n# Crate quick_xmlCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nHigh performance XML reader/writer.\n## \u00a7\u27e84\u27e9Description\nquick-xml contains two modes of operation:\nA streaming API based on the StAX\u27e85\u27e9 model. This is suited for larger XML documents which cannot completely read into memory at once.\nThe user has to explicitly _ask_ for the next XML event, similar to a database cursor. This is achieved by the following two structs:\n  * `Reader`\u27e86\u27e9: A low level XML pull-reader where buffer allocation/clearing is left to user.\n  * `Writer`\u27e87\u27e9: A XML writer. Can be nested with readers if you want to transform XMLs.\n\n\nEspecially for nested XML elements, the user must keep track _where_ (how deep) in the XML document the current event is located.\nquick-xml contains optional support of asynchronous reading and writing using tokio\u27e88\u27e9. To get it enable the `async-tokio`\u27e89\u27e9 feature.\nFurthermore, quick-xml also contains optional Serde\u27e810\u27e9 support to directly serialize and deserialize from structs, without having to deal with the XML events. To get it enable the `serialize`\u27e811\u27e9 feature. Read more about mapping Rust types to XML in the documentation of `de`\u27e812\u27e9 module. Also check `serde_helpers`\u27e813\u27e9 module.\n## \u00a7\u27e814\u27e9Examples\n  * For a reading example see `Reader`\u27e86\u27e9\n  * For a writing example see `Writer`\u27e87\u27e9\n\n\n## \u00a7\u27e815\u27e9Features\n`quick-xml` supports the following features:\n  * **`async-tokio`**\u27e89\u27e9\u2014 Enables support for asynchronous reading and writing from`tokio`\u2019s IO-Traits by enabling reading events\u27e816\u27e9 from types implementing `tokio::io::AsyncBufRead`\u27e817\u27e9.\n  * **`encoding`**\u27e818\u27e9\u2014 Enables support of non-UTF-8 encoded documents. Encoding will be inferred from the XML declaration if it is found, otherwise UTF-8 is assumed.\nCurrently, only ASCII-compatible encodings are supported. For example, UTF-16 will not work (therefore, `quick-xml` is not standard compliant\u27e819\u27e9).\nThus, quick-xml supports all encodings of `encoding_rs`\u27e820\u27e9 except these:\n    * UTF-16BE\u27e821\u27e9\n    * UTF-16LE\u27e822\u27e9\n    * ISO-2022-JP\u27e823\u27e9\nYou should stop processing a document when one of these encodings is detected, because generated events can be wrong and do not reflect a real document structure!\nBecause these are the only supported encodings that are not ASCII compatible, you can check for them:\n```\nuse quick_xml::events::Event;\nuse quick_xml::reader::Reader;\nlet xml = to_utf16le_with_bom(r#\"<?xml encoding='UTF-16'><element/>\"#);\nlet mut reader = Reader::from_reader(xml.as_ref());\nreader.config_mut().trim_text(true);\nlet mut buf = Vec::new();\nlet mut unsupported = false;\nloop {\n  if !reader.decoder().encoding().is_ascii_compatible() {\n    unsupported = true;\n    break;\n  }\n  buf.clear();\n  match reader.read_event_into(&mut buf).unwrap() {\n    Event::Eof => break,\n    _ => {}\n  }\n}\nassert_eq!(unsupported, true);\n```\n\nThis restriction will be eliminated once issue #158\u27e824\u27e9 is resolved.\n  * **`escape-html`**\u27e825\u27e9\u2014 Enables support for recognizing allHTML 5 entities\u27e826\u27e9 in `unescape`\u27e827\u27e9 function. The full list of entities also can be found in <https://html.spec.whatwg.org/entities.json>.\n  * **`overlapped-lists`**\u27e828\u27e9\u2014 This feature is for the Serde deserializer that enables support for deserializing lists where tags are overlapped with tags that do not correspond to the list.\nWhen this feature is enabled, the XML:\n```\n<any-name>\n <item/>\n <another-item/>\n <item/>\n <item/>\n</any-name>\n```\n\ncould be deserialized to a struct:\n```\n#[derive(Deserialize)]\n#[serde(rename_all = \"kebab-case\")]\nstruct AnyName {\n item: Vec<()>,\n another_item: (),\n}\n```\n\nWhen this feature is not enabled (default), only the first element will be associated with the field, and the deserialized type will report an error (duplicated field) when the deserializer encounters a second `<item/>`.\nNote, that enabling this feature can lead to high and even unlimited memory consumption, because deserializer needs to check all events up to the end of a container tag (`</any-name>` in this example) to figure out that there are no more items for a field. If `</any-name>` or even EOF is not encountered, the parsing will never end which can lead to a denial-of-service (DoS) scenario.\nHaving several lists and overlapped elements for them in XML could also lead to quadratic parsing time, because the deserializer must check the list of events as many times as the number of sequence fields present in the schema.\nTo reduce negative consequences, always limit\u27e829\u27e9 the maximum number of events that `Deserializer`\u27e830\u27e9 will buffer.\nThis feature works only with `serialize` feature and has no effect if `serialize` is not enabled.\n  * **`serde-types`**\u27e831\u27e9\u2014 Enables serialization of some quick-xml types using`serde`\u27e832\u27e9. This feature is rarely needed.\nThis feature does NOT provide XML serializer or deserializer. You should use the `serialize` feature for that instead.\n  * **`serialize`**\u27e811\u27e9\u2014 Enables support for`serde`\u27e832\u27e9 serialization and deserialization. When this feature is enabled, quick-xml provides serializer and deserializer for XML.\nThis feature does NOT enables serializaton of the types inside quick-xml. If you need that, use the `serde-types` feature.\n\n\n## Re-exports\u00a7\u27e833\u27e9\n\n`pub use crate::encoding::Decoder[](https://docs.rs/quick-xml/latest/quick_xml/encoding/struct.Decoder.html \"struct quick_xml::encoding::Decoder\");`\n\n\n`pub use crate::errors::serialize::DeError[](https://docs.rs/quick-xml/latest/quick_xml/errors/serialize/enum.DeError.html \"enum quick_xml::errors::serialize::DeError\");``serialize`\n\n\n`pub use crate::errors::serialize::SeError[](https://docs.rs/quick-xml/latest/quick_xml/errors/serialize/enum.SeError.html \"enum quick_xml::errors::serialize::SeError\");``serialize`\n\n\n`pub use crate::errors::Error[](https://docs.rs/quick-xml/latest/quick_xml/errors/enum.Error.html \"enum quick_xml::errors::Error\");`\n\n\n`pub use crate::errors::Result[](https://docs.rs/quick-xml/latest/quick_xml/errors/type.Result.html \"type quick_xml::errors::Result\");`\n\n\n`pub use crate::reader::NsReader[](https://docs.rs/quick-xml/latest/quick_xml/reader/struct.NsReader.html \"struct quick_xml::reader::NsReader\");`\n\n\n`pub use crate::reader::Reader[](https://docs.rs/quick-xml/latest/quick_xml/reader/struct.Reader.html \"struct quick_xml::reader::Reader\");`\n\n\n`pub use crate::writer::ElementWriter[](https://docs.rs/quick-xml/latest/quick_xml/writer/struct.ElementWriter.html \"struct quick_xml::writer::ElementWriter\");`\n\n\n`pub use crate::writer::Writer[](https://docs.rs/quick-xml/latest/quick_xml/writer/struct.Writer.html \"struct quick_xml::writer::Writer\");`\n\n## Modules\u00a7\u27e834\u27e9\n\nde\u27e812\u27e9`serialize`\n    Serde `Deserializer` module.\n\nencoding\u27e835\u27e9\n    A module for wrappers that encode / decode data.\n\nerrors\u27e836\u27e9\n    Error management module\n\nescape\u27e837\u27e9\n    Manage xml character escapes\n\nevents\u27e838\u27e9\n    Defines zero-copy XML events used throughout this library.\n\nname\u27e839\u27e9\n    Module for handling names according to the W3C Namespaces in XML 1.1 (Second Edition)\u27e840\u27e9 specification\n\nparser\u27e841\u27e9\n    Contains low-level parsers of different XML pieces.\n\nreader\u27e842\u27e9\n    Contains high-level interface for a pull-based XML parser.\n\nse\u27e843\u27e9`serialize`\n    Module to handle custom serde `Serializer`\n\nserde_helpers\u27e813\u27e9`serde-types`\n    Provides helper functions to glue an XML with a serde content model.\n\nwriter\u27e844\u27e9\n    Contains high-level interface for an events-based XML emitter.\n## Macros\u00a7\u27e845\u27e9\n\nimpl_deserialize_for_internally_tagged_enum\u27e846\u27e9`serde-types`\n    A helper to implement `Deserialize`\u27e847\u27e9 for internally tagged\u27e848\u27e9 enums which does not use `Deserializer::deserialize_any`\u27e849\u27e9 that produces wrong results with XML because of serde#1183\u27e850\u27e9.\n",
            "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/quick-xml/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/quick-xml/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/quick-xml/latest/src/quick_xml/lib.rs.html#1-79: Source\n\u27e84\u27e9 https://docs.rs/quick-xml/latest/quick_xml/#description: \u00a7\n\u27e85\u27e9 https://en.wikipedia.org/wiki/StAX: StAX\n\u27e86\u27e9 https://docs.rs/quick-xml/latest/quick_xml/reader/struct.Reader.html: struct quick_xml::reader::Reader - `Reader`\n\u27e87\u27e9 https://docs.rs/quick-xml/latest/quick_xml/writer/struct.Writer.html: struct quick_xml::writer::Writer - `Writer`\n\u27e88\u27e9 https://tokio.rs/: tokio\n\u27e89\u27e9 https://docs.rs/quick-xml/latest/quick_xml/#async-tokio: `async-tokio`\n\u27e810\u27e9 https://serde.rs/: Serde\n\u27e811\u27e9 https://docs.rs/quick-xml/latest/quick_xml/#serialize: `serialize`\n\u27e812\u27e9 https://docs.rs/quick-xml/latest/quick_xml/de/index.html: `de`\n\u27e813\u27e9 https://docs.rs/quick-xml/latest/quick_xml/serde_helpers/index.html: mod quick_xml::serde_helpers - `serde_helpers`\n\u27e814\u27e9 https://docs.rs/quick-xml/latest/quick_xml/#examples: \u00a7\n\u27e815\u27e9 https://docs.rs/quick-xml/latest/quick_xml/#features: \u00a7\n\u27e816\u27e9 https://docs.rs/quick-xml/latest/quick_xml/reader/struct.Reader.html#method.read_event_into_async: method quick_xml::reader::Reader::read_event_into_async - reading events\n\u27e817\u27e9 https://docs.rs/tokio/1.45.1/x86_64-unknown-linux-gnu/tokio/io/async_buf_read/trait.AsyncBufRead.html: trait tokio::io::async_buf_read::AsyncBufRead - `tokio::io::AsyncBufRead`\n\u27e818\u27e9 https://docs.rs/quick-xml/latest/quick_xml/#encoding: **`encoding`**\n\u27e819\u27e9 https://www.w3.org/TR/xml11/#charencoding: standard compliant\n\u27e820\u27e9 https://docs.rs/encoding_rs/0.8.35/x86_64-unknown-linux-gnu/encoding_rs/index.html: mod encoding_rs - `encoding_rs`\n\u27e821\u27e9 https://docs.rs/encoding_rs/0.8.35/x86_64-unknown-linux-gnu/encoding_rs/static.UTF_16BE.html: static encoding_rs::UTF_16BE - UTF-16BE\n\u27e822\u27e9 https://docs.rs/encoding_rs/0.8.35/x86_64-unknown-linux-gnu/encoding_rs/static.UTF_16LE.html: static encoding_rs::UTF_16LE - UTF-16LE\n\u27e823\u27e9 https://docs.rs/encoding_rs/0.8.35/x86_64-unknown-linux-gnu/encoding_rs/static.ISO_2022_JP.html: static encoding_rs::ISO_2022_JP - ISO-2022-JP\n\u27e824\u27e9 https://github.com/tafia/quick-xml/issues/158: #158\n\u27e825\u27e9 https://docs.rs/quick-xml/latest/quick_xml/#escape-html: **`escape-html`**\n\u27e826\u27e9 https://dev.w3.org/html5/html-author/charref: HTML 5 entities\n\u27e827\u27e9 https://docs.rs/quick-xml/latest/quick_xml/escape/fn.unescape.html: fn quick_xml::escape::unescape - `unescape`\n\u27e828\u27e9 https://docs.rs/quick-xml/latest/quick_xml/#overlapped-lists: **`overlapped-lists`**\n\u27e829\u27e9 https://docs.rs/quick-xml/latest/quick_xml/de/struct.Deserializer.html#method.event_buffer_size: method quick_xml::de::Deserializer::event_buffer_size - limit\n\u27e830\u27e9 https://docs.rs/quick-xml/latest/quick_xml/de/struct.Deserializer.html: struct quick_xml::de::Deserializer - `Deserializer`\n\u27e831\u27e9 https://docs.rs/quick-xml/latest/quick_xml/#serde-types: **`serde-types`**\n\u27e832\u27e9 https://docs.rs/serde/1.0.219/x86_64-unknown-linux-gnu/serde/index.html: mod serde - `serde`\n\u27e833\u27e9 https://docs.rs/quick-xml/latest/quick_xml/#reexports: \u00a7\n\u27e834\u27e9 https://docs.rs/quick-xml/latest/quick_xml/#modules: \u00a7\n\u27e835\u27e9 https://docs.rs/quick-xml/latest/quick_xml/encoding/index.html: mod quick_xml::encoding - encoding\n\u27e836\u27e9 https://docs.rs/quick-xml/latest/quick_xml/errors/index.html: mod quick_xml::errors - errors\n\u27e837\u27e9 https://docs.rs/quick-xml/latest/quick_xml/escape/index.html: mod quick_xml::escape - escape\n\u27e838\u27e9 https://docs.rs/quick-xml/latest/quick_xml/events/index.html: mod quick_xml::events - events\n\u27e839\u27e9 https://docs.rs/quick-xml/latest/quick_xml/name/index.html: mod quick_xml::name - name\n\u27e840\u27e9 https://www.w3.org/TR/xml-names11: Namespaces in XML 1.1 (Second Edition)\n\u27e841\u27e9 https://docs.rs/quick-xml/latest/quick_xml/parser/index.html: mod quick_xml::parser - parser\n\u27e842\u27e9 https://docs.rs/quick-xml/latest/quick_xml/reader/index.html: mod quick_xml::reader - reader\n\u27e843\u27e9 https://docs.rs/quick-xml/latest/quick_xml/se/index.html: mod quick_xml::se - se\n\u27e844\u27e9 https://docs.rs/quick-xml/latest/quick_xml/writer/index.html: mod quick_xml::writer - writer\n\u27e845\u27e9 https://docs.rs/quick-xml/latest/quick_xml/#macros: \u00a7\n\u27e846\u27e9 https://docs.rs/quick-xml/latest/quick_xml/macro.impl_deserialize_for_internally_tagged_enum.html: macro quick_xml::impl_deserialize_for_internally_tagged_enum - impl_deserialize_for_internally_tagged_enum\n\u27e847\u27e9 https://docs.rs/serde/1.0.219/x86_64-unknown-linux-gnu/serde/de/trait.Deserialize.html: trait serde::de::Deserialize - `Deserialize`\n\u27e848\u27e9 https://serde.rs/enum-representations.html#internally-tagged: internally tagged\n\u27e849\u27e9 https://docs.rs/serde/1.0.219/x86_64-unknown-linux-gnu/serde/de/trait.Deserializer.html#tymethod.deserialize_any: method serde::de::Deserializer::deserialize_any - `Deserializer::deserialize_any`\n\u27e850\u27e9 https://github.com/serde-rs/serde/issues/1183: serde#1183\n",
            "fit_markdown": "",
            "fit_html": ""
          },
          "downloads": 0,
          "github_stars": 0,
          "dependencies": [],
          "features": {},
          "code_snippets": [],
          "readme_sections": {},
          "librs_downloads": null,
          "source": "crates.io",
          "enhanced_scraping": {},
          "enhanced_features": [],
          "enhanced_dependencies": [],
          "readme_summary": "The `quick-xml` crate is a high-performance XML reader and writer for Rust, offering both a streaming StAX-based API for large documents and optional Serde integration for XML serialization/deserialization. Key features include asynchronous support via Tokio (`async-tokio`), handling non-UTF-8 encodings (`encoding`), HTML entity unescaping (`escape-html`), and advanced Serde deserialization options like overlapped lists (`overlapped-lists`). It is suitable for efficient XML processing with customizable features for specific use cases.",
          "feature_summary": null,
          "use_case": "Serialization",
          "score": 7.0,
          "factual_counterfactual": "### Pair 1: Streaming API  \n\u2705 Factual: `quick-xml` provides a streaming API based on the StAX model, allowing users to process large XML documents incrementally without loading the entire document into memory.  \n\u274c Counterfactual: `quick-xml` processes XML documents entirely in memory by default, making it unsuitable for large files.  \n\n---\n\n### Pair 2: Encoding Support  \n\u2705 Factual: `quick-xml` supports ASCII-compatible encodings, but does not support UTF-16 or ISO-2022-JP due to limitations in the underlying `encoding_rs` library.  \n\u274c Counterfactual: `quick-xml` fully supports all XML encodings, including UTF-16 and ISO-2022-JP, as defined by the XML standard.  \n\n---\n\n### Pair 3: Serde Integration  \n\u2705 Factual: `quick-xml` offers optional Serde support, enabling users to serialize and deserialize XML directly into Rust structs by enabling the `serialize` feature.  \n\u274c Counterfactual: `quick-xml` requires manual parsing of XML events and does not support Serde integration for serialization or deserialization.",
          "source_analysis": null,
          "user_behavior": null,
          "security": null
        }
      },
      "irl_score": 8.6,
      "execution_id": "exec-bd8dc2d9-1631cfa6-1751259154",
      "timestamp": "2025-06-30T04:52:34.265623+00:00",
      "canon_version": "1.3.0"
    },
    "rule_zero_compliant": true
  }
]