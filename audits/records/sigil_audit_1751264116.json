[
  {
    "execution_id": "exec-a2c183d5-7cd7101f-1751264107",
    "timestamp": "2025-06-30T06:15:07.107059+00:00",
    "sacred_chain": {
      "input_data": "paste",
      "context_sources": [
        "crates.io",
        "github.com",
        "lib.rs",
        "docs.rs"
      ],
      "reasoning_steps": [
        "Input canonicalized: 'paste' -> 'paste'",
        "Context gathered from 4 validated sources",
        "Metadata extracted: 4 fields",
        "Documentation analyzed: quality 7.0",
        "Sentiment analyzed: positive",
        "Ecosystem analyzed: utilities",
        "Quality score synthesized: 7.50",
        "Trust decision: DEFER - Insufficient data for decision",
        "IRL confidence: 8.600"
      ],
      "suggestion": "ALLOW: Positive community sentiment",
      "verdict": "DEFER",
      "audit_info": {
        "metadata": {
          "name": "paste",
          "type": "rust_crate",
          "source": "manual_input",
          "extraction_method": "irl_engine"
        },
        "sentiment": {
          "quality_score": 7.0,
          "completeness": 0.8,
          "examples_present": true,
          "api_documented": true
        },
        "ecosystem": {
          "overall": "positive",
          "positive_mentions": 10,
          "negative_mentions": 2,
          "neutral_mentions": 5,
          "total_mentions": 17
        },
        "quality_score": 7.5,
        "verdict_reason": "Insufficient data for decision",
        "sanitized_documentation": {
          "crates_io": {
            "url": "https://crates.io/crates/paste",
            "title": "paste v1.0.15",
            "content": {
              "raw_markdown": "#  paste v1.0.15\nMacros for all your token pasting needs \n  * [ #macros ](https://crates.io/keywords/macros)\n\n\n  * [ Readme ](https://crates.io/crates/paste)\n  * [ 35 Versions ](https://crates.io/crates/paste/versions)\n  * [ Dependencies ](https://crates.io/crates/paste/dependencies)\n  * [ Dependents ](https://crates.io/crates/paste/reverse_dependencies)\n\n\n## Metadata\nabout 1 year ago \nv1.31.0 \n[ MIT ](https://choosealicense.com/licenses/mit) OR [ Apache-2.0 ](https://choosealicense.com/licenses/apache-2.0)\n17.9 KiB \n## Install\nRun the following Cargo command in your project directory:\ncargo add paste\nOr add the following line to your Cargo.toml:\npaste = \"1.0.15\"\n## Documentation\n[ docs.rs/paste ](https://docs.rs/paste)\n## Repository\n[ github.com/dtolnay/paste ](https://github.com/dtolnay/paste)\n## Owners\n## Categories\n  * [No dynamic allocation](https://crates.io/categories/no-std::no-alloc)\n  * [Development tools](https://crates.io/categories/development-tools)\n  * [No standard library](https://crates.io/categories/no-std)\n\n\n[ Report crate ](https://crates.io/support?crate=paste&inquire=crate-violation)\n### Stats Overview\n219,077,570 Downloads all time\n35 Versions published\n#### Downloads over the last 90 days\nDisplay as \nStacked \n  * Stacked \n  * Unstacked \n\n\nLoading\u2026\n",
              "markdown_with_citations": "#  paste v1.0.15\nMacros for all your token pasting needs \n  *  #macros \u27e81\u27e9\n\n\n  *  Readme \u27e82\u27e9\n  *  35 Versions \u27e83\u27e9\n  *  Dependencies \u27e84\u27e9\n  *  Dependents \u27e85\u27e9\n\n\n## Metadata\nabout 1 year ago \nv1.31.0 \n MIT \u27e86\u27e9 OR  Apache-2.0 \u27e87\u27e9\n17.9 KiB \n## Install\nRun the following Cargo command in your project directory:\ncargo add paste\nOr add the following line to your Cargo.toml:\npaste = \"1.0.15\"\n## Documentation\n docs.rs/paste \u27e88\u27e9\n## Repository\n github.com/dtolnay/paste \u27e89\u27e9\n## Owners\n## Categories\n  * No dynamic allocation\u27e810\u27e9\n  * Development tools\u27e811\u27e9\n  * No standard library\u27e812\u27e9\n\n\n Report crate \u27e813\u27e9\n### Stats Overview\n219,077,570 Downloads all time\n35 Versions published\n#### Downloads over the last 90 days\nDisplay as \nStacked \n  * Stacked \n  * Unstacked \n\n\nLoading\u2026\n",
              "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://crates.io/keywords/macros:  #macros \n\u27e82\u27e9 https://crates.io/crates/paste:  Readme \n\u27e83\u27e9 https://crates.io/crates/paste/versions:  35 Versions \n\u27e84\u27e9 https://crates.io/crates/paste/dependencies:  Dependencies \n\u27e85\u27e9 https://crates.io/crates/paste/reverse_dependencies:  Dependents \n\u27e86\u27e9 https://choosealicense.com/licenses/mit:  MIT \n\u27e87\u27e9 https://choosealicense.com/licenses/apache-2.0:  Apache-2.0 \n\u27e88\u27e9 https://docs.rs/paste:  docs.rs/paste \n\u27e89\u27e9 https://github.com/dtolnay/paste:  github.com/dtolnay/paste \n\u27e810\u27e9 https://crates.io/categories/no-std::no-alloc: No dynamic allocation\n\u27e811\u27e9 https://crates.io/categories/development-tools: Development tools\n\u27e812\u27e9 https://crates.io/categories/no-std: No standard library\n\u27e813\u27e9 https://crates.io/support?crate=paste&inquire=crate-violation:  Report crate \n",
              "fit_markdown": "",
              "fit_html": ""
            },
            "structured_data": {},
            "quality_score": 3.0,
            "extraction_method": "crawl4ai",
            "error": null,
            "metadata": {
              "doc_type": "docs",
              "content_length": 1292,
              "has_structured_data": false,
              "crawl_success": true
            },
            "timestamp": "117896.9631802"
          },
          "docs_rs": {
            "url": "https://docs.rs/paste",
            "title": "Crate pasteCopy item path",
            "content": {
              "raw_markdown": "[](https://docs.rs/paste/latest/paste/all.html \"show sidebar\")\n# Crate pasteCopy item path\n[Settings](https://docs.rs/paste/latest/settings.html)\n[Help](https://docs.rs/paste/latest/help.html)\nSummary[Source](https://docs.rs/paste/latest/src/paste/lib.rs.html#1-454)\nExpand description\n[![github](https://img.shields.io/badge/github-8da0cb?style=for-the-badge&labelColor=555555&logo=github)](https://github.com/dtolnay/paste) [![crates-io](https://img.shields.io/badge/crates.io-fc8d62?style=for-the-badge&labelColor=555555&logo=rust)](https://crates.io/crates/paste) [![docs-rs](https://img.shields.io/badge/docs.rs-66c2a5?style=for-the-badge&labelColor=555555&logo=docs.rs)](https://docs.rs/paste)\nThe nightly-only [`concat_idents!`](https://doc.rust-lang.org/std/macro.concat_idents.html) macro in the Rust standard library is notoriously underpowered in that its concatenated identifiers can only refer to existing items, they can never be used to define something new.\nThis crate provides a flexible way to paste together identifiers in a macro, including using pasted identifiers to define new items.\nThis approach works with any Rust compiler 1.31+.\n## [\u00a7](https://docs.rs/paste/latest/paste/#pasting-identifiers)Pasting identifiers\nWithin the `paste!` macro, identifiers inside `[<`\u2026`>]` are pasted together to form a single identifier.\n```\nuse paste::paste;\npaste! {\n  // Defines a const called `QRST`.\n  const [<Q R S T>]: &str = \"success!\";\n}\nfn main() {\n  assert_eq!(\n    paste! { [<Q R S T>].len() },\n    8,\n  );\n}\n```\n\n## [\u00a7](https://docs.rs/paste/latest/paste/#more-elaborate-example)More elaborate example\nThe next example shows a macro that generates accessor methods for some struct fields. It demonstrates how you might find it useful to bundle a paste invocation inside of a macro_rules macro.\n```\nuse paste::paste;\nmacro_rules! make_a_struct_and_getters {\n  ($name:ident { $($field:ident),* }) => {\n    // Define a struct. This expands to:\n    //\n    //   pub struct S {\n    //     a: String,\n    //     b: String,\n    //     c: String,\n    //   }\n    pub struct $name {\n      $(\n        $field: String,\n      )*\n    }\n    // Build an impl block with getters. This expands to:\n    //\n    //   impl S {\n    //     pub fn get_a(&self) -> &str { &self.a }\n    //     pub fn get_b(&self) -> &str { &self.b }\n    //     pub fn get_c(&self) -> &str { &self.c }\n    //   }\n    paste! {\n      impl $name {\n        $(\n          pub fn [<get_ $field>](&self) -> &str {\n            &self.$field\n          }\n        )*\n      }\n    }\n  }\n}\nmake_a_struct_and_getters!(S { a, b, c });\nfn call_some_getters(s: &S) -> bool {\n  s.get_a() == s.get_b() && s.get_c().is_empty()\n}\n```\n\n## [\u00a7](https://docs.rs/paste/latest/paste/#case-conversion)Case conversion\nUse `$var:lower` or `$var:upper` in the segment list to convert an interpolated segment to lower- or uppercase as part of the paste. For example, `[<ld_ $reg:lower _expr>]` would paste to `ld_bc_expr` if invoked with $reg=`Bc`.\nUse `$var:snake` to convert CamelCase input to snake_case. Use `$var:camel` to convert snake_case to CamelCase. These compose, so for example `$var:snake:upper` would give you SCREAMING_CASE.\nThe precise Unicode conversions are as defined by [`str::to_lowercase`](https://doc.rust-lang.org/std/primitive.str.html#method.to_lowercase) and [`str::to_uppercase`](https://doc.rust-lang.org/std/primitive.str.html#method.to_uppercase).\n## [\u00a7](https://docs.rs/paste/latest/paste/#pasting-documentation-strings)Pasting documentation strings\nWithin the `paste!` macro, arguments to a #[doc \u2026] attribute are implicitly concatenated together to form a coherent documentation string.\n```\nuse paste::paste;\nmacro_rules! method_new {\n  ($ret:ident) => {\n    paste! {\n      #[doc = \"Create a new `\" $ret \"` object.\"]\n      pub fn new() -> $ret { todo!() }\n    }\n  };\n}\npub struct Paste {}\nmethod_new!(Paste); // expands to #[doc = \"Create a new `Paste` object\"]\n```\n\n## Macros[\u00a7](https://docs.rs/paste/latest/paste/#macros)\n\n[paste](https://docs.rs/paste/latest/paste/macro.paste.html \"macro paste::paste\")\n\n",
              "markdown_with_citations": "[](https://docs.rs/paste/latest/paste/all.html \"show sidebar\")\n# Crate pasteCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\n![github\u27e84\u27e9](https://github.com/dtolnay/paste) ![crates-io\u27e85\u27e9](https://crates.io/crates/paste) ![docs-rs\u27e86\u27e9](https://docs.rs/paste)\nThe nightly-only `concat_idents!`\u27e87\u27e9 macro in the Rust standard library is notoriously underpowered in that its concatenated identifiers can only refer to existing items, they can never be used to define something new.\nThis crate provides a flexible way to paste together identifiers in a macro, including using pasted identifiers to define new items.\nThis approach works with any Rust compiler 1.31+.\n## \u00a7\u27e88\u27e9Pasting identifiers\nWithin the `paste!` macro, identifiers inside `[<`\u2026`>]` are pasted together to form a single identifier.\n```\nuse paste::paste;\npaste! {\n  // Defines a const called `QRST`.\n  const [<Q R S T>]: &str = \"success!\";\n}\nfn main() {\n  assert_eq!(\n    paste! { [<Q R S T>].len() },\n    8,\n  );\n}\n```\n\n## \u00a7\u27e89\u27e9More elaborate example\nThe next example shows a macro that generates accessor methods for some struct fields. It demonstrates how you might find it useful to bundle a paste invocation inside of a macro_rules macro.\n```\nuse paste::paste;\nmacro_rules! make_a_struct_and_getters {\n  ($name:ident { $($field:ident),* }) => {\n    // Define a struct. This expands to:\n    //\n    //   pub struct S {\n    //     a: String,\n    //     b: String,\n    //     c: String,\n    //   }\n    pub struct $name {\n      $(\n        $field: String,\n      )*\n    }\n    // Build an impl block with getters. This expands to:\n    //\n    //   impl S {\n    //     pub fn get_a(&self) -> &str { &self.a }\n    //     pub fn get_b(&self) -> &str { &self.b }\n    //     pub fn get_c(&self) -> &str { &self.c }\n    //   }\n    paste! {\n      impl $name {\n        $(\n          pub fn <get_ $field>\u27e810\u27e9 -> &str {\n            &self.$field\n          }\n        )*\n      }\n    }\n  }\n}\nmake_a_struct_and_getters!(S { a, b, c });\nfn call_some_getters(s: &S) -> bool {\n  s.get_a() == s.get_b() && s.get_c().is_empty()\n}\n```\n\n## \u00a7\u27e811\u27e9Case conversion\nUse `$var:lower` or `$var:upper` in the segment list to convert an interpolated segment to lower- or uppercase as part of the paste. For example, `[<ld_ $reg:lower _expr>]` would paste to `ld_bc_expr` if invoked with $reg=`Bc`.\nUse `$var:snake` to convert CamelCase input to snake_case. Use `$var:camel` to convert snake_case to CamelCase. These compose, so for example `$var:snake:upper` would give you SCREAMING_CASE.\nThe precise Unicode conversions are as defined by `str::to_lowercase`\u27e812\u27e9 and `str::to_uppercase`\u27e813\u27e9.\n## \u00a7\u27e814\u27e9Pasting documentation strings\nWithin the `paste!` macro, arguments to a #[doc \u2026] attribute are implicitly concatenated together to form a coherent documentation string.\n```\nuse paste::paste;\nmacro_rules! method_new {\n  ($ret:ident) => {\n    paste! {\n      #[doc = \"Create a new `\" $ret \"` object.\"]\n      pub fn new() -> $ret { todo!() }\n    }\n  };\n}\npub struct Paste {}\nmethod_new!(Paste); // expands to #[doc = \"Create a new `Paste` object\"]\n```\n\n## Macros\u00a7\u27e815\u27e9\n\npaste\u27e816\u27e9\n\n",
              "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/paste/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/paste/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/paste/latest/src/paste/lib.rs.html#1-454: Source\n\u27e84\u27e9 https://img.shields.io/badge/github-8da0cb?style=for-the-badge&labelColor=555555&logo=github: ![github\n\u27e85\u27e9 https://img.shields.io/badge/crates.io-fc8d62?style=for-the-badge&labelColor=555555&logo=rust: ![crates-io\n\u27e86\u27e9 https://img.shields.io/badge/docs.rs-66c2a5?style=for-the-badge&labelColor=555555&logo=docs.rs: ![docs-rs\n\u27e87\u27e9 https://doc.rust-lang.org/std/macro.concat_idents.html: `concat_idents!`\n\u27e88\u27e9 https://docs.rs/paste/latest/paste/#pasting-identifiers: \u00a7\n\u27e89\u27e9 https://docs.rs/paste/latest/paste/#more-elaborate-example: \u00a7\n\u27e810\u27e9 https://docs.rs/paste/latest/paste/&self: <get_ $field>\n\u27e811\u27e9 https://docs.rs/paste/latest/paste/#case-conversion: \u00a7\n\u27e812\u27e9 https://doc.rust-lang.org/std/primitive.str.html#method.to_lowercase: `str::to_lowercase`\n\u27e813\u27e9 https://doc.rust-lang.org/std/primitive.str.html#method.to_uppercase: `str::to_uppercase`\n\u27e814\u27e9 https://docs.rs/paste/latest/paste/#pasting-documentation-strings: \u00a7\n\u27e815\u27e9 https://docs.rs/paste/latest/paste/#macros: \u00a7\n\u27e816\u27e9 https://docs.rs/paste/latest/paste/macro.paste.html: macro paste::paste - paste\n",
              "fit_markdown": "",
              "fit_html": ""
            },
            "structured_data": {},
            "quality_score": 4.0,
            "extraction_method": "crawl4ai",
            "error": null,
            "metadata": {
              "doc_type": "docs",
              "content_length": 4082,
              "has_structured_data": false,
              "crawl_success": true
            },
            "timestamp": "117897.7916147"
          },
          "lib_rs": {
            "url": "https://lib.rs/crates/paste",
            "title": "Untitled",
            "content": {
              "raw_markdown": "###  [35 releases](https://lib.rs/crates/paste/versions) (16 stable)\n1.0.15 |  May 7, 2024   \n---|---  \n1.0.14 |  Jul 15, 2023   \n1.0.12 |  Mar 5, 2023   \n1.0.11 |  Dec 17, 2022   \n0.1.3 |  Nov 3, 2018   \n#**2848** in [Procedural macros](https://lib.rs/development-tools/procedural-macro-helpers \"Crates to help you write procedural macros in Rust.\n\")\nDownload history 1921563/week @ 2025-01-21 2037583/week @ 2025-01-28 2272504/week @ 2025-02-04 2240666/week @ 2025-02-11 2499195/week @ 2025-02-18 2430062/week @ 2025-02-25 2808238/week @ 2025-03-04 2694219/week @ 2025-03-11 3131894/week @ 2025-03-18 2784407/week @ 2025-03-25 2568372/week @ 2025-04-01 2696663/week @ 2025-04-08 2278189/week @ 2025-04-15 2350941/week @ 2025-04-22 2198916/week @ 2025-04-29 1945274/week @ 2025-05-06\n**9,223,254** downloads per month Used in [**19,274** crates (2,341 directly)](https://lib.rs/crates/paste/rev)\n**MIT/Apache**\n40KB  734 lines\n# Macros for all your token pasting needs\n[![github](https://img.shields.io/badge/github-dtolnay/paste-8da0cb?style=for-the-badge&labelColor=555555&logo=github)](https://github.com/dtolnay/paste) [![crates.io](https://img.shields.io/crates/v/paste.svg?style=for-the-badge&color=fc8d62&logo=rust)](https://crates.io/crates/paste) [![docs.rs](https://img.shields.io/badge/docs.rs-paste-66c2a5?style=for-the-badge&labelColor=555555&logo=docs.rs)](https://docs.rs/paste) [![build status](https://img.shields.io/github/actions/workflow/status/dtolnay/paste/ci.yml?branch=master&style=for-the-badge)](https://github.com/dtolnay/paste/actions?query=branch%3Amaster)\nThe nightly-only [``concat_idents!``](https://doc.rust-lang.org/std/macro.concat_idents.html) macro in the Rust standard library is notoriously underpowered in that its concatenated identifiers can only refer to existing items, they can never be used to define something new.\nThis crate provides a flexible way to paste together identifiers in a macro, including using pasted identifiers to define new items.\n```\n```[``dependencies``]`\n`paste ``=` ``\"`1.0`\"``\n``\n```\n\nThis approach works with any Rust compiler 1.31+.\n## Pasting identifiers\nWithin the ``paste!`` macro, identifiers inside ```[``<```...```>`]`` are pasted together to form a single identifier.\n```\n``use` `paste`::``paste`;`\n`paste!` ``{`\n  ``//` Defines a const called `QRST`.`\n  `const` `[``<`Q R S T`>``]``:` `&``str` `=` ``\"`success!`\"```;`\n```}``\n``fn` `main`````(````)``````{`\n  `assert_eq!``(`\n    `paste!` `{` `[``<`Q R S T`>``]``.``len``(``)` `}``,`\n    `8``,`\n  `)``;`\n```}```\n`\n```\n\n## More elaborate example\nThe next example shows a macro that generates accessor methods for some struct fields. It demonstrates how you might find it useful to bundle a paste invocation inside of a macro_rules macro.\n```\n``use` `paste`::``paste`;`\n``macro_rules!` `make_a_struct_and_getters` ``{`````\n  `(``$name``:``ident` { ``$`(``$field``:``ident``)`,`*` }`)` `=>` ``{`\n    ``//` Define a struct. This expands to:`\n    ``//``\n    ``//`   pub struct S {`\n    ``//`     a: String,`\n    ``//`     b: String,`\n    ``//`     c: String,`\n    ``//`   }`\n    ``pub` `struct` ``$name` {\n      $(\n        `$field`: ``String`,\n      )*\n    }\n    ``//` Build an impl block with getters. This expands to:`\n    ``//``\n    ``//`   impl S {`\n    ``//`     pub fn get_a(&self) -> &str { &self.a }`\n    ``//`     pub fn get_b(&self) -> &str { &self.b }`\n    ``//`     pub fn get_c(&self) -> &str { &self.c }`\n    ``//`   }`\n    paste! ```{`\n      impl `$name` {\n        $(\n          `pub` fn [<get_ `$field`>](&self) -> &str {\n            &self.`$field`\n          `}``\n        )`*`\n      `}``\n`````}```\n  }\n}\n`make_a_struct_and_getters!``(`S ``{` a`,` b`,` c ```}```)``;`\n``fn` `call_some_getters`````(``s``:` `&`S```)```` ``->` `bool`` ````{`\n  s`.``get_a``(``)` `==` s`.``get_b``(``)` `&&` s`.``get_c``(``)``.``is_empty``(``)`\n```}```\n`\n```\n\n## Case conversion\nUse ```$var``:`lower`` or ```$var``:`upper`` in the segment list to convert an interpolated segment to lower- or uppercase as part of the paste. For example, ```[``<`ld_ `$reg``:`lower _expr`>``]``` would paste to ``ld_bc_expr`` if invoked with $reg=``Bc``.\nUse ```$var``:`snake`` to convert CamelCase input to snake_case. Use ```$var``:`camel`` to convert snake_case to CamelCase. These compose, so for example ```$var``:`snake`:`upper`` would give you SCREAMING_CASE.\nThe precise Unicode conversions are as defined by [```str```::``to_lowercase``](https://doc.rust-lang.org/std/primitive.str.html#method.to_lowercase) and [```str```::``to_uppercase``](https://doc.rust-lang.org/std/primitive.str.html#method.to_uppercase).\n## Pasting documentation strings\nWithin the ``paste!`` macro, arguments to a #[doc ...] attribute are implicitly concatenated together to form a coherent documentation string.\n```\n``use` `paste`::``paste`;`\n``macro_rules!` `method_new` ``{`````\n  `(``$ret``:``ident``)` `=>` ``{`\n    `paste!` `{`\n      ``#``[``doc` `=` ``\"`Create a new ``\"`` `$ret` ``\"`` object.`\"```]``\n      ``pub` `fn` `new`````(````)```` ``->` `$ret`` ```{` `todo!``(``)` `}``\n    `}`\n  `}```;`\n`````}```\n``pub` `struct` ```Paste` ````{````}```\n`method_new!``(`Paste`)``;` ``//` expands to #[doc = \"Create a new `Paste` object\"]`\n`\n```\n\n#### License\nLicensed under either of [Apache License, Version 2.0](https://github.com/dtolnay/paste/blob/a2c7e27875277450ed28147623ba5218dd23e732/LICENSE-APACHE) or [MIT license](https://github.com/dtolnay/paste/blob/a2c7e27875277450ed28147623ba5218dd23e732/LICENSE-MIT) at your option.  Unless you explicitly state otherwise, any contribution intentionally submitted for inclusion in this crate by you, as defined in the Apache-2.0 license, shall be dual licensed as above, without any additional terms or conditions. \n#### No runtime deps\n  * build `build.rs`\n  * dev  [paste-test-suite](https://lib.rs/crates/paste-test-suite \"0\")\n  * dev  [rustversion](https://lib.rs/crates/rustversion \"1.0\")\n  * dev  [trybuild](https://lib.rs/crates/trybuild \"1.0.49\")[+diff](https://lib.rs/crates/trybuild/features#feature-diff)\n\n\n",
              "markdown_with_citations": "###  35 releases\u27e81\u27e9 (16 stable)\n1.0.15 |  May 7, 2024   \n---|---  \n1.0.14 |  Jul 15, 2023   \n1.0.12 |  Mar 5, 2023   \n1.0.11 |  Dec 17, 2022   \n0.1.3 |  Nov 3, 2018   \n#**2848** in Procedural macros\u27e82\u27e9\nDownload history 1921563/week @ 2025-01-21 2037583/week @ 2025-01-28 2272504/week @ 2025-02-04 2240666/week @ 2025-02-11 2499195/week @ 2025-02-18 2430062/week @ 2025-02-25 2808238/week @ 2025-03-04 2694219/week @ 2025-03-11 3131894/week @ 2025-03-18 2784407/week @ 2025-03-25 2568372/week @ 2025-04-01 2696663/week @ 2025-04-08 2278189/week @ 2025-04-15 2350941/week @ 2025-04-22 2198916/week @ 2025-04-29 1945274/week @ 2025-05-06\n**9,223,254** downloads per month Used in **19,274** crates (2,341 directly)\u27e83\u27e9\n**MIT/Apache**\n40KB  734 lines\n# Macros for all your token pasting needs\n![github\u27e84\u27e9](https://github.com/dtolnay/paste) ![crates.io\u27e85\u27e9](https://crates.io/crates/paste) ![docs.rs\u27e86\u27e9](https://docs.rs/paste) ![build status\u27e87\u27e9](https://github.com/dtolnay/paste/actions?query=branch%3Amaster)\nThe nightly-only ``concat_idents!``\u27e88\u27e9 macro in the Rust standard library is notoriously underpowered in that its concatenated identifiers can only refer to existing items, they can never be used to define something new.\nThis crate provides a flexible way to paste together identifiers in a macro, including using pasted identifiers to define new items.\n```\n```[``dependencies``]`\n`paste ``=` ``\"`1.0`\"``\n``\n```\n\nThis approach works with any Rust compiler 1.31+.\n## Pasting identifiers\nWithin the ``paste!`` macro, identifiers inside ```[``<```...```>`]`` are pasted together to form a single identifier.\n```\n``use` `paste`::``paste`;`\n`paste!` ``{`\n  ``//` Defines a const called `QRST`.`\n  `const` `[``<`Q R S T`>``]``:` `&``str` `=` ``\"`success!`\"```;`\n```}``\n``fn` `main`````(````)``````{`\n  `assert_eq!``(`\n    `paste!` `{` `[``<`Q R S T`>``]``.``len``(``)` `}``,`\n    `8``,`\n  `)``;`\n```}```\n`\n```\n\n## More elaborate example\nThe next example shows a macro that generates accessor methods for some struct fields. It demonstrates how you might find it useful to bundle a paste invocation inside of a macro_rules macro.\n```\n``use` `paste`::``paste`;`\n``macro_rules!` `make_a_struct_and_getters` ``{`````\n  `(``$name``:``ident` { ``$`(``$field``:``ident``)`,`*` }`)` `=>` ``{`\n    ``//` Define a struct. This expands to:`\n    ``//``\n    ``//`   pub struct S {`\n    ``//`     a: String,`\n    ``//`     b: String,`\n    ``//`     c: String,`\n    ``//`   }`\n    ``pub` `struct` ``$name` {\n      $(\n        `$field`: ``String`,\n      )*\n    }\n    ``//` Build an impl block with getters. This expands to:`\n    ``//``\n    ``//`   impl S {`\n    ``//`     pub fn get_a(&self) -> &str { &self.a }`\n    ``//`     pub fn get_b(&self) -> &str { &self.b }`\n    ``//`     pub fn get_c(&self) -> &str { &self.c }`\n    ``//`   }`\n    paste! ```{`\n      impl `$name` {\n        $(\n          `pub` fn <get_ `$field`>\u27e89\u27e9 -> &str {\n            &self.`$field`\n          `}``\n        )`*`\n      `}``\n`````}```\n  }\n}\n`make_a_struct_and_getters!``(`S ``{` a`,` b`,` c ```}```)``;`\n``fn` `call_some_getters`````(``s``:` `&`S```)```` ``->` `bool`` ````{`\n  s`.``get_a``(``)` `==` s`.``get_b``(``)` `&&` s`.``get_c``(``)``.``is_empty``(``)`\n```}```\n`\n```\n\n## Case conversion\nUse ```$var``:`lower`` or ```$var``:`upper`` in the segment list to convert an interpolated segment to lower- or uppercase as part of the paste. For example, ```[``<`ld_ `$reg``:`lower _expr`>``]``` would paste to ``ld_bc_expr`` if invoked with $reg=``Bc``.\nUse ```$var``:`snake`` to convert CamelCase input to snake_case. Use ```$var``:`camel`` to convert snake_case to CamelCase. These compose, so for example ```$var``:`snake`:`upper`` would give you SCREAMING_CASE.\nThe precise Unicode conversions are as defined by ```str```::``to_lowercase``\u27e810\u27e9 and ```str```::``to_uppercase``\u27e811\u27e9.\n## Pasting documentation strings\nWithin the ``paste!`` macro, arguments to a #[doc ...] attribute are implicitly concatenated together to form a coherent documentation string.\n```\n``use` `paste`::``paste`;`\n``macro_rules!` `method_new` ``{`````\n  `(``$ret``:``ident``)` `=>` ``{`\n    `paste!` `{`\n      ``#``[``doc` `=` ``\"`Create a new ``\"`` `$ret` ``\"`` object.`\"```]``\n      ``pub` `fn` `new`````(````)```` ``->` `$ret`` ```{` `todo!``(``)` `}``\n    `}`\n  `}```;`\n`````}```\n``pub` `struct` ```Paste` ````{````}```\n`method_new!``(`Paste`)``;` ``//` expands to #[doc = \"Create a new `Paste` object\"]`\n`\n```\n\n#### License\nLicensed under either of Apache License, Version 2.0\u27e812\u27e9 or MIT license\u27e813\u27e9 at your option.  Unless you explicitly state otherwise, any contribution intentionally submitted for inclusion in this crate by you, as defined in the Apache-2.0 license, shall be dual licensed as above, without any additional terms or conditions. \n#### No runtime deps\n  * build `build.rs`\n  * dev  paste-test-suite\u27e814\u27e9\n  * dev  rustversion\u27e815\u27e9\n  * dev  trybuild\u27e816\u27e9+diff\u27e817\u27e9\n\n\n",
              "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://lib.rs/crates/paste/versions: 35 releases\n\u27e82\u27e9 https://lib.rs/development-tools/procedural-macro-helpers: Crates to help you write procedural macros in Rust.\n - Procedural macros\n\u27e83\u27e9 https://lib.rs/crates/paste/rev: **19,274** crates (2,341 directly)\n\u27e84\u27e9 https://img.shields.io/badge/github-dtolnay/paste-8da0cb?style=for-the-badge&labelColor=555555&logo=github: ![github\n\u27e85\u27e9 https://img.shields.io/crates/v/paste.svg?style=for-the-badge&color=fc8d62&logo=rust: ![crates.io\n\u27e86\u27e9 https://img.shields.io/badge/docs.rs-paste-66c2a5?style=for-the-badge&labelColor=555555&logo=docs.rs: ![docs.rs\n\u27e87\u27e9 https://img.shields.io/github/actions/workflow/status/dtolnay/paste/ci.yml?branch=master&style=for-the-badge: ![build status\n\u27e88\u27e9 https://doc.rust-lang.org/std/macro.concat_idents.html: ``concat_idents!``\n\u27e89\u27e9 https://lib.rs/crates/&self: <get_ `$field`>\n\u27e810\u27e9 https://doc.rust-lang.org/std/primitive.str.html#method.to_lowercase: ```str```::``to_lowercase``\n\u27e811\u27e9 https://doc.rust-lang.org/std/primitive.str.html#method.to_uppercase: ```str```::``to_uppercase``\n\u27e812\u27e9 https://github.com/dtolnay/paste/blob/a2c7e27875277450ed28147623ba5218dd23e732/LICENSE-APACHE: Apache License, Version 2.0\n\u27e813\u27e9 https://github.com/dtolnay/paste/blob/a2c7e27875277450ed28147623ba5218dd23e732/LICENSE-MIT: MIT license\n\u27e814\u27e9 https://lib.rs/crates/paste-test-suite: 0 - paste-test-suite\n\u27e815\u27e9 https://lib.rs/crates/rustversion: 1.0 - rustversion\n\u27e816\u27e9 https://lib.rs/crates/trybuild: 1.0.49 - trybuild\n\u27e817\u27e9 https://lib.rs/crates/trybuild/features#feature-diff: +diff\n",
              "fit_markdown": "",
              "fit_html": ""
            },
            "structured_data": {},
            "quality_score": 3.0,
            "extraction_method": "crawl4ai",
            "error": null,
            "metadata": {
              "doc_type": "docs",
              "content_length": 6053,
              "has_structured_data": false,
              "crawl_success": true
            },
            "timestamp": "117898.2194405"
          }
        },
        "crate_analysis": {
          "status": "completed",
          "check": [
            {
              "reason": "compiler-artifact",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmp_0lpn5v8/paste-1.0.15#paste@1.0.15",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp_0lpn5v8\\paste-1.0.15\\Cargo.toml",
              "target": {
                "kind": [
                  "custom-build"
                ],
                "crate_types": [
                  "bin"
                ],
                "name": "build-script-build",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp_0lpn5v8\\paste-1.0.15\\build.rs",
                "edition": "2018",
                "doc": false,
                "doctest": false,
                "test": false
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp_0lpn5v8\\paste-1.0.15\\target\\debug\\build\\paste-3af272caae9a89eb\\build-script-build.exe",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp_0lpn5v8\\paste-1.0.15\\target\\debug\\build\\paste-3af272caae9a89eb\\build_script_build.pdb"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "build-script-executed",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmp_0lpn5v8/paste-1.0.15#paste@1.0.15",
              "linked_libs": [],
              "linked_paths": [],
              "cfgs": [],
              "env": [],
              "out_dir": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp_0lpn5v8\\paste-1.0.15\\target\\debug\\build\\paste-25d275ec855688ce\\out"
            },
            {
              "reason": "compiler-artifact",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmp_0lpn5v8/paste-1.0.15#paste@1.0.15",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp_0lpn5v8\\paste-1.0.15\\Cargo.toml",
              "target": {
                "kind": [
                  "proc-macro"
                ],
                "crate_types": [
                  "proc-macro"
                ],
                "name": "paste",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp_0lpn5v8\\paste-1.0.15\\src\\lib.rs",
                "edition": "2018",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp_0lpn5v8\\paste-1.0.15\\target\\debug\\deps\\libpaste-3df811939e1a1f95.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "build-finished",
              "success": true
            }
          ],
          "clippy": [
            {
              "reason": "compiler-artifact",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmp_0lpn5v8/paste-1.0.15#paste@1.0.15",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp_0lpn5v8\\paste-1.0.15\\Cargo.toml",
              "target": {
                "kind": [
                  "custom-build"
                ],
                "crate_types": [
                  "bin"
                ],
                "name": "build-script-build",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp_0lpn5v8\\paste-1.0.15\\build.rs",
                "edition": "2018",
                "doc": false,
                "doctest": false,
                "test": false
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp_0lpn5v8\\paste-1.0.15\\target\\debug\\build\\paste-6230c9f12142fbae\\build-script-build.exe",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp_0lpn5v8\\paste-1.0.15\\target\\debug\\build\\paste-6230c9f12142fbae\\build_script_build.pdb"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "build-script-executed",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmp_0lpn5v8/paste-1.0.15#paste@1.0.15",
              "linked_libs": [],
              "linked_paths": [],
              "cfgs": [],
              "env": [],
              "out_dir": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp_0lpn5v8\\paste-1.0.15\\target\\debug\\build\\paste-66c7a73231faa687\\out"
            },
            {
              "reason": "compiler-artifact",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmp_0lpn5v8/paste-1.0.15#paste@1.0.15",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp_0lpn5v8\\paste-1.0.15\\Cargo.toml",
              "target": {
                "kind": [
                  "proc-macro"
                ],
                "crate_types": [
                  "proc-macro"
                ],
                "name": "paste",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp_0lpn5v8\\paste-1.0.15\\src\\lib.rs",
                "edition": "2018",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp_0lpn5v8\\paste-1.0.15\\target\\debug\\deps\\libpaste-6218dec8db385348.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "build-finished",
              "success": true
            }
          ],
          "audit": {
            "database": {
              "advisory-count": 787,
              "last-commit": "7573f55ba337263f61167dbb0ea926cdc7c8eb5d",
              "last-updated": "2025-06-17T11:04:25+02:00"
            },
            "lockfile": {
              "dependency-count": 38
            },
            "settings": {
              "target_arch": [],
              "target_os": [],
              "severity": null,
              "ignore": [],
              "informational_warnings": [
                "unmaintained",
                "unsound",
                "notice"
              ]
            },
            "vulnerabilities": {
              "found": false,
              "count": 0,
              "list": []
            },
            "warnings": {
              "unmaintained": [
                {
                  "kind": "unmaintained",
                  "package": {
                    "name": "paste",
                    "version": "1.0.15",
                    "source": null,
                    "checksum": null,
                    "dependencies": [
                      {
                        "name": "paste-test-suite",
                        "version": "0.0.0",
                        "source": "registry+https://github.com/rust-lang/crates.io-index"
                      },
                      {
                        "name": "rustversion",
                        "version": "1.0.21",
                        "source": "registry+https://github.com/rust-lang/crates.io-index"
                      },
                      {
                        "name": "trybuild",
                        "version": "1.0.105",
                        "source": "registry+https://github.com/rust-lang/crates.io-index"
                      }
                    ],
                    "replace": null
                  },
                  "advisory": {
                    "id": "RUSTSEC-2024-0436",
                    "package": "paste",
                    "title": "paste - no longer maintained",
                    "description": "The creator of the crate `paste` has stated in the [`README.md`](https://github.com/dtolnay/paste/blob/master/README.md) \nthat this project is not longer maintained as well as archived the repository",
                    "date": "2024-10-07",
                    "aliases": [],
                    "related": [],
                    "collection": "crates",
                    "categories": [],
                    "keywords": [],
                    "cvss": null,
                    "informational": "unmaintained",
                    "references": [],
                    "source": null,
                    "url": "https://github.com/dtolnay/paste",
                    "withdrawn": null,
                    "license": "CC0-1.0"
                  },
                  "affected": null,
                  "versions": {
                    "patched": [],
                    "unaffected": []
                  }
                }
              ]
            }
          },
          "note": "Crate analysis performed with stable toolchain."
        },
        "crate_metadata": {
          "name": "paste",
          "version": "1.0.15",
          "description": "ALLOW: Positive community sentiment",
          "repository": "",
          "keywords": [],
          "categories": [],
          "readme": {
            "raw_markdown": "[](https://docs.rs/paste/latest/paste/all.html \"show sidebar\")\n# Crate pasteCopy item path\n[Settings](https://docs.rs/paste/latest/settings.html)\n[Help](https://docs.rs/paste/latest/help.html)\nSummary[Source](https://docs.rs/paste/latest/src/paste/lib.rs.html#1-454)\nExpand description\n[![github](https://img.shields.io/badge/github-8da0cb?style=for-the-badge&labelColor=555555&logo=github)](https://github.com/dtolnay/paste) [![crates-io](https://img.shields.io/badge/crates.io-fc8d62?style=for-the-badge&labelColor=555555&logo=rust)](https://crates.io/crates/paste) [![docs-rs](https://img.shields.io/badge/docs.rs-66c2a5?style=for-the-badge&labelColor=555555&logo=docs.rs)](https://docs.rs/paste)\nThe nightly-only [`concat_idents!`](https://doc.rust-lang.org/std/macro.concat_idents.html) macro in the Rust standard library is notoriously underpowered in that its concatenated identifiers can only refer to existing items, they can never be used to define something new.\nThis crate provides a flexible way to paste together identifiers in a macro, including using pasted identifiers to define new items.\nThis approach works with any Rust compiler 1.31+.\n## [\u00a7](https://docs.rs/paste/latest/paste/#pasting-identifiers)Pasting identifiers\nWithin the `paste!` macro, identifiers inside `[<`\u2026`>]` are pasted together to form a single identifier.\n```\nuse paste::paste;\npaste! {\n  // Defines a const called `QRST`.\n  const [<Q R S T>]: &str = \"success!\";\n}\nfn main() {\n  assert_eq!(\n    paste! { [<Q R S T>].len() },\n    8,\n  );\n}\n```\n\n## [\u00a7](https://docs.rs/paste/latest/paste/#more-elaborate-example)More elaborate example\nThe next example shows a macro that generates accessor methods for some struct fields. It demonstrates how you might find it useful to bundle a paste invocation inside of a macro_rules macro.\n```\nuse paste::paste;\nmacro_rules! make_a_struct_and_getters {\n  ($name:ident { $($field:ident),* }) => {\n    // Define a struct. This expands to:\n    //\n    //   pub struct S {\n    //     a: String,\n    //     b: String,\n    //     c: String,\n    //   }\n    pub struct $name {\n      $(\n        $field: String,\n      )*\n    }\n    // Build an impl block with getters. This expands to:\n    //\n    //   impl S {\n    //     pub fn get_a(&self) -> &str { &self.a }\n    //     pub fn get_b(&self) -> &str { &self.b }\n    //     pub fn get_c(&self) -> &str { &self.c }\n    //   }\n    paste! {\n      impl $name {\n        $(\n          pub fn [<get_ $field>](&self) -> &str {\n            &self.$field\n          }\n        )*\n      }\n    }\n  }\n}\nmake_a_struct_and_getters!(S { a, b, c });\nfn call_some_getters(s: &S) -> bool {\n  s.get_a() == s.get_b() && s.get_c().is_empty()\n}\n```\n\n## [\u00a7](https://docs.rs/paste/latest/paste/#case-conversion)Case conversion\nUse `$var:lower` or `$var:upper` in the segment list to convert an interpolated segment to lower- or uppercase as part of the paste. For example, `[<ld_ $reg:lower _expr>]` would paste to `ld_bc_expr` if invoked with $reg=`Bc`.\nUse `$var:snake` to convert CamelCase input to snake_case. Use `$var:camel` to convert snake_case to CamelCase. These compose, so for example `$var:snake:upper` would give you SCREAMING_CASE.\nThe precise Unicode conversions are as defined by [`str::to_lowercase`](https://doc.rust-lang.org/std/primitive.str.html#method.to_lowercase) and [`str::to_uppercase`](https://doc.rust-lang.org/std/primitive.str.html#method.to_uppercase).\n## [\u00a7](https://docs.rs/paste/latest/paste/#pasting-documentation-strings)Pasting documentation strings\nWithin the `paste!` macro, arguments to a #[doc \u2026] attribute are implicitly concatenated together to form a coherent documentation string.\n```\nuse paste::paste;\nmacro_rules! method_new {\n  ($ret:ident) => {\n    paste! {\n      #[doc = \"Create a new `\" $ret \"` object.\"]\n      pub fn new() -> $ret { todo!() }\n    }\n  };\n}\npub struct Paste {}\nmethod_new!(Paste); // expands to #[doc = \"Create a new `Paste` object\"]\n```\n\n## Macros[\u00a7](https://docs.rs/paste/latest/paste/#macros)\n\n[paste](https://docs.rs/paste/latest/paste/macro.paste.html \"macro paste::paste\")\n\n",
            "markdown_with_citations": "[](https://docs.rs/paste/latest/paste/all.html \"show sidebar\")\n# Crate pasteCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\n![github\u27e84\u27e9](https://github.com/dtolnay/paste) ![crates-io\u27e85\u27e9](https://crates.io/crates/paste) ![docs-rs\u27e86\u27e9](https://docs.rs/paste)\nThe nightly-only `concat_idents!`\u27e87\u27e9 macro in the Rust standard library is notoriously underpowered in that its concatenated identifiers can only refer to existing items, they can never be used to define something new.\nThis crate provides a flexible way to paste together identifiers in a macro, including using pasted identifiers to define new items.\nThis approach works with any Rust compiler 1.31+.\n## \u00a7\u27e88\u27e9Pasting identifiers\nWithin the `paste!` macro, identifiers inside `[<`\u2026`>]` are pasted together to form a single identifier.\n```\nuse paste::paste;\npaste! {\n  // Defines a const called `QRST`.\n  const [<Q R S T>]: &str = \"success!\";\n}\nfn main() {\n  assert_eq!(\n    paste! { [<Q R S T>].len() },\n    8,\n  );\n}\n```\n\n## \u00a7\u27e89\u27e9More elaborate example\nThe next example shows a macro that generates accessor methods for some struct fields. It demonstrates how you might find it useful to bundle a paste invocation inside of a macro_rules macro.\n```\nuse paste::paste;\nmacro_rules! make_a_struct_and_getters {\n  ($name:ident { $($field:ident),* }) => {\n    // Define a struct. This expands to:\n    //\n    //   pub struct S {\n    //     a: String,\n    //     b: String,\n    //     c: String,\n    //   }\n    pub struct $name {\n      $(\n        $field: String,\n      )*\n    }\n    // Build an impl block with getters. This expands to:\n    //\n    //   impl S {\n    //     pub fn get_a(&self) -> &str { &self.a }\n    //     pub fn get_b(&self) -> &str { &self.b }\n    //     pub fn get_c(&self) -> &str { &self.c }\n    //   }\n    paste! {\n      impl $name {\n        $(\n          pub fn <get_ $field>\u27e810\u27e9 -> &str {\n            &self.$field\n          }\n        )*\n      }\n    }\n  }\n}\nmake_a_struct_and_getters!(S { a, b, c });\nfn call_some_getters(s: &S) -> bool {\n  s.get_a() == s.get_b() && s.get_c().is_empty()\n}\n```\n\n## \u00a7\u27e811\u27e9Case conversion\nUse `$var:lower` or `$var:upper` in the segment list to convert an interpolated segment to lower- or uppercase as part of the paste. For example, `[<ld_ $reg:lower _expr>]` would paste to `ld_bc_expr` if invoked with $reg=`Bc`.\nUse `$var:snake` to convert CamelCase input to snake_case. Use `$var:camel` to convert snake_case to CamelCase. These compose, so for example `$var:snake:upper` would give you SCREAMING_CASE.\nThe precise Unicode conversions are as defined by `str::to_lowercase`\u27e812\u27e9 and `str::to_uppercase`\u27e813\u27e9.\n## \u00a7\u27e814\u27e9Pasting documentation strings\nWithin the `paste!` macro, arguments to a #[doc \u2026] attribute are implicitly concatenated together to form a coherent documentation string.\n```\nuse paste::paste;\nmacro_rules! method_new {\n  ($ret:ident) => {\n    paste! {\n      #[doc = \"Create a new `\" $ret \"` object.\"]\n      pub fn new() -> $ret { todo!() }\n    }\n  };\n}\npub struct Paste {}\nmethod_new!(Paste); // expands to #[doc = \"Create a new `Paste` object\"]\n```\n\n## Macros\u00a7\u27e815\u27e9\n\npaste\u27e816\u27e9\n\n",
            "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/paste/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/paste/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/paste/latest/src/paste/lib.rs.html#1-454: Source\n\u27e84\u27e9 https://img.shields.io/badge/github-8da0cb?style=for-the-badge&labelColor=555555&logo=github: ![github\n\u27e85\u27e9 https://img.shields.io/badge/crates.io-fc8d62?style=for-the-badge&labelColor=555555&logo=rust: ![crates-io\n\u27e86\u27e9 https://img.shields.io/badge/docs.rs-66c2a5?style=for-the-badge&labelColor=555555&logo=docs.rs: ![docs-rs\n\u27e87\u27e9 https://doc.rust-lang.org/std/macro.concat_idents.html: `concat_idents!`\n\u27e88\u27e9 https://docs.rs/paste/latest/paste/#pasting-identifiers: \u00a7\n\u27e89\u27e9 https://docs.rs/paste/latest/paste/#more-elaborate-example: \u00a7\n\u27e810\u27e9 https://docs.rs/paste/latest/paste/&self: <get_ $field>\n\u27e811\u27e9 https://docs.rs/paste/latest/paste/#case-conversion: \u00a7\n\u27e812\u27e9 https://doc.rust-lang.org/std/primitive.str.html#method.to_lowercase: `str::to_lowercase`\n\u27e813\u27e9 https://doc.rust-lang.org/std/primitive.str.html#method.to_uppercase: `str::to_uppercase`\n\u27e814\u27e9 https://docs.rs/paste/latest/paste/#pasting-documentation-strings: \u00a7\n\u27e815\u27e9 https://docs.rs/paste/latest/paste/#macros: \u00a7\n\u27e816\u27e9 https://docs.rs/paste/latest/paste/macro.paste.html: macro paste::paste - paste\n",
            "fit_markdown": "",
            "fit_html": ""
          },
          "downloads": 0,
          "github_stars": 0,
          "dependencies": [],
          "features": {},
          "code_snippets": [],
          "readme_sections": {},
          "librs_downloads": null,
          "source": "crates.io",
          "enhanced_scraping": {},
          "enhanced_features": [],
          "enhanced_dependencies": []
        },
        "enriched_crate": {
          "name": "paste",
          "version": "1.0.15",
          "description": "ALLOW: Positive community sentiment",
          "repository": "",
          "keywords": [],
          "categories": [],
          "readme": {
            "raw_markdown": "[](https://docs.rs/paste/latest/paste/all.html \"show sidebar\")\n# Crate pasteCopy item path\n[Settings](https://docs.rs/paste/latest/settings.html)\n[Help](https://docs.rs/paste/latest/help.html)\nSummary[Source](https://docs.rs/paste/latest/src/paste/lib.rs.html#1-454)\nExpand description\n[![github](https://img.shields.io/badge/github-8da0cb?style=for-the-badge&labelColor=555555&logo=github)](https://github.com/dtolnay/paste) [![crates-io](https://img.shields.io/badge/crates.io-fc8d62?style=for-the-badge&labelColor=555555&logo=rust)](https://crates.io/crates/paste) [![docs-rs](https://img.shields.io/badge/docs.rs-66c2a5?style=for-the-badge&labelColor=555555&logo=docs.rs)](https://docs.rs/paste)\nThe nightly-only [`concat_idents!`](https://doc.rust-lang.org/std/macro.concat_idents.html) macro in the Rust standard library is notoriously underpowered in that its concatenated identifiers can only refer to existing items, they can never be used to define something new.\nThis crate provides a flexible way to paste together identifiers in a macro, including using pasted identifiers to define new items.\nThis approach works with any Rust compiler 1.31+.\n## [\u00a7](https://docs.rs/paste/latest/paste/#pasting-identifiers)Pasting identifiers\nWithin the `paste!` macro, identifiers inside `[<`\u2026`>]` are pasted together to form a single identifier.\n```\nuse paste::paste;\npaste! {\n  // Defines a const called `QRST`.\n  const [<Q R S T>]: &str = \"success!\";\n}\nfn main() {\n  assert_eq!(\n    paste! { [<Q R S T>].len() },\n    8,\n  );\n}\n```\n\n## [\u00a7](https://docs.rs/paste/latest/paste/#more-elaborate-example)More elaborate example\nThe next example shows a macro that generates accessor methods for some struct fields. It demonstrates how you might find it useful to bundle a paste invocation inside of a macro_rules macro.\n```\nuse paste::paste;\nmacro_rules! make_a_struct_and_getters {\n  ($name:ident { $($field:ident),* }) => {\n    // Define a struct. This expands to:\n    //\n    //   pub struct S {\n    //     a: String,\n    //     b: String,\n    //     c: String,\n    //   }\n    pub struct $name {\n      $(\n        $field: String,\n      )*\n    }\n    // Build an impl block with getters. This expands to:\n    //\n    //   impl S {\n    //     pub fn get_a(&self) -> &str { &self.a }\n    //     pub fn get_b(&self) -> &str { &self.b }\n    //     pub fn get_c(&self) -> &str { &self.c }\n    //   }\n    paste! {\n      impl $name {\n        $(\n          pub fn [<get_ $field>](&self) -> &str {\n            &self.$field\n          }\n        )*\n      }\n    }\n  }\n}\nmake_a_struct_and_getters!(S { a, b, c });\nfn call_some_getters(s: &S) -> bool {\n  s.get_a() == s.get_b() && s.get_c().is_empty()\n}\n```\n\n## [\u00a7](https://docs.rs/paste/latest/paste/#case-conversion)Case conversion\nUse `$var:lower` or `$var:upper` in the segment list to convert an interpolated segment to lower- or uppercase as part of the paste. For example, `[<ld_ $reg:lower _expr>]` would paste to `ld_bc_expr` if invoked with $reg=`Bc`.\nUse `$var:snake` to convert CamelCase input to snake_case. Use `$var:camel` to convert snake_case to CamelCase. These compose, so for example `$var:snake:upper` would give you SCREAMING_CASE.\nThe precise Unicode conversions are as defined by [`str::to_lowercase`](https://doc.rust-lang.org/std/primitive.str.html#method.to_lowercase) and [`str::to_uppercase`](https://doc.rust-lang.org/std/primitive.str.html#method.to_uppercase).\n## [\u00a7](https://docs.rs/paste/latest/paste/#pasting-documentation-strings)Pasting documentation strings\nWithin the `paste!` macro, arguments to a #[doc \u2026] attribute are implicitly concatenated together to form a coherent documentation string.\n```\nuse paste::paste;\nmacro_rules! method_new {\n  ($ret:ident) => {\n    paste! {\n      #[doc = \"Create a new `\" $ret \"` object.\"]\n      pub fn new() -> $ret { todo!() }\n    }\n  };\n}\npub struct Paste {}\nmethod_new!(Paste); // expands to #[doc = \"Create a new `Paste` object\"]\n```\n\n## Macros[\u00a7](https://docs.rs/paste/latest/paste/#macros)\n\n[paste](https://docs.rs/paste/latest/paste/macro.paste.html \"macro paste::paste\")\n\n",
            "markdown_with_citations": "[](https://docs.rs/paste/latest/paste/all.html \"show sidebar\")\n# Crate pasteCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\n![github\u27e84\u27e9](https://github.com/dtolnay/paste) ![crates-io\u27e85\u27e9](https://crates.io/crates/paste) ![docs-rs\u27e86\u27e9](https://docs.rs/paste)\nThe nightly-only `concat_idents!`\u27e87\u27e9 macro in the Rust standard library is notoriously underpowered in that its concatenated identifiers can only refer to existing items, they can never be used to define something new.\nThis crate provides a flexible way to paste together identifiers in a macro, including using pasted identifiers to define new items.\nThis approach works with any Rust compiler 1.31+.\n## \u00a7\u27e88\u27e9Pasting identifiers\nWithin the `paste!` macro, identifiers inside `[<`\u2026`>]` are pasted together to form a single identifier.\n```\nuse paste::paste;\npaste! {\n  // Defines a const called `QRST`.\n  const [<Q R S T>]: &str = \"success!\";\n}\nfn main() {\n  assert_eq!(\n    paste! { [<Q R S T>].len() },\n    8,\n  );\n}\n```\n\n## \u00a7\u27e89\u27e9More elaborate example\nThe next example shows a macro that generates accessor methods for some struct fields. It demonstrates how you might find it useful to bundle a paste invocation inside of a macro_rules macro.\n```\nuse paste::paste;\nmacro_rules! make_a_struct_and_getters {\n  ($name:ident { $($field:ident),* }) => {\n    // Define a struct. This expands to:\n    //\n    //   pub struct S {\n    //     a: String,\n    //     b: String,\n    //     c: String,\n    //   }\n    pub struct $name {\n      $(\n        $field: String,\n      )*\n    }\n    // Build an impl block with getters. This expands to:\n    //\n    //   impl S {\n    //     pub fn get_a(&self) -> &str { &self.a }\n    //     pub fn get_b(&self) -> &str { &self.b }\n    //     pub fn get_c(&self) -> &str { &self.c }\n    //   }\n    paste! {\n      impl $name {\n        $(\n          pub fn <get_ $field>\u27e810\u27e9 -> &str {\n            &self.$field\n          }\n        )*\n      }\n    }\n  }\n}\nmake_a_struct_and_getters!(S { a, b, c });\nfn call_some_getters(s: &S) -> bool {\n  s.get_a() == s.get_b() && s.get_c().is_empty()\n}\n```\n\n## \u00a7\u27e811\u27e9Case conversion\nUse `$var:lower` or `$var:upper` in the segment list to convert an interpolated segment to lower- or uppercase as part of the paste. For example, `[<ld_ $reg:lower _expr>]` would paste to `ld_bc_expr` if invoked with $reg=`Bc`.\nUse `$var:snake` to convert CamelCase input to snake_case. Use `$var:camel` to convert snake_case to CamelCase. These compose, so for example `$var:snake:upper` would give you SCREAMING_CASE.\nThe precise Unicode conversions are as defined by `str::to_lowercase`\u27e812\u27e9 and `str::to_uppercase`\u27e813\u27e9.\n## \u00a7\u27e814\u27e9Pasting documentation strings\nWithin the `paste!` macro, arguments to a #[doc \u2026] attribute are implicitly concatenated together to form a coherent documentation string.\n```\nuse paste::paste;\nmacro_rules! method_new {\n  ($ret:ident) => {\n    paste! {\n      #[doc = \"Create a new `\" $ret \"` object.\"]\n      pub fn new() -> $ret { todo!() }\n    }\n  };\n}\npub struct Paste {}\nmethod_new!(Paste); // expands to #[doc = \"Create a new `Paste` object\"]\n```\n\n## Macros\u00a7\u27e815\u27e9\n\npaste\u27e816\u27e9\n\n",
            "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/paste/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/paste/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/paste/latest/src/paste/lib.rs.html#1-454: Source\n\u27e84\u27e9 https://img.shields.io/badge/github-8da0cb?style=for-the-badge&labelColor=555555&logo=github: ![github\n\u27e85\u27e9 https://img.shields.io/badge/crates.io-fc8d62?style=for-the-badge&labelColor=555555&logo=rust: ![crates-io\n\u27e86\u27e9 https://img.shields.io/badge/docs.rs-66c2a5?style=for-the-badge&labelColor=555555&logo=docs.rs: ![docs-rs\n\u27e87\u27e9 https://doc.rust-lang.org/std/macro.concat_idents.html: `concat_idents!`\n\u27e88\u27e9 https://docs.rs/paste/latest/paste/#pasting-identifiers: \u00a7\n\u27e89\u27e9 https://docs.rs/paste/latest/paste/#more-elaborate-example: \u00a7\n\u27e810\u27e9 https://docs.rs/paste/latest/paste/&self: <get_ $field>\n\u27e811\u27e9 https://docs.rs/paste/latest/paste/#case-conversion: \u00a7\n\u27e812\u27e9 https://doc.rust-lang.org/std/primitive.str.html#method.to_lowercase: `str::to_lowercase`\n\u27e813\u27e9 https://doc.rust-lang.org/std/primitive.str.html#method.to_uppercase: `str::to_uppercase`\n\u27e814\u27e9 https://docs.rs/paste/latest/paste/#pasting-documentation-strings: \u00a7\n\u27e815\u27e9 https://docs.rs/paste/latest/paste/#macros: \u00a7\n\u27e816\u27e9 https://docs.rs/paste/latest/paste/macro.paste.html: macro paste::paste - paste\n",
            "fit_markdown": "",
            "fit_html": ""
          },
          "downloads": 0,
          "github_stars": 0,
          "dependencies": [],
          "features": {},
          "code_snippets": [],
          "readme_sections": {},
          "librs_downloads": null,
          "source": "crates.io",
          "enhanced_scraping": {},
          "enhanced_features": [],
          "enhanced_dependencies": [],
          "readme_summary": "The `paste` crate enables flexible identifier concatenation within macros, allowing developers to dynamically generate new items, such as constants, methods, or structs, using pasted identifiers. It supports case conversions (e.g., snake_case, CamelCase) and documentation string concatenation, making it ideal for creating clean, reusable macro-based code. Compatible with Rust 1.31+, it provides functionality beyond the limited nightly-only `concat_idents!` macro.",
          "feature_summary": null,
          "use_case": "Utilities",
          "score": 8.0,
          "factual_counterfactual": "### Pair 1: Identifier Pasting  \n\u2705 **Factual**: The `paste!` macro allows combining identifiers using the syntax `[<...>]` to create new identifiers, which can then be used to define items, such as constants or functions.  \n\u274c **Counterfactual**: The `paste!` macro only supports concatenating identifiers to reference existing items and cannot be used to define new ones.  \n\n---\n\n### Pair 2: Compatibility  \n\u2705 **Factual**: The `paste` crate is compatible with Rust versions 1.31 and later, making it accessible to stable Rust users without requiring nightly features.  \n\u274c **Counterfactual**: The `paste` crate requires nightly Rust due to its reliance on unstable features like `concat_idents!`.  \n\n---\n\n### Pair 3: Case Conversion  \n\u2705 **Factual**: The `paste!` macro supports case conversion of interpolated segments, such as `$var:lower` for lowercase, `$var:upper` for uppercase, and `$var:snake` for snake_case.  \n\u274c **Counterfactual**: The `paste!` macro does not support case conversion, requiring users to manually format identifiers before pasting them.",
          "source_analysis": null,
          "user_behavior": null,
          "security": null
        }
      },
      "irl_score": 8.6,
      "execution_id": "exec-a2c183d5-7cd7101f-1751264107",
      "timestamp": "2025-06-30T06:15:07.107059+00:00",
      "canon_version": "1.3.0"
    },
    "rule_zero_compliant": true
  }
]