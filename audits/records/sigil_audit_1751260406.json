[
  {
    "execution_id": "exec-a83919e8-75e3b952-1751260398",
    "timestamp": "2025-06-30T05:13:18.162906+00:00",
    "sacred_chain": {
      "input_data": "nu-ansi-term",
      "context_sources": [
        "crates.io",
        "github.com",
        "lib.rs",
        "docs.rs"
      ],
      "reasoning_steps": [
        "Input canonicalized: 'nu-ansi-term' -> 'nu-ansi-term'",
        "Context gathered from 4 validated sources",
        "Metadata extracted: 4 fields",
        "Documentation analyzed: quality 7.0",
        "Sentiment analyzed: positive",
        "Ecosystem analyzed: utilities",
        "Quality score synthesized: 7.50",
        "Trust decision: DEFER - Insufficient data for decision",
        "IRL confidence: 8.600"
      ],
      "suggestion": "ALLOW: Positive community sentiment",
      "verdict": "DEFER",
      "audit_info": {
        "metadata": {
          "name": "nu-ansi-term",
          "type": "rust_crate",
          "source": "manual_input",
          "extraction_method": "irl_engine"
        },
        "sentiment": {
          "quality_score": 7.0,
          "completeness": 0.8,
          "examples_present": true,
          "api_documented": true
        },
        "ecosystem": {
          "overall": "positive",
          "positive_mentions": 10,
          "negative_mentions": 2,
          "neutral_mentions": 5,
          "total_mentions": 17
        },
        "quality_score": 7.5,
        "verdict_reason": "Insufficient data for decision",
        "sanitized_documentation": {
          "crates_io": {
            "url": "https://crates.io/crates/nu-ansi-term",
            "title": "nu-ansi-term v0.50.1",
            "content": {
              "raw_markdown": "#  nu-ansi-term v0.50.1\nLibrary for ANSI terminal colors and styles (bold, underline) \n  * [ Readme ](https://crates.io/crates/nu-ansi-term)\n  * [ 25 Versions ](https://crates.io/crates/nu-ansi-term/versions)\n  * [ Dependencies ](https://crates.io/crates/nu-ansi-term/dependencies)\n  * [ Dependents ](https://crates.io/crates/nu-ansi-term/reverse_dependencies)\n\n\n## Metadata\n11 months ago \nv1.62.1 \n[ MIT ](https://choosealicense.com/licenses/mit)\n27.9 KiB \n## Install\nRun the following Cargo command in your project directory:\ncargo add nu-ansi-term\nOr add the following line to your Cargo.toml:\nnu-ansi-term = \"0.50.1\"\n## Repository\n[ github.com/nushell/nu-ansi-term ](https://github.com/nushell/nu-ansi-term)\n## Owners\n[ Report crate ](https://crates.io/support?crate=nu-ansi-term&inquire=crate-violation)\n### Stats Overview\n155,816,118 Downloads all time\n25 Versions published\n#### Downloads over the last 90 days\nDisplay as \nStacked \n  * Stacked \n  * Unstacked \n\n\nLoading\u2026\n",
              "markdown_with_citations": "#  nu-ansi-term v0.50.1\nLibrary for ANSI terminal colors and styles (bold, underline) \n  *  Readme \u27e81\u27e9\n  *  25 Versions \u27e82\u27e9\n  *  Dependencies \u27e83\u27e9\n  *  Dependents \u27e84\u27e9\n\n\n## Metadata\n11 months ago \nv1.62.1 \n MIT \u27e85\u27e9\n27.9 KiB \n## Install\nRun the following Cargo command in your project directory:\ncargo add nu-ansi-term\nOr add the following line to your Cargo.toml:\nnu-ansi-term = \"0.50.1\"\n## Repository\n github.com/nushell/nu-ansi-term \u27e86\u27e9\n## Owners\n Report crate \u27e87\u27e9\n### Stats Overview\n155,816,118 Downloads all time\n25 Versions published\n#### Downloads over the last 90 days\nDisplay as \nStacked \n  * Stacked \n  * Unstacked \n\n\nLoading\u2026\n",
              "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://crates.io/crates/nu-ansi-term:  Readme \n\u27e82\u27e9 https://crates.io/crates/nu-ansi-term/versions:  25 Versions \n\u27e83\u27e9 https://crates.io/crates/nu-ansi-term/dependencies:  Dependencies \n\u27e84\u27e9 https://crates.io/crates/nu-ansi-term/reverse_dependencies:  Dependents \n\u27e85\u27e9 https://choosealicense.com/licenses/mit:  MIT \n\u27e86\u27e9 https://github.com/nushell/nu-ansi-term:  github.com/nushell/nu-ansi-term \n\u27e87\u27e9 https://crates.io/support?crate=nu-ansi-term&inquire=crate-violation:  Report crate \n",
              "fit_markdown": "",
              "fit_html": ""
            },
            "structured_data": {},
            "quality_score": 2.0,
            "extraction_method": "crawl4ai",
            "error": null,
            "metadata": {
              "doc_type": "docs",
              "content_length": 978,
              "has_structured_data": false,
              "crawl_success": true
            },
            "timestamp": "114187.530693"
          },
          "docs_rs": {
            "url": "https://docs.rs/nu-ansi-term",
            "title": "Crate nu_ansi_termCopy item path",
            "content": {
              "raw_markdown": "[](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/all.html \"show sidebar\")\n# Crate nu_ansi_termCopy item path\n[Settings](https://docs.rs/nu-ansi-term/latest/settings.html)\n[Help](https://docs.rs/nu-ansi-term/latest/help.html)\nSummary[Source](https://docs.rs/nu-ansi-term/latest/src/nu_ansi_term/lib.rs.html#1-267)\nExpand description\nThis is a library for controlling colors and formatting, such as red bold text or blue underlined text, on ANSI terminals.\n### [\u00a7](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/#basic-usage)Basic usage\nThere are three main types in this crate that you need to be concerned with: [`AnsiString`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/type.AnsiString.html), [`Style`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html), and [`Color`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/enum.Color.html).\nA `Style` holds stylistic information: foreground and background colors, whether the text should be bold, or blinking, or other properties. The [`Color`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/enum.Color.html) enum represents the available colors. And an [`AnsiString`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/type.AnsiString.html) is a string paired with a [`Style`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html).\n[`Color`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/enum.Color.html) is also available as an alias to `Color`.\nTo format a string, call the `paint` method on a `Style` or a `Color`, passing in the string you want to format as the argument. For example, here\u2019s how to get some red text:\n```\nuse nu_ansi_term::Color::Red;\nprintln!(\"This is in red: {}\", Red.paint(\"a red string\"));\n```\n\nIt\u2019s important to note that the `paint` method does _not_ actually return a string with the ANSI control characters surrounding it. Instead, it returns an [`AnsiString`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/type.AnsiString.html) value that has a [`Display`](https://doc.rust-lang.org/std/fmt/trait.Display.html) implementation that, when formatted, returns the characters. This allows strings to be printed with a minimum of [`String`](https://doc.rust-lang.org/std/string/struct.String.html) allocations being performed behind the scenes.\nIf you _do_ want to get at the escape codes, then you can convert the [`AnsiString`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/type.AnsiString.html) to a string as you would any other `Display` value:\n```\nuse nu_ansi_term::Color::Red;\nlet red_string = Red.paint(\"a red string\").to_string();\n```\n\n### [\u00a7](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/#bold-underline-background-and-other-styles)Bold, underline, background, and other styles\nFor anything more complex than plain foreground color changes, you need to construct `Style` values themselves, rather than beginning with a `Color`. You can do this by chaining methods based on a new `Style`, created with [`Style::new()`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html#method.new). Each method creates a new style that has that specific property set. For example:\n```\nuse nu_ansi_term::Style;\nprintln!(\"How about some {} and {}?\",\n     Style::new().bold().paint(\"bold\"),\n     Style::new().underline().paint(\"underline\"));\n```\n\nFor brevity, these methods have also been implemented for `Color` values, so you can give your styles a foreground color without having to begin with an empty `Style` value:\n```\nuse nu_ansi_term::Color::{Blue, Yellow};\nprintln!(\"Demonstrating {} and {}!\",\n     Blue.bold().paint(\"blue bold\"),\n     Yellow.underline().paint(\"yellow underline\"));\nprintln!(\"Yellow on blue: {}\", Yellow.on(Blue).paint(\"wow!\"));\n```\n\nThe complete list of styles you can use are: [`bold`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html#method.bold), [`dimmed`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html#method.dimmed), [`italic`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html#method.italic), [`underline`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html#method.underline), [`blink`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html#method.blink), [`reverse`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html#method.reverse), [`hidden`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html#method.hidden), [`strikethrough`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html#method.strikethrough), and [`on`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html#method.on) for background colors.\nIn some cases, you may find it easier to change the foreground on an existing `Style` rather than starting from the appropriate `Color`. You can do this using the [`fg`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html#method.fg) method:\n```\nuse nu_ansi_term::Style;\nuse nu_ansi_term::Color::{Blue, Cyan, Yellow};\nprintln!(\"Yellow on blue: {}\", Style::new().on(Blue).fg(Yellow).paint(\"yow!\"));\nprintln!(\"Also yellow on blue: {}\", Cyan.on(Blue).fg(Yellow).paint(\"zow!\"));\n```\n\nYou can turn a `Color` into a `Style` with the [`normal`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/enum.Color.html#method.normal) method. This will produce the exact same `AnsiString` as if you just used the `paint` method on the `Color` directly, but it\u2019s useful in certain cases: for example, you may have a method that returns `Styles`, and need to represent both the \u201cred bold\u201d and \u201cred, but not bold\u201d styles with values of the same type. The `Style` struct also has a [`Default`](https://doc.rust-lang.org/std/default/trait.Default.html) implementation if you want to have a style with _nothing_ set.\n```\nuse nu_ansi_term::Style;\nuse nu_ansi_term::Color::Red;\nRed.normal().paint(\"yet another red string\");\nStyle::default().paint(\"a completely regular string\");\n```\n\n### [\u00a7](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/#extended-colors)Extended colors\nYou can access the extended range of 256 colors by using the `Color::Fixed` variant, which takes an argument of the color number to use. This can be included wherever you would use a `Color`:\n```\nuse nu_ansi_term::Color::Fixed;\nFixed(134).paint(\"A sort of light purple\");\nFixed(221).on(Fixed(124)).paint(\"Mustard in the ketchup\");\n```\n\nThe first sixteen of these values are the same as the normal and bold standard color variants. There\u2019s nothing stopping you from using these as `Fixed` colors instead, but there\u2019s nothing to be gained by doing so either.\nYou can also access full 24-bit color by using the `Color::Rgb` variant, which takes separate `u8` arguments for red, green, and blue:\n```\nuse nu_ansi_term::Color::Rgb;\nRgb(70, 130, 180).paint(\"Steel blue\");\n```\n\n### [\u00a7](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/#combining-successive-colored-strings)Combining successive colored strings\nThe benefit of writing ANSI escape codes to the terminal is that they _stack_ : you do not need to end every colored string with a reset code if the text that follows it is of a similar style. For example, if you want to have some blue text followed by some blue bold text, it\u2019s possible to send the ANSI code for blue, followed by the ANSI code for bold, and finishing with a reset code without having to have an extra one between the two strings.\nThis crate can optimise the ANSI codes that get printed in situations like this, making life easier for your terminal renderer. The [`AnsiStrings`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/type.AnsiStrings.html) type takes a slice of several [`AnsiString`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/type.AnsiString.html) values, and will iterate over each of them, printing only the codes for the styles that need to be updated as part of its formatting routine.\nThe following code snippet uses this to enclose a binary number displayed in red bold text inside some red, but not bold, brackets:\n```\nuse nu_ansi_term::Color::Red;\nuse nu_ansi_term::{AnsiString, AnsiStrings};\nlet some_value = format!(\"{:b}\", 42);\nlet strings: &[AnsiString<'static>] = &[\n  Red.paint(\"[\"),\n  Red.bold().paint(some_value),\n  Red.paint(\"]\"),\n];\nprintln!(\"Value: {}\", AnsiStrings(strings));\n```\n\nThere are several things to note here. Firstly, the [`paint`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/type.AnsiByteString.html#method.write_to) method can take _either_ an owned [`String`](https://doc.rust-lang.org/std/string/struct.String.html) or a borrowed [`&str`](https://doc.rust-lang.org/std/primitive.str.html). Internally, an [`AnsiString`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/type.AnsiString.html) holds a copy-on-write ([`Cow`](https://doc.rust-lang.org/std/borrow/enum.Cow.html)) string value to deal with both owned and borrowed strings at the same time. This is used here to display a `String`, the result of the `format!` call, using the same mechanism as some statically-available `&str` slices. Secondly, that the [`AnsiStrings`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/type.AnsiStrings.html) value works in the same way as its singular counterpart, with a [`Display`](https://doc.rust-lang.org/std/fmt/trait.Display.html) implementation that only performs the formatting when required.\n### [\u00a7](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/#byte-strings)Byte strings\nThis library also supports formatting `\\[u8]` byte strings; this supports applications working with text in an unknown encoding. [`Style`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html) and [`Color`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/enum.Color.html) support painting `\\[u8]` values, resulting in an [`AnsiByteString`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/type.AnsiByteString.html). This type does not implement [`Display`](https://doc.rust-lang.org/std/fmt/trait.Display.html), as it may not contain UTF-8, but it does provide a method [`write_to`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/type.AnsiByteString.html#method.write_to) to write the result to any value that implements [`Write`](https://doc.rust-lang.org/std/io/trait.Write.html):\n```\nuse nu_ansi_term::Color::Green;\nGreen.paint(\"user data\".as_bytes()).write_to(&mut std::io::stdout()).unwrap();\n```\n\nSimilarly, the type [`AnsiByteStrings`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/type.AnsiByteStrings.html) supports writing a list of [`AnsiByteString`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/type.AnsiByteString.html) values with minimal escape sequences:\n```\nuse nu_ansi_term::Color::Green;\nuse nu_ansi_term::AnsiByteStrings;\nAnsiByteStrings(&[\n  Green.paint(\"user data 1\\n\".as_bytes()),\n  Green.bold().paint(\"user data 2\\n\".as_bytes()),\n]).write_to(&mut std::io::stdout()).unwrap();\n```\n\n## Re-exports[\u00a7](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/#reexports)\n\n`pub use ansi::Infix[](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/ansi/struct.Infix.html \"struct nu_ansi_term::ansi::Infix\");`\n\n\n`pub use ansi::Prefix[](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/ansi/struct.Prefix.html \"struct nu_ansi_term::ansi::Prefix\");`\n\n\n`pub use ansi::Suffix[](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/ansi/struct.Suffix.html \"struct nu_ansi_term::ansi::Suffix\");`\n\n\n`pub use gradient[](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/gradient/index.html \"mod nu_ansi_term::gradient\")::*;`\n\n## Modules[\u00a7](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/#modules)\n\n[ansi](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/ansi/index.html \"mod nu_ansi_term::ansi\")\n\n\n[gradient](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/gradient/index.html \"mod nu_ansi_term::gradient\")\n\n## Structs[\u00a7](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/#structs)\n\n[AnsiGenericString](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.AnsiGenericString.html \"struct nu_ansi_term::AnsiGenericString\")\n    An `AnsiGenericString` includes a generic string type and a `Style` to display that string. `AnsiString` and `AnsiByteString` are aliases for this type on `str` and `\\[u8]`, respectively.\n\n[AnsiGenericStrings](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.AnsiGenericStrings.html \"struct nu_ansi_term::AnsiGenericStrings\")\n    A set of `AnsiGenericStrings`s collected together, in order to be written with a minimum of control characters.\n\n[Rgb](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Rgb.html \"struct nu_ansi_term::Rgb\")\n\n\n[Style](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html \"struct nu_ansi_term::Style\")\n    A style is a collection of properties that can format a string using ANSI escape codes.\n## Enums[\u00a7](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/#enums)\n\n[Color](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/enum.Color.html \"enum nu_ansi_term::Color\")\n    A color is one specific type of ANSI escape code, and can refer to either the foreground or background color.\n## Functions[\u00a7](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/#functions)\n\n[AnsiByteStrings](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/fn.AnsiByteStrings.html \"fn nu_ansi_term::AnsiByteStrings\")\n    A function to construct an `AnsiByteStrings` instance.\n\n[AnsiStrings](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/fn.AnsiStrings.html \"fn nu_ansi_term::AnsiStrings\")\n    A function to construct an `AnsiStrings` instance.\n\n[sub_string](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/fn.sub_string.html \"fn nu_ansi_term::sub_string\")\n    Return a substring of the given AnsiStrings sequence, while keeping the formatting.\n\n[unstyle](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/fn.unstyle.html \"fn nu_ansi_term::unstyle\")\n    Return a concatenated copy of `strs` without the formatting, as an allocated `String`.\n\n[unstyled_len](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/fn.unstyled_len.html \"fn nu_ansi_term::unstyled_len\")\n    Return the unstyled length of AnsiStrings. This is equaivalent to `unstyle(strs).len()`.\n## Type Aliases[\u00a7](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/#types)\n\n[AnsiByteString](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/type.AnsiByteString.html \"type nu_ansi_term::AnsiByteString\")\n    An `AnsiByteString` represents a formatted series of bytes. Use `AnsiByteString` when styling text with an unknown encoding.\n\n[AnsiByteStrings](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/type.AnsiByteStrings.html \"type nu_ansi_term::AnsiByteStrings\")\n    A set of `AnsiByteString`s collected together, in order to be written with a minimum of control characters.\n\n[AnsiString](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/type.AnsiString.html \"type nu_ansi_term::AnsiString\")\n    An ANSI String is a string coupled with the `Style` to display it in a terminal.\n\n[AnsiStrings](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/type.AnsiStrings.html \"type nu_ansi_term::AnsiStrings\")\n    A set of `AnsiString`s collected together, in order to be written with a minimum of control characters.\n",
              "markdown_with_citations": "[](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/all.html \"show sidebar\")\n# Crate nu_ansi_termCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nThis is a library for controlling colors and formatting, such as red bold text or blue underlined text, on ANSI terminals.\n### \u00a7\u27e84\u27e9Basic usage\nThere are three main types in this crate that you need to be concerned with: `AnsiString`\u27e85\u27e9, `Style`\u27e86\u27e9, and `Color`\u27e87\u27e9.\nA `Style` holds stylistic information: foreground and background colors, whether the text should be bold, or blinking, or other properties. The `Color`\u27e87\u27e9 enum represents the available colors. And an `AnsiString`\u27e85\u27e9 is a string paired with a `Style`\u27e86\u27e9.\n`Color`\u27e87\u27e9 is also available as an alias to `Color`.\nTo format a string, call the `paint` method on a `Style` or a `Color`, passing in the string you want to format as the argument. For example, here\u2019s how to get some red text:\n```\nuse nu_ansi_term::Color::Red;\nprintln!(\"This is in red: {}\", Red.paint(\"a red string\"));\n```\n\nIt\u2019s important to note that the `paint` method does _not_ actually return a string with the ANSI control characters surrounding it. Instead, it returns an `AnsiString`\u27e85\u27e9 value that has a `Display`\u27e88\u27e9 implementation that, when formatted, returns the characters. This allows strings to be printed with a minimum of `String`\u27e89\u27e9 allocations being performed behind the scenes.\nIf you _do_ want to get at the escape codes, then you can convert the `AnsiString`\u27e85\u27e9 to a string as you would any other `Display` value:\n```\nuse nu_ansi_term::Color::Red;\nlet red_string = Red.paint(\"a red string\").to_string();\n```\n\n### \u00a7\u27e810\u27e9Bold, underline, background, and other styles\nFor anything more complex than plain foreground color changes, you need to construct `Style` values themselves, rather than beginning with a `Color`. You can do this by chaining methods based on a new `Style`, created with `Style::new()`\u27e811\u27e9. Each method creates a new style that has that specific property set. For example:\n```\nuse nu_ansi_term::Style;\nprintln!(\"How about some {} and {}?\",\n     Style::new().bold().paint(\"bold\"),\n     Style::new().underline().paint(\"underline\"));\n```\n\nFor brevity, these methods have also been implemented for `Color` values, so you can give your styles a foreground color without having to begin with an empty `Style` value:\n```\nuse nu_ansi_term::Color::{Blue, Yellow};\nprintln!(\"Demonstrating {} and {}!\",\n     Blue.bold().paint(\"blue bold\"),\n     Yellow.underline().paint(\"yellow underline\"));\nprintln!(\"Yellow on blue: {}\", Yellow.on(Blue).paint(\"wow!\"));\n```\n\nThe complete list of styles you can use are: `bold`\u27e812\u27e9, `dimmed`\u27e813\u27e9, `italic`\u27e814\u27e9, `underline`\u27e815\u27e9, `blink`\u27e816\u27e9, `reverse`\u27e817\u27e9, `hidden`\u27e818\u27e9, `strikethrough`\u27e819\u27e9, and `on`\u27e820\u27e9 for background colors.\nIn some cases, you may find it easier to change the foreground on an existing `Style` rather than starting from the appropriate `Color`. You can do this using the `fg`\u27e821\u27e9 method:\n```\nuse nu_ansi_term::Style;\nuse nu_ansi_term::Color::{Blue, Cyan, Yellow};\nprintln!(\"Yellow on blue: {}\", Style::new().on(Blue).fg(Yellow).paint(\"yow!\"));\nprintln!(\"Also yellow on blue: {}\", Cyan.on(Blue).fg(Yellow).paint(\"zow!\"));\n```\n\nYou can turn a `Color` into a `Style` with the `normal`\u27e822\u27e9 method. This will produce the exact same `AnsiString` as if you just used the `paint` method on the `Color` directly, but it\u2019s useful in certain cases: for example, you may have a method that returns `Styles`, and need to represent both the \u201cred bold\u201d and \u201cred, but not bold\u201d styles with values of the same type. The `Style` struct also has a `Default`\u27e823\u27e9 implementation if you want to have a style with _nothing_ set.\n```\nuse nu_ansi_term::Style;\nuse nu_ansi_term::Color::Red;\nRed.normal().paint(\"yet another red string\");\nStyle::default().paint(\"a completely regular string\");\n```\n\n### \u00a7\u27e824\u27e9Extended colors\nYou can access the extended range of 256 colors by using the `Color::Fixed` variant, which takes an argument of the color number to use. This can be included wherever you would use a `Color`:\n```\nuse nu_ansi_term::Color::Fixed;\nFixed(134).paint(\"A sort of light purple\");\nFixed(221).on(Fixed(124)).paint(\"Mustard in the ketchup\");\n```\n\nThe first sixteen of these values are the same as the normal and bold standard color variants. There\u2019s nothing stopping you from using these as `Fixed` colors instead, but there\u2019s nothing to be gained by doing so either.\nYou can also access full 24-bit color by using the `Color::Rgb` variant, which takes separate `u8` arguments for red, green, and blue:\n```\nuse nu_ansi_term::Color::Rgb;\nRgb(70, 130, 180).paint(\"Steel blue\");\n```\n\n### \u00a7\u27e825\u27e9Combining successive colored strings\nThe benefit of writing ANSI escape codes to the terminal is that they _stack_ : you do not need to end every colored string with a reset code if the text that follows it is of a similar style. For example, if you want to have some blue text followed by some blue bold text, it\u2019s possible to send the ANSI code for blue, followed by the ANSI code for bold, and finishing with a reset code without having to have an extra one between the two strings.\nThis crate can optimise the ANSI codes that get printed in situations like this, making life easier for your terminal renderer. The `AnsiStrings`\u27e826\u27e9 type takes a slice of several `AnsiString`\u27e85\u27e9 values, and will iterate over each of them, printing only the codes for the styles that need to be updated as part of its formatting routine.\nThe following code snippet uses this to enclose a binary number displayed in red bold text inside some red, but not bold, brackets:\n```\nuse nu_ansi_term::Color::Red;\nuse nu_ansi_term::{AnsiString, AnsiStrings};\nlet some_value = format!(\"{:b}\", 42);\nlet strings: &[AnsiString<'static>] = &[\n  Red.paint(\"[\"),\n  Red.bold().paint(some_value),\n  Red.paint(\"]\"),\n];\nprintln!(\"Value: {}\", AnsiStrings(strings));\n```\n\nThere are several things to note here. Firstly, the `paint`\u27e827\u27e9 method can take _either_ an owned `String`\u27e89\u27e9 or a borrowed `&str`\u27e828\u27e9. Internally, an `AnsiString`\u27e85\u27e9 holds a copy-on-write (`Cow`\u27e829\u27e9) string value to deal with both owned and borrowed strings at the same time. This is used here to display a `String`, the result of the `format!` call, using the same mechanism as some statically-available `&str` slices. Secondly, that the `AnsiStrings`\u27e826\u27e9 value works in the same way as its singular counterpart, with a `Display`\u27e88\u27e9 implementation that only performs the formatting when required.\n### \u00a7\u27e830\u27e9Byte strings\nThis library also supports formatting `\\[u8]` byte strings; this supports applications working with text in an unknown encoding. `Style`\u27e86\u27e9 and `Color`\u27e87\u27e9 support painting `\\[u8]` values, resulting in an `AnsiByteString`\u27e831\u27e9. This type does not implement `Display`\u27e88\u27e9, as it may not contain UTF-8, but it does provide a method `write_to`\u27e827\u27e9 to write the result to any value that implements `Write`\u27e832\u27e9:\n```\nuse nu_ansi_term::Color::Green;\nGreen.paint(\"user data\".as_bytes()).write_to(&mut std::io::stdout()).unwrap();\n```\n\nSimilarly, the type `AnsiByteStrings`\u27e833\u27e9 supports writing a list of `AnsiByteString`\u27e831\u27e9 values with minimal escape sequences:\n```\nuse nu_ansi_term::Color::Green;\nuse nu_ansi_term::AnsiByteStrings;\nAnsiByteStrings(&[\n  Green.paint(\"user data 1\\n\".as_bytes()),\n  Green.bold().paint(\"user data 2\\n\".as_bytes()),\n]).write_to(&mut std::io::stdout()).unwrap();\n```\n\n## Re-exports\u00a7\u27e834\u27e9\n\n`pub use ansi::Infix[](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/ansi/struct.Infix.html \"struct nu_ansi_term::ansi::Infix\");`\n\n\n`pub use ansi::Prefix[](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/ansi/struct.Prefix.html \"struct nu_ansi_term::ansi::Prefix\");`\n\n\n`pub use ansi::Suffix[](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/ansi/struct.Suffix.html \"struct nu_ansi_term::ansi::Suffix\");`\n\n\n`pub use gradient[](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/gradient/index.html \"mod nu_ansi_term::gradient\")::*;`\n\n## Modules\u00a7\u27e835\u27e9\n\nansi\u27e836\u27e9\n\n\ngradient\u27e837\u27e9\n\n## Structs\u00a7\u27e838\u27e9\n\nAnsiGenericString\u27e839\u27e9\n    An `AnsiGenericString` includes a generic string type and a `Style` to display that string. `AnsiString` and `AnsiByteString` are aliases for this type on `str` and `\\[u8]`, respectively.\n\nAnsiGenericStrings\u27e840\u27e9\n    A set of `AnsiGenericStrings`s collected together, in order to be written with a minimum of control characters.\n\nRgb\u27e841\u27e9\n\n\nStyle\u27e86\u27e9\n    A style is a collection of properties that can format a string using ANSI escape codes.\n## Enums\u00a7\u27e842\u27e9\n\nColor\u27e87\u27e9\n    A color is one specific type of ANSI escape code, and can refer to either the foreground or background color.\n## Functions\u00a7\u27e843\u27e9\n\nAnsiByteStrings\u27e844\u27e9\n    A function to construct an `AnsiByteStrings` instance.\n\nAnsiStrings\u27e845\u27e9\n    A function to construct an `AnsiStrings` instance.\n\nsub_string\u27e846\u27e9\n    Return a substring of the given AnsiStrings sequence, while keeping the formatting.\n\nunstyle\u27e847\u27e9\n    Return a concatenated copy of `strs` without the formatting, as an allocated `String`.\n\nunstyled_len\u27e848\u27e9\n    Return the unstyled length of AnsiStrings. This is equaivalent to `unstyle(strs).len()`.\n## Type Aliases\u00a7\u27e849\u27e9\n\nAnsiByteString\u27e831\u27e9\n    An `AnsiByteString` represents a formatted series of bytes. Use `AnsiByteString` when styling text with an unknown encoding.\n\nAnsiByteStrings\u27e833\u27e9\n    A set of `AnsiByteString`s collected together, in order to be written with a minimum of control characters.\n\nAnsiString\u27e85\u27e9\n    An ANSI String is a string coupled with the `Style` to display it in a terminal.\n\nAnsiStrings\u27e826\u27e9\n    A set of `AnsiString`s collected together, in order to be written with a minimum of control characters.\n",
              "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/nu-ansi-term/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/nu-ansi-term/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/nu-ansi-term/latest/src/nu_ansi_term/lib.rs.html#1-267: Source\n\u27e84\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/#basic-usage: \u00a7\n\u27e85\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/type.AnsiString.html: `AnsiString`\n\u27e86\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html: `Style`\n\u27e87\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/enum.Color.html: `Color`\n\u27e88\u27e9 https://doc.rust-lang.org/std/fmt/trait.Display.html: `Display`\n\u27e89\u27e9 https://doc.rust-lang.org/std/string/struct.String.html: `String`\n\u27e810\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/#bold-underline-background-and-other-styles: \u00a7\n\u27e811\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html#method.new: `Style::new()`\n\u27e812\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html#method.bold: `bold`\n\u27e813\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html#method.dimmed: `dimmed`\n\u27e814\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html#method.italic: `italic`\n\u27e815\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html#method.underline: `underline`\n\u27e816\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html#method.blink: `blink`\n\u27e817\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html#method.reverse: `reverse`\n\u27e818\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html#method.hidden: `hidden`\n\u27e819\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html#method.strikethrough: `strikethrough`\n\u27e820\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html#method.on: `on`\n\u27e821\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html#method.fg: `fg`\n\u27e822\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/enum.Color.html#method.normal: `normal`\n\u27e823\u27e9 https://doc.rust-lang.org/std/default/trait.Default.html: `Default`\n\u27e824\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/#extended-colors: \u00a7\n\u27e825\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/#combining-successive-colored-strings: \u00a7\n\u27e826\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/type.AnsiStrings.html: `AnsiStrings`\n\u27e827\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/type.AnsiByteString.html#method.write_to: `paint`\n\u27e828\u27e9 https://doc.rust-lang.org/std/primitive.str.html: `&str`\n\u27e829\u27e9 https://doc.rust-lang.org/std/borrow/enum.Cow.html: `Cow`\n\u27e830\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/#byte-strings: \u00a7\n\u27e831\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/type.AnsiByteString.html: `AnsiByteString`\n\u27e832\u27e9 https://doc.rust-lang.org/std/io/trait.Write.html: `Write`\n\u27e833\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/type.AnsiByteStrings.html: `AnsiByteStrings`\n\u27e834\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/#reexports: \u00a7\n\u27e835\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/#modules: \u00a7\n\u27e836\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/ansi/index.html: mod nu_ansi_term::ansi - ansi\n\u27e837\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/gradient/index.html: mod nu_ansi_term::gradient - gradient\n\u27e838\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/#structs: \u00a7\n\u27e839\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.AnsiGenericString.html: struct nu_ansi_term::AnsiGenericString - AnsiGenericString\n\u27e840\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.AnsiGenericStrings.html: struct nu_ansi_term::AnsiGenericStrings - AnsiGenericStrings\n\u27e841\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Rgb.html: struct nu_ansi_term::Rgb - Rgb\n\u27e842\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/#enums: \u00a7\n\u27e843\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/#functions: \u00a7\n\u27e844\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/fn.AnsiByteStrings.html: fn nu_ansi_term::AnsiByteStrings - AnsiByteStrings\n\u27e845\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/fn.AnsiStrings.html: fn nu_ansi_term::AnsiStrings - AnsiStrings\n\u27e846\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/fn.sub_string.html: fn nu_ansi_term::sub_string - sub_string\n\u27e847\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/fn.unstyle.html: fn nu_ansi_term::unstyle - unstyle\n\u27e848\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/fn.unstyled_len.html: fn nu_ansi_term::unstyled_len - unstyled_len\n\u27e849\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/#types: \u00a7\n",
              "fit_markdown": "",
              "fit_html": ""
            },
            "structured_data": {},
            "quality_score": 4.0,
            "extraction_method": "crawl4ai",
            "error": null,
            "metadata": {
              "doc_type": "docs",
              "content_length": 14970,
              "has_structured_data": false,
              "crawl_success": true
            },
            "timestamp": "114188.4106647"
          },
          "lib_rs": {
            "url": "https://lib.rs/crates/nu-ansi-term",
            "title": "Untitled",
            "content": {
              "raw_markdown": "###  [22 breaking releases](https://lib.rs/crates/nu-ansi-term/versions)\n0.50.1 |  Jul 23, 2024   \n---|---  \n0.50.0 |  Jan 22, 2024   \n0.49.0 |  Jul 22, 2023   \n0.47.0 |  Mar 13, 2023   \n0.29.0 |  Mar 30, 2021   \n#**9** in [Command-line interface](https://lib.rs/command-line-interface \"Crates to help create command line interfaces, such as argument parsers, line-editing, or output coloring and formatting.\")\nDownload history 1846149/week @ 2025-01-28 2000988/week @ 2025-02-04 2046823/week @ 2025-02-11 2296226/week @ 2025-02-18 2175884/week @ 2025-02-25 2586179/week @ 2025-03-04 2548779/week @ 2025-03-11 2966986/week @ 2025-03-18 2666176/week @ 2025-03-25 2409685/week @ 2025-04-01 2469960/week @ 2025-04-08 2138225/week @ 2025-04-15 2290833/week @ 2025-04-22 2167294/week @ 2025-04-29 2220314/week @ 2025-05-06 1888995/week @ 2025-05-13\n**8,890,270** downloads per month Used in [**955** crates (126 directly)](https://lib.rs/crates/nu-ansi-term/rev)\n**MIT** license \n105KB  1.5K  SLoC\n# nu-ansi-term\n> This is a copy of rust-ansi-term but with Colour change to Color and light foreground colors added (90-97) as well as light background colors added (100-107).\nThis is a library for controlling colors and formatting, such as red bold text or blue underlined text, on ANSI terminals.\n## [View the Rustdoc](https://docs.rs/nu_ansi_term/)\n## Installation\nThis crate works with [Cargo](http://crates.io). Add the following to your ``Cargo.toml`` dependencies section:\n```\n```[``dependencies``]`\n`nu-ansi-term ``=` ``\"`0.49`\"``\n``# optional gnu-legacy mode to have two digit instead of one digit styles``\n`nu-ansi-term = { version=\"0.49\", features``=```[```\"`gnu_legacy`\"```]`` }\n``\n```\n\n## Basic usage\nThere are three main types in this crate that you need to be concerned with: ``AnsiString``, ``Style``, and ``Color``.\nA ``Style`` holds stylistic information: foreground and background colors, whether the text should be bold, or blinking, or other properties. The ``Color`` enum represents the available colors. And an ``AnsiString`` is a string paired with a ``Style``.\nTo format a string, call the ``paint`` method on a ``Style`` or a ``Color``, passing in the string you want to format as the argument. For example, here\u2019s how to get some red text:\n```\n``use` `nu_ansi_term`::```Color`::``Red`;`\n`println!``(```\"`This is in red: `{}``\"```,` Red`.``paint``(```\"`a red string`\"```)``)``;`\n`\n```\n\nIt\u2019s important to note that the ``paint`` method does _not_ actually return a string with the ANSI control characters surrounding it. Instead, it returns an ``AnsiString`` value that has a ``Display`` implementation that, when formatted, returns the characters. This allows strings to be printed with a minimum of ```String``` allocations being performed behind the scenes.\nIf you _do_ want to get at the escape codes, then you can convert the ``AnsiString`` to a string as you would any other ``Display`` value:\n```\n``use` `nu_ansi_term`::```Color`::``Red`;`\n`let` red_string `=` Red`.``paint``(```\"`a red string`\"```)``.``to_string``(``)``;`\n`\n```\n\n**Note for Windows 10 users:** On Windows 10, the application must enable ANSI support first:\n```\n``let` enabled `=` `nu_ansi_term`::``enable_ansi_support`(``)``;`\n`\n```\n\n## Bold, underline, background, and other styles\nFor anything more complex than plain foreground color changes, you need to construct ``Style`` values themselves, rather than beginning with a ``Color``. You can do this by chaining methods based on a new ``Style``, created with ```Style`::``new`(``)```. Each method creates a new style that has that specific property set. For example:\n```\n``use` `nu_ansi_term`::``Style`;`\n`println!``(```\"`How about some `{}` and `{}`?`\"```,`\n     `Style`::``new`(``)``.``bold``(``)``.``paint``(```\"`bold`\"```)``,`\n     `Style`::``new`(``)``.``underline``(``)``.``paint``(```\"`underline`\"```)``)``;`\n`\n```\n\nFor brevity, these methods have also been implemented for ``Color`` values, so you can give your styles a foreground color without having to begin with an empty ``Style`` value:\n```\n``use` `nu_ansi_term`::```Color`::````{`Blue`,` Yellow```}```;`\n`println!``(```\"`Demonstrating `{}` and `{}`!`\"```,`\n     Blue`.``bold``(``)``.``paint``(```\"`blue bold`\"```)``,`\n     Yellow`.``underline``(``)``.``paint``(```\"`yellow underline`\"```)``)``;`\n`println!``(```\"`Yellow on blue: `{}``\"```,` Yellow`.``on``(`Blue`)``.``paint``(```\"`wow!`\"```)``)``;`\n`\n```\n\nThe complete list of styles you can use are: ``bold``, ``dimmed``, ``italic``, ``underline``, ``blink``, ``reverse``, ``hidden``, and ``on`` for background colors.\nIn some cases, you may find it easier to change the foreground on an existing ``Style`` rather than starting from the appropriate ``Color``. You can do this using the ``fg`` method:\n```\n``use` `nu_ansi_term`::``Style`;`\n`use` `nu_ansi_term`::```Color`::````{`Blue`,` Cyan`,` Yellow```}```;`\n`println!``(```\"`Yellow on blue: `{}``\"```,` `Style`::``new`(``)``.``on``(`Blue`)``.``fg``(`Yellow`)``.``paint``(```\"`yow!`\"```)``)``;`\n`println!``(```\"`Also yellow on blue: `{}``\"```,` Cyan`.``on``(`Blue`)``.``fg``(`Yellow`)``.``paint``(```\"`zow!`\"```)``)``;`\n`\n```\n\nYou can turn a ``Color`` into a ``Style`` with the ``normal`` method. This will produce the exact same ``AnsiString`` as if you just used the ``paint`` method on the ``Color`` directly, but it\u2019s useful in certain cases: for example, you may have a method that returns ``Styles``, and need to represent both the \u201cred bold\u201d and \u201cred, but not bold\u201d styles with values of the same type. The ``Style`` struct also has a ```Default``` implementation if you want to have a style with _nothing_ set.\n```\n``use` `nu_ansi_term`::``Style`;`\n`use` `nu_ansi_term`::```Color`::``Red`;`\nRed`.``normal``(``)``.``paint``(```\"`yet another red string`\"```)``;`\n`Style`::``default`(``)``.``paint``(```\"`a completely regular string`\"```)``;`\n`\n```\n\nSometimes it is desirable to hard-reset a style/color just before applying a new one. To reset and apply, the ``reset_before_style`` method can be used on either ``Color`` or ``Style`` structs.\n```\n``use` `nu_ansi_term`::``Style`;`\n`println!``(```\"``\\x1b`[33mHow about some `{}` `\\x1b`[33mand `{}`?`\\x1b`[0m`\"```,`\n     `Style`::``new`(``)``.``reset_before_style``(``)``.``bold``(``)``.``paint``(```\"`bold`\"```)``,`\n     `Style`::``new`(``)``.``reset_before_style``(``)``.``underline``(``)``.``paint``(```\"`underline`\"```)``)``;`\n`\n```\n\n## Extended colors\nYou can access the extended range of 256 colors by using the ```Color`::``Fixed`` variant, which takes an argument of the color number to use. This can be included wherever you would use a ``Color``:\n```\n``use` `nu_ansi_term`::```Color`::``Fixed`;`\nFixed`(``134``)``.``paint``(```\"`A sort of light purple`\"```)``;`\nFixed`(``221``)``.``on``(`Fixed`(``124``)``)``.``paint``(```\"`Mustard in the ketchup`\"```)``;`\n`\n```\n\nThe first sixteen of these values are the same as the normal and bold standard color variants. There\u2019s nothing stopping you from using these as ``Fixed`` colors instead, but there\u2019s nothing to be gained by doing so either.\nYou can also access full 24-bit color by using the ```Color`::```RGB``` variant, which takes separate ```u8``` arguments for red, green, and blue:\n```\n``use` `nu_ansi_term`::```Color`::```RGB``;`\n`RGB``(``70``,` `130``,` `180``)``.``paint``(```\"`Steel blue`\"```)``;`\n`\n```\n\n## Combining successive colored strings\nThe benefit of writing ANSI escape codes to the terminal is that they _stack_ : you do not need to end every colored string with a reset code if the text that follows it is of a similar style. For example, if you want to have some blue text followed by some blue bold text, it\u2019s possible to send the ANSI code for blue, followed by the ANSI code for bold, and finishing with a reset code without having to have an extra one between the two strings.\nThis crate can optimise the ANSI codes that get printed in situations like this, making life easier for your terminal renderer. The ``AnsiStrings`` struct takes a slice of several ``AnsiString`` values, and will iterate over each of them, printing only the codes for the styles that need to be updated as part of its formatting routine.\nThe following code snippet uses this to enclose a binary number displayed in red bold text inside some red, but not bold, brackets:\n```\n``use` `nu_ansi_term`::```Color`::``Red`;`\n`use` `nu_ansi_term`::````{`AnsiString`,` AnsiStrings```}```;`\n`let` some_value `=` `format!``(```\"``{:b}``\"```,` `42``)``;`\n`let` strings`:` `&``[``AnsiString`<``'static``>```]` `=` `&``[`\n  Red`.``paint``(```\"`[`\"```)``,`\n  Red`.``bold``(``)``.``paint``(`some_value`)``,`\n  Red`.``paint``(```\"`]`\"```)``,`\n`]``;`\n`println!``(```\"`Value: `{}``\"```,` AnsiStrings`(`strings`)``)``;`\n`\n```\n\nThere are several things to note here. Firstly, the ``paint`` method can take _either_ an owned ```String``` or a borrowed ```&``str```. Internally, an ``AnsiString`` holds a copy-on-write (``Cow``) string value to deal with both owned and borrowed strings at the same time. This is used here to display a ```String```, the result of the ``format!`` call, using the same mechanism as some statically-available ```&``str``` slices. Secondly, that the ``AnsiStrings`` value works in the same way as its singular counterpart, with a ``Display`` implementation that only performs the formatting when required.\n## Byte strings\nThis library also supports formatting ```[``u8``]``` byte strings; this supports applications working with text in an unknown encoding. ``Style`` and ``Color`` support painting ```[``u8``]``` values, resulting in an ``AnsiByteString``. This type does not implement ``Display``, as it may not contain UTF-8, but it does provide a method ``write_to`` to write the result to any value that implements ``Write``:\n```\n``use` `nu_ansi_term`::```Color`::``Green`;`\nGreen`.``paint``(```\"`user data`\"```.``as_bytes``(``)``)``.``write_to``(``&``mut` `std`::```io`::``stdout`(``)``)``.``unwrap``(``)``;`\n`\n```\n\nSimilarly, the type ``AnsiByteStrings`` supports writing a list of ``AnsiByteString`` values with minimal escape sequences:\n```\n``use` `nu_ansi_term`::```Color`::``Green`;`\n`use` `nu_ansi_term`::``AnsiByteStrings`;`\nAnsiByteStrings`(``&``[`\n  Green`.``paint``(```\"`user data 1`\\n``\"```.``as_bytes``(``)``)``,`\n  Green`.``bold``(``)``.``paint``(```\"`user data 2`\\n``\"```.``as_bytes``(``)``)``,`\n`]``)``.``write_to``(``&``mut` `std`::```io`::``stdout`(``)``)``.``unwrap``(``)``;`\n`\n```\n\n#### Dependencies\n~0\u20138.5MB  ~69K SLoC\n  * [derive_serde_style?](https://lib.rs/crates/nu-ansi-term/features#feature-derive_serde_style \"optional feature\") [serde](https://lib.rs/crates/serde \"1.0.152\")[+derive](https://lib.rs/crates/serde/features#feature-derive)\n  * [windows-sys](https://lib.rs/crates/windows-sys \"renamed windows, obsolete\") 0.52[+Win32_Foundation](https://lib.rs/crates/windows-sys/features#feature-Win32_Foundation)[+Win32\u2026Console](https://lib.rs/crates/windows-sys/features#feature-Win32_System_Console)[+Win32\u2026FileSystem](https://lib.rs/crates/windows-sys/features#feature-Win32_Storage_FileSystem)[+Win32_Security](https://lib.rs/crates/windows-sys/features#feature-Win32_Security) win\n\n\n  * dev  [doc-comment](https://lib.rs/crates/doc-comment \"0.3.3\")\n  * dev  [serde_json](https://lib.rs/crates/serde_json \"1.0.94\")\n\n\n#### [Other feature](https://lib.rs/crates/nu-ansi-term/features)\n  * [gnu_legacy](https://lib.rs/crates/nu-ansi-term/features#feature-gnu_legacy)\n\n\n  *[SLoC]: approx. additional lines of code\n",
              "markdown_with_citations": "###  22 breaking releases\u27e81\u27e9\n0.50.1 |  Jul 23, 2024   \n---|---  \n0.50.0 |  Jan 22, 2024   \n0.49.0 |  Jul 22, 2023   \n0.47.0 |  Mar 13, 2023   \n0.29.0 |  Mar 30, 2021   \n#**9** in Command-line interface\u27e82\u27e9\nDownload history 1846149/week @ 2025-01-28 2000988/week @ 2025-02-04 2046823/week @ 2025-02-11 2296226/week @ 2025-02-18 2175884/week @ 2025-02-25 2586179/week @ 2025-03-04 2548779/week @ 2025-03-11 2966986/week @ 2025-03-18 2666176/week @ 2025-03-25 2409685/week @ 2025-04-01 2469960/week @ 2025-04-08 2138225/week @ 2025-04-15 2290833/week @ 2025-04-22 2167294/week @ 2025-04-29 2220314/week @ 2025-05-06 1888995/week @ 2025-05-13\n**8,890,270** downloads per month Used in **955** crates (126 directly)\u27e83\u27e9\n**MIT** license \n105KB  1.5K  SLoC\n# nu-ansi-term\n> This is a copy of rust-ansi-term but with Colour change to Color and light foreground colors added (90-97) as well as light background colors added (100-107).\nThis is a library for controlling colors and formatting, such as red bold text or blue underlined text, on ANSI terminals.\n## View the Rustdoc\u27e84\u27e9\n## Installation\nThis crate works with Cargo\u27e85\u27e9. Add the following to your ``Cargo.toml`` dependencies section:\n```\n```[``dependencies``]`\n`nu-ansi-term ``=` ``\"`0.49`\"``\n``# optional gnu-legacy mode to have two digit instead of one digit styles``\n`nu-ansi-term = { version=\"0.49\", features``=```[```\"`gnu_legacy`\"```]`` }\n``\n```\n\n## Basic usage\nThere are three main types in this crate that you need to be concerned with: ``AnsiString``, ``Style``, and ``Color``.\nA ``Style`` holds stylistic information: foreground and background colors, whether the text should be bold, or blinking, or other properties. The ``Color`` enum represents the available colors. And an ``AnsiString`` is a string paired with a ``Style``.\nTo format a string, call the ``paint`` method on a ``Style`` or a ``Color``, passing in the string you want to format as the argument. For example, here\u2019s how to get some red text:\n```\n``use` `nu_ansi_term`::```Color`::``Red`;`\n`println!``(```\"`This is in red: `{}``\"```,` Red`.``paint``(```\"`a red string`\"```)``)``;`\n`\n```\n\nIt\u2019s important to note that the ``paint`` method does _not_ actually return a string with the ANSI control characters surrounding it. Instead, it returns an ``AnsiString`` value that has a ``Display`` implementation that, when formatted, returns the characters. This allows strings to be printed with a minimum of ```String``` allocations being performed behind the scenes.\nIf you _do_ want to get at the escape codes, then you can convert the ``AnsiString`` to a string as you would any other ``Display`` value:\n```\n``use` `nu_ansi_term`::```Color`::``Red`;`\n`let` red_string `=` Red`.``paint``(```\"`a red string`\"```)``.``to_string``(``)``;`\n`\n```\n\n**Note for Windows 10 users:** On Windows 10, the application must enable ANSI support first:\n```\n``let` enabled `=` `nu_ansi_term`::``enable_ansi_support`(``)``;`\n`\n```\n\n## Bold, underline, background, and other styles\nFor anything more complex than plain foreground color changes, you need to construct ``Style`` values themselves, rather than beginning with a ``Color``. You can do this by chaining methods based on a new ``Style``, created with ```Style`::``new`(``)```. Each method creates a new style that has that specific property set. For example:\n```\n``use` `nu_ansi_term`::``Style`;`\n`println!``(```\"`How about some `{}` and `{}`?`\"```,`\n     `Style`::``new`(``)``.``bold``(``)``.``paint``(```\"`bold`\"```)``,`\n     `Style`::``new`(``)``.``underline``(``)``.``paint``(```\"`underline`\"```)``)``;`\n`\n```\n\nFor brevity, these methods have also been implemented for ``Color`` values, so you can give your styles a foreground color without having to begin with an empty ``Style`` value:\n```\n``use` `nu_ansi_term`::```Color`::````{`Blue`,` Yellow```}```;`\n`println!``(```\"`Demonstrating `{}` and `{}`!`\"```,`\n     Blue`.``bold``(``)``.``paint``(```\"`blue bold`\"```)``,`\n     Yellow`.``underline``(``)``.``paint``(```\"`yellow underline`\"```)``)``;`\n`println!``(```\"`Yellow on blue: `{}``\"```,` Yellow`.``on``(`Blue`)``.``paint``(```\"`wow!`\"```)``)``;`\n`\n```\n\nThe complete list of styles you can use are: ``bold``, ``dimmed``, ``italic``, ``underline``, ``blink``, ``reverse``, ``hidden``, and ``on`` for background colors.\nIn some cases, you may find it easier to change the foreground on an existing ``Style`` rather than starting from the appropriate ``Color``. You can do this using the ``fg`` method:\n```\n``use` `nu_ansi_term`::``Style`;`\n`use` `nu_ansi_term`::```Color`::````{`Blue`,` Cyan`,` Yellow```}```;`\n`println!``(```\"`Yellow on blue: `{}``\"```,` `Style`::``new`(``)``.``on``(`Blue`)``.``fg``(`Yellow`)``.``paint``(```\"`yow!`\"```)``)``;`\n`println!``(```\"`Also yellow on blue: `{}``\"```,` Cyan`.``on``(`Blue`)``.``fg``(`Yellow`)``.``paint``(```\"`zow!`\"```)``)``;`\n`\n```\n\nYou can turn a ``Color`` into a ``Style`` with the ``normal`` method. This will produce the exact same ``AnsiString`` as if you just used the ``paint`` method on the ``Color`` directly, but it\u2019s useful in certain cases: for example, you may have a method that returns ``Styles``, and need to represent both the \u201cred bold\u201d and \u201cred, but not bold\u201d styles with values of the same type. The ``Style`` struct also has a ```Default``` implementation if you want to have a style with _nothing_ set.\n```\n``use` `nu_ansi_term`::``Style`;`\n`use` `nu_ansi_term`::```Color`::``Red`;`\nRed`.``normal``(``)``.``paint``(```\"`yet another red string`\"```)``;`\n`Style`::``default`(``)``.``paint``(```\"`a completely regular string`\"```)``;`\n`\n```\n\nSometimes it is desirable to hard-reset a style/color just before applying a new one. To reset and apply, the ``reset_before_style`` method can be used on either ``Color`` or ``Style`` structs.\n```\n``use` `nu_ansi_term`::``Style`;`\n`println!``(```\"``\\x1b`[33mHow about some `{}` `\\x1b`[33mand `{}`?`\\x1b`[0m`\"```,`\n     `Style`::``new`(``)``.``reset_before_style``(``)``.``bold``(``)``.``paint``(```\"`bold`\"```)``,`\n     `Style`::``new`(``)``.``reset_before_style``(``)``.``underline``(``)``.``paint``(```\"`underline`\"```)``)``;`\n`\n```\n\n## Extended colors\nYou can access the extended range of 256 colors by using the ```Color`::``Fixed`` variant, which takes an argument of the color number to use. This can be included wherever you would use a ``Color``:\n```\n``use` `nu_ansi_term`::```Color`::``Fixed`;`\nFixed`(``134``)``.``paint``(```\"`A sort of light purple`\"```)``;`\nFixed`(``221``)``.``on``(`Fixed`(``124``)``)``.``paint``(```\"`Mustard in the ketchup`\"```)``;`\n`\n```\n\nThe first sixteen of these values are the same as the normal and bold standard color variants. There\u2019s nothing stopping you from using these as ``Fixed`` colors instead, but there\u2019s nothing to be gained by doing so either.\nYou can also access full 24-bit color by using the ```Color`::```RGB``` variant, which takes separate ```u8``` arguments for red, green, and blue:\n```\n``use` `nu_ansi_term`::```Color`::```RGB``;`\n`RGB``(``70``,` `130``,` `180``)``.``paint``(```\"`Steel blue`\"```)``;`\n`\n```\n\n## Combining successive colored strings\nThe benefit of writing ANSI escape codes to the terminal is that they _stack_ : you do not need to end every colored string with a reset code if the text that follows it is of a similar style. For example, if you want to have some blue text followed by some blue bold text, it\u2019s possible to send the ANSI code for blue, followed by the ANSI code for bold, and finishing with a reset code without having to have an extra one between the two strings.\nThis crate can optimise the ANSI codes that get printed in situations like this, making life easier for your terminal renderer. The ``AnsiStrings`` struct takes a slice of several ``AnsiString`` values, and will iterate over each of them, printing only the codes for the styles that need to be updated as part of its formatting routine.\nThe following code snippet uses this to enclose a binary number displayed in red bold text inside some red, but not bold, brackets:\n```\n``use` `nu_ansi_term`::```Color`::``Red`;`\n`use` `nu_ansi_term`::````{`AnsiString`,` AnsiStrings```}```;`\n`let` some_value `=` `format!``(```\"``{:b}``\"```,` `42``)``;`\n`let` strings`:` `&``[``AnsiString`<``'static``>```]` `=` `&``[`\n  Red`.``paint``(```\"`[`\"```)``,`\n  Red`.``bold``(``)``.``paint``(`some_value`)``,`\n  Red`.``paint``(```\"`]`\"```)``,`\n`]``;`\n`println!``(```\"`Value: `{}``\"```,` AnsiStrings`(`strings`)``)``;`\n`\n```\n\nThere are several things to note here. Firstly, the ``paint`` method can take _either_ an owned ```String``` or a borrowed ```&``str```. Internally, an ``AnsiString`` holds a copy-on-write (``Cow``) string value to deal with both owned and borrowed strings at the same time. This is used here to display a ```String```, the result of the ``format!`` call, using the same mechanism as some statically-available ```&``str``` slices. Secondly, that the ``AnsiStrings`` value works in the same way as its singular counterpart, with a ``Display`` implementation that only performs the formatting when required.\n## Byte strings\nThis library also supports formatting ```[``u8``]``` byte strings; this supports applications working with text in an unknown encoding. ``Style`` and ``Color`` support painting ```[``u8``]``` values, resulting in an ``AnsiByteString``. This type does not implement ``Display``, as it may not contain UTF-8, but it does provide a method ``write_to`` to write the result to any value that implements ``Write``:\n```\n``use` `nu_ansi_term`::```Color`::``Green`;`\nGreen`.``paint``(```\"`user data`\"```.``as_bytes``(``)``)``.``write_to``(``&``mut` `std`::```io`::``stdout`(``)``)``.``unwrap``(``)``;`\n`\n```\n\nSimilarly, the type ``AnsiByteStrings`` supports writing a list of ``AnsiByteString`` values with minimal escape sequences:\n```\n``use` `nu_ansi_term`::```Color`::``Green`;`\n`use` `nu_ansi_term`::``AnsiByteStrings`;`\nAnsiByteStrings`(``&``[`\n  Green`.``paint``(```\"`user data 1`\\n``\"```.``as_bytes``(``)``)``,`\n  Green`.``bold``(``)``.``paint``(```\"`user data 2`\\n``\"```.``as_bytes``(``)``)``,`\n`]``)``.``write_to``(``&``mut` `std`::```io`::``stdout`(``)``)``.``unwrap``(``)``;`\n`\n```\n\n#### Dependencies\n~0\u20138.5MB  ~69K SLoC\n  * derive_serde_style?\u27e86\u27e9 serde\u27e87\u27e9+derive\u27e88\u27e9\n  * windows-sys\u27e89\u27e9 0.52+Win32_Foundation\u27e810\u27e9+Win32\u2026Console\u27e811\u27e9+Win32\u2026FileSystem\u27e812\u27e9+Win32_Security\u27e813\u27e9 win\n\n\n  * dev  doc-comment\u27e814\u27e9\n  * dev  serde_json\u27e815\u27e9\n\n\n#### Other feature\u27e816\u27e9\n  * gnu_legacy\u27e817\u27e9\n\n\n  *[SLoC]: approx. additional lines of code\n",
              "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://lib.rs/crates/nu-ansi-term/versions: 22 breaking releases\n\u27e82\u27e9 https://lib.rs/command-line-interface: Crates to help create command line interfaces, such as argument parsers, line-editing, or output coloring and formatting. - Command-line interface\n\u27e83\u27e9 https://lib.rs/crates/nu-ansi-term/rev: **955** crates (126 directly)\n\u27e84\u27e9 https://docs.rs/nu_ansi_term/: View the Rustdoc\n\u27e85\u27e9 http://crates.io: Cargo\n\u27e86\u27e9 https://lib.rs/crates/nu-ansi-term/features#feature-derive_serde_style: optional feature - derive_serde_style?\n\u27e87\u27e9 https://lib.rs/crates/serde: 1.0.152 - serde\n\u27e88\u27e9 https://lib.rs/crates/serde/features#feature-derive: +derive\n\u27e89\u27e9 https://lib.rs/crates/windows-sys: renamed windows, obsolete - windows-sys\n\u27e810\u27e9 https://lib.rs/crates/windows-sys/features#feature-Win32_Foundation: +Win32_Foundation\n\u27e811\u27e9 https://lib.rs/crates/windows-sys/features#feature-Win32_System_Console: +Win32\u2026Console\n\u27e812\u27e9 https://lib.rs/crates/windows-sys/features#feature-Win32_Storage_FileSystem: +Win32\u2026FileSystem\n\u27e813\u27e9 https://lib.rs/crates/windows-sys/features#feature-Win32_Security: +Win32_Security\n\u27e814\u27e9 https://lib.rs/crates/doc-comment: 0.3.3 - doc-comment\n\u27e815\u27e9 https://lib.rs/crates/serde_json: 1.0.94 - serde_json\n\u27e816\u27e9 https://lib.rs/crates/nu-ansi-term/features: Other feature\n\u27e817\u27e9 https://lib.rs/crates/nu-ansi-term/features#feature-gnu_legacy: gnu_legacy\n",
              "fit_markdown": "",
              "fit_html": ""
            },
            "structured_data": {},
            "quality_score": 3.0,
            "extraction_method": "crawl4ai",
            "error": null,
            "metadata": {
              "doc_type": "docs",
              "content_length": 11478,
              "has_structured_data": false,
              "crawl_success": true
            },
            "timestamp": "114189.2355109"
          }
        },
        "crate_analysis": {
          "status": "completed",
          "check": [
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#windows_x86_64_msvc@0.52.6",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\windows_x86_64_msvc-0.52.6\\Cargo.toml",
              "target": {
                "kind": [
                  "custom-build"
                ],
                "crate_types": [
                  "bin"
                ],
                "name": "build-script-build",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\windows_x86_64_msvc-0.52.6\\build.rs",
                "edition": "2021",
                "doc": false,
                "doctest": false,
                "test": false
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpqz10t2mc\\nu-ansi-term-0.50.1\\target\\debug\\build\\windows_x86_64_msvc-733c1e19d91d737a\\build-script-build.exe",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpqz10t2mc\\nu-ansi-term-0.50.1\\target\\debug\\build\\windows_x86_64_msvc-733c1e19d91d737a\\build_script_build.pdb"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "build-script-executed",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#windows_x86_64_msvc@0.52.6",
              "linked_libs": [],
              "linked_paths": [
                "native=C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\windows_x86_64_msvc-0.52.6\\lib"
              ],
              "cfgs": [],
              "env": [],
              "out_dir": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpqz10t2mc\\nu-ansi-term-0.50.1\\target\\debug\\build\\windows_x86_64_msvc-a8b60e91c970423e\\out"
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#windows_x86_64_msvc@0.52.6",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\windows_x86_64_msvc-0.52.6\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "windows_x86_64_msvc",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\windows_x86_64_msvc-0.52.6\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpqz10t2mc\\nu-ansi-term-0.50.1\\target\\debug\\deps\\libwindows_x86_64_msvc-2b925ab0435b4697.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#windows-targets@0.52.6",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\windows-targets-0.52.6\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "windows_targets",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\windows-targets-0.52.6\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpqz10t2mc\\nu-ansi-term-0.50.1\\target\\debug\\deps\\libwindows_targets-88f43bd664d6863b.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#windows-sys@0.52.0",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\windows-sys-0.52.0\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "windows_sys",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\windows-sys-0.52.0\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "Win32",
                "Win32_Foundation",
                "Win32_Security",
                "Win32_Storage",
                "Win32_Storage_FileSystem",
                "Win32_System",
                "Win32_System_Console",
                "default"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpqz10t2mc\\nu-ansi-term-0.50.1\\target\\debug\\deps\\libwindows_sys-ebdeb241239e5255.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "compiler-artifact",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpqz10t2mc/nu-ansi-term-0.50.1#nu-ansi-term@0.50.1",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpqz10t2mc\\nu-ansi-term-0.50.1\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "nu_ansi_term",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpqz10t2mc\\nu-ansi-term-0.50.1\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpqz10t2mc\\nu-ansi-term-0.50.1\\target\\debug\\deps\\libnu_ansi_term-ffe77860faec954a.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "build-finished",
              "success": true
            }
          ],
          "clippy": [
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#windows_x86_64_msvc@0.52.6",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\windows_x86_64_msvc-0.52.6\\Cargo.toml",
              "target": {
                "kind": [
                  "custom-build"
                ],
                "crate_types": [
                  "bin"
                ],
                "name": "build-script-build",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\windows_x86_64_msvc-0.52.6\\build.rs",
                "edition": "2021",
                "doc": false,
                "doctest": false,
                "test": false
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpqz10t2mc\\nu-ansi-term-0.50.1\\target\\debug\\build\\windows_x86_64_msvc-733c1e19d91d737a\\build-script-build.exe",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpqz10t2mc\\nu-ansi-term-0.50.1\\target\\debug\\build\\windows_x86_64_msvc-733c1e19d91d737a\\build_script_build.pdb"
              ],
              "executable": null,
              "fresh": true
            },
            {
              "reason": "build-script-executed",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#windows_x86_64_msvc@0.52.6",
              "linked_libs": [],
              "linked_paths": [
                "native=C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\windows_x86_64_msvc-0.52.6\\lib"
              ],
              "cfgs": [],
              "env": [],
              "out_dir": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpqz10t2mc\\nu-ansi-term-0.50.1\\target\\debug\\build\\windows_x86_64_msvc-a8b60e91c970423e\\out"
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#windows_x86_64_msvc@0.52.6",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\windows_x86_64_msvc-0.52.6\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "windows_x86_64_msvc",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\windows_x86_64_msvc-0.52.6\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpqz10t2mc\\nu-ansi-term-0.50.1\\target\\debug\\deps\\libwindows_x86_64_msvc-2b925ab0435b4697.rmeta"
              ],
              "executable": null,
              "fresh": true
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#windows-targets@0.52.6",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\windows-targets-0.52.6\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "windows_targets",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\windows-targets-0.52.6\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpqz10t2mc\\nu-ansi-term-0.50.1\\target\\debug\\deps\\libwindows_targets-88f43bd664d6863b.rmeta"
              ],
              "executable": null,
              "fresh": true
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#windows-sys@0.52.0",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\windows-sys-0.52.0\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "windows_sys",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\windows-sys-0.52.0\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "Win32",
                "Win32_Foundation",
                "Win32_Security",
                "Win32_Storage",
                "Win32_Storage_FileSystem",
                "Win32_System",
                "Win32_System_Console",
                "default"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpqz10t2mc\\nu-ansi-term-0.50.1\\target\\debug\\deps\\libwindows_sys-ebdeb241239e5255.rmeta"
              ],
              "executable": null,
              "fresh": true
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpqz10t2mc/nu-ansi-term-0.50.1#nu-ansi-term@0.50.1",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpqz10t2mc\\nu-ansi-term-0.50.1\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "nu_ansi_term",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpqz10t2mc\\nu-ansi-term-0.50.1\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: empty lines after doc comment\n  --> src\\rgb.rs:69:5\n   |\n69 | /     /// Creates a new [Rgb] color from a [HSL] color\n...  |\n96 | |\n   | |_^\n97 |       /// Computes the linear interpolation between `self` and `other` for `t`\n98 |       pub fn lerp(&self, other: Self, t: f32) -> Self {\n   |       ----------- the comment documents this function\n   |\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#empty_line_after_doc_comments\n   = note: `#[warn(clippy::empty_line_after_doc_comments)]` on by default\n   = help: if the empty lines are unintentional, remove them\nhelp: if the doc comment should not document function `lerp` then comment it out\n   |\n69 |     // /// Creates a new [Rgb] color from a [HSL] color\n   |     ++\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#empty_line_after_doc_comments",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "note",
                    "message": "`#[warn(clippy::empty_line_after_doc_comments)]` on by default",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "if the empty lines are unintentional, remove them",
                    "rendered": null,
                    "spans": [
                      {
                        "byte_end": 2143,
                        "byte_start": 2142,
                        "column_end": 1,
                        "column_start": 13,
                        "expansion": null,
                        "file_name": "src\\rgb.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 74,
                        "line_start": 73,
                        "suggested_replacement": "",
                        "suggestion_applicability": "MaybeIncorrect",
                        "text": [
                          {
                            "highlight_end": 13,
                            "highlight_start": 13,
                            "text": "    //     }"
                          },
                          {
                            "highlight_end": 1,
                            "highlight_start": 1,
                            "text": ""
                          }
                        ]
                      },
                      {
                        "byte_end": 2709,
                        "byte_start": 2708,
                        "column_end": 1,
                        "column_start": 14,
                        "expansion": null,
                        "file_name": "src\\rgb.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 93,
                        "line_start": 92,
                        "suggested_replacement": "",
                        "suggestion_applicability": "MaybeIncorrect",
                        "text": [
                          {
                            "highlight_end": 14,
                            "highlight_start": 14,
                            "text": "    //     };"
                          },
                          {
                            "highlight_end": 1,
                            "highlight_start": 1,
                            "text": ""
                          }
                        ]
                      },
                      {
                        "byte_end": 2805,
                        "byte_start": 2804,
                        "column_end": 1,
                        "column_start": 9,
                        "expansion": null,
                        "file_name": "src\\rgb.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 96,
                        "line_start": 95,
                        "suggested_replacement": "",
                        "suggestion_applicability": "MaybeIncorrect",
                        "text": [
                          {
                            "highlight_end": 9,
                            "highlight_start": 9,
                            "text": "    // }"
                          },
                          {
                            "highlight_end": 1,
                            "highlight_start": 1,
                            "text": ""
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "if the doc comment should not document function `lerp` then comment it out",
                    "rendered": null,
                    "spans": [
                      {
                        "byte_end": 1964,
                        "byte_start": 1964,
                        "column_end": 5,
                        "column_start": 5,
                        "expansion": null,
                        "file_name": "src\\rgb.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 69,
                        "line_start": 69,
                        "suggested_replacement": "// ",
                        "suggestion_applicability": "MaybeIncorrect",
                        "text": [
                          {
                            "highlight_end": 5,
                            "highlight_start": 5,
                            "text": "    /// Creates a new [Rgb] color from a [HSL] color"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "code": {
                  "code": "clippy::empty_line_after_doc_comments",
                  "explanation": null
                },
                "level": "warning",
                "message": "empty lines after doc comment",
                "spans": [
                  {
                    "byte_end": 2898,
                    "byte_start": 2887,
                    "column_end": 16,
                    "column_start": 5,
                    "expansion": null,
                    "file_name": "src\\rgb.rs",
                    "is_primary": false,
                    "label": "the comment documents this function",
                    "line_end": 98,
                    "line_start": 98,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 16,
                        "highlight_start": 5,
                        "text": "    pub fn lerp(&self, other: Self, t: f32) -> Self {"
                      }
                    ]
                  },
                  {
                    "byte_end": 2805,
                    "byte_start": 1964,
                    "column_end": 1,
                    "column_start": 5,
                    "expansion": null,
                    "file_name": "src\\rgb.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 96,
                    "line_start": 69,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 53,
                        "highlight_start": 5,
                        "text": "    /// Creates a new [Rgb] color from a [HSL] color"
                      },
                      {
                        "highlight_end": 43,
                        "highlight_start": 1,
                        "text": "    // pub fn from_hsl(hsl: HSL) -> Self {"
                      },
                      {
                        "highlight_end": 29,
                        "highlight_start": 1,
                        "text": "    //     if hsl.s == 0.0 {"
                      },
                      {
                        "highlight_end": 45,
                        "highlight_start": 1,
                        "text": "    //         return Self::gray_f32(hsl.l);"
                      },
                      {
                        "highlight_end": 13,
                        "highlight_start": 1,
                        "text": "    //     }"
                      },
                      {
                        "highlight_end": 1,
                        "highlight_start": 1,
                        "text": ""
                      },
                      {
                        "highlight_end": 36,
                        "highlight_start": 1,
                        "text": "    //     let q = if hsl.l < 0.5 {"
                      },
                      {
                        "highlight_end": 37,
                        "highlight_start": 1,
                        "text": "    //         hsl.l * (1.0 + hsl.s)"
                      },
                      {
                        "highlight_end": 20,
                        "highlight_start": 1,
                        "text": "    //     } else {"
                      },
                      {
                        "highlight_end": 45,
                        "highlight_start": 1,
                        "text": "    //         hsl.l + hsl.s - hsl.l * hsl.s"
                      },
                      {
                        "highlight_end": 14,
                        "highlight_start": 1,
                        "text": "    //     };"
                      },
                      {
                        "highlight_end": 36,
                        "highlight_start": 1,
                        "text": "    //     let p = 2.0 * hsl.l - q;"
                      },
                      {
                        "highlight_end": 32,
                        "highlight_start": 1,
                        "text": "    //     let h2c = |t: f32| {"
                      },
                      {
                        "highlight_end": 42,
                        "highlight_start": 1,
                        "text": "    //         let t = t.clamp(0.0, 1.0);"
                      },
                      {
                        "highlight_end": 34,
                        "highlight_start": 1,
                        "text": "    //         if 6.0 * t < 1.0 {"
                      },
                      {
                        "highlight_end": 41,
                        "highlight_start": 1,
                        "text": "    //             p + 6.0 * (q - p) * t"
                      },
                      {
                        "highlight_end": 35,
                        "highlight_start": 1,
                        "text": "    //         } else if t < 0.5 {"
                      },
                      {
                        "highlight_end": 21,
                        "highlight_start": 1,
                        "text": "    //             q"
                      },
                      {
                        "highlight_end": 41,
                        "highlight_start": 1,
                        "text": "    //         } else if 1.0 < 1.5 * t {"
                      },
                      {
                        "highlight_end": 55,
                        "highlight_start": 1,
                        "text": "    //             p + 6.0 * (q - p) * (1.0 / 1.5 - t)"
                      },
                      {
                        "highlight_end": 24,
                        "highlight_start": 1,
                        "text": "    //         } else {"
                      },
                      {
                        "highlight_end": 21,
                        "highlight_start": 1,
                        "text": "    //             p"
                      },
                      {
                        "highlight_end": 17,
                        "highlight_start": 1,
                        "text": "    //         }"
                      },
                      {
                        "highlight_end": 14,
                        "highlight_start": 1,
                        "text": "    //     };"
                      },
                      {
                        "highlight_end": 1,
                        "highlight_start": 1,
                        "text": ""
                      },
                      {
                        "highlight_end": 86,
                        "highlight_start": 1,
                        "text": "    //     Self::from_f32(h2c(hsl.h + 1.0 / 3.0), h2c(hsl.h), h2c(hsl.h - 1.0 / 3.0))"
                      },
                      {
                        "highlight_end": 9,
                        "highlight_start": 1,
                        "text": "    // }"
                      },
                      {
                        "highlight_end": 1,
                        "highlight_start": 1,
                        "text": ""
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpqz10t2mc/nu-ansi-term-0.50.1#nu-ansi-term@0.50.1",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpqz10t2mc\\nu-ansi-term-0.50.1\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "nu_ansi_term",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpqz10t2mc\\nu-ansi-term-0.50.1\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: variables can be used directly in the `format!` string\n  --> src\\ansi.rs:34:17\n   |\n34 |                 write!(f, \"{}\", c)?;\n   |                 ^^^^^^^^^^^^^^^^^^\n   |\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#uninlined_format_args\n   = note: `#[warn(clippy::uninlined_format_args)]` on by default\nhelp: change this to\n   |\n34 -                 write!(f, \"{}\", c)?;\n34 +                 write!(f, \"{c}\")?;\n   |\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#uninlined_format_args",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "note",
                    "message": "`#[warn(clippy::uninlined_format_args)]` on by default",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "change this to",
                    "rendered": null,
                    "spans": [
                      {
                        "byte_end": 1206,
                        "byte_start": 1206,
                        "column_end": 29,
                        "column_start": 29,
                        "expansion": null,
                        "file_name": "src\\ansi.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 34,
                        "line_start": 34,
                        "suggested_replacement": "c",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 29,
                            "highlight_start": 29,
                            "text": "                write!(f, \"{}\", c)?;"
                          }
                        ]
                      },
                      {
                        "byte_end": 1211,
                        "byte_start": 1208,
                        "column_end": 34,
                        "column_start": 31,
                        "expansion": null,
                        "file_name": "src\\ansi.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 34,
                        "line_start": 34,
                        "suggested_replacement": "",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 34,
                            "highlight_start": 31,
                            "text": "                write!(f, \"{}\", c)?;"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "code": {
                  "code": "clippy::uninlined_format_args",
                  "explanation": null
                },
                "level": "warning",
                "message": "variables can be used directly in the `format!` string",
                "spans": [
                  {
                    "byte_end": 1212,
                    "byte_start": 1194,
                    "column_end": 35,
                    "column_start": 17,
                    "expansion": null,
                    "file_name": "src\\ansi.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 34,
                    "line_start": 34,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 35,
                        "highlight_start": 17,
                        "text": "                write!(f, \"{}\", c)?;"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpqz10t2mc/nu-ansi-term-0.50.1#nu-ansi-term@0.50.1",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpqz10t2mc\\nu-ansi-term-0.50.1\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "nu_ansi_term",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpqz10t2mc\\nu-ansi-term-0.50.1\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: variables can be used directly in the `format!` string\n   --> src\\ansi.rs:114:13\n    |\n114 |             write!(f, \"{}\", RESET)\n    |             ^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#uninlined_format_args\nhelp: change this to\n    |\n114 -             write!(f, \"{}\", RESET)\n114 +             write!(f, \"{RESET}\")\n    |\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#uninlined_format_args",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "change this to",
                    "rendered": null,
                    "spans": [
                      {
                        "byte_end": 3563,
                        "byte_start": 3563,
                        "column_end": 25,
                        "column_start": 25,
                        "expansion": null,
                        "file_name": "src\\ansi.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 114,
                        "line_start": 114,
                        "suggested_replacement": "RESET",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 25,
                            "highlight_start": 25,
                            "text": "            write!(f, \"{}\", RESET)"
                          }
                        ]
                      },
                      {
                        "byte_end": 3572,
                        "byte_start": 3565,
                        "column_end": 34,
                        "column_start": 27,
                        "expansion": null,
                        "file_name": "src\\ansi.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 114,
                        "line_start": 114,
                        "suggested_replacement": "",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 34,
                            "highlight_start": 27,
                            "text": "            write!(f, \"{}\", RESET)"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "code": {
                  "code": "clippy::uninlined_format_args",
                  "explanation": null
                },
                "level": "warning",
                "message": "variables can be used directly in the `format!` string",
                "spans": [
                  {
                    "byte_end": 3573,
                    "byte_start": 3551,
                    "column_end": 35,
                    "column_start": 13,
                    "expansion": null,
                    "file_name": "src\\ansi.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 114,
                    "line_start": 114,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 35,
                        "highlight_start": 13,
                        "text": "            write!(f, \"{}\", RESET)"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpqz10t2mc/nu-ansi-term-0.50.1#nu-ansi-term@0.50.1",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpqz10t2mc\\nu-ansi-term-0.50.1\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "nu_ansi_term",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpqz10t2mc\\nu-ansi-term-0.50.1\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: variables can be used directly in the `format!` string\n   --> src\\ansi.rs:134:34\n    |\n134 |             Color::Fixed(num) => write!(f, \"38;5;{}\", num),\n    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#uninlined_format_args\nhelp: change this to\n    |\n134 -             Color::Fixed(num) => write!(f, \"38;5;{}\", num),\n134 +             Color::Fixed(num) => write!(f, \"38;5;{num}\"),\n    |\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#uninlined_format_args",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "change this to",
                    "rendered": null,
                    "spans": [
                      {
                        "byte_end": 4289,
                        "byte_start": 4289,
                        "column_end": 51,
                        "column_start": 51,
                        "expansion": null,
                        "file_name": "src\\ansi.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 134,
                        "line_start": 134,
                        "suggested_replacement": "num",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 51,
                            "highlight_start": 51,
                            "text": "            Color::Fixed(num) => write!(f, \"38;5;{}\", num),"
                          }
                        ]
                      },
                      {
                        "byte_end": 4296,
                        "byte_start": 4291,
                        "column_end": 58,
                        "column_start": 53,
                        "expansion": null,
                        "file_name": "src\\ansi.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 134,
                        "line_start": 134,
                        "suggested_replacement": "",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 58,
                            "highlight_start": 53,
                            "text": "            Color::Fixed(num) => write!(f, \"38;5;{}\", num),"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "code": {
                  "code": "clippy::uninlined_format_args",
                  "explanation": null
                },
                "level": "warning",
                "message": "variables can be used directly in the `format!` string",
                "spans": [
                  {
                    "byte_end": 4297,
                    "byte_start": 4272,
                    "column_end": 59,
                    "column_start": 34,
                    "expansion": null,
                    "file_name": "src\\ansi.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 134,
                    "line_start": 134,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 59,
                        "highlight_start": 34,
                        "text": "            Color::Fixed(num) => write!(f, \"38;5;{}\", num),"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpqz10t2mc/nu-ansi-term-0.50.1#nu-ansi-term@0.50.1",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpqz10t2mc\\nu-ansi-term-0.50.1\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "nu_ansi_term",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpqz10t2mc\\nu-ansi-term-0.50.1\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: variables can be used directly in the `format!` string\n   --> src\\ansi.rs:135:36\n    |\n135 |             Color::Rgb(r, g, b) => write!(f, \"38;2;{};{};{}\", r, g, b),\n    |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#uninlined_format_args\nhelp: change this to\n    |\n135 -             Color::Rgb(r, g, b) => write!(f, \"38;2;{};{};{}\", r, g, b),\n135 +             Color::Rgb(r, g, b) => write!(f, \"38;2;{r};{g};{b}\"),\n    |\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#uninlined_format_args",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "change this to",
                    "rendered": null,
                    "spans": [
                      {
                        "byte_end": 4351,
                        "byte_start": 4351,
                        "column_end": 53,
                        "column_start": 53,
                        "expansion": null,
                        "file_name": "src\\ansi.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 135,
                        "line_start": 135,
                        "suggested_replacement": "r",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 53,
                            "highlight_start": 53,
                            "text": "            Color::Rgb(r, g, b) => write!(f, \"38;2;{};{};{}\", r, g, b),"
                          }
                        ]
                      },
                      {
                        "byte_end": 4354,
                        "byte_start": 4354,
                        "column_end": 56,
                        "column_start": 56,
                        "expansion": null,
                        "file_name": "src\\ansi.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 135,
                        "line_start": 135,
                        "suggested_replacement": "g",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 56,
                            "highlight_start": 56,
                            "text": "            Color::Rgb(r, g, b) => write!(f, \"38;2;{};{};{}\", r, g, b),"
                          }
                        ]
                      },
                      {
                        "byte_end": 4357,
                        "byte_start": 4357,
                        "column_end": 59,
                        "column_start": 59,
                        "expansion": null,
                        "file_name": "src\\ansi.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 135,
                        "line_start": 135,
                        "suggested_replacement": "b",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 59,
                            "highlight_start": 59,
                            "text": "            Color::Rgb(r, g, b) => write!(f, \"38;2;{};{};{}\", r, g, b),"
                          }
                        ]
                      },
                      {
                        "byte_end": 4362,
                        "byte_start": 4359,
                        "column_end": 64,
                        "column_start": 61,
                        "expansion": null,
                        "file_name": "src\\ansi.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 135,
                        "line_start": 135,
                        "suggested_replacement": "",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 64,
                            "highlight_start": 61,
                            "text": "            Color::Rgb(r, g, b) => write!(f, \"38;2;{};{};{}\", r, g, b),"
                          }
                        ]
                      },
                      {
                        "byte_end": 4365,
                        "byte_start": 4362,
                        "column_end": 67,
                        "column_start": 64,
                        "expansion": null,
                        "file_name": "src\\ansi.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 135,
                        "line_start": 135,
                        "suggested_replacement": "",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 67,
                            "highlight_start": 64,
                            "text": "            Color::Rgb(r, g, b) => write!(f, \"38;2;{};{};{}\", r, g, b),"
                          }
                        ]
                      },
                      {
                        "byte_end": 4368,
                        "byte_start": 4365,
                        "column_end": 70,
                        "column_start": 67,
                        "expansion": null,
                        "file_name": "src\\ansi.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 135,
                        "line_start": 135,
                        "suggested_replacement": "",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 70,
                            "highlight_start": 67,
                            "text": "            Color::Rgb(r, g, b) => write!(f, \"38;2;{};{};{}\", r, g, b),"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "code": {
                  "code": "clippy::uninlined_format_args",
                  "explanation": null
                },
                "level": "warning",
                "message": "variables can be used directly in the `format!` string",
                "spans": [
                  {
                    "byte_end": 4369,
                    "byte_start": 4334,
                    "column_end": 71,
                    "column_start": 36,
                    "expansion": null,
                    "file_name": "src\\ansi.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 135,
                    "line_start": 135,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 71,
                        "highlight_start": 36,
                        "text": "            Color::Rgb(r, g, b) => write!(f, \"38;2;{};{};{}\", r, g, b),"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpqz10t2mc/nu-ansi-term-0.50.1#nu-ansi-term@0.50.1",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpqz10t2mc\\nu-ansi-term-0.50.1\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "nu_ansi_term",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpqz10t2mc\\nu-ansi-term-0.50.1\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: variables can be used directly in the `format!` string\n   --> src\\ansi.rs:160:34\n    |\n160 |             Color::Fixed(num) => write!(f, \"48;5;{}\", num),\n    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#uninlined_format_args\nhelp: change this to\n    |\n160 -             Color::Fixed(num) => write!(f, \"48;5;{}\", num),\n160 +             Color::Fixed(num) => write!(f, \"48;5;{num}\"),\n    |\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#uninlined_format_args",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "change this to",
                    "rendered": null,
                    "spans": [
                      {
                        "byte_end": 5453,
                        "byte_start": 5453,
                        "column_end": 51,
                        "column_start": 51,
                        "expansion": null,
                        "file_name": "src\\ansi.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 160,
                        "line_start": 160,
                        "suggested_replacement": "num",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 51,
                            "highlight_start": 51,
                            "text": "            Color::Fixed(num) => write!(f, \"48;5;{}\", num),"
                          }
                        ]
                      },
                      {
                        "byte_end": 5460,
                        "byte_start": 5455,
                        "column_end": 58,
                        "column_start": 53,
                        "expansion": null,
                        "file_name": "src\\ansi.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 160,
                        "line_start": 160,
                        "suggested_replacement": "",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 58,
                            "highlight_start": 53,
                            "text": "            Color::Fixed(num) => write!(f, \"48;5;{}\", num),"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "code": {
                  "code": "clippy::uninlined_format_args",
                  "explanation": null
                },
                "level": "warning",
                "message": "variables can be used directly in the `format!` string",
                "spans": [
                  {
                    "byte_end": 5461,
                    "byte_start": 5436,
                    "column_end": 59,
                    "column_start": 34,
                    "expansion": null,
                    "file_name": "src\\ansi.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 160,
                    "line_start": 160,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 59,
                        "highlight_start": 34,
                        "text": "            Color::Fixed(num) => write!(f, \"48;5;{}\", num),"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpqz10t2mc/nu-ansi-term-0.50.1#nu-ansi-term@0.50.1",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpqz10t2mc\\nu-ansi-term-0.50.1\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "nu_ansi_term",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpqz10t2mc\\nu-ansi-term-0.50.1\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: variables can be used directly in the `format!` string\n   --> src\\ansi.rs:161:36\n    |\n161 |             Color::Rgb(r, g, b) => write!(f, \"48;2;{};{};{}\", r, g, b),\n    |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#uninlined_format_args\nhelp: change this to\n    |\n161 -             Color::Rgb(r, g, b) => write!(f, \"48;2;{};{};{}\", r, g, b),\n161 +             Color::Rgb(r, g, b) => write!(f, \"48;2;{r};{g};{b}\"),\n    |\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#uninlined_format_args",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "change this to",
                    "rendered": null,
                    "spans": [
                      {
                        "byte_end": 5515,
                        "byte_start": 5515,
                        "column_end": 53,
                        "column_start": 53,
                        "expansion": null,
                        "file_name": "src\\ansi.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 161,
                        "line_start": 161,
                        "suggested_replacement": "r",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 53,
                            "highlight_start": 53,
                            "text": "            Color::Rgb(r, g, b) => write!(f, \"48;2;{};{};{}\", r, g, b),"
                          }
                        ]
                      },
                      {
                        "byte_end": 5518,
                        "byte_start": 5518,
                        "column_end": 56,
                        "column_start": 56,
                        "expansion": null,
                        "file_name": "src\\ansi.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 161,
                        "line_start": 161,
                        "suggested_replacement": "g",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 56,
                            "highlight_start": 56,
                            "text": "            Color::Rgb(r, g, b) => write!(f, \"48;2;{};{};{}\", r, g, b),"
                          }
                        ]
                      },
                      {
                        "byte_end": 5521,
                        "byte_start": 5521,
                        "column_end": 59,
                        "column_start": 59,
                        "expansion": null,
                        "file_name": "src\\ansi.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 161,
                        "line_start": 161,
                        "suggested_replacement": "b",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 59,
                            "highlight_start": 59,
                            "text": "            Color::Rgb(r, g, b) => write!(f, \"48;2;{};{};{}\", r, g, b),"
                          }
                        ]
                      },
                      {
                        "byte_end": 5526,
                        "byte_start": 5523,
                        "column_end": 64,
                        "column_start": 61,
                        "expansion": null,
                        "file_name": "src\\ansi.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 161,
                        "line_start": 161,
                        "suggested_replacement": "",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 64,
                            "highlight_start": 61,
                            "text": "            Color::Rgb(r, g, b) => write!(f, \"48;2;{};{};{}\", r, g, b),"
                          }
                        ]
                      },
                      {
                        "byte_end": 5529,
                        "byte_start": 5526,
                        "column_end": 67,
                        "column_start": 64,
                        "expansion": null,
                        "file_name": "src\\ansi.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 161,
                        "line_start": 161,
                        "suggested_replacement": "",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 67,
                            "highlight_start": 64,
                            "text": "            Color::Rgb(r, g, b) => write!(f, \"48;2;{};{};{}\", r, g, b),"
                          }
                        ]
                      },
                      {
                        "byte_end": 5532,
                        "byte_start": 5529,
                        "column_end": 70,
                        "column_start": 67,
                        "expansion": null,
                        "file_name": "src\\ansi.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 161,
                        "line_start": 161,
                        "suggested_replacement": "",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 70,
                            "highlight_start": 67,
                            "text": "            Color::Rgb(r, g, b) => write!(f, \"48;2;{};{};{}\", r, g, b),"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "code": {
                  "code": "clippy::uninlined_format_args",
                  "explanation": null
                },
                "level": "warning",
                "message": "variables can be used directly in the `format!` string",
                "spans": [
                  {
                    "byte_end": 5533,
                    "byte_start": 5498,
                    "column_end": 71,
                    "column_start": 36,
                    "expansion": null,
                    "file_name": "src\\ansi.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 161,
                    "line_start": 161,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 71,
                        "highlight_start": 36,
                        "text": "            Color::Rgb(r, g, b) => write!(f, \"48;2;{};{};{}\", r, g, b),"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpqz10t2mc/nu-ansi-term-0.50.1#nu-ansi-term@0.50.1",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpqz10t2mc\\nu-ansi-term-0.50.1\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "nu_ansi_term",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpqz10t2mc\\nu-ansi-term-0.50.1\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: variables can be used directly in the `format!` string\n   --> src\\display.rs:375:17\n    |\n375 |                 write!(w, \"{}\", RESET)?;\n    |                 ^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#uninlined_format_args\nhelp: change this to\n    |\n375 -                 write!(w, \"{}\", RESET)?;\n375 +                 write!(w, \"{RESET}\")?;\n    |\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#uninlined_format_args",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "change this to",
                    "rendered": null,
                    "spans": [
                      {
                        "byte_end": 11361,
                        "byte_start": 11361,
                        "column_end": 29,
                        "column_start": 29,
                        "expansion": null,
                        "file_name": "src\\display.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 375,
                        "line_start": 375,
                        "suggested_replacement": "RESET",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 29,
                            "highlight_start": 29,
                            "text": "                write!(w, \"{}\", RESET)?;"
                          }
                        ]
                      },
                      {
                        "byte_end": 11370,
                        "byte_start": 11363,
                        "column_end": 38,
                        "column_start": 31,
                        "expansion": null,
                        "file_name": "src\\display.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 375,
                        "line_start": 375,
                        "suggested_replacement": "",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 38,
                            "highlight_start": 31,
                            "text": "                write!(w, \"{}\", RESET)?;"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "code": {
                  "code": "clippy::uninlined_format_args",
                  "explanation": null
                },
                "level": "warning",
                "message": "variables can be used directly in the `format!` string",
                "spans": [
                  {
                    "byte_end": 11371,
                    "byte_start": 11349,
                    "column_end": 39,
                    "column_start": 17,
                    "expansion": null,
                    "file_name": "src\\display.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 375,
                    "line_start": 375,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 39,
                        "highlight_start": 17,
                        "text": "                write!(w, \"{}\", RESET)?;"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpqz10t2mc/nu-ansi-term-0.50.1#nu-ansi-term@0.50.1",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpqz10t2mc\\nu-ansi-term-0.50.1\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "nu_ansi_term",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpqz10t2mc\\nu-ansi-term-0.50.1\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: variables can be used directly in the `format!` string\n  --> src\\debug.rs:40:17\n   |\n40 |                 write!(fmt, \"fg({:?})\", fg)?\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#uninlined_format_args\nhelp: change this to\n   |\n40 -                 write!(fmt, \"fg({:?})\", fg)?\n40 +                 write!(fmt, \"fg({fg:?})\")?\n   |\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#uninlined_format_args",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "change this to",
                    "rendered": null,
                    "spans": [
                      {
                        "byte_end": 1591,
                        "byte_start": 1591,
                        "column_end": 34,
                        "column_start": 34,
                        "expansion": null,
                        "file_name": "src\\debug.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 40,
                        "line_start": 40,
                        "suggested_replacement": "fg",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 34,
                            "highlight_start": 34,
                            "text": "                write!(fmt, \"fg({:?})\", fg)?"
                          }
                        ]
                      },
                      {
                        "byte_end": 1600,
                        "byte_start": 1596,
                        "column_end": 43,
                        "column_start": 39,
                        "expansion": null,
                        "file_name": "src\\debug.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 40,
                        "line_start": 40,
                        "suggested_replacement": "",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 43,
                            "highlight_start": 39,
                            "text": "                write!(fmt, \"fg({:?})\", fg)?"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "code": {
                  "code": "clippy::uninlined_format_args",
                  "explanation": null
                },
                "level": "warning",
                "message": "variables can be used directly in the `format!` string",
                "spans": [
                  {
                    "byte_end": 1601,
                    "byte_start": 1574,
                    "column_end": 44,
                    "column_start": 17,
                    "expansion": null,
                    "file_name": "src\\debug.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 40,
                    "line_start": 40,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 44,
                        "highlight_start": 17,
                        "text": "                write!(fmt, \"fg({:?})\", fg)?"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpqz10t2mc/nu-ansi-term-0.50.1#nu-ansi-term@0.50.1",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpqz10t2mc\\nu-ansi-term-0.50.1\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "nu_ansi_term",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpqz10t2mc\\nu-ansi-term-0.50.1\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: variables can be used directly in the `format!` string\n  --> src\\debug.rs:48:17\n   |\n48 |                 write!(fmt, \"on({:?})\", bg)?\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#uninlined_format_args\nhelp: change this to\n   |\n48 -                 write!(fmt, \"on({:?})\", bg)?\n48 +                 write!(fmt, \"on({bg:?})\")?\n   |\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#uninlined_format_args",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "change this to",
                    "rendered": null,
                    "spans": [
                      {
                        "byte_end": 1837,
                        "byte_start": 1837,
                        "column_end": 34,
                        "column_start": 34,
                        "expansion": null,
                        "file_name": "src\\debug.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 48,
                        "line_start": 48,
                        "suggested_replacement": "bg",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 34,
                            "highlight_start": 34,
                            "text": "                write!(fmt, \"on({:?})\", bg)?"
                          }
                        ]
                      },
                      {
                        "byte_end": 1846,
                        "byte_start": 1842,
                        "column_end": 43,
                        "column_start": 39,
                        "expansion": null,
                        "file_name": "src\\debug.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 48,
                        "line_start": 48,
                        "suggested_replacement": "",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 43,
                            "highlight_start": 39,
                            "text": "                write!(fmt, \"on({:?})\", bg)?"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "code": {
                  "code": "clippy::uninlined_format_args",
                  "explanation": null
                },
                "level": "warning",
                "message": "variables can be used directly in the `format!` string",
                "spans": [
                  {
                    "byte_end": 1847,
                    "byte_start": 1820,
                    "column_end": 44,
                    "column_start": 17,
                    "expansion": null,
                    "file_name": "src\\debug.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 48,
                    "line_start": 48,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 44,
                        "highlight_start": 17,
                        "text": "                write!(fmt, \"on({:?})\", bg)?"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-artifact",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpqz10t2mc/nu-ansi-term-0.50.1#nu-ansi-term@0.50.1",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpqz10t2mc\\nu-ansi-term-0.50.1\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "nu_ansi_term",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpqz10t2mc\\nu-ansi-term-0.50.1\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpqz10t2mc\\nu-ansi-term-0.50.1\\target\\debug\\deps\\libnu_ansi_term-2de612af93d0d2ce.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "build-finished",
              "success": true
            }
          ],
          "audit": {
            "database": {
              "advisory-count": 787,
              "last-commit": "7573f55ba337263f61167dbb0ea926cdc7c8eb5d",
              "last-updated": "2025-06-17T11:04:25+02:00"
            },
            "lockfile": {
              "dependency-count": 21
            },
            "settings": {
              "target_arch": [],
              "target_os": [],
              "severity": null,
              "ignore": [],
              "informational_warnings": [
                "unmaintained",
                "unsound",
                "notice"
              ]
            },
            "vulnerabilities": {
              "found": false,
              "count": 0,
              "list": []
            },
            "warnings": {}
          },
          "note": "Crate analysis performed with stable toolchain."
        },
        "crate_metadata": {
          "name": "nu-ansi-term",
          "version": "0.50.1",
          "description": "ALLOW: Positive community sentiment",
          "repository": "",
          "keywords": [],
          "categories": [],
          "readme": {
            "raw_markdown": "[](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/all.html \"show sidebar\")\n# Crate nu_ansi_termCopy item path\n[Settings](https://docs.rs/nu-ansi-term/latest/settings.html)\n[Help](https://docs.rs/nu-ansi-term/latest/help.html)\nSummary[Source](https://docs.rs/nu-ansi-term/latest/src/nu_ansi_term/lib.rs.html#1-267)\nExpand description\nThis is a library for controlling colors and formatting, such as red bold text or blue underlined text, on ANSI terminals.\n### [\u00a7](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/#basic-usage)Basic usage\nThere are three main types in this crate that you need to be concerned with: [`AnsiString`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/type.AnsiString.html), [`Style`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html), and [`Color`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/enum.Color.html).\nA `Style` holds stylistic information: foreground and background colors, whether the text should be bold, or blinking, or other properties. The [`Color`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/enum.Color.html) enum represents the available colors. And an [`AnsiString`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/type.AnsiString.html) is a string paired with a [`Style`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html).\n[`Color`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/enum.Color.html) is also available as an alias to `Color`.\nTo format a string, call the `paint` method on a `Style` or a `Color`, passing in the string you want to format as the argument. For example, here\u2019s how to get some red text:\n```\nuse nu_ansi_term::Color::Red;\nprintln!(\"This is in red: {}\", Red.paint(\"a red string\"));\n```\n\nIt\u2019s important to note that the `paint` method does _not_ actually return a string with the ANSI control characters surrounding it. Instead, it returns an [`AnsiString`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/type.AnsiString.html) value that has a [`Display`](https://doc.rust-lang.org/std/fmt/trait.Display.html) implementation that, when formatted, returns the characters. This allows strings to be printed with a minimum of [`String`](https://doc.rust-lang.org/std/string/struct.String.html) allocations being performed behind the scenes.\nIf you _do_ want to get at the escape codes, then you can convert the [`AnsiString`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/type.AnsiString.html) to a string as you would any other `Display` value:\n```\nuse nu_ansi_term::Color::Red;\nlet red_string = Red.paint(\"a red string\").to_string();\n```\n\n### [\u00a7](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/#bold-underline-background-and-other-styles)Bold, underline, background, and other styles\nFor anything more complex than plain foreground color changes, you need to construct `Style` values themselves, rather than beginning with a `Color`. You can do this by chaining methods based on a new `Style`, created with [`Style::new()`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html#method.new). Each method creates a new style that has that specific property set. For example:\n```\nuse nu_ansi_term::Style;\nprintln!(\"How about some {} and {}?\",\n     Style::new().bold().paint(\"bold\"),\n     Style::new().underline().paint(\"underline\"));\n```\n\nFor brevity, these methods have also been implemented for `Color` values, so you can give your styles a foreground color without having to begin with an empty `Style` value:\n```\nuse nu_ansi_term::Color::{Blue, Yellow};\nprintln!(\"Demonstrating {} and {}!\",\n     Blue.bold().paint(\"blue bold\"),\n     Yellow.underline().paint(\"yellow underline\"));\nprintln!(\"Yellow on blue: {}\", Yellow.on(Blue).paint(\"wow!\"));\n```\n\nThe complete list of styles you can use are: [`bold`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html#method.bold), [`dimmed`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html#method.dimmed), [`italic`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html#method.italic), [`underline`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html#method.underline), [`blink`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html#method.blink), [`reverse`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html#method.reverse), [`hidden`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html#method.hidden), [`strikethrough`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html#method.strikethrough), and [`on`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html#method.on) for background colors.\nIn some cases, you may find it easier to change the foreground on an existing `Style` rather than starting from the appropriate `Color`. You can do this using the [`fg`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html#method.fg) method:\n```\nuse nu_ansi_term::Style;\nuse nu_ansi_term::Color::{Blue, Cyan, Yellow};\nprintln!(\"Yellow on blue: {}\", Style::new().on(Blue).fg(Yellow).paint(\"yow!\"));\nprintln!(\"Also yellow on blue: {}\", Cyan.on(Blue).fg(Yellow).paint(\"zow!\"));\n```\n\nYou can turn a `Color` into a `Style` with the [`normal`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/enum.Color.html#method.normal) method. This will produce the exact same `AnsiString` as if you just used the `paint` method on the `Color` directly, but it\u2019s useful in certain cases: for example, you may have a method that returns `Styles`, and need to represent both the \u201cred bold\u201d and \u201cred, but not bold\u201d styles with values of the same type. The `Style` struct also has a [`Default`](https://doc.rust-lang.org/std/default/trait.Default.html) implementation if you want to have a style with _nothing_ set.\n```\nuse nu_ansi_term::Style;\nuse nu_ansi_term::Color::Red;\nRed.normal().paint(\"yet another red string\");\nStyle::default().paint(\"a completely regular string\");\n```\n\n### [\u00a7](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/#extended-colors)Extended colors\nYou can access the extended range of 256 colors by using the `Color::Fixed` variant, which takes an argument of the color number to use. This can be included wherever you would use a `Color`:\n```\nuse nu_ansi_term::Color::Fixed;\nFixed(134).paint(\"A sort of light purple\");\nFixed(221).on(Fixed(124)).paint(\"Mustard in the ketchup\");\n```\n\nThe first sixteen of these values are the same as the normal and bold standard color variants. There\u2019s nothing stopping you from using these as `Fixed` colors instead, but there\u2019s nothing to be gained by doing so either.\nYou can also access full 24-bit color by using the `Color::Rgb` variant, which takes separate `u8` arguments for red, green, and blue:\n```\nuse nu_ansi_term::Color::Rgb;\nRgb(70, 130, 180).paint(\"Steel blue\");\n```\n\n### [\u00a7](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/#combining-successive-colored-strings)Combining successive colored strings\nThe benefit of writing ANSI escape codes to the terminal is that they _stack_ : you do not need to end every colored string with a reset code if the text that follows it is of a similar style. For example, if you want to have some blue text followed by some blue bold text, it\u2019s possible to send the ANSI code for blue, followed by the ANSI code for bold, and finishing with a reset code without having to have an extra one between the two strings.\nThis crate can optimise the ANSI codes that get printed in situations like this, making life easier for your terminal renderer. The [`AnsiStrings`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/type.AnsiStrings.html) type takes a slice of several [`AnsiString`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/type.AnsiString.html) values, and will iterate over each of them, printing only the codes for the styles that need to be updated as part of its formatting routine.\nThe following code snippet uses this to enclose a binary number displayed in red bold text inside some red, but not bold, brackets:\n```\nuse nu_ansi_term::Color::Red;\nuse nu_ansi_term::{AnsiString, AnsiStrings};\nlet some_value = format!(\"{:b}\", 42);\nlet strings: &[AnsiString<'static>] = &[\n  Red.paint(\"[\"),\n  Red.bold().paint(some_value),\n  Red.paint(\"]\"),\n];\nprintln!(\"Value: {}\", AnsiStrings(strings));\n```\n\nThere are several things to note here. Firstly, the [`paint`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/type.AnsiByteString.html#method.write_to) method can take _either_ an owned [`String`](https://doc.rust-lang.org/std/string/struct.String.html) or a borrowed [`&str`](https://doc.rust-lang.org/std/primitive.str.html). Internally, an [`AnsiString`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/type.AnsiString.html) holds a copy-on-write ([`Cow`](https://doc.rust-lang.org/std/borrow/enum.Cow.html)) string value to deal with both owned and borrowed strings at the same time. This is used here to display a `String`, the result of the `format!` call, using the same mechanism as some statically-available `&str` slices. Secondly, that the [`AnsiStrings`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/type.AnsiStrings.html) value works in the same way as its singular counterpart, with a [`Display`](https://doc.rust-lang.org/std/fmt/trait.Display.html) implementation that only performs the formatting when required.\n### [\u00a7](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/#byte-strings)Byte strings\nThis library also supports formatting `\\[u8]` byte strings; this supports applications working with text in an unknown encoding. [`Style`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html) and [`Color`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/enum.Color.html) support painting `\\[u8]` values, resulting in an [`AnsiByteString`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/type.AnsiByteString.html). This type does not implement [`Display`](https://doc.rust-lang.org/std/fmt/trait.Display.html), as it may not contain UTF-8, but it does provide a method [`write_to`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/type.AnsiByteString.html#method.write_to) to write the result to any value that implements [`Write`](https://doc.rust-lang.org/std/io/trait.Write.html):\n```\nuse nu_ansi_term::Color::Green;\nGreen.paint(\"user data\".as_bytes()).write_to(&mut std::io::stdout()).unwrap();\n```\n\nSimilarly, the type [`AnsiByteStrings`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/type.AnsiByteStrings.html) supports writing a list of [`AnsiByteString`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/type.AnsiByteString.html) values with minimal escape sequences:\n```\nuse nu_ansi_term::Color::Green;\nuse nu_ansi_term::AnsiByteStrings;\nAnsiByteStrings(&[\n  Green.paint(\"user data 1\\n\".as_bytes()),\n  Green.bold().paint(\"user data 2\\n\".as_bytes()),\n]).write_to(&mut std::io::stdout()).unwrap();\n```\n\n## Re-exports[\u00a7](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/#reexports)\n\n`pub use ansi::Infix[](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/ansi/struct.Infix.html \"struct nu_ansi_term::ansi::Infix\");`\n\n\n`pub use ansi::Prefix[](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/ansi/struct.Prefix.html \"struct nu_ansi_term::ansi::Prefix\");`\n\n\n`pub use ansi::Suffix[](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/ansi/struct.Suffix.html \"struct nu_ansi_term::ansi::Suffix\");`\n\n\n`pub use gradient[](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/gradient/index.html \"mod nu_ansi_term::gradient\")::*;`\n\n## Modules[\u00a7](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/#modules)\n\n[ansi](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/ansi/index.html \"mod nu_ansi_term::ansi\")\n\n\n[gradient](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/gradient/index.html \"mod nu_ansi_term::gradient\")\n\n## Structs[\u00a7](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/#structs)\n\n[AnsiGenericString](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.AnsiGenericString.html \"struct nu_ansi_term::AnsiGenericString\")\n    An `AnsiGenericString` includes a generic string type and a `Style` to display that string. `AnsiString` and `AnsiByteString` are aliases for this type on `str` and `\\[u8]`, respectively.\n\n[AnsiGenericStrings](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.AnsiGenericStrings.html \"struct nu_ansi_term::AnsiGenericStrings\")\n    A set of `AnsiGenericStrings`s collected together, in order to be written with a minimum of control characters.\n\n[Rgb](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Rgb.html \"struct nu_ansi_term::Rgb\")\n\n\n[Style](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html \"struct nu_ansi_term::Style\")\n    A style is a collection of properties that can format a string using ANSI escape codes.\n## Enums[\u00a7](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/#enums)\n\n[Color](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/enum.Color.html \"enum nu_ansi_term::Color\")\n    A color is one specific type of ANSI escape code, and can refer to either the foreground or background color.\n## Functions[\u00a7](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/#functions)\n\n[AnsiByteStrings](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/fn.AnsiByteStrings.html \"fn nu_ansi_term::AnsiByteStrings\")\n    A function to construct an `AnsiByteStrings` instance.\n\n[AnsiStrings](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/fn.AnsiStrings.html \"fn nu_ansi_term::AnsiStrings\")\n    A function to construct an `AnsiStrings` instance.\n\n[sub_string](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/fn.sub_string.html \"fn nu_ansi_term::sub_string\")\n    Return a substring of the given AnsiStrings sequence, while keeping the formatting.\n\n[unstyle](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/fn.unstyle.html \"fn nu_ansi_term::unstyle\")\n    Return a concatenated copy of `strs` without the formatting, as an allocated `String`.\n\n[unstyled_len](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/fn.unstyled_len.html \"fn nu_ansi_term::unstyled_len\")\n    Return the unstyled length of AnsiStrings. This is equaivalent to `unstyle(strs).len()`.\n## Type Aliases[\u00a7](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/#types)\n\n[AnsiByteString](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/type.AnsiByteString.html \"type nu_ansi_term::AnsiByteString\")\n    An `AnsiByteString` represents a formatted series of bytes. Use `AnsiByteString` when styling text with an unknown encoding.\n\n[AnsiByteStrings](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/type.AnsiByteStrings.html \"type nu_ansi_term::AnsiByteStrings\")\n    A set of `AnsiByteString`s collected together, in order to be written with a minimum of control characters.\n\n[AnsiString](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/type.AnsiString.html \"type nu_ansi_term::AnsiString\")\n    An ANSI String is a string coupled with the `Style` to display it in a terminal.\n\n[AnsiStrings](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/type.AnsiStrings.html \"type nu_ansi_term::AnsiStrings\")\n    A set of `AnsiString`s collected together, in order to be written with a minimum of control characters.\n",
            "markdown_with_citations": "[](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/all.html \"show sidebar\")\n# Crate nu_ansi_termCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nThis is a library for controlling colors and formatting, such as red bold text or blue underlined text, on ANSI terminals.\n### \u00a7\u27e84\u27e9Basic usage\nThere are three main types in this crate that you need to be concerned with: `AnsiString`\u27e85\u27e9, `Style`\u27e86\u27e9, and `Color`\u27e87\u27e9.\nA `Style` holds stylistic information: foreground and background colors, whether the text should be bold, or blinking, or other properties. The `Color`\u27e87\u27e9 enum represents the available colors. And an `AnsiString`\u27e85\u27e9 is a string paired with a `Style`\u27e86\u27e9.\n`Color`\u27e87\u27e9 is also available as an alias to `Color`.\nTo format a string, call the `paint` method on a `Style` or a `Color`, passing in the string you want to format as the argument. For example, here\u2019s how to get some red text:\n```\nuse nu_ansi_term::Color::Red;\nprintln!(\"This is in red: {}\", Red.paint(\"a red string\"));\n```\n\nIt\u2019s important to note that the `paint` method does _not_ actually return a string with the ANSI control characters surrounding it. Instead, it returns an `AnsiString`\u27e85\u27e9 value that has a `Display`\u27e88\u27e9 implementation that, when formatted, returns the characters. This allows strings to be printed with a minimum of `String`\u27e89\u27e9 allocations being performed behind the scenes.\nIf you _do_ want to get at the escape codes, then you can convert the `AnsiString`\u27e85\u27e9 to a string as you would any other `Display` value:\n```\nuse nu_ansi_term::Color::Red;\nlet red_string = Red.paint(\"a red string\").to_string();\n```\n\n### \u00a7\u27e810\u27e9Bold, underline, background, and other styles\nFor anything more complex than plain foreground color changes, you need to construct `Style` values themselves, rather than beginning with a `Color`. You can do this by chaining methods based on a new `Style`, created with `Style::new()`\u27e811\u27e9. Each method creates a new style that has that specific property set. For example:\n```\nuse nu_ansi_term::Style;\nprintln!(\"How about some {} and {}?\",\n     Style::new().bold().paint(\"bold\"),\n     Style::new().underline().paint(\"underline\"));\n```\n\nFor brevity, these methods have also been implemented for `Color` values, so you can give your styles a foreground color without having to begin with an empty `Style` value:\n```\nuse nu_ansi_term::Color::{Blue, Yellow};\nprintln!(\"Demonstrating {} and {}!\",\n     Blue.bold().paint(\"blue bold\"),\n     Yellow.underline().paint(\"yellow underline\"));\nprintln!(\"Yellow on blue: {}\", Yellow.on(Blue).paint(\"wow!\"));\n```\n\nThe complete list of styles you can use are: `bold`\u27e812\u27e9, `dimmed`\u27e813\u27e9, `italic`\u27e814\u27e9, `underline`\u27e815\u27e9, `blink`\u27e816\u27e9, `reverse`\u27e817\u27e9, `hidden`\u27e818\u27e9, `strikethrough`\u27e819\u27e9, and `on`\u27e820\u27e9 for background colors.\nIn some cases, you may find it easier to change the foreground on an existing `Style` rather than starting from the appropriate `Color`. You can do this using the `fg`\u27e821\u27e9 method:\n```\nuse nu_ansi_term::Style;\nuse nu_ansi_term::Color::{Blue, Cyan, Yellow};\nprintln!(\"Yellow on blue: {}\", Style::new().on(Blue).fg(Yellow).paint(\"yow!\"));\nprintln!(\"Also yellow on blue: {}\", Cyan.on(Blue).fg(Yellow).paint(\"zow!\"));\n```\n\nYou can turn a `Color` into a `Style` with the `normal`\u27e822\u27e9 method. This will produce the exact same `AnsiString` as if you just used the `paint` method on the `Color` directly, but it\u2019s useful in certain cases: for example, you may have a method that returns `Styles`, and need to represent both the \u201cred bold\u201d and \u201cred, but not bold\u201d styles with values of the same type. The `Style` struct also has a `Default`\u27e823\u27e9 implementation if you want to have a style with _nothing_ set.\n```\nuse nu_ansi_term::Style;\nuse nu_ansi_term::Color::Red;\nRed.normal().paint(\"yet another red string\");\nStyle::default().paint(\"a completely regular string\");\n```\n\n### \u00a7\u27e824\u27e9Extended colors\nYou can access the extended range of 256 colors by using the `Color::Fixed` variant, which takes an argument of the color number to use. This can be included wherever you would use a `Color`:\n```\nuse nu_ansi_term::Color::Fixed;\nFixed(134).paint(\"A sort of light purple\");\nFixed(221).on(Fixed(124)).paint(\"Mustard in the ketchup\");\n```\n\nThe first sixteen of these values are the same as the normal and bold standard color variants. There\u2019s nothing stopping you from using these as `Fixed` colors instead, but there\u2019s nothing to be gained by doing so either.\nYou can also access full 24-bit color by using the `Color::Rgb` variant, which takes separate `u8` arguments for red, green, and blue:\n```\nuse nu_ansi_term::Color::Rgb;\nRgb(70, 130, 180).paint(\"Steel blue\");\n```\n\n### \u00a7\u27e825\u27e9Combining successive colored strings\nThe benefit of writing ANSI escape codes to the terminal is that they _stack_ : you do not need to end every colored string with a reset code if the text that follows it is of a similar style. For example, if you want to have some blue text followed by some blue bold text, it\u2019s possible to send the ANSI code for blue, followed by the ANSI code for bold, and finishing with a reset code without having to have an extra one between the two strings.\nThis crate can optimise the ANSI codes that get printed in situations like this, making life easier for your terminal renderer. The `AnsiStrings`\u27e826\u27e9 type takes a slice of several `AnsiString`\u27e85\u27e9 values, and will iterate over each of them, printing only the codes for the styles that need to be updated as part of its formatting routine.\nThe following code snippet uses this to enclose a binary number displayed in red bold text inside some red, but not bold, brackets:\n```\nuse nu_ansi_term::Color::Red;\nuse nu_ansi_term::{AnsiString, AnsiStrings};\nlet some_value = format!(\"{:b}\", 42);\nlet strings: &[AnsiString<'static>] = &[\n  Red.paint(\"[\"),\n  Red.bold().paint(some_value),\n  Red.paint(\"]\"),\n];\nprintln!(\"Value: {}\", AnsiStrings(strings));\n```\n\nThere are several things to note here. Firstly, the `paint`\u27e827\u27e9 method can take _either_ an owned `String`\u27e89\u27e9 or a borrowed `&str`\u27e828\u27e9. Internally, an `AnsiString`\u27e85\u27e9 holds a copy-on-write (`Cow`\u27e829\u27e9) string value to deal with both owned and borrowed strings at the same time. This is used here to display a `String`, the result of the `format!` call, using the same mechanism as some statically-available `&str` slices. Secondly, that the `AnsiStrings`\u27e826\u27e9 value works in the same way as its singular counterpart, with a `Display`\u27e88\u27e9 implementation that only performs the formatting when required.\n### \u00a7\u27e830\u27e9Byte strings\nThis library also supports formatting `\\[u8]` byte strings; this supports applications working with text in an unknown encoding. `Style`\u27e86\u27e9 and `Color`\u27e87\u27e9 support painting `\\[u8]` values, resulting in an `AnsiByteString`\u27e831\u27e9. This type does not implement `Display`\u27e88\u27e9, as it may not contain UTF-8, but it does provide a method `write_to`\u27e827\u27e9 to write the result to any value that implements `Write`\u27e832\u27e9:\n```\nuse nu_ansi_term::Color::Green;\nGreen.paint(\"user data\".as_bytes()).write_to(&mut std::io::stdout()).unwrap();\n```\n\nSimilarly, the type `AnsiByteStrings`\u27e833\u27e9 supports writing a list of `AnsiByteString`\u27e831\u27e9 values with minimal escape sequences:\n```\nuse nu_ansi_term::Color::Green;\nuse nu_ansi_term::AnsiByteStrings;\nAnsiByteStrings(&[\n  Green.paint(\"user data 1\\n\".as_bytes()),\n  Green.bold().paint(\"user data 2\\n\".as_bytes()),\n]).write_to(&mut std::io::stdout()).unwrap();\n```\n\n## Re-exports\u00a7\u27e834\u27e9\n\n`pub use ansi::Infix[](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/ansi/struct.Infix.html \"struct nu_ansi_term::ansi::Infix\");`\n\n\n`pub use ansi::Prefix[](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/ansi/struct.Prefix.html \"struct nu_ansi_term::ansi::Prefix\");`\n\n\n`pub use ansi::Suffix[](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/ansi/struct.Suffix.html \"struct nu_ansi_term::ansi::Suffix\");`\n\n\n`pub use gradient[](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/gradient/index.html \"mod nu_ansi_term::gradient\")::*;`\n\n## Modules\u00a7\u27e835\u27e9\n\nansi\u27e836\u27e9\n\n\ngradient\u27e837\u27e9\n\n## Structs\u00a7\u27e838\u27e9\n\nAnsiGenericString\u27e839\u27e9\n    An `AnsiGenericString` includes a generic string type and a `Style` to display that string. `AnsiString` and `AnsiByteString` are aliases for this type on `str` and `\\[u8]`, respectively.\n\nAnsiGenericStrings\u27e840\u27e9\n    A set of `AnsiGenericStrings`s collected together, in order to be written with a minimum of control characters.\n\nRgb\u27e841\u27e9\n\n\nStyle\u27e86\u27e9\n    A style is a collection of properties that can format a string using ANSI escape codes.\n## Enums\u00a7\u27e842\u27e9\n\nColor\u27e87\u27e9\n    A color is one specific type of ANSI escape code, and can refer to either the foreground or background color.\n## Functions\u00a7\u27e843\u27e9\n\nAnsiByteStrings\u27e844\u27e9\n    A function to construct an `AnsiByteStrings` instance.\n\nAnsiStrings\u27e845\u27e9\n    A function to construct an `AnsiStrings` instance.\n\nsub_string\u27e846\u27e9\n    Return a substring of the given AnsiStrings sequence, while keeping the formatting.\n\nunstyle\u27e847\u27e9\n    Return a concatenated copy of `strs` without the formatting, as an allocated `String`.\n\nunstyled_len\u27e848\u27e9\n    Return the unstyled length of AnsiStrings. This is equaivalent to `unstyle(strs).len()`.\n## Type Aliases\u00a7\u27e849\u27e9\n\nAnsiByteString\u27e831\u27e9\n    An `AnsiByteString` represents a formatted series of bytes. Use `AnsiByteString` when styling text with an unknown encoding.\n\nAnsiByteStrings\u27e833\u27e9\n    A set of `AnsiByteString`s collected together, in order to be written with a minimum of control characters.\n\nAnsiString\u27e85\u27e9\n    An ANSI String is a string coupled with the `Style` to display it in a terminal.\n\nAnsiStrings\u27e826\u27e9\n    A set of `AnsiString`s collected together, in order to be written with a minimum of control characters.\n",
            "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/nu-ansi-term/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/nu-ansi-term/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/nu-ansi-term/latest/src/nu_ansi_term/lib.rs.html#1-267: Source\n\u27e84\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/#basic-usage: \u00a7\n\u27e85\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/type.AnsiString.html: `AnsiString`\n\u27e86\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html: `Style`\n\u27e87\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/enum.Color.html: `Color`\n\u27e88\u27e9 https://doc.rust-lang.org/std/fmt/trait.Display.html: `Display`\n\u27e89\u27e9 https://doc.rust-lang.org/std/string/struct.String.html: `String`\n\u27e810\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/#bold-underline-background-and-other-styles: \u00a7\n\u27e811\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html#method.new: `Style::new()`\n\u27e812\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html#method.bold: `bold`\n\u27e813\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html#method.dimmed: `dimmed`\n\u27e814\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html#method.italic: `italic`\n\u27e815\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html#method.underline: `underline`\n\u27e816\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html#method.blink: `blink`\n\u27e817\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html#method.reverse: `reverse`\n\u27e818\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html#method.hidden: `hidden`\n\u27e819\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html#method.strikethrough: `strikethrough`\n\u27e820\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html#method.on: `on`\n\u27e821\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html#method.fg: `fg`\n\u27e822\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/enum.Color.html#method.normal: `normal`\n\u27e823\u27e9 https://doc.rust-lang.org/std/default/trait.Default.html: `Default`\n\u27e824\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/#extended-colors: \u00a7\n\u27e825\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/#combining-successive-colored-strings: \u00a7\n\u27e826\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/type.AnsiStrings.html: `AnsiStrings`\n\u27e827\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/type.AnsiByteString.html#method.write_to: `paint`\n\u27e828\u27e9 https://doc.rust-lang.org/std/primitive.str.html: `&str`\n\u27e829\u27e9 https://doc.rust-lang.org/std/borrow/enum.Cow.html: `Cow`\n\u27e830\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/#byte-strings: \u00a7\n\u27e831\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/type.AnsiByteString.html: `AnsiByteString`\n\u27e832\u27e9 https://doc.rust-lang.org/std/io/trait.Write.html: `Write`\n\u27e833\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/type.AnsiByteStrings.html: `AnsiByteStrings`\n\u27e834\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/#reexports: \u00a7\n\u27e835\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/#modules: \u00a7\n\u27e836\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/ansi/index.html: mod nu_ansi_term::ansi - ansi\n\u27e837\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/gradient/index.html: mod nu_ansi_term::gradient - gradient\n\u27e838\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/#structs: \u00a7\n\u27e839\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.AnsiGenericString.html: struct nu_ansi_term::AnsiGenericString - AnsiGenericString\n\u27e840\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.AnsiGenericStrings.html: struct nu_ansi_term::AnsiGenericStrings - AnsiGenericStrings\n\u27e841\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Rgb.html: struct nu_ansi_term::Rgb - Rgb\n\u27e842\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/#enums: \u00a7\n\u27e843\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/#functions: \u00a7\n\u27e844\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/fn.AnsiByteStrings.html: fn nu_ansi_term::AnsiByteStrings - AnsiByteStrings\n\u27e845\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/fn.AnsiStrings.html: fn nu_ansi_term::AnsiStrings - AnsiStrings\n\u27e846\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/fn.sub_string.html: fn nu_ansi_term::sub_string - sub_string\n\u27e847\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/fn.unstyle.html: fn nu_ansi_term::unstyle - unstyle\n\u27e848\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/fn.unstyled_len.html: fn nu_ansi_term::unstyled_len - unstyled_len\n\u27e849\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/#types: \u00a7\n",
            "fit_markdown": "",
            "fit_html": ""
          },
          "downloads": 0,
          "github_stars": 0,
          "dependencies": [],
          "features": {},
          "code_snippets": [],
          "readme_sections": {},
          "librs_downloads": null,
          "source": "crates.io",
          "enhanced_scraping": {},
          "enhanced_features": [],
          "enhanced_dependencies": []
        },
        "enriched_crate": {
          "name": "nu-ansi-term",
          "version": "0.50.1",
          "description": "ALLOW: Positive community sentiment",
          "repository": "",
          "keywords": [],
          "categories": [],
          "readme": {
            "raw_markdown": "[](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/all.html \"show sidebar\")\n# Crate nu_ansi_termCopy item path\n[Settings](https://docs.rs/nu-ansi-term/latest/settings.html)\n[Help](https://docs.rs/nu-ansi-term/latest/help.html)\nSummary[Source](https://docs.rs/nu-ansi-term/latest/src/nu_ansi_term/lib.rs.html#1-267)\nExpand description\nThis is a library for controlling colors and formatting, such as red bold text or blue underlined text, on ANSI terminals.\n### [\u00a7](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/#basic-usage)Basic usage\nThere are three main types in this crate that you need to be concerned with: [`AnsiString`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/type.AnsiString.html), [`Style`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html), and [`Color`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/enum.Color.html).\nA `Style` holds stylistic information: foreground and background colors, whether the text should be bold, or blinking, or other properties. The [`Color`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/enum.Color.html) enum represents the available colors. And an [`AnsiString`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/type.AnsiString.html) is a string paired with a [`Style`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html).\n[`Color`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/enum.Color.html) is also available as an alias to `Color`.\nTo format a string, call the `paint` method on a `Style` or a `Color`, passing in the string you want to format as the argument. For example, here\u2019s how to get some red text:\n```\nuse nu_ansi_term::Color::Red;\nprintln!(\"This is in red: {}\", Red.paint(\"a red string\"));\n```\n\nIt\u2019s important to note that the `paint` method does _not_ actually return a string with the ANSI control characters surrounding it. Instead, it returns an [`AnsiString`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/type.AnsiString.html) value that has a [`Display`](https://doc.rust-lang.org/std/fmt/trait.Display.html) implementation that, when formatted, returns the characters. This allows strings to be printed with a minimum of [`String`](https://doc.rust-lang.org/std/string/struct.String.html) allocations being performed behind the scenes.\nIf you _do_ want to get at the escape codes, then you can convert the [`AnsiString`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/type.AnsiString.html) to a string as you would any other `Display` value:\n```\nuse nu_ansi_term::Color::Red;\nlet red_string = Red.paint(\"a red string\").to_string();\n```\n\n### [\u00a7](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/#bold-underline-background-and-other-styles)Bold, underline, background, and other styles\nFor anything more complex than plain foreground color changes, you need to construct `Style` values themselves, rather than beginning with a `Color`. You can do this by chaining methods based on a new `Style`, created with [`Style::new()`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html#method.new). Each method creates a new style that has that specific property set. For example:\n```\nuse nu_ansi_term::Style;\nprintln!(\"How about some {} and {}?\",\n     Style::new().bold().paint(\"bold\"),\n     Style::new().underline().paint(\"underline\"));\n```\n\nFor brevity, these methods have also been implemented for `Color` values, so you can give your styles a foreground color without having to begin with an empty `Style` value:\n```\nuse nu_ansi_term::Color::{Blue, Yellow};\nprintln!(\"Demonstrating {} and {}!\",\n     Blue.bold().paint(\"blue bold\"),\n     Yellow.underline().paint(\"yellow underline\"));\nprintln!(\"Yellow on blue: {}\", Yellow.on(Blue).paint(\"wow!\"));\n```\n\nThe complete list of styles you can use are: [`bold`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html#method.bold), [`dimmed`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html#method.dimmed), [`italic`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html#method.italic), [`underline`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html#method.underline), [`blink`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html#method.blink), [`reverse`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html#method.reverse), [`hidden`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html#method.hidden), [`strikethrough`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html#method.strikethrough), and [`on`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html#method.on) for background colors.\nIn some cases, you may find it easier to change the foreground on an existing `Style` rather than starting from the appropriate `Color`. You can do this using the [`fg`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html#method.fg) method:\n```\nuse nu_ansi_term::Style;\nuse nu_ansi_term::Color::{Blue, Cyan, Yellow};\nprintln!(\"Yellow on blue: {}\", Style::new().on(Blue).fg(Yellow).paint(\"yow!\"));\nprintln!(\"Also yellow on blue: {}\", Cyan.on(Blue).fg(Yellow).paint(\"zow!\"));\n```\n\nYou can turn a `Color` into a `Style` with the [`normal`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/enum.Color.html#method.normal) method. This will produce the exact same `AnsiString` as if you just used the `paint` method on the `Color` directly, but it\u2019s useful in certain cases: for example, you may have a method that returns `Styles`, and need to represent both the \u201cred bold\u201d and \u201cred, but not bold\u201d styles with values of the same type. The `Style` struct also has a [`Default`](https://doc.rust-lang.org/std/default/trait.Default.html) implementation if you want to have a style with _nothing_ set.\n```\nuse nu_ansi_term::Style;\nuse nu_ansi_term::Color::Red;\nRed.normal().paint(\"yet another red string\");\nStyle::default().paint(\"a completely regular string\");\n```\n\n### [\u00a7](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/#extended-colors)Extended colors\nYou can access the extended range of 256 colors by using the `Color::Fixed` variant, which takes an argument of the color number to use. This can be included wherever you would use a `Color`:\n```\nuse nu_ansi_term::Color::Fixed;\nFixed(134).paint(\"A sort of light purple\");\nFixed(221).on(Fixed(124)).paint(\"Mustard in the ketchup\");\n```\n\nThe first sixteen of these values are the same as the normal and bold standard color variants. There\u2019s nothing stopping you from using these as `Fixed` colors instead, but there\u2019s nothing to be gained by doing so either.\nYou can also access full 24-bit color by using the `Color::Rgb` variant, which takes separate `u8` arguments for red, green, and blue:\n```\nuse nu_ansi_term::Color::Rgb;\nRgb(70, 130, 180).paint(\"Steel blue\");\n```\n\n### [\u00a7](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/#combining-successive-colored-strings)Combining successive colored strings\nThe benefit of writing ANSI escape codes to the terminal is that they _stack_ : you do not need to end every colored string with a reset code if the text that follows it is of a similar style. For example, if you want to have some blue text followed by some blue bold text, it\u2019s possible to send the ANSI code for blue, followed by the ANSI code for bold, and finishing with a reset code without having to have an extra one between the two strings.\nThis crate can optimise the ANSI codes that get printed in situations like this, making life easier for your terminal renderer. The [`AnsiStrings`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/type.AnsiStrings.html) type takes a slice of several [`AnsiString`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/type.AnsiString.html) values, and will iterate over each of them, printing only the codes for the styles that need to be updated as part of its formatting routine.\nThe following code snippet uses this to enclose a binary number displayed in red bold text inside some red, but not bold, brackets:\n```\nuse nu_ansi_term::Color::Red;\nuse nu_ansi_term::{AnsiString, AnsiStrings};\nlet some_value = format!(\"{:b}\", 42);\nlet strings: &[AnsiString<'static>] = &[\n  Red.paint(\"[\"),\n  Red.bold().paint(some_value),\n  Red.paint(\"]\"),\n];\nprintln!(\"Value: {}\", AnsiStrings(strings));\n```\n\nThere are several things to note here. Firstly, the [`paint`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/type.AnsiByteString.html#method.write_to) method can take _either_ an owned [`String`](https://doc.rust-lang.org/std/string/struct.String.html) or a borrowed [`&str`](https://doc.rust-lang.org/std/primitive.str.html). Internally, an [`AnsiString`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/type.AnsiString.html) holds a copy-on-write ([`Cow`](https://doc.rust-lang.org/std/borrow/enum.Cow.html)) string value to deal with both owned and borrowed strings at the same time. This is used here to display a `String`, the result of the `format!` call, using the same mechanism as some statically-available `&str` slices. Secondly, that the [`AnsiStrings`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/type.AnsiStrings.html) value works in the same way as its singular counterpart, with a [`Display`](https://doc.rust-lang.org/std/fmt/trait.Display.html) implementation that only performs the formatting when required.\n### [\u00a7](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/#byte-strings)Byte strings\nThis library also supports formatting `\\[u8]` byte strings; this supports applications working with text in an unknown encoding. [`Style`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html) and [`Color`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/enum.Color.html) support painting `\\[u8]` values, resulting in an [`AnsiByteString`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/type.AnsiByteString.html). This type does not implement [`Display`](https://doc.rust-lang.org/std/fmt/trait.Display.html), as it may not contain UTF-8, but it does provide a method [`write_to`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/type.AnsiByteString.html#method.write_to) to write the result to any value that implements [`Write`](https://doc.rust-lang.org/std/io/trait.Write.html):\n```\nuse nu_ansi_term::Color::Green;\nGreen.paint(\"user data\".as_bytes()).write_to(&mut std::io::stdout()).unwrap();\n```\n\nSimilarly, the type [`AnsiByteStrings`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/type.AnsiByteStrings.html) supports writing a list of [`AnsiByteString`](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/type.AnsiByteString.html) values with minimal escape sequences:\n```\nuse nu_ansi_term::Color::Green;\nuse nu_ansi_term::AnsiByteStrings;\nAnsiByteStrings(&[\n  Green.paint(\"user data 1\\n\".as_bytes()),\n  Green.bold().paint(\"user data 2\\n\".as_bytes()),\n]).write_to(&mut std::io::stdout()).unwrap();\n```\n\n## Re-exports[\u00a7](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/#reexports)\n\n`pub use ansi::Infix[](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/ansi/struct.Infix.html \"struct nu_ansi_term::ansi::Infix\");`\n\n\n`pub use ansi::Prefix[](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/ansi/struct.Prefix.html \"struct nu_ansi_term::ansi::Prefix\");`\n\n\n`pub use ansi::Suffix[](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/ansi/struct.Suffix.html \"struct nu_ansi_term::ansi::Suffix\");`\n\n\n`pub use gradient[](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/gradient/index.html \"mod nu_ansi_term::gradient\")::*;`\n\n## Modules[\u00a7](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/#modules)\n\n[ansi](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/ansi/index.html \"mod nu_ansi_term::ansi\")\n\n\n[gradient](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/gradient/index.html \"mod nu_ansi_term::gradient\")\n\n## Structs[\u00a7](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/#structs)\n\n[AnsiGenericString](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.AnsiGenericString.html \"struct nu_ansi_term::AnsiGenericString\")\n    An `AnsiGenericString` includes a generic string type and a `Style` to display that string. `AnsiString` and `AnsiByteString` are aliases for this type on `str` and `\\[u8]`, respectively.\n\n[AnsiGenericStrings](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.AnsiGenericStrings.html \"struct nu_ansi_term::AnsiGenericStrings\")\n    A set of `AnsiGenericStrings`s collected together, in order to be written with a minimum of control characters.\n\n[Rgb](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Rgb.html \"struct nu_ansi_term::Rgb\")\n\n\n[Style](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html \"struct nu_ansi_term::Style\")\n    A style is a collection of properties that can format a string using ANSI escape codes.\n## Enums[\u00a7](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/#enums)\n\n[Color](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/enum.Color.html \"enum nu_ansi_term::Color\")\n    A color is one specific type of ANSI escape code, and can refer to either the foreground or background color.\n## Functions[\u00a7](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/#functions)\n\n[AnsiByteStrings](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/fn.AnsiByteStrings.html \"fn nu_ansi_term::AnsiByteStrings\")\n    A function to construct an `AnsiByteStrings` instance.\n\n[AnsiStrings](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/fn.AnsiStrings.html \"fn nu_ansi_term::AnsiStrings\")\n    A function to construct an `AnsiStrings` instance.\n\n[sub_string](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/fn.sub_string.html \"fn nu_ansi_term::sub_string\")\n    Return a substring of the given AnsiStrings sequence, while keeping the formatting.\n\n[unstyle](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/fn.unstyle.html \"fn nu_ansi_term::unstyle\")\n    Return a concatenated copy of `strs` without the formatting, as an allocated `String`.\n\n[unstyled_len](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/fn.unstyled_len.html \"fn nu_ansi_term::unstyled_len\")\n    Return the unstyled length of AnsiStrings. This is equaivalent to `unstyle(strs).len()`.\n## Type Aliases[\u00a7](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/#types)\n\n[AnsiByteString](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/type.AnsiByteString.html \"type nu_ansi_term::AnsiByteString\")\n    An `AnsiByteString` represents a formatted series of bytes. Use `AnsiByteString` when styling text with an unknown encoding.\n\n[AnsiByteStrings](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/type.AnsiByteStrings.html \"type nu_ansi_term::AnsiByteStrings\")\n    A set of `AnsiByteString`s collected together, in order to be written with a minimum of control characters.\n\n[AnsiString](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/type.AnsiString.html \"type nu_ansi_term::AnsiString\")\n    An ANSI String is a string coupled with the `Style` to display it in a terminal.\n\n[AnsiStrings](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/type.AnsiStrings.html \"type nu_ansi_term::AnsiStrings\")\n    A set of `AnsiString`s collected together, in order to be written with a minimum of control characters.\n",
            "markdown_with_citations": "[](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/all.html \"show sidebar\")\n# Crate nu_ansi_termCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nThis is a library for controlling colors and formatting, such as red bold text or blue underlined text, on ANSI terminals.\n### \u00a7\u27e84\u27e9Basic usage\nThere are three main types in this crate that you need to be concerned with: `AnsiString`\u27e85\u27e9, `Style`\u27e86\u27e9, and `Color`\u27e87\u27e9.\nA `Style` holds stylistic information: foreground and background colors, whether the text should be bold, or blinking, or other properties. The `Color`\u27e87\u27e9 enum represents the available colors. And an `AnsiString`\u27e85\u27e9 is a string paired with a `Style`\u27e86\u27e9.\n`Color`\u27e87\u27e9 is also available as an alias to `Color`.\nTo format a string, call the `paint` method on a `Style` or a `Color`, passing in the string you want to format as the argument. For example, here\u2019s how to get some red text:\n```\nuse nu_ansi_term::Color::Red;\nprintln!(\"This is in red: {}\", Red.paint(\"a red string\"));\n```\n\nIt\u2019s important to note that the `paint` method does _not_ actually return a string with the ANSI control characters surrounding it. Instead, it returns an `AnsiString`\u27e85\u27e9 value that has a `Display`\u27e88\u27e9 implementation that, when formatted, returns the characters. This allows strings to be printed with a minimum of `String`\u27e89\u27e9 allocations being performed behind the scenes.\nIf you _do_ want to get at the escape codes, then you can convert the `AnsiString`\u27e85\u27e9 to a string as you would any other `Display` value:\n```\nuse nu_ansi_term::Color::Red;\nlet red_string = Red.paint(\"a red string\").to_string();\n```\n\n### \u00a7\u27e810\u27e9Bold, underline, background, and other styles\nFor anything more complex than plain foreground color changes, you need to construct `Style` values themselves, rather than beginning with a `Color`. You can do this by chaining methods based on a new `Style`, created with `Style::new()`\u27e811\u27e9. Each method creates a new style that has that specific property set. For example:\n```\nuse nu_ansi_term::Style;\nprintln!(\"How about some {} and {}?\",\n     Style::new().bold().paint(\"bold\"),\n     Style::new().underline().paint(\"underline\"));\n```\n\nFor brevity, these methods have also been implemented for `Color` values, so you can give your styles a foreground color without having to begin with an empty `Style` value:\n```\nuse nu_ansi_term::Color::{Blue, Yellow};\nprintln!(\"Demonstrating {} and {}!\",\n     Blue.bold().paint(\"blue bold\"),\n     Yellow.underline().paint(\"yellow underline\"));\nprintln!(\"Yellow on blue: {}\", Yellow.on(Blue).paint(\"wow!\"));\n```\n\nThe complete list of styles you can use are: `bold`\u27e812\u27e9, `dimmed`\u27e813\u27e9, `italic`\u27e814\u27e9, `underline`\u27e815\u27e9, `blink`\u27e816\u27e9, `reverse`\u27e817\u27e9, `hidden`\u27e818\u27e9, `strikethrough`\u27e819\u27e9, and `on`\u27e820\u27e9 for background colors.\nIn some cases, you may find it easier to change the foreground on an existing `Style` rather than starting from the appropriate `Color`. You can do this using the `fg`\u27e821\u27e9 method:\n```\nuse nu_ansi_term::Style;\nuse nu_ansi_term::Color::{Blue, Cyan, Yellow};\nprintln!(\"Yellow on blue: {}\", Style::new().on(Blue).fg(Yellow).paint(\"yow!\"));\nprintln!(\"Also yellow on blue: {}\", Cyan.on(Blue).fg(Yellow).paint(\"zow!\"));\n```\n\nYou can turn a `Color` into a `Style` with the `normal`\u27e822\u27e9 method. This will produce the exact same `AnsiString` as if you just used the `paint` method on the `Color` directly, but it\u2019s useful in certain cases: for example, you may have a method that returns `Styles`, and need to represent both the \u201cred bold\u201d and \u201cred, but not bold\u201d styles with values of the same type. The `Style` struct also has a `Default`\u27e823\u27e9 implementation if you want to have a style with _nothing_ set.\n```\nuse nu_ansi_term::Style;\nuse nu_ansi_term::Color::Red;\nRed.normal().paint(\"yet another red string\");\nStyle::default().paint(\"a completely regular string\");\n```\n\n### \u00a7\u27e824\u27e9Extended colors\nYou can access the extended range of 256 colors by using the `Color::Fixed` variant, which takes an argument of the color number to use. This can be included wherever you would use a `Color`:\n```\nuse nu_ansi_term::Color::Fixed;\nFixed(134).paint(\"A sort of light purple\");\nFixed(221).on(Fixed(124)).paint(\"Mustard in the ketchup\");\n```\n\nThe first sixteen of these values are the same as the normal and bold standard color variants. There\u2019s nothing stopping you from using these as `Fixed` colors instead, but there\u2019s nothing to be gained by doing so either.\nYou can also access full 24-bit color by using the `Color::Rgb` variant, which takes separate `u8` arguments for red, green, and blue:\n```\nuse nu_ansi_term::Color::Rgb;\nRgb(70, 130, 180).paint(\"Steel blue\");\n```\n\n### \u00a7\u27e825\u27e9Combining successive colored strings\nThe benefit of writing ANSI escape codes to the terminal is that they _stack_ : you do not need to end every colored string with a reset code if the text that follows it is of a similar style. For example, if you want to have some blue text followed by some blue bold text, it\u2019s possible to send the ANSI code for blue, followed by the ANSI code for bold, and finishing with a reset code without having to have an extra one between the two strings.\nThis crate can optimise the ANSI codes that get printed in situations like this, making life easier for your terminal renderer. The `AnsiStrings`\u27e826\u27e9 type takes a slice of several `AnsiString`\u27e85\u27e9 values, and will iterate over each of them, printing only the codes for the styles that need to be updated as part of its formatting routine.\nThe following code snippet uses this to enclose a binary number displayed in red bold text inside some red, but not bold, brackets:\n```\nuse nu_ansi_term::Color::Red;\nuse nu_ansi_term::{AnsiString, AnsiStrings};\nlet some_value = format!(\"{:b}\", 42);\nlet strings: &[AnsiString<'static>] = &[\n  Red.paint(\"[\"),\n  Red.bold().paint(some_value),\n  Red.paint(\"]\"),\n];\nprintln!(\"Value: {}\", AnsiStrings(strings));\n```\n\nThere are several things to note here. Firstly, the `paint`\u27e827\u27e9 method can take _either_ an owned `String`\u27e89\u27e9 or a borrowed `&str`\u27e828\u27e9. Internally, an `AnsiString`\u27e85\u27e9 holds a copy-on-write (`Cow`\u27e829\u27e9) string value to deal with both owned and borrowed strings at the same time. This is used here to display a `String`, the result of the `format!` call, using the same mechanism as some statically-available `&str` slices. Secondly, that the `AnsiStrings`\u27e826\u27e9 value works in the same way as its singular counterpart, with a `Display`\u27e88\u27e9 implementation that only performs the formatting when required.\n### \u00a7\u27e830\u27e9Byte strings\nThis library also supports formatting `\\[u8]` byte strings; this supports applications working with text in an unknown encoding. `Style`\u27e86\u27e9 and `Color`\u27e87\u27e9 support painting `\\[u8]` values, resulting in an `AnsiByteString`\u27e831\u27e9. This type does not implement `Display`\u27e88\u27e9, as it may not contain UTF-8, but it does provide a method `write_to`\u27e827\u27e9 to write the result to any value that implements `Write`\u27e832\u27e9:\n```\nuse nu_ansi_term::Color::Green;\nGreen.paint(\"user data\".as_bytes()).write_to(&mut std::io::stdout()).unwrap();\n```\n\nSimilarly, the type `AnsiByteStrings`\u27e833\u27e9 supports writing a list of `AnsiByteString`\u27e831\u27e9 values with minimal escape sequences:\n```\nuse nu_ansi_term::Color::Green;\nuse nu_ansi_term::AnsiByteStrings;\nAnsiByteStrings(&[\n  Green.paint(\"user data 1\\n\".as_bytes()),\n  Green.bold().paint(\"user data 2\\n\".as_bytes()),\n]).write_to(&mut std::io::stdout()).unwrap();\n```\n\n## Re-exports\u00a7\u27e834\u27e9\n\n`pub use ansi::Infix[](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/ansi/struct.Infix.html \"struct nu_ansi_term::ansi::Infix\");`\n\n\n`pub use ansi::Prefix[](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/ansi/struct.Prefix.html \"struct nu_ansi_term::ansi::Prefix\");`\n\n\n`pub use ansi::Suffix[](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/ansi/struct.Suffix.html \"struct nu_ansi_term::ansi::Suffix\");`\n\n\n`pub use gradient[](https://docs.rs/nu-ansi-term/latest/nu_ansi_term/gradient/index.html \"mod nu_ansi_term::gradient\")::*;`\n\n## Modules\u00a7\u27e835\u27e9\n\nansi\u27e836\u27e9\n\n\ngradient\u27e837\u27e9\n\n## Structs\u00a7\u27e838\u27e9\n\nAnsiGenericString\u27e839\u27e9\n    An `AnsiGenericString` includes a generic string type and a `Style` to display that string. `AnsiString` and `AnsiByteString` are aliases for this type on `str` and `\\[u8]`, respectively.\n\nAnsiGenericStrings\u27e840\u27e9\n    A set of `AnsiGenericStrings`s collected together, in order to be written with a minimum of control characters.\n\nRgb\u27e841\u27e9\n\n\nStyle\u27e86\u27e9\n    A style is a collection of properties that can format a string using ANSI escape codes.\n## Enums\u00a7\u27e842\u27e9\n\nColor\u27e87\u27e9\n    A color is one specific type of ANSI escape code, and can refer to either the foreground or background color.\n## Functions\u00a7\u27e843\u27e9\n\nAnsiByteStrings\u27e844\u27e9\n    A function to construct an `AnsiByteStrings` instance.\n\nAnsiStrings\u27e845\u27e9\n    A function to construct an `AnsiStrings` instance.\n\nsub_string\u27e846\u27e9\n    Return a substring of the given AnsiStrings sequence, while keeping the formatting.\n\nunstyle\u27e847\u27e9\n    Return a concatenated copy of `strs` without the formatting, as an allocated `String`.\n\nunstyled_len\u27e848\u27e9\n    Return the unstyled length of AnsiStrings. This is equaivalent to `unstyle(strs).len()`.\n## Type Aliases\u00a7\u27e849\u27e9\n\nAnsiByteString\u27e831\u27e9\n    An `AnsiByteString` represents a formatted series of bytes. Use `AnsiByteString` when styling text with an unknown encoding.\n\nAnsiByteStrings\u27e833\u27e9\n    A set of `AnsiByteString`s collected together, in order to be written with a minimum of control characters.\n\nAnsiString\u27e85\u27e9\n    An ANSI String is a string coupled with the `Style` to display it in a terminal.\n\nAnsiStrings\u27e826\u27e9\n    A set of `AnsiString`s collected together, in order to be written with a minimum of control characters.\n",
            "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/nu-ansi-term/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/nu-ansi-term/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/nu-ansi-term/latest/src/nu_ansi_term/lib.rs.html#1-267: Source\n\u27e84\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/#basic-usage: \u00a7\n\u27e85\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/type.AnsiString.html: `AnsiString`\n\u27e86\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html: `Style`\n\u27e87\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/enum.Color.html: `Color`\n\u27e88\u27e9 https://doc.rust-lang.org/std/fmt/trait.Display.html: `Display`\n\u27e89\u27e9 https://doc.rust-lang.org/std/string/struct.String.html: `String`\n\u27e810\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/#bold-underline-background-and-other-styles: \u00a7\n\u27e811\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html#method.new: `Style::new()`\n\u27e812\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html#method.bold: `bold`\n\u27e813\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html#method.dimmed: `dimmed`\n\u27e814\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html#method.italic: `italic`\n\u27e815\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html#method.underline: `underline`\n\u27e816\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html#method.blink: `blink`\n\u27e817\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html#method.reverse: `reverse`\n\u27e818\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html#method.hidden: `hidden`\n\u27e819\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html#method.strikethrough: `strikethrough`\n\u27e820\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html#method.on: `on`\n\u27e821\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Style.html#method.fg: `fg`\n\u27e822\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/enum.Color.html#method.normal: `normal`\n\u27e823\u27e9 https://doc.rust-lang.org/std/default/trait.Default.html: `Default`\n\u27e824\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/#extended-colors: \u00a7\n\u27e825\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/#combining-successive-colored-strings: \u00a7\n\u27e826\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/type.AnsiStrings.html: `AnsiStrings`\n\u27e827\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/type.AnsiByteString.html#method.write_to: `paint`\n\u27e828\u27e9 https://doc.rust-lang.org/std/primitive.str.html: `&str`\n\u27e829\u27e9 https://doc.rust-lang.org/std/borrow/enum.Cow.html: `Cow`\n\u27e830\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/#byte-strings: \u00a7\n\u27e831\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/type.AnsiByteString.html: `AnsiByteString`\n\u27e832\u27e9 https://doc.rust-lang.org/std/io/trait.Write.html: `Write`\n\u27e833\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/type.AnsiByteStrings.html: `AnsiByteStrings`\n\u27e834\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/#reexports: \u00a7\n\u27e835\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/#modules: \u00a7\n\u27e836\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/ansi/index.html: mod nu_ansi_term::ansi - ansi\n\u27e837\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/gradient/index.html: mod nu_ansi_term::gradient - gradient\n\u27e838\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/#structs: \u00a7\n\u27e839\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.AnsiGenericString.html: struct nu_ansi_term::AnsiGenericString - AnsiGenericString\n\u27e840\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.AnsiGenericStrings.html: struct nu_ansi_term::AnsiGenericStrings - AnsiGenericStrings\n\u27e841\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/struct.Rgb.html: struct nu_ansi_term::Rgb - Rgb\n\u27e842\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/#enums: \u00a7\n\u27e843\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/#functions: \u00a7\n\u27e844\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/fn.AnsiByteStrings.html: fn nu_ansi_term::AnsiByteStrings - AnsiByteStrings\n\u27e845\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/fn.AnsiStrings.html: fn nu_ansi_term::AnsiStrings - AnsiStrings\n\u27e846\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/fn.sub_string.html: fn nu_ansi_term::sub_string - sub_string\n\u27e847\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/fn.unstyle.html: fn nu_ansi_term::unstyle - unstyle\n\u27e848\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/fn.unstyled_len.html: fn nu_ansi_term::unstyled_len - unstyled_len\n\u27e849\u27e9 https://docs.rs/nu-ansi-term/latest/nu_ansi_term/#types: \u00a7\n",
            "fit_markdown": "",
            "fit_html": ""
          },
          "downloads": 0,
          "github_stars": 0,
          "dependencies": [],
          "features": {},
          "code_snippets": [],
          "readme_sections": {},
          "librs_downloads": null,
          "source": "crates.io",
          "enhanced_scraping": {},
          "enhanced_features": [],
          "enhanced_dependencies": [],
          "readme_summary": "The `nu-ansi-term` crate provides utilities for styling and formatting text with ANSI escape codes in terminal applications. It supports foreground and background colors, extended 256-color and 24-bit RGB color ranges, and various text styles like bold, underline, italic, and strikethrough. It optimizes ANSI code generation and offers composable APIs via `Style`, `Color`, and `AnsiString` for efficient text rendering.",
          "feature_summary": null,
          "use_case": "Utilities",
          "score": 5.0,
          "factual_counterfactual": "### Pair 1: Basic Usage  \n\u2705 **Factual**: The `nu-ansi-term` crate provides the `paint` method for both `Style` and `Color`, allowing users to format strings with ANSI control characters. The method returns an `AnsiString` which implements the `Display` trait for efficient formatting.  \n\u274c **Counterfactual**: The `paint` method in `nu-ansi-term` directly returns a `String` containing the ANSI control characters, making it necessary to allocate memory for every formatting operation.  \n\n---\n\n### Pair 2: Style Construction  \n\u2705 **Factual**: The `Style` struct in `nu-ansi-term` can be constructed using `Style::new()` and modified by chaining methods like `.bold()`, `.underline()`, and `.on()` for background colors.  \n\u274c **Counterfactual**: The `Style` struct in `nu-ansi-term` must be initialized with a foreground color and cannot be created as an empty style using `Style::new()`.  \n\n---\n\n### Pair 3: Color and Style Interactions  \n\u2705 **Factual**: The `Color` enum in `nu-ansi-term` can be converted into a `Style` using the `.normal()` method, allowing users to represent both styled and unstyled colors uniformly.  \n\u274c **Counterfactual**: The `Color` enum in `nu-ansi-term` cannot be converted into a `Style`; users",
          "source_analysis": null,
          "user_behavior": null,
          "security": null
        }
      },
      "irl_score": 8.6,
      "execution_id": "exec-a83919e8-75e3b952-1751260398",
      "timestamp": "2025-06-30T05:13:18.162906+00:00",
      "canon_version": "1.3.0"
    },
    "rule_zero_compliant": true
  }
]