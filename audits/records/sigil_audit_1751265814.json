[
  {
    "execution_id": "exec-3aa3c439-cb51f9ec-1751265798",
    "timestamp": "2025-06-30T06:43:18.773851+00:00",
    "sacred_chain": {
      "input_data": "ultraviolet",
      "context_sources": [
        "crates.io",
        "github.com",
        "lib.rs",
        "docs.rs"
      ],
      "reasoning_steps": [
        "Input canonicalized: 'ultraviolet' -> 'ultraviolet'",
        "Context gathered from 4 validated sources",
        "Metadata extracted: 4 fields",
        "Documentation analyzed: quality 7.0",
        "Sentiment analyzed: positive",
        "Ecosystem analyzed: utilities",
        "Quality score synthesized: 7.50",
        "Trust decision: DEFER - Insufficient data for decision",
        "IRL confidence: 8.600"
      ],
      "suggestion": "ALLOW: Positive community sentiment",
      "verdict": "DEFER",
      "audit_info": {
        "metadata": {
          "name": "ultraviolet",
          "type": "rust_crate",
          "source": "manual_input",
          "extraction_method": "irl_engine"
        },
        "sentiment": {
          "quality_score": 7.0,
          "completeness": 0.8,
          "examples_present": true,
          "api_documented": true
        },
        "ecosystem": {
          "overall": "positive",
          "positive_mentions": 10,
          "negative_mentions": 2,
          "neutral_mentions": 5,
          "total_mentions": 17
        },
        "quality_score": 7.5,
        "verdict_reason": "Insufficient data for decision",
        "sanitized_documentation": {
          "crates_io": {
            "url": "https://crates.io/crates/ultraviolet",
            "title": "ultraviolet v0.10.0",
            "content": {
              "raw_markdown": "#  ultraviolet v0.10.0\nA crate to do linear algebra, fast. \n  * [ #graphics ](https://crates.io/keywords/graphics)\n  * [ #linear-algebra ](https://crates.io/keywords/linear-algebra)\n  * [ #math ](https://crates.io/keywords/math)\n  * [ #simd ](https://crates.io/keywords/simd)\n  * [ #wide ](https://crates.io/keywords/wide)\n\n\n  * [ Readme ](https://crates.io/crates/ultraviolet)\n  * [ 52 Versions ](https://crates.io/crates/ultraviolet/versions)\n  * [ Dependencies ](https://crates.io/crates/ultraviolet/dependencies)\n  * [ Dependents ](https://crates.io/crates/ultraviolet/reverse_dependencies)\n\n\n## Metadata\n2 months ago \n2018 edition \n[ MIT ](https://choosealicense.com/licenses/mit) OR [ Apache-2.0 ](https://choosealicense.com/licenses/apache-2.0) OR [ Zlib ](https://choosealicense.com/licenses/zlib)\n55.8 KiB \n## Install\nRun the following Cargo command in your project directory:\ncargo add ultraviolet\nOr add the following line to your Cargo.toml:\nultraviolet = \"0.10.0\"\n## Repository\n[ github.com/termhn/ultraviolet ](https://github.com/termhn/ultraviolet)\n## Owners\n[ Report crate ](https://crates.io/support?crate=ultraviolet&inquire=crate-violation)\n### Stats Overview\n613,853 Downloads all time\n52 Versions published\n#### Downloads over the last 90 days\nDisplay as \nStacked \n  * Stacked \n  * Unstacked \n\n\nLoading\u2026\n",
              "markdown_with_citations": "#  ultraviolet v0.10.0\nA crate to do linear algebra, fast. \n  *  #graphics \u27e81\u27e9\n  *  #linear-algebra \u27e82\u27e9\n  *  #math \u27e83\u27e9\n  *  #simd \u27e84\u27e9\n  *  #wide \u27e85\u27e9\n\n\n  *  Readme \u27e86\u27e9\n  *  52 Versions \u27e87\u27e9\n  *  Dependencies \u27e88\u27e9\n  *  Dependents \u27e89\u27e9\n\n\n## Metadata\n2 months ago \n2018 edition \n MIT \u27e810\u27e9 OR  Apache-2.0 \u27e811\u27e9 OR  Zlib \u27e812\u27e9\n55.8 KiB \n## Install\nRun the following Cargo command in your project directory:\ncargo add ultraviolet\nOr add the following line to your Cargo.toml:\nultraviolet = \"0.10.0\"\n## Repository\n github.com/termhn/ultraviolet \u27e813\u27e9\n## Owners\n Report crate \u27e814\u27e9\n### Stats Overview\n613,853 Downloads all time\n52 Versions published\n#### Downloads over the last 90 days\nDisplay as \nStacked \n  * Stacked \n  * Unstacked \n\n\nLoading\u2026\n",
              "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://crates.io/keywords/graphics:  #graphics \n\u27e82\u27e9 https://crates.io/keywords/linear-algebra:  #linear-algebra \n\u27e83\u27e9 https://crates.io/keywords/math:  #math \n\u27e84\u27e9 https://crates.io/keywords/simd:  #simd \n\u27e85\u27e9 https://crates.io/keywords/wide:  #wide \n\u27e86\u27e9 https://crates.io/crates/ultraviolet:  Readme \n\u27e87\u27e9 https://crates.io/crates/ultraviolet/versions:  52 Versions \n\u27e88\u27e9 https://crates.io/crates/ultraviolet/dependencies:  Dependencies \n\u27e89\u27e9 https://crates.io/crates/ultraviolet/reverse_dependencies:  Dependents \n\u27e810\u27e9 https://choosealicense.com/licenses/mit:  MIT \n\u27e811\u27e9 https://choosealicense.com/licenses/apache-2.0:  Apache-2.0 \n\u27e812\u27e9 https://choosealicense.com/licenses/zlib:  Zlib \n\u27e813\u27e9 https://github.com/termhn/ultraviolet:  github.com/termhn/ultraviolet \n\u27e814\u27e9 https://crates.io/support?crate=ultraviolet&inquire=crate-violation:  Report crate \n",
              "fit_markdown": "",
              "fit_html": ""
            },
            "structured_data": {},
            "quality_score": 3.0,
            "extraction_method": "crawl4ai",
            "error": null,
            "metadata": {
              "doc_type": "docs",
              "content_length": 1325,
              "has_structured_data": false,
              "crawl_success": true
            },
            "timestamp": "119588.4025029"
          },
          "docs_rs": {
            "url": "https://docs.rs/ultraviolet",
            "title": "Crate ultravioletCopy item path",
            "content": {
              "raw_markdown": "[](https://docs.rs/ultraviolet/latest/ultraviolet/all.html \"show sidebar\")\n# Crate ultravioletCopy item path\n[Settings](https://docs.rs/ultraviolet/latest/settings.html)\n[Help](https://docs.rs/ultraviolet/latest/help.html)\nSummary[Source](https://docs.rs/ultraviolet/latest/src/ultraviolet/lib.rs.html#1-139)\nExpand description\n## [\u00a7](https://docs.rs/ultraviolet/latest/ultraviolet/#ultraviolet)`ultraviolet`\nThis is a crate to computer-graphics and games-related linear and geometric algebra, but _fast_ , both in terms of productivity and in terms of runtime performance.\nIn terms of productivity, ultraviolet uses no generics and is designed to be as straightforward of an interface as possible, resulting in fast compilation times and clear code. In addition, the lack of generics and Rust type-system \u201chacks\u201d result in clear and concise errors that are easy to parse and fix for the user.\nIn terms of runtime performance, ultraviolet was designed from the start with performance in mind. To do so, we provide two separate kinds of each type, each with nearly identical functionality, one with usual scalar f32 values, and the other a \u2018wide\u2019 type which uses SIMD f32x4 vectors for each value. This design is clear and explicit in intent, and it also allows code to take full advantage of SIMD.\nThe \u2018wide\u2019 types use an \u201cSoA\u201d (Structure of Arrays) architecture such that each wide data structure actually contains the data for 4 or 8 of its associated data type and will do any operation on all of the simd \u2018lanes\u2019 at the same time. For example, a `Vec3x8` is equivalent to 8 `Vec3`s all bundled together into one data structure.\nDoing this is potentially _much_ (factor of 10) faster than an standard \u201cAoS\u201d (Array of Structs) layout, though it does depend on your workload and algorithm requirements. Algorithms must be carefully architected to take full advantage of this, and doing so can be easier said than done, especially if your algorithm involves significant branching.\n`ultraviolet` was the first Rust math library to be designed in this \u201cAoSoA\u201d manner, though `nalgebra` now supports it for several of their data structures as well.\n### [\u00a7](https://docs.rs/ultraviolet/latest/ultraviolet/#benchmarks)Benchmarks\nSee [`mathbench-rs`](https://github.com/bitshifter/mathbench-rs) for latest benchmarks.\n### [\u00a7](https://docs.rs/ultraviolet/latest/ultraviolet/#cargo-features)Cargo Features\nTo help further improve build times, `ultraviolet` puts various functionality under feature flags. For example, the 2d and 3d projective geometric algebras as well as f64 and integer types are disabled by default. In order to enable them, enable the corresponding crate feature flags in your `Cargo.toml`. For example:\n```\n[dependencies]\nultraviolet = { version = \"0.9\", features = [ \"f64\", \"int\" ] }\n```\n\nWill enable the `f64` and `int` features. Here\u2019s a list of the available features:\n  * `f64` \u2013 Enable `f64` bit wide floating point support. Naming convention is `D[Type]`, such as `DVec3x4` would be a collection of 4 3d vectors with `f64` precision each.\n  * `int` \u2013 Enable integer vector types.\n  * `bytemuck` \u2013 Enable casting of many types to byte arrays, for use with graphics APIs.\n  * `mint` \u2013 Enable interoperation with other math crates through the `mint` interface.\n  * `num-traits` \u2013 Enable [identity traits](https://docs.rs/num-traits/latest/num_traits/identities/index.html) for interoperation with other math crates.\n  * `serde` \u2013 Enable `Serialize` and `Deserialize` implementations for many scalar types.\n\n\n### [\u00a7](https://docs.rs/ultraviolet/latest/ultraviolet/#crate-features)Crate Features\nThis crate is currently being dogfooded in my ray tracer [`rayn`](https://github.com/termhn/rayn), and is being used by various independent Rust game developers for various projects. It does what those users have currently needed it to do.\nThere are a couple relatively unique/novel features in this library, the most important being the use of the Geometric Algebra.\nInstead of implementing complex number algebra (for 2d rotations) and Quaternion algebra (for 3d rotations), we use Rotors, a concept taken from Geometric Algebra, to represent 2d and 3d rotations.\nWhat this means for the programmer is that you will be using the `Rotor3` type in place of a Quaternion, though you can expect it to do basically all the same things that a Quaternion does. In fact, Quaternions are directly isomorphic to Rotors (meaning they are in essense the same thing, just formulated differently). The reason this decision was made was twofold: first, the derivation of the math is actually quite simple to understand. All the derivations for the code implemented in the Rotor structs in this library are written out in the `derivations` folder of the GitHub repo; I derived them manually as part of the implementation.\nOn the other hand, Quaternions are often basically just seen as black boxes that we programmers use to do rotations because they have some nice properties, but that we don\u2019t really understand. You can use Rotors this same way, but you can also easily understand them. Second is that in some sense they can be seen as \u2018more correct\u2019 than Quaternions. Specifically, they facilitate a more proper understanding of rotation as being something that occurs _within a plane_ rather than something that occurs _around an axis_ , as it is generally thought. Finally, Rotors also generalize to 4 and even higher dimensions, and if someone wants to they could implement a Rotor4 which retains all the properties of a Rotor3/Quaternion but does rotation in 4 dimensions instead, something which simply is not possible to do with Quaternions.\nIf it\u2019s missing something you need it to do, bug me on the [GitHub issue tracker](https://github.com/termhn/ultraviolet/issues) and/or Rust community discord server (I\u2019m Fusha there) and I\u2019ll try to add it for you, if I believe it fits with the vision of the lib :)\n## Re-exports[\u00a7](https://docs.rs/ultraviolet/latest/ultraviolet/#reexports)\n\n`pub use bivec[](https://docs.rs/ultraviolet/latest/ultraviolet/bivec/index.html \"mod ultraviolet::bivec\")::*;`\n\n\n`pub use conversion[](https://docs.rs/ultraviolet/latest/ultraviolet/conversion/index.html \"mod ultraviolet::conversion\")::*;`\n\n\n`pub use int[](https://docs.rs/ultraviolet/latest/ultraviolet/int/index.html \"mod ultraviolet::int\")::*;`\n\n\n`pub use interp[](https://docs.rs/ultraviolet/latest/ultraviolet/interp/index.html \"mod ultraviolet::interp\")::*;`\n\n\n`pub use mat[](https://docs.rs/ultraviolet/latest/ultraviolet/mat/index.html \"mod ultraviolet::mat\")::*;`\n\n\n`pub use rotor[](https://docs.rs/ultraviolet/latest/ultraviolet/rotor/index.html \"mod ultraviolet::rotor\")::*;`\n\n\n`pub use transform[](https://docs.rs/ultraviolet/latest/ultraviolet/transform/index.html \"mod ultraviolet::transform\")::*;`\n\n\n`pub use vec[](https://docs.rs/ultraviolet/latest/ultraviolet/vec/index.html \"mod ultraviolet::vec\")::*;`\n\n## Modules[\u00a7](https://docs.rs/ultraviolet/latest/ultraviolet/#modules)\n\n[bivec](https://docs.rs/ultraviolet/latest/ultraviolet/bivec/index.html \"mod ultraviolet::bivec\")\n    Bivectors, i.e. oriented areas.\n\n[conversion](https://docs.rs/ultraviolet/latest/ultraviolet/conversion/index.html \"mod ultraviolet::conversion\")\n    Contains implementations to convert between `UVec`/`IVec` and `Vec`/`DVec`.\n\n[int](https://docs.rs/ultraviolet/latest/ultraviolet/int/index.html \"mod ultraviolet::int\")\n\n\n[interp](https://docs.rs/ultraviolet/latest/ultraviolet/interp/index.html \"mod ultraviolet::interp\")\n    Interpolation on types for which it makes sense.\n\n[mat](https://docs.rs/ultraviolet/latest/ultraviolet/mat/index.html \"mod ultraviolet::mat\")\n    Square matrices.\n\n[projection](https://docs.rs/ultraviolet/latest/ultraviolet/projection/index.html \"mod ultraviolet::projection\")\n    Utility functions to create projection matrices.\n\n[rotor](https://docs.rs/ultraviolet/latest/ultraviolet/rotor/index.html \"mod ultraviolet::rotor\")\n    Rotors, i.e. constructs that describe and perform rotations.\n\n[transform](https://docs.rs/ultraviolet/latest/ultraviolet/transform/index.html \"mod ultraviolet::transform\")\n    Dedicated transformation types as the combination of primitives.\n\n[vec](https://docs.rs/ultraviolet/latest/ultraviolet/vec/index.html \"mod ultraviolet::vec\")\n    Vectors and points, i.e. directed line segments and locations.\n## Macros[\u00a7](https://docs.rs/ultraviolet/latest/ultraviolet/#macros)\n\n[derive_default_identity](https://docs.rs/ultraviolet/latest/ultraviolet/macro.derive_default_identity.html \"macro ultraviolet::derive_default_identity\")\n\n## Structs[\u00a7](https://docs.rs/ultraviolet/latest/ultraviolet/#structs)\n\n[f32x4](https://docs.rs/ultraviolet/latest/ultraviolet/struct.f32x4.html \"struct ultraviolet::f32x4\")\n\n\n[f32x8](https://docs.rs/ultraviolet/latest/ultraviolet/struct.f32x8.html \"struct ultraviolet::f32x8\")\n\n\n[f64x2](https://docs.rs/ultraviolet/latest/ultraviolet/struct.f64x2.html \"struct ultraviolet::f64x2\")\n\n\n[f64x4](https://docs.rs/ultraviolet/latest/ultraviolet/struct.f64x4.html \"struct ultraviolet::f64x4\")\n\n\n[m32x4](https://docs.rs/ultraviolet/latest/ultraviolet/struct.m32x4.html \"struct ultraviolet::m32x4\")\n\n\n[m32x8](https://docs.rs/ultraviolet/latest/ultraviolet/struct.m32x8.html \"struct ultraviolet::m32x8\")\n\n\n[m64x2](https://docs.rs/ultraviolet/latest/ultraviolet/struct.m64x2.html \"struct ultraviolet::m64x2\")\n\n\n[m64x4](https://docs.rs/ultraviolet/latest/ultraviolet/struct.m64x4.html \"struct ultraviolet::m64x4\")\n\n",
              "markdown_with_citations": "[](https://docs.rs/ultraviolet/latest/ultraviolet/all.html \"show sidebar\")\n# Crate ultravioletCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\n## \u00a7\u27e84\u27e9`ultraviolet`\nThis is a crate to computer-graphics and games-related linear and geometric algebra, but _fast_ , both in terms of productivity and in terms of runtime performance.\nIn terms of productivity, ultraviolet uses no generics and is designed to be as straightforward of an interface as possible, resulting in fast compilation times and clear code. In addition, the lack of generics and Rust type-system \u201chacks\u201d result in clear and concise errors that are easy to parse and fix for the user.\nIn terms of runtime performance, ultraviolet was designed from the start with performance in mind. To do so, we provide two separate kinds of each type, each with nearly identical functionality, one with usual scalar f32 values, and the other a \u2018wide\u2019 type which uses SIMD f32x4 vectors for each value. This design is clear and explicit in intent, and it also allows code to take full advantage of SIMD.\nThe \u2018wide\u2019 types use an \u201cSoA\u201d (Structure of Arrays) architecture such that each wide data structure actually contains the data for 4 or 8 of its associated data type and will do any operation on all of the simd \u2018lanes\u2019 at the same time. For example, a `Vec3x8` is equivalent to 8 `Vec3`s all bundled together into one data structure.\nDoing this is potentially _much_ (factor of 10) faster than an standard \u201cAoS\u201d (Array of Structs) layout, though it does depend on your workload and algorithm requirements. Algorithms must be carefully architected to take full advantage of this, and doing so can be easier said than done, especially if your algorithm involves significant branching.\n`ultraviolet` was the first Rust math library to be designed in this \u201cAoSoA\u201d manner, though `nalgebra` now supports it for several of their data structures as well.\n### \u00a7\u27e85\u27e9Benchmarks\nSee `mathbench-rs`\u27e86\u27e9 for latest benchmarks.\n### \u00a7\u27e87\u27e9Cargo Features\nTo help further improve build times, `ultraviolet` puts various functionality under feature flags. For example, the 2d and 3d projective geometric algebras as well as f64 and integer types are disabled by default. In order to enable them, enable the corresponding crate feature flags in your `Cargo.toml`. For example:\n```\n[dependencies]\nultraviolet = { version = \"0.9\", features = [ \"f64\", \"int\" ] }\n```\n\nWill enable the `f64` and `int` features. Here\u2019s a list of the available features:\n  * `f64` \u2013 Enable `f64` bit wide floating point support. Naming convention is `D[Type]`, such as `DVec3x4` would be a collection of 4 3d vectors with `f64` precision each.\n  * `int` \u2013 Enable integer vector types.\n  * `bytemuck` \u2013 Enable casting of many types to byte arrays, for use with graphics APIs.\n  * `mint` \u2013 Enable interoperation with other math crates through the `mint` interface.\n  * `num-traits` \u2013 Enable identity traits\u27e88\u27e9 for interoperation with other math crates.\n  * `serde` \u2013 Enable `Serialize` and `Deserialize` implementations for many scalar types.\n\n\n### \u00a7\u27e89\u27e9Crate Features\nThis crate is currently being dogfooded in my ray tracer `rayn`\u27e810\u27e9, and is being used by various independent Rust game developers for various projects. It does what those users have currently needed it to do.\nThere are a couple relatively unique/novel features in this library, the most important being the use of the Geometric Algebra.\nInstead of implementing complex number algebra (for 2d rotations) and Quaternion algebra (for 3d rotations), we use Rotors, a concept taken from Geometric Algebra, to represent 2d and 3d rotations.\nWhat this means for the programmer is that you will be using the `Rotor3` type in place of a Quaternion, though you can expect it to do basically all the same things that a Quaternion does. In fact, Quaternions are directly isomorphic to Rotors (meaning they are in essense the same thing, just formulated differently). The reason this decision was made was twofold: first, the derivation of the math is actually quite simple to understand. All the derivations for the code implemented in the Rotor structs in this library are written out in the `derivations` folder of the GitHub repo; I derived them manually as part of the implementation.\nOn the other hand, Quaternions are often basically just seen as black boxes that we programmers use to do rotations because they have some nice properties, but that we don\u2019t really understand. You can use Rotors this same way, but you can also easily understand them. Second is that in some sense they can be seen as \u2018more correct\u2019 than Quaternions. Specifically, they facilitate a more proper understanding of rotation as being something that occurs _within a plane_ rather than something that occurs _around an axis_ , as it is generally thought. Finally, Rotors also generalize to 4 and even higher dimensions, and if someone wants to they could implement a Rotor4 which retains all the properties of a Rotor3/Quaternion but does rotation in 4 dimensions instead, something which simply is not possible to do with Quaternions.\nIf it\u2019s missing something you need it to do, bug me on the GitHub issue tracker\u27e811\u27e9 and/or Rust community discord server (I\u2019m Fusha there) and I\u2019ll try to add it for you, if I believe it fits with the vision of the lib :)\n## Re-exports\u00a7\u27e812\u27e9\n\n`pub use bivec[](https://docs.rs/ultraviolet/latest/ultraviolet/bivec/index.html \"mod ultraviolet::bivec\")::*;`\n\n\n`pub use conversion[](https://docs.rs/ultraviolet/latest/ultraviolet/conversion/index.html \"mod ultraviolet::conversion\")::*;`\n\n\n`pub use int[](https://docs.rs/ultraviolet/latest/ultraviolet/int/index.html \"mod ultraviolet::int\")::*;`\n\n\n`pub use interp[](https://docs.rs/ultraviolet/latest/ultraviolet/interp/index.html \"mod ultraviolet::interp\")::*;`\n\n\n`pub use mat[](https://docs.rs/ultraviolet/latest/ultraviolet/mat/index.html \"mod ultraviolet::mat\")::*;`\n\n\n`pub use rotor[](https://docs.rs/ultraviolet/latest/ultraviolet/rotor/index.html \"mod ultraviolet::rotor\")::*;`\n\n\n`pub use transform[](https://docs.rs/ultraviolet/latest/ultraviolet/transform/index.html \"mod ultraviolet::transform\")::*;`\n\n\n`pub use vec[](https://docs.rs/ultraviolet/latest/ultraviolet/vec/index.html \"mod ultraviolet::vec\")::*;`\n\n## Modules\u00a7\u27e813\u27e9\n\nbivec\u27e814\u27e9\n    Bivectors, i.e. oriented areas.\n\nconversion\u27e815\u27e9\n    Contains implementations to convert between `UVec`/`IVec` and `Vec`/`DVec`.\n\nint\u27e816\u27e9\n\n\ninterp\u27e817\u27e9\n    Interpolation on types for which it makes sense.\n\nmat\u27e818\u27e9\n    Square matrices.\n\nprojection\u27e819\u27e9\n    Utility functions to create projection matrices.\n\nrotor\u27e820\u27e9\n    Rotors, i.e. constructs that describe and perform rotations.\n\ntransform\u27e821\u27e9\n    Dedicated transformation types as the combination of primitives.\n\nvec\u27e822\u27e9\n    Vectors and points, i.e. directed line segments and locations.\n## Macros\u00a7\u27e823\u27e9\n\nderive_default_identity\u27e824\u27e9\n\n## Structs\u00a7\u27e825\u27e9\n\nf32x4\u27e826\u27e9\n\n\nf32x8\u27e827\u27e9\n\n\nf64x2\u27e828\u27e9\n\n\nf64x4\u27e829\u27e9\n\n\nm32x4\u27e830\u27e9\n\n\nm32x8\u27e831\u27e9\n\n\nm64x2\u27e832\u27e9\n\n\nm64x4\u27e833\u27e9\n\n",
              "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/ultraviolet/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/ultraviolet/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/ultraviolet/latest/src/ultraviolet/lib.rs.html#1-139: Source\n\u27e84\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/#ultraviolet: \u00a7\n\u27e85\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/#benchmarks: \u00a7\n\u27e86\u27e9 https://github.com/bitshifter/mathbench-rs: `mathbench-rs`\n\u27e87\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/#cargo-features: \u00a7\n\u27e88\u27e9 https://docs.rs/num-traits/latest/num_traits/identities/index.html: identity traits\n\u27e89\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/#crate-features: \u00a7\n\u27e810\u27e9 https://github.com/termhn/rayn: `rayn`\n\u27e811\u27e9 https://github.com/termhn/ultraviolet/issues: GitHub issue tracker\n\u27e812\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/#reexports: \u00a7\n\u27e813\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/#modules: \u00a7\n\u27e814\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/bivec/index.html: mod ultraviolet::bivec - bivec\n\u27e815\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/conversion/index.html: mod ultraviolet::conversion - conversion\n\u27e816\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/int/index.html: mod ultraviolet::int - int\n\u27e817\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/interp/index.html: mod ultraviolet::interp - interp\n\u27e818\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/mat/index.html: mod ultraviolet::mat - mat\n\u27e819\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/projection/index.html: mod ultraviolet::projection - projection\n\u27e820\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/rotor/index.html: mod ultraviolet::rotor - rotor\n\u27e821\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/transform/index.html: mod ultraviolet::transform - transform\n\u27e822\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/vec/index.html: mod ultraviolet::vec - vec\n\u27e823\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/#macros: \u00a7\n\u27e824\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/macro.derive_default_identity.html: macro ultraviolet::derive_default_identity - derive_default_identity\n\u27e825\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/#structs: \u00a7\n\u27e826\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/struct.f32x4.html: struct ultraviolet::f32x4 - f32x4\n\u27e827\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/struct.f32x8.html: struct ultraviolet::f32x8 - f32x8\n\u27e828\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/struct.f64x2.html: struct ultraviolet::f64x2 - f64x2\n\u27e829\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/struct.f64x4.html: struct ultraviolet::f64x4 - f64x4\n\u27e830\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/struct.m32x4.html: struct ultraviolet::m32x4 - m32x4\n\u27e831\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/struct.m32x8.html: struct ultraviolet::m32x8 - m32x8\n\u27e832\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/struct.m64x2.html: struct ultraviolet::m64x2 - m64x2\n\u27e833\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/struct.m64x4.html: struct ultraviolet::m64x4 - m64x4\n",
              "fit_markdown": "",
              "fit_html": ""
            },
            "structured_data": {},
            "quality_score": 4.0,
            "extraction_method": "crawl4ai",
            "error": null,
            "metadata": {
              "doc_type": "docs",
              "content_length": 9478,
              "has_structured_data": false,
              "crawl_success": true
            },
            "timestamp": "119589.253275"
          },
          "lib_rs": {
            "url": "https://lib.rs/crates/ultraviolet",
            "title": "Untitled",
            "content": {
              "raw_markdown": "###  [46 releases](https://lib.rs/crates/ultraviolet/versions)\n0.10.0 |  Apr 26, 2025   \n---|---  \n0.9.2 |  Sep 3, 2023   \n0.9.1 |  Mar 19, 2023   \n0.9.0 |  Mar 3, 2022   \n0.3.3 |  Nov 29, 2019   \n#**37** in [Math](https://lib.rs/science/math \"Crates related to solving mathematical problems.\")\nDownload history 4268/week @ 2025-03-10 3691/week @ 2025-03-17 3476/week @ 2025-03-24 2297/week @ 2025-03-31 2571/week @ 2025-04-07 2809/week @ 2025-04-14 4964/week @ 2025-04-21 5181/week @ 2025-04-28 3196/week @ 2025-05-05 2228/week @ 2025-05-12 1993/week @ 2025-05-19 2215/week @ 2025-05-26 1670/week @ 2025-06-02 2433/week @ 2025-06-09 4165/week @ 2025-06-16 4725/week @ 2025-06-23\n**13,082** downloads per month Used in [**102** crates (29 directly)](https://lib.rs/crates/ultraviolet/rev)\n**MIT OR Apache-2.0 OR Zlib**\n425KB  9K  SLoC\n[![crates.io](https://img.shields.io/crates/v/ultraviolet.svg)](https://crates.io/crates/ultraviolet) [![docs.rs](https://img.gs/czjpqfbdkz/full/https://docs.rs/ultraviolet/badge.svg)](https://docs.rs/ultraviolet)\n# ``ultraviolet``\nThis is a crate to computer-graphics and games-related linear and geometric algebra, but _fast_ , both in terms of productivity and in terms of runtime performance.\nIn terms of productivity, ultraviolet uses no generics and is designed to be as straightforward of an interface as possible, resulting in fast compilation times and clear code. In addition, the lack of generics and Rust type-system \"hacks\" result in clear and concise errors that are easy to parse and fix for the user.\nIn terms of runtime performance, ultraviolet was designed from the start with performance in mind. To do so, we provide two separate kinds of each type, each with nearly identical functionality, one with usual scalar f32 values, and the other a 'wide' type which uses SIMD f32x4 vectors for each value. This design is clear and explicit in intent, and it also allows code to take full advantage of SIMD.\nThe 'wide' types use an \"SoA\" (Structure of Arrays) architecture such that each wide data structure actually contains the data for 4 or 8 of its associated data type and will do any operation on all of the simd 'lanes' at the same time. For example, a ``Vec3x8`` is equivalent to 8 ``Vec3``s all bundled together into one data structure.\nDoing this is potentially _much_ (factor of 10) faster than an standard \"AoS\" (Array of Structs) layout, though it does depend on your workload and algorithm requirements. Algorithms must be carefully architected to take full advantage of this, and doing so can be easier said than done, especially if your algorithm involves significant branching.\n``ultraviolet`` was the first Rust math library to be designed in this \"AoSoA\" manner, though ``nalgebra`` now supports it for several of their data structures as well.\n## Benchmarks\nSee [``mathbench-rs``](https://github.com/bitshifter/mathbench-rs) for latest benchmarks (may not be fully up-to-date with git master).\n## Cargo Features\nTo help further improve build times, ``ultraviolet`` puts various functionality under feature flags. For example, the 2d and 3d projective geometric algebras as well as f64 and integer types are disabled by default. In order to enable them, enable the corresponding crate feature flags in your ``Cargo.toml``. For example:\n```\n```[``dependencies``]`\n`ultraviolet = { version = \"0.9\", features ``=` ``[` ``\"`f64`\"``, ``\"`int`\"`` `]`` }\n``\n```\n\nWill enable the ```f64``` and ``int`` features. Here's a list of the available features:\n  * ```f64``` \u2013 Enable ```f64``` bit wide floating point support. Naming convention is ``D`[`Type`]```, such as ``DVec3x4`` would be a collection of 4 3d vectors with ```f64``` precision each.\n  * ``int`` \u2013 Enable integer vector types.\n  * ``bytemuck`` \u2013 Enable casting of many types to byte arrays, for use with graphics APIs.\n  * ``mint`` \u2013 Enable interoperation with other math crates through the ``mint`` interface.\n  * ``num-traits`` \u2013 Enable [identity traits](https://docs.rs/num-traits/latest/num_traits/identities/index.html) for interoperation with other math crates.\n  * ``serde`` \u2013 Enable ``Serialize`` and ``Deserialize`` implementations for many scalar types.\n\n\n## Crate Features\nThis crate is currently being dogfooded in my ray tracer [``rayn``](https://github.com/termhn/rayn), and is being used by various independent Rust game developers for various projects. It does what those users have currently needed it to do.\nThere are a couple relatively unique/novel features in this library, the most important being the use of the Geometric Algebra.\nInstead of implementing complex number algebra (for 2d rotations) and Quaternion algebra (for 3d rotations), we use Rotors, a concept taken from Geometric Algebra, to represent 2d and 3d rotations.\nWhat this means for the programmer is that you will be using the ``Rotor3`` type in place of a Quaternion, though you can expect it to do basically all the same things that a Quaternion does. In fact, Quaternions are directly isomorphic to Rotors (meaning they are in essense the same thing, just formulated differently). The reason this decision was made was twofold: first, the derivation of the math is actually quite simple to understand. All the derivations for the code implemented in the Rotor structs in this library are written out in the ``derivations`` folder of the GitHub repo; I derived them manually as part of the implementation.\nOn the other hand, Quaternions are often basically just seen as black boxes that we programmers use to do rotations because they have some nice properties, but that we don't really understand. You can use Rotors this same way, but you can also easily understand them. Second is that in some sense they can be seen as 'more correct' than Quaternions. Specifically, they facilitate a more proper understanding of rotation as being something that occurs _within a plane_ rather than something that occurs _around an axis_ , as it is generally thought. Finally, Rotors also generalize to 4 and even higher dimensions, and if someone wants to they could implement a Rotor4 which retains all the properties of a Rotor3/Quaternion but does rotation in 4 dimensions instead, something which simply is not possible to do with Quaternions.\nIf it's missing something you need it to do, bug me on the [GitHub issue tracker](https://github.com/termhn/ultraviolet/issues) and/or Rust community discord server (I'm Fusha there) and I'll try to add it for you, if I believe it fits with the vision of the lib :)\n## Examples\n### Euler Integration\n[Euler Integration](https://en.wikipedia.org/wiki/Euler_method) is a method for numerically solving ordinary differential equations. If that sounds complicated, don't worry! The details of the method don't matter if you're not looking to implement any kind of physics simulation but this method is common in games. Keep reading for the code below!\nThe point is that if you are doing the same basic math operations on multiple floating point values with no conditionals (no ```if```s), porting to wide data types and parallel processing is quite simple.\nHere is the scalar example of Euler Integration:\n```\n```fn` `integrate`````(`\n  `pos``:` `&``mut` [`uv`::``Vec3],\n  `vel``:` `&``mut` [`uv`::``Vec3],\n  `acc``:` `&`[`uv`::``Vec3],\n  `dt``:` `f32`,\n```)``````{`\n  `for` `(``(`position`,` velocity`)``,` acceleration`)` `in` pos`.``iter_mut``(``)``.``zip``(`vel`)``.``zip``(`acc`)` `{`\n    `*`velocity `=` `*`velocity `+` `*`acceleration `*` dt`;`\n    `*`position `=` `*`position `+` `*`velocity `*` dt`;`\n  `}`\n```}```\n`\n```\n\nThe code loops over each set of corresponding position, velocity, and acceleration vectors. It first adjusts the velocity by the acceleration scaled by the amount of time that has passed and then adjusts the position by the velocity scaled by the amount of time that has passed.\nThese are all multiplication, addition, and assignment operators that need to be applied in the same way to all of the variables in question.\nTo port this function to wide data types and parallel processing, all we have to do is change the data types and we're done! The new function looks like this:\n```\n```fn` `integrate_x8`````(`\n  `pos``:` `&``mut` [`uv`::``Vec3x8],\n  `vel``:` `&``mut` [`uv`::``Vec3x8],\n  `acc``:` `&`[`uv`::``Vec3x8],\n  `dt``:` f32x8,\n```)``````{`\n  `for` `(``(`position`,` velocity`)``,` acceleration`)` `in` pos`.``iter_mut``(``)``.``zip``(`vel`)``.``zip``(`acc`)` `{`\n    `*`velocity `=` `*`velocity `+` `*`acceleration `*` dt`;`\n    `*`position `=` `*`position `+` `*`velocity `*` dt`;`\n  `}`\n```}```\n`\n```\n\nThis function now processes 8 sets of vectors in parallel and brings significant speed gains!\nThe only caveat is that the calling code that creates the slices of vectors needs to be modified to populate these wide data types with 8 sets of values instead of just one. The scalar code for that looks like this:\n```\n``let` `mut` pos`:` ``Vec``<``uv`::``Vec3`>`` `=` `Vec```::``with_capacity`(``100``)``;`\n`let` `mut` vel`:` ``Vec``<``uv`::``Vec3`>`` `=` `Vec```::``with_capacity`(``100``)``;`\n`let` `mut` acc`:` ``Vec``<``uv`::``Vec3`>`` `=` `Vec```::``with_capacity`(``100``)``;`\n``//` You would probably write these constant values in-line but`\n``//` they are here for illustrative purposes`\n`let` pos_x `=` `1.``0``f32``;`\n`let` pos_y `=` `2.``0``f32``;`\n`let` pos_z `=` `3.``0``f32``;`\n`let` vel_x `=` `4.``0``f32``;`\n`let` vel_y `=` `5.``0``f32``;`\n`let` vel_z `=` `6.``0``f32``;`\n`let` acc_x `=` `7.``0``f32``;`\n`let` acc_y `=` `8.``0``f32``;`\n`let` acc_z `=` `9.``0``f32``;`\n`for` `(``(`position`,` velocity`)``,` acceleration`)` `in` pos`.``iter_mut``(``)``.``zip``(`vel`)``.``zip``(`acc`)` ``{`\n  pos`.``push``(``uv`::```Vec3`::``new`(`pos_x`,` pos_y`,` pos_z`)``)``;`\n  vel`.``push``(``uv`::```Vec3`::``new`(`vel_x`,` vel_y`,` vel_z`)``)``;`\n  acc`.``push``(``uv`::```Vec3`::``new`(`acc_x`,` acc_y`,` acc_z`)``)``;`\n```}``\n`\n```\n\nWhereas to populate the same for the 8-lane wide ``Vec3x8`` data type, the code could look like this:\n```\n``let` `mut` pos`:` ``Vec``<``uv`::``Vec3x8`>`` `=` `Vec```::``with_capacity`(``100` `/` `8` `+` `1``)``;`\n`let` `mut` vel`:` ``Vec``<``uv`::``Vec3x8`>`` `=` `Vec```::``with_capacity`(``100` `/` `8` `+` `1``)``;`\n`let` `mut` acc`:` ``Vec``<``uv`::``Vec3x8`>`` `=` `Vec```::``with_capacity`(``100` `/` `8` `+` `1``)``;`\n`let` pos_x `=` `uv`::```f32x8`::``splat`(``1.``0``f32``)``;`\n`let` pos_y `=` `uv`::```f32x8`::``splat`(``2.``0``f32``)``;`\n`let` pos_z `=` `uv`::```f32x8`::``splat`(``3.``0``f32``)``;`\n`let` vel_x `=` `uv`::```f32x8`::``splat`(``4.``0``f32``)``;`\n`let` vel_y `=` `uv`::```f32x8`::``splat`(``5.``0``f32``)``;`\n`let` vel_z `=` `uv`::```f32x8`::``splat`(``6.``0``f32``)``;`\n`let` acc_x `=` `uv`::```f32x8`::``splat`(``7.``0``f32``)``;`\n`let` acc_y `=` `uv`::```f32x8`::``splat`(``8.``0``f32``)``;`\n`let` acc_z `=` `uv`::```f32x8`::``splat`(``9.``0``f32``)``;`\n`for` `(``(`position`,` velocity`)``,` acceleration`)` `in` pos`.``iter_mut``(``)``.``zip``(`vel`)``.``zip``(`acc`)` ``{`\n  pos`.``push``(``uv`::```Vec3x8`::``new`(`pos_x`,` pos_y`,` pos_z`)``)``;`\n  vel`.``push``(``uv`::```Vec3x8`::``new`(`vel_x`,` vel_y`,` vel_z`)``)``;`\n  acc`.``push``(``uv`::```Vec3x8`::``new`(`acc_x`,` acc_y`,` acc_z`)``)``;`\n```}``\n`\n```\n\nNote that ```100` `/` `8``` in maths terms would be ```12.``5```, but we can't conveniently have a half-sized ``Vec3x8``.\nThere are various ways to handle these 'remainder' vectors. You could fall back to scalar code, or progressively fall back to narrower wide types, such as ``Vec3x4``, or you can just consider whether the cost of calculating a few additional vectors that you won't use is worth adding complexity to your code.\n### Ray-Sphere Intersection\nScalar code that operates on a single value at a time needs some restructuring to take advantage of SIMD and the 4-/8-wide data types.\nBelow is an example of scalar ray-sphere instersection code using ``Vec3`` for points and vectors:\n```\n```fn` `ray_sphere_intersect`````(`\n  `ray_o``:` `uv`::``Vec3,\n  `ray_d``:` `uv`::``Vec3,\n  `sphere_o``:` `uv`::``Vec3,\n  `sphere_r_sq``:` `f32`,\n```)```` ``->` `f32`` ````{`\n  `let` oc `=` ray_o `-` sphere_o`;`\n  `let` b `=` oc`.``dot``(`ray_d`)``;`\n  `let` c `=` oc`.``mag_sq``(``)` `-` sphere_r_sq`;`\n  `let` descrim `=` b `*` b `-` c`;`\n  `if` descrim `>` `0.``0` `{`\n    `let` desc_sqrt `=` descrim`.``sqrt``(``)``;`\n    `let` t1 `=` `-`b `-` desc_sqrt`;`\n    `if` t1 `>` `0.``0` `{`\n      t1\n    `}` `else` `{`\n      `let` t2 `=` `-`b `+` desc_sqrt`;`\n      `if` t2 `>` `0.``0` `{`\n        t2\n      `}` `else` `{`\n        `f32```::```MAX`\n      `}`\n    `}`\n  `}` `else` `{`\n    `f32```::```MAX`\n  `}`\n```}```\n`\n```\n\nThis porting guide will not discuss the details of the algorithm, but will focus on how to convert the code to apply parallel SIMD operations on wide data types.\nThe first thing to do is to convert the parameter and return types from scalar ``Vec3`` to wide ``Vec3x8`` and ``f32x8``:\n```\n```fn` `ray_sphere_intersect_x8`````(`\n  `ray_o``:` `uv`::``Vec3x8,\n  `ray_d``:` `uv`::``Vec3x8,\n  `sphere_o``:` `uv`::``Vec3x8,\n  `sphere_r_sq``:` `uv`::``f32x8,\n```)```` ``->` `uv`::``f32x8` ````{`\n```\n```\n\nEach call to the function will process 8 ray-sphere intersections in parallel. The first four lines of the function remain the same:\n```\n`  `let` oc `=` ray_o `-` sphere_o`;`\n  `let` b `=` oc`.``dot``(`ray_d`)``;`\n  `let` c `=` oc`.``mag_sq``(``)` `-` sphere_r_sq`;`\n  `let` descrim `=` b `*` b `-` c`;`\n`\n```\n\nDespite this code being the same, the calculations for 8 rays and spheres will be carried out at the same time!\nThe next line of the scalar code tests the value of ``descrim`` to see if it is greater than ```0.``0```. When operating on 8 values at a time, the code cannot branch along two separate paths because the value of ``descrim`` for each of the 8 values may cause branching to different sets of operations. To support this we would need to convert back to scalar code and then we lose all the performance benefits of parallel processing.\nSo, how do we convert this? We have a tradeoff to consider depending on the frequency of divergence, that is depending on how often the branch will follow one or the other path. If it is very likely for the given data and algorithm that the majority of branches will take one path, we can check whether all lanes take that path and then branch based on that. Such a bias toward one branch path is relatively rare, and in the case of this algorithm it is common to branch either way so this approach would produce slower code.\nAnother approach is to calculate the results for both branches for all 8 lanes, and then filter the results with masks that select the correct values from the possibilities at the end.\nTo create the mask for 8 lanes of ``descrim`` values with ```0.``0```:\n```\n`  `let` desc_pos `=` descrim`.``cmp_gt``(``uv`::```f32x8`::``splat`(``0.``0``)``)``;`\n`\n```\n\nIn the true case of the original scalar version, we then have more arithmetic operations that end up looking the exact same when we do them on the vectorized version:\n```\n`  `let` desc_sqrt `=` descrim`.``sqrt``(``)``;`\n  `let` t1 `=` `-`b `-` desc_sqrt`;`\n`\n```\n\nAnd now in the scalar code we have another branch based on ``t1 `>` `0.``0```, so we apply the same technique, with a little bit extra:\n```\n`  `let` t1_valid `=` t1`.``cmp_gt``(``uv`::```f32x8`::``splat`(``0.``0``)``)` `&` desc_pos`;`\n`\n```\n\nThe ```&` desc_pos`` at the end does a bitwise and operation to combine the masks that say whether each of the lanes of ``t1 `>` `0.``0``` are true or false, with those of whether each of the lanes of ``descrim `>` `0.``0``` were true or false, and if both are true for a lane, then the mask value will be true for that lane in ``t1_mask``, otherwise the value for the lane will be ```false```. This is combining the nested logic.\nThe true case of the ``t1 `>` `0.``0``` condition just returns ``t1``, but the false case has some more calculation and branching that can be ported in a similar way:\n```\n`  `let` t2 `=` `-`b `+` desc_sqrt`;`\n  `let` t2_valid `=` t2`.``cmp_gt``(``uv`::```f32x8`::``splat`(``0.``0``)``)` `&` desc_pos`;`\n`\n```\n\nThis may sound like it could be slower than scalar code because this algorithm being applied to wide data types is doing all the calculations for both branches regardless of which is true, and you would be right!\nThis approach is indeed a tradeoff and depends on the likelihood of branching one way or the other, and the cost of calculation of the branches. However, even with an algorithm that is particularly branch-heavy like the ray-sphere intersection we're analyzing here, in practice, the benefits of being able to calculate multiple pieces of data simultaneously often results in a net win! As with all optimization, measurement tells the truth.\nAt this point, we have ported almost the entire algorithm. We have values for ``t1`` and ``t2`` for each of the 8 lanes. We have mask values in ``t1_valid`` that indicate whether both ``descrim `>` `0.``0` `&&` t1 `>` `0.``0``` for each lane. And we have ``t2_valid`` with values indicating exactly ``descrim `>` `0.``0` `&&` t2 `>` `0.``0```. When the scalar code does not return ``t1`` or ``t2``, it returns ```f32```::```MAX```. How do we now select the correct return value for each of the lanes?\n``ultraviolet`` has a ``blend`` function on the mask types that uses the true or false values for each of the lanes to select from the calculated values for the true and false cases. So if ``a`` were a wide vector of values that would be calculated in the true case of a branch, and ``b`` were for the false case, with a mask ``m`` we could select from ``a`` and ``b`` based on ``m`` by calling ``m`.``blend``(`a`,` b`)``` and the result would be the desired output values!\nLet's try to apply that to the scalar code by looking just at its logical control flow:\n```\n`  `if` descrim `>` `0.``0` ``{`\n    `if` t1 `>` `0.``0` `{`\n      t1\n    `}` `else` `{`\n      `if` t2 `>` `0.``0` `{`\n        t2\n      `}` `else` `{`\n        `f32```::```MAX`\n      `}`\n    `}`\n  ```}`` `else` ``{`\n    `f32```::```MAX`\n  ```}``\n`\n```\n\nSo if we take the outer-most if condition..\n```\n`  `let` t `=` t1_valid`.``blend``(`t1`,` `?``?``?``)``;`\n`\n```\n\nWhat is the value for false case of the ``descrim `>` `0.``0` `&&` t1 `>` `0.``0``` test? There are two possibilities - either ``descrim `<=` `0.``0```, which is the false case of the ``descrim `>` `0.``0``` condition, or ``descrim `>` `0.``0` `&&` t1 `<=` `0.``0``` which is the else case where we handle ``t2``. This looks complicated. Let's try looking at the ``descrim `>` `0.``0` `&&` t2 `>` `0.``0``` case in the scalar code and try ``blend``ing that:\n```\n`  `let` t `=` t2_valid`.``blend``(`t2`,` `uv`::```f32x8`::``splat`(``std`::```f32`::```MAX``)``)``;`\n`\n```\n\nSo ``descrim `>` `0.``0` `&&` t2 `>` `0.``0``` has two false cases, either ``descrim `<=` `0.``0``` and we want to return ```f32```::```MAX```, or ``descrim `>` `0.``0` `&&` t2 `<=` `0.``0``` and we want to return ```f32```::```MAX```, so we can ``blend`` to select the correct values here to cover the false case of the scalar ``descrim `>` `0.``0``` condition, and the false case of the ``t1 `>` `0.``0``` condition, that leaves only the true case of the ``t1 `>` `0.``0``` condition left to resolve...\nAnd that is exactly what ``t1_valid`.``blend``(`t1`,` `?``?``?``)``` would select! So we can combine the two blends like this:\n```\n`  `let` t `=` t2_valid`.``blend``(`t2`,` `uv`::```f32x8`::``splat`(``std`::```f32`::```MAX``)``)``;`\n  `let` t `=` t1_valid`.``blend``(`t1`,` t`)``;`\n`\n```\n\n``t`` now contains ``t1``, ``t2`` or ```f32```::```MAX``` as appropriate for each of the lanes! We have completed the port of the scalar algorithm code to leverage SIMD operations on 8-lane wide data types to calculate 8 ray-sphere intersections in parallel!\nBelow is the full example of the same ray-sphere intersection algorithm implemented using the wide ``Vec3x8`` type:\n```\n```fn` `ray_sphere_intersect_x8`````(`\n  `sphere_o``:` `uv`::``Vec3x8,\n  `sphere_r_sq``:` `uv`::``f32x8,\n  `ray_o``:` `uv`::``Vec3x8,\n  `ray_d``:` `uv`::``Vec3x8,\n```)```` ``->` `uv`::``f32x8` ````{`\n  `let` oc `=` ray_o `-` sphere_o`;`\n  `let` b `=` oc`.``dot``(`ray_d`)``;`\n  `let` c `=` oc`.``mag_sq``(``)` `-` sphere_r_sq`;`\n  `let` descrim `=` b `*` b `-` c`;`\n  `let` desc_pos `=` descrim`.``cmp_gt``(``uv`::```f32x8`::``splat`(``0.``0``)``)``;`\n  `let` desc_sqrt `=` descrim`.``sqrt``(``)``;`\n  `let` t1 `=` `-`b `-` desc_sqrt`;`\n  `let` t1_valid `=` t1`.``cmp_gt``(``uv`::```f32x8`::``splat`(``0.``0``)``)` `&` desc_pos`;`\n  `let` t2 `=` `-`b `+` desc_sqrt`;`\n  `let` t2_valid `=` t2`.``cmp_gt``(``uv`::```f32x8`::``splat`(``0.``0``)``)` `&` desc_pos`;`\n  `let` t `=` t2_valid`.``blend``(`t2`,` `uv`::```f32x8`::``splat`(``std`::```f32`::```MAX``)``)``;`\n  `let` t `=` t1_valid`.``blend``(`t1`,` t`)``;`\n  t\n```}```\n`\n```\n\n#### Dependencies\n~1.5MB  ~27K SLoC\n  * [ optional ](https://lib.rs/crates/ultraviolet/features#feature-bytemuck \"bytemuck is optional feature\") [bytemuck](https://lib.rs/crates/bytemuck \"1.22\")\n  * [ optional ](https://lib.rs/crates/ultraviolet/features#feature-mint \"mint is optional feature\") [mint](https://lib.rs/crates/mint \"0.5\")\n  * [ optional ](https://lib.rs/crates/ultraviolet/features#feature-num-traits \"num-traits is optional feature\") [num-traits](https://lib.rs/crates/num-traits \"0.2\")\n  * [ optional ](https://lib.rs/crates/ultraviolet/features#feature-serde \"serde is optional feature\") [serde](https://lib.rs/crates/serde \"1.0\")\n  * [wide](https://lib.rs/crates/wide \"0.7\")\n\n\n  * dev  [serde_test](https://lib.rs/crates/serde_test \"1.0\")\n\n\n#### [Other features](https://lib.rs/crates/ultraviolet/features)\n  * [f64](https://lib.rs/crates/ultraviolet/features#feature-f64)\n  * [int](https://lib.rs/crates/ultraviolet/features#feature-int)\n\n\n  *[SLoC]: approx. additional lines of code\n",
              "markdown_with_citations": "###  46 releases\u27e81\u27e9\n0.10.0 |  Apr 26, 2025   \n---|---  \n0.9.2 |  Sep 3, 2023   \n0.9.1 |  Mar 19, 2023   \n0.9.0 |  Mar 3, 2022   \n0.3.3 |  Nov 29, 2019   \n#**37** in Math\u27e82\u27e9\nDownload history 4268/week @ 2025-03-10 3691/week @ 2025-03-17 3476/week @ 2025-03-24 2297/week @ 2025-03-31 2571/week @ 2025-04-07 2809/week @ 2025-04-14 4964/week @ 2025-04-21 5181/week @ 2025-04-28 3196/week @ 2025-05-05 2228/week @ 2025-05-12 1993/week @ 2025-05-19 2215/week @ 2025-05-26 1670/week @ 2025-06-02 2433/week @ 2025-06-09 4165/week @ 2025-06-16 4725/week @ 2025-06-23\n**13,082** downloads per month Used in **102** crates (29 directly)\u27e83\u27e9\n**MIT OR Apache-2.0 OR Zlib**\n425KB  9K  SLoC\n![crates.io\u27e84\u27e9](https://crates.io/crates/ultraviolet) ![docs.rs\u27e85\u27e9](https://docs.rs/ultraviolet)\n# ``ultraviolet``\nThis is a crate to computer-graphics and games-related linear and geometric algebra, but _fast_ , both in terms of productivity and in terms of runtime performance.\nIn terms of productivity, ultraviolet uses no generics and is designed to be as straightforward of an interface as possible, resulting in fast compilation times and clear code. In addition, the lack of generics and Rust type-system \"hacks\" result in clear and concise errors that are easy to parse and fix for the user.\nIn terms of runtime performance, ultraviolet was designed from the start with performance in mind. To do so, we provide two separate kinds of each type, each with nearly identical functionality, one with usual scalar f32 values, and the other a 'wide' type which uses SIMD f32x4 vectors for each value. This design is clear and explicit in intent, and it also allows code to take full advantage of SIMD.\nThe 'wide' types use an \"SoA\" (Structure of Arrays) architecture such that each wide data structure actually contains the data for 4 or 8 of its associated data type and will do any operation on all of the simd 'lanes' at the same time. For example, a ``Vec3x8`` is equivalent to 8 ``Vec3``s all bundled together into one data structure.\nDoing this is potentially _much_ (factor of 10) faster than an standard \"AoS\" (Array of Structs) layout, though it does depend on your workload and algorithm requirements. Algorithms must be carefully architected to take full advantage of this, and doing so can be easier said than done, especially if your algorithm involves significant branching.\n``ultraviolet`` was the first Rust math library to be designed in this \"AoSoA\" manner, though ``nalgebra`` now supports it for several of their data structures as well.\n## Benchmarks\nSee ``mathbench-rs``\u27e86\u27e9 for latest benchmarks (may not be fully up-to-date with git master).\n## Cargo Features\nTo help further improve build times, ``ultraviolet`` puts various functionality under feature flags. For example, the 2d and 3d projective geometric algebras as well as f64 and integer types are disabled by default. In order to enable them, enable the corresponding crate feature flags in your ``Cargo.toml``. For example:\n```\n```[``dependencies``]`\n`ultraviolet = { version = \"0.9\", features ``=` ``[` ``\"`f64`\"``, ``\"`int`\"`` `]`` }\n``\n```\n\nWill enable the ```f64``` and ``int`` features. Here's a list of the available features:\n  * ```f64``` \u2013 Enable ```f64``` bit wide floating point support. Naming convention is ``D`[`Type`]```, such as ``DVec3x4`` would be a collection of 4 3d vectors with ```f64``` precision each.\n  * ``int`` \u2013 Enable integer vector types.\n  * ``bytemuck`` \u2013 Enable casting of many types to byte arrays, for use with graphics APIs.\n  * ``mint`` \u2013 Enable interoperation with other math crates through the ``mint`` interface.\n  * ``num-traits`` \u2013 Enable identity traits\u27e87\u27e9 for interoperation with other math crates.\n  * ``serde`` \u2013 Enable ``Serialize`` and ``Deserialize`` implementations for many scalar types.\n\n\n## Crate Features\nThis crate is currently being dogfooded in my ray tracer ``rayn``\u27e88\u27e9, and is being used by various independent Rust game developers for various projects. It does what those users have currently needed it to do.\nThere are a couple relatively unique/novel features in this library, the most important being the use of the Geometric Algebra.\nInstead of implementing complex number algebra (for 2d rotations) and Quaternion algebra (for 3d rotations), we use Rotors, a concept taken from Geometric Algebra, to represent 2d and 3d rotations.\nWhat this means for the programmer is that you will be using the ``Rotor3`` type in place of a Quaternion, though you can expect it to do basically all the same things that a Quaternion does. In fact, Quaternions are directly isomorphic to Rotors (meaning they are in essense the same thing, just formulated differently). The reason this decision was made was twofold: first, the derivation of the math is actually quite simple to understand. All the derivations for the code implemented in the Rotor structs in this library are written out in the ``derivations`` folder of the GitHub repo; I derived them manually as part of the implementation.\nOn the other hand, Quaternions are often basically just seen as black boxes that we programmers use to do rotations because they have some nice properties, but that we don't really understand. You can use Rotors this same way, but you can also easily understand them. Second is that in some sense they can be seen as 'more correct' than Quaternions. Specifically, they facilitate a more proper understanding of rotation as being something that occurs _within a plane_ rather than something that occurs _around an axis_ , as it is generally thought. Finally, Rotors also generalize to 4 and even higher dimensions, and if someone wants to they could implement a Rotor4 which retains all the properties of a Rotor3/Quaternion but does rotation in 4 dimensions instead, something which simply is not possible to do with Quaternions.\nIf it's missing something you need it to do, bug me on the GitHub issue tracker\u27e89\u27e9 and/or Rust community discord server (I'm Fusha there) and I'll try to add it for you, if I believe it fits with the vision of the lib :)\n## Examples\n### Euler Integration\nEuler Integration\u27e810\u27e9 is a method for numerically solving ordinary differential equations. If that sounds complicated, don't worry! The details of the method don't matter if you're not looking to implement any kind of physics simulation but this method is common in games. Keep reading for the code below!\nThe point is that if you are doing the same basic math operations on multiple floating point values with no conditionals (no ```if```s), porting to wide data types and parallel processing is quite simple.\nHere is the scalar example of Euler Integration:\n```\n```fn` `integrate`````(`\n  `pos``:` `&``mut` [`uv`::``Vec3],\n  `vel``:` `&``mut` [`uv`::``Vec3],\n  `acc``:` `&`[`uv`::``Vec3],\n  `dt``:` `f32`,\n```)``````{`\n  `for` `(``(`position`,` velocity`)``,` acceleration`)` `in` pos`.``iter_mut``(``)``.``zip``(`vel`)``.``zip``(`acc`)` `{`\n    `*`velocity `=` `*`velocity `+` `*`acceleration `*` dt`;`\n    `*`position `=` `*`position `+` `*`velocity `*` dt`;`\n  `}`\n```}```\n`\n```\n\nThe code loops over each set of corresponding position, velocity, and acceleration vectors. It first adjusts the velocity by the acceleration scaled by the amount of time that has passed and then adjusts the position by the velocity scaled by the amount of time that has passed.\nThese are all multiplication, addition, and assignment operators that need to be applied in the same way to all of the variables in question.\nTo port this function to wide data types and parallel processing, all we have to do is change the data types and we're done! The new function looks like this:\n```\n```fn` `integrate_x8`````(`\n  `pos``:` `&``mut` [`uv`::``Vec3x8],\n  `vel``:` `&``mut` [`uv`::``Vec3x8],\n  `acc``:` `&`[`uv`::``Vec3x8],\n  `dt``:` f32x8,\n```)``````{`\n  `for` `(``(`position`,` velocity`)``,` acceleration`)` `in` pos`.``iter_mut``(``)``.``zip``(`vel`)``.``zip``(`acc`)` `{`\n    `*`velocity `=` `*`velocity `+` `*`acceleration `*` dt`;`\n    `*`position `=` `*`position `+` `*`velocity `*` dt`;`\n  `}`\n```}```\n`\n```\n\nThis function now processes 8 sets of vectors in parallel and brings significant speed gains!\nThe only caveat is that the calling code that creates the slices of vectors needs to be modified to populate these wide data types with 8 sets of values instead of just one. The scalar code for that looks like this:\n```\n``let` `mut` pos`:` ``Vec``<``uv`::``Vec3`>`` `=` `Vec```::``with_capacity`(``100``)``;`\n`let` `mut` vel`:` ``Vec``<``uv`::``Vec3`>`` `=` `Vec```::``with_capacity`(``100``)``;`\n`let` `mut` acc`:` ``Vec``<``uv`::``Vec3`>`` `=` `Vec```::``with_capacity`(``100``)``;`\n``//` You would probably write these constant values in-line but`\n``//` they are here for illustrative purposes`\n`let` pos_x `=` `1.``0``f32``;`\n`let` pos_y `=` `2.``0``f32``;`\n`let` pos_z `=` `3.``0``f32``;`\n`let` vel_x `=` `4.``0``f32``;`\n`let` vel_y `=` `5.``0``f32``;`\n`let` vel_z `=` `6.``0``f32``;`\n`let` acc_x `=` `7.``0``f32``;`\n`let` acc_y `=` `8.``0``f32``;`\n`let` acc_z `=` `9.``0``f32``;`\n`for` `(``(`position`,` velocity`)``,` acceleration`)` `in` pos`.``iter_mut``(``)``.``zip``(`vel`)``.``zip``(`acc`)` ``{`\n  pos`.``push``(``uv`::```Vec3`::``new`(`pos_x`,` pos_y`,` pos_z`)``)``;`\n  vel`.``push``(``uv`::```Vec3`::``new`(`vel_x`,` vel_y`,` vel_z`)``)``;`\n  acc`.``push``(``uv`::```Vec3`::``new`(`acc_x`,` acc_y`,` acc_z`)``)``;`\n```}``\n`\n```\n\nWhereas to populate the same for the 8-lane wide ``Vec3x8`` data type, the code could look like this:\n```\n``let` `mut` pos`:` ``Vec``<``uv`::``Vec3x8`>`` `=` `Vec```::``with_capacity`(``100` `/` `8` `+` `1``)``;`\n`let` `mut` vel`:` ``Vec``<``uv`::``Vec3x8`>`` `=` `Vec```::``with_capacity`(``100` `/` `8` `+` `1``)``;`\n`let` `mut` acc`:` ``Vec``<``uv`::``Vec3x8`>`` `=` `Vec```::``with_capacity`(``100` `/` `8` `+` `1``)``;`\n`let` pos_x `=` `uv`::```f32x8`::``splat`(``1.``0``f32``)``;`\n`let` pos_y `=` `uv`::```f32x8`::``splat`(``2.``0``f32``)``;`\n`let` pos_z `=` `uv`::```f32x8`::``splat`(``3.``0``f32``)``;`\n`let` vel_x `=` `uv`::```f32x8`::``splat`(``4.``0``f32``)``;`\n`let` vel_y `=` `uv`::```f32x8`::``splat`(``5.``0``f32``)``;`\n`let` vel_z `=` `uv`::```f32x8`::``splat`(``6.``0``f32``)``;`\n`let` acc_x `=` `uv`::```f32x8`::``splat`(``7.``0``f32``)``;`\n`let` acc_y `=` `uv`::```f32x8`::``splat`(``8.``0``f32``)``;`\n`let` acc_z `=` `uv`::```f32x8`::``splat`(``9.``0``f32``)``;`\n`for` `(``(`position`,` velocity`)``,` acceleration`)` `in` pos`.``iter_mut``(``)``.``zip``(`vel`)``.``zip``(`acc`)` ``{`\n  pos`.``push``(``uv`::```Vec3x8`::``new`(`pos_x`,` pos_y`,` pos_z`)``)``;`\n  vel`.``push``(``uv`::```Vec3x8`::``new`(`vel_x`,` vel_y`,` vel_z`)``)``;`\n  acc`.``push``(``uv`::```Vec3x8`::``new`(`acc_x`,` acc_y`,` acc_z`)``)``;`\n```}``\n`\n```\n\nNote that ```100` `/` `8``` in maths terms would be ```12.``5```, but we can't conveniently have a half-sized ``Vec3x8``.\nThere are various ways to handle these 'remainder' vectors. You could fall back to scalar code, or progressively fall back to narrower wide types, such as ``Vec3x4``, or you can just consider whether the cost of calculating a few additional vectors that you won't use is worth adding complexity to your code.\n### Ray-Sphere Intersection\nScalar code that operates on a single value at a time needs some restructuring to take advantage of SIMD and the 4-/8-wide data types.\nBelow is an example of scalar ray-sphere instersection code using ``Vec3`` for points and vectors:\n```\n```fn` `ray_sphere_intersect`````(`\n  `ray_o``:` `uv`::``Vec3,\n  `ray_d``:` `uv`::``Vec3,\n  `sphere_o``:` `uv`::``Vec3,\n  `sphere_r_sq``:` `f32`,\n```)```` ``->` `f32`` ````{`\n  `let` oc `=` ray_o `-` sphere_o`;`\n  `let` b `=` oc`.``dot``(`ray_d`)``;`\n  `let` c `=` oc`.``mag_sq``(``)` `-` sphere_r_sq`;`\n  `let` descrim `=` b `*` b `-` c`;`\n  `if` descrim `>` `0.``0` `{`\n    `let` desc_sqrt `=` descrim`.``sqrt``(``)``;`\n    `let` t1 `=` `-`b `-` desc_sqrt`;`\n    `if` t1 `>` `0.``0` `{`\n      t1\n    `}` `else` `{`\n      `let` t2 `=` `-`b `+` desc_sqrt`;`\n      `if` t2 `>` `0.``0` `{`\n        t2\n      `}` `else` `{`\n        `f32```::```MAX`\n      `}`\n    `}`\n  `}` `else` `{`\n    `f32```::```MAX`\n  `}`\n```}```\n`\n```\n\nThis porting guide will not discuss the details of the algorithm, but will focus on how to convert the code to apply parallel SIMD operations on wide data types.\nThe first thing to do is to convert the parameter and return types from scalar ``Vec3`` to wide ``Vec3x8`` and ``f32x8``:\n```\n```fn` `ray_sphere_intersect_x8`````(`\n  `ray_o``:` `uv`::``Vec3x8,\n  `ray_d``:` `uv`::``Vec3x8,\n  `sphere_o``:` `uv`::``Vec3x8,\n  `sphere_r_sq``:` `uv`::``f32x8,\n```)```` ``->` `uv`::``f32x8` ````{`\n```\n```\n\nEach call to the function will process 8 ray-sphere intersections in parallel. The first four lines of the function remain the same:\n```\n`  `let` oc `=` ray_o `-` sphere_o`;`\n  `let` b `=` oc`.``dot``(`ray_d`)``;`\n  `let` c `=` oc`.``mag_sq``(``)` `-` sphere_r_sq`;`\n  `let` descrim `=` b `*` b `-` c`;`\n`\n```\n\nDespite this code being the same, the calculations for 8 rays and spheres will be carried out at the same time!\nThe next line of the scalar code tests the value of ``descrim`` to see if it is greater than ```0.``0```. When operating on 8 values at a time, the code cannot branch along two separate paths because the value of ``descrim`` for each of the 8 values may cause branching to different sets of operations. To support this we would need to convert back to scalar code and then we lose all the performance benefits of parallel processing.\nSo, how do we convert this? We have a tradeoff to consider depending on the frequency of divergence, that is depending on how often the branch will follow one or the other path. If it is very likely for the given data and algorithm that the majority of branches will take one path, we can check whether all lanes take that path and then branch based on that. Such a bias toward one branch path is relatively rare, and in the case of this algorithm it is common to branch either way so this approach would produce slower code.\nAnother approach is to calculate the results for both branches for all 8 lanes, and then filter the results with masks that select the correct values from the possibilities at the end.\nTo create the mask for 8 lanes of ``descrim`` values with ```0.``0```:\n```\n`  `let` desc_pos `=` descrim`.``cmp_gt``(``uv`::```f32x8`::``splat`(``0.``0``)``)``;`\n`\n```\n\nIn the true case of the original scalar version, we then have more arithmetic operations that end up looking the exact same when we do them on the vectorized version:\n```\n`  `let` desc_sqrt `=` descrim`.``sqrt``(``)``;`\n  `let` t1 `=` `-`b `-` desc_sqrt`;`\n`\n```\n\nAnd now in the scalar code we have another branch based on ``t1 `>` `0.``0```, so we apply the same technique, with a little bit extra:\n```\n`  `let` t1_valid `=` t1`.``cmp_gt``(``uv`::```f32x8`::``splat`(``0.``0``)``)` `&` desc_pos`;`\n`\n```\n\nThe ```&` desc_pos`` at the end does a bitwise and operation to combine the masks that say whether each of the lanes of ``t1 `>` `0.``0``` are true or false, with those of whether each of the lanes of ``descrim `>` `0.``0``` were true or false, and if both are true for a lane, then the mask value will be true for that lane in ``t1_mask``, otherwise the value for the lane will be ```false```. This is combining the nested logic.\nThe true case of the ``t1 `>` `0.``0``` condition just returns ``t1``, but the false case has some more calculation and branching that can be ported in a similar way:\n```\n`  `let` t2 `=` `-`b `+` desc_sqrt`;`\n  `let` t2_valid `=` t2`.``cmp_gt``(``uv`::```f32x8`::``splat`(``0.``0``)``)` `&` desc_pos`;`\n`\n```\n\nThis may sound like it could be slower than scalar code because this algorithm being applied to wide data types is doing all the calculations for both branches regardless of which is true, and you would be right!\nThis approach is indeed a tradeoff and depends on the likelihood of branching one way or the other, and the cost of calculation of the branches. However, even with an algorithm that is particularly branch-heavy like the ray-sphere intersection we're analyzing here, in practice, the benefits of being able to calculate multiple pieces of data simultaneously often results in a net win! As with all optimization, measurement tells the truth.\nAt this point, we have ported almost the entire algorithm. We have values for ``t1`` and ``t2`` for each of the 8 lanes. We have mask values in ``t1_valid`` that indicate whether both ``descrim `>` `0.``0` `&&` t1 `>` `0.``0``` for each lane. And we have ``t2_valid`` with values indicating exactly ``descrim `>` `0.``0` `&&` t2 `>` `0.``0```. When the scalar code does not return ``t1`` or ``t2``, it returns ```f32```::```MAX```. How do we now select the correct return value for each of the lanes?\n``ultraviolet`` has a ``blend`` function on the mask types that uses the true or false values for each of the lanes to select from the calculated values for the true and false cases. So if ``a`` were a wide vector of values that would be calculated in the true case of a branch, and ``b`` were for the false case, with a mask ``m`` we could select from ``a`` and ``b`` based on ``m`` by calling ``m`.``blend``(`a`,` b`)``` and the result would be the desired output values!\nLet's try to apply that to the scalar code by looking just at its logical control flow:\n```\n`  `if` descrim `>` `0.``0` ``{`\n    `if` t1 `>` `0.``0` `{`\n      t1\n    `}` `else` `{`\n      `if` t2 `>` `0.``0` `{`\n        t2\n      `}` `else` `{`\n        `f32```::```MAX`\n      `}`\n    `}`\n  ```}`` `else` ``{`\n    `f32```::```MAX`\n  ```}``\n`\n```\n\nSo if we take the outer-most if condition..\n```\n`  `let` t `=` t1_valid`.``blend``(`t1`,` `?``?``?``)``;`\n`\n```\n\nWhat is the value for false case of the ``descrim `>` `0.``0` `&&` t1 `>` `0.``0``` test? There are two possibilities - either ``descrim `<=` `0.``0```, which is the false case of the ``descrim `>` `0.``0``` condition, or ``descrim `>` `0.``0` `&&` t1 `<=` `0.``0``` which is the else case where we handle ``t2``. This looks complicated. Let's try looking at the ``descrim `>` `0.``0` `&&` t2 `>` `0.``0``` case in the scalar code and try ``blend``ing that:\n```\n`  `let` t `=` t2_valid`.``blend``(`t2`,` `uv`::```f32x8`::``splat`(``std`::```f32`::```MAX``)``)``;`\n`\n```\n\nSo ``descrim `>` `0.``0` `&&` t2 `>` `0.``0``` has two false cases, either ``descrim `<=` `0.``0``` and we want to return ```f32```::```MAX```, or ``descrim `>` `0.``0` `&&` t2 `<=` `0.``0``` and we want to return ```f32```::```MAX```, so we can ``blend`` to select the correct values here to cover the false case of the scalar ``descrim `>` `0.``0``` condition, and the false case of the ``t1 `>` `0.``0``` condition, that leaves only the true case of the ``t1 `>` `0.``0``` condition left to resolve...\nAnd that is exactly what ``t1_valid`.``blend``(`t1`,` `?``?``?``)``` would select! So we can combine the two blends like this:\n```\n`  `let` t `=` t2_valid`.``blend``(`t2`,` `uv`::```f32x8`::``splat`(``std`::```f32`::```MAX``)``)``;`\n  `let` t `=` t1_valid`.``blend``(`t1`,` t`)``;`\n`\n```\n\n``t`` now contains ``t1``, ``t2`` or ```f32```::```MAX``` as appropriate for each of the lanes! We have completed the port of the scalar algorithm code to leverage SIMD operations on 8-lane wide data types to calculate 8 ray-sphere intersections in parallel!\nBelow is the full example of the same ray-sphere intersection algorithm implemented using the wide ``Vec3x8`` type:\n```\n```fn` `ray_sphere_intersect_x8`````(`\n  `sphere_o``:` `uv`::``Vec3x8,\n  `sphere_r_sq``:` `uv`::``f32x8,\n  `ray_o``:` `uv`::``Vec3x8,\n  `ray_d``:` `uv`::``Vec3x8,\n```)```` ``->` `uv`::``f32x8` ````{`\n  `let` oc `=` ray_o `-` sphere_o`;`\n  `let` b `=` oc`.``dot``(`ray_d`)``;`\n  `let` c `=` oc`.``mag_sq``(``)` `-` sphere_r_sq`;`\n  `let` descrim `=` b `*` b `-` c`;`\n  `let` desc_pos `=` descrim`.``cmp_gt``(``uv`::```f32x8`::``splat`(``0.``0``)``)``;`\n  `let` desc_sqrt `=` descrim`.``sqrt``(``)``;`\n  `let` t1 `=` `-`b `-` desc_sqrt`;`\n  `let` t1_valid `=` t1`.``cmp_gt``(``uv`::```f32x8`::``splat`(``0.``0``)``)` `&` desc_pos`;`\n  `let` t2 `=` `-`b `+` desc_sqrt`;`\n  `let` t2_valid `=` t2`.``cmp_gt``(``uv`::```f32x8`::``splat`(``0.``0``)``)` `&` desc_pos`;`\n  `let` t `=` t2_valid`.``blend``(`t2`,` `uv`::```f32x8`::``splat`(``std`::```f32`::```MAX``)``)``;`\n  `let` t `=` t1_valid`.``blend``(`t1`,` t`)``;`\n  t\n```}```\n`\n```\n\n#### Dependencies\n~1.5MB  ~27K SLoC\n  *  optional \u27e811\u27e9 bytemuck\u27e812\u27e9\n  *  optional \u27e813\u27e9 mint\u27e814\u27e9\n  *  optional \u27e815\u27e9 num-traits\u27e816\u27e9\n  *  optional \u27e817\u27e9 serde\u27e818\u27e9\n  * wide\u27e819\u27e9\n\n\n  * dev  serde_test\u27e820\u27e9\n\n\n#### Other features\u27e821\u27e9\n  * f64\u27e822\u27e9\n  * int\u27e823\u27e9\n\n\n  *[SLoC]: approx. additional lines of code\n",
              "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://lib.rs/crates/ultraviolet/versions: 46 releases\n\u27e82\u27e9 https://lib.rs/science/math: Crates related to solving mathematical problems. - Math\n\u27e83\u27e9 https://lib.rs/crates/ultraviolet/rev: **102** crates (29 directly)\n\u27e84\u27e9 https://img.shields.io/crates/v/ultraviolet.svg: ![crates.io\n\u27e85\u27e9 https://img.gs/czjpqfbdkz/full/https://docs.rs/ultraviolet/badge.svg: ![docs.rs\n\u27e86\u27e9 https://github.com/bitshifter/mathbench-rs: ``mathbench-rs``\n\u27e87\u27e9 https://docs.rs/num-traits/latest/num_traits/identities/index.html: identity traits\n\u27e88\u27e9 https://github.com/termhn/rayn: ``rayn``\n\u27e89\u27e9 https://github.com/termhn/ultraviolet/issues: GitHub issue tracker\n\u27e810\u27e9 https://en.wikipedia.org/wiki/Euler_method: Euler Integration\n\u27e811\u27e9 https://lib.rs/crates/ultraviolet/features#feature-bytemuck: bytemuck is optional feature -  optional \n\u27e812\u27e9 https://lib.rs/crates/bytemuck: 1.22 - bytemuck\n\u27e813\u27e9 https://lib.rs/crates/ultraviolet/features#feature-mint: mint is optional feature -  optional \n\u27e814\u27e9 https://lib.rs/crates/mint: 0.5 - mint\n\u27e815\u27e9 https://lib.rs/crates/ultraviolet/features#feature-num-traits: num-traits is optional feature -  optional \n\u27e816\u27e9 https://lib.rs/crates/num-traits: 0.2 - num-traits\n\u27e817\u27e9 https://lib.rs/crates/ultraviolet/features#feature-serde: serde is optional feature -  optional \n\u27e818\u27e9 https://lib.rs/crates/serde: 1.0 - serde\n\u27e819\u27e9 https://lib.rs/crates/wide: 0.7 - wide\n\u27e820\u27e9 https://lib.rs/crates/serde_test: 1.0 - serde_test\n\u27e821\u27e9 https://lib.rs/crates/ultraviolet/features: Other features\n\u27e822\u27e9 https://lib.rs/crates/ultraviolet/features#feature-f64: f64\n\u27e823\u27e9 https://lib.rs/crates/ultraviolet/features#feature-int: int\n",
              "fit_markdown": "",
              "fit_html": ""
            },
            "structured_data": {},
            "quality_score": 3.0,
            "extraction_method": "crawl4ai",
            "error": null,
            "metadata": {
              "doc_type": "docs",
              "content_length": 21940,
              "has_structured_data": false,
              "crawl_success": true
            },
            "timestamp": "119589.9227333"
          }
        },
        "crate_analysis": {
          "status": "completed",
          "check": [
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#bytemuck@1.22.0",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\bytemuck-1.22.0\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "bytemuck",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\bytemuck-1.22.0\\src\\lib.rs",
                "edition": "2018",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpykcp88jo\\ultraviolet-0.10.0\\target\\debug\\deps\\libbytemuck-89435c95c037c5a1.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#safe_arch@0.6.0",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\safe_arch-0.6.0\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "safe_arch",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\safe_arch-0.6.0\\src\\lib.rs",
                "edition": "2018",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "bytemuck",
                "default"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpykcp88jo\\ultraviolet-0.10.0\\target\\debug\\deps\\libsafe_arch-d78784caadf3a1ad.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#wide@0.7.8",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\wide-0.7.8\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "wide",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\wide-0.7.8\\src\\lib.rs",
                "edition": "2018",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "default",
                "std"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpykcp88jo\\ultraviolet-0.10.0\\target\\debug\\deps\\libwide-b711ba7a32620bdb.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "compiler-artifact",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpykcp88jo/ultraviolet-0.10.0#ultraviolet@0.10.0",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpykcp88jo\\ultraviolet-0.10.0\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "ultraviolet",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpykcp88jo\\ultraviolet-0.10.0\\src\\lib.rs",
                "edition": "2018",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "default"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpykcp88jo\\ultraviolet-0.10.0\\target\\debug\\deps\\libultraviolet-7a47ae803e91a990.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "build-finished",
              "success": true
            }
          ],
          "clippy": [
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#bytemuck@1.22.0",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\bytemuck-1.22.0\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "bytemuck",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\bytemuck-1.22.0\\src\\lib.rs",
                "edition": "2018",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpykcp88jo\\ultraviolet-0.10.0\\target\\debug\\deps\\libbytemuck-89435c95c037c5a1.rmeta"
              ],
              "executable": null,
              "fresh": true
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#safe_arch@0.6.0",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\safe_arch-0.6.0\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "safe_arch",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\safe_arch-0.6.0\\src\\lib.rs",
                "edition": "2018",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "bytemuck",
                "default"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpykcp88jo\\ultraviolet-0.10.0\\target\\debug\\deps\\libsafe_arch-d78784caadf3a1ad.rmeta"
              ],
              "executable": null,
              "fresh": true
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#wide@0.7.8",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\wide-0.7.8\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "wide",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\wide-0.7.8\\src\\lib.rs",
                "edition": "2018",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "default",
                "std"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpykcp88jo\\ultraviolet-0.10.0\\target\\debug\\deps\\libwide-b711ba7a32620bdb.rmeta"
              ],
              "executable": null,
              "fresh": true
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpykcp88jo/ultraviolet-0.10.0#ultraviolet@0.10.0",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpykcp88jo\\ultraviolet-0.10.0\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "ultraviolet",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpykcp88jo\\ultraviolet-0.10.0\\src\\lib.rs",
                "edition": "2018",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "error: variables can be used directly in the `format!` string\n  --> src\\util.rs:46:13\n   |\n46 | /             println!(\n47 | |                 \"{} should equal {} with epsilon 0.01 but doesn't.\",\n48 | |                 self, other\n49 | |             );\n   | |_____________^\n   |\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#uninlined_format_args\nnote: the lint level is defined here\n  --> src\\lib.rs:86:5\n   |\n86 |     clippy::all\n   |     ^^^^^^^^^^^\n   = note: `#[deny(clippy::uninlined_format_args)]` implied by `#[deny(clippy::all)]`\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#uninlined_format_args",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "note",
                    "message": "the lint level is defined here",
                    "rendered": null,
                    "spans": [
                      {
                        "byte_end": 5770,
                        "byte_start": 5759,
                        "column_end": 16,
                        "column_start": 5,
                        "expansion": null,
                        "file_name": "src\\lib.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 86,
                        "line_start": 86,
                        "suggested_replacement": null,
                        "suggestion_applicability": null,
                        "text": [
                          {
                            "highlight_end": 16,
                            "highlight_start": 5,
                            "text": "    clippy::all"
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "note",
                    "message": "`#[deny(clippy::uninlined_format_args)]` implied by `#[deny(clippy::all)]`",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "change this to",
                    "rendered": null,
                    "spans": [
                      {
                        "byte_end": 909,
                        "byte_start": 909,
                        "column_end": 19,
                        "column_start": 19,
                        "expansion": null,
                        "file_name": "src\\util.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 47,
                        "line_start": 47,
                        "suggested_replacement": "self",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 19,
                            "highlight_start": 19,
                            "text": "                \"{} should equal {} with epsilon 0.01 but doesn't.\","
                          }
                        ]
                      },
                      {
                        "byte_end": 925,
                        "byte_start": 925,
                        "column_end": 35,
                        "column_start": 35,
                        "expansion": null,
                        "file_name": "src\\util.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 47,
                        "line_start": 47,
                        "suggested_replacement": "other",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 35,
                            "highlight_start": 35,
                            "text": "                \"{} should equal {} with epsilon 0.01 but doesn't.\","
                          }
                        ]
                      },
                      {
                        "byte_end": 980,
                        "byte_start": 958,
                        "column_end": 21,
                        "column_start": 68,
                        "expansion": null,
                        "file_name": "src\\util.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 48,
                        "line_start": 47,
                        "suggested_replacement": "",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 69,
                            "highlight_start": 68,
                            "text": "                \"{} should equal {} with epsilon 0.01 but doesn't.\","
                          },
                          {
                            "highlight_end": 21,
                            "highlight_start": 1,
                            "text": "                self, other"
                          }
                        ]
                      },
                      {
                        "byte_end": 987,
                        "byte_start": 980,
                        "column_end": 28,
                        "column_start": 21,
                        "expansion": null,
                        "file_name": "src\\util.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 48,
                        "line_start": 48,
                        "suggested_replacement": "",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 28,
                            "highlight_start": 21,
                            "text": "                self, other"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "code": {
                  "code": "clippy::uninlined_format_args",
                  "explanation": null
                },
                "level": "error",
                "message": "variables can be used directly in the `format!` string",
                "spans": [
                  {
                    "byte_end": 1001,
                    "byte_start": 881,
                    "column_end": 14,
                    "column_start": 13,
                    "expansion": null,
                    "file_name": "src\\util.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 49,
                    "line_start": 46,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 22,
                        "highlight_start": 13,
                        "text": "            println!("
                      },
                      {
                        "highlight_end": 69,
                        "highlight_start": 1,
                        "text": "                \"{} should equal {} with epsilon 0.01 but doesn't.\","
                      },
                      {
                        "highlight_end": 28,
                        "highlight_start": 1,
                        "text": "                self, other"
                      },
                      {
                        "highlight_end": 14,
                        "highlight_start": 1,
                        "text": "            );"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpykcp88jo/ultraviolet-0.10.0#ultraviolet@0.10.0",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpykcp88jo\\ultraviolet-0.10.0\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "ultraviolet",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpykcp88jo\\ultraviolet-0.10.0\\src\\lib.rs",
                "edition": "2018",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "error: variables can be used directly in the `format!` string\n  --> src\\util.rs:61:13\n   |\n61 | /             println!(\n62 | |                 \"{} should equal {} with epsilon 0.01 but doesn't.\",\n63 | |                 self, other\n64 | |             );\n   | |_____________^\n   |\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#uninlined_format_args\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#uninlined_format_args",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "change this to",
                    "rendered": null,
                    "spans": [
                      {
                        "byte_end": 1249,
                        "byte_start": 1249,
                        "column_end": 19,
                        "column_start": 19,
                        "expansion": null,
                        "file_name": "src\\util.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 62,
                        "line_start": 62,
                        "suggested_replacement": "self",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 19,
                            "highlight_start": 19,
                            "text": "                \"{} should equal {} with epsilon 0.01 but doesn't.\","
                          }
                        ]
                      },
                      {
                        "byte_end": 1265,
                        "byte_start": 1265,
                        "column_end": 35,
                        "column_start": 35,
                        "expansion": null,
                        "file_name": "src\\util.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 62,
                        "line_start": 62,
                        "suggested_replacement": "other",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 35,
                            "highlight_start": 35,
                            "text": "                \"{} should equal {} with epsilon 0.01 but doesn't.\","
                          }
                        ]
                      },
                      {
                        "byte_end": 1320,
                        "byte_start": 1298,
                        "column_end": 21,
                        "column_start": 68,
                        "expansion": null,
                        "file_name": "src\\util.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 63,
                        "line_start": 62,
                        "suggested_replacement": "",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 69,
                            "highlight_start": 68,
                            "text": "                \"{} should equal {} with epsilon 0.01 but doesn't.\","
                          },
                          {
                            "highlight_end": 21,
                            "highlight_start": 1,
                            "text": "                self, other"
                          }
                        ]
                      },
                      {
                        "byte_end": 1327,
                        "byte_start": 1320,
                        "column_end": 28,
                        "column_start": 21,
                        "expansion": null,
                        "file_name": "src\\util.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 63,
                        "line_start": 63,
                        "suggested_replacement": "",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 28,
                            "highlight_start": 21,
                            "text": "                self, other"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "code": {
                  "code": "clippy::uninlined_format_args",
                  "explanation": null
                },
                "level": "error",
                "message": "variables can be used directly in the `format!` string",
                "spans": [
                  {
                    "byte_end": 1341,
                    "byte_start": 1221,
                    "column_end": 14,
                    "column_start": 13,
                    "expansion": null,
                    "file_name": "src\\util.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 64,
                    "line_start": 61,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 22,
                        "highlight_start": 13,
                        "text": "            println!("
                      },
                      {
                        "highlight_end": 69,
                        "highlight_start": 1,
                        "text": "                \"{} should equal {} with epsilon 0.01 but doesn't.\","
                      },
                      {
                        "highlight_end": 28,
                        "highlight_start": 1,
                        "text": "                self, other"
                      },
                      {
                        "highlight_end": 14,
                        "highlight_start": 1,
                        "text": "            );"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "build-finished",
              "success": false
            }
          ],
          "audit": {
            "database": {
              "advisory-count": 787,
              "last-commit": "7573f55ba337263f61167dbb0ea926cdc7c8eb5d",
              "last-updated": "2025-06-17T11:04:25+02:00"
            },
            "lockfile": {
              "dependency-count": 9
            },
            "settings": {
              "target_arch": [],
              "target_os": [],
              "severity": null,
              "ignore": [],
              "informational_warnings": [
                "unmaintained",
                "unsound",
                "notice"
              ]
            },
            "vulnerabilities": {
              "found": false,
              "count": 0,
              "list": []
            },
            "warnings": {}
          },
          "note": "Crate analysis performed with stable toolchain."
        },
        "crate_metadata": {
          "name": "ultraviolet",
          "version": "0.10.0",
          "description": "ALLOW: Positive community sentiment",
          "repository": "",
          "keywords": [],
          "categories": [],
          "readme": {
            "raw_markdown": "[](https://docs.rs/ultraviolet/latest/ultraviolet/all.html \"show sidebar\")\n# Crate ultravioletCopy item path\n[Settings](https://docs.rs/ultraviolet/latest/settings.html)\n[Help](https://docs.rs/ultraviolet/latest/help.html)\nSummary[Source](https://docs.rs/ultraviolet/latest/src/ultraviolet/lib.rs.html#1-139)\nExpand description\n## [\u00a7](https://docs.rs/ultraviolet/latest/ultraviolet/#ultraviolet)`ultraviolet`\nThis is a crate to computer-graphics and games-related linear and geometric algebra, but _fast_ , both in terms of productivity and in terms of runtime performance.\nIn terms of productivity, ultraviolet uses no generics and is designed to be as straightforward of an interface as possible, resulting in fast compilation times and clear code. In addition, the lack of generics and Rust type-system \u201chacks\u201d result in clear and concise errors that are easy to parse and fix for the user.\nIn terms of runtime performance, ultraviolet was designed from the start with performance in mind. To do so, we provide two separate kinds of each type, each with nearly identical functionality, one with usual scalar f32 values, and the other a \u2018wide\u2019 type which uses SIMD f32x4 vectors for each value. This design is clear and explicit in intent, and it also allows code to take full advantage of SIMD.\nThe \u2018wide\u2019 types use an \u201cSoA\u201d (Structure of Arrays) architecture such that each wide data structure actually contains the data for 4 or 8 of its associated data type and will do any operation on all of the simd \u2018lanes\u2019 at the same time. For example, a `Vec3x8` is equivalent to 8 `Vec3`s all bundled together into one data structure.\nDoing this is potentially _much_ (factor of 10) faster than an standard \u201cAoS\u201d (Array of Structs) layout, though it does depend on your workload and algorithm requirements. Algorithms must be carefully architected to take full advantage of this, and doing so can be easier said than done, especially if your algorithm involves significant branching.\n`ultraviolet` was the first Rust math library to be designed in this \u201cAoSoA\u201d manner, though `nalgebra` now supports it for several of their data structures as well.\n### [\u00a7](https://docs.rs/ultraviolet/latest/ultraviolet/#benchmarks)Benchmarks\nSee [`mathbench-rs`](https://github.com/bitshifter/mathbench-rs) for latest benchmarks.\n### [\u00a7](https://docs.rs/ultraviolet/latest/ultraviolet/#cargo-features)Cargo Features\nTo help further improve build times, `ultraviolet` puts various functionality under feature flags. For example, the 2d and 3d projective geometric algebras as well as f64 and integer types are disabled by default. In order to enable them, enable the corresponding crate feature flags in your `Cargo.toml`. For example:\n```\n[dependencies]\nultraviolet = { version = \"0.9\", features = [ \"f64\", \"int\" ] }\n```\n\nWill enable the `f64` and `int` features. Here\u2019s a list of the available features:\n  * `f64` \u2013 Enable `f64` bit wide floating point support. Naming convention is `D[Type]`, such as `DVec3x4` would be a collection of 4 3d vectors with `f64` precision each.\n  * `int` \u2013 Enable integer vector types.\n  * `bytemuck` \u2013 Enable casting of many types to byte arrays, for use with graphics APIs.\n  * `mint` \u2013 Enable interoperation with other math crates through the `mint` interface.\n  * `num-traits` \u2013 Enable [identity traits](https://docs.rs/num-traits/latest/num_traits/identities/index.html) for interoperation with other math crates.\n  * `serde` \u2013 Enable `Serialize` and `Deserialize` implementations for many scalar types.\n\n\n### [\u00a7](https://docs.rs/ultraviolet/latest/ultraviolet/#crate-features)Crate Features\nThis crate is currently being dogfooded in my ray tracer [`rayn`](https://github.com/termhn/rayn), and is being used by various independent Rust game developers for various projects. It does what those users have currently needed it to do.\nThere are a couple relatively unique/novel features in this library, the most important being the use of the Geometric Algebra.\nInstead of implementing complex number algebra (for 2d rotations) and Quaternion algebra (for 3d rotations), we use Rotors, a concept taken from Geometric Algebra, to represent 2d and 3d rotations.\nWhat this means for the programmer is that you will be using the `Rotor3` type in place of a Quaternion, though you can expect it to do basically all the same things that a Quaternion does. In fact, Quaternions are directly isomorphic to Rotors (meaning they are in essense the same thing, just formulated differently). The reason this decision was made was twofold: first, the derivation of the math is actually quite simple to understand. All the derivations for the code implemented in the Rotor structs in this library are written out in the `derivations` folder of the GitHub repo; I derived them manually as part of the implementation.\nOn the other hand, Quaternions are often basically just seen as black boxes that we programmers use to do rotations because they have some nice properties, but that we don\u2019t really understand. You can use Rotors this same way, but you can also easily understand them. Second is that in some sense they can be seen as \u2018more correct\u2019 than Quaternions. Specifically, they facilitate a more proper understanding of rotation as being something that occurs _within a plane_ rather than something that occurs _around an axis_ , as it is generally thought. Finally, Rotors also generalize to 4 and even higher dimensions, and if someone wants to they could implement a Rotor4 which retains all the properties of a Rotor3/Quaternion but does rotation in 4 dimensions instead, something which simply is not possible to do with Quaternions.\nIf it\u2019s missing something you need it to do, bug me on the [GitHub issue tracker](https://github.com/termhn/ultraviolet/issues) and/or Rust community discord server (I\u2019m Fusha there) and I\u2019ll try to add it for you, if I believe it fits with the vision of the lib :)\n## Re-exports[\u00a7](https://docs.rs/ultraviolet/latest/ultraviolet/#reexports)\n\n`pub use bivec[](https://docs.rs/ultraviolet/latest/ultraviolet/bivec/index.html \"mod ultraviolet::bivec\")::*;`\n\n\n`pub use conversion[](https://docs.rs/ultraviolet/latest/ultraviolet/conversion/index.html \"mod ultraviolet::conversion\")::*;`\n\n\n`pub use int[](https://docs.rs/ultraviolet/latest/ultraviolet/int/index.html \"mod ultraviolet::int\")::*;`\n\n\n`pub use interp[](https://docs.rs/ultraviolet/latest/ultraviolet/interp/index.html \"mod ultraviolet::interp\")::*;`\n\n\n`pub use mat[](https://docs.rs/ultraviolet/latest/ultraviolet/mat/index.html \"mod ultraviolet::mat\")::*;`\n\n\n`pub use rotor[](https://docs.rs/ultraviolet/latest/ultraviolet/rotor/index.html \"mod ultraviolet::rotor\")::*;`\n\n\n`pub use transform[](https://docs.rs/ultraviolet/latest/ultraviolet/transform/index.html \"mod ultraviolet::transform\")::*;`\n\n\n`pub use vec[](https://docs.rs/ultraviolet/latest/ultraviolet/vec/index.html \"mod ultraviolet::vec\")::*;`\n\n## Modules[\u00a7](https://docs.rs/ultraviolet/latest/ultraviolet/#modules)\n\n[bivec](https://docs.rs/ultraviolet/latest/ultraviolet/bivec/index.html \"mod ultraviolet::bivec\")\n    Bivectors, i.e. oriented areas.\n\n[conversion](https://docs.rs/ultraviolet/latest/ultraviolet/conversion/index.html \"mod ultraviolet::conversion\")\n    Contains implementations to convert between `UVec`/`IVec` and `Vec`/`DVec`.\n\n[int](https://docs.rs/ultraviolet/latest/ultraviolet/int/index.html \"mod ultraviolet::int\")\n\n\n[interp](https://docs.rs/ultraviolet/latest/ultraviolet/interp/index.html \"mod ultraviolet::interp\")\n    Interpolation on types for which it makes sense.\n\n[mat](https://docs.rs/ultraviolet/latest/ultraviolet/mat/index.html \"mod ultraviolet::mat\")\n    Square matrices.\n\n[projection](https://docs.rs/ultraviolet/latest/ultraviolet/projection/index.html \"mod ultraviolet::projection\")\n    Utility functions to create projection matrices.\n\n[rotor](https://docs.rs/ultraviolet/latest/ultraviolet/rotor/index.html \"mod ultraviolet::rotor\")\n    Rotors, i.e. constructs that describe and perform rotations.\n\n[transform](https://docs.rs/ultraviolet/latest/ultraviolet/transform/index.html \"mod ultraviolet::transform\")\n    Dedicated transformation types as the combination of primitives.\n\n[vec](https://docs.rs/ultraviolet/latest/ultraviolet/vec/index.html \"mod ultraviolet::vec\")\n    Vectors and points, i.e. directed line segments and locations.\n## Macros[\u00a7](https://docs.rs/ultraviolet/latest/ultraviolet/#macros)\n\n[derive_default_identity](https://docs.rs/ultraviolet/latest/ultraviolet/macro.derive_default_identity.html \"macro ultraviolet::derive_default_identity\")\n\n## Structs[\u00a7](https://docs.rs/ultraviolet/latest/ultraviolet/#structs)\n\n[f32x4](https://docs.rs/ultraviolet/latest/ultraviolet/struct.f32x4.html \"struct ultraviolet::f32x4\")\n\n\n[f32x8](https://docs.rs/ultraviolet/latest/ultraviolet/struct.f32x8.html \"struct ultraviolet::f32x8\")\n\n\n[f64x2](https://docs.rs/ultraviolet/latest/ultraviolet/struct.f64x2.html \"struct ultraviolet::f64x2\")\n\n\n[f64x4](https://docs.rs/ultraviolet/latest/ultraviolet/struct.f64x4.html \"struct ultraviolet::f64x4\")\n\n\n[m32x4](https://docs.rs/ultraviolet/latest/ultraviolet/struct.m32x4.html \"struct ultraviolet::m32x4\")\n\n\n[m32x8](https://docs.rs/ultraviolet/latest/ultraviolet/struct.m32x8.html \"struct ultraviolet::m32x8\")\n\n\n[m64x2](https://docs.rs/ultraviolet/latest/ultraviolet/struct.m64x2.html \"struct ultraviolet::m64x2\")\n\n\n[m64x4](https://docs.rs/ultraviolet/latest/ultraviolet/struct.m64x4.html \"struct ultraviolet::m64x4\")\n\n",
            "markdown_with_citations": "[](https://docs.rs/ultraviolet/latest/ultraviolet/all.html \"show sidebar\")\n# Crate ultravioletCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\n## \u00a7\u27e84\u27e9`ultraviolet`\nThis is a crate to computer-graphics and games-related linear and geometric algebra, but _fast_ , both in terms of productivity and in terms of runtime performance.\nIn terms of productivity, ultraviolet uses no generics and is designed to be as straightforward of an interface as possible, resulting in fast compilation times and clear code. In addition, the lack of generics and Rust type-system \u201chacks\u201d result in clear and concise errors that are easy to parse and fix for the user.\nIn terms of runtime performance, ultraviolet was designed from the start with performance in mind. To do so, we provide two separate kinds of each type, each with nearly identical functionality, one with usual scalar f32 values, and the other a \u2018wide\u2019 type which uses SIMD f32x4 vectors for each value. This design is clear and explicit in intent, and it also allows code to take full advantage of SIMD.\nThe \u2018wide\u2019 types use an \u201cSoA\u201d (Structure of Arrays) architecture such that each wide data structure actually contains the data for 4 or 8 of its associated data type and will do any operation on all of the simd \u2018lanes\u2019 at the same time. For example, a `Vec3x8` is equivalent to 8 `Vec3`s all bundled together into one data structure.\nDoing this is potentially _much_ (factor of 10) faster than an standard \u201cAoS\u201d (Array of Structs) layout, though it does depend on your workload and algorithm requirements. Algorithms must be carefully architected to take full advantage of this, and doing so can be easier said than done, especially if your algorithm involves significant branching.\n`ultraviolet` was the first Rust math library to be designed in this \u201cAoSoA\u201d manner, though `nalgebra` now supports it for several of their data structures as well.\n### \u00a7\u27e85\u27e9Benchmarks\nSee `mathbench-rs`\u27e86\u27e9 for latest benchmarks.\n### \u00a7\u27e87\u27e9Cargo Features\nTo help further improve build times, `ultraviolet` puts various functionality under feature flags. For example, the 2d and 3d projective geometric algebras as well as f64 and integer types are disabled by default. In order to enable them, enable the corresponding crate feature flags in your `Cargo.toml`. For example:\n```\n[dependencies]\nultraviolet = { version = \"0.9\", features = [ \"f64\", \"int\" ] }\n```\n\nWill enable the `f64` and `int` features. Here\u2019s a list of the available features:\n  * `f64` \u2013 Enable `f64` bit wide floating point support. Naming convention is `D[Type]`, such as `DVec3x4` would be a collection of 4 3d vectors with `f64` precision each.\n  * `int` \u2013 Enable integer vector types.\n  * `bytemuck` \u2013 Enable casting of many types to byte arrays, for use with graphics APIs.\n  * `mint` \u2013 Enable interoperation with other math crates through the `mint` interface.\n  * `num-traits` \u2013 Enable identity traits\u27e88\u27e9 for interoperation with other math crates.\n  * `serde` \u2013 Enable `Serialize` and `Deserialize` implementations for many scalar types.\n\n\n### \u00a7\u27e89\u27e9Crate Features\nThis crate is currently being dogfooded in my ray tracer `rayn`\u27e810\u27e9, and is being used by various independent Rust game developers for various projects. It does what those users have currently needed it to do.\nThere are a couple relatively unique/novel features in this library, the most important being the use of the Geometric Algebra.\nInstead of implementing complex number algebra (for 2d rotations) and Quaternion algebra (for 3d rotations), we use Rotors, a concept taken from Geometric Algebra, to represent 2d and 3d rotations.\nWhat this means for the programmer is that you will be using the `Rotor3` type in place of a Quaternion, though you can expect it to do basically all the same things that a Quaternion does. In fact, Quaternions are directly isomorphic to Rotors (meaning they are in essense the same thing, just formulated differently). The reason this decision was made was twofold: first, the derivation of the math is actually quite simple to understand. All the derivations for the code implemented in the Rotor structs in this library are written out in the `derivations` folder of the GitHub repo; I derived them manually as part of the implementation.\nOn the other hand, Quaternions are often basically just seen as black boxes that we programmers use to do rotations because they have some nice properties, but that we don\u2019t really understand. You can use Rotors this same way, but you can also easily understand them. Second is that in some sense they can be seen as \u2018more correct\u2019 than Quaternions. Specifically, they facilitate a more proper understanding of rotation as being something that occurs _within a plane_ rather than something that occurs _around an axis_ , as it is generally thought. Finally, Rotors also generalize to 4 and even higher dimensions, and if someone wants to they could implement a Rotor4 which retains all the properties of a Rotor3/Quaternion but does rotation in 4 dimensions instead, something which simply is not possible to do with Quaternions.\nIf it\u2019s missing something you need it to do, bug me on the GitHub issue tracker\u27e811\u27e9 and/or Rust community discord server (I\u2019m Fusha there) and I\u2019ll try to add it for you, if I believe it fits with the vision of the lib :)\n## Re-exports\u00a7\u27e812\u27e9\n\n`pub use bivec[](https://docs.rs/ultraviolet/latest/ultraviolet/bivec/index.html \"mod ultraviolet::bivec\")::*;`\n\n\n`pub use conversion[](https://docs.rs/ultraviolet/latest/ultraviolet/conversion/index.html \"mod ultraviolet::conversion\")::*;`\n\n\n`pub use int[](https://docs.rs/ultraviolet/latest/ultraviolet/int/index.html \"mod ultraviolet::int\")::*;`\n\n\n`pub use interp[](https://docs.rs/ultraviolet/latest/ultraviolet/interp/index.html \"mod ultraviolet::interp\")::*;`\n\n\n`pub use mat[](https://docs.rs/ultraviolet/latest/ultraviolet/mat/index.html \"mod ultraviolet::mat\")::*;`\n\n\n`pub use rotor[](https://docs.rs/ultraviolet/latest/ultraviolet/rotor/index.html \"mod ultraviolet::rotor\")::*;`\n\n\n`pub use transform[](https://docs.rs/ultraviolet/latest/ultraviolet/transform/index.html \"mod ultraviolet::transform\")::*;`\n\n\n`pub use vec[](https://docs.rs/ultraviolet/latest/ultraviolet/vec/index.html \"mod ultraviolet::vec\")::*;`\n\n## Modules\u00a7\u27e813\u27e9\n\nbivec\u27e814\u27e9\n    Bivectors, i.e. oriented areas.\n\nconversion\u27e815\u27e9\n    Contains implementations to convert between `UVec`/`IVec` and `Vec`/`DVec`.\n\nint\u27e816\u27e9\n\n\ninterp\u27e817\u27e9\n    Interpolation on types for which it makes sense.\n\nmat\u27e818\u27e9\n    Square matrices.\n\nprojection\u27e819\u27e9\n    Utility functions to create projection matrices.\n\nrotor\u27e820\u27e9\n    Rotors, i.e. constructs that describe and perform rotations.\n\ntransform\u27e821\u27e9\n    Dedicated transformation types as the combination of primitives.\n\nvec\u27e822\u27e9\n    Vectors and points, i.e. directed line segments and locations.\n## Macros\u00a7\u27e823\u27e9\n\nderive_default_identity\u27e824\u27e9\n\n## Structs\u00a7\u27e825\u27e9\n\nf32x4\u27e826\u27e9\n\n\nf32x8\u27e827\u27e9\n\n\nf64x2\u27e828\u27e9\n\n\nf64x4\u27e829\u27e9\n\n\nm32x4\u27e830\u27e9\n\n\nm32x8\u27e831\u27e9\n\n\nm64x2\u27e832\u27e9\n\n\nm64x4\u27e833\u27e9\n\n",
            "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/ultraviolet/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/ultraviolet/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/ultraviolet/latest/src/ultraviolet/lib.rs.html#1-139: Source\n\u27e84\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/#ultraviolet: \u00a7\n\u27e85\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/#benchmarks: \u00a7\n\u27e86\u27e9 https://github.com/bitshifter/mathbench-rs: `mathbench-rs`\n\u27e87\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/#cargo-features: \u00a7\n\u27e88\u27e9 https://docs.rs/num-traits/latest/num_traits/identities/index.html: identity traits\n\u27e89\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/#crate-features: \u00a7\n\u27e810\u27e9 https://github.com/termhn/rayn: `rayn`\n\u27e811\u27e9 https://github.com/termhn/ultraviolet/issues: GitHub issue tracker\n\u27e812\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/#reexports: \u00a7\n\u27e813\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/#modules: \u00a7\n\u27e814\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/bivec/index.html: mod ultraviolet::bivec - bivec\n\u27e815\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/conversion/index.html: mod ultraviolet::conversion - conversion\n\u27e816\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/int/index.html: mod ultraviolet::int - int\n\u27e817\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/interp/index.html: mod ultraviolet::interp - interp\n\u27e818\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/mat/index.html: mod ultraviolet::mat - mat\n\u27e819\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/projection/index.html: mod ultraviolet::projection - projection\n\u27e820\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/rotor/index.html: mod ultraviolet::rotor - rotor\n\u27e821\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/transform/index.html: mod ultraviolet::transform - transform\n\u27e822\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/vec/index.html: mod ultraviolet::vec - vec\n\u27e823\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/#macros: \u00a7\n\u27e824\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/macro.derive_default_identity.html: macro ultraviolet::derive_default_identity - derive_default_identity\n\u27e825\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/#structs: \u00a7\n\u27e826\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/struct.f32x4.html: struct ultraviolet::f32x4 - f32x4\n\u27e827\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/struct.f32x8.html: struct ultraviolet::f32x8 - f32x8\n\u27e828\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/struct.f64x2.html: struct ultraviolet::f64x2 - f64x2\n\u27e829\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/struct.f64x4.html: struct ultraviolet::f64x4 - f64x4\n\u27e830\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/struct.m32x4.html: struct ultraviolet::m32x4 - m32x4\n\u27e831\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/struct.m32x8.html: struct ultraviolet::m32x8 - m32x8\n\u27e832\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/struct.m64x2.html: struct ultraviolet::m64x2 - m64x2\n\u27e833\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/struct.m64x4.html: struct ultraviolet::m64x4 - m64x4\n",
            "fit_markdown": "",
            "fit_html": ""
          },
          "downloads": 0,
          "github_stars": 0,
          "dependencies": [],
          "features": {},
          "code_snippets": [],
          "readme_sections": {},
          "librs_downloads": null,
          "source": "crates.io",
          "enhanced_scraping": {},
          "enhanced_features": [],
          "enhanced_dependencies": []
        },
        "enriched_crate": {
          "name": "ultraviolet",
          "version": "0.10.0",
          "description": "ALLOW: Positive community sentiment",
          "repository": "",
          "keywords": [],
          "categories": [],
          "readme": {
            "raw_markdown": "[](https://docs.rs/ultraviolet/latest/ultraviolet/all.html \"show sidebar\")\n# Crate ultravioletCopy item path\n[Settings](https://docs.rs/ultraviolet/latest/settings.html)\n[Help](https://docs.rs/ultraviolet/latest/help.html)\nSummary[Source](https://docs.rs/ultraviolet/latest/src/ultraviolet/lib.rs.html#1-139)\nExpand description\n## [\u00a7](https://docs.rs/ultraviolet/latest/ultraviolet/#ultraviolet)`ultraviolet`\nThis is a crate to computer-graphics and games-related linear and geometric algebra, but _fast_ , both in terms of productivity and in terms of runtime performance.\nIn terms of productivity, ultraviolet uses no generics and is designed to be as straightforward of an interface as possible, resulting in fast compilation times and clear code. In addition, the lack of generics and Rust type-system \u201chacks\u201d result in clear and concise errors that are easy to parse and fix for the user.\nIn terms of runtime performance, ultraviolet was designed from the start with performance in mind. To do so, we provide two separate kinds of each type, each with nearly identical functionality, one with usual scalar f32 values, and the other a \u2018wide\u2019 type which uses SIMD f32x4 vectors for each value. This design is clear and explicit in intent, and it also allows code to take full advantage of SIMD.\nThe \u2018wide\u2019 types use an \u201cSoA\u201d (Structure of Arrays) architecture such that each wide data structure actually contains the data for 4 or 8 of its associated data type and will do any operation on all of the simd \u2018lanes\u2019 at the same time. For example, a `Vec3x8` is equivalent to 8 `Vec3`s all bundled together into one data structure.\nDoing this is potentially _much_ (factor of 10) faster than an standard \u201cAoS\u201d (Array of Structs) layout, though it does depend on your workload and algorithm requirements. Algorithms must be carefully architected to take full advantage of this, and doing so can be easier said than done, especially if your algorithm involves significant branching.\n`ultraviolet` was the first Rust math library to be designed in this \u201cAoSoA\u201d manner, though `nalgebra` now supports it for several of their data structures as well.\n### [\u00a7](https://docs.rs/ultraviolet/latest/ultraviolet/#benchmarks)Benchmarks\nSee [`mathbench-rs`](https://github.com/bitshifter/mathbench-rs) for latest benchmarks.\n### [\u00a7](https://docs.rs/ultraviolet/latest/ultraviolet/#cargo-features)Cargo Features\nTo help further improve build times, `ultraviolet` puts various functionality under feature flags. For example, the 2d and 3d projective geometric algebras as well as f64 and integer types are disabled by default. In order to enable them, enable the corresponding crate feature flags in your `Cargo.toml`. For example:\n```\n[dependencies]\nultraviolet = { version = \"0.9\", features = [ \"f64\", \"int\" ] }\n```\n\nWill enable the `f64` and `int` features. Here\u2019s a list of the available features:\n  * `f64` \u2013 Enable `f64` bit wide floating point support. Naming convention is `D[Type]`, such as `DVec3x4` would be a collection of 4 3d vectors with `f64` precision each.\n  * `int` \u2013 Enable integer vector types.\n  * `bytemuck` \u2013 Enable casting of many types to byte arrays, for use with graphics APIs.\n  * `mint` \u2013 Enable interoperation with other math crates through the `mint` interface.\n  * `num-traits` \u2013 Enable [identity traits](https://docs.rs/num-traits/latest/num_traits/identities/index.html) for interoperation with other math crates.\n  * `serde` \u2013 Enable `Serialize` and `Deserialize` implementations for many scalar types.\n\n\n### [\u00a7](https://docs.rs/ultraviolet/latest/ultraviolet/#crate-features)Crate Features\nThis crate is currently being dogfooded in my ray tracer [`rayn`](https://github.com/termhn/rayn), and is being used by various independent Rust game developers for various projects. It does what those users have currently needed it to do.\nThere are a couple relatively unique/novel features in this library, the most important being the use of the Geometric Algebra.\nInstead of implementing complex number algebra (for 2d rotations) and Quaternion algebra (for 3d rotations), we use Rotors, a concept taken from Geometric Algebra, to represent 2d and 3d rotations.\nWhat this means for the programmer is that you will be using the `Rotor3` type in place of a Quaternion, though you can expect it to do basically all the same things that a Quaternion does. In fact, Quaternions are directly isomorphic to Rotors (meaning they are in essense the same thing, just formulated differently). The reason this decision was made was twofold: first, the derivation of the math is actually quite simple to understand. All the derivations for the code implemented in the Rotor structs in this library are written out in the `derivations` folder of the GitHub repo; I derived them manually as part of the implementation.\nOn the other hand, Quaternions are often basically just seen as black boxes that we programmers use to do rotations because they have some nice properties, but that we don\u2019t really understand. You can use Rotors this same way, but you can also easily understand them. Second is that in some sense they can be seen as \u2018more correct\u2019 than Quaternions. Specifically, they facilitate a more proper understanding of rotation as being something that occurs _within a plane_ rather than something that occurs _around an axis_ , as it is generally thought. Finally, Rotors also generalize to 4 and even higher dimensions, and if someone wants to they could implement a Rotor4 which retains all the properties of a Rotor3/Quaternion but does rotation in 4 dimensions instead, something which simply is not possible to do with Quaternions.\nIf it\u2019s missing something you need it to do, bug me on the [GitHub issue tracker](https://github.com/termhn/ultraviolet/issues) and/or Rust community discord server (I\u2019m Fusha there) and I\u2019ll try to add it for you, if I believe it fits with the vision of the lib :)\n## Re-exports[\u00a7](https://docs.rs/ultraviolet/latest/ultraviolet/#reexports)\n\n`pub use bivec[](https://docs.rs/ultraviolet/latest/ultraviolet/bivec/index.html \"mod ultraviolet::bivec\")::*;`\n\n\n`pub use conversion[](https://docs.rs/ultraviolet/latest/ultraviolet/conversion/index.html \"mod ultraviolet::conversion\")::*;`\n\n\n`pub use int[](https://docs.rs/ultraviolet/latest/ultraviolet/int/index.html \"mod ultraviolet::int\")::*;`\n\n\n`pub use interp[](https://docs.rs/ultraviolet/latest/ultraviolet/interp/index.html \"mod ultraviolet::interp\")::*;`\n\n\n`pub use mat[](https://docs.rs/ultraviolet/latest/ultraviolet/mat/index.html \"mod ultraviolet::mat\")::*;`\n\n\n`pub use rotor[](https://docs.rs/ultraviolet/latest/ultraviolet/rotor/index.html \"mod ultraviolet::rotor\")::*;`\n\n\n`pub use transform[](https://docs.rs/ultraviolet/latest/ultraviolet/transform/index.html \"mod ultraviolet::transform\")::*;`\n\n\n`pub use vec[](https://docs.rs/ultraviolet/latest/ultraviolet/vec/index.html \"mod ultraviolet::vec\")::*;`\n\n## Modules[\u00a7](https://docs.rs/ultraviolet/latest/ultraviolet/#modules)\n\n[bivec](https://docs.rs/ultraviolet/latest/ultraviolet/bivec/index.html \"mod ultraviolet::bivec\")\n    Bivectors, i.e. oriented areas.\n\n[conversion](https://docs.rs/ultraviolet/latest/ultraviolet/conversion/index.html \"mod ultraviolet::conversion\")\n    Contains implementations to convert between `UVec`/`IVec` and `Vec`/`DVec`.\n\n[int](https://docs.rs/ultraviolet/latest/ultraviolet/int/index.html \"mod ultraviolet::int\")\n\n\n[interp](https://docs.rs/ultraviolet/latest/ultraviolet/interp/index.html \"mod ultraviolet::interp\")\n    Interpolation on types for which it makes sense.\n\n[mat](https://docs.rs/ultraviolet/latest/ultraviolet/mat/index.html \"mod ultraviolet::mat\")\n    Square matrices.\n\n[projection](https://docs.rs/ultraviolet/latest/ultraviolet/projection/index.html \"mod ultraviolet::projection\")\n    Utility functions to create projection matrices.\n\n[rotor](https://docs.rs/ultraviolet/latest/ultraviolet/rotor/index.html \"mod ultraviolet::rotor\")\n    Rotors, i.e. constructs that describe and perform rotations.\n\n[transform](https://docs.rs/ultraviolet/latest/ultraviolet/transform/index.html \"mod ultraviolet::transform\")\n    Dedicated transformation types as the combination of primitives.\n\n[vec](https://docs.rs/ultraviolet/latest/ultraviolet/vec/index.html \"mod ultraviolet::vec\")\n    Vectors and points, i.e. directed line segments and locations.\n## Macros[\u00a7](https://docs.rs/ultraviolet/latest/ultraviolet/#macros)\n\n[derive_default_identity](https://docs.rs/ultraviolet/latest/ultraviolet/macro.derive_default_identity.html \"macro ultraviolet::derive_default_identity\")\n\n## Structs[\u00a7](https://docs.rs/ultraviolet/latest/ultraviolet/#structs)\n\n[f32x4](https://docs.rs/ultraviolet/latest/ultraviolet/struct.f32x4.html \"struct ultraviolet::f32x4\")\n\n\n[f32x8](https://docs.rs/ultraviolet/latest/ultraviolet/struct.f32x8.html \"struct ultraviolet::f32x8\")\n\n\n[f64x2](https://docs.rs/ultraviolet/latest/ultraviolet/struct.f64x2.html \"struct ultraviolet::f64x2\")\n\n\n[f64x4](https://docs.rs/ultraviolet/latest/ultraviolet/struct.f64x4.html \"struct ultraviolet::f64x4\")\n\n\n[m32x4](https://docs.rs/ultraviolet/latest/ultraviolet/struct.m32x4.html \"struct ultraviolet::m32x4\")\n\n\n[m32x8](https://docs.rs/ultraviolet/latest/ultraviolet/struct.m32x8.html \"struct ultraviolet::m32x8\")\n\n\n[m64x2](https://docs.rs/ultraviolet/latest/ultraviolet/struct.m64x2.html \"struct ultraviolet::m64x2\")\n\n\n[m64x4](https://docs.rs/ultraviolet/latest/ultraviolet/struct.m64x4.html \"struct ultraviolet::m64x4\")\n\n",
            "markdown_with_citations": "[](https://docs.rs/ultraviolet/latest/ultraviolet/all.html \"show sidebar\")\n# Crate ultravioletCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\n## \u00a7\u27e84\u27e9`ultraviolet`\nThis is a crate to computer-graphics and games-related linear and geometric algebra, but _fast_ , both in terms of productivity and in terms of runtime performance.\nIn terms of productivity, ultraviolet uses no generics and is designed to be as straightforward of an interface as possible, resulting in fast compilation times and clear code. In addition, the lack of generics and Rust type-system \u201chacks\u201d result in clear and concise errors that are easy to parse and fix for the user.\nIn terms of runtime performance, ultraviolet was designed from the start with performance in mind. To do so, we provide two separate kinds of each type, each with nearly identical functionality, one with usual scalar f32 values, and the other a \u2018wide\u2019 type which uses SIMD f32x4 vectors for each value. This design is clear and explicit in intent, and it also allows code to take full advantage of SIMD.\nThe \u2018wide\u2019 types use an \u201cSoA\u201d (Structure of Arrays) architecture such that each wide data structure actually contains the data for 4 or 8 of its associated data type and will do any operation on all of the simd \u2018lanes\u2019 at the same time. For example, a `Vec3x8` is equivalent to 8 `Vec3`s all bundled together into one data structure.\nDoing this is potentially _much_ (factor of 10) faster than an standard \u201cAoS\u201d (Array of Structs) layout, though it does depend on your workload and algorithm requirements. Algorithms must be carefully architected to take full advantage of this, and doing so can be easier said than done, especially if your algorithm involves significant branching.\n`ultraviolet` was the first Rust math library to be designed in this \u201cAoSoA\u201d manner, though `nalgebra` now supports it for several of their data structures as well.\n### \u00a7\u27e85\u27e9Benchmarks\nSee `mathbench-rs`\u27e86\u27e9 for latest benchmarks.\n### \u00a7\u27e87\u27e9Cargo Features\nTo help further improve build times, `ultraviolet` puts various functionality under feature flags. For example, the 2d and 3d projective geometric algebras as well as f64 and integer types are disabled by default. In order to enable them, enable the corresponding crate feature flags in your `Cargo.toml`. For example:\n```\n[dependencies]\nultraviolet = { version = \"0.9\", features = [ \"f64\", \"int\" ] }\n```\n\nWill enable the `f64` and `int` features. Here\u2019s a list of the available features:\n  * `f64` \u2013 Enable `f64` bit wide floating point support. Naming convention is `D[Type]`, such as `DVec3x4` would be a collection of 4 3d vectors with `f64` precision each.\n  * `int` \u2013 Enable integer vector types.\n  * `bytemuck` \u2013 Enable casting of many types to byte arrays, for use with graphics APIs.\n  * `mint` \u2013 Enable interoperation with other math crates through the `mint` interface.\n  * `num-traits` \u2013 Enable identity traits\u27e88\u27e9 for interoperation with other math crates.\n  * `serde` \u2013 Enable `Serialize` and `Deserialize` implementations for many scalar types.\n\n\n### \u00a7\u27e89\u27e9Crate Features\nThis crate is currently being dogfooded in my ray tracer `rayn`\u27e810\u27e9, and is being used by various independent Rust game developers for various projects. It does what those users have currently needed it to do.\nThere are a couple relatively unique/novel features in this library, the most important being the use of the Geometric Algebra.\nInstead of implementing complex number algebra (for 2d rotations) and Quaternion algebra (for 3d rotations), we use Rotors, a concept taken from Geometric Algebra, to represent 2d and 3d rotations.\nWhat this means for the programmer is that you will be using the `Rotor3` type in place of a Quaternion, though you can expect it to do basically all the same things that a Quaternion does. In fact, Quaternions are directly isomorphic to Rotors (meaning they are in essense the same thing, just formulated differently). The reason this decision was made was twofold: first, the derivation of the math is actually quite simple to understand. All the derivations for the code implemented in the Rotor structs in this library are written out in the `derivations` folder of the GitHub repo; I derived them manually as part of the implementation.\nOn the other hand, Quaternions are often basically just seen as black boxes that we programmers use to do rotations because they have some nice properties, but that we don\u2019t really understand. You can use Rotors this same way, but you can also easily understand them. Second is that in some sense they can be seen as \u2018more correct\u2019 than Quaternions. Specifically, they facilitate a more proper understanding of rotation as being something that occurs _within a plane_ rather than something that occurs _around an axis_ , as it is generally thought. Finally, Rotors also generalize to 4 and even higher dimensions, and if someone wants to they could implement a Rotor4 which retains all the properties of a Rotor3/Quaternion but does rotation in 4 dimensions instead, something which simply is not possible to do with Quaternions.\nIf it\u2019s missing something you need it to do, bug me on the GitHub issue tracker\u27e811\u27e9 and/or Rust community discord server (I\u2019m Fusha there) and I\u2019ll try to add it for you, if I believe it fits with the vision of the lib :)\n## Re-exports\u00a7\u27e812\u27e9\n\n`pub use bivec[](https://docs.rs/ultraviolet/latest/ultraviolet/bivec/index.html \"mod ultraviolet::bivec\")::*;`\n\n\n`pub use conversion[](https://docs.rs/ultraviolet/latest/ultraviolet/conversion/index.html \"mod ultraviolet::conversion\")::*;`\n\n\n`pub use int[](https://docs.rs/ultraviolet/latest/ultraviolet/int/index.html \"mod ultraviolet::int\")::*;`\n\n\n`pub use interp[](https://docs.rs/ultraviolet/latest/ultraviolet/interp/index.html \"mod ultraviolet::interp\")::*;`\n\n\n`pub use mat[](https://docs.rs/ultraviolet/latest/ultraviolet/mat/index.html \"mod ultraviolet::mat\")::*;`\n\n\n`pub use rotor[](https://docs.rs/ultraviolet/latest/ultraviolet/rotor/index.html \"mod ultraviolet::rotor\")::*;`\n\n\n`pub use transform[](https://docs.rs/ultraviolet/latest/ultraviolet/transform/index.html \"mod ultraviolet::transform\")::*;`\n\n\n`pub use vec[](https://docs.rs/ultraviolet/latest/ultraviolet/vec/index.html \"mod ultraviolet::vec\")::*;`\n\n## Modules\u00a7\u27e813\u27e9\n\nbivec\u27e814\u27e9\n    Bivectors, i.e. oriented areas.\n\nconversion\u27e815\u27e9\n    Contains implementations to convert between `UVec`/`IVec` and `Vec`/`DVec`.\n\nint\u27e816\u27e9\n\n\ninterp\u27e817\u27e9\n    Interpolation on types for which it makes sense.\n\nmat\u27e818\u27e9\n    Square matrices.\n\nprojection\u27e819\u27e9\n    Utility functions to create projection matrices.\n\nrotor\u27e820\u27e9\n    Rotors, i.e. constructs that describe and perform rotations.\n\ntransform\u27e821\u27e9\n    Dedicated transformation types as the combination of primitives.\n\nvec\u27e822\u27e9\n    Vectors and points, i.e. directed line segments and locations.\n## Macros\u00a7\u27e823\u27e9\n\nderive_default_identity\u27e824\u27e9\n\n## Structs\u00a7\u27e825\u27e9\n\nf32x4\u27e826\u27e9\n\n\nf32x8\u27e827\u27e9\n\n\nf64x2\u27e828\u27e9\n\n\nf64x4\u27e829\u27e9\n\n\nm32x4\u27e830\u27e9\n\n\nm32x8\u27e831\u27e9\n\n\nm64x2\u27e832\u27e9\n\n\nm64x4\u27e833\u27e9\n\n",
            "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/ultraviolet/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/ultraviolet/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/ultraviolet/latest/src/ultraviolet/lib.rs.html#1-139: Source\n\u27e84\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/#ultraviolet: \u00a7\n\u27e85\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/#benchmarks: \u00a7\n\u27e86\u27e9 https://github.com/bitshifter/mathbench-rs: `mathbench-rs`\n\u27e87\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/#cargo-features: \u00a7\n\u27e88\u27e9 https://docs.rs/num-traits/latest/num_traits/identities/index.html: identity traits\n\u27e89\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/#crate-features: \u00a7\n\u27e810\u27e9 https://github.com/termhn/rayn: `rayn`\n\u27e811\u27e9 https://github.com/termhn/ultraviolet/issues: GitHub issue tracker\n\u27e812\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/#reexports: \u00a7\n\u27e813\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/#modules: \u00a7\n\u27e814\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/bivec/index.html: mod ultraviolet::bivec - bivec\n\u27e815\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/conversion/index.html: mod ultraviolet::conversion - conversion\n\u27e816\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/int/index.html: mod ultraviolet::int - int\n\u27e817\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/interp/index.html: mod ultraviolet::interp - interp\n\u27e818\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/mat/index.html: mod ultraviolet::mat - mat\n\u27e819\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/projection/index.html: mod ultraviolet::projection - projection\n\u27e820\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/rotor/index.html: mod ultraviolet::rotor - rotor\n\u27e821\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/transform/index.html: mod ultraviolet::transform - transform\n\u27e822\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/vec/index.html: mod ultraviolet::vec - vec\n\u27e823\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/#macros: \u00a7\n\u27e824\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/macro.derive_default_identity.html: macro ultraviolet::derive_default_identity - derive_default_identity\n\u27e825\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/#structs: \u00a7\n\u27e826\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/struct.f32x4.html: struct ultraviolet::f32x4 - f32x4\n\u27e827\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/struct.f32x8.html: struct ultraviolet::f32x8 - f32x8\n\u27e828\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/struct.f64x2.html: struct ultraviolet::f64x2 - f64x2\n\u27e829\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/struct.f64x4.html: struct ultraviolet::f64x4 - f64x4\n\u27e830\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/struct.m32x4.html: struct ultraviolet::m32x4 - m32x4\n\u27e831\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/struct.m32x8.html: struct ultraviolet::m32x8 - m32x8\n\u27e832\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/struct.m64x2.html: struct ultraviolet::m64x2 - m64x2\n\u27e833\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/struct.m64x4.html: struct ultraviolet::m64x4 - m64x4\n",
            "fit_markdown": "",
            "fit_html": ""
          },
          "downloads": 0,
          "github_stars": 0,
          "dependencies": [],
          "features": {},
          "code_snippets": [],
          "readme_sections": {},
          "librs_downloads": null,
          "source": "crates.io",
          "enhanced_scraping": {},
          "enhanced_features": [],
          "enhanced_dependencies": [],
          "readme_summary": "The `ultraviolet` crate is a high-performance linear and geometric algebra library tailored for computer graphics and game development. It offers both scalar and SIMD-optimized \"wide\" types using an AoSoA (Array of Structures of Arrays) architecture for significant runtime performance gains. Key features include support for Rotors (a geometric algebra alternative to Quaternions), modular functionality via feature flags (e.g., `f64`, `int`, `serde`), and interoperability with other math libraries through `mint` and `num-traits`.",
          "feature_summary": null,
          "use_case": "Utilities",
          "score": 7.0,
          "factual_counterfactual": "### Pair 1: SIMD and Performance\n\n\u2705 **Factual:** The `ultraviolet` crate provides \"wide\" types that leverage SIMD (Single Instruction, Multiple Data) f32x4 vectors for improved runtime performance, enabling operations on multiple data simultaneously through a Structure of Arrays (SoA) approach.\n\n\u274c **Counterfactual:** The `ultraviolet` crate exclusively uses SIMD for all operations, and does not provide scalar types for workloads that do not benefit from SIMD optimization.\n\n---\n\n### Pair 2: Rotors vs Quaternions\n\n\u2705 **Factual:** `ultraviolet` uses Rotors, derived from Geometric Algebra, to represent 2D and 3D rotations, offering a conceptually simple and mathematically robust alternative to Quaternions.\n\n\u274c **Counterfactual:** Rotors in `ultraviolet` are fundamentally different from Quaternions and cannot be used interchangeably for 3D rotations.\n\n---\n\n### Pair 3: Feature Flags\n\n\u2705 **Factual:** The crate provides feature flags such as `f64`, `int`, and `serde` to enable additional functionality, including double-precision floating-point types, integer vector types, and serialization/deserialization support.\n\n\u274c **Counterfactual:** All features in `ultraviolet`, including `f64` and `int` support, are enabled by default, making it unnecessary to specify them in `Cargo.toml`.",
          "source_analysis": null,
          "user_behavior": null,
          "security": null
        }
      },
      "irl_score": 8.6,
      "execution_id": "exec-3aa3c439-cb51f9ec-1751265798",
      "timestamp": "2025-06-30T06:43:18.773851+00:00",
      "canon_version": "1.3.0"
    },
    "rule_zero_compliant": true
  }
]