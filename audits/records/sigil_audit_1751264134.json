[
  {
    "execution_id": "exec-d71256c0-70368c1c-1751264127",
    "timestamp": "2025-06-30T06:15:27.595806+00:00",
    "sacred_chain": {
      "input_data": "lazy_static",
      "context_sources": [
        "crates.io",
        "github.com",
        "lib.rs",
        "docs.rs"
      ],
      "reasoning_steps": [
        "Input canonicalized: 'lazy_static' -> 'lazy_static'",
        "Context gathered from 4 validated sources",
        "Metadata extracted: 4 fields",
        "Documentation analyzed: quality 7.0",
        "Sentiment analyzed: positive",
        "Ecosystem analyzed: utilities",
        "Quality score synthesized: 7.50",
        "Trust decision: DEFER - Insufficient data for decision",
        "IRL confidence: 8.600"
      ],
      "suggestion": "ALLOW: Positive community sentiment",
      "verdict": "DEFER",
      "audit_info": {
        "metadata": {
          "name": "lazy_static",
          "type": "rust_crate",
          "source": "manual_input",
          "extraction_method": "irl_engine"
        },
        "sentiment": {
          "quality_score": 7.0,
          "completeness": 0.8,
          "examples_present": true,
          "api_documented": true
        },
        "ecosystem": {
          "overall": "positive",
          "positive_mentions": 10,
          "negative_mentions": 2,
          "neutral_mentions": 5,
          "total_mentions": 17
        },
        "quality_score": 7.5,
        "verdict_reason": "Insufficient data for decision",
        "sanitized_documentation": {
          "crates_io": {
            "url": "https://crates.io/crates/lazy_static",
            "title": "lazy_static v1.5.0",
            "content": {
              "raw_markdown": "#  lazy_static v1.5.0\nA macro for declaring lazily evaluated statics in Rust. \n  * [ #lazy ](https://crates.io/keywords/lazy)\n  * [ #macro ](https://crates.io/keywords/macro)\n  * [ #static ](https://crates.io/keywords/static)\n\n\n  * [ Readme ](https://crates.io/crates/lazy_static)\n  * [ 38 Versions ](https://crates.io/crates/lazy_static/versions)\n  * [ Dependencies ](https://crates.io/crates/lazy_static/dependencies)\n  * [ Dependents ](https://crates.io/crates/lazy_static/reverse_dependencies)\n\n\n## Metadata\nabout 1 year ago \n[ MIT ](https://choosealicense.com/licenses/mit) OR [ Apache-2.0 ](https://choosealicense.com/licenses/apache-2.0)\n13.7 KiB \n## Install\nRun the following Cargo command in your project directory:\ncargo add lazy_static\nOr add the following line to your Cargo.toml:\nlazy_static = \"1.5.0\"\n## Documentation\n[ docs.rs/lazy_static ](https://docs.rs/lazy_static)\n## Repository\n[ github.com/rust-lang-nursery/lazy-static.rs ](https://github.com/rust-lang-nursery/lazy-static.rs)\n## Owners\n## Categories\n  * [No standard library](https://crates.io/categories/no-std)\n  * [Memory management](https://crates.io/categories/memory-management)\n  * [Rust patterns](https://crates.io/categories/rust-patterns)\n\n\n[ Report crate ](https://crates.io/support?crate=lazy_static&inquire=crate-violation)\n### Stats Overview\n433,177,420 Downloads all time\n38 Versions published\n#### Downloads over the last 90 days\nDisplay as \nStacked \n  * Stacked \n  * Unstacked \n\n\nLoading\u2026\n",
              "markdown_with_citations": "#  lazy_static v1.5.0\nA macro for declaring lazily evaluated statics in Rust. \n  *  #lazy \u27e81\u27e9\n  *  #macro \u27e82\u27e9\n  *  #static \u27e83\u27e9\n\n\n  *  Readme \u27e84\u27e9\n  *  38 Versions \u27e85\u27e9\n  *  Dependencies \u27e86\u27e9\n  *  Dependents \u27e87\u27e9\n\n\n## Metadata\nabout 1 year ago \n MIT \u27e88\u27e9 OR  Apache-2.0 \u27e89\u27e9\n13.7 KiB \n## Install\nRun the following Cargo command in your project directory:\ncargo add lazy_static\nOr add the following line to your Cargo.toml:\nlazy_static = \"1.5.0\"\n## Documentation\n docs.rs/lazy_static \u27e810\u27e9\n## Repository\n github.com/rust-lang-nursery/lazy-static.rs \u27e811\u27e9\n## Owners\n## Categories\n  * No standard library\u27e812\u27e9\n  * Memory management\u27e813\u27e9\n  * Rust patterns\u27e814\u27e9\n\n\n Report crate \u27e815\u27e9\n### Stats Overview\n433,177,420 Downloads all time\n38 Versions published\n#### Downloads over the last 90 days\nDisplay as \nStacked \n  * Stacked \n  * Unstacked \n\n\nLoading\u2026\n",
              "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://crates.io/keywords/lazy:  #lazy \n\u27e82\u27e9 https://crates.io/keywords/macro:  #macro \n\u27e83\u27e9 https://crates.io/keywords/static:  #static \n\u27e84\u27e9 https://crates.io/crates/lazy_static:  Readme \n\u27e85\u27e9 https://crates.io/crates/lazy_static/versions:  38 Versions \n\u27e86\u27e9 https://crates.io/crates/lazy_static/dependencies:  Dependencies \n\u27e87\u27e9 https://crates.io/crates/lazy_static/reverse_dependencies:  Dependents \n\u27e88\u27e9 https://choosealicense.com/licenses/mit:  MIT \n\u27e89\u27e9 https://choosealicense.com/licenses/apache-2.0:  Apache-2.0 \n\u27e810\u27e9 https://docs.rs/lazy_static:  docs.rs/lazy_static \n\u27e811\u27e9 https://github.com/rust-lang-nursery/lazy-static.rs:  github.com/rust-lang-nursery/lazy-static.rs \n\u27e812\u27e9 https://crates.io/categories/no-std: No standard library\n\u27e813\u27e9 https://crates.io/categories/memory-management: Memory management\n\u27e814\u27e9 https://crates.io/categories/rust-patterns: Rust patterns\n\u27e815\u27e9 https://crates.io/support?crate=lazy_static&inquire=crate-violation:  Report crate \n",
              "fit_markdown": "",
              "fit_html": ""
            },
            "structured_data": {},
            "quality_score": 3.0,
            "extraction_method": "crawl4ai",
            "error": null,
            "metadata": {
              "doc_type": "docs",
              "content_length": 1480,
              "has_structured_data": false,
              "crawl_success": true
            },
            "timestamp": "117917.584976"
          },
          "docs_rs": {
            "url": "https://docs.rs/lazy_static",
            "title": "Crate lazy_staticCopy item path",
            "content": {
              "raw_markdown": "[](https://docs.rs/lazy_static/latest/lazy_static/all.html \"show sidebar\")\n# Crate lazy_staticCopy item path\n[Settings](https://docs.rs/lazy_static/latest/settings.html)\n[Help](https://docs.rs/lazy_static/latest/help.html)\nSummary[Source](https://docs.rs/lazy_static/latest/src/lazy_static/lib.rs.html#8-208)\nExpand description\nA macro for declaring lazily evaluated statics.\nUsing this macro, it is possible to have `static`s that require code to be executed at runtime in order to be initialized. This includes anything requiring heap allocations, like vectors or hash maps, as well as anything that requires function calls to be computed.\n## [\u00a7](https://docs.rs/lazy_static/latest/lazy_static/#syntax)Syntax\n[\u24d8](https://docs.rs/lazy_static/latest/lazy_static/ \"This example is not tested\")```\nlazy_static! {\n  [pub] static ref NAME_1: TYPE_1 = EXPR_1;\n  [pub] static ref NAME_2: TYPE_2 = EXPR_2;\n  ...\n  [pub] static ref NAME_N: TYPE_N = EXPR_N;\n}\n```\n\nAttributes (including doc comments) are supported as well:\n```\nuse lazy_static::lazy_static;\nlazy_static! {\n  /// This is an example for using doc comment attributes\n  static ref EXAMPLE: u8 = 42;\n}\n```\n\n## [\u00a7](https://docs.rs/lazy_static/latest/lazy_static/#semantics)Semantics\nFor a given `static ref NAME: TYPE = EXPR;`, the macro generates a unique type that implements `Deref<TYPE>` and stores it in a static with name `NAME`. (Attributes end up attaching to this type.)\nOn first deref, `EXPR` gets evaluated and stored internally, such that all further derefs can return a reference to the same object. Note that this can lead to deadlocks if you have multiple lazy statics that depend on each other in their initialization.\nApart from the lazy initialization, the resulting \u201cstatic ref\u201d variables have generally the same properties as regular \u201cstatic\u201d variables:\n  * Any type in them needs to fulfill the `Sync` trait.\n  * If the type has a destructor, then it will not run when the process exits.\n\n\n## [\u00a7](https://docs.rs/lazy_static/latest/lazy_static/#example)Example\nUsing the macro:\n```\nuse lazy_static::lazy_static;\nuse std::collections::HashMap;\nlazy_static! {\n  static ref HASHMAP: HashMap<u32, &'static str> = {\n    let mut m = HashMap::new();\n    m.insert(0, \"foo\");\n    m.insert(1, \"bar\");\n    m.insert(2, \"baz\");\n    m\n  };\n  static ref COUNT: usize = HASHMAP.len();\n  static ref NUMBER: u32 = times_two(21);\n}\nfn times_two(n: u32) -> u32 { n * 2 }\nfn main() {\n  println!(\"The map has {} entries.\", *COUNT);\n  println!(\"The entry for `0` is \\\"{}\\\".\", HASHMAP.get(&0).unwrap());\n  println!(\"A expensive calculation on a static results in: {}.\", *NUMBER);\n}\n```\n\n## [\u00a7](https://docs.rs/lazy_static/latest/lazy_static/#implementation-details)Implementation details\nThe `Deref` implementation uses a hidden static variable that is guarded by an atomic check on each access.\n## [\u00a7](https://docs.rs/lazy_static/latest/lazy_static/#cargo-features)Cargo features\nThis crate provides one cargo feature:\n  * `spin_no_std`: This allows using this crate in a no-std environment, by depending on the standalone `spin` crate.\n\n\n## Macros[\u00a7](https://docs.rs/lazy_static/latest/lazy_static/#macros)\n\n[lazy_static](https://docs.rs/lazy_static/latest/lazy_static/macro.lazy_static.html \"macro lazy_static::lazy_static\")\n\n## Traits[\u00a7](https://docs.rs/lazy_static/latest/lazy_static/#traits)\n\n[LazyStatic](https://docs.rs/lazy_static/latest/lazy_static/trait.LazyStatic.html \"trait lazy_static::LazyStatic\")\n    Support trait for enabling a few common operation on lazy static values.\n## Functions[\u00a7](https://docs.rs/lazy_static/latest/lazy_static/#functions)\n\n[initialize](https://docs.rs/lazy_static/latest/lazy_static/fn.initialize.html \"fn lazy_static::initialize\")\n    Takes a shared reference to a lazy static and initializes it if it has not been already.\n",
              "markdown_with_citations": "[](https://docs.rs/lazy_static/latest/lazy_static/all.html \"show sidebar\")\n# Crate lazy_staticCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nA macro for declaring lazily evaluated statics.\nUsing this macro, it is possible to have `static`s that require code to be executed at runtime in order to be initialized. This includes anything requiring heap allocations, like vectors or hash maps, as well as anything that requires function calls to be computed.\n## \u00a7\u27e84\u27e9Syntax\n\u24d8\u27e85\u27e9```\nlazy_static! {\n  [pub] static ref NAME_1: TYPE_1 = EXPR_1;\n  [pub] static ref NAME_2: TYPE_2 = EXPR_2;\n  ...\n  [pub] static ref NAME_N: TYPE_N = EXPR_N;\n}\n```\n\nAttributes (including doc comments) are supported as well:\n```\nuse lazy_static::lazy_static;\nlazy_static! {\n  /// This is an example for using doc comment attributes\n  static ref EXAMPLE: u8 = 42;\n}\n```\n\n## \u00a7\u27e86\u27e9Semantics\nFor a given `static ref NAME: TYPE = EXPR;`, the macro generates a unique type that implements `Deref<TYPE>` and stores it in a static with name `NAME`. (Attributes end up attaching to this type.)\nOn first deref, `EXPR` gets evaluated and stored internally, such that all further derefs can return a reference to the same object. Note that this can lead to deadlocks if you have multiple lazy statics that depend on each other in their initialization.\nApart from the lazy initialization, the resulting \u201cstatic ref\u201d variables have generally the same properties as regular \u201cstatic\u201d variables:\n  * Any type in them needs to fulfill the `Sync` trait.\n  * If the type has a destructor, then it will not run when the process exits.\n\n\n## \u00a7\u27e87\u27e9Example\nUsing the macro:\n```\nuse lazy_static::lazy_static;\nuse std::collections::HashMap;\nlazy_static! {\n  static ref HASHMAP: HashMap<u32, &'static str> = {\n    let mut m = HashMap::new();\n    m.insert(0, \"foo\");\n    m.insert(1, \"bar\");\n    m.insert(2, \"baz\");\n    m\n  };\n  static ref COUNT: usize = HASHMAP.len();\n  static ref NUMBER: u32 = times_two(21);\n}\nfn times_two(n: u32) -> u32 { n * 2 }\nfn main() {\n  println!(\"The map has {} entries.\", *COUNT);\n  println!(\"The entry for `0` is \\\"{}\\\".\", HASHMAP.get(&0).unwrap());\n  println!(\"A expensive calculation on a static results in: {}.\", *NUMBER);\n}\n```\n\n## \u00a7\u27e88\u27e9Implementation details\nThe `Deref` implementation uses a hidden static variable that is guarded by an atomic check on each access.\n## \u00a7\u27e89\u27e9Cargo features\nThis crate provides one cargo feature:\n  * `spin_no_std`: This allows using this crate in a no-std environment, by depending on the standalone `spin` crate.\n\n\n## Macros\u00a7\u27e810\u27e9\n\nlazy_static\u27e811\u27e9\n\n## Traits\u00a7\u27e812\u27e9\n\nLazyStatic\u27e813\u27e9\n    Support trait for enabling a few common operation on lazy static values.\n## Functions\u00a7\u27e814\u27e9\n\ninitialize\u27e815\u27e9\n    Takes a shared reference to a lazy static and initializes it if it has not been already.\n",
              "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/lazy_static/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/lazy_static/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/lazy_static/latest/src/lazy_static/lib.rs.html#8-208: Source\n\u27e84\u27e9 https://docs.rs/lazy_static/latest/lazy_static/#syntax: \u00a7\n\u27e85\u27e9 https://docs.rs/lazy_static/latest/lazy_static/: This example is not tested - \u24d8\n\u27e86\u27e9 https://docs.rs/lazy_static/latest/lazy_static/#semantics: \u00a7\n\u27e87\u27e9 https://docs.rs/lazy_static/latest/lazy_static/#example: \u00a7\n\u27e88\u27e9 https://docs.rs/lazy_static/latest/lazy_static/#implementation-details: \u00a7\n\u27e89\u27e9 https://docs.rs/lazy_static/latest/lazy_static/#cargo-features: \u00a7\n\u27e810\u27e9 https://docs.rs/lazy_static/latest/lazy_static/#macros: \u00a7\n\u27e811\u27e9 https://docs.rs/lazy_static/latest/lazy_static/macro.lazy_static.html: macro lazy_static::lazy_static - lazy_static\n\u27e812\u27e9 https://docs.rs/lazy_static/latest/lazy_static/#traits: \u00a7\n\u27e813\u27e9 https://docs.rs/lazy_static/latest/lazy_static/trait.LazyStatic.html: trait lazy_static::LazyStatic - LazyStatic\n\u27e814\u27e9 https://docs.rs/lazy_static/latest/lazy_static/#functions: \u00a7\n\u27e815\u27e9 https://docs.rs/lazy_static/latest/lazy_static/fn.initialize.html: fn lazy_static::initialize - initialize\n",
              "fit_markdown": "",
              "fit_html": ""
            },
            "structured_data": {},
            "quality_score": 4.0,
            "extraction_method": "crawl4ai",
            "error": null,
            "metadata": {
              "doc_type": "docs",
              "content_length": 3818,
              "has_structured_data": false,
              "crawl_success": true
            },
            "timestamp": "117918.3039735"
          },
          "lib_rs": {
            "url": "https://lib.rs/crates/lazy_static",
            "title": "Untitled",
            "content": {
              "raw_markdown": "###  [38 releases](https://lib.rs/crates/lazy_static/versions) (9 stable)\nUses old Rust 2015\n1.5.0 |  Jun 21, 2024   \n---|---  \n1.4.0 |  Aug 26, 2019   \n1.3.0 |  Feb 27, 2019   \n1.2.0 |  Nov 4, 2018   \n0.1.1 |  Nov 23, 2014   \n#**38** in [Rust patterns](https://lib.rs/rust-patterns \"Shared solutions for particular situations specific to programming in Rust.\")\nDownload history 4100053/week @ 2025-03-07 4229302/week @ 2025-03-14 4794114/week @ 2025-03-21 4118114/week @ 2025-03-28 4495333/week @ 2025-04-04 4358215/week @ 2025-04-11 4105890/week @ 2025-04-18 4127487/week @ 2025-04-25 3981514/week @ 2025-05-02 4149075/week @ 2025-05-09 4485437/week @ 2025-05-16 3633757/week @ 2025-05-23 3877348/week @ 2025-05-30 4160082/week @ 2025-06-06 5073490/week @ 2025-06-13 5242596/week @ 2025-06-20\n**19,000,736** downloads per month Used in [**49,361** crates (10,520 directly)](https://lib.rs/crates/lazy_static/rev)\n**MIT/Apache**\n15KB  125 lines\n# lazy-static.rs\nA macro for declaring lazily evaluated statics in Rust.\nUsing this macro, it is possible to have ```static```s that require code to be executed at runtime in order to be initialized. This includes anything requiring heap allocations, like vectors or hash maps, as well as anything that requires non-const function calls to be computed.\n[![Rust](https://img.gs/czjpqfbdkz/full/https://github.com/rust-lang-nursery/lazy-static.rs/actions/workflows/rust.yml/badge.svg)](https://github.com/rust-lang-nursery/lazy-static.rs/actions/workflows/rust.yml) [![Latest version](https://img.shields.io/crates/v/lazy_static.svg)](https://crates.io/crates/lazy_static) [![Documentation](https://img.gs/czjpqfbdkz/full/https://docs.rs/lazy_static/badge.svg)](https://docs.rs/lazy_static) [![License](https://img.shields.io/crates/l/lazy_static.svg)](https://github.com/rust-lang-nursery/lazy-static.rs#license)\n## Minimum supported ``rustc``\n```1.``40``.``0``+```\nThis version is explicitly tested in CI and may only be bumped in new minor versions. Any changes to the supported minimum version will be called out in the release notes.\n# Getting Started\n[lazy-static.rs is available on crates.io](https://crates.io/crates/lazy_static). It is recommended to look there for the newest released version, as well as links to the newest builds of the docs.\nAt the point of the last update of this README, the latest published version could be used like this:\nAdd the following dependency to your Cargo manifest...\n```\n```[``dependencies``]`\n`lazy_static ``=` ``\"`1.5.0`\"``\n``\n```\n\n...and see the [docs](https://docs.rs/lazy_static) for how to use it.\n# Example\n```\n``use` `lazy_static`::``lazy_static`;`\n`use` `std`::```collections`::``HashMap`;`\n`lazy_static!` ``{`\n  `static` `ref` `HASHMAP``:` `HashMap`<``u32`, `&``'static` `str``>`` `=` `{`\n    `let` `mut` m `=` `HashMap`::``new`(``)``;`\n    m`.``insert``(``0``,` ``\"`foo`\"```)``;`\n    m`.``insert``(``1``,` ``\"`bar`\"```)``;`\n    m`.``insert``(``2``,` ``\"`baz`\"```)``;`\n    m\n  `}``;`\n```}``\n``fn` `main`````(````)``````{`\n  ``//` First access to `HASHMAP` initializes it`\n  `println!``(```\"`The entry for `0` is `\\\"``{}``\\\"`.`\"```,` `HASHMAP``.``get``(``&``0``)``.``unwrap``(``)``)``;`\n  ``//` Any further access to `HASHMAP` just returns the computed value`\n  `println!``(```\"`The entry for `1` is `\\\"``{}``\\\"`.`\"```,` `HASHMAP``.``get``(``&``1``)``.``unwrap``(``)``)``;`\n```}```\n`\n```\n\n# Standard library\nIt is now possible to easily replicate this crate's functionality in Rust's standard library with [```std`::```sync`::``OnceLock``](https://doc.rust-lang.org/std/sync/struct.OnceLock.html). The example above could be also be written as:\n```\n``use` `std`::```collections`::``HashMap`;`\n`use` `std`::```sync`::``OnceLock`;`\n``fn` `hashmap`````(````)```` ``->` `&``'static` `HashMap`<``u32`, `&``'static` `str``>``` ````{`\n  `static` `HASHMAP``:` `OnceLock`<`HashMap`<``u32`, `&``str``>``>`` `=` `OnceLock`::``new`(``)``;`\n  `HASHMAP``.``get_or_init``(````|``````|`` ```{`\n    `let` `mut` m `=` `HashMap`::``new`(``)``;`\n    m`.``insert``(``0``,` ``\"`foo`\"```)``;`\n    m`.``insert``(``1``,` ``\"`bar`\"```)``;`\n    m`.``insert``(``2``,` ``\"`baz`\"```)``;`\n    m\n  `}```)`\n```}```\n``fn` `main`````(````)``````{`\n  ``//` First access to `HASHMAP` initializes it`\n  `println!``(```\"`The entry for `0` is `\\\"``{}``\\\"`.`\"```,` `hashmap``(``)``.``get``(``&``0``)``.``unwrap``(``)``)``;`\n  ``//` Any further access to `HASHMAP` just returns the computed value`\n  `println!``(```\"`The entry for `1` is `\\\"``{}``\\\"`.`\"```,` `hashmap``(``)``.``get``(``&``1``)``.``unwrap``(``)``)``;`\n```}```\n`\n```\n\n## License\nLicensed under either of\n  * Apache License, Version 2.0, ([LICENSE-APACHE](https://github.com/rust-lang-nursery/lazy-static.rs/blob/HEAD/LICENSE-APACHE) or <https://www.apache.org/licenses/LICENSE-2.0>)\n  * MIT license ([LICENSE-MIT](https://github.com/rust-lang-nursery/lazy-static.rs/blob/HEAD/LICENSE-MIT) or <https://opensource.org/licenses/MIT>)\n\n\nat your option.\n### Contribution\nUnless you explicitly state otherwise, any contribution intentionally submitted for inclusion in the work by you, as defined in the Apache-2.0 license, shall be dual licensed as above, without any additional terms or conditions.\n#### Dependencies\n~38KB \n  * [spin_no_std?](https://lib.rs/crates/lazy_static/features#feature-spin_no_std \"optional feature\") [spin](https://lib.rs/crates/spin \"outdated\") 0.9.8[+once](https://lib.rs/crates/spin/features#feature-once)\n\n\n  * dev  [doc-comment](https://lib.rs/crates/doc-comment \"0.3.1\")\n  * dev  [trybuild](https://lib.rs/crates/trybuild \"1\")\n\n\n",
              "markdown_with_citations": "###  38 releases\u27e81\u27e9 (9 stable)\nUses old Rust 2015\n1.5.0 |  Jun 21, 2024   \n---|---  \n1.4.0 |  Aug 26, 2019   \n1.3.0 |  Feb 27, 2019   \n1.2.0 |  Nov 4, 2018   \n0.1.1 |  Nov 23, 2014   \n#**38** in Rust patterns\u27e82\u27e9\nDownload history 4100053/week @ 2025-03-07 4229302/week @ 2025-03-14 4794114/week @ 2025-03-21 4118114/week @ 2025-03-28 4495333/week @ 2025-04-04 4358215/week @ 2025-04-11 4105890/week @ 2025-04-18 4127487/week @ 2025-04-25 3981514/week @ 2025-05-02 4149075/week @ 2025-05-09 4485437/week @ 2025-05-16 3633757/week @ 2025-05-23 3877348/week @ 2025-05-30 4160082/week @ 2025-06-06 5073490/week @ 2025-06-13 5242596/week @ 2025-06-20\n**19,000,736** downloads per month Used in **49,361** crates (10,520 directly)\u27e83\u27e9\n**MIT/Apache**\n15KB  125 lines\n# lazy-static.rs\nA macro for declaring lazily evaluated statics in Rust.\nUsing this macro, it is possible to have ```static```s that require code to be executed at runtime in order to be initialized. This includes anything requiring heap allocations, like vectors or hash maps, as well as anything that requires non-const function calls to be computed.\n![Rust\u27e84\u27e9](https://github.com/rust-lang-nursery/lazy-static.rs/actions/workflows/rust.yml) ![Latest version\u27e85\u27e9](https://crates.io/crates/lazy_static) ![Documentation\u27e86\u27e9](https://docs.rs/lazy_static) ![License\u27e87\u27e9](https://github.com/rust-lang-nursery/lazy-static.rs#license)\n## Minimum supported ``rustc``\n```1.``40``.``0``+```\nThis version is explicitly tested in CI and may only be bumped in new minor versions. Any changes to the supported minimum version will be called out in the release notes.\n# Getting Started\nlazy-static.rs is available on crates.io\u27e88\u27e9. It is recommended to look there for the newest released version, as well as links to the newest builds of the docs.\nAt the point of the last update of this README, the latest published version could be used like this:\nAdd the following dependency to your Cargo manifest...\n```\n```[``dependencies``]`\n`lazy_static ``=` ``\"`1.5.0`\"``\n``\n```\n\n...and see the docs\u27e89\u27e9 for how to use it.\n# Example\n```\n``use` `lazy_static`::``lazy_static`;`\n`use` `std`::```collections`::``HashMap`;`\n`lazy_static!` ``{`\n  `static` `ref` `HASHMAP``:` `HashMap`<``u32`, `&``'static` `str``>`` `=` `{`\n    `let` `mut` m `=` `HashMap`::``new`(``)``;`\n    m`.``insert``(``0``,` ``\"`foo`\"```)``;`\n    m`.``insert``(``1``,` ``\"`bar`\"```)``;`\n    m`.``insert``(``2``,` ``\"`baz`\"```)``;`\n    m\n  `}``;`\n```}``\n``fn` `main`````(````)``````{`\n  ``//` First access to `HASHMAP` initializes it`\n  `println!``(```\"`The entry for `0` is `\\\"``{}``\\\"`.`\"```,` `HASHMAP``.``get``(``&``0``)``.``unwrap``(``)``)``;`\n  ``//` Any further access to `HASHMAP` just returns the computed value`\n  `println!``(```\"`The entry for `1` is `\\\"``{}``\\\"`.`\"```,` `HASHMAP``.``get``(``&``1``)``.``unwrap``(``)``)``;`\n```}```\n`\n```\n\n# Standard library\nIt is now possible to easily replicate this crate's functionality in Rust's standard library with ```std`::```sync`::``OnceLock``\u27e810\u27e9. The example above could be also be written as:\n```\n``use` `std`::```collections`::``HashMap`;`\n`use` `std`::```sync`::``OnceLock`;`\n``fn` `hashmap`````(````)```` ``->` `&``'static` `HashMap`<``u32`, `&``'static` `str``>``` ````{`\n  `static` `HASHMAP``:` `OnceLock`<`HashMap`<``u32`, `&``str``>``>`` `=` `OnceLock`::``new`(``)``;`\n  `HASHMAP``.``get_or_init``(````|``````|`` ```{`\n    `let` `mut` m `=` `HashMap`::``new`(``)``;`\n    m`.``insert``(``0``,` ``\"`foo`\"```)``;`\n    m`.``insert``(``1``,` ``\"`bar`\"```)``;`\n    m`.``insert``(``2``,` ``\"`baz`\"```)``;`\n    m\n  `}```)`\n```}```\n``fn` `main`````(````)``````{`\n  ``//` First access to `HASHMAP` initializes it`\n  `println!``(```\"`The entry for `0` is `\\\"``{}``\\\"`.`\"```,` `hashmap``(``)``.``get``(``&``0``)``.``unwrap``(``)``)``;`\n  ``//` Any further access to `HASHMAP` just returns the computed value`\n  `println!``(```\"`The entry for `1` is `\\\"``{}``\\\"`.`\"```,` `hashmap``(``)``.``get``(``&``1``)``.``unwrap``(``)``)``;`\n```}```\n`\n```\n\n## License\nLicensed under either of\n  * Apache License, Version 2.0, (LICENSE-APACHE\u27e811\u27e9 or <https://www.apache.org/licenses/LICENSE-2.0>)\n  * MIT license (LICENSE-MIT\u27e812\u27e9 or <https://opensource.org/licenses/MIT>)\n\n\nat your option.\n### Contribution\nUnless you explicitly state otherwise, any contribution intentionally submitted for inclusion in the work by you, as defined in the Apache-2.0 license, shall be dual licensed as above, without any additional terms or conditions.\n#### Dependencies\n~38KB \n  * spin_no_std?\u27e813\u27e9 spin\u27e814\u27e9 0.9.8+once\u27e815\u27e9\n\n\n  * dev  doc-comment\u27e816\u27e9\n  * dev  trybuild\u27e817\u27e9\n\n\n",
              "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://lib.rs/crates/lazy_static/versions: 38 releases\n\u27e82\u27e9 https://lib.rs/rust-patterns: Shared solutions for particular situations specific to programming in Rust. - Rust patterns\n\u27e83\u27e9 https://lib.rs/crates/lazy_static/rev: **49,361** crates (10,520 directly)\n\u27e84\u27e9 https://img.gs/czjpqfbdkz/full/https://github.com/rust-lang-nursery/lazy-static.rs/actions/workflows/rust.yml/badge.svg: ![Rust\n\u27e85\u27e9 https://img.shields.io/crates/v/lazy_static.svg: ![Latest version\n\u27e86\u27e9 https://img.gs/czjpqfbdkz/full/https://docs.rs/lazy_static/badge.svg: ![Documentation\n\u27e87\u27e9 https://img.shields.io/crates/l/lazy_static.svg: ![License\n\u27e88\u27e9 https://crates.io/crates/lazy_static: lazy-static.rs is available on crates.io\n\u27e89\u27e9 https://docs.rs/lazy_static: docs\n\u27e810\u27e9 https://doc.rust-lang.org/std/sync/struct.OnceLock.html: ```std`::```sync`::``OnceLock``\n\u27e811\u27e9 https://github.com/rust-lang-nursery/lazy-static.rs/blob/HEAD/LICENSE-APACHE: LICENSE-APACHE\n\u27e812\u27e9 https://github.com/rust-lang-nursery/lazy-static.rs/blob/HEAD/LICENSE-MIT: LICENSE-MIT\n\u27e813\u27e9 https://lib.rs/crates/lazy_static/features#feature-spin_no_std: optional feature - spin_no_std?\n\u27e814\u27e9 https://lib.rs/crates/spin: outdated - spin\n\u27e815\u27e9 https://lib.rs/crates/spin/features#feature-once: +once\n\u27e816\u27e9 https://lib.rs/crates/doc-comment: 0.3.1 - doc-comment\n\u27e817\u27e9 https://lib.rs/crates/trybuild: 1 - trybuild\n",
              "fit_markdown": "",
              "fit_html": ""
            },
            "structured_data": {},
            "quality_score": 3.0,
            "extraction_method": "crawl4ai",
            "error": null,
            "metadata": {
              "doc_type": "docs",
              "content_length": 5578,
              "has_structured_data": false,
              "crawl_success": true
            },
            "timestamp": "117918.7084157"
          }
        },
        "crate_analysis": {
          "status": "completed",
          "check": [
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmp1izags19/lazy_static-1.5.0#lazy_static@1.5.0",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp1izags19\\lazy_static-1.5.0\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "lazy_static",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp1izags19\\lazy_static-1.5.0\\src\\lib.rs",
                "edition": "2015",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: elided lifetime has a name\n  --> src\\inline_lazy.rs:26:43\n   |\n26 |     pub fn get<F>(&'static self, f: F) -> &T\n   |                                           ^ this elided lifetime gets resolved as `'static`\n   |\n   = note: `#[warn(elided_named_lifetimes)]` on by default\nhelp: consider specifying it explicitly\n   |\n26 |     pub fn get<F>(&'static self, f: F) -> &'static T\n   |                                            +++++++\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "note",
                    "message": "`#[warn(elided_named_lifetimes)]` on by default",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "consider specifying it explicitly",
                    "rendered": null,
                    "spans": [
                      {
                        "byte_end": 844,
                        "byte_start": 844,
                        "column_end": 44,
                        "column_start": 44,
                        "expansion": null,
                        "file_name": "src\\inline_lazy.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 26,
                        "line_start": 26,
                        "suggested_replacement": "'static ",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 44,
                            "highlight_start": 44,
                            "text": "    pub fn get<F>(&'static self, f: F) -> &T"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "code": {
                  "code": "elided_named_lifetimes",
                  "explanation": null
                },
                "level": "warning",
                "message": "elided lifetime has a name",
                "spans": [
                  {
                    "byte_end": 844,
                    "byte_start": 843,
                    "column_end": 44,
                    "column_start": 43,
                    "expansion": null,
                    "file_name": "src\\inline_lazy.rs",
                    "is_primary": true,
                    "label": "this elided lifetime gets resolved as `'static`",
                    "line_end": 26,
                    "line_start": 26,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 44,
                        "highlight_start": 43,
                        "text": "    pub fn get<F>(&'static self, f: F) -> &T"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-artifact",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmp1izags19/lazy_static-1.5.0#lazy_static@1.5.0",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp1izags19\\lazy_static-1.5.0\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "lazy_static",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp1izags19\\lazy_static-1.5.0\\src\\lib.rs",
                "edition": "2015",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp1izags19\\lazy_static-1.5.0\\target\\debug\\deps\\liblazy_static-8c35b374178a02de.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "build-finished",
              "success": true
            }
          ],
          "clippy": [
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmp1izags19/lazy_static-1.5.0#lazy_static@1.5.0",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp1izags19\\lazy_static-1.5.0\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "lazy_static",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp1izags19\\lazy_static-1.5.0\\src\\lib.rs",
                "edition": "2015",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: elided lifetime has a name\n  --> src\\inline_lazy.rs:26:43\n   |\n26 |     pub fn get<F>(&'static self, f: F) -> &T\n   |                                           ^ this elided lifetime gets resolved as `'static`\n   |\n   = note: `#[warn(elided_named_lifetimes)]` on by default\nhelp: consider specifying it explicitly\n   |\n26 |     pub fn get<F>(&'static self, f: F) -> &'static T\n   |                                            +++++++\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "note",
                    "message": "`#[warn(elided_named_lifetimes)]` on by default",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "consider specifying it explicitly",
                    "rendered": null,
                    "spans": [
                      {
                        "byte_end": 844,
                        "byte_start": 844,
                        "column_end": 44,
                        "column_start": 44,
                        "expansion": null,
                        "file_name": "src\\inline_lazy.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 26,
                        "line_start": 26,
                        "suggested_replacement": "'static ",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 44,
                            "highlight_start": 44,
                            "text": "    pub fn get<F>(&'static self, f: F) -> &T"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "code": {
                  "code": "elided_named_lifetimes",
                  "explanation": null
                },
                "level": "warning",
                "message": "elided lifetime has a name",
                "spans": [
                  {
                    "byte_end": 844,
                    "byte_start": 843,
                    "column_end": 44,
                    "column_start": 43,
                    "expansion": null,
                    "file_name": "src\\inline_lazy.rs",
                    "is_primary": true,
                    "label": "this elided lifetime gets resolved as `'static`",
                    "line_end": 26,
                    "line_start": 26,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 44,
                        "highlight_start": 43,
                        "text": "    pub fn get<F>(&'static self, f: F) -> &T"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmp1izags19/lazy_static-1.5.0#lazy_static@1.5.0",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp1izags19\\lazy_static-1.5.0\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "lazy_static",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp1izags19\\lazy_static-1.5.0\\src\\lib.rs",
                "edition": "2015",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: a `const` item should not be interior mutable\n  --> src\\inline_lazy.rs:23:5\n   |\n23 |     pub const INIT: Self = Lazy(Cell::new(MaybeUninit::uninit()), ONCE_INIT);\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#declare_interior_mutable_const\n   = note: `#[warn(clippy::declare_interior_mutable_const)]` on by default\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#declare_interior_mutable_const",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "note",
                    "message": "`#[warn(clippy::declare_interior_mutable_const)]` on by default",
                    "rendered": null,
                    "spans": []
                  }
                ],
                "code": {
                  "code": "clippy::declare_interior_mutable_const",
                  "explanation": null
                },
                "level": "warning",
                "message": "a `const` item should not be interior mutable",
                "spans": [
                  {
                    "byte_end": 777,
                    "byte_start": 704,
                    "column_end": 78,
                    "column_start": 5,
                    "expansion": null,
                    "file_name": "src\\inline_lazy.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 23,
                    "line_start": 23,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 78,
                        "highlight_start": 5,
                        "text": "    pub const INIT: Self = Lazy(Cell::new(MaybeUninit::uninit()), ONCE_INIT);"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-artifact",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmp1izags19/lazy_static-1.5.0#lazy_static@1.5.0",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp1izags19\\lazy_static-1.5.0\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "lazy_static",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp1izags19\\lazy_static-1.5.0\\src\\lib.rs",
                "edition": "2015",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp1izags19\\lazy_static-1.5.0\\target\\debug\\deps\\liblazy_static-8ae9466ec2e899a8.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "build-finished",
              "success": true
            }
          ],
          "audit": {
            "database": {
              "advisory-count": 787,
              "last-commit": "7573f55ba337263f61167dbb0ea926cdc7c8eb5d",
              "last-updated": "2025-06-17T11:04:25+02:00"
            },
            "lockfile": {
              "dependency-count": 35
            },
            "settings": {
              "target_arch": [],
              "target_os": [],
              "severity": null,
              "ignore": [],
              "informational_warnings": [
                "unmaintained",
                "unsound",
                "notice"
              ]
            },
            "vulnerabilities": {
              "found": false,
              "count": 0,
              "list": []
            },
            "warnings": {}
          },
          "note": "Crate analysis performed with stable toolchain."
        },
        "crate_metadata": {
          "name": "lazy_static",
          "version": "1.5.0",
          "description": "ALLOW: Positive community sentiment",
          "repository": "",
          "keywords": [],
          "categories": [],
          "readme": {
            "raw_markdown": "[](https://docs.rs/lazy_static/latest/lazy_static/all.html \"show sidebar\")\n# Crate lazy_staticCopy item path\n[Settings](https://docs.rs/lazy_static/latest/settings.html)\n[Help](https://docs.rs/lazy_static/latest/help.html)\nSummary[Source](https://docs.rs/lazy_static/latest/src/lazy_static/lib.rs.html#8-208)\nExpand description\nA macro for declaring lazily evaluated statics.\nUsing this macro, it is possible to have `static`s that require code to be executed at runtime in order to be initialized. This includes anything requiring heap allocations, like vectors or hash maps, as well as anything that requires function calls to be computed.\n## [\u00a7](https://docs.rs/lazy_static/latest/lazy_static/#syntax)Syntax\n[\u24d8](https://docs.rs/lazy_static/latest/lazy_static/ \"This example is not tested\")```\nlazy_static! {\n  [pub] static ref NAME_1: TYPE_1 = EXPR_1;\n  [pub] static ref NAME_2: TYPE_2 = EXPR_2;\n  ...\n  [pub] static ref NAME_N: TYPE_N = EXPR_N;\n}\n```\n\nAttributes (including doc comments) are supported as well:\n```\nuse lazy_static::lazy_static;\nlazy_static! {\n  /// This is an example for using doc comment attributes\n  static ref EXAMPLE: u8 = 42;\n}\n```\n\n## [\u00a7](https://docs.rs/lazy_static/latest/lazy_static/#semantics)Semantics\nFor a given `static ref NAME: TYPE = EXPR;`, the macro generates a unique type that implements `Deref<TYPE>` and stores it in a static with name `NAME`. (Attributes end up attaching to this type.)\nOn first deref, `EXPR` gets evaluated and stored internally, such that all further derefs can return a reference to the same object. Note that this can lead to deadlocks if you have multiple lazy statics that depend on each other in their initialization.\nApart from the lazy initialization, the resulting \u201cstatic ref\u201d variables have generally the same properties as regular \u201cstatic\u201d variables:\n  * Any type in them needs to fulfill the `Sync` trait.\n  * If the type has a destructor, then it will not run when the process exits.\n\n\n## [\u00a7](https://docs.rs/lazy_static/latest/lazy_static/#example)Example\nUsing the macro:\n```\nuse lazy_static::lazy_static;\nuse std::collections::HashMap;\nlazy_static! {\n  static ref HASHMAP: HashMap<u32, &'static str> = {\n    let mut m = HashMap::new();\n    m.insert(0, \"foo\");\n    m.insert(1, \"bar\");\n    m.insert(2, \"baz\");\n    m\n  };\n  static ref COUNT: usize = HASHMAP.len();\n  static ref NUMBER: u32 = times_two(21);\n}\nfn times_two(n: u32) -> u32 { n * 2 }\nfn main() {\n  println!(\"The map has {} entries.\", *COUNT);\n  println!(\"The entry for `0` is \\\"{}\\\".\", HASHMAP.get(&0).unwrap());\n  println!(\"A expensive calculation on a static results in: {}.\", *NUMBER);\n}\n```\n\n## [\u00a7](https://docs.rs/lazy_static/latest/lazy_static/#implementation-details)Implementation details\nThe `Deref` implementation uses a hidden static variable that is guarded by an atomic check on each access.\n## [\u00a7](https://docs.rs/lazy_static/latest/lazy_static/#cargo-features)Cargo features\nThis crate provides one cargo feature:\n  * `spin_no_std`: This allows using this crate in a no-std environment, by depending on the standalone `spin` crate.\n\n\n## Macros[\u00a7](https://docs.rs/lazy_static/latest/lazy_static/#macros)\n\n[lazy_static](https://docs.rs/lazy_static/latest/lazy_static/macro.lazy_static.html \"macro lazy_static::lazy_static\")\n\n## Traits[\u00a7](https://docs.rs/lazy_static/latest/lazy_static/#traits)\n\n[LazyStatic](https://docs.rs/lazy_static/latest/lazy_static/trait.LazyStatic.html \"trait lazy_static::LazyStatic\")\n    Support trait for enabling a few common operation on lazy static values.\n## Functions[\u00a7](https://docs.rs/lazy_static/latest/lazy_static/#functions)\n\n[initialize](https://docs.rs/lazy_static/latest/lazy_static/fn.initialize.html \"fn lazy_static::initialize\")\n    Takes a shared reference to a lazy static and initializes it if it has not been already.\n",
            "markdown_with_citations": "[](https://docs.rs/lazy_static/latest/lazy_static/all.html \"show sidebar\")\n# Crate lazy_staticCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nA macro for declaring lazily evaluated statics.\nUsing this macro, it is possible to have `static`s that require code to be executed at runtime in order to be initialized. This includes anything requiring heap allocations, like vectors or hash maps, as well as anything that requires function calls to be computed.\n## \u00a7\u27e84\u27e9Syntax\n\u24d8\u27e85\u27e9```\nlazy_static! {\n  [pub] static ref NAME_1: TYPE_1 = EXPR_1;\n  [pub] static ref NAME_2: TYPE_2 = EXPR_2;\n  ...\n  [pub] static ref NAME_N: TYPE_N = EXPR_N;\n}\n```\n\nAttributes (including doc comments) are supported as well:\n```\nuse lazy_static::lazy_static;\nlazy_static! {\n  /// This is an example for using doc comment attributes\n  static ref EXAMPLE: u8 = 42;\n}\n```\n\n## \u00a7\u27e86\u27e9Semantics\nFor a given `static ref NAME: TYPE = EXPR;`, the macro generates a unique type that implements `Deref<TYPE>` and stores it in a static with name `NAME`. (Attributes end up attaching to this type.)\nOn first deref, `EXPR` gets evaluated and stored internally, such that all further derefs can return a reference to the same object. Note that this can lead to deadlocks if you have multiple lazy statics that depend on each other in their initialization.\nApart from the lazy initialization, the resulting \u201cstatic ref\u201d variables have generally the same properties as regular \u201cstatic\u201d variables:\n  * Any type in them needs to fulfill the `Sync` trait.\n  * If the type has a destructor, then it will not run when the process exits.\n\n\n## \u00a7\u27e87\u27e9Example\nUsing the macro:\n```\nuse lazy_static::lazy_static;\nuse std::collections::HashMap;\nlazy_static! {\n  static ref HASHMAP: HashMap<u32, &'static str> = {\n    let mut m = HashMap::new();\n    m.insert(0, \"foo\");\n    m.insert(1, \"bar\");\n    m.insert(2, \"baz\");\n    m\n  };\n  static ref COUNT: usize = HASHMAP.len();\n  static ref NUMBER: u32 = times_two(21);\n}\nfn times_two(n: u32) -> u32 { n * 2 }\nfn main() {\n  println!(\"The map has {} entries.\", *COUNT);\n  println!(\"The entry for `0` is \\\"{}\\\".\", HASHMAP.get(&0).unwrap());\n  println!(\"A expensive calculation on a static results in: {}.\", *NUMBER);\n}\n```\n\n## \u00a7\u27e88\u27e9Implementation details\nThe `Deref` implementation uses a hidden static variable that is guarded by an atomic check on each access.\n## \u00a7\u27e89\u27e9Cargo features\nThis crate provides one cargo feature:\n  * `spin_no_std`: This allows using this crate in a no-std environment, by depending on the standalone `spin` crate.\n\n\n## Macros\u00a7\u27e810\u27e9\n\nlazy_static\u27e811\u27e9\n\n## Traits\u00a7\u27e812\u27e9\n\nLazyStatic\u27e813\u27e9\n    Support trait for enabling a few common operation on lazy static values.\n## Functions\u00a7\u27e814\u27e9\n\ninitialize\u27e815\u27e9\n    Takes a shared reference to a lazy static and initializes it if it has not been already.\n",
            "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/lazy_static/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/lazy_static/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/lazy_static/latest/src/lazy_static/lib.rs.html#8-208: Source\n\u27e84\u27e9 https://docs.rs/lazy_static/latest/lazy_static/#syntax: \u00a7\n\u27e85\u27e9 https://docs.rs/lazy_static/latest/lazy_static/: This example is not tested - \u24d8\n\u27e86\u27e9 https://docs.rs/lazy_static/latest/lazy_static/#semantics: \u00a7\n\u27e87\u27e9 https://docs.rs/lazy_static/latest/lazy_static/#example: \u00a7\n\u27e88\u27e9 https://docs.rs/lazy_static/latest/lazy_static/#implementation-details: \u00a7\n\u27e89\u27e9 https://docs.rs/lazy_static/latest/lazy_static/#cargo-features: \u00a7\n\u27e810\u27e9 https://docs.rs/lazy_static/latest/lazy_static/#macros: \u00a7\n\u27e811\u27e9 https://docs.rs/lazy_static/latest/lazy_static/macro.lazy_static.html: macro lazy_static::lazy_static - lazy_static\n\u27e812\u27e9 https://docs.rs/lazy_static/latest/lazy_static/#traits: \u00a7\n\u27e813\u27e9 https://docs.rs/lazy_static/latest/lazy_static/trait.LazyStatic.html: trait lazy_static::LazyStatic - LazyStatic\n\u27e814\u27e9 https://docs.rs/lazy_static/latest/lazy_static/#functions: \u00a7\n\u27e815\u27e9 https://docs.rs/lazy_static/latest/lazy_static/fn.initialize.html: fn lazy_static::initialize - initialize\n",
            "fit_markdown": "",
            "fit_html": ""
          },
          "downloads": 0,
          "github_stars": 0,
          "dependencies": [],
          "features": {},
          "code_snippets": [],
          "readme_sections": {},
          "librs_downloads": null,
          "source": "crates.io",
          "enhanced_scraping": {},
          "enhanced_features": [],
          "enhanced_dependencies": []
        },
        "enriched_crate": {
          "name": "lazy_static",
          "version": "1.5.0",
          "description": "ALLOW: Positive community sentiment",
          "repository": "",
          "keywords": [],
          "categories": [],
          "readme": {
            "raw_markdown": "[](https://docs.rs/lazy_static/latest/lazy_static/all.html \"show sidebar\")\n# Crate lazy_staticCopy item path\n[Settings](https://docs.rs/lazy_static/latest/settings.html)\n[Help](https://docs.rs/lazy_static/latest/help.html)\nSummary[Source](https://docs.rs/lazy_static/latest/src/lazy_static/lib.rs.html#8-208)\nExpand description\nA macro for declaring lazily evaluated statics.\nUsing this macro, it is possible to have `static`s that require code to be executed at runtime in order to be initialized. This includes anything requiring heap allocations, like vectors or hash maps, as well as anything that requires function calls to be computed.\n## [\u00a7](https://docs.rs/lazy_static/latest/lazy_static/#syntax)Syntax\n[\u24d8](https://docs.rs/lazy_static/latest/lazy_static/ \"This example is not tested\")```\nlazy_static! {\n  [pub] static ref NAME_1: TYPE_1 = EXPR_1;\n  [pub] static ref NAME_2: TYPE_2 = EXPR_2;\n  ...\n  [pub] static ref NAME_N: TYPE_N = EXPR_N;\n}\n```\n\nAttributes (including doc comments) are supported as well:\n```\nuse lazy_static::lazy_static;\nlazy_static! {\n  /// This is an example for using doc comment attributes\n  static ref EXAMPLE: u8 = 42;\n}\n```\n\n## [\u00a7](https://docs.rs/lazy_static/latest/lazy_static/#semantics)Semantics\nFor a given `static ref NAME: TYPE = EXPR;`, the macro generates a unique type that implements `Deref<TYPE>` and stores it in a static with name `NAME`. (Attributes end up attaching to this type.)\nOn first deref, `EXPR` gets evaluated and stored internally, such that all further derefs can return a reference to the same object. Note that this can lead to deadlocks if you have multiple lazy statics that depend on each other in their initialization.\nApart from the lazy initialization, the resulting \u201cstatic ref\u201d variables have generally the same properties as regular \u201cstatic\u201d variables:\n  * Any type in them needs to fulfill the `Sync` trait.\n  * If the type has a destructor, then it will not run when the process exits.\n\n\n## [\u00a7](https://docs.rs/lazy_static/latest/lazy_static/#example)Example\nUsing the macro:\n```\nuse lazy_static::lazy_static;\nuse std::collections::HashMap;\nlazy_static! {\n  static ref HASHMAP: HashMap<u32, &'static str> = {\n    let mut m = HashMap::new();\n    m.insert(0, \"foo\");\n    m.insert(1, \"bar\");\n    m.insert(2, \"baz\");\n    m\n  };\n  static ref COUNT: usize = HASHMAP.len();\n  static ref NUMBER: u32 = times_two(21);\n}\nfn times_two(n: u32) -> u32 { n * 2 }\nfn main() {\n  println!(\"The map has {} entries.\", *COUNT);\n  println!(\"The entry for `0` is \\\"{}\\\".\", HASHMAP.get(&0).unwrap());\n  println!(\"A expensive calculation on a static results in: {}.\", *NUMBER);\n}\n```\n\n## [\u00a7](https://docs.rs/lazy_static/latest/lazy_static/#implementation-details)Implementation details\nThe `Deref` implementation uses a hidden static variable that is guarded by an atomic check on each access.\n## [\u00a7](https://docs.rs/lazy_static/latest/lazy_static/#cargo-features)Cargo features\nThis crate provides one cargo feature:\n  * `spin_no_std`: This allows using this crate in a no-std environment, by depending on the standalone `spin` crate.\n\n\n## Macros[\u00a7](https://docs.rs/lazy_static/latest/lazy_static/#macros)\n\n[lazy_static](https://docs.rs/lazy_static/latest/lazy_static/macro.lazy_static.html \"macro lazy_static::lazy_static\")\n\n## Traits[\u00a7](https://docs.rs/lazy_static/latest/lazy_static/#traits)\n\n[LazyStatic](https://docs.rs/lazy_static/latest/lazy_static/trait.LazyStatic.html \"trait lazy_static::LazyStatic\")\n    Support trait for enabling a few common operation on lazy static values.\n## Functions[\u00a7](https://docs.rs/lazy_static/latest/lazy_static/#functions)\n\n[initialize](https://docs.rs/lazy_static/latest/lazy_static/fn.initialize.html \"fn lazy_static::initialize\")\n    Takes a shared reference to a lazy static and initializes it if it has not been already.\n",
            "markdown_with_citations": "[](https://docs.rs/lazy_static/latest/lazy_static/all.html \"show sidebar\")\n# Crate lazy_staticCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nA macro for declaring lazily evaluated statics.\nUsing this macro, it is possible to have `static`s that require code to be executed at runtime in order to be initialized. This includes anything requiring heap allocations, like vectors or hash maps, as well as anything that requires function calls to be computed.\n## \u00a7\u27e84\u27e9Syntax\n\u24d8\u27e85\u27e9```\nlazy_static! {\n  [pub] static ref NAME_1: TYPE_1 = EXPR_1;\n  [pub] static ref NAME_2: TYPE_2 = EXPR_2;\n  ...\n  [pub] static ref NAME_N: TYPE_N = EXPR_N;\n}\n```\n\nAttributes (including doc comments) are supported as well:\n```\nuse lazy_static::lazy_static;\nlazy_static! {\n  /// This is an example for using doc comment attributes\n  static ref EXAMPLE: u8 = 42;\n}\n```\n\n## \u00a7\u27e86\u27e9Semantics\nFor a given `static ref NAME: TYPE = EXPR;`, the macro generates a unique type that implements `Deref<TYPE>` and stores it in a static with name `NAME`. (Attributes end up attaching to this type.)\nOn first deref, `EXPR` gets evaluated and stored internally, such that all further derefs can return a reference to the same object. Note that this can lead to deadlocks if you have multiple lazy statics that depend on each other in their initialization.\nApart from the lazy initialization, the resulting \u201cstatic ref\u201d variables have generally the same properties as regular \u201cstatic\u201d variables:\n  * Any type in them needs to fulfill the `Sync` trait.\n  * If the type has a destructor, then it will not run when the process exits.\n\n\n## \u00a7\u27e87\u27e9Example\nUsing the macro:\n```\nuse lazy_static::lazy_static;\nuse std::collections::HashMap;\nlazy_static! {\n  static ref HASHMAP: HashMap<u32, &'static str> = {\n    let mut m = HashMap::new();\n    m.insert(0, \"foo\");\n    m.insert(1, \"bar\");\n    m.insert(2, \"baz\");\n    m\n  };\n  static ref COUNT: usize = HASHMAP.len();\n  static ref NUMBER: u32 = times_two(21);\n}\nfn times_two(n: u32) -> u32 { n * 2 }\nfn main() {\n  println!(\"The map has {} entries.\", *COUNT);\n  println!(\"The entry for `0` is \\\"{}\\\".\", HASHMAP.get(&0).unwrap());\n  println!(\"A expensive calculation on a static results in: {}.\", *NUMBER);\n}\n```\n\n## \u00a7\u27e88\u27e9Implementation details\nThe `Deref` implementation uses a hidden static variable that is guarded by an atomic check on each access.\n## \u00a7\u27e89\u27e9Cargo features\nThis crate provides one cargo feature:\n  * `spin_no_std`: This allows using this crate in a no-std environment, by depending on the standalone `spin` crate.\n\n\n## Macros\u00a7\u27e810\u27e9\n\nlazy_static\u27e811\u27e9\n\n## Traits\u00a7\u27e812\u27e9\n\nLazyStatic\u27e813\u27e9\n    Support trait for enabling a few common operation on lazy static values.\n## Functions\u00a7\u27e814\u27e9\n\ninitialize\u27e815\u27e9\n    Takes a shared reference to a lazy static and initializes it if it has not been already.\n",
            "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/lazy_static/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/lazy_static/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/lazy_static/latest/src/lazy_static/lib.rs.html#8-208: Source\n\u27e84\u27e9 https://docs.rs/lazy_static/latest/lazy_static/#syntax: \u00a7\n\u27e85\u27e9 https://docs.rs/lazy_static/latest/lazy_static/: This example is not tested - \u24d8\n\u27e86\u27e9 https://docs.rs/lazy_static/latest/lazy_static/#semantics: \u00a7\n\u27e87\u27e9 https://docs.rs/lazy_static/latest/lazy_static/#example: \u00a7\n\u27e88\u27e9 https://docs.rs/lazy_static/latest/lazy_static/#implementation-details: \u00a7\n\u27e89\u27e9 https://docs.rs/lazy_static/latest/lazy_static/#cargo-features: \u00a7\n\u27e810\u27e9 https://docs.rs/lazy_static/latest/lazy_static/#macros: \u00a7\n\u27e811\u27e9 https://docs.rs/lazy_static/latest/lazy_static/macro.lazy_static.html: macro lazy_static::lazy_static - lazy_static\n\u27e812\u27e9 https://docs.rs/lazy_static/latest/lazy_static/#traits: \u00a7\n\u27e813\u27e9 https://docs.rs/lazy_static/latest/lazy_static/trait.LazyStatic.html: trait lazy_static::LazyStatic - LazyStatic\n\u27e814\u27e9 https://docs.rs/lazy_static/latest/lazy_static/#functions: \u00a7\n\u27e815\u27e9 https://docs.rs/lazy_static/latest/lazy_static/fn.initialize.html: fn lazy_static::initialize - initialize\n",
            "fit_markdown": "",
            "fit_html": ""
          },
          "downloads": 0,
          "github_stars": 0,
          "dependencies": [],
          "features": {},
          "code_snippets": [],
          "readme_sections": {},
          "librs_downloads": null,
          "source": "crates.io",
          "enhanced_scraping": {},
          "enhanced_features": [],
          "enhanced_dependencies": [],
          "readme_summary": "The `lazy_static` crate provides a macro for defining lazily evaluated static variables in Rust, enabling runtime initialization for complex types like collections or computed values. It ensures thread-safe access via `Deref`, evaluates the static only once, and supports attributes and documentation comments. Additionally, it offers a `spin_no_std` feature for use in no-std environments.",
          "feature_summary": null,
          "use_case": "Utilities",
          "score": 8.5,
          "factual_counterfactual": "### Pair 1: Lazy Initialization Mechanism  \n\u2705 Factual: The `lazy_static` crate allows the creation of lazily evaluated static variables, where initialization occurs only on first access.  \n\u274c Counterfactual: The `lazy_static` crate initializes all static variables at compile time, ensuring they are ready before the program starts execution.  \n\n---\n\n### Pair 2: Thread Safety  \n\u2705 Factual: All types used in `lazy_static` must implement the `Sync` trait to ensure thread safety during lazy initialization.  \n\u274c Counterfactual: The `lazy_static` crate does not enforce the `Sync` trait, allowing non-thread-safe types to be used in lazy static variables.  \n\n---\n\n### Pair 3: No-std Support  \n\u2705 Factual: The `lazy_static` crate provides a `spin_no_std` feature, enabling its use in `no_std` environments by relying on the `spin` crate for synchronization.  \n\u274c Counterfactual: The `lazy_static` crate cannot be used in `no_std` environments, as it always depends on standard library synchronization primitives.",
          "source_analysis": null,
          "user_behavior": null,
          "security": null
        }
      },
      "irl_score": 8.6,
      "execution_id": "exec-d71256c0-70368c1c-1751264127",
      "timestamp": "2025-06-30T06:15:27.595806+00:00",
      "canon_version": "1.3.0"
    },
    "rule_zero_compliant": true
  }
]