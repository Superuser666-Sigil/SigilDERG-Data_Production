[
  {
    "execution_id": "exec-d452418b-793cee25-1751260641",
    "timestamp": "2025-06-30T05:17:21.719512+00:00",
    "sacred_chain": {
      "input_data": "once_cell",
      "context_sources": [
        "crates.io",
        "github.com",
        "lib.rs",
        "docs.rs"
      ],
      "reasoning_steps": [
        "Input canonicalized: 'once_cell' -> 'once_cell'",
        "Context gathered from 4 validated sources",
        "Metadata extracted: 4 fields",
        "Documentation analyzed: quality 7.0",
        "Sentiment analyzed: positive",
        "Ecosystem analyzed: utilities",
        "Quality score synthesized: 7.50",
        "Trust decision: DEFER - Insufficient data for decision",
        "IRL confidence: 8.600"
      ],
      "suggestion": "ALLOW: Positive community sentiment",
      "verdict": "DEFER",
      "audit_info": {
        "metadata": {
          "name": "once_cell",
          "type": "rust_crate",
          "source": "manual_input",
          "extraction_method": "irl_engine"
        },
        "sentiment": {
          "quality_score": 7.0,
          "completeness": 0.8,
          "examples_present": true,
          "api_documented": true
        },
        "ecosystem": {
          "overall": "positive",
          "positive_mentions": 10,
          "negative_mentions": 2,
          "neutral_mentions": 5,
          "total_mentions": 17
        },
        "quality_score": 7.5,
        "verdict_reason": "Insufficient data for decision",
        "sanitized_documentation": {
          "crates_io": {
            "url": "https://crates.io/crates/once_cell",
            "title": "once_cell v1.21.3",
            "content": {
              "raw_markdown": "#  once_cell v1.21.3\nSingle assignment cells and lazy values. \n  * [ #lazy ](https://crates.io/keywords/lazy)\n  * [ #static ](https://crates.io/keywords/static)\n\n\n  * [ Readme ](https://crates.io/crates/once_cell)\n  * [ 66 Versions ](https://crates.io/crates/once_cell/versions)\n  * [ Dependencies ](https://crates.io/crates/once_cell/dependencies)\n  * [ Dependents ](https://crates.io/crates/once_cell/reverse_dependencies)\n\n\n## Metadata\n3 months ago \nv1.65.0 \n[ MIT ](https://choosealicense.com/licenses/mit) OR [ Apache-2.0 ](https://choosealicense.com/licenses/apache-2.0)\n33.7 KiB \n## Install\nRun the following Cargo command in your project directory:\ncargo add once_cell\nOr add the following line to your Cargo.toml:\nonce_cell = \"1.21.3\"\n## Documentation\n[ docs.rs/once_cell ](https://docs.rs/once_cell)\n## Repository\n[ github.com/matklad/once_cell ](https://github.com/matklad/once_cell)\n## Owners\n## Categories\n  * [Memory management](https://crates.io/categories/memory-management)\n  * [Rust patterns](https://crates.io/categories/rust-patterns)\n\n\n[ Report crate ](https://crates.io/support?crate=once_cell&inquire=crate-violation)\n### Stats Overview\n484,288,399 Downloads all time\n66 Versions published\n#### Downloads over the last 90 days\nDisplay as \nStacked \n  * Stacked \n  * Unstacked \n\n\nLoading\u2026\n",
              "markdown_with_citations": "#  once_cell v1.21.3\nSingle assignment cells and lazy values. \n  *  #lazy \u27e81\u27e9\n  *  #static \u27e82\u27e9\n\n\n  *  Readme \u27e83\u27e9\n  *  66 Versions \u27e84\u27e9\n  *  Dependencies \u27e85\u27e9\n  *  Dependents \u27e86\u27e9\n\n\n## Metadata\n3 months ago \nv1.65.0 \n MIT \u27e87\u27e9 OR  Apache-2.0 \u27e88\u27e9\n33.7 KiB \n## Install\nRun the following Cargo command in your project directory:\ncargo add once_cell\nOr add the following line to your Cargo.toml:\nonce_cell = \"1.21.3\"\n## Documentation\n docs.rs/once_cell \u27e89\u27e9\n## Repository\n github.com/matklad/once_cell \u27e810\u27e9\n## Owners\n## Categories\n  * Memory management\u27e811\u27e9\n  * Rust patterns\u27e812\u27e9\n\n\n Report crate \u27e813\u27e9\n### Stats Overview\n484,288,399 Downloads all time\n66 Versions published\n#### Downloads over the last 90 days\nDisplay as \nStacked \n  * Stacked \n  * Unstacked \n\n\nLoading\u2026\n",
              "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://crates.io/keywords/lazy:  #lazy \n\u27e82\u27e9 https://crates.io/keywords/static:  #static \n\u27e83\u27e9 https://crates.io/crates/once_cell:  Readme \n\u27e84\u27e9 https://crates.io/crates/once_cell/versions:  66 Versions \n\u27e85\u27e9 https://crates.io/crates/once_cell/dependencies:  Dependencies \n\u27e86\u27e9 https://crates.io/crates/once_cell/reverse_dependencies:  Dependents \n\u27e87\u27e9 https://choosealicense.com/licenses/mit:  MIT \n\u27e88\u27e9 https://choosealicense.com/licenses/apache-2.0:  Apache-2.0 \n\u27e89\u27e9 https://docs.rs/once_cell:  docs.rs/once_cell \n\u27e810\u27e9 https://github.com/matklad/once_cell:  github.com/matklad/once_cell \n\u27e811\u27e9 https://crates.io/categories/memory-management: Memory management\n\u27e812\u27e9 https://crates.io/categories/rust-patterns: Rust patterns\n\u27e813\u27e9 https://crates.io/support?crate=once_cell&inquire=crate-violation:  Report crate \n",
              "fit_markdown": "",
              "fit_html": ""
            },
            "structured_data": {},
            "quality_score": 3.0,
            "extraction_method": "crawl4ai",
            "error": null,
            "metadata": {
              "doc_type": "docs",
              "content_length": 1310,
              "has_structured_data": false,
              "crawl_success": true
            },
            "timestamp": "114431.7173492"
          },
          "docs_rs": {
            "url": "https://docs.rs/once_cell",
            "title": "Crate once_cellCopy item path",
            "content": {
              "raw_markdown": "[](https://docs.rs/once_cell/latest/once_cell/all.html \"show sidebar\")\n# Crate once_cellCopy item path\n[Settings](https://docs.rs/once_cell/latest/settings.html)\n[Help](https://docs.rs/once_cell/latest/help.html)\nSummary[Source](https://docs.rs/once_cell/latest/src/once_cell/lib.rs.html#1-1412)\nExpand description\n## [\u00a7](https://docs.rs/once_cell/latest/once_cell/#overview)Overview\n`once_cell` provides two new cell-like types, [`unsync::OnceCell`](https://docs.rs/once_cell/latest/once_cell/unsync/struct.OnceCell.html) and [`sync::OnceCell`](https://docs.rs/once_cell/latest/once_cell/sync/struct.OnceCell.html). A `OnceCell` might store arbitrary non-`Copy` types, can be assigned to at most once and provides direct access to the stored contents. The core API looks _roughly_ like this (and there\u2019s much more inside, read on!):\n[\u24d8](https://docs.rs/once_cell/latest/once_cell/ \"This example is not tested\")```\nimpl<T> OnceCell<T> {\n  const fn new() -> OnceCell<T> { ... }\n  fn set(&self, value: T) -> Result<(), T> { ... }\n  fn get(&self) -> Option<&T> { ... }\n}\n```\n\nNote that, like with [`RefCell`](https://doc.rust-lang.org/std/cell/struct.RefCell.html) and [`Mutex`](https://doc.rust-lang.org/std/sync/struct.Mutex.html), the `set` method requires only a shared reference. Because of the single assignment restriction `get` can return a `&T` instead of `Ref<T>` or `MutexGuard<T>`.\nThe `sync` flavor is thread-safe (that is, implements the [`Sync`](https://doc.rust-lang.org/std/marker/trait.Sync.html) trait), while the `unsync` one is not.\n## [\u00a7](https://docs.rs/once_cell/latest/once_cell/#recipes)Recipes\n`OnceCell` might be useful for a variety of patterns.\n### [\u00a7](https://docs.rs/once_cell/latest/once_cell/#safe-initialization-of-global-data)Safe Initialization of Global Data\n```\nuse std::{env, io};\nuse once_cell::sync::OnceCell;\n#[derive(Debug)]\npub struct Logger {\n  // ...\n}\nstatic INSTANCE: OnceCell<Logger> = OnceCell::new();\nimpl Logger {\n  pub fn global() -> &'static Logger {\n    INSTANCE.get().expect(\"logger is not initialized\")\n  }\n  fn from_cli(args: env::Args) -> Result<Logger, std::io::Error> {\n    // ...\n  }\n}\nfn main() {\n  let logger = Logger::from_cli(env::args()).unwrap();\n  INSTANCE.set(logger).unwrap();\n  // use `Logger::global()` from now on\n}\n```\n\n### [\u00a7](https://docs.rs/once_cell/latest/once_cell/#lazy-initialized-global-data)Lazy Initialized Global Data\nThis is essentially the `lazy_static!` macro, but without a macro.\n```\nuse std::{sync::Mutex, collections::HashMap};\nuse once_cell::sync::OnceCell;\nfn global_data() -> &'static Mutex<HashMap<i32, String>> {\n  static INSTANCE: OnceCell<Mutex<HashMap<i32, String>>> = OnceCell::new();\n  INSTANCE.get_or_init(|| {\n    let mut m = HashMap::new();\n    m.insert(13, \"Spica\".to_string());\n    m.insert(74, \"Hoyten\".to_string());\n    Mutex::new(m)\n  })\n}\n```\n\nThere are also the [`sync::Lazy`](https://docs.rs/once_cell/latest/once_cell/sync/struct.Lazy.html) and [`unsync::Lazy`](https://docs.rs/once_cell/latest/once_cell/unsync/struct.Lazy.html) convenience types to streamline this pattern:\n```\nuse std::{sync::Mutex, collections::HashMap};\nuse once_cell::sync::Lazy;\nstatic GLOBAL_DATA: Lazy<Mutex<HashMap<i32, String>>> = Lazy::new(|| {\n  let mut m = HashMap::new();\n  m.insert(13, \"Spica\".to_string());\n  m.insert(74, \"Hoyten\".to_string());\n  Mutex::new(m)\n});\nfn main() {\n  println!(\"{:?}\", GLOBAL_DATA.lock().unwrap());\n}\n```\n\nNote that the variable that holds `Lazy` is declared as `static`, _not_ `const`. This is important: using `const` instead compiles, but works wrong.\n### [\u00a7](https://docs.rs/once_cell/latest/once_cell/#general-purpose-lazy-evaluation)General purpose lazy evaluation\nUnlike `lazy_static!`, `Lazy` works with local variables.\n```\nuse once_cell::unsync::Lazy;\nfn main() {\n  let ctx = vec![1, 2, 3];\n  let thunk = Lazy::new(|| {\n    ctx.iter().sum::<i32>()\n  });\n  assert_eq!(*thunk, 6);\n}\n```\n\nIf you need a lazy field in a struct, you probably should use `OnceCell` directly, because that will allow you to access `self` during initialization.\n```\nuse std::{fs, path::PathBuf};\nuse once_cell::unsync::OnceCell;\nstruct Ctx {\n  config_path: PathBuf,\n  config: OnceCell<String>,\n}\nimpl Ctx {\n  pub fn get_config(&self) -> Result<&str, std::io::Error> {\n    let cfg = self.config.get_or_try_init(|| {\n      fs::read_to_string(&self.config_path)\n    })?;\n    Ok(cfg.as_str())\n  }\n}\n```\n\n### [\u00a7](https://docs.rs/once_cell/latest/once_cell/#lazily-compiled-regex)Lazily Compiled Regex\nThis is a `regex!` macro which takes a string literal and returns an _expression_ that evaluates to a `&'static Regex`:\n```\nmacro_rules! regex {\n  ($re:literal $(,)?) => {{\n    static RE: once_cell::sync::OnceCell<regex::Regex> = once_cell::sync::OnceCell::new();\n    RE.get_or_init(|| regex::Regex::new($re).unwrap())\n  }};\n}\n```\n\nThis macro can be useful to avoid the \u201ccompile regex on every loop iteration\u201d problem.\n### [\u00a7](https://docs.rs/once_cell/latest/once_cell/#runtime-include_bytes)Runtime `include_bytes!`\nThe `include_bytes` macro is useful to include test resources, but it slows down test compilation a lot. An alternative is to load the resources at runtime:\n```\nuse std::path::Path;\nuse once_cell::sync::OnceCell;\npub struct TestResource {\n  path: &'static str,\n  cell: OnceCell<Vec<u8>>,\n}\nimpl TestResource {\n  pub const fn new(path: &'static str) -> TestResource {\n    TestResource { path, cell: OnceCell::new() }\n  }\n  pub fn bytes(&self) -> &[u8] {\n    self.cell.get_or_init(|| {\n      let dir = std::env::var(\"CARGO_MANIFEST_DIR\").unwrap();\n      let path = Path::new(dir.as_str()).join(self.path);\n      std::fs::read(&path).unwrap_or_else(|_err| {\n        panic!(\"failed to load test resource: {}\", path.display())\n      })\n    }).as_slice()\n  }\n}\nstatic TEST_IMAGE: TestResource = TestResource::new(\"test_data/lena.png\");\n#[test]\nfn test_sobel_filter() {\n  let rgb: &[u8] = TEST_IMAGE.bytes();\n  // ...\n}\n```\n\n### [\u00a7](https://docs.rs/once_cell/latest/once_cell/#lateinit)`lateinit`\n`LateInit` type for delayed initialization. It is reminiscent of Kotlin\u2019s `lateinit` keyword and allows construction of cyclic data structures:\n```\nuse once_cell::sync::OnceCell;\npub struct LateInit<T> { cell: OnceCell<T> }\nimpl<T> LateInit<T> {\n  pub fn init(&self, value: T) {\n    assert!(self.cell.set(value).is_ok())\n  }\n}\nimpl<T> Default for LateInit<T> {\n  fn default() -> Self { LateInit { cell: OnceCell::default() } }\n}\nimpl<T> std::ops::Deref for LateInit<T> {\n  type Target = T;\n  fn deref(&self) -> &T {\n    self.cell.get().unwrap()\n  }\n}\n#[derive(Default)]\nstruct A<'a> {\n  b: LateInit<&'a B<'a>>,\n}\n#[derive(Default)]\nstruct B<'a> {\n  a: LateInit<&'a A<'a>>\n}\n\nfn build_cycle() {\n  let a = A::default();\n  let b = B::default();\n  a.b.init(&b);\n  b.a.init(&a);\n  let _a = &a.b.a.b.a;\n}\n```\n\n## [\u00a7](https://docs.rs/once_cell/latest/once_cell/#comparison-with-std)Comparison with std\n`!Sync` types| Access Mode| Drawbacks  \n---|---|---  \n`Cell<T>`| `T`| requires `T: Copy` for `get`  \n`RefCell<T>`| `RefMut<T>` / `Ref<T>`| may panic at runtime  \n`unsync::OnceCell<T>`| `&T`| assignable only once  \n`Sync` types| Access Mode| Drawbacks  \n---|---|---  \n`AtomicT`| `T`| works only with certain `Copy` types  \n`Mutex<T>`| `MutexGuard<T>`| may deadlock at runtime, may block the thread  \n`sync::OnceCell<T>`| `&T`| assignable only once, may block the thread  \nTechnically, calling `get_or_init` will also cause a panic or a deadlock if it recursively calls itself. However, because the assignment can happen only once, such cases should be more rare than equivalents with `RefCell` and `Mutex`.\n## [\u00a7](https://docs.rs/once_cell/latest/once_cell/#minimum-supported-rustc-version)Minimum Supported `rustc` Version\nIf only the `std`, `alloc`, or `race` features are enabled, MSRV will be updated conservatively, supporting at least latest 8 versions of the compiler. When using other features, like `parking_lot`, MSRV might be updated more frequently, up to the latest stable. In both cases, increasing MSRV is _not_ considered a semver-breaking change and requires only a minor version bump.\n## [\u00a7](https://docs.rs/once_cell/latest/once_cell/#implementation-details)Implementation details\nThe implementation is based on the [`lazy_static`](https://github.com/rust-lang-nursery/lazy-static.rs/) and [`lazy_cell`](https://github.com/indiv0/lazycell/) crates and [`std::sync::Once`](https://doc.rust-lang.org/std/sync/struct.Once.html). In some sense, `once_cell` just streamlines and unifies those APIs.\nTo implement a sync flavor of `OnceCell`, this crates uses either a custom re-implementation of `std::sync::Once` or `parking_lot::Mutex`. This is controlled by the `parking_lot` feature (disabled by default). Performance is the same for both cases, but the `parking_lot` based `OnceCell<T>` is smaller by up to 16 bytes.\nThis crate uses `unsafe`.\n## [\u00a7](https://docs.rs/once_cell/latest/once_cell/#faq)F.A.Q.\n**Should I use the sync or unsync flavor?**\nBecause Rust compiler checks thread safety for you, it\u2019s impossible to accidentally use `unsync` where `sync` is required. So, use `unsync` in single-threaded code and `sync` in multi-threaded. It\u2019s easy to switch between the two if code becomes multi-threaded later.\nAt the moment, `unsync` has an additional benefit that reentrant initialization causes a panic, which might be easier to debug than a deadlock.\n**Does this crate support async?**\nNo, but you can use [`async_once_cell`](https://crates.io/crates/async_once_cell) instead.\n**Does this crate support`no_std`?**\nYes, but with caveats. `OnceCell` is a synchronization primitive which _semantically_ relies on blocking. `OnceCell` guarantees that at most one `f` will be called to compute the value. If two threads of execution call `get_or_init` concurrently, one of them has to wait.\nWaiting fundamentally requires OS support. Execution environment needs to understand who waits on whom to prevent deadlocks due to priority inversion. You _could_ make code to compile by blindly using pure spinlocks, but the runtime behavior would be subtly wrong.\nGiven these constraints, `once_cell` provides the following options:\n  * The `race` module provides similar, but distinct synchronization primitive which is compatible with `no_std`. With `race`, the `f` function can be called multiple times by different threads, but only one thread will win to install the value.\n  * `critical-section` feature (with a `-`, not `_`) uses `critical_section` to implement blocking.\n\n\n**Can I bring my own mutex?**\nThere is [generic_once_cell](https://crates.io/crates/generic_once_cell) to allow just that.\n**Should I use`std::cell::OnceCell` , `once_cell`, or `lazy_static`?**\nIf you can use `std` version (your MSRV is at least 1.70, and you don\u2019t need extra features `once_cell` provides), use `std`. Otherwise, use `once_cell`. Don\u2019t use `lazy_static`.\n## [\u00a7](https://docs.rs/once_cell/latest/once_cell/#related-crates)Related crates\n  * Most of this crate\u2019s functionality is available in `std` starting with Rust 1.70. See `std::cell::OnceCell` and `std::sync::OnceLock`.\n  * [double-checked-cell](https://github.com/niklasf/double-checked-cell)\n  * [lazy-init](https://crates.io/crates/lazy-init)\n  * [lazycell](https://crates.io/crates/lazycell)\n  * [mitochondria](https://crates.io/crates/mitochondria)\n  * [lazy_static](https://crates.io/crates/lazy_static)\n  * [async_once_cell](https://crates.io/crates/async_once_cell)\n  * [generic_once_cell](https://crates.io/crates/generic_once_cell) (bring your own mutex)\n\n\n## Modules[\u00a7](https://docs.rs/once_cell/latest/once_cell/#modules)\n\n[race](https://docs.rs/once_cell/latest/once_cell/race/index.html \"mod once_cell::race\")\n    Thread-safe, non-blocking, \u201cfirst one wins\u201d flavor of `OnceCell`.\n\n[sync](https://docs.rs/once_cell/latest/once_cell/sync/index.html \"mod once_cell::sync\")\n    Thread-safe, blocking version of `OnceCell`.\n\n[unsync](https://docs.rs/once_cell/latest/once_cell/unsync/index.html \"mod once_cell::unsync\")\n    Single-threaded version of `OnceCell`.\n",
              "markdown_with_citations": "[](https://docs.rs/once_cell/latest/once_cell/all.html \"show sidebar\")\n# Crate once_cellCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\n## \u00a7\u27e84\u27e9Overview\n`once_cell` provides two new cell-like types, `unsync::OnceCell`\u27e85\u27e9 and `sync::OnceCell`\u27e86\u27e9. A `OnceCell` might store arbitrary non-`Copy` types, can be assigned to at most once and provides direct access to the stored contents. The core API looks _roughly_ like this (and there\u2019s much more inside, read on!):\n\u24d8\u27e87\u27e9```\nimpl<T> OnceCell<T> {\n  const fn new() -> OnceCell<T> { ... }\n  fn set(&self, value: T) -> Result<(), T> { ... }\n  fn get(&self) -> Option<&T> { ... }\n}\n```\n\nNote that, like with `RefCell`\u27e88\u27e9 and `Mutex`\u27e89\u27e9, the `set` method requires only a shared reference. Because of the single assignment restriction `get` can return a `&T` instead of `Ref<T>` or `MutexGuard<T>`.\nThe `sync` flavor is thread-safe (that is, implements the `Sync`\u27e810\u27e9 trait), while the `unsync` one is not.\n## \u00a7\u27e811\u27e9Recipes\n`OnceCell` might be useful for a variety of patterns.\n### \u00a7\u27e812\u27e9Safe Initialization of Global Data\n```\nuse std::{env, io};\nuse once_cell::sync::OnceCell;\n#[derive(Debug)]\npub struct Logger {\n  // ...\n}\nstatic INSTANCE: OnceCell<Logger> = OnceCell::new();\nimpl Logger {\n  pub fn global() -> &'static Logger {\n    INSTANCE.get().expect(\"logger is not initialized\")\n  }\n  fn from_cli(args: env::Args) -> Result<Logger, std::io::Error> {\n    // ...\n  }\n}\nfn main() {\n  let logger = Logger::from_cli(env::args()).unwrap();\n  INSTANCE.set(logger).unwrap();\n  // use `Logger::global()` from now on\n}\n```\n\n### \u00a7\u27e813\u27e9Lazy Initialized Global Data\nThis is essentially the `lazy_static!` macro, but without a macro.\n```\nuse std::{sync::Mutex, collections::HashMap};\nuse once_cell::sync::OnceCell;\nfn global_data() -> &'static Mutex<HashMap<i32, String>> {\n  static INSTANCE: OnceCell<Mutex<HashMap<i32, String>>> = OnceCell::new();\n  INSTANCE.get_or_init(|| {\n    let mut m = HashMap::new();\n    m.insert(13, \"Spica\".to_string());\n    m.insert(74, \"Hoyten\".to_string());\n    Mutex::new(m)\n  })\n}\n```\n\nThere are also the `sync::Lazy`\u27e814\u27e9 and `unsync::Lazy`\u27e815\u27e9 convenience types to streamline this pattern:\n```\nuse std::{sync::Mutex, collections::HashMap};\nuse once_cell::sync::Lazy;\nstatic GLOBAL_DATA: Lazy<Mutex<HashMap<i32, String>>> = Lazy::new(|| {\n  let mut m = HashMap::new();\n  m.insert(13, \"Spica\".to_string());\n  m.insert(74, \"Hoyten\".to_string());\n  Mutex::new(m)\n});\nfn main() {\n  println!(\"{:?}\", GLOBAL_DATA.lock().unwrap());\n}\n```\n\nNote that the variable that holds `Lazy` is declared as `static`, _not_ `const`. This is important: using `const` instead compiles, but works wrong.\n### \u00a7\u27e816\u27e9General purpose lazy evaluation\nUnlike `lazy_static!`, `Lazy` works with local variables.\n```\nuse once_cell::unsync::Lazy;\nfn main() {\n  let ctx = vec![1, 2, 3];\n  let thunk = Lazy::new(|| {\n    ctx.iter().sum::<i32>()\n  });\n  assert_eq!(*thunk, 6);\n}\n```\n\nIf you need a lazy field in a struct, you probably should use `OnceCell` directly, because that will allow you to access `self` during initialization.\n```\nuse std::{fs, path::PathBuf};\nuse once_cell::unsync::OnceCell;\nstruct Ctx {\n  config_path: PathBuf,\n  config: OnceCell<String>,\n}\nimpl Ctx {\n  pub fn get_config(&self) -> Result<&str, std::io::Error> {\n    let cfg = self.config.get_or_try_init(|| {\n      fs::read_to_string(&self.config_path)\n    })?;\n    Ok(cfg.as_str())\n  }\n}\n```\n\n### \u00a7\u27e817\u27e9Lazily Compiled Regex\nThis is a `regex!` macro which takes a string literal and returns an _expression_ that evaluates to a `&'static Regex`:\n```\nmacro_rules! regex {\n  ($re:literal $(,)?) => {{\n    static RE: once_cell::sync::OnceCell<regex::Regex> = once_cell::sync::OnceCell::new();\n    RE.get_or_init(|| regex::Regex::new($re).unwrap())\n  }};\n}\n```\n\nThis macro can be useful to avoid the \u201ccompile regex on every loop iteration\u201d problem.\n### \u00a7\u27e818\u27e9Runtime `include_bytes!`\nThe `include_bytes` macro is useful to include test resources, but it slows down test compilation a lot. An alternative is to load the resources at runtime:\n```\nuse std::path::Path;\nuse once_cell::sync::OnceCell;\npub struct TestResource {\n  path: &'static str,\n  cell: OnceCell<Vec<u8>>,\n}\nimpl TestResource {\n  pub const fn new(path: &'static str) -> TestResource {\n    TestResource { path, cell: OnceCell::new() }\n  }\n  pub fn bytes(&self) -> &[u8] {\n    self.cell.get_or_init(|| {\n      let dir = std::env::var(\"CARGO_MANIFEST_DIR\").unwrap();\n      let path = Path::new(dir.as_str()).join(self.path);\n      std::fs::read(&path).unwrap_or_else(|_err| {\n        panic!(\"failed to load test resource: {}\", path.display())\n      })\n    }).as_slice()\n  }\n}\nstatic TEST_IMAGE: TestResource = TestResource::new(\"test_data/lena.png\");\n#[test]\nfn test_sobel_filter() {\n  let rgb: &[u8] = TEST_IMAGE.bytes();\n  // ...\n}\n```\n\n### \u00a7\u27e819\u27e9`lateinit`\n`LateInit` type for delayed initialization. It is reminiscent of Kotlin\u2019s `lateinit` keyword and allows construction of cyclic data structures:\n```\nuse once_cell::sync::OnceCell;\npub struct LateInit<T> { cell: OnceCell<T> }\nimpl<T> LateInit<T> {\n  pub fn init(&self, value: T) {\n    assert!(self.cell.set(value).is_ok())\n  }\n}\nimpl<T> Default for LateInit<T> {\n  fn default() -> Self { LateInit { cell: OnceCell::default() } }\n}\nimpl<T> std::ops::Deref for LateInit<T> {\n  type Target = T;\n  fn deref(&self) -> &T {\n    self.cell.get().unwrap()\n  }\n}\n#[derive(Default)]\nstruct A<'a> {\n  b: LateInit<&'a B<'a>>,\n}\n#[derive(Default)]\nstruct B<'a> {\n  a: LateInit<&'a A<'a>>\n}\n\nfn build_cycle() {\n  let a = A::default();\n  let b = B::default();\n  a.b.init(&b);\n  b.a.init(&a);\n  let _a = &a.b.a.b.a;\n}\n```\n\n## \u00a7\u27e820\u27e9Comparison with std\n`!Sync` types| Access Mode| Drawbacks  \n---|---|---  \n`Cell<T>`| `T`| requires `T: Copy` for `get`  \n`RefCell<T>`| `RefMut<T>` / `Ref<T>`| may panic at runtime  \n`unsync::OnceCell<T>`| `&T`| assignable only once  \n`Sync` types| Access Mode| Drawbacks  \n---|---|---  \n`AtomicT`| `T`| works only with certain `Copy` types  \n`Mutex<T>`| `MutexGuard<T>`| may deadlock at runtime, may block the thread  \n`sync::OnceCell<T>`| `&T`| assignable only once, may block the thread  \nTechnically, calling `get_or_init` will also cause a panic or a deadlock if it recursively calls itself. However, because the assignment can happen only once, such cases should be more rare than equivalents with `RefCell` and `Mutex`.\n## \u00a7\u27e821\u27e9Minimum Supported `rustc` Version\nIf only the `std`, `alloc`, or `race` features are enabled, MSRV will be updated conservatively, supporting at least latest 8 versions of the compiler. When using other features, like `parking_lot`, MSRV might be updated more frequently, up to the latest stable. In both cases, increasing MSRV is _not_ considered a semver-breaking change and requires only a minor version bump.\n## \u00a7\u27e822\u27e9Implementation details\nThe implementation is based on the `lazy_static`\u27e823\u27e9 and `lazy_cell`\u27e824\u27e9 crates and `std::sync::Once`\u27e825\u27e9. In some sense, `once_cell` just streamlines and unifies those APIs.\nTo implement a sync flavor of `OnceCell`, this crates uses either a custom re-implementation of `std::sync::Once` or `parking_lot::Mutex`. This is controlled by the `parking_lot` feature (disabled by default). Performance is the same for both cases, but the `parking_lot` based `OnceCell<T>` is smaller by up to 16 bytes.\nThis crate uses `unsafe`.\n## \u00a7\u27e826\u27e9F.A.Q.\n**Should I use the sync or unsync flavor?**\nBecause Rust compiler checks thread safety for you, it\u2019s impossible to accidentally use `unsync` where `sync` is required. So, use `unsync` in single-threaded code and `sync` in multi-threaded. It\u2019s easy to switch between the two if code becomes multi-threaded later.\nAt the moment, `unsync` has an additional benefit that reentrant initialization causes a panic, which might be easier to debug than a deadlock.\n**Does this crate support async?**\nNo, but you can use `async_once_cell`\u27e827\u27e9 instead.\n**Does this crate support`no_std`?**\nYes, but with caveats. `OnceCell` is a synchronization primitive which _semantically_ relies on blocking. `OnceCell` guarantees that at most one `f` will be called to compute the value. If two threads of execution call `get_or_init` concurrently, one of them has to wait.\nWaiting fundamentally requires OS support. Execution environment needs to understand who waits on whom to prevent deadlocks due to priority inversion. You _could_ make code to compile by blindly using pure spinlocks, but the runtime behavior would be subtly wrong.\nGiven these constraints, `once_cell` provides the following options:\n  * The `race` module provides similar, but distinct synchronization primitive which is compatible with `no_std`. With `race`, the `f` function can be called multiple times by different threads, but only one thread will win to install the value.\n  * `critical-section` feature (with a `-`, not `_`) uses `critical_section` to implement blocking.\n\n\n**Can I bring my own mutex?**\nThere is generic_once_cell\u27e828\u27e9 to allow just that.\n**Should I use`std::cell::OnceCell` , `once_cell`, or `lazy_static`?**\nIf you can use `std` version (your MSRV is at least 1.70, and you don\u2019t need extra features `once_cell` provides), use `std`. Otherwise, use `once_cell`. Don\u2019t use `lazy_static`.\n## \u00a7\u27e829\u27e9Related crates\n  * Most of this crate\u2019s functionality is available in `std` starting with Rust 1.70. See `std::cell::OnceCell` and `std::sync::OnceLock`.\n  * double-checked-cell\u27e830\u27e9\n  * lazy-init\u27e831\u27e9\n  * lazycell\u27e832\u27e9\n  * mitochondria\u27e833\u27e9\n  * lazy_static\u27e834\u27e9\n  * async_once_cell\u27e827\u27e9\n  * generic_once_cell\u27e828\u27e9 (bring your own mutex)\n\n\n## Modules\u00a7\u27e835\u27e9\n\nrace\u27e836\u27e9\n    Thread-safe, non-blocking, \u201cfirst one wins\u201d flavor of `OnceCell`.\n\nsync\u27e837\u27e9\n    Thread-safe, blocking version of `OnceCell`.\n\nunsync\u27e838\u27e9\n    Single-threaded version of `OnceCell`.\n",
              "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/once_cell/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/once_cell/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/once_cell/latest/src/once_cell/lib.rs.html#1-1412: Source\n\u27e84\u27e9 https://docs.rs/once_cell/latest/once_cell/#overview: \u00a7\n\u27e85\u27e9 https://docs.rs/once_cell/latest/once_cell/unsync/struct.OnceCell.html: `unsync::OnceCell`\n\u27e86\u27e9 https://docs.rs/once_cell/latest/once_cell/sync/struct.OnceCell.html: `sync::OnceCell`\n\u27e87\u27e9 https://docs.rs/once_cell/latest/once_cell/: This example is not tested - \u24d8\n\u27e88\u27e9 https://doc.rust-lang.org/std/cell/struct.RefCell.html: `RefCell`\n\u27e89\u27e9 https://doc.rust-lang.org/std/sync/struct.Mutex.html: `Mutex`\n\u27e810\u27e9 https://doc.rust-lang.org/std/marker/trait.Sync.html: `Sync`\n\u27e811\u27e9 https://docs.rs/once_cell/latest/once_cell/#recipes: \u00a7\n\u27e812\u27e9 https://docs.rs/once_cell/latest/once_cell/#safe-initialization-of-global-data: \u00a7\n\u27e813\u27e9 https://docs.rs/once_cell/latest/once_cell/#lazy-initialized-global-data: \u00a7\n\u27e814\u27e9 https://docs.rs/once_cell/latest/once_cell/sync/struct.Lazy.html: `sync::Lazy`\n\u27e815\u27e9 https://docs.rs/once_cell/latest/once_cell/unsync/struct.Lazy.html: `unsync::Lazy`\n\u27e816\u27e9 https://docs.rs/once_cell/latest/once_cell/#general-purpose-lazy-evaluation: \u00a7\n\u27e817\u27e9 https://docs.rs/once_cell/latest/once_cell/#lazily-compiled-regex: \u00a7\n\u27e818\u27e9 https://docs.rs/once_cell/latest/once_cell/#runtime-include_bytes: \u00a7\n\u27e819\u27e9 https://docs.rs/once_cell/latest/once_cell/#lateinit: \u00a7\n\u27e820\u27e9 https://docs.rs/once_cell/latest/once_cell/#comparison-with-std: \u00a7\n\u27e821\u27e9 https://docs.rs/once_cell/latest/once_cell/#minimum-supported-rustc-version: \u00a7\n\u27e822\u27e9 https://docs.rs/once_cell/latest/once_cell/#implementation-details: \u00a7\n\u27e823\u27e9 https://github.com/rust-lang-nursery/lazy-static.rs/: `lazy_static`\n\u27e824\u27e9 https://github.com/indiv0/lazycell/: `lazy_cell`\n\u27e825\u27e9 https://doc.rust-lang.org/std/sync/struct.Once.html: `std::sync::Once`\n\u27e826\u27e9 https://docs.rs/once_cell/latest/once_cell/#faq: \u00a7\n\u27e827\u27e9 https://crates.io/crates/async_once_cell: `async_once_cell`\n\u27e828\u27e9 https://crates.io/crates/generic_once_cell: generic_once_cell\n\u27e829\u27e9 https://docs.rs/once_cell/latest/once_cell/#related-crates: \u00a7\n\u27e830\u27e9 https://github.com/niklasf/double-checked-cell: double-checked-cell\n\u27e831\u27e9 https://crates.io/crates/lazy-init: lazy-init\n\u27e832\u27e9 https://crates.io/crates/lazycell: lazycell\n\u27e833\u27e9 https://crates.io/crates/mitochondria: mitochondria\n\u27e834\u27e9 https://crates.io/crates/lazy_static: lazy_static\n\u27e835\u27e9 https://docs.rs/once_cell/latest/once_cell/#modules: \u00a7\n\u27e836\u27e9 https://docs.rs/once_cell/latest/once_cell/race/index.html: mod once_cell::race - race\n\u27e837\u27e9 https://docs.rs/once_cell/latest/once_cell/sync/index.html: mod once_cell::sync - sync\n\u27e838\u27e9 https://docs.rs/once_cell/latest/once_cell/unsync/index.html: mod once_cell::unsync - unsync\n",
              "fit_markdown": "",
              "fit_html": ""
            },
            "structured_data": {},
            "quality_score": 4.0,
            "extraction_method": "crawl4ai",
            "error": null,
            "metadata": {
              "doc_type": "docs",
              "content_length": 12049,
              "has_structured_data": false,
              "crawl_success": true
            },
            "timestamp": "114432.3973035"
          },
          "lib_rs": {
            "url": "https://lib.rs/crates/once_cell",
            "title": "Untitled",
            "content": {
              "raw_markdown": "###  [58 releases](https://lib.rs/crates/once_cell/versions) (37 stable)\n1.21.3 |  Mar 28, 2025   \n---|---  \n1.20.3 |  Feb 6, 2025   \n1.20.2 |  Oct 5, 2024   \n1.19.0 |  Dec 7, 2023   \n0.1.6 |  Sep 21, 2018   \n#**5** in [Rust patterns](https://lib.rs/rust-patterns \"Shared solutions for particular situations specific to programming in Rust.\")\nDownload history 5571180/week @ 2025-03-09 5896116/week @ 2025-03-16 5918431/week @ 2025-03-23 5665325/week @ 2025-03-30 5978660/week @ 2025-04-06 5515970/week @ 2025-04-13 5251000/week @ 2025-04-20 5327983/week @ 2025-04-27 5212206/week @ 2025-05-04 5531262/week @ 2025-05-11 5732338/week @ 2025-05-18 4751241/week @ 2025-05-25 4995065/week @ 2025-06-01 5632209/week @ 2025-06-08 6360344/week @ 2025-06-15 5617764/week @ 2025-06-22\n**22,935,563** downloads per month Used in [**74,279** crates (6,091 directly)](https://lib.rs/crates/once_cell/rev)\n**MIT/Apache**\n92KB  1K  SLoC\n![once_cell](https://img.gs/czjpqfbdkz/800/https://raw.githubusercontent.com/matklad/once_cell/29e3d93cf0367fc6c295785b282b8101127a3e16/design/logo.png)\n[![Build Status](https://img.gs/czjpqfbdkz/full/https://github.com/matklad/once_cell/actions/workflows/ci.yaml/badge.svg)](https://github.com/matklad/once_cell/actions) [![Crates.io](https://img.shields.io/crates/v/once_cell.svg)](https://crates.io/crates/once_cell) [![API reference](https://img.gs/czjpqfbdkz/full/https://docs.rs/once_cell/badge.svg)](https://docs.rs/once_cell/)\n# Overview\n``once_cell`` provides two new cell-like types, ```unsync`::``OnceCell`` and ```sync`::``OnceCell``. ``OnceCell`` might store arbitrary non-```Copy``` types, can be assigned to at most once and provide direct access to the stored contents. In a nutshell, API looks _roughly_ like this:\n```\n```impl` ```OnceCell```<`T`>`` ````{`\n  ``fn` `new`````(````)```` ``->` `OnceCell`<`T`>``` ```{` `...` `}``\n  ``fn` `set`````(``&``self`, `value``:` T```)```` ``->` ``Result``<``(``)`, T`>``` ```{` `...` `}``\n  ``fn` `get`````(``&``self````)```` ``->` ``Option``<``&`T`>``` ```{` `...` `}``\n```}```\n`\n```\n\nNote that, like with ``RefCell`` and ``Mutex``, the ``set`` method requires only a shared reference. Because of the single assignment restriction ``get`` can return an ```&`T`` instead of ```Ref`<`T`>```` or ```MutexGuard`<`T`>````.\n``once_cell`` also has a ```Lazy`<`T`>```` type, build on top of ``OnceCell`` which provides the same API as the ``lazy_static!`` macro, but without using any macros:\n```\n``use` `std`::````{``sync`::``Mutex`,` `collections`::``HashMap```}```;`\n`use` `once_cell`::```sync`::``Lazy`;`\n`static` `GLOBAL_DATA``:` `Lazy`<`Mutex`<`HashMap`<``i32`, `String``>``>``>`` `=` `Lazy`::``new`(````|``````|`` ````{`\n  `let` `mut` m `=` `HashMap`::``new`(``)``;`\n  m`.``insert``(``13``,` ``\"`Spica`\"```.``to_string``(``)``)``;`\n  m`.``insert``(``74``,` ``\"`Hoyten`\"```.``to_string``(``)``)``;`\n  `Mutex`::``new`(`m`)`\n```}````)``;`\n``fn` `main`````(````)``````{`\n  `println!``(```\"``{:?}``\"```,` `GLOBAL_DATA``.``lock``(``)``.``unwrap``(``)``)``;`\n```}```\n`\n```\n\nMore patterns and use-cases are in the [docs](https://docs.rs/once_cell/)!\n# Related crates\n  * [double-checked-cell](https://github.com/niklasf/double-checked-cell)\n  * [lazy-init](https://lib.rs/crates/lazy-init)\n  * [lazycell](https://lib.rs/crates/lazycell)\n  * [mitochondria](https://lib.rs/crates/mitochondria)\n  * [lazy_static](https://lib.rs/crates/lazy_static)\n  * [async_once_cell](https://lib.rs/crates/async_once_cell)\n  * [generic_once_cell](https://lib.rs/crates/generic_once_cell) (bring your own mutex)\n\n\nParts of ``once_cell`` API are included into ``std`` [as of Rust 1.70.0](https://github.com/rust-lang/rust/pull/105587).\n#### Dependencies\n~0\u20135MB \n  * [ optional ](https://lib.rs/crates/once_cell/features#feature-critical-section \"critical-section is optional feature\") [critical-section](https://lib.rs/crates/critical-section \"1.1.3\")\n  * [parking_lot?](https://lib.rs/crates/once_cell/features#feature-parking_lot \"optional feature\") [parking_lot_core](https://lib.rs/crates/parking_lot_core \"0.9.10\")\n  * [ optional ](https://lib.rs/crates/once_cell/features#feature-portable-atomic \"portable-atomic is optional feature\") [portable-atomic](https://lib.rs/crates/portable-atomic \"1.8\")\n\n\n  * dev  [regex](https://lib.rs/crates/regex \"1.10.6\")\n\n\n#### [Other features](https://lib.rs/crates/once_cell/features)\n  * [alloc](https://lib.rs/crates/once_cell/features#feature-alloc)\n  * [atomic-polyfill](https://lib.rs/crates/once_cell/features#feature-atomic-polyfill)\n  * [race](https://lib.rs/crates/once_cell/features#feature-race)\n  * [std](https://lib.rs/crates/once_cell/features#feature-std)\n  * [unstable](https://lib.rs/crates/once_cell/features#feature-unstable)\n\n\n  *[SLoC]: Lines of code, excluding comments\n",
              "markdown_with_citations": "###  58 releases\u27e81\u27e9 (37 stable)\n1.21.3 |  Mar 28, 2025   \n---|---  \n1.20.3 |  Feb 6, 2025   \n1.20.2 |  Oct 5, 2024   \n1.19.0 |  Dec 7, 2023   \n0.1.6 |  Sep 21, 2018   \n#**5** in Rust patterns\u27e82\u27e9\nDownload history 5571180/week @ 2025-03-09 5896116/week @ 2025-03-16 5918431/week @ 2025-03-23 5665325/week @ 2025-03-30 5978660/week @ 2025-04-06 5515970/week @ 2025-04-13 5251000/week @ 2025-04-20 5327983/week @ 2025-04-27 5212206/week @ 2025-05-04 5531262/week @ 2025-05-11 5732338/week @ 2025-05-18 4751241/week @ 2025-05-25 4995065/week @ 2025-06-01 5632209/week @ 2025-06-08 6360344/week @ 2025-06-15 5617764/week @ 2025-06-22\n**22,935,563** downloads per month Used in **74,279** crates (6,091 directly)\u27e83\u27e9\n**MIT/Apache**\n92KB  1K  SLoC\n![once_cell\u27e84\u27e9]\n![Build Status\u27e85\u27e9](https://github.com/matklad/once_cell/actions) ![Crates.io\u27e86\u27e9](https://crates.io/crates/once_cell) ![API reference\u27e87\u27e9](https://docs.rs/once_cell/)\n# Overview\n``once_cell`` provides two new cell-like types, ```unsync`::``OnceCell`` and ```sync`::``OnceCell``. ``OnceCell`` might store arbitrary non-```Copy``` types, can be assigned to at most once and provide direct access to the stored contents. In a nutshell, API looks _roughly_ like this:\n```\n```impl` ```OnceCell```<`T`>`` ````{`\n  ``fn` `new`````(````)```` ``->` `OnceCell`<`T`>``` ```{` `...` `}``\n  ``fn` `set`````(``&``self`, `value``:` T```)```` ``->` ``Result``<``(``)`, T`>``` ```{` `...` `}``\n  ``fn` `get`````(``&``self````)```` ``->` ``Option``<``&`T`>``` ```{` `...` `}``\n```}```\n`\n```\n\nNote that, like with ``RefCell`` and ``Mutex``, the ``set`` method requires only a shared reference. Because of the single assignment restriction ``get`` can return an ```&`T`` instead of ```Ref`<`T`>```` or ```MutexGuard`<`T`>````.\n``once_cell`` also has a ```Lazy`<`T`>```` type, build on top of ``OnceCell`` which provides the same API as the ``lazy_static!`` macro, but without using any macros:\n```\n``use` `std`::````{``sync`::``Mutex`,` `collections`::``HashMap```}```;`\n`use` `once_cell`::```sync`::``Lazy`;`\n`static` `GLOBAL_DATA``:` `Lazy`<`Mutex`<`HashMap`<``i32`, `String``>``>``>`` `=` `Lazy`::``new`(````|``````|`` ````{`\n  `let` `mut` m `=` `HashMap`::``new`(``)``;`\n  m`.``insert``(``13``,` ``\"`Spica`\"```.``to_string``(``)``)``;`\n  m`.``insert``(``74``,` ``\"`Hoyten`\"```.``to_string``(``)``)``;`\n  `Mutex`::``new`(`m`)`\n```}````)``;`\n``fn` `main`````(````)``````{`\n  `println!``(```\"``{:?}``\"```,` `GLOBAL_DATA``.``lock``(``)``.``unwrap``(``)``)``;`\n```}```\n`\n```\n\nMore patterns and use-cases are in the docs\u27e88\u27e9!\n# Related crates\n  * double-checked-cell\u27e89\u27e9\n  * lazy-init\u27e810\u27e9\n  * lazycell\u27e811\u27e9\n  * mitochondria\u27e812\u27e9\n  * lazy_static\u27e813\u27e9\n  * async_once_cell\u27e814\u27e9\n  * generic_once_cell\u27e815\u27e9 (bring your own mutex)\n\n\nParts of ``once_cell`` API are included into ``std`` as of Rust 1.70.0\u27e816\u27e9.\n#### Dependencies\n~0\u20135MB \n  *  optional \u27e817\u27e9 critical-section\u27e818\u27e9\n  * parking_lot?\u27e819\u27e9 parking_lot_core\u27e820\u27e9\n  *  optional \u27e821\u27e9 portable-atomic\u27e822\u27e9\n\n\n  * dev  regex\u27e823\u27e9\n\n\n#### Other features\u27e824\u27e9\n  * alloc\u27e825\u27e9\n  * atomic-polyfill\u27e826\u27e9\n  * race\u27e827\u27e9\n  * std\u27e828\u27e9\n  * unstable\u27e829\u27e9\n\n\n  *[SLoC]: Lines of code, excluding comments\n",
              "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://lib.rs/crates/once_cell/versions: 58 releases\n\u27e82\u27e9 https://lib.rs/rust-patterns: Shared solutions for particular situations specific to programming in Rust. - Rust patterns\n\u27e83\u27e9 https://lib.rs/crates/once_cell/rev: **74,279** crates (6,091 directly)\n\u27e84\u27e9 https://img.gs/czjpqfbdkz/800/https://raw.githubusercontent.com/matklad/once_cell/29e3d93cf0367fc6c295785b282b8101127a3e16/design/logo.png: once_cell\n\u27e85\u27e9 https://img.gs/czjpqfbdkz/full/https://github.com/matklad/once_cell/actions/workflows/ci.yaml/badge.svg: ![Build Status\n\u27e86\u27e9 https://img.shields.io/crates/v/once_cell.svg: ![Crates.io\n\u27e87\u27e9 https://img.gs/czjpqfbdkz/full/https://docs.rs/once_cell/badge.svg: ![API reference\n\u27e88\u27e9 https://docs.rs/once_cell/: docs\n\u27e89\u27e9 https://github.com/niklasf/double-checked-cell: double-checked-cell\n\u27e810\u27e9 https://lib.rs/crates/lazy-init: lazy-init\n\u27e811\u27e9 https://lib.rs/crates/lazycell: lazycell\n\u27e812\u27e9 https://lib.rs/crates/mitochondria: mitochondria\n\u27e813\u27e9 https://lib.rs/crates/lazy_static: lazy_static\n\u27e814\u27e9 https://lib.rs/crates/async_once_cell: async_once_cell\n\u27e815\u27e9 https://lib.rs/crates/generic_once_cell: generic_once_cell\n\u27e816\u27e9 https://github.com/rust-lang/rust/pull/105587: as of Rust 1.70.0\n\u27e817\u27e9 https://lib.rs/crates/once_cell/features#feature-critical-section: critical-section is optional feature -  optional \n\u27e818\u27e9 https://lib.rs/crates/critical-section: 1.1.3 - critical-section\n\u27e819\u27e9 https://lib.rs/crates/once_cell/features#feature-parking_lot: optional feature - parking_lot?\n\u27e820\u27e9 https://lib.rs/crates/parking_lot_core: 0.9.10 - parking_lot_core\n\u27e821\u27e9 https://lib.rs/crates/once_cell/features#feature-portable-atomic: portable-atomic is optional feature -  optional \n\u27e822\u27e9 https://lib.rs/crates/portable-atomic: 1.8 - portable-atomic\n\u27e823\u27e9 https://lib.rs/crates/regex: 1.10.6 - regex\n\u27e824\u27e9 https://lib.rs/crates/once_cell/features: Other features\n\u27e825\u27e9 https://lib.rs/crates/once_cell/features#feature-alloc: alloc\n\u27e826\u27e9 https://lib.rs/crates/once_cell/features#feature-atomic-polyfill: atomic-polyfill\n\u27e827\u27e9 https://lib.rs/crates/once_cell/features#feature-race: race\n\u27e828\u27e9 https://lib.rs/crates/once_cell/features#feature-std: std\n\u27e829\u27e9 https://lib.rs/crates/once_cell/features#feature-unstable: unstable\n",
              "fit_markdown": "",
              "fit_html": ""
            },
            "structured_data": {},
            "quality_score": 3.0,
            "extraction_method": "crawl4ai",
            "error": null,
            "metadata": {
              "doc_type": "docs",
              "content_length": 4786,
              "has_structured_data": false,
              "crawl_success": true
            },
            "timestamp": "114432.7949226"
          }
        },
        "crate_analysis": {
          "status": "completed",
          "check": [
            {
              "reason": "compiler-artifact",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmp4sew26ie/once_cell-1.21.3#once_cell@1.21.3",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp4sew26ie\\once_cell-1.21.3\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "once_cell",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp4sew26ie\\once_cell-1.21.3\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "alloc",
                "default",
                "race",
                "std"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp4sew26ie\\once_cell-1.21.3\\target\\debug\\deps\\libonce_cell-62b59e15e07ef969.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "build-finished",
              "success": true
            }
          ],
          "clippy": [
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmp4sew26ie/once_cell-1.21.3#once_cell@1.21.3",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp4sew26ie\\once_cell-1.21.3\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "once_cell",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp4sew26ie\\once_cell-1.21.3\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: needless `fn main` in doctest\n   --> src\\lib.rs:115:5\n    |\n115 |   //! use once_cell::unsync::Lazy;\n    |  _____^\n116 | | //!\n117 | | //! fn main() {\n118 | | //!     let ctx = vec![1, 2, 3];\n...   |\n122 | | //!     assert_eq!(*thunk, 6);\n123 | | //! }\n    | |_____^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#needless_doctest_main\n    = note: `#[warn(clippy::needless_doctest_main)]` on by default\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#needless_doctest_main",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "note",
                    "message": "`#[warn(clippy::needless_doctest_main)]` on by default",
                    "rendered": null,
                    "spans": []
                  }
                ],
                "code": {
                  "code": "clippy::needless_doctest_main",
                  "explanation": null
                },
                "level": "warning",
                "message": "needless `fn main` in doctest",
                "spans": [
                  {
                    "byte_end": 3705,
                    "byte_start": 3504,
                    "column_end": 6,
                    "column_start": 5,
                    "expansion": null,
                    "file_name": "src\\lib.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 123,
                    "line_start": 115,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 33,
                        "highlight_start": 5,
                        "text": "//! use once_cell::unsync::Lazy;"
                      },
                      {
                        "highlight_end": 4,
                        "highlight_start": 1,
                        "text": "//!"
                      },
                      {
                        "highlight_end": 16,
                        "highlight_start": 1,
                        "text": "//! fn main() {"
                      },
                      {
                        "highlight_end": 33,
                        "highlight_start": 1,
                        "text": "//!     let ctx = vec![1, 2, 3];"
                      },
                      {
                        "highlight_end": 35,
                        "highlight_start": 1,
                        "text": "//!     let thunk = Lazy::new(|| {"
                      },
                      {
                        "highlight_end": 36,
                        "highlight_start": 1,
                        "text": "//!         ctx.iter().sum::<i32>()"
                      },
                      {
                        "highlight_end": 12,
                        "highlight_start": 1,
                        "text": "//!     });"
                      },
                      {
                        "highlight_end": 31,
                        "highlight_start": 1,
                        "text": "//!     assert_eq!(*thunk, 6);"
                      },
                      {
                        "highlight_end": 6,
                        "highlight_start": 1,
                        "text": "//! }"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmp4sew26ie/once_cell-1.21.3#once_cell@1.21.3",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp4sew26ie\\once_cell-1.21.3\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "once_cell",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp4sew26ie\\once_cell-1.21.3\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: unit tests in doctest are not executed\n   --> src\\lib.rs:200:5\n    |\n200 |   //! #[test]\n    |  _____^\n201 | | //! fn test_sobel_filter() {\n    | |________________________^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#test_attr_in_doctest\n    = note: `#[warn(clippy::test_attr_in_doctest)]` on by default\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#test_attr_in_doctest",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "note",
                    "message": "`#[warn(clippy::test_attr_in_doctest)]` on by default",
                    "rendered": null,
                    "spans": []
                  }
                ],
                "code": {
                  "code": "clippy::test_attr_in_doctest",
                  "explanation": null
                },
                "level": "warning",
                "message": "unit tests in doctest are not executed",
                "spans": [
                  {
                    "byte_end": 5937,
                    "byte_start": 5905,
                    "column_end": 25,
                    "column_start": 5,
                    "expansion": null,
                    "file_name": "src\\lib.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 201,
                    "line_start": 200,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 12,
                        "highlight_start": 5,
                        "text": "//! #[test]"
                      },
                      {
                        "highlight_end": 25,
                        "highlight_start": 1,
                        "text": "//! fn test_sobel_filter() {"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmp4sew26ie/once_cell-1.21.3#once_cell@1.21.3",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp4sew26ie\\once_cell-1.21.3\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "once_cell",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp4sew26ie\\once_cell-1.21.3\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: transmute from `*mut T` to `usize` which could be expressed as a pointer cast instead\n   --> src\\imp_std.rs:255:18\n    |\n255 |         unsafe { core::mem::transmute(ptr) }\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `ptr as usize`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#transmutes_expressible_as_ptr_casts\n    = note: `#[warn(clippy::transmutes_expressible_as_ptr_casts)]` on by default\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#transmutes_expressible_as_ptr_casts",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "note",
                    "message": "`#[warn(clippy::transmutes_expressible_as_ptr_casts)]` on by default",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "try",
                    "rendered": null,
                    "spans": [
                      {
                        "byte_end": 8683,
                        "byte_start": 8658,
                        "column_end": 43,
                        "column_start": 18,
                        "expansion": null,
                        "file_name": "src\\imp_std.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 255,
                        "line_start": 255,
                        "suggested_replacement": "ptr as usize",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 43,
                            "highlight_start": 18,
                            "text": "        unsafe { core::mem::transmute(ptr) }"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "code": {
                  "code": "clippy::transmutes_expressible_as_ptr_casts",
                  "explanation": null
                },
                "level": "warning",
                "message": "transmute from `*mut T` to `usize` which could be expressed as a pointer cast instead",
                "spans": [
                  {
                    "byte_end": 8683,
                    "byte_start": 8658,
                    "column_end": 43,
                    "column_start": 18,
                    "expansion": null,
                    "file_name": "src\\imp_std.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 255,
                    "line_start": 255,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 43,
                        "highlight_start": 18,
                        "text": "        unsafe { core::mem::transmute(ptr) }"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmp4sew26ie/once_cell-1.21.3#once_cell@1.21.3",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp4sew26ie\\once_cell-1.21.3\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "once_cell",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp4sew26ie\\once_cell-1.21.3\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: this returns a `Result<_, ()>`\n   --> src\\race.rs:107:5\n    |\n107 |     pub fn set(&self, value: NonZeroUsize) -> Result<(), ()> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: use a custom `Error` type instead\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#result_unit_err\n    = note: `#[warn(clippy::result_unit_err)]` on by default\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "use a custom `Error` type instead",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#result_unit_err",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "note",
                    "message": "`#[warn(clippy::result_unit_err)]` on by default",
                    "rendered": null,
                    "spans": []
                  }
                ],
                "code": {
                  "code": "clippy::result_unit_err",
                  "explanation": null
                },
                "level": "warning",
                "message": "this returns a `Result<_, ()>`",
                "spans": [
                  {
                    "byte_end": 4433,
                    "byte_start": 4377,
                    "column_end": 61,
                    "column_start": 5,
                    "expansion": null,
                    "file_name": "src\\race.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 107,
                    "line_start": 107,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 61,
                        "highlight_start": 5,
                        "text": "    pub fn set(&self, value: NonZeroUsize) -> Result<(), ()> {"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmp4sew26ie/once_cell-1.21.3#once_cell@1.21.3",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp4sew26ie\\once_cell-1.21.3\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "once_cell",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp4sew26ie\\once_cell-1.21.3\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: this returns a `Result<_, ()>`\n   --> src\\race.rs:189:5\n    |\n189 |     pub fn set(&self, value: bool) -> Result<(), ()> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: use a custom `Error` type instead\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#result_unit_err\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "use a custom `Error` type instead",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#result_unit_err",
                    "rendered": null,
                    "spans": []
                  }
                ],
                "code": {
                  "code": "clippy::result_unit_err",
                  "explanation": null
                },
                "level": "warning",
                "message": "this returns a `Result<_, ()>`",
                "spans": [
                  {
                    "byte_end": 6894,
                    "byte_start": 6846,
                    "column_end": 53,
                    "column_start": 5,
                    "expansion": null,
                    "file_name": "src\\race.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 189,
                    "line_start": 189,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 53,
                        "highlight_start": 5,
                        "text": "    pub fn set(&self, value: bool) -> Result<(), ()> {"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmp4sew26ie/once_cell-1.21.3#once_cell@1.21.3",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp4sew26ie\\once_cell-1.21.3\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "once_cell",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp4sew26ie\\once_cell-1.21.3\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: this returns a `Result<_, ()>`\n   --> src\\race.rs:268:5\n    |\n268 |     pub fn set(&self, value: &'a T) -> Result<(), ()> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: use a custom `Error` type instead\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#result_unit_err\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "use a custom `Error` type instead",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#result_unit_err",
                    "rendered": null,
                    "spans": []
                  }
                ],
                "code": {
                  "code": "clippy::result_unit_err",
                  "explanation": null
                },
                "level": "warning",
                "message": "this returns a `Result<_, ()>`",
                "spans": [
                  {
                    "byte_end": 9321,
                    "byte_start": 9272,
                    "column_end": 54,
                    "column_start": 5,
                    "expansion": null,
                    "file_name": "src\\race.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 268,
                    "line_start": 268,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 54,
                        "highlight_start": 5,
                        "text": "    pub fn set(&self, value: &'a T) -> Result<(), ()> {"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-artifact",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmp4sew26ie/once_cell-1.21.3#once_cell@1.21.3",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp4sew26ie\\once_cell-1.21.3\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "once_cell",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp4sew26ie\\once_cell-1.21.3\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "alloc",
                "default",
                "race",
                "std"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp4sew26ie\\once_cell-1.21.3\\target\\debug\\deps\\libonce_cell-7aa9f03095627592.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "build-finished",
              "success": true
            }
          ],
          "audit": {
            "database": {
              "advisory-count": 787,
              "last-commit": "7573f55ba337263f61167dbb0ea926cdc7c8eb5d",
              "last-updated": "2025-06-17T11:04:25+02:00"
            },
            "lockfile": {
              "dependency-count": 23
            },
            "settings": {
              "target_arch": [],
              "target_os": [],
              "severity": null,
              "ignore": [],
              "informational_warnings": [
                "unmaintained",
                "unsound",
                "notice"
              ]
            },
            "vulnerabilities": {
              "found": false,
              "count": 0,
              "list": []
            },
            "warnings": {
              "yanked": [
                {
                  "kind": "yanked",
                  "package": {
                    "name": "critical-section",
                    "version": "1.1.3",
                    "source": "registry+https://github.com/rust-lang/crates.io-index",
                    "checksum": "f64009896348fc5af4222e9cf7d7d82a95a256c634ebcf61c53e4ea461422242",
                    "replace": null
                  },
                  "advisory": null,
                  "affected": null,
                  "versions": null
                }
              ]
            }
          },
          "note": "Crate analysis performed with stable toolchain."
        },
        "crate_metadata": {
          "name": "once_cell",
          "version": "1.21.3",
          "description": "ALLOW: Positive community sentiment",
          "repository": "",
          "keywords": [],
          "categories": [],
          "readme": {
            "raw_markdown": "[](https://docs.rs/once_cell/latest/once_cell/all.html \"show sidebar\")\n# Crate once_cellCopy item path\n[Settings](https://docs.rs/once_cell/latest/settings.html)\n[Help](https://docs.rs/once_cell/latest/help.html)\nSummary[Source](https://docs.rs/once_cell/latest/src/once_cell/lib.rs.html#1-1412)\nExpand description\n## [\u00a7](https://docs.rs/once_cell/latest/once_cell/#overview)Overview\n`once_cell` provides two new cell-like types, [`unsync::OnceCell`](https://docs.rs/once_cell/latest/once_cell/unsync/struct.OnceCell.html) and [`sync::OnceCell`](https://docs.rs/once_cell/latest/once_cell/sync/struct.OnceCell.html). A `OnceCell` might store arbitrary non-`Copy` types, can be assigned to at most once and provides direct access to the stored contents. The core API looks _roughly_ like this (and there\u2019s much more inside, read on!):\n[\u24d8](https://docs.rs/once_cell/latest/once_cell/ \"This example is not tested\")```\nimpl<T> OnceCell<T> {\n  const fn new() -> OnceCell<T> { ... }\n  fn set(&self, value: T) -> Result<(), T> { ... }\n  fn get(&self) -> Option<&T> { ... }\n}\n```\n\nNote that, like with [`RefCell`](https://doc.rust-lang.org/std/cell/struct.RefCell.html) and [`Mutex`](https://doc.rust-lang.org/std/sync/struct.Mutex.html), the `set` method requires only a shared reference. Because of the single assignment restriction `get` can return a `&T` instead of `Ref<T>` or `MutexGuard<T>`.\nThe `sync` flavor is thread-safe (that is, implements the [`Sync`](https://doc.rust-lang.org/std/marker/trait.Sync.html) trait), while the `unsync` one is not.\n## [\u00a7](https://docs.rs/once_cell/latest/once_cell/#recipes)Recipes\n`OnceCell` might be useful for a variety of patterns.\n### [\u00a7](https://docs.rs/once_cell/latest/once_cell/#safe-initialization-of-global-data)Safe Initialization of Global Data\n```\nuse std::{env, io};\nuse once_cell::sync::OnceCell;\n#[derive(Debug)]\npub struct Logger {\n  // ...\n}\nstatic INSTANCE: OnceCell<Logger> = OnceCell::new();\nimpl Logger {\n  pub fn global() -> &'static Logger {\n    INSTANCE.get().expect(\"logger is not initialized\")\n  }\n  fn from_cli(args: env::Args) -> Result<Logger, std::io::Error> {\n    // ...\n  }\n}\nfn main() {\n  let logger = Logger::from_cli(env::args()).unwrap();\n  INSTANCE.set(logger).unwrap();\n  // use `Logger::global()` from now on\n}\n```\n\n### [\u00a7](https://docs.rs/once_cell/latest/once_cell/#lazy-initialized-global-data)Lazy Initialized Global Data\nThis is essentially the `lazy_static!` macro, but without a macro.\n```\nuse std::{sync::Mutex, collections::HashMap};\nuse once_cell::sync::OnceCell;\nfn global_data() -> &'static Mutex<HashMap<i32, String>> {\n  static INSTANCE: OnceCell<Mutex<HashMap<i32, String>>> = OnceCell::new();\n  INSTANCE.get_or_init(|| {\n    let mut m = HashMap::new();\n    m.insert(13, \"Spica\".to_string());\n    m.insert(74, \"Hoyten\".to_string());\n    Mutex::new(m)\n  })\n}\n```\n\nThere are also the [`sync::Lazy`](https://docs.rs/once_cell/latest/once_cell/sync/struct.Lazy.html) and [`unsync::Lazy`](https://docs.rs/once_cell/latest/once_cell/unsync/struct.Lazy.html) convenience types to streamline this pattern:\n```\nuse std::{sync::Mutex, collections::HashMap};\nuse once_cell::sync::Lazy;\nstatic GLOBAL_DATA: Lazy<Mutex<HashMap<i32, String>>> = Lazy::new(|| {\n  let mut m = HashMap::new();\n  m.insert(13, \"Spica\".to_string());\n  m.insert(74, \"Hoyten\".to_string());\n  Mutex::new(m)\n});\nfn main() {\n  println!(\"{:?}\", GLOBAL_DATA.lock().unwrap());\n}\n```\n\nNote that the variable that holds `Lazy` is declared as `static`, _not_ `const`. This is important: using `const` instead compiles, but works wrong.\n### [\u00a7](https://docs.rs/once_cell/latest/once_cell/#general-purpose-lazy-evaluation)General purpose lazy evaluation\nUnlike `lazy_static!`, `Lazy` works with local variables.\n```\nuse once_cell::unsync::Lazy;\nfn main() {\n  let ctx = vec![1, 2, 3];\n  let thunk = Lazy::new(|| {\n    ctx.iter().sum::<i32>()\n  });\n  assert_eq!(*thunk, 6);\n}\n```\n\nIf you need a lazy field in a struct, you probably should use `OnceCell` directly, because that will allow you to access `self` during initialization.\n```\nuse std::{fs, path::PathBuf};\nuse once_cell::unsync::OnceCell;\nstruct Ctx {\n  config_path: PathBuf,\n  config: OnceCell<String>,\n}\nimpl Ctx {\n  pub fn get_config(&self) -> Result<&str, std::io::Error> {\n    let cfg = self.config.get_or_try_init(|| {\n      fs::read_to_string(&self.config_path)\n    })?;\n    Ok(cfg.as_str())\n  }\n}\n```\n\n### [\u00a7](https://docs.rs/once_cell/latest/once_cell/#lazily-compiled-regex)Lazily Compiled Regex\nThis is a `regex!` macro which takes a string literal and returns an _expression_ that evaluates to a `&'static Regex`:\n```\nmacro_rules! regex {\n  ($re:literal $(,)?) => {{\n    static RE: once_cell::sync::OnceCell<regex::Regex> = once_cell::sync::OnceCell::new();\n    RE.get_or_init(|| regex::Regex::new($re).unwrap())\n  }};\n}\n```\n\nThis macro can be useful to avoid the \u201ccompile regex on every loop iteration\u201d problem.\n### [\u00a7](https://docs.rs/once_cell/latest/once_cell/#runtime-include_bytes)Runtime `include_bytes!`\nThe `include_bytes` macro is useful to include test resources, but it slows down test compilation a lot. An alternative is to load the resources at runtime:\n```\nuse std::path::Path;\nuse once_cell::sync::OnceCell;\npub struct TestResource {\n  path: &'static str,\n  cell: OnceCell<Vec<u8>>,\n}\nimpl TestResource {\n  pub const fn new(path: &'static str) -> TestResource {\n    TestResource { path, cell: OnceCell::new() }\n  }\n  pub fn bytes(&self) -> &[u8] {\n    self.cell.get_or_init(|| {\n      let dir = std::env::var(\"CARGO_MANIFEST_DIR\").unwrap();\n      let path = Path::new(dir.as_str()).join(self.path);\n      std::fs::read(&path).unwrap_or_else(|_err| {\n        panic!(\"failed to load test resource: {}\", path.display())\n      })\n    }).as_slice()\n  }\n}\nstatic TEST_IMAGE: TestResource = TestResource::new(\"test_data/lena.png\");\n#[test]\nfn test_sobel_filter() {\n  let rgb: &[u8] = TEST_IMAGE.bytes();\n  // ...\n}\n```\n\n### [\u00a7](https://docs.rs/once_cell/latest/once_cell/#lateinit)`lateinit`\n`LateInit` type for delayed initialization. It is reminiscent of Kotlin\u2019s `lateinit` keyword and allows construction of cyclic data structures:\n```\nuse once_cell::sync::OnceCell;\npub struct LateInit<T> { cell: OnceCell<T> }\nimpl<T> LateInit<T> {\n  pub fn init(&self, value: T) {\n    assert!(self.cell.set(value).is_ok())\n  }\n}\nimpl<T> Default for LateInit<T> {\n  fn default() -> Self { LateInit { cell: OnceCell::default() } }\n}\nimpl<T> std::ops::Deref for LateInit<T> {\n  type Target = T;\n  fn deref(&self) -> &T {\n    self.cell.get().unwrap()\n  }\n}\n#[derive(Default)]\nstruct A<'a> {\n  b: LateInit<&'a B<'a>>,\n}\n#[derive(Default)]\nstruct B<'a> {\n  a: LateInit<&'a A<'a>>\n}\n\nfn build_cycle() {\n  let a = A::default();\n  let b = B::default();\n  a.b.init(&b);\n  b.a.init(&a);\n  let _a = &a.b.a.b.a;\n}\n```\n\n## [\u00a7](https://docs.rs/once_cell/latest/once_cell/#comparison-with-std)Comparison with std\n`!Sync` types| Access Mode| Drawbacks  \n---|---|---  \n`Cell<T>`| `T`| requires `T: Copy` for `get`  \n`RefCell<T>`| `RefMut<T>` / `Ref<T>`| may panic at runtime  \n`unsync::OnceCell<T>`| `&T`| assignable only once  \n`Sync` types| Access Mode| Drawbacks  \n---|---|---  \n`AtomicT`| `T`| works only with certain `Copy` types  \n`Mutex<T>`| `MutexGuard<T>`| may deadlock at runtime, may block the thread  \n`sync::OnceCell<T>`| `&T`| assignable only once, may block the thread  \nTechnically, calling `get_or_init` will also cause a panic or a deadlock if it recursively calls itself. However, because the assignment can happen only once, such cases should be more rare than equivalents with `RefCell` and `Mutex`.\n## [\u00a7](https://docs.rs/once_cell/latest/once_cell/#minimum-supported-rustc-version)Minimum Supported `rustc` Version\nIf only the `std`, `alloc`, or `race` features are enabled, MSRV will be updated conservatively, supporting at least latest 8 versions of the compiler. When using other features, like `parking_lot`, MSRV might be updated more frequently, up to the latest stable. In both cases, increasing MSRV is _not_ considered a semver-breaking change and requires only a minor version bump.\n## [\u00a7](https://docs.rs/once_cell/latest/once_cell/#implementation-details)Implementation details\nThe implementation is based on the [`lazy_static`](https://github.com/rust-lang-nursery/lazy-static.rs/) and [`lazy_cell`](https://github.com/indiv0/lazycell/) crates and [`std::sync::Once`](https://doc.rust-lang.org/std/sync/struct.Once.html). In some sense, `once_cell` just streamlines and unifies those APIs.\nTo implement a sync flavor of `OnceCell`, this crates uses either a custom re-implementation of `std::sync::Once` or `parking_lot::Mutex`. This is controlled by the `parking_lot` feature (disabled by default). Performance is the same for both cases, but the `parking_lot` based `OnceCell<T>` is smaller by up to 16 bytes.\nThis crate uses `unsafe`.\n## [\u00a7](https://docs.rs/once_cell/latest/once_cell/#faq)F.A.Q.\n**Should I use the sync or unsync flavor?**\nBecause Rust compiler checks thread safety for you, it\u2019s impossible to accidentally use `unsync` where `sync` is required. So, use `unsync` in single-threaded code and `sync` in multi-threaded. It\u2019s easy to switch between the two if code becomes multi-threaded later.\nAt the moment, `unsync` has an additional benefit that reentrant initialization causes a panic, which might be easier to debug than a deadlock.\n**Does this crate support async?**\nNo, but you can use [`async_once_cell`](https://crates.io/crates/async_once_cell) instead.\n**Does this crate support`no_std`?**\nYes, but with caveats. `OnceCell` is a synchronization primitive which _semantically_ relies on blocking. `OnceCell` guarantees that at most one `f` will be called to compute the value. If two threads of execution call `get_or_init` concurrently, one of them has to wait.\nWaiting fundamentally requires OS support. Execution environment needs to understand who waits on whom to prevent deadlocks due to priority inversion. You _could_ make code to compile by blindly using pure spinlocks, but the runtime behavior would be subtly wrong.\nGiven these constraints, `once_cell` provides the following options:\n  * The `race` module provides similar, but distinct synchronization primitive which is compatible with `no_std`. With `race`, the `f` function can be called multiple times by different threads, but only one thread will win to install the value.\n  * `critical-section` feature (with a `-`, not `_`) uses `critical_section` to implement blocking.\n\n\n**Can I bring my own mutex?**\nThere is [generic_once_cell](https://crates.io/crates/generic_once_cell) to allow just that.\n**Should I use`std::cell::OnceCell` , `once_cell`, or `lazy_static`?**\nIf you can use `std` version (your MSRV is at least 1.70, and you don\u2019t need extra features `once_cell` provides), use `std`. Otherwise, use `once_cell`. Don\u2019t use `lazy_static`.\n## [\u00a7](https://docs.rs/once_cell/latest/once_cell/#related-crates)Related crates\n  * Most of this crate\u2019s functionality is available in `std` starting with Rust 1.70. See `std::cell::OnceCell` and `std::sync::OnceLock`.\n  * [double-checked-cell](https://github.com/niklasf/double-checked-cell)\n  * [lazy-init](https://crates.io/crates/lazy-init)\n  * [lazycell](https://crates.io/crates/lazycell)\n  * [mitochondria](https://crates.io/crates/mitochondria)\n  * [lazy_static](https://crates.io/crates/lazy_static)\n  * [async_once_cell](https://crates.io/crates/async_once_cell)\n  * [generic_once_cell](https://crates.io/crates/generic_once_cell) (bring your own mutex)\n\n\n## Modules[\u00a7](https://docs.rs/once_cell/latest/once_cell/#modules)\n\n[race](https://docs.rs/once_cell/latest/once_cell/race/index.html \"mod once_cell::race\")\n    Thread-safe, non-blocking, \u201cfirst one wins\u201d flavor of `OnceCell`.\n\n[sync](https://docs.rs/once_cell/latest/once_cell/sync/index.html \"mod once_cell::sync\")\n    Thread-safe, blocking version of `OnceCell`.\n\n[unsync](https://docs.rs/once_cell/latest/once_cell/unsync/index.html \"mod once_cell::unsync\")\n    Single-threaded version of `OnceCell`.\n",
            "markdown_with_citations": "[](https://docs.rs/once_cell/latest/once_cell/all.html \"show sidebar\")\n# Crate once_cellCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\n## \u00a7\u27e84\u27e9Overview\n`once_cell` provides two new cell-like types, `unsync::OnceCell`\u27e85\u27e9 and `sync::OnceCell`\u27e86\u27e9. A `OnceCell` might store arbitrary non-`Copy` types, can be assigned to at most once and provides direct access to the stored contents. The core API looks _roughly_ like this (and there\u2019s much more inside, read on!):\n\u24d8\u27e87\u27e9```\nimpl<T> OnceCell<T> {\n  const fn new() -> OnceCell<T> { ... }\n  fn set(&self, value: T) -> Result<(), T> { ... }\n  fn get(&self) -> Option<&T> { ... }\n}\n```\n\nNote that, like with `RefCell`\u27e88\u27e9 and `Mutex`\u27e89\u27e9, the `set` method requires only a shared reference. Because of the single assignment restriction `get` can return a `&T` instead of `Ref<T>` or `MutexGuard<T>`.\nThe `sync` flavor is thread-safe (that is, implements the `Sync`\u27e810\u27e9 trait), while the `unsync` one is not.\n## \u00a7\u27e811\u27e9Recipes\n`OnceCell` might be useful for a variety of patterns.\n### \u00a7\u27e812\u27e9Safe Initialization of Global Data\n```\nuse std::{env, io};\nuse once_cell::sync::OnceCell;\n#[derive(Debug)]\npub struct Logger {\n  // ...\n}\nstatic INSTANCE: OnceCell<Logger> = OnceCell::new();\nimpl Logger {\n  pub fn global() -> &'static Logger {\n    INSTANCE.get().expect(\"logger is not initialized\")\n  }\n  fn from_cli(args: env::Args) -> Result<Logger, std::io::Error> {\n    // ...\n  }\n}\nfn main() {\n  let logger = Logger::from_cli(env::args()).unwrap();\n  INSTANCE.set(logger).unwrap();\n  // use `Logger::global()` from now on\n}\n```\n\n### \u00a7\u27e813\u27e9Lazy Initialized Global Data\nThis is essentially the `lazy_static!` macro, but without a macro.\n```\nuse std::{sync::Mutex, collections::HashMap};\nuse once_cell::sync::OnceCell;\nfn global_data() -> &'static Mutex<HashMap<i32, String>> {\n  static INSTANCE: OnceCell<Mutex<HashMap<i32, String>>> = OnceCell::new();\n  INSTANCE.get_or_init(|| {\n    let mut m = HashMap::new();\n    m.insert(13, \"Spica\".to_string());\n    m.insert(74, \"Hoyten\".to_string());\n    Mutex::new(m)\n  })\n}\n```\n\nThere are also the `sync::Lazy`\u27e814\u27e9 and `unsync::Lazy`\u27e815\u27e9 convenience types to streamline this pattern:\n```\nuse std::{sync::Mutex, collections::HashMap};\nuse once_cell::sync::Lazy;\nstatic GLOBAL_DATA: Lazy<Mutex<HashMap<i32, String>>> = Lazy::new(|| {\n  let mut m = HashMap::new();\n  m.insert(13, \"Spica\".to_string());\n  m.insert(74, \"Hoyten\".to_string());\n  Mutex::new(m)\n});\nfn main() {\n  println!(\"{:?}\", GLOBAL_DATA.lock().unwrap());\n}\n```\n\nNote that the variable that holds `Lazy` is declared as `static`, _not_ `const`. This is important: using `const` instead compiles, but works wrong.\n### \u00a7\u27e816\u27e9General purpose lazy evaluation\nUnlike `lazy_static!`, `Lazy` works with local variables.\n```\nuse once_cell::unsync::Lazy;\nfn main() {\n  let ctx = vec![1, 2, 3];\n  let thunk = Lazy::new(|| {\n    ctx.iter().sum::<i32>()\n  });\n  assert_eq!(*thunk, 6);\n}\n```\n\nIf you need a lazy field in a struct, you probably should use `OnceCell` directly, because that will allow you to access `self` during initialization.\n```\nuse std::{fs, path::PathBuf};\nuse once_cell::unsync::OnceCell;\nstruct Ctx {\n  config_path: PathBuf,\n  config: OnceCell<String>,\n}\nimpl Ctx {\n  pub fn get_config(&self) -> Result<&str, std::io::Error> {\n    let cfg = self.config.get_or_try_init(|| {\n      fs::read_to_string(&self.config_path)\n    })?;\n    Ok(cfg.as_str())\n  }\n}\n```\n\n### \u00a7\u27e817\u27e9Lazily Compiled Regex\nThis is a `regex!` macro which takes a string literal and returns an _expression_ that evaluates to a `&'static Regex`:\n```\nmacro_rules! regex {\n  ($re:literal $(,)?) => {{\n    static RE: once_cell::sync::OnceCell<regex::Regex> = once_cell::sync::OnceCell::new();\n    RE.get_or_init(|| regex::Regex::new($re).unwrap())\n  }};\n}\n```\n\nThis macro can be useful to avoid the \u201ccompile regex on every loop iteration\u201d problem.\n### \u00a7\u27e818\u27e9Runtime `include_bytes!`\nThe `include_bytes` macro is useful to include test resources, but it slows down test compilation a lot. An alternative is to load the resources at runtime:\n```\nuse std::path::Path;\nuse once_cell::sync::OnceCell;\npub struct TestResource {\n  path: &'static str,\n  cell: OnceCell<Vec<u8>>,\n}\nimpl TestResource {\n  pub const fn new(path: &'static str) -> TestResource {\n    TestResource { path, cell: OnceCell::new() }\n  }\n  pub fn bytes(&self) -> &[u8] {\n    self.cell.get_or_init(|| {\n      let dir = std::env::var(\"CARGO_MANIFEST_DIR\").unwrap();\n      let path = Path::new(dir.as_str()).join(self.path);\n      std::fs::read(&path).unwrap_or_else(|_err| {\n        panic!(\"failed to load test resource: {}\", path.display())\n      })\n    }).as_slice()\n  }\n}\nstatic TEST_IMAGE: TestResource = TestResource::new(\"test_data/lena.png\");\n#[test]\nfn test_sobel_filter() {\n  let rgb: &[u8] = TEST_IMAGE.bytes();\n  // ...\n}\n```\n\n### \u00a7\u27e819\u27e9`lateinit`\n`LateInit` type for delayed initialization. It is reminiscent of Kotlin\u2019s `lateinit` keyword and allows construction of cyclic data structures:\n```\nuse once_cell::sync::OnceCell;\npub struct LateInit<T> { cell: OnceCell<T> }\nimpl<T> LateInit<T> {\n  pub fn init(&self, value: T) {\n    assert!(self.cell.set(value).is_ok())\n  }\n}\nimpl<T> Default for LateInit<T> {\n  fn default() -> Self { LateInit { cell: OnceCell::default() } }\n}\nimpl<T> std::ops::Deref for LateInit<T> {\n  type Target = T;\n  fn deref(&self) -> &T {\n    self.cell.get().unwrap()\n  }\n}\n#[derive(Default)]\nstruct A<'a> {\n  b: LateInit<&'a B<'a>>,\n}\n#[derive(Default)]\nstruct B<'a> {\n  a: LateInit<&'a A<'a>>\n}\n\nfn build_cycle() {\n  let a = A::default();\n  let b = B::default();\n  a.b.init(&b);\n  b.a.init(&a);\n  let _a = &a.b.a.b.a;\n}\n```\n\n## \u00a7\u27e820\u27e9Comparison with std\n`!Sync` types| Access Mode| Drawbacks  \n---|---|---  \n`Cell<T>`| `T`| requires `T: Copy` for `get`  \n`RefCell<T>`| `RefMut<T>` / `Ref<T>`| may panic at runtime  \n`unsync::OnceCell<T>`| `&T`| assignable only once  \n`Sync` types| Access Mode| Drawbacks  \n---|---|---  \n`AtomicT`| `T`| works only with certain `Copy` types  \n`Mutex<T>`| `MutexGuard<T>`| may deadlock at runtime, may block the thread  \n`sync::OnceCell<T>`| `&T`| assignable only once, may block the thread  \nTechnically, calling `get_or_init` will also cause a panic or a deadlock if it recursively calls itself. However, because the assignment can happen only once, such cases should be more rare than equivalents with `RefCell` and `Mutex`.\n## \u00a7\u27e821\u27e9Minimum Supported `rustc` Version\nIf only the `std`, `alloc`, or `race` features are enabled, MSRV will be updated conservatively, supporting at least latest 8 versions of the compiler. When using other features, like `parking_lot`, MSRV might be updated more frequently, up to the latest stable. In both cases, increasing MSRV is _not_ considered a semver-breaking change and requires only a minor version bump.\n## \u00a7\u27e822\u27e9Implementation details\nThe implementation is based on the `lazy_static`\u27e823\u27e9 and `lazy_cell`\u27e824\u27e9 crates and `std::sync::Once`\u27e825\u27e9. In some sense, `once_cell` just streamlines and unifies those APIs.\nTo implement a sync flavor of `OnceCell`, this crates uses either a custom re-implementation of `std::sync::Once` or `parking_lot::Mutex`. This is controlled by the `parking_lot` feature (disabled by default). Performance is the same for both cases, but the `parking_lot` based `OnceCell<T>` is smaller by up to 16 bytes.\nThis crate uses `unsafe`.\n## \u00a7\u27e826\u27e9F.A.Q.\n**Should I use the sync or unsync flavor?**\nBecause Rust compiler checks thread safety for you, it\u2019s impossible to accidentally use `unsync` where `sync` is required. So, use `unsync` in single-threaded code and `sync` in multi-threaded. It\u2019s easy to switch between the two if code becomes multi-threaded later.\nAt the moment, `unsync` has an additional benefit that reentrant initialization causes a panic, which might be easier to debug than a deadlock.\n**Does this crate support async?**\nNo, but you can use `async_once_cell`\u27e827\u27e9 instead.\n**Does this crate support`no_std`?**\nYes, but with caveats. `OnceCell` is a synchronization primitive which _semantically_ relies on blocking. `OnceCell` guarantees that at most one `f` will be called to compute the value. If two threads of execution call `get_or_init` concurrently, one of them has to wait.\nWaiting fundamentally requires OS support. Execution environment needs to understand who waits on whom to prevent deadlocks due to priority inversion. You _could_ make code to compile by blindly using pure spinlocks, but the runtime behavior would be subtly wrong.\nGiven these constraints, `once_cell` provides the following options:\n  * The `race` module provides similar, but distinct synchronization primitive which is compatible with `no_std`. With `race`, the `f` function can be called multiple times by different threads, but only one thread will win to install the value.\n  * `critical-section` feature (with a `-`, not `_`) uses `critical_section` to implement blocking.\n\n\n**Can I bring my own mutex?**\nThere is generic_once_cell\u27e828\u27e9 to allow just that.\n**Should I use`std::cell::OnceCell` , `once_cell`, or `lazy_static`?**\nIf you can use `std` version (your MSRV is at least 1.70, and you don\u2019t need extra features `once_cell` provides), use `std`. Otherwise, use `once_cell`. Don\u2019t use `lazy_static`.\n## \u00a7\u27e829\u27e9Related crates\n  * Most of this crate\u2019s functionality is available in `std` starting with Rust 1.70. See `std::cell::OnceCell` and `std::sync::OnceLock`.\n  * double-checked-cell\u27e830\u27e9\n  * lazy-init\u27e831\u27e9\n  * lazycell\u27e832\u27e9\n  * mitochondria\u27e833\u27e9\n  * lazy_static\u27e834\u27e9\n  * async_once_cell\u27e827\u27e9\n  * generic_once_cell\u27e828\u27e9 (bring your own mutex)\n\n\n## Modules\u00a7\u27e835\u27e9\n\nrace\u27e836\u27e9\n    Thread-safe, non-blocking, \u201cfirst one wins\u201d flavor of `OnceCell`.\n\nsync\u27e837\u27e9\n    Thread-safe, blocking version of `OnceCell`.\n\nunsync\u27e838\u27e9\n    Single-threaded version of `OnceCell`.\n",
            "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/once_cell/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/once_cell/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/once_cell/latest/src/once_cell/lib.rs.html#1-1412: Source\n\u27e84\u27e9 https://docs.rs/once_cell/latest/once_cell/#overview: \u00a7\n\u27e85\u27e9 https://docs.rs/once_cell/latest/once_cell/unsync/struct.OnceCell.html: `unsync::OnceCell`\n\u27e86\u27e9 https://docs.rs/once_cell/latest/once_cell/sync/struct.OnceCell.html: `sync::OnceCell`\n\u27e87\u27e9 https://docs.rs/once_cell/latest/once_cell/: This example is not tested - \u24d8\n\u27e88\u27e9 https://doc.rust-lang.org/std/cell/struct.RefCell.html: `RefCell`\n\u27e89\u27e9 https://doc.rust-lang.org/std/sync/struct.Mutex.html: `Mutex`\n\u27e810\u27e9 https://doc.rust-lang.org/std/marker/trait.Sync.html: `Sync`\n\u27e811\u27e9 https://docs.rs/once_cell/latest/once_cell/#recipes: \u00a7\n\u27e812\u27e9 https://docs.rs/once_cell/latest/once_cell/#safe-initialization-of-global-data: \u00a7\n\u27e813\u27e9 https://docs.rs/once_cell/latest/once_cell/#lazy-initialized-global-data: \u00a7\n\u27e814\u27e9 https://docs.rs/once_cell/latest/once_cell/sync/struct.Lazy.html: `sync::Lazy`\n\u27e815\u27e9 https://docs.rs/once_cell/latest/once_cell/unsync/struct.Lazy.html: `unsync::Lazy`\n\u27e816\u27e9 https://docs.rs/once_cell/latest/once_cell/#general-purpose-lazy-evaluation: \u00a7\n\u27e817\u27e9 https://docs.rs/once_cell/latest/once_cell/#lazily-compiled-regex: \u00a7\n\u27e818\u27e9 https://docs.rs/once_cell/latest/once_cell/#runtime-include_bytes: \u00a7\n\u27e819\u27e9 https://docs.rs/once_cell/latest/once_cell/#lateinit: \u00a7\n\u27e820\u27e9 https://docs.rs/once_cell/latest/once_cell/#comparison-with-std: \u00a7\n\u27e821\u27e9 https://docs.rs/once_cell/latest/once_cell/#minimum-supported-rustc-version: \u00a7\n\u27e822\u27e9 https://docs.rs/once_cell/latest/once_cell/#implementation-details: \u00a7\n\u27e823\u27e9 https://github.com/rust-lang-nursery/lazy-static.rs/: `lazy_static`\n\u27e824\u27e9 https://github.com/indiv0/lazycell/: `lazy_cell`\n\u27e825\u27e9 https://doc.rust-lang.org/std/sync/struct.Once.html: `std::sync::Once`\n\u27e826\u27e9 https://docs.rs/once_cell/latest/once_cell/#faq: \u00a7\n\u27e827\u27e9 https://crates.io/crates/async_once_cell: `async_once_cell`\n\u27e828\u27e9 https://crates.io/crates/generic_once_cell: generic_once_cell\n\u27e829\u27e9 https://docs.rs/once_cell/latest/once_cell/#related-crates: \u00a7\n\u27e830\u27e9 https://github.com/niklasf/double-checked-cell: double-checked-cell\n\u27e831\u27e9 https://crates.io/crates/lazy-init: lazy-init\n\u27e832\u27e9 https://crates.io/crates/lazycell: lazycell\n\u27e833\u27e9 https://crates.io/crates/mitochondria: mitochondria\n\u27e834\u27e9 https://crates.io/crates/lazy_static: lazy_static\n\u27e835\u27e9 https://docs.rs/once_cell/latest/once_cell/#modules: \u00a7\n\u27e836\u27e9 https://docs.rs/once_cell/latest/once_cell/race/index.html: mod once_cell::race - race\n\u27e837\u27e9 https://docs.rs/once_cell/latest/once_cell/sync/index.html: mod once_cell::sync - sync\n\u27e838\u27e9 https://docs.rs/once_cell/latest/once_cell/unsync/index.html: mod once_cell::unsync - unsync\n",
            "fit_markdown": "",
            "fit_html": ""
          },
          "downloads": 0,
          "github_stars": 0,
          "dependencies": [],
          "features": {},
          "code_snippets": [],
          "readme_sections": {},
          "librs_downloads": null,
          "source": "crates.io",
          "enhanced_scraping": {},
          "enhanced_features": [],
          "enhanced_dependencies": []
        },
        "enriched_crate": {
          "name": "once_cell",
          "version": "1.21.3",
          "description": "ALLOW: Positive community sentiment",
          "repository": "",
          "keywords": [],
          "categories": [],
          "readme": {
            "raw_markdown": "[](https://docs.rs/once_cell/latest/once_cell/all.html \"show sidebar\")\n# Crate once_cellCopy item path\n[Settings](https://docs.rs/once_cell/latest/settings.html)\n[Help](https://docs.rs/once_cell/latest/help.html)\nSummary[Source](https://docs.rs/once_cell/latest/src/once_cell/lib.rs.html#1-1412)\nExpand description\n## [\u00a7](https://docs.rs/once_cell/latest/once_cell/#overview)Overview\n`once_cell` provides two new cell-like types, [`unsync::OnceCell`](https://docs.rs/once_cell/latest/once_cell/unsync/struct.OnceCell.html) and [`sync::OnceCell`](https://docs.rs/once_cell/latest/once_cell/sync/struct.OnceCell.html). A `OnceCell` might store arbitrary non-`Copy` types, can be assigned to at most once and provides direct access to the stored contents. The core API looks _roughly_ like this (and there\u2019s much more inside, read on!):\n[\u24d8](https://docs.rs/once_cell/latest/once_cell/ \"This example is not tested\")```\nimpl<T> OnceCell<T> {\n  const fn new() -> OnceCell<T> { ... }\n  fn set(&self, value: T) -> Result<(), T> { ... }\n  fn get(&self) -> Option<&T> { ... }\n}\n```\n\nNote that, like with [`RefCell`](https://doc.rust-lang.org/std/cell/struct.RefCell.html) and [`Mutex`](https://doc.rust-lang.org/std/sync/struct.Mutex.html), the `set` method requires only a shared reference. Because of the single assignment restriction `get` can return a `&T` instead of `Ref<T>` or `MutexGuard<T>`.\nThe `sync` flavor is thread-safe (that is, implements the [`Sync`](https://doc.rust-lang.org/std/marker/trait.Sync.html) trait), while the `unsync` one is not.\n## [\u00a7](https://docs.rs/once_cell/latest/once_cell/#recipes)Recipes\n`OnceCell` might be useful for a variety of patterns.\n### [\u00a7](https://docs.rs/once_cell/latest/once_cell/#safe-initialization-of-global-data)Safe Initialization of Global Data\n```\nuse std::{env, io};\nuse once_cell::sync::OnceCell;\n#[derive(Debug)]\npub struct Logger {\n  // ...\n}\nstatic INSTANCE: OnceCell<Logger> = OnceCell::new();\nimpl Logger {\n  pub fn global() -> &'static Logger {\n    INSTANCE.get().expect(\"logger is not initialized\")\n  }\n  fn from_cli(args: env::Args) -> Result<Logger, std::io::Error> {\n    // ...\n  }\n}\nfn main() {\n  let logger = Logger::from_cli(env::args()).unwrap();\n  INSTANCE.set(logger).unwrap();\n  // use `Logger::global()` from now on\n}\n```\n\n### [\u00a7](https://docs.rs/once_cell/latest/once_cell/#lazy-initialized-global-data)Lazy Initialized Global Data\nThis is essentially the `lazy_static!` macro, but without a macro.\n```\nuse std::{sync::Mutex, collections::HashMap};\nuse once_cell::sync::OnceCell;\nfn global_data() -> &'static Mutex<HashMap<i32, String>> {\n  static INSTANCE: OnceCell<Mutex<HashMap<i32, String>>> = OnceCell::new();\n  INSTANCE.get_or_init(|| {\n    let mut m = HashMap::new();\n    m.insert(13, \"Spica\".to_string());\n    m.insert(74, \"Hoyten\".to_string());\n    Mutex::new(m)\n  })\n}\n```\n\nThere are also the [`sync::Lazy`](https://docs.rs/once_cell/latest/once_cell/sync/struct.Lazy.html) and [`unsync::Lazy`](https://docs.rs/once_cell/latest/once_cell/unsync/struct.Lazy.html) convenience types to streamline this pattern:\n```\nuse std::{sync::Mutex, collections::HashMap};\nuse once_cell::sync::Lazy;\nstatic GLOBAL_DATA: Lazy<Mutex<HashMap<i32, String>>> = Lazy::new(|| {\n  let mut m = HashMap::new();\n  m.insert(13, \"Spica\".to_string());\n  m.insert(74, \"Hoyten\".to_string());\n  Mutex::new(m)\n});\nfn main() {\n  println!(\"{:?}\", GLOBAL_DATA.lock().unwrap());\n}\n```\n\nNote that the variable that holds `Lazy` is declared as `static`, _not_ `const`. This is important: using `const` instead compiles, but works wrong.\n### [\u00a7](https://docs.rs/once_cell/latest/once_cell/#general-purpose-lazy-evaluation)General purpose lazy evaluation\nUnlike `lazy_static!`, `Lazy` works with local variables.\n```\nuse once_cell::unsync::Lazy;\nfn main() {\n  let ctx = vec![1, 2, 3];\n  let thunk = Lazy::new(|| {\n    ctx.iter().sum::<i32>()\n  });\n  assert_eq!(*thunk, 6);\n}\n```\n\nIf you need a lazy field in a struct, you probably should use `OnceCell` directly, because that will allow you to access `self` during initialization.\n```\nuse std::{fs, path::PathBuf};\nuse once_cell::unsync::OnceCell;\nstruct Ctx {\n  config_path: PathBuf,\n  config: OnceCell<String>,\n}\nimpl Ctx {\n  pub fn get_config(&self) -> Result<&str, std::io::Error> {\n    let cfg = self.config.get_or_try_init(|| {\n      fs::read_to_string(&self.config_path)\n    })?;\n    Ok(cfg.as_str())\n  }\n}\n```\n\n### [\u00a7](https://docs.rs/once_cell/latest/once_cell/#lazily-compiled-regex)Lazily Compiled Regex\nThis is a `regex!` macro which takes a string literal and returns an _expression_ that evaluates to a `&'static Regex`:\n```\nmacro_rules! regex {\n  ($re:literal $(,)?) => {{\n    static RE: once_cell::sync::OnceCell<regex::Regex> = once_cell::sync::OnceCell::new();\n    RE.get_or_init(|| regex::Regex::new($re).unwrap())\n  }};\n}\n```\n\nThis macro can be useful to avoid the \u201ccompile regex on every loop iteration\u201d problem.\n### [\u00a7](https://docs.rs/once_cell/latest/once_cell/#runtime-include_bytes)Runtime `include_bytes!`\nThe `include_bytes` macro is useful to include test resources, but it slows down test compilation a lot. An alternative is to load the resources at runtime:\n```\nuse std::path::Path;\nuse once_cell::sync::OnceCell;\npub struct TestResource {\n  path: &'static str,\n  cell: OnceCell<Vec<u8>>,\n}\nimpl TestResource {\n  pub const fn new(path: &'static str) -> TestResource {\n    TestResource { path, cell: OnceCell::new() }\n  }\n  pub fn bytes(&self) -> &[u8] {\n    self.cell.get_or_init(|| {\n      let dir = std::env::var(\"CARGO_MANIFEST_DIR\").unwrap();\n      let path = Path::new(dir.as_str()).join(self.path);\n      std::fs::read(&path).unwrap_or_else(|_err| {\n        panic!(\"failed to load test resource: {}\", path.display())\n      })\n    }).as_slice()\n  }\n}\nstatic TEST_IMAGE: TestResource = TestResource::new(\"test_data/lena.png\");\n#[test]\nfn test_sobel_filter() {\n  let rgb: &[u8] = TEST_IMAGE.bytes();\n  // ...\n}\n```\n\n### [\u00a7](https://docs.rs/once_cell/latest/once_cell/#lateinit)`lateinit`\n`LateInit` type for delayed initialization. It is reminiscent of Kotlin\u2019s `lateinit` keyword and allows construction of cyclic data structures:\n```\nuse once_cell::sync::OnceCell;\npub struct LateInit<T> { cell: OnceCell<T> }\nimpl<T> LateInit<T> {\n  pub fn init(&self, value: T) {\n    assert!(self.cell.set(value).is_ok())\n  }\n}\nimpl<T> Default for LateInit<T> {\n  fn default() -> Self { LateInit { cell: OnceCell::default() } }\n}\nimpl<T> std::ops::Deref for LateInit<T> {\n  type Target = T;\n  fn deref(&self) -> &T {\n    self.cell.get().unwrap()\n  }\n}\n#[derive(Default)]\nstruct A<'a> {\n  b: LateInit<&'a B<'a>>,\n}\n#[derive(Default)]\nstruct B<'a> {\n  a: LateInit<&'a A<'a>>\n}\n\nfn build_cycle() {\n  let a = A::default();\n  let b = B::default();\n  a.b.init(&b);\n  b.a.init(&a);\n  let _a = &a.b.a.b.a;\n}\n```\n\n## [\u00a7](https://docs.rs/once_cell/latest/once_cell/#comparison-with-std)Comparison with std\n`!Sync` types| Access Mode| Drawbacks  \n---|---|---  \n`Cell<T>`| `T`| requires `T: Copy` for `get`  \n`RefCell<T>`| `RefMut<T>` / `Ref<T>`| may panic at runtime  \n`unsync::OnceCell<T>`| `&T`| assignable only once  \n`Sync` types| Access Mode| Drawbacks  \n---|---|---  \n`AtomicT`| `T`| works only with certain `Copy` types  \n`Mutex<T>`| `MutexGuard<T>`| may deadlock at runtime, may block the thread  \n`sync::OnceCell<T>`| `&T`| assignable only once, may block the thread  \nTechnically, calling `get_or_init` will also cause a panic or a deadlock if it recursively calls itself. However, because the assignment can happen only once, such cases should be more rare than equivalents with `RefCell` and `Mutex`.\n## [\u00a7](https://docs.rs/once_cell/latest/once_cell/#minimum-supported-rustc-version)Minimum Supported `rustc` Version\nIf only the `std`, `alloc`, or `race` features are enabled, MSRV will be updated conservatively, supporting at least latest 8 versions of the compiler. When using other features, like `parking_lot`, MSRV might be updated more frequently, up to the latest stable. In both cases, increasing MSRV is _not_ considered a semver-breaking change and requires only a minor version bump.\n## [\u00a7](https://docs.rs/once_cell/latest/once_cell/#implementation-details)Implementation details\nThe implementation is based on the [`lazy_static`](https://github.com/rust-lang-nursery/lazy-static.rs/) and [`lazy_cell`](https://github.com/indiv0/lazycell/) crates and [`std::sync::Once`](https://doc.rust-lang.org/std/sync/struct.Once.html). In some sense, `once_cell` just streamlines and unifies those APIs.\nTo implement a sync flavor of `OnceCell`, this crates uses either a custom re-implementation of `std::sync::Once` or `parking_lot::Mutex`. This is controlled by the `parking_lot` feature (disabled by default). Performance is the same for both cases, but the `parking_lot` based `OnceCell<T>` is smaller by up to 16 bytes.\nThis crate uses `unsafe`.\n## [\u00a7](https://docs.rs/once_cell/latest/once_cell/#faq)F.A.Q.\n**Should I use the sync or unsync flavor?**\nBecause Rust compiler checks thread safety for you, it\u2019s impossible to accidentally use `unsync` where `sync` is required. So, use `unsync` in single-threaded code and `sync` in multi-threaded. It\u2019s easy to switch between the two if code becomes multi-threaded later.\nAt the moment, `unsync` has an additional benefit that reentrant initialization causes a panic, which might be easier to debug than a deadlock.\n**Does this crate support async?**\nNo, but you can use [`async_once_cell`](https://crates.io/crates/async_once_cell) instead.\n**Does this crate support`no_std`?**\nYes, but with caveats. `OnceCell` is a synchronization primitive which _semantically_ relies on blocking. `OnceCell` guarantees that at most one `f` will be called to compute the value. If two threads of execution call `get_or_init` concurrently, one of them has to wait.\nWaiting fundamentally requires OS support. Execution environment needs to understand who waits on whom to prevent deadlocks due to priority inversion. You _could_ make code to compile by blindly using pure spinlocks, but the runtime behavior would be subtly wrong.\nGiven these constraints, `once_cell` provides the following options:\n  * The `race` module provides similar, but distinct synchronization primitive which is compatible with `no_std`. With `race`, the `f` function can be called multiple times by different threads, but only one thread will win to install the value.\n  * `critical-section` feature (with a `-`, not `_`) uses `critical_section` to implement blocking.\n\n\n**Can I bring my own mutex?**\nThere is [generic_once_cell](https://crates.io/crates/generic_once_cell) to allow just that.\n**Should I use`std::cell::OnceCell` , `once_cell`, or `lazy_static`?**\nIf you can use `std` version (your MSRV is at least 1.70, and you don\u2019t need extra features `once_cell` provides), use `std`. Otherwise, use `once_cell`. Don\u2019t use `lazy_static`.\n## [\u00a7](https://docs.rs/once_cell/latest/once_cell/#related-crates)Related crates\n  * Most of this crate\u2019s functionality is available in `std` starting with Rust 1.70. See `std::cell::OnceCell` and `std::sync::OnceLock`.\n  * [double-checked-cell](https://github.com/niklasf/double-checked-cell)\n  * [lazy-init](https://crates.io/crates/lazy-init)\n  * [lazycell](https://crates.io/crates/lazycell)\n  * [mitochondria](https://crates.io/crates/mitochondria)\n  * [lazy_static](https://crates.io/crates/lazy_static)\n  * [async_once_cell](https://crates.io/crates/async_once_cell)\n  * [generic_once_cell](https://crates.io/crates/generic_once_cell) (bring your own mutex)\n\n\n## Modules[\u00a7](https://docs.rs/once_cell/latest/once_cell/#modules)\n\n[race](https://docs.rs/once_cell/latest/once_cell/race/index.html \"mod once_cell::race\")\n    Thread-safe, non-blocking, \u201cfirst one wins\u201d flavor of `OnceCell`.\n\n[sync](https://docs.rs/once_cell/latest/once_cell/sync/index.html \"mod once_cell::sync\")\n    Thread-safe, blocking version of `OnceCell`.\n\n[unsync](https://docs.rs/once_cell/latest/once_cell/unsync/index.html \"mod once_cell::unsync\")\n    Single-threaded version of `OnceCell`.\n",
            "markdown_with_citations": "[](https://docs.rs/once_cell/latest/once_cell/all.html \"show sidebar\")\n# Crate once_cellCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\n## \u00a7\u27e84\u27e9Overview\n`once_cell` provides two new cell-like types, `unsync::OnceCell`\u27e85\u27e9 and `sync::OnceCell`\u27e86\u27e9. A `OnceCell` might store arbitrary non-`Copy` types, can be assigned to at most once and provides direct access to the stored contents. The core API looks _roughly_ like this (and there\u2019s much more inside, read on!):\n\u24d8\u27e87\u27e9```\nimpl<T> OnceCell<T> {\n  const fn new() -> OnceCell<T> { ... }\n  fn set(&self, value: T) -> Result<(), T> { ... }\n  fn get(&self) -> Option<&T> { ... }\n}\n```\n\nNote that, like with `RefCell`\u27e88\u27e9 and `Mutex`\u27e89\u27e9, the `set` method requires only a shared reference. Because of the single assignment restriction `get` can return a `&T` instead of `Ref<T>` or `MutexGuard<T>`.\nThe `sync` flavor is thread-safe (that is, implements the `Sync`\u27e810\u27e9 trait), while the `unsync` one is not.\n## \u00a7\u27e811\u27e9Recipes\n`OnceCell` might be useful for a variety of patterns.\n### \u00a7\u27e812\u27e9Safe Initialization of Global Data\n```\nuse std::{env, io};\nuse once_cell::sync::OnceCell;\n#[derive(Debug)]\npub struct Logger {\n  // ...\n}\nstatic INSTANCE: OnceCell<Logger> = OnceCell::new();\nimpl Logger {\n  pub fn global() -> &'static Logger {\n    INSTANCE.get().expect(\"logger is not initialized\")\n  }\n  fn from_cli(args: env::Args) -> Result<Logger, std::io::Error> {\n    // ...\n  }\n}\nfn main() {\n  let logger = Logger::from_cli(env::args()).unwrap();\n  INSTANCE.set(logger).unwrap();\n  // use `Logger::global()` from now on\n}\n```\n\n### \u00a7\u27e813\u27e9Lazy Initialized Global Data\nThis is essentially the `lazy_static!` macro, but without a macro.\n```\nuse std::{sync::Mutex, collections::HashMap};\nuse once_cell::sync::OnceCell;\nfn global_data() -> &'static Mutex<HashMap<i32, String>> {\n  static INSTANCE: OnceCell<Mutex<HashMap<i32, String>>> = OnceCell::new();\n  INSTANCE.get_or_init(|| {\n    let mut m = HashMap::new();\n    m.insert(13, \"Spica\".to_string());\n    m.insert(74, \"Hoyten\".to_string());\n    Mutex::new(m)\n  })\n}\n```\n\nThere are also the `sync::Lazy`\u27e814\u27e9 and `unsync::Lazy`\u27e815\u27e9 convenience types to streamline this pattern:\n```\nuse std::{sync::Mutex, collections::HashMap};\nuse once_cell::sync::Lazy;\nstatic GLOBAL_DATA: Lazy<Mutex<HashMap<i32, String>>> = Lazy::new(|| {\n  let mut m = HashMap::new();\n  m.insert(13, \"Spica\".to_string());\n  m.insert(74, \"Hoyten\".to_string());\n  Mutex::new(m)\n});\nfn main() {\n  println!(\"{:?}\", GLOBAL_DATA.lock().unwrap());\n}\n```\n\nNote that the variable that holds `Lazy` is declared as `static`, _not_ `const`. This is important: using `const` instead compiles, but works wrong.\n### \u00a7\u27e816\u27e9General purpose lazy evaluation\nUnlike `lazy_static!`, `Lazy` works with local variables.\n```\nuse once_cell::unsync::Lazy;\nfn main() {\n  let ctx = vec![1, 2, 3];\n  let thunk = Lazy::new(|| {\n    ctx.iter().sum::<i32>()\n  });\n  assert_eq!(*thunk, 6);\n}\n```\n\nIf you need a lazy field in a struct, you probably should use `OnceCell` directly, because that will allow you to access `self` during initialization.\n```\nuse std::{fs, path::PathBuf};\nuse once_cell::unsync::OnceCell;\nstruct Ctx {\n  config_path: PathBuf,\n  config: OnceCell<String>,\n}\nimpl Ctx {\n  pub fn get_config(&self) -> Result<&str, std::io::Error> {\n    let cfg = self.config.get_or_try_init(|| {\n      fs::read_to_string(&self.config_path)\n    })?;\n    Ok(cfg.as_str())\n  }\n}\n```\n\n### \u00a7\u27e817\u27e9Lazily Compiled Regex\nThis is a `regex!` macro which takes a string literal and returns an _expression_ that evaluates to a `&'static Regex`:\n```\nmacro_rules! regex {\n  ($re:literal $(,)?) => {{\n    static RE: once_cell::sync::OnceCell<regex::Regex> = once_cell::sync::OnceCell::new();\n    RE.get_or_init(|| regex::Regex::new($re).unwrap())\n  }};\n}\n```\n\nThis macro can be useful to avoid the \u201ccompile regex on every loop iteration\u201d problem.\n### \u00a7\u27e818\u27e9Runtime `include_bytes!`\nThe `include_bytes` macro is useful to include test resources, but it slows down test compilation a lot. An alternative is to load the resources at runtime:\n```\nuse std::path::Path;\nuse once_cell::sync::OnceCell;\npub struct TestResource {\n  path: &'static str,\n  cell: OnceCell<Vec<u8>>,\n}\nimpl TestResource {\n  pub const fn new(path: &'static str) -> TestResource {\n    TestResource { path, cell: OnceCell::new() }\n  }\n  pub fn bytes(&self) -> &[u8] {\n    self.cell.get_or_init(|| {\n      let dir = std::env::var(\"CARGO_MANIFEST_DIR\").unwrap();\n      let path = Path::new(dir.as_str()).join(self.path);\n      std::fs::read(&path).unwrap_or_else(|_err| {\n        panic!(\"failed to load test resource: {}\", path.display())\n      })\n    }).as_slice()\n  }\n}\nstatic TEST_IMAGE: TestResource = TestResource::new(\"test_data/lena.png\");\n#[test]\nfn test_sobel_filter() {\n  let rgb: &[u8] = TEST_IMAGE.bytes();\n  // ...\n}\n```\n\n### \u00a7\u27e819\u27e9`lateinit`\n`LateInit` type for delayed initialization. It is reminiscent of Kotlin\u2019s `lateinit` keyword and allows construction of cyclic data structures:\n```\nuse once_cell::sync::OnceCell;\npub struct LateInit<T> { cell: OnceCell<T> }\nimpl<T> LateInit<T> {\n  pub fn init(&self, value: T) {\n    assert!(self.cell.set(value).is_ok())\n  }\n}\nimpl<T> Default for LateInit<T> {\n  fn default() -> Self { LateInit { cell: OnceCell::default() } }\n}\nimpl<T> std::ops::Deref for LateInit<T> {\n  type Target = T;\n  fn deref(&self) -> &T {\n    self.cell.get().unwrap()\n  }\n}\n#[derive(Default)]\nstruct A<'a> {\n  b: LateInit<&'a B<'a>>,\n}\n#[derive(Default)]\nstruct B<'a> {\n  a: LateInit<&'a A<'a>>\n}\n\nfn build_cycle() {\n  let a = A::default();\n  let b = B::default();\n  a.b.init(&b);\n  b.a.init(&a);\n  let _a = &a.b.a.b.a;\n}\n```\n\n## \u00a7\u27e820\u27e9Comparison with std\n`!Sync` types| Access Mode| Drawbacks  \n---|---|---  \n`Cell<T>`| `T`| requires `T: Copy` for `get`  \n`RefCell<T>`| `RefMut<T>` / `Ref<T>`| may panic at runtime  \n`unsync::OnceCell<T>`| `&T`| assignable only once  \n`Sync` types| Access Mode| Drawbacks  \n---|---|---  \n`AtomicT`| `T`| works only with certain `Copy` types  \n`Mutex<T>`| `MutexGuard<T>`| may deadlock at runtime, may block the thread  \n`sync::OnceCell<T>`| `&T`| assignable only once, may block the thread  \nTechnically, calling `get_or_init` will also cause a panic or a deadlock if it recursively calls itself. However, because the assignment can happen only once, such cases should be more rare than equivalents with `RefCell` and `Mutex`.\n## \u00a7\u27e821\u27e9Minimum Supported `rustc` Version\nIf only the `std`, `alloc`, or `race` features are enabled, MSRV will be updated conservatively, supporting at least latest 8 versions of the compiler. When using other features, like `parking_lot`, MSRV might be updated more frequently, up to the latest stable. In both cases, increasing MSRV is _not_ considered a semver-breaking change and requires only a minor version bump.\n## \u00a7\u27e822\u27e9Implementation details\nThe implementation is based on the `lazy_static`\u27e823\u27e9 and `lazy_cell`\u27e824\u27e9 crates and `std::sync::Once`\u27e825\u27e9. In some sense, `once_cell` just streamlines and unifies those APIs.\nTo implement a sync flavor of `OnceCell`, this crates uses either a custom re-implementation of `std::sync::Once` or `parking_lot::Mutex`. This is controlled by the `parking_lot` feature (disabled by default). Performance is the same for both cases, but the `parking_lot` based `OnceCell<T>` is smaller by up to 16 bytes.\nThis crate uses `unsafe`.\n## \u00a7\u27e826\u27e9F.A.Q.\n**Should I use the sync or unsync flavor?**\nBecause Rust compiler checks thread safety for you, it\u2019s impossible to accidentally use `unsync` where `sync` is required. So, use `unsync` in single-threaded code and `sync` in multi-threaded. It\u2019s easy to switch between the two if code becomes multi-threaded later.\nAt the moment, `unsync` has an additional benefit that reentrant initialization causes a panic, which might be easier to debug than a deadlock.\n**Does this crate support async?**\nNo, but you can use `async_once_cell`\u27e827\u27e9 instead.\n**Does this crate support`no_std`?**\nYes, but with caveats. `OnceCell` is a synchronization primitive which _semantically_ relies on blocking. `OnceCell` guarantees that at most one `f` will be called to compute the value. If two threads of execution call `get_or_init` concurrently, one of them has to wait.\nWaiting fundamentally requires OS support. Execution environment needs to understand who waits on whom to prevent deadlocks due to priority inversion. You _could_ make code to compile by blindly using pure spinlocks, but the runtime behavior would be subtly wrong.\nGiven these constraints, `once_cell` provides the following options:\n  * The `race` module provides similar, but distinct synchronization primitive which is compatible with `no_std`. With `race`, the `f` function can be called multiple times by different threads, but only one thread will win to install the value.\n  * `critical-section` feature (with a `-`, not `_`) uses `critical_section` to implement blocking.\n\n\n**Can I bring my own mutex?**\nThere is generic_once_cell\u27e828\u27e9 to allow just that.\n**Should I use`std::cell::OnceCell` , `once_cell`, or `lazy_static`?**\nIf you can use `std` version (your MSRV is at least 1.70, and you don\u2019t need extra features `once_cell` provides), use `std`. Otherwise, use `once_cell`. Don\u2019t use `lazy_static`.\n## \u00a7\u27e829\u27e9Related crates\n  * Most of this crate\u2019s functionality is available in `std` starting with Rust 1.70. See `std::cell::OnceCell` and `std::sync::OnceLock`.\n  * double-checked-cell\u27e830\u27e9\n  * lazy-init\u27e831\u27e9\n  * lazycell\u27e832\u27e9\n  * mitochondria\u27e833\u27e9\n  * lazy_static\u27e834\u27e9\n  * async_once_cell\u27e827\u27e9\n  * generic_once_cell\u27e828\u27e9 (bring your own mutex)\n\n\n## Modules\u00a7\u27e835\u27e9\n\nrace\u27e836\u27e9\n    Thread-safe, non-blocking, \u201cfirst one wins\u201d flavor of `OnceCell`.\n\nsync\u27e837\u27e9\n    Thread-safe, blocking version of `OnceCell`.\n\nunsync\u27e838\u27e9\n    Single-threaded version of `OnceCell`.\n",
            "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/once_cell/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/once_cell/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/once_cell/latest/src/once_cell/lib.rs.html#1-1412: Source\n\u27e84\u27e9 https://docs.rs/once_cell/latest/once_cell/#overview: \u00a7\n\u27e85\u27e9 https://docs.rs/once_cell/latest/once_cell/unsync/struct.OnceCell.html: `unsync::OnceCell`\n\u27e86\u27e9 https://docs.rs/once_cell/latest/once_cell/sync/struct.OnceCell.html: `sync::OnceCell`\n\u27e87\u27e9 https://docs.rs/once_cell/latest/once_cell/: This example is not tested - \u24d8\n\u27e88\u27e9 https://doc.rust-lang.org/std/cell/struct.RefCell.html: `RefCell`\n\u27e89\u27e9 https://doc.rust-lang.org/std/sync/struct.Mutex.html: `Mutex`\n\u27e810\u27e9 https://doc.rust-lang.org/std/marker/trait.Sync.html: `Sync`\n\u27e811\u27e9 https://docs.rs/once_cell/latest/once_cell/#recipes: \u00a7\n\u27e812\u27e9 https://docs.rs/once_cell/latest/once_cell/#safe-initialization-of-global-data: \u00a7\n\u27e813\u27e9 https://docs.rs/once_cell/latest/once_cell/#lazy-initialized-global-data: \u00a7\n\u27e814\u27e9 https://docs.rs/once_cell/latest/once_cell/sync/struct.Lazy.html: `sync::Lazy`\n\u27e815\u27e9 https://docs.rs/once_cell/latest/once_cell/unsync/struct.Lazy.html: `unsync::Lazy`\n\u27e816\u27e9 https://docs.rs/once_cell/latest/once_cell/#general-purpose-lazy-evaluation: \u00a7\n\u27e817\u27e9 https://docs.rs/once_cell/latest/once_cell/#lazily-compiled-regex: \u00a7\n\u27e818\u27e9 https://docs.rs/once_cell/latest/once_cell/#runtime-include_bytes: \u00a7\n\u27e819\u27e9 https://docs.rs/once_cell/latest/once_cell/#lateinit: \u00a7\n\u27e820\u27e9 https://docs.rs/once_cell/latest/once_cell/#comparison-with-std: \u00a7\n\u27e821\u27e9 https://docs.rs/once_cell/latest/once_cell/#minimum-supported-rustc-version: \u00a7\n\u27e822\u27e9 https://docs.rs/once_cell/latest/once_cell/#implementation-details: \u00a7\n\u27e823\u27e9 https://github.com/rust-lang-nursery/lazy-static.rs/: `lazy_static`\n\u27e824\u27e9 https://github.com/indiv0/lazycell/: `lazy_cell`\n\u27e825\u27e9 https://doc.rust-lang.org/std/sync/struct.Once.html: `std::sync::Once`\n\u27e826\u27e9 https://docs.rs/once_cell/latest/once_cell/#faq: \u00a7\n\u27e827\u27e9 https://crates.io/crates/async_once_cell: `async_once_cell`\n\u27e828\u27e9 https://crates.io/crates/generic_once_cell: generic_once_cell\n\u27e829\u27e9 https://docs.rs/once_cell/latest/once_cell/#related-crates: \u00a7\n\u27e830\u27e9 https://github.com/niklasf/double-checked-cell: double-checked-cell\n\u27e831\u27e9 https://crates.io/crates/lazy-init: lazy-init\n\u27e832\u27e9 https://crates.io/crates/lazycell: lazycell\n\u27e833\u27e9 https://crates.io/crates/mitochondria: mitochondria\n\u27e834\u27e9 https://crates.io/crates/lazy_static: lazy_static\n\u27e835\u27e9 https://docs.rs/once_cell/latest/once_cell/#modules: \u00a7\n\u27e836\u27e9 https://docs.rs/once_cell/latest/once_cell/race/index.html: mod once_cell::race - race\n\u27e837\u27e9 https://docs.rs/once_cell/latest/once_cell/sync/index.html: mod once_cell::sync - sync\n\u27e838\u27e9 https://docs.rs/once_cell/latest/once_cell/unsync/index.html: mod once_cell::unsync - unsync\n",
            "fit_markdown": "",
            "fit_html": ""
          },
          "downloads": 0,
          "github_stars": 0,
          "dependencies": [],
          "features": {},
          "code_snippets": [],
          "readme_sections": {},
          "librs_downloads": null,
          "source": "crates.io",
          "enhanced_scraping": {},
          "enhanced_features": [],
          "enhanced_dependencies": [],
          "readme_summary": "The `once_cell` crate provides `OnceCell` and `Lazy` types for safe, single-assignment or lazy initialization of data, supporting both thread-safe (`sync`) and non-thread-safe (`unsync`) variants. It enables patterns like global or lazy-initialized data, lazy evaluation for local variables, and cyclic data structures (`LateInit`). Additionally, it offers utilities for efficient runtime initialization, such as lazily compiled regex and runtime alternatives to `include_bytes!`.",
          "feature_summary": null,
          "use_case": "Utilities",
          "score": 9.0,
          "factual_counterfactual": "### Pair 1: Thread Safety and Sync/Unsync Variants\n\u2705 Factual: The `once_cell` crate provides two variants of `OnceCell`: `sync::OnceCell`, which is thread-safe and implements the `Sync` trait, and `unsync::OnceCell`, which is not thread-safe and is intended for single-threaded contexts.  \n\u274c Counterfactual: Both `sync::OnceCell` and `unsync::OnceCell` are thread-safe, but `unsync::OnceCell` has better performance in multi-threaded environments due to reduced locking overhead.\n\n---\n\n### Pair 2: Lazy Initialization\n\u2705 Factual: The `sync::Lazy` type in `once_cell` allows for lazy initialization of global data without requiring a macro, making it a lightweight alternative to the `lazy_static!` macro.  \n\u274c Counterfactual: The `sync::Lazy` type in `once_cell` requires the use of macros for lazy initialization, similar to `lazy_static!`.\n\n---\n\n### Pair 3: Single Assignment Restriction\n\u2705 Factual: The `OnceCell` type enforces a single assignment rule, meaning a value can only be set once, and subsequent attempts to set a value will result in an error.  \n\u274c Counterfactual: The `OnceCell` type allows multiple assignments, but overwrites the previous value without returning an error.",
          "source_analysis": null,
          "user_behavior": null,
          "security": null
        }
      },
      "irl_score": 8.6,
      "execution_id": "exec-d452418b-793cee25-1751260641",
      "timestamp": "2025-06-30T05:17:21.719512+00:00",
      "canon_version": "1.3.0"
    },
    "rule_zero_compliant": true
  }
]