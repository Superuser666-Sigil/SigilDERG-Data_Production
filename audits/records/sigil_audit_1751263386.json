[
  {
    "execution_id": "exec-a0ba73e0-388fb624-1751263373",
    "timestamp": "2025-06-30T06:02:53.349081+00:00",
    "sacred_chain": {
      "input_data": "rmp",
      "context_sources": [
        "crates.io",
        "github.com",
        "lib.rs",
        "docs.rs"
      ],
      "reasoning_steps": [
        "Input canonicalized: 'rmp' -> 'rmp'",
        "Context gathered from 4 validated sources",
        "Metadata extracted: 4 fields",
        "Documentation analyzed: quality 7.0",
        "Sentiment analyzed: positive",
        "Ecosystem analyzed: utilities",
        "Quality score synthesized: 7.50",
        "Trust decision: DEFER - Insufficient data for decision",
        "IRL confidence: 8.600"
      ],
      "suggestion": "ALLOW: Positive community sentiment",
      "verdict": "DEFER",
      "audit_info": {
        "metadata": {
          "name": "rmp",
          "type": "rust_crate",
          "source": "manual_input",
          "extraction_method": "irl_engine"
        },
        "sentiment": {
          "quality_score": 7.0,
          "completeness": 0.8,
          "examples_present": true,
          "api_documented": true
        },
        "ecosystem": {
          "overall": "positive",
          "positive_mentions": 10,
          "negative_mentions": 2,
          "neutral_mentions": 5,
          "total_mentions": 17
        },
        "quality_score": 7.5,
        "verdict_reason": "Insufficient data for decision",
        "sanitized_documentation": {
          "crates_io": {
            "url": "https://crates.io/crates/rmp",
            "title": "rmp v0.8.14",
            "content": {
              "raw_markdown": "#  rmp v0.8.14\nPure Rust MessagePack serialization implementation \n  * [ #messagepack ](https://crates.io/keywords/messagepack)\n  * [ #msgpack ](https://crates.io/keywords/msgpack)\n\n\n  * [ Readme ](https://crates.io/crates/rmp)\n  * [ 33 Versions ](https://crates.io/crates/rmp/versions)\n  * [ Dependencies ](https://crates.io/crates/rmp/dependencies)\n  * [ Dependents ](https://crates.io/crates/rmp/reverse_dependencies)\n\n\n## Metadata\nabout 1 year ago \n2021 edition \n[ MIT ](https://choosealicense.com/licenses/mit)\n29 KiB \n## Install\nRun the following Cargo command in your project directory:\ncargo add rmp\nOr add the following line to your Cargo.toml:\nrmp = \"0.8.14\"\n## Documentation\n[ docs.rs/rmp ](https://docs.rs/rmp)\n## Repository\n[ github.com/3Hren/msgpack-rust ](https://github.com/3Hren/msgpack-rust)\n## Owners\n## Categories\n  * [Encoding](https://crates.io/categories/encoding)\n\n\n[ Report crate ](https://crates.io/support?crate=rmp&inquire=crate-violation)\n### Stats Overview\n50,991,419 Downloads all time\n33 Versions published\n#### Downloads over the last 90 days\nDisplay as \nStacked \n  * Stacked \n  * Unstacked \n\n\nLoading\u2026\n",
              "markdown_with_citations": "#  rmp v0.8.14\nPure Rust MessagePack serialization implementation \n  *  #messagepack \u27e81\u27e9\n  *  #msgpack \u27e82\u27e9\n\n\n  *  Readme \u27e83\u27e9\n  *  33 Versions \u27e84\u27e9\n  *  Dependencies \u27e85\u27e9\n  *  Dependents \u27e86\u27e9\n\n\n## Metadata\nabout 1 year ago \n2021 edition \n MIT \u27e87\u27e9\n29 KiB \n## Install\nRun the following Cargo command in your project directory:\ncargo add rmp\nOr add the following line to your Cargo.toml:\nrmp = \"0.8.14\"\n## Documentation\n docs.rs/rmp \u27e88\u27e9\n## Repository\n github.com/3Hren/msgpack-rust \u27e89\u27e9\n## Owners\n## Categories\n  * Encoding\u27e810\u27e9\n\n\n Report crate \u27e811\u27e9\n### Stats Overview\n50,991,419 Downloads all time\n33 Versions published\n#### Downloads over the last 90 days\nDisplay as \nStacked \n  * Stacked \n  * Unstacked \n\n\nLoading\u2026\n",
              "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://crates.io/keywords/messagepack:  #messagepack \n\u27e82\u27e9 https://crates.io/keywords/msgpack:  #msgpack \n\u27e83\u27e9 https://crates.io/crates/rmp:  Readme \n\u27e84\u27e9 https://crates.io/crates/rmp/versions:  33 Versions \n\u27e85\u27e9 https://crates.io/crates/rmp/dependencies:  Dependencies \n\u27e86\u27e9 https://crates.io/crates/rmp/reverse_dependencies:  Dependents \n\u27e87\u27e9 https://choosealicense.com/licenses/mit:  MIT \n\u27e88\u27e9 https://docs.rs/rmp:  docs.rs/rmp \n\u27e89\u27e9 https://github.com/3Hren/msgpack-rust:  github.com/3Hren/msgpack-rust \n\u27e810\u27e9 https://crates.io/categories/encoding: Encoding\n\u27e811\u27e9 https://crates.io/support?crate=rmp&inquire=crate-violation:  Report crate \n",
              "fit_markdown": "",
              "fit_html": ""
            },
            "structured_data": {},
            "quality_score": 3.0,
            "extraction_method": "crawl4ai",
            "error": null,
            "metadata": {
              "doc_type": "docs",
              "content_length": 1136,
              "has_structured_data": false,
              "crawl_success": true
            },
            "timestamp": "117163.3096313"
          },
          "docs_rs": {
            "url": "https://docs.rs/rmp",
            "title": "Crate rmpCopy item path",
            "content": {
              "raw_markdown": "[](https://docs.rs/rmp/latest/rmp/all.html \"show sidebar\")\n# Crate rmpCopy item path\n[Settings](https://docs.rs/rmp/latest/settings.html)\n[Help](https://docs.rs/rmp/latest/help.html)\nSummary[Source](https://docs.rs/rmp/latest/src/rmp/lib.rs.html#1-14)\nExpand description\n### [\u00a7](https://docs.rs/rmp/latest/rmp/#the-rust-messagepack-library)The Rust MessagePack Library\nRMP is a pure Rust [MessagePack](http://msgpack.org) implementation of an efficient binary serialization format. This crate provides low-level core functionality, writers and readers for primitive values with direct mapping between binary MessagePack format.\n[Looking for Serde support](https://lib.rs/crates/rmp-serde)?\nThis crate represents the very basic functionality needed to work with MessagePack format. Ideologically it is developed as a basis for building high-level abstractions.\n#### [\u00a7](https://docs.rs/rmp/latest/rmp/#usage)Usage\nTo use `rmp`, first add this to your `Cargo.toml`:\n```\n[dependencies.rmp]\nrmp = \"0.8\"\n```\n\n#### [\u00a7](https://docs.rs/rmp/latest/rmp/#features)Features\n  * **Low-level API**\nRMP is designed to be lightweight and straightforward. There are low-level APIs, which give you full control over the encoding/decoding process. `no-std` environments are supported.\n  * **Zero-copy value decoding**\nRMP allows to decode bytes from a buffer in a zero-copy manner, without any heap allocations. easily and blazingly fast. Rust static checks guarantee that the data will be valid until buffer lives.\n  * **Clear error handling**\nRMP\u2019s error system guarantees that you never receive an error enum with unreachable variant.\n  * **Robust and tested**\nThis project is developed using TDD and CI, so any found bugs will be fixed without breaking existing functionality.\n\n\n#### [\u00a7](https://docs.rs/rmp/latest/rmp/#detailed)Detailed\nCurrently there are two large modules: encode and decode. More detail you can find in the corresponding sections.\nFormally every MessagePack message consists of some marker encapsulating a data type and the data itself. Sometimes there are no separate data chunk, for example for booleans. In these cases a marker contains the value. For example, the `true` value is encoded as `0xc3`.\n```\nlet mut buf = Vec::new();\nrmp::encode::write_bool(&mut buf, true).unwrap();\nassert_eq!([0xc3], buf[..]);\n```\n\nSometimes a single value can be encoded in multiple ways. For example a value of `42` can be represented as: `[0x2a], [0xcc, 0x2a], [0xcd, 0x00, 0x2a]` and so on, and all of them are considered as valid representations. To allow fine-grained control over encoding such values the library provides direct mapping functions.\n```\nlet mut bufs = vec![vec![]; 5];\nrmp::encode::write_pfix(&mut bufs[0], 42).unwrap();\nrmp::encode::write_u8(&mut bufs[1], 42).unwrap();\nrmp::encode::write_u16(&mut bufs[2], 42).unwrap();\nrmp::encode::write_u32(&mut bufs[3], 42).unwrap();\nrmp::encode::write_u64(&mut bufs[4], 42).unwrap();\nassert_eq!([0x2a], bufs[0][..]);\nassert_eq!([0xcc, 0x2a], bufs[1][..]);\nassert_eq!([0xcd, 0x00, 0x2a], bufs[2][..]);\nassert_eq!([0xce, 0x00, 0x00, 0x00, 0x2a], bufs[3][..]);\nassert_eq!([0xcf, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2a], bufs[4][..]);\n```\n\nBut they aren\u2019t planned to be widely used. Instead we often need to encode bytes compactly to save space. In these cases RMP provides functions that guarantee that for encoding the most compact representation will be chosen.\n```\nlet mut buf = Vec::new();\nrmp::encode::write_sint(&mut buf, 300).unwrap();\nassert_eq!([0xcd, 0x1, 0x2c], buf[..]);\n```\n\nOn the other hand for deserialization it is not matter in which representation the value is encoded - RMP deals with all of them.\nSometimes you know the exact type representation and want to enforce the deserialization process to make it strongly type safe.\n```\nlet buf = [0xcd, 0x1, 0x2c];\nassert_eq!(300, rmp::decode::read_u16(&mut &buf[..]).unwrap());\n```\n\nHowever if you try to decode such bytearray as other integer type, for example `u32`, there will be type mismatch error.\n```\nlet buf = [0xcd, 0x1, 0x2c];\nrmp::decode::read_u32(&mut &buf[..]).err().unwrap();\n```\n\nBut sometimes all you want is just to encode an integer that _must_ fit in the specified type no matter how it was encoded. RMP provides [`such`](https://docs.rs/rmp/latest/rmp/decode/fn.read_int.html) function to ease integration with other MessagePack libraries.\n```\nlet buf = [0xcd, 0x1, 0x2c];\nassert_eq!(300i16, rmp::decode::read_int(&mut &buf[..]).unwrap());\nassert_eq!(300i32, rmp::decode::read_int(&mut &buf[..]).unwrap());\nassert_eq!(300i64, rmp::decode::read_int(&mut &buf[..]).unwrap());\nassert_eq!(300u16, rmp::decode::read_int(&mut &buf[..]).unwrap());\nassert_eq!(300u32, rmp::decode::read_int(&mut &buf[..]).unwrap());\nassert_eq!(300u64, rmp::decode::read_int(&mut &buf[..]).unwrap());\n```\n\n#### [\u00a7](https://docs.rs/rmp/latest/rmp/#api)API\nAlmost all API are represented as pure functions, which accepts a generic `Write` or `Read` and the value to be encoded/decoded. For example let\u2019s do a round trip for \u03c0 number.\n```\nlet pi = std::f64::consts::PI;\nlet mut buf = Vec::new();\nrmp::encode::write_f64(&mut buf, pi).unwrap();\nassert_eq!([0xcb, 0x40, 0x9, 0x21, 0xfb, 0x54, 0x44, 0x2d, 0x18], buf[..]);\nassert_eq!(pi, rmp::decode::read_f64(&mut &buf[..]).unwrap());\n```\n\nLicense: MIT\n## Modules[\u00a7](https://docs.rs/rmp/latest/rmp/#modules)\n\n[decode](https://docs.rs/rmp/latest/rmp/decode/index.html \"mod rmp::decode\")\n    Provides various functions and structs for MessagePack decoding.\n\n[encode](https://docs.rs/rmp/latest/rmp/encode/index.html \"mod rmp::encode\")\n    Provides various functions and structs for MessagePack encoding.\n## Enums[\u00a7](https://docs.rs/rmp/latest/rmp/#enums)\n\n[Marker](https://docs.rs/rmp/latest/rmp/enum.Marker.html \"enum rmp::Marker\")\n    Format markers.\n## Constants[\u00a7](https://docs.rs/rmp/latest/rmp/#constants)\n\n[MSGPACK_VERSION](https://docs.rs/rmp/latest/rmp/constant.MSGPACK_VERSION.html \"constant rmp::MSGPACK_VERSION\")\n    Version of the MessagePack [spec](http://github.com/msgpack/msgpack/blob/master/spec.md).\n",
              "markdown_with_citations": "[](https://docs.rs/rmp/latest/rmp/all.html \"show sidebar\")\n# Crate rmpCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\n### \u00a7\u27e84\u27e9The Rust MessagePack Library\nRMP is a pure Rust MessagePack\u27e85\u27e9 implementation of an efficient binary serialization format. This crate provides low-level core functionality, writers and readers for primitive values with direct mapping between binary MessagePack format.\nLooking for Serde support\u27e86\u27e9?\nThis crate represents the very basic functionality needed to work with MessagePack format. Ideologically it is developed as a basis for building high-level abstractions.\n#### \u00a7\u27e87\u27e9Usage\nTo use `rmp`, first add this to your `Cargo.toml`:\n```\n[dependencies.rmp]\nrmp = \"0.8\"\n```\n\n#### \u00a7\u27e88\u27e9Features\n  * **Low-level API**\nRMP is designed to be lightweight and straightforward. There are low-level APIs, which give you full control over the encoding/decoding process. `no-std` environments are supported.\n  * **Zero-copy value decoding**\nRMP allows to decode bytes from a buffer in a zero-copy manner, without any heap allocations. easily and blazingly fast. Rust static checks guarantee that the data will be valid until buffer lives.\n  * **Clear error handling**\nRMP\u2019s error system guarantees that you never receive an error enum with unreachable variant.\n  * **Robust and tested**\nThis project is developed using TDD and CI, so any found bugs will be fixed without breaking existing functionality.\n\n\n#### \u00a7\u27e89\u27e9Detailed\nCurrently there are two large modules: encode and decode. More detail you can find in the corresponding sections.\nFormally every MessagePack message consists of some marker encapsulating a data type and the data itself. Sometimes there are no separate data chunk, for example for booleans. In these cases a marker contains the value. For example, the `true` value is encoded as `0xc3`.\n```\nlet mut buf = Vec::new();\nrmp::encode::write_bool(&mut buf, true).unwrap();\nassert_eq!([0xc3], buf[..]);\n```\n\nSometimes a single value can be encoded in multiple ways. For example a value of `42` can be represented as: `[0x2a], [0xcc, 0x2a], [0xcd, 0x00, 0x2a]` and so on, and all of them are considered as valid representations. To allow fine-grained control over encoding such values the library provides direct mapping functions.\n```\nlet mut bufs = vec![vec![]; 5];\nrmp::encode::write_pfix(&mut bufs[0], 42).unwrap();\nrmp::encode::write_u8(&mut bufs[1], 42).unwrap();\nrmp::encode::write_u16(&mut bufs[2], 42).unwrap();\nrmp::encode::write_u32(&mut bufs[3], 42).unwrap();\nrmp::encode::write_u64(&mut bufs[4], 42).unwrap();\nassert_eq!([0x2a], bufs[0][..]);\nassert_eq!([0xcc, 0x2a], bufs[1][..]);\nassert_eq!([0xcd, 0x00, 0x2a], bufs[2][..]);\nassert_eq!([0xce, 0x00, 0x00, 0x00, 0x2a], bufs[3][..]);\nassert_eq!([0xcf, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2a], bufs[4][..]);\n```\n\nBut they aren\u2019t planned to be widely used. Instead we often need to encode bytes compactly to save space. In these cases RMP provides functions that guarantee that for encoding the most compact representation will be chosen.\n```\nlet mut buf = Vec::new();\nrmp::encode::write_sint(&mut buf, 300).unwrap();\nassert_eq!([0xcd, 0x1, 0x2c], buf[..]);\n```\n\nOn the other hand for deserialization it is not matter in which representation the value is encoded - RMP deals with all of them.\nSometimes you know the exact type representation and want to enforce the deserialization process to make it strongly type safe.\n```\nlet buf = [0xcd, 0x1, 0x2c];\nassert_eq!(300, rmp::decode::read_u16(&mut &buf[..]).unwrap());\n```\n\nHowever if you try to decode such bytearray as other integer type, for example `u32`, there will be type mismatch error.\n```\nlet buf = [0xcd, 0x1, 0x2c];\nrmp::decode::read_u32(&mut &buf[..]).err().unwrap();\n```\n\nBut sometimes all you want is just to encode an integer that _must_ fit in the specified type no matter how it was encoded. RMP provides `such`\u27e810\u27e9 function to ease integration with other MessagePack libraries.\n```\nlet buf = [0xcd, 0x1, 0x2c];\nassert_eq!(300i16, rmp::decode::read_int(&mut &buf[..]).unwrap());\nassert_eq!(300i32, rmp::decode::read_int(&mut &buf[..]).unwrap());\nassert_eq!(300i64, rmp::decode::read_int(&mut &buf[..]).unwrap());\nassert_eq!(300u16, rmp::decode::read_int(&mut &buf[..]).unwrap());\nassert_eq!(300u32, rmp::decode::read_int(&mut &buf[..]).unwrap());\nassert_eq!(300u64, rmp::decode::read_int(&mut &buf[..]).unwrap());\n```\n\n#### \u00a7\u27e811\u27e9API\nAlmost all API are represented as pure functions, which accepts a generic `Write` or `Read` and the value to be encoded/decoded. For example let\u2019s do a round trip for \u03c0 number.\n```\nlet pi = std::f64::consts::PI;\nlet mut buf = Vec::new();\nrmp::encode::write_f64(&mut buf, pi).unwrap();\nassert_eq!([0xcb, 0x40, 0x9, 0x21, 0xfb, 0x54, 0x44, 0x2d, 0x18], buf[..]);\nassert_eq!(pi, rmp::decode::read_f64(&mut &buf[..]).unwrap());\n```\n\nLicense: MIT\n## Modules\u00a7\u27e812\u27e9\n\ndecode\u27e813\u27e9\n    Provides various functions and structs for MessagePack decoding.\n\nencode\u27e814\u27e9\n    Provides various functions and structs for MessagePack encoding.\n## Enums\u00a7\u27e815\u27e9\n\nMarker\u27e816\u27e9\n    Format markers.\n## Constants\u00a7\u27e817\u27e9\n\nMSGPACK_VERSION\u27e818\u27e9\n    Version of the MessagePack spec\u27e819\u27e9.\n",
              "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/rmp/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/rmp/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/rmp/latest/src/rmp/lib.rs.html#1-14: Source\n\u27e84\u27e9 https://docs.rs/rmp/latest/rmp/#the-rust-messagepack-library: \u00a7\n\u27e85\u27e9 http://msgpack.org: MessagePack\n\u27e86\u27e9 https://lib.rs/crates/rmp-serde: Looking for Serde support\n\u27e87\u27e9 https://docs.rs/rmp/latest/rmp/#usage: \u00a7\n\u27e88\u27e9 https://docs.rs/rmp/latest/rmp/#features: \u00a7\n\u27e89\u27e9 https://docs.rs/rmp/latest/rmp/#detailed: \u00a7\n\u27e810\u27e9 https://docs.rs/rmp/latest/rmp/decode/fn.read_int.html: `such`\n\u27e811\u27e9 https://docs.rs/rmp/latest/rmp/#api: \u00a7\n\u27e812\u27e9 https://docs.rs/rmp/latest/rmp/#modules: \u00a7\n\u27e813\u27e9 https://docs.rs/rmp/latest/rmp/decode/index.html: mod rmp::decode - decode\n\u27e814\u27e9 https://docs.rs/rmp/latest/rmp/encode/index.html: mod rmp::encode - encode\n\u27e815\u27e9 https://docs.rs/rmp/latest/rmp/#enums: \u00a7\n\u27e816\u27e9 https://docs.rs/rmp/latest/rmp/enum.Marker.html: enum rmp::Marker - Marker\n\u27e817\u27e9 https://docs.rs/rmp/latest/rmp/#constants: \u00a7\n\u27e818\u27e9 https://docs.rs/rmp/latest/rmp/constant.MSGPACK_VERSION.html: constant rmp::MSGPACK_VERSION - MSGPACK_VERSION\n\u27e819\u27e9 http://github.com/msgpack/msgpack/blob/master/spec.md: spec\n",
              "fit_markdown": "",
              "fit_html": ""
            },
            "structured_data": {},
            "quality_score": 4.0,
            "extraction_method": "crawl4ai",
            "error": null,
            "metadata": {
              "doc_type": "docs",
              "content_length": 6079,
              "has_structured_data": false,
              "crawl_success": true
            },
            "timestamp": "117164.0414344"
          },
          "lib_rs": {
            "url": "https://lib.rs/crates/rmp",
            "title": "Untitled",
            "content": {
              "raw_markdown": "###  [7 releases](https://lib.rs/crates/rmp/versions)\n0.8.14 |  Apr 17, 2024   \n---|---  \n0.8.12 |  Jul 21, 2023   \n0.8.11 |  Apr 19, 2022   \n0.8.10 |  Feb 2, 2021   \n0.4.0 |  ~~Jul 17, 2015~~  \n#**34** in [Encoding](https://lib.rs/encoding \"Encoding and/or decoding data from one data format to another.\")\nDownload history 951458/week @ 2025-03-03 925101/week @ 2025-03-10 1181609/week @ 2025-03-17 1300933/week @ 2025-03-24 829613/week @ 2025-03-31 920536/week @ 2025-04-07 739278/week @ 2025-04-14 686746/week @ 2025-04-21 616043/week @ 2025-04-28 696276/week @ 2025-05-05 693246/week @ 2025-05-12 697129/week @ 2025-05-19 632502/week @ 2025-05-26 720627/week @ 2025-06-02 694632/week @ 2025-06-09 693072/week @ 2025-06-16\n**2,764,878** downloads per month Used in [**2,175** crates (131 directly)](https://lib.rs/crates/rmp/rev)\n**MIT** license \n92KB  1.5K  SLoC\n## The Rust MessagePack Library\nRMP is a pure Rust [MessagePack](http://msgpack.org) implementation of an efficient binary serialization format. This crate provides low-level core functionality, writers and readers for primitive values with direct mapping between binary MessagePack format.\n[Looking for Serde support](https://lib.rs/crates/rmp-serde)?\nThis crate represents the very basic functionality needed to work with MessagePack format. Ideologically it is developed as a basis for building high-level abstractions.\n### Usage\nTo use ``rmp``, first add this to your ``Cargo.toml``:\n```\n```[``dependencies.rmp``]`\n`rmp ``=` ``\"`0.8`\"``\n``\n```\n\n### Features\n  * **Low-level API**\nRMP is designed to be lightweight and straightforward. There are low-level APIs, which give you full control over the encoding/decoding process. ``no-std`` environments are supported.\n  * **Zero-copy value decoding**\nRMP allows to decode bytes from a buffer in a zero-copy manner, without any heap allocations. easily and blazingly fast. Rust static checks guarantee that the data will be valid until buffer lives.\n  * **Clear error handling**\nRMP's error system guarantees that you never receive an error enum with unreachable variant.\n  * **Robust and tested**\nThis project is developed using TDD and CI, so any found bugs will be fixed without breaking existing functionality.\n\n\n### Detailed\nCurrently there are two large modules: encode and decode. More detail you can find in the corresponding sections.\nFormally every MessagePack message consists of some marker encapsulating a data type and the data itself. Sometimes there are no separate data chunk, for example for booleans. In these cases a marker contains the value. For example, the ```true``` value is encoded as ```0xc3```.\n```\n``let` `mut` buf `=` `Vec```::``new`(``)``;`\n`rmp`::```encode`::``write_bool`(``&``mut` buf`,` `true``)``.``unwrap``(``)``;`\n`assert_eq!``(``[``0xc3``]``,` buf`[``..``]``)``;`\n`\n```\n\nSometimes a single value can be encoded in multiple ways. For example a value of ```42``` can be represented as: ```[``0x2a``]``,` `[``0xcc``,` `0x2a``]``,` `[``0xcd``,` `0x00``,` `0x2a``]``` and so on, and all of them are considered as valid representations. To allow fine-grained control over encoding such values the library provides direct mapping functions.\n```\n``let` `mut` bufs `=` `vec!``[``vec!``[``]``;` `5``]``;`\n`rmp`::```encode`::``write_pfix`(``&``mut` bufs`[``0``]``,` `42``)``.``unwrap``(``)``;`\n`rmp`::```encode`::``write_u8`(``&``mut` bufs`[``1``]``,` `42``)``.``unwrap``(``)``;`\n`rmp`::```encode`::``write_u16`(``&``mut` bufs`[``2``]``,` `42``)``.``unwrap``(``)``;`\n`rmp`::```encode`::``write_u32`(``&``mut` bufs`[``3``]``,` `42``)``.``unwrap``(``)``;`\n`rmp`::```encode`::``write_u64`(``&``mut` bufs`[``4``]``,` `42``)``.``unwrap``(``)``;`\n`assert_eq!``(``[``0x2a``]``,` bufs`[``0``]``[``..``]``)``;`\n`assert_eq!``(``[``0xcc``,` `0x2a``]``,` bufs`[``1``]``[``..``]``)``;`\n`assert_eq!``(``[``0xcd``,` `0x00``,` `0x2a``]``,` bufs`[``2``]``[``..``]``)``;`\n`assert_eq!``(``[``0xce``,` `0x00``,` `0x00``,` `0x00``,` `0x2a``]``,` bufs`[``3``]``[``..``]``)``;`\n`assert_eq!``(``[``0xcf``,` `0x00``,` `0x00``,` `0x00``,` `0x00``,` `0x00``,` `0x00``,` `0x00``,` `0x2a``]``,` bufs`[``4``]``[``..``]``)``;`\n`\n```\n\nBut they aren't planned to be widely used. Instead we often need to encode bytes compactly to save space. In these cases RMP provides functions that guarantee that for encoding the most compact representation will be chosen.\n```\n``let` `mut` buf `=` `Vec```::``new`(``)``;`\n`rmp`::```encode`::``write_sint`(``&``mut` buf`,` `300``)``.``unwrap``(``)``;`\n`assert_eq!``(``[``0xcd``,` `0x1``,` `0x2c``]``,` buf`[``..``]``)``;`\n`\n```\n\nOn the other hand for deserialization it is not matter in which representation the value is encoded - RMP deals with all of them.\nSometimes you know the exact type representation and want to enforce the deserialization process to make it strongly type safe.\n```\n``let` buf `=` `[``0xcd``,` `0x1``,` `0x2c``]``;`\n`assert_eq!``(``300``,` `rmp`::```decode`::``read_u16`(``&``mut` `&`buf`[``..``]``)``.``unwrap``(``)``)``;`\n`\n```\n\nHowever if you try to decode such bytearray as other integer type, for example ```u32```, there will be type mismatch error.\n```\n``let` buf `=` `[``0xcd``,` `0x1``,` `0x2c``]``;`\n`rmp`::```decode`::``read_u32`(``&``mut` `&`buf`[``..``]``)``.``err``(``)``.``unwrap``(``)``;`\n`\n```\n\nBut sometimes all you want is just to encode an integer that _must_ fit in the specified type no matter how it was encoded. RMP provides [``such``](https://docs.rs/rmp/latest/rmp/decode/fn.read_int.html) function to ease integration with other MessagePack libraries.\n```\n``let` buf `=` `[``0xcd``,` `0x1``,` `0x2c``]``;`\n`assert_eq!``(``300``i16``,` `rmp`::```decode`::``read_int`(``&``mut` `&`buf`[``..``]``)``.``unwrap``(``)``)``;`\n`assert_eq!``(``300``i32``,` `rmp`::```decode`::``read_int`(``&``mut` `&`buf`[``..``]``)``.``unwrap``(``)``)``;`\n`assert_eq!``(``300``i64``,` `rmp`::```decode`::``read_int`(``&``mut` `&`buf`[``..``]``)``.``unwrap``(``)``)``;`\n`assert_eq!``(``300``u16``,` `rmp`::```decode`::``read_int`(``&``mut` `&`buf`[``..``]``)``.``unwrap``(``)``)``;`\n`assert_eq!``(``300``u32``,` `rmp`::```decode`::``read_int`(``&``mut` `&`buf`[``..``]``)``.``unwrap``(``)``)``;`\n`assert_eq!``(``300``u64``,` `rmp`::```decode`::``read_int`(``&``mut` `&`buf`[``..``]``)``.``unwrap``(``)``)``;`\n`\n```\n\n### API\nAlmost all API are represented as pure functions, which accepts a generic ``Write`` or ``Read`` and the value to be encoded/decoded. For example let's do a round trip for \u03c0 number.\n```\n``let` pi `=` `std`::```f64`::```consts`::```PI``;`\n`let` `mut` buf `=` `Vec```::``new`(``)``;`\n`rmp`::```encode`::``write_f64`(``&``mut` buf`,` pi`)``.``unwrap``(``)``;`\n`assert_eq!``(``[``0xcb``,` `0x40``,` `0x9``,` `0x21``,` `0xfb``,` `0x54``,` `0x44``,` `0x2d``,` `0x18``]``,` buf`[``..``]``)``;`\n`assert_eq!``(`pi`,` `rmp`::```decode`::``read_f64`(``&``mut` `&`buf`[``..``]``)``.``unwrap``(``)``)``;`\n`\n```\n\nLicense: MIT\n#### Dependencies\n~180\u2013270KB \n  * [byteorder](https://lib.rs/crates/byteorder \"1.4.2\")\n  * [num-traits](https://lib.rs/crates/num-traits \"0.2.14\")\n  * [paste](https://lib.rs/crates/paste \"1.0\")\n\n\n  * dev  [quickcheck](https://lib.rs/crates/quickcheck \"new\") 1.0\n\n\n#### [Other feature](https://lib.rs/crates/rmp/features)\n  * [std](https://lib.rs/crates/rmp/features#feature-std)\n\n\n  *[SLoC]: Lines of code, excluding comments\n",
              "markdown_with_citations": "###  7 releases\u27e81\u27e9\n0.8.14 |  Apr 17, 2024   \n---|---  \n0.8.12 |  Jul 21, 2023   \n0.8.11 |  Apr 19, 2022   \n0.8.10 |  Feb 2, 2021   \n0.4.0 |  ~~Jul 17, 2015~~  \n#**34** in Encoding\u27e82\u27e9\nDownload history 951458/week @ 2025-03-03 925101/week @ 2025-03-10 1181609/week @ 2025-03-17 1300933/week @ 2025-03-24 829613/week @ 2025-03-31 920536/week @ 2025-04-07 739278/week @ 2025-04-14 686746/week @ 2025-04-21 616043/week @ 2025-04-28 696276/week @ 2025-05-05 693246/week @ 2025-05-12 697129/week @ 2025-05-19 632502/week @ 2025-05-26 720627/week @ 2025-06-02 694632/week @ 2025-06-09 693072/week @ 2025-06-16\n**2,764,878** downloads per month Used in **2,175** crates (131 directly)\u27e83\u27e9\n**MIT** license \n92KB  1.5K  SLoC\n## The Rust MessagePack Library\nRMP is a pure Rust MessagePack\u27e84\u27e9 implementation of an efficient binary serialization format. This crate provides low-level core functionality, writers and readers for primitive values with direct mapping between binary MessagePack format.\nLooking for Serde support\u27e85\u27e9?\nThis crate represents the very basic functionality needed to work with MessagePack format. Ideologically it is developed as a basis for building high-level abstractions.\n### Usage\nTo use ``rmp``, first add this to your ``Cargo.toml``:\n```\n```[``dependencies.rmp``]`\n`rmp ``=` ``\"`0.8`\"``\n``\n```\n\n### Features\n  * **Low-level API**\nRMP is designed to be lightweight and straightforward. There are low-level APIs, which give you full control over the encoding/decoding process. ``no-std`` environments are supported.\n  * **Zero-copy value decoding**\nRMP allows to decode bytes from a buffer in a zero-copy manner, without any heap allocations. easily and blazingly fast. Rust static checks guarantee that the data will be valid until buffer lives.\n  * **Clear error handling**\nRMP's error system guarantees that you never receive an error enum with unreachable variant.\n  * **Robust and tested**\nThis project is developed using TDD and CI, so any found bugs will be fixed without breaking existing functionality.\n\n\n### Detailed\nCurrently there are two large modules: encode and decode. More detail you can find in the corresponding sections.\nFormally every MessagePack message consists of some marker encapsulating a data type and the data itself. Sometimes there are no separate data chunk, for example for booleans. In these cases a marker contains the value. For example, the ```true``` value is encoded as ```0xc3```.\n```\n``let` `mut` buf `=` `Vec```::``new`(``)``;`\n`rmp`::```encode`::``write_bool`(``&``mut` buf`,` `true``)``.``unwrap``(``)``;`\n`assert_eq!``(``[``0xc3``]``,` buf`[``..``]``)``;`\n`\n```\n\nSometimes a single value can be encoded in multiple ways. For example a value of ```42``` can be represented as: ```[``0x2a``]``,` `[``0xcc``,` `0x2a``]``,` `[``0xcd``,` `0x00``,` `0x2a``]``` and so on, and all of them are considered as valid representations. To allow fine-grained control over encoding such values the library provides direct mapping functions.\n```\n``let` `mut` bufs `=` `vec!``[``vec!``[``]``;` `5``]``;`\n`rmp`::```encode`::``write_pfix`(``&``mut` bufs`[``0``]``,` `42``)``.``unwrap``(``)``;`\n`rmp`::```encode`::``write_u8`(``&``mut` bufs`[``1``]``,` `42``)``.``unwrap``(``)``;`\n`rmp`::```encode`::``write_u16`(``&``mut` bufs`[``2``]``,` `42``)``.``unwrap``(``)``;`\n`rmp`::```encode`::``write_u32`(``&``mut` bufs`[``3``]``,` `42``)``.``unwrap``(``)``;`\n`rmp`::```encode`::``write_u64`(``&``mut` bufs`[``4``]``,` `42``)``.``unwrap``(``)``;`\n`assert_eq!``(``[``0x2a``]``,` bufs`[``0``]``[``..``]``)``;`\n`assert_eq!``(``[``0xcc``,` `0x2a``]``,` bufs`[``1``]``[``..``]``)``;`\n`assert_eq!``(``[``0xcd``,` `0x00``,` `0x2a``]``,` bufs`[``2``]``[``..``]``)``;`\n`assert_eq!``(``[``0xce``,` `0x00``,` `0x00``,` `0x00``,` `0x2a``]``,` bufs`[``3``]``[``..``]``)``;`\n`assert_eq!``(``[``0xcf``,` `0x00``,` `0x00``,` `0x00``,` `0x00``,` `0x00``,` `0x00``,` `0x00``,` `0x2a``]``,` bufs`[``4``]``[``..``]``)``;`\n`\n```\n\nBut they aren't planned to be widely used. Instead we often need to encode bytes compactly to save space. In these cases RMP provides functions that guarantee that for encoding the most compact representation will be chosen.\n```\n``let` `mut` buf `=` `Vec```::``new`(``)``;`\n`rmp`::```encode`::``write_sint`(``&``mut` buf`,` `300``)``.``unwrap``(``)``;`\n`assert_eq!``(``[``0xcd``,` `0x1``,` `0x2c``]``,` buf`[``..``]``)``;`\n`\n```\n\nOn the other hand for deserialization it is not matter in which representation the value is encoded - RMP deals with all of them.\nSometimes you know the exact type representation and want to enforce the deserialization process to make it strongly type safe.\n```\n``let` buf `=` `[``0xcd``,` `0x1``,` `0x2c``]``;`\n`assert_eq!``(``300``,` `rmp`::```decode`::``read_u16`(``&``mut` `&`buf`[``..``]``)``.``unwrap``(``)``)``;`\n`\n```\n\nHowever if you try to decode such bytearray as other integer type, for example ```u32```, there will be type mismatch error.\n```\n``let` buf `=` `[``0xcd``,` `0x1``,` `0x2c``]``;`\n`rmp`::```decode`::``read_u32`(``&``mut` `&`buf`[``..``]``)``.``err``(``)``.``unwrap``(``)``;`\n`\n```\n\nBut sometimes all you want is just to encode an integer that _must_ fit in the specified type no matter how it was encoded. RMP provides ``such``\u27e86\u27e9 function to ease integration with other MessagePack libraries.\n```\n``let` buf `=` `[``0xcd``,` `0x1``,` `0x2c``]``;`\n`assert_eq!``(``300``i16``,` `rmp`::```decode`::``read_int`(``&``mut` `&`buf`[``..``]``)``.``unwrap``(``)``)``;`\n`assert_eq!``(``300``i32``,` `rmp`::```decode`::``read_int`(``&``mut` `&`buf`[``..``]``)``.``unwrap``(``)``)``;`\n`assert_eq!``(``300``i64``,` `rmp`::```decode`::``read_int`(``&``mut` `&`buf`[``..``]``)``.``unwrap``(``)``)``;`\n`assert_eq!``(``300``u16``,` `rmp`::```decode`::``read_int`(``&``mut` `&`buf`[``..``]``)``.``unwrap``(``)``)``;`\n`assert_eq!``(``300``u32``,` `rmp`::```decode`::``read_int`(``&``mut` `&`buf`[``..``]``)``.``unwrap``(``)``)``;`\n`assert_eq!``(``300``u64``,` `rmp`::```decode`::``read_int`(``&``mut` `&`buf`[``..``]``)``.``unwrap``(``)``)``;`\n`\n```\n\n### API\nAlmost all API are represented as pure functions, which accepts a generic ``Write`` or ``Read`` and the value to be encoded/decoded. For example let's do a round trip for \u03c0 number.\n```\n``let` pi `=` `std`::```f64`::```consts`::```PI``;`\n`let` `mut` buf `=` `Vec```::``new`(``)``;`\n`rmp`::```encode`::``write_f64`(``&``mut` buf`,` pi`)``.``unwrap``(``)``;`\n`assert_eq!``(``[``0xcb``,` `0x40``,` `0x9``,` `0x21``,` `0xfb``,` `0x54``,` `0x44``,` `0x2d``,` `0x18``]``,` buf`[``..``]``)``;`\n`assert_eq!``(`pi`,` `rmp`::```decode`::``read_f64`(``&``mut` `&`buf`[``..``]``)``.``unwrap``(``)``)``;`\n`\n```\n\nLicense: MIT\n#### Dependencies\n~180\u2013270KB \n  * byteorder\u27e87\u27e9\n  * num-traits\u27e88\u27e9\n  * paste\u27e89\u27e9\n\n\n  * dev  quickcheck\u27e810\u27e9 1.0\n\n\n#### Other feature\u27e811\u27e9\n  * std\u27e812\u27e9\n\n\n  *[SLoC]: Lines of code, excluding comments\n",
              "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://lib.rs/crates/rmp/versions: 7 releases\n\u27e82\u27e9 https://lib.rs/encoding: Encoding and/or decoding data from one data format to another. - Encoding\n\u27e83\u27e9 https://lib.rs/crates/rmp/rev: **2,175** crates (131 directly)\n\u27e84\u27e9 http://msgpack.org: MessagePack\n\u27e85\u27e9 https://lib.rs/crates/rmp-serde: Looking for Serde support\n\u27e86\u27e9 https://docs.rs/rmp/latest/rmp/decode/fn.read_int.html: ``such``\n\u27e87\u27e9 https://lib.rs/crates/byteorder: 1.4.2 - byteorder\n\u27e88\u27e9 https://lib.rs/crates/num-traits: 0.2.14 - num-traits\n\u27e89\u27e9 https://lib.rs/crates/paste: 1.0 - paste\n\u27e810\u27e9 https://lib.rs/crates/quickcheck: new - quickcheck\n\u27e811\u27e9 https://lib.rs/crates/rmp/features: Other feature\n\u27e812\u27e9 https://lib.rs/crates/rmp/features#feature-std: std\n",
              "fit_markdown": "",
              "fit_html": ""
            },
            "structured_data": {},
            "quality_score": 3.0,
            "extraction_method": "crawl4ai",
            "error": null,
            "metadata": {
              "doc_type": "docs",
              "content_length": 7337,
              "has_structured_data": false,
              "crawl_success": true
            },
            "timestamp": "117164.4537279"
          }
        },
        "crate_analysis": {
          "status": "completed",
          "check": [
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#byteorder@1.5.0",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\byteorder-1.5.0\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "byteorder",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\byteorder-1.5.0\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "std"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmplw8xuk51\\rmp-0.8.14\\target\\debug\\deps\\libbyteorder-aa7d78db036b3aed.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#paste@1.0.14",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\paste-1.0.14\\Cargo.toml",
              "target": {
                "kind": [
                  "custom-build"
                ],
                "crate_types": [
                  "bin"
                ],
                "name": "build-script-build",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\paste-1.0.14\\build.rs",
                "edition": "2018",
                "doc": false,
                "doctest": false,
                "test": false
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmplw8xuk51\\rmp-0.8.14\\target\\debug\\build\\paste-5843be50bd63ba8f\\build-script-build.exe",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmplw8xuk51\\rmp-0.8.14\\target\\debug\\build\\paste-5843be50bd63ba8f\\build_script_build.pdb"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#autocfg@1.2.0",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\autocfg-1.2.0\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "autocfg",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\autocfg-1.2.0\\src\\lib.rs",
                "edition": "2015",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmplw8xuk51\\rmp-0.8.14\\target\\debug\\deps\\libautocfg-efd84676dc09c289.rlib",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmplw8xuk51\\rmp-0.8.14\\target\\debug\\deps\\libautocfg-efd84676dc09c289.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "build-script-executed",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#paste@1.0.14",
              "linked_libs": [],
              "linked_paths": [],
              "cfgs": [],
              "env": [],
              "out_dir": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmplw8xuk51\\rmp-0.8.14\\target\\debug\\build\\paste-ba369a6e55aad20e\\out"
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#num-traits@0.2.18",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\num-traits-0.2.18\\Cargo.toml",
              "target": {
                "kind": [
                  "custom-build"
                ],
                "crate_types": [
                  "bin"
                ],
                "name": "build-script-build",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\num-traits-0.2.18\\build.rs",
                "edition": "2018",
                "doc": false,
                "doctest": false,
                "test": false
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "std"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmplw8xuk51\\rmp-0.8.14\\target\\debug\\build\\num-traits-b060962b561d4819\\build-script-build.exe",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmplw8xuk51\\rmp-0.8.14\\target\\debug\\build\\num-traits-b060962b561d4819\\build_script_build.pdb"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#paste@1.0.14",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\paste-1.0.14\\Cargo.toml",
              "target": {
                "kind": [
                  "proc-macro"
                ],
                "crate_types": [
                  "proc-macro"
                ],
                "name": "paste",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\paste-1.0.14\\src\\lib.rs",
                "edition": "2018",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmplw8xuk51\\rmp-0.8.14\\target\\debug\\deps\\paste-bbd88100e0c80cc6.dll",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmplw8xuk51\\rmp-0.8.14\\target\\debug\\deps\\paste-bbd88100e0c80cc6.dll.lib",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmplw8xuk51\\rmp-0.8.14\\target\\debug\\deps\\paste-bbd88100e0c80cc6.dll.exp",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmplw8xuk51\\rmp-0.8.14\\target\\debug\\deps\\paste-bbd88100e0c80cc6.pdb"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "build-script-executed",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#num-traits@0.2.18",
              "linked_libs": [],
              "linked_paths": [],
              "cfgs": [
                "has_to_int_unchecked",
                "has_reverse_bits",
                "has_leading_trailing_ones",
                "has_div_euclid",
                "has_copysign",
                "has_is_subnormal",
                "has_total_cmp",
                "has_int_to_from_bytes",
                "has_float_to_from_bytes"
              ],
              "env": [],
              "out_dir": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmplw8xuk51\\rmp-0.8.14\\target\\debug\\build\\num-traits-a6d8ae2328407c72\\out"
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#num-traits@0.2.18",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\num-traits-0.2.18\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "num_traits",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\num-traits-0.2.18\\src\\lib.rs",
                "edition": "2018",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "std"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmplw8xuk51\\rmp-0.8.14\\target\\debug\\deps\\libnum_traits-bb4fcc627948f645.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "compiler-artifact",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmplw8xuk51/rmp-0.8.14#rmp@0.8.14",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmplw8xuk51\\rmp-0.8.14\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "rmp",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmplw8xuk51\\rmp-0.8.14\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "default",
                "std"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmplw8xuk51\\rmp-0.8.14\\target\\debug\\deps\\librmp-03e14617b1ffa156.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "build-finished",
              "success": true
            }
          ],
          "clippy": [
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#autocfg@1.2.0",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\autocfg-1.2.0\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "autocfg",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\autocfg-1.2.0\\src\\lib.rs",
                "edition": "2015",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmplw8xuk51\\rmp-0.8.14\\target\\debug\\deps\\libautocfg-efd84676dc09c289.rlib",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmplw8xuk51\\rmp-0.8.14\\target\\debug\\deps\\libautocfg-efd84676dc09c289.rmeta"
              ],
              "executable": null,
              "fresh": true
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#num-traits@0.2.18",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\num-traits-0.2.18\\Cargo.toml",
              "target": {
                "kind": [
                  "custom-build"
                ],
                "crate_types": [
                  "bin"
                ],
                "name": "build-script-build",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\num-traits-0.2.18\\build.rs",
                "edition": "2018",
                "doc": false,
                "doctest": false,
                "test": false
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "std"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmplw8xuk51\\rmp-0.8.14\\target\\debug\\build\\num-traits-b060962b561d4819\\build-script-build.exe",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmplw8xuk51\\rmp-0.8.14\\target\\debug\\build\\num-traits-b060962b561d4819\\build_script_build.pdb"
              ],
              "executable": null,
              "fresh": true
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#paste@1.0.14",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\paste-1.0.14\\Cargo.toml",
              "target": {
                "kind": [
                  "custom-build"
                ],
                "crate_types": [
                  "bin"
                ],
                "name": "build-script-build",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\paste-1.0.14\\build.rs",
                "edition": "2018",
                "doc": false,
                "doctest": false,
                "test": false
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmplw8xuk51\\rmp-0.8.14\\target\\debug\\build\\paste-5843be50bd63ba8f\\build-script-build.exe",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmplw8xuk51\\rmp-0.8.14\\target\\debug\\build\\paste-5843be50bd63ba8f\\build_script_build.pdb"
              ],
              "executable": null,
              "fresh": true
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#byteorder@1.5.0",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\byteorder-1.5.0\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "byteorder",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\byteorder-1.5.0\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "std"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmplw8xuk51\\rmp-0.8.14\\target\\debug\\deps\\libbyteorder-aa7d78db036b3aed.rmeta"
              ],
              "executable": null,
              "fresh": true
            },
            {
              "reason": "build-script-executed",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#num-traits@0.2.18",
              "linked_libs": [],
              "linked_paths": [],
              "cfgs": [
                "has_to_int_unchecked",
                "has_reverse_bits",
                "has_leading_trailing_ones",
                "has_div_euclid",
                "has_copysign",
                "has_is_subnormal",
                "has_total_cmp",
                "has_int_to_from_bytes",
                "has_float_to_from_bytes"
              ],
              "env": [],
              "out_dir": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmplw8xuk51\\rmp-0.8.14\\target\\debug\\build\\num-traits-a6d8ae2328407c72\\out"
            },
            {
              "reason": "build-script-executed",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#paste@1.0.14",
              "linked_libs": [],
              "linked_paths": [],
              "cfgs": [],
              "env": [],
              "out_dir": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmplw8xuk51\\rmp-0.8.14\\target\\debug\\build\\paste-ba369a6e55aad20e\\out"
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#paste@1.0.14",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\paste-1.0.14\\Cargo.toml",
              "target": {
                "kind": [
                  "proc-macro"
                ],
                "crate_types": [
                  "proc-macro"
                ],
                "name": "paste",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\paste-1.0.14\\src\\lib.rs",
                "edition": "2018",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmplw8xuk51\\rmp-0.8.14\\target\\debug\\deps\\paste-bbd88100e0c80cc6.dll",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmplw8xuk51\\rmp-0.8.14\\target\\debug\\deps\\paste-bbd88100e0c80cc6.dll.lib",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmplw8xuk51\\rmp-0.8.14\\target\\debug\\deps\\paste-bbd88100e0c80cc6.dll.exp",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmplw8xuk51\\rmp-0.8.14\\target\\debug\\deps\\paste-bbd88100e0c80cc6.pdb"
              ],
              "executable": null,
              "fresh": true
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#num-traits@0.2.18",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\num-traits-0.2.18\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "num_traits",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\num-traits-0.2.18\\src\\lib.rs",
                "edition": "2018",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "std"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmplw8xuk51\\rmp-0.8.14\\target\\debug\\deps\\libnum_traits-bb4fcc627948f645.rmeta"
              ],
              "executable": null,
              "fresh": true
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmplw8xuk51/rmp-0.8.14#rmp@0.8.14",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmplw8xuk51\\rmp-0.8.14\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "rmp",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmplw8xuk51\\rmp-0.8.14\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: manual `Range::contains` implementation\n  --> src\\encode\\sint.rs:28:13\n   |\n28 |     assert!(-32 <= val && val < 0);\n   |             ^^^^^^^^^^^^^^^^^^^^^ help: use: `(-32..0).contains(&val)`\n   |\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#manual_range_contains\n   = note: `#[warn(clippy::manual_range_contains)]` on by default\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#manual_range_contains",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "note",
                    "message": "`#[warn(clippy::manual_range_contains)]` on by default",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "use",
                    "rendered": null,
                    "spans": [
                      {
                        "byte_end": 1156,
                        "byte_start": 1135,
                        "column_end": 34,
                        "column_start": 13,
                        "expansion": null,
                        "file_name": "src\\encode\\sint.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 28,
                        "line_start": 28,
                        "suggested_replacement": "(-32..0).contains(&val)",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 34,
                            "highlight_start": 13,
                            "text": "    assert!(-32 <= val && val < 0);"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "code": {
                  "code": "clippy::manual_range_contains",
                  "explanation": null
                },
                "level": "warning",
                "message": "manual `Range::contains` implementation",
                "spans": [
                  {
                    "byte_end": 1156,
                    "byte_start": 1135,
                    "column_end": 34,
                    "column_start": 13,
                    "expansion": null,
                    "file_name": "src\\encode\\sint.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 28,
                    "line_start": 28,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 34,
                        "highlight_start": 13,
                        "text": "    assert!(-32 <= val && val < 0);"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmplw8xuk51/rmp-0.8.14#rmp@0.8.14",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmplw8xuk51\\rmp-0.8.14\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "rmp",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmplw8xuk51\\rmp-0.8.14\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: manual `Range::contains` implementation\n   --> src\\encode\\sint.rs:149:16\n    |\n149 |         val if -32 <= val && val < 0 => {\n    |                ^^^^^^^^^^^^^^^^^^^^^ help: use: `(-32..0).contains(&val)`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#manual_range_contains\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#manual_range_contains",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "use",
                    "rendered": null,
                    "spans": [
                      {
                        "byte_end": 6147,
                        "byte_start": 6126,
                        "column_end": 37,
                        "column_start": 16,
                        "expansion": null,
                        "file_name": "src\\encode\\sint.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 149,
                        "line_start": 149,
                        "suggested_replacement": "(-32..0).contains(&val)",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 37,
                            "highlight_start": 16,
                            "text": "        val if -32 <= val && val < 0 => {"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "code": {
                  "code": "clippy::manual_range_contains",
                  "explanation": null
                },
                "level": "warning",
                "message": "manual `Range::contains` implementation",
                "spans": [
                  {
                    "byte_end": 6147,
                    "byte_start": 6126,
                    "column_end": 37,
                    "column_start": 16,
                    "expansion": null,
                    "file_name": "src\\encode\\sint.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 149,
                    "line_start": 149,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 37,
                        "highlight_start": 16,
                        "text": "        val if -32 <= val && val < 0 => {"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmplw8xuk51/rmp-0.8.14#rmp@0.8.14",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmplw8xuk51\\rmp-0.8.14\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "rmp",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmplw8xuk51\\rmp-0.8.14\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: manual `Range::contains` implementation\n   --> src\\encode\\sint.rs:154:16\n    |\n154 |         val if -128 <= val && val < -32 => write_i8(wr, val as i8).and(Ok(Marker::I8)),\n    |                ^^^^^^^^^^^^^^^^^^^^^^^^ help: use: `(-128..-32).contains(&val)`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#manual_range_contains\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#manual_range_contains",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "use",
                    "rendered": null,
                    "spans": [
                      {
                        "byte_end": 6354,
                        "byte_start": 6330,
                        "column_end": 40,
                        "column_start": 16,
                        "expansion": null,
                        "file_name": "src\\encode\\sint.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 154,
                        "line_start": 154,
                        "suggested_replacement": "(-128..-32).contains(&val)",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 40,
                            "highlight_start": 16,
                            "text": "        val if -128 <= val && val < -32 => write_i8(wr, val as i8).and(Ok(Marker::I8)),"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "code": {
                  "code": "clippy::manual_range_contains",
                  "explanation": null
                },
                "level": "warning",
                "message": "manual `Range::contains` implementation",
                "spans": [
                  {
                    "byte_end": 6354,
                    "byte_start": 6330,
                    "column_end": 40,
                    "column_start": 16,
                    "expansion": null,
                    "file_name": "src\\encode\\sint.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 154,
                    "line_start": 154,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 40,
                        "highlight_start": 16,
                        "text": "        val if -128 <= val && val < -32 => write_i8(wr, val as i8).and(Ok(Marker::I8)),"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmplw8xuk51/rmp-0.8.14#rmp@0.8.14",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmplw8xuk51\\rmp-0.8.14\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "rmp",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmplw8xuk51\\rmp-0.8.14\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: manual `Range::contains` implementation\n   --> src\\encode\\sint.rs:155:16\n    |\n155 |         val if -32768 <= val && val < -128 => write_i16(wr, val as i16).and(Ok(Marker::I16)),\n    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use: `(-32768..-128).contains(&val)`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#manual_range_contains\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#manual_range_contains",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "use",
                    "rendered": null,
                    "spans": [
                      {
                        "byte_end": 6445,
                        "byte_start": 6418,
                        "column_end": 43,
                        "column_start": 16,
                        "expansion": null,
                        "file_name": "src\\encode\\sint.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 155,
                        "line_start": 155,
                        "suggested_replacement": "(-32768..-128).contains(&val)",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 43,
                            "highlight_start": 16,
                            "text": "        val if -32768 <= val && val < -128 => write_i16(wr, val as i16).and(Ok(Marker::I16)),"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "code": {
                  "code": "clippy::manual_range_contains",
                  "explanation": null
                },
                "level": "warning",
                "message": "manual `Range::contains` implementation",
                "spans": [
                  {
                    "byte_end": 6445,
                    "byte_start": 6418,
                    "column_end": 43,
                    "column_start": 16,
                    "expansion": null,
                    "file_name": "src\\encode\\sint.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 155,
                    "line_start": 155,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 43,
                        "highlight_start": 16,
                        "text": "        val if -32768 <= val && val < -128 => write_i16(wr, val as i16).and(Ok(Marker::I16)),"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmplw8xuk51/rmp-0.8.14#rmp@0.8.14",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmplw8xuk51\\rmp-0.8.14\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "rmp",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmplw8xuk51\\rmp-0.8.14\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: manual `Range::contains` implementation\n   --> src\\encode\\sint.rs:156:16\n    |\n156 |         val if -2147483648 <= val && val < -32768 => write_i32(wr, val as i32).and(Ok(Marker::I32)),\n    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use: `(-2147483648..-32768).contains(&val)`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#manual_range_contains\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#manual_range_contains",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "use",
                    "rendered": null,
                    "spans": [
                      {
                        "byte_end": 6546,
                        "byte_start": 6512,
                        "column_end": 50,
                        "column_start": 16,
                        "expansion": null,
                        "file_name": "src\\encode\\sint.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 156,
                        "line_start": 156,
                        "suggested_replacement": "(-2147483648..-32768).contains(&val)",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 50,
                            "highlight_start": 16,
                            "text": "        val if -2147483648 <= val && val < -32768 => write_i32(wr, val as i32).and(Ok(Marker::I32)),"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "code": {
                  "code": "clippy::manual_range_contains",
                  "explanation": null
                },
                "level": "warning",
                "message": "manual `Range::contains` implementation",
                "spans": [
                  {
                    "byte_end": 6546,
                    "byte_start": 6512,
                    "column_end": 50,
                    "column_start": 16,
                    "expansion": null,
                    "file_name": "src\\encode\\sint.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 156,
                    "line_start": 156,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 50,
                        "highlight_start": 16,
                        "text": "        val if -2147483648 <= val && val < -32768 => write_i32(wr, val as i32).and(Ok(Marker::I32)),"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmplw8xuk51/rmp-0.8.14#rmp@0.8.14",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmplw8xuk51\\rmp-0.8.14\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "rmp",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmplw8xuk51\\rmp-0.8.14\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: manual `Range::contains` implementation\n   --> src\\encode\\sint.rs:158:16\n    |\n158 |         val if 0 <= val && val < 128 => {\n    |                ^^^^^^^^^^^^^^^^^^^^^ help: use: `(0..128).contains(&val)`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#manual_range_contains\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#manual_range_contains",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "use",
                    "rendered": null,
                    "spans": [
                      {
                        "byte_end": 6711,
                        "byte_start": 6690,
                        "column_end": 37,
                        "column_start": 16,
                        "expansion": null,
                        "file_name": "src\\encode\\sint.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 158,
                        "line_start": 158,
                        "suggested_replacement": "(0..128).contains(&val)",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 37,
                            "highlight_start": 16,
                            "text": "        val if 0 <= val && val < 128 => {"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "code": {
                  "code": "clippy::manual_range_contains",
                  "explanation": null
                },
                "level": "warning",
                "message": "manual `Range::contains` implementation",
                "spans": [
                  {
                    "byte_end": 6711,
                    "byte_start": 6690,
                    "column_end": 37,
                    "column_start": 16,
                    "expansion": null,
                    "file_name": "src\\encode\\sint.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 158,
                    "line_start": 158,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 37,
                        "highlight_start": 16,
                        "text": "        val if 0 <= val && val < 128 => {"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-artifact",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmplw8xuk51/rmp-0.8.14#rmp@0.8.14",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmplw8xuk51\\rmp-0.8.14\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "rmp",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmplw8xuk51\\rmp-0.8.14\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "default",
                "std"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmplw8xuk51\\rmp-0.8.14\\target\\debug\\deps\\librmp-00bd0d0df9e9cd0b.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "build-finished",
              "success": true
            }
          ],
          "audit": {
            "database": {
              "advisory-count": 787,
              "last-commit": "7573f55ba337263f61167dbb0ea926cdc7c8eb5d",
              "last-updated": "2025-06-17T11:04:25+02:00"
            },
            "lockfile": {
              "dependency-count": 19
            },
            "settings": {
              "target_arch": [],
              "target_os": [],
              "severity": null,
              "ignore": [],
              "informational_warnings": [
                "unmaintained",
                "unsound",
                "notice"
              ]
            },
            "vulnerabilities": {
              "found": false,
              "count": 0,
              "list": []
            },
            "warnings": {
              "unmaintained": [
                {
                  "kind": "unmaintained",
                  "package": {
                    "name": "paste",
                    "version": "1.0.14",
                    "source": "registry+https://github.com/rust-lang/crates.io-index",
                    "checksum": "de3145af08024dea9fa9914f381a17b8fc6034dfb00f3a84013f7ff43f29ed4c",
                    "replace": null
                  },
                  "advisory": {
                    "id": "RUSTSEC-2024-0436",
                    "package": "paste",
                    "title": "paste - no longer maintained",
                    "description": "The creator of the crate `paste` has stated in the [`README.md`](https://github.com/dtolnay/paste/blob/master/README.md) \nthat this project is not longer maintained as well as archived the repository",
                    "date": "2024-10-07",
                    "aliases": [],
                    "related": [],
                    "collection": "crates",
                    "categories": [],
                    "keywords": [],
                    "cvss": null,
                    "informational": "unmaintained",
                    "references": [],
                    "source": null,
                    "url": "https://github.com/dtolnay/paste",
                    "withdrawn": null,
                    "license": "CC0-1.0"
                  },
                  "affected": null,
                  "versions": {
                    "patched": [],
                    "unaffected": []
                  }
                }
              ]
            }
          },
          "note": "Crate analysis performed with stable toolchain."
        },
        "crate_metadata": {
          "name": "rmp",
          "version": "0.8.14",
          "description": "ALLOW: Positive community sentiment",
          "repository": "",
          "keywords": [],
          "categories": [],
          "readme": {
            "raw_markdown": "[](https://docs.rs/rmp/latest/rmp/all.html \"show sidebar\")\n# Crate rmpCopy item path\n[Settings](https://docs.rs/rmp/latest/settings.html)\n[Help](https://docs.rs/rmp/latest/help.html)\nSummary[Source](https://docs.rs/rmp/latest/src/rmp/lib.rs.html#1-14)\nExpand description\n### [\u00a7](https://docs.rs/rmp/latest/rmp/#the-rust-messagepack-library)The Rust MessagePack Library\nRMP is a pure Rust [MessagePack](http://msgpack.org) implementation of an efficient binary serialization format. This crate provides low-level core functionality, writers and readers for primitive values with direct mapping between binary MessagePack format.\n[Looking for Serde support](https://lib.rs/crates/rmp-serde)?\nThis crate represents the very basic functionality needed to work with MessagePack format. Ideologically it is developed as a basis for building high-level abstractions.\n#### [\u00a7](https://docs.rs/rmp/latest/rmp/#usage)Usage\nTo use `rmp`, first add this to your `Cargo.toml`:\n```\n[dependencies.rmp]\nrmp = \"0.8\"\n```\n\n#### [\u00a7](https://docs.rs/rmp/latest/rmp/#features)Features\n  * **Low-level API**\nRMP is designed to be lightweight and straightforward. There are low-level APIs, which give you full control over the encoding/decoding process. `no-std` environments are supported.\n  * **Zero-copy value decoding**\nRMP allows to decode bytes from a buffer in a zero-copy manner, without any heap allocations. easily and blazingly fast. Rust static checks guarantee that the data will be valid until buffer lives.\n  * **Clear error handling**\nRMP\u2019s error system guarantees that you never receive an error enum with unreachable variant.\n  * **Robust and tested**\nThis project is developed using TDD and CI, so any found bugs will be fixed without breaking existing functionality.\n\n\n#### [\u00a7](https://docs.rs/rmp/latest/rmp/#detailed)Detailed\nCurrently there are two large modules: encode and decode. More detail you can find in the corresponding sections.\nFormally every MessagePack message consists of some marker encapsulating a data type and the data itself. Sometimes there are no separate data chunk, for example for booleans. In these cases a marker contains the value. For example, the `true` value is encoded as `0xc3`.\n```\nlet mut buf = Vec::new();\nrmp::encode::write_bool(&mut buf, true).unwrap();\nassert_eq!([0xc3], buf[..]);\n```\n\nSometimes a single value can be encoded in multiple ways. For example a value of `42` can be represented as: `[0x2a], [0xcc, 0x2a], [0xcd, 0x00, 0x2a]` and so on, and all of them are considered as valid representations. To allow fine-grained control over encoding such values the library provides direct mapping functions.\n```\nlet mut bufs = vec![vec![]; 5];\nrmp::encode::write_pfix(&mut bufs[0], 42).unwrap();\nrmp::encode::write_u8(&mut bufs[1], 42).unwrap();\nrmp::encode::write_u16(&mut bufs[2], 42).unwrap();\nrmp::encode::write_u32(&mut bufs[3], 42).unwrap();\nrmp::encode::write_u64(&mut bufs[4], 42).unwrap();\nassert_eq!([0x2a], bufs[0][..]);\nassert_eq!([0xcc, 0x2a], bufs[1][..]);\nassert_eq!([0xcd, 0x00, 0x2a], bufs[2][..]);\nassert_eq!([0xce, 0x00, 0x00, 0x00, 0x2a], bufs[3][..]);\nassert_eq!([0xcf, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2a], bufs[4][..]);\n```\n\nBut they aren\u2019t planned to be widely used. Instead we often need to encode bytes compactly to save space. In these cases RMP provides functions that guarantee that for encoding the most compact representation will be chosen.\n```\nlet mut buf = Vec::new();\nrmp::encode::write_sint(&mut buf, 300).unwrap();\nassert_eq!([0xcd, 0x1, 0x2c], buf[..]);\n```\n\nOn the other hand for deserialization it is not matter in which representation the value is encoded - RMP deals with all of them.\nSometimes you know the exact type representation and want to enforce the deserialization process to make it strongly type safe.\n```\nlet buf = [0xcd, 0x1, 0x2c];\nassert_eq!(300, rmp::decode::read_u16(&mut &buf[..]).unwrap());\n```\n\nHowever if you try to decode such bytearray as other integer type, for example `u32`, there will be type mismatch error.\n```\nlet buf = [0xcd, 0x1, 0x2c];\nrmp::decode::read_u32(&mut &buf[..]).err().unwrap();\n```\n\nBut sometimes all you want is just to encode an integer that _must_ fit in the specified type no matter how it was encoded. RMP provides [`such`](https://docs.rs/rmp/latest/rmp/decode/fn.read_int.html) function to ease integration with other MessagePack libraries.\n```\nlet buf = [0xcd, 0x1, 0x2c];\nassert_eq!(300i16, rmp::decode::read_int(&mut &buf[..]).unwrap());\nassert_eq!(300i32, rmp::decode::read_int(&mut &buf[..]).unwrap());\nassert_eq!(300i64, rmp::decode::read_int(&mut &buf[..]).unwrap());\nassert_eq!(300u16, rmp::decode::read_int(&mut &buf[..]).unwrap());\nassert_eq!(300u32, rmp::decode::read_int(&mut &buf[..]).unwrap());\nassert_eq!(300u64, rmp::decode::read_int(&mut &buf[..]).unwrap());\n```\n\n#### [\u00a7](https://docs.rs/rmp/latest/rmp/#api)API\nAlmost all API are represented as pure functions, which accepts a generic `Write` or `Read` and the value to be encoded/decoded. For example let\u2019s do a round trip for \u03c0 number.\n```\nlet pi = std::f64::consts::PI;\nlet mut buf = Vec::new();\nrmp::encode::write_f64(&mut buf, pi).unwrap();\nassert_eq!([0xcb, 0x40, 0x9, 0x21, 0xfb, 0x54, 0x44, 0x2d, 0x18], buf[..]);\nassert_eq!(pi, rmp::decode::read_f64(&mut &buf[..]).unwrap());\n```\n\nLicense: MIT\n## Modules[\u00a7](https://docs.rs/rmp/latest/rmp/#modules)\n\n[decode](https://docs.rs/rmp/latest/rmp/decode/index.html \"mod rmp::decode\")\n    Provides various functions and structs for MessagePack decoding.\n\n[encode](https://docs.rs/rmp/latest/rmp/encode/index.html \"mod rmp::encode\")\n    Provides various functions and structs for MessagePack encoding.\n## Enums[\u00a7](https://docs.rs/rmp/latest/rmp/#enums)\n\n[Marker](https://docs.rs/rmp/latest/rmp/enum.Marker.html \"enum rmp::Marker\")\n    Format markers.\n## Constants[\u00a7](https://docs.rs/rmp/latest/rmp/#constants)\n\n[MSGPACK_VERSION](https://docs.rs/rmp/latest/rmp/constant.MSGPACK_VERSION.html \"constant rmp::MSGPACK_VERSION\")\n    Version of the MessagePack [spec](http://github.com/msgpack/msgpack/blob/master/spec.md).\n",
            "markdown_with_citations": "[](https://docs.rs/rmp/latest/rmp/all.html \"show sidebar\")\n# Crate rmpCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\n### \u00a7\u27e84\u27e9The Rust MessagePack Library\nRMP is a pure Rust MessagePack\u27e85\u27e9 implementation of an efficient binary serialization format. This crate provides low-level core functionality, writers and readers for primitive values with direct mapping between binary MessagePack format.\nLooking for Serde support\u27e86\u27e9?\nThis crate represents the very basic functionality needed to work with MessagePack format. Ideologically it is developed as a basis for building high-level abstractions.\n#### \u00a7\u27e87\u27e9Usage\nTo use `rmp`, first add this to your `Cargo.toml`:\n```\n[dependencies.rmp]\nrmp = \"0.8\"\n```\n\n#### \u00a7\u27e88\u27e9Features\n  * **Low-level API**\nRMP is designed to be lightweight and straightforward. There are low-level APIs, which give you full control over the encoding/decoding process. `no-std` environments are supported.\n  * **Zero-copy value decoding**\nRMP allows to decode bytes from a buffer in a zero-copy manner, without any heap allocations. easily and blazingly fast. Rust static checks guarantee that the data will be valid until buffer lives.\n  * **Clear error handling**\nRMP\u2019s error system guarantees that you never receive an error enum with unreachable variant.\n  * **Robust and tested**\nThis project is developed using TDD and CI, so any found bugs will be fixed without breaking existing functionality.\n\n\n#### \u00a7\u27e89\u27e9Detailed\nCurrently there are two large modules: encode and decode. More detail you can find in the corresponding sections.\nFormally every MessagePack message consists of some marker encapsulating a data type and the data itself. Sometimes there are no separate data chunk, for example for booleans. In these cases a marker contains the value. For example, the `true` value is encoded as `0xc3`.\n```\nlet mut buf = Vec::new();\nrmp::encode::write_bool(&mut buf, true).unwrap();\nassert_eq!([0xc3], buf[..]);\n```\n\nSometimes a single value can be encoded in multiple ways. For example a value of `42` can be represented as: `[0x2a], [0xcc, 0x2a], [0xcd, 0x00, 0x2a]` and so on, and all of them are considered as valid representations. To allow fine-grained control over encoding such values the library provides direct mapping functions.\n```\nlet mut bufs = vec![vec![]; 5];\nrmp::encode::write_pfix(&mut bufs[0], 42).unwrap();\nrmp::encode::write_u8(&mut bufs[1], 42).unwrap();\nrmp::encode::write_u16(&mut bufs[2], 42).unwrap();\nrmp::encode::write_u32(&mut bufs[3], 42).unwrap();\nrmp::encode::write_u64(&mut bufs[4], 42).unwrap();\nassert_eq!([0x2a], bufs[0][..]);\nassert_eq!([0xcc, 0x2a], bufs[1][..]);\nassert_eq!([0xcd, 0x00, 0x2a], bufs[2][..]);\nassert_eq!([0xce, 0x00, 0x00, 0x00, 0x2a], bufs[3][..]);\nassert_eq!([0xcf, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2a], bufs[4][..]);\n```\n\nBut they aren\u2019t planned to be widely used. Instead we often need to encode bytes compactly to save space. In these cases RMP provides functions that guarantee that for encoding the most compact representation will be chosen.\n```\nlet mut buf = Vec::new();\nrmp::encode::write_sint(&mut buf, 300).unwrap();\nassert_eq!([0xcd, 0x1, 0x2c], buf[..]);\n```\n\nOn the other hand for deserialization it is not matter in which representation the value is encoded - RMP deals with all of them.\nSometimes you know the exact type representation and want to enforce the deserialization process to make it strongly type safe.\n```\nlet buf = [0xcd, 0x1, 0x2c];\nassert_eq!(300, rmp::decode::read_u16(&mut &buf[..]).unwrap());\n```\n\nHowever if you try to decode such bytearray as other integer type, for example `u32`, there will be type mismatch error.\n```\nlet buf = [0xcd, 0x1, 0x2c];\nrmp::decode::read_u32(&mut &buf[..]).err().unwrap();\n```\n\nBut sometimes all you want is just to encode an integer that _must_ fit in the specified type no matter how it was encoded. RMP provides `such`\u27e810\u27e9 function to ease integration with other MessagePack libraries.\n```\nlet buf = [0xcd, 0x1, 0x2c];\nassert_eq!(300i16, rmp::decode::read_int(&mut &buf[..]).unwrap());\nassert_eq!(300i32, rmp::decode::read_int(&mut &buf[..]).unwrap());\nassert_eq!(300i64, rmp::decode::read_int(&mut &buf[..]).unwrap());\nassert_eq!(300u16, rmp::decode::read_int(&mut &buf[..]).unwrap());\nassert_eq!(300u32, rmp::decode::read_int(&mut &buf[..]).unwrap());\nassert_eq!(300u64, rmp::decode::read_int(&mut &buf[..]).unwrap());\n```\n\n#### \u00a7\u27e811\u27e9API\nAlmost all API are represented as pure functions, which accepts a generic `Write` or `Read` and the value to be encoded/decoded. For example let\u2019s do a round trip for \u03c0 number.\n```\nlet pi = std::f64::consts::PI;\nlet mut buf = Vec::new();\nrmp::encode::write_f64(&mut buf, pi).unwrap();\nassert_eq!([0xcb, 0x40, 0x9, 0x21, 0xfb, 0x54, 0x44, 0x2d, 0x18], buf[..]);\nassert_eq!(pi, rmp::decode::read_f64(&mut &buf[..]).unwrap());\n```\n\nLicense: MIT\n## Modules\u00a7\u27e812\u27e9\n\ndecode\u27e813\u27e9\n    Provides various functions and structs for MessagePack decoding.\n\nencode\u27e814\u27e9\n    Provides various functions and structs for MessagePack encoding.\n## Enums\u00a7\u27e815\u27e9\n\nMarker\u27e816\u27e9\n    Format markers.\n## Constants\u00a7\u27e817\u27e9\n\nMSGPACK_VERSION\u27e818\u27e9\n    Version of the MessagePack spec\u27e819\u27e9.\n",
            "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/rmp/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/rmp/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/rmp/latest/src/rmp/lib.rs.html#1-14: Source\n\u27e84\u27e9 https://docs.rs/rmp/latest/rmp/#the-rust-messagepack-library: \u00a7\n\u27e85\u27e9 http://msgpack.org: MessagePack\n\u27e86\u27e9 https://lib.rs/crates/rmp-serde: Looking for Serde support\n\u27e87\u27e9 https://docs.rs/rmp/latest/rmp/#usage: \u00a7\n\u27e88\u27e9 https://docs.rs/rmp/latest/rmp/#features: \u00a7\n\u27e89\u27e9 https://docs.rs/rmp/latest/rmp/#detailed: \u00a7\n\u27e810\u27e9 https://docs.rs/rmp/latest/rmp/decode/fn.read_int.html: `such`\n\u27e811\u27e9 https://docs.rs/rmp/latest/rmp/#api: \u00a7\n\u27e812\u27e9 https://docs.rs/rmp/latest/rmp/#modules: \u00a7\n\u27e813\u27e9 https://docs.rs/rmp/latest/rmp/decode/index.html: mod rmp::decode - decode\n\u27e814\u27e9 https://docs.rs/rmp/latest/rmp/encode/index.html: mod rmp::encode - encode\n\u27e815\u27e9 https://docs.rs/rmp/latest/rmp/#enums: \u00a7\n\u27e816\u27e9 https://docs.rs/rmp/latest/rmp/enum.Marker.html: enum rmp::Marker - Marker\n\u27e817\u27e9 https://docs.rs/rmp/latest/rmp/#constants: \u00a7\n\u27e818\u27e9 https://docs.rs/rmp/latest/rmp/constant.MSGPACK_VERSION.html: constant rmp::MSGPACK_VERSION - MSGPACK_VERSION\n\u27e819\u27e9 http://github.com/msgpack/msgpack/blob/master/spec.md: spec\n",
            "fit_markdown": "",
            "fit_html": ""
          },
          "downloads": 0,
          "github_stars": 0,
          "dependencies": [],
          "features": {},
          "code_snippets": [],
          "readme_sections": {},
          "librs_downloads": null,
          "source": "crates.io",
          "enhanced_scraping": {},
          "enhanced_features": [],
          "enhanced_dependencies": []
        },
        "enriched_crate": {
          "name": "rmp",
          "version": "0.8.14",
          "description": "ALLOW: Positive community sentiment",
          "repository": "",
          "keywords": [],
          "categories": [],
          "readme": {
            "raw_markdown": "[](https://docs.rs/rmp/latest/rmp/all.html \"show sidebar\")\n# Crate rmpCopy item path\n[Settings](https://docs.rs/rmp/latest/settings.html)\n[Help](https://docs.rs/rmp/latest/help.html)\nSummary[Source](https://docs.rs/rmp/latest/src/rmp/lib.rs.html#1-14)\nExpand description\n### [\u00a7](https://docs.rs/rmp/latest/rmp/#the-rust-messagepack-library)The Rust MessagePack Library\nRMP is a pure Rust [MessagePack](http://msgpack.org) implementation of an efficient binary serialization format. This crate provides low-level core functionality, writers and readers for primitive values with direct mapping between binary MessagePack format.\n[Looking for Serde support](https://lib.rs/crates/rmp-serde)?\nThis crate represents the very basic functionality needed to work with MessagePack format. Ideologically it is developed as a basis for building high-level abstractions.\n#### [\u00a7](https://docs.rs/rmp/latest/rmp/#usage)Usage\nTo use `rmp`, first add this to your `Cargo.toml`:\n```\n[dependencies.rmp]\nrmp = \"0.8\"\n```\n\n#### [\u00a7](https://docs.rs/rmp/latest/rmp/#features)Features\n  * **Low-level API**\nRMP is designed to be lightweight and straightforward. There are low-level APIs, which give you full control over the encoding/decoding process. `no-std` environments are supported.\n  * **Zero-copy value decoding**\nRMP allows to decode bytes from a buffer in a zero-copy manner, without any heap allocations. easily and blazingly fast. Rust static checks guarantee that the data will be valid until buffer lives.\n  * **Clear error handling**\nRMP\u2019s error system guarantees that you never receive an error enum with unreachable variant.\n  * **Robust and tested**\nThis project is developed using TDD and CI, so any found bugs will be fixed without breaking existing functionality.\n\n\n#### [\u00a7](https://docs.rs/rmp/latest/rmp/#detailed)Detailed\nCurrently there are two large modules: encode and decode. More detail you can find in the corresponding sections.\nFormally every MessagePack message consists of some marker encapsulating a data type and the data itself. Sometimes there are no separate data chunk, for example for booleans. In these cases a marker contains the value. For example, the `true` value is encoded as `0xc3`.\n```\nlet mut buf = Vec::new();\nrmp::encode::write_bool(&mut buf, true).unwrap();\nassert_eq!([0xc3], buf[..]);\n```\n\nSometimes a single value can be encoded in multiple ways. For example a value of `42` can be represented as: `[0x2a], [0xcc, 0x2a], [0xcd, 0x00, 0x2a]` and so on, and all of them are considered as valid representations. To allow fine-grained control over encoding such values the library provides direct mapping functions.\n```\nlet mut bufs = vec![vec![]; 5];\nrmp::encode::write_pfix(&mut bufs[0], 42).unwrap();\nrmp::encode::write_u8(&mut bufs[1], 42).unwrap();\nrmp::encode::write_u16(&mut bufs[2], 42).unwrap();\nrmp::encode::write_u32(&mut bufs[3], 42).unwrap();\nrmp::encode::write_u64(&mut bufs[4], 42).unwrap();\nassert_eq!([0x2a], bufs[0][..]);\nassert_eq!([0xcc, 0x2a], bufs[1][..]);\nassert_eq!([0xcd, 0x00, 0x2a], bufs[2][..]);\nassert_eq!([0xce, 0x00, 0x00, 0x00, 0x2a], bufs[3][..]);\nassert_eq!([0xcf, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2a], bufs[4][..]);\n```\n\nBut they aren\u2019t planned to be widely used. Instead we often need to encode bytes compactly to save space. In these cases RMP provides functions that guarantee that for encoding the most compact representation will be chosen.\n```\nlet mut buf = Vec::new();\nrmp::encode::write_sint(&mut buf, 300).unwrap();\nassert_eq!([0xcd, 0x1, 0x2c], buf[..]);\n```\n\nOn the other hand for deserialization it is not matter in which representation the value is encoded - RMP deals with all of them.\nSometimes you know the exact type representation and want to enforce the deserialization process to make it strongly type safe.\n```\nlet buf = [0xcd, 0x1, 0x2c];\nassert_eq!(300, rmp::decode::read_u16(&mut &buf[..]).unwrap());\n```\n\nHowever if you try to decode such bytearray as other integer type, for example `u32`, there will be type mismatch error.\n```\nlet buf = [0xcd, 0x1, 0x2c];\nrmp::decode::read_u32(&mut &buf[..]).err().unwrap();\n```\n\nBut sometimes all you want is just to encode an integer that _must_ fit in the specified type no matter how it was encoded. RMP provides [`such`](https://docs.rs/rmp/latest/rmp/decode/fn.read_int.html) function to ease integration with other MessagePack libraries.\n```\nlet buf = [0xcd, 0x1, 0x2c];\nassert_eq!(300i16, rmp::decode::read_int(&mut &buf[..]).unwrap());\nassert_eq!(300i32, rmp::decode::read_int(&mut &buf[..]).unwrap());\nassert_eq!(300i64, rmp::decode::read_int(&mut &buf[..]).unwrap());\nassert_eq!(300u16, rmp::decode::read_int(&mut &buf[..]).unwrap());\nassert_eq!(300u32, rmp::decode::read_int(&mut &buf[..]).unwrap());\nassert_eq!(300u64, rmp::decode::read_int(&mut &buf[..]).unwrap());\n```\n\n#### [\u00a7](https://docs.rs/rmp/latest/rmp/#api)API\nAlmost all API are represented as pure functions, which accepts a generic `Write` or `Read` and the value to be encoded/decoded. For example let\u2019s do a round trip for \u03c0 number.\n```\nlet pi = std::f64::consts::PI;\nlet mut buf = Vec::new();\nrmp::encode::write_f64(&mut buf, pi).unwrap();\nassert_eq!([0xcb, 0x40, 0x9, 0x21, 0xfb, 0x54, 0x44, 0x2d, 0x18], buf[..]);\nassert_eq!(pi, rmp::decode::read_f64(&mut &buf[..]).unwrap());\n```\n\nLicense: MIT\n## Modules[\u00a7](https://docs.rs/rmp/latest/rmp/#modules)\n\n[decode](https://docs.rs/rmp/latest/rmp/decode/index.html \"mod rmp::decode\")\n    Provides various functions and structs for MessagePack decoding.\n\n[encode](https://docs.rs/rmp/latest/rmp/encode/index.html \"mod rmp::encode\")\n    Provides various functions and structs for MessagePack encoding.\n## Enums[\u00a7](https://docs.rs/rmp/latest/rmp/#enums)\n\n[Marker](https://docs.rs/rmp/latest/rmp/enum.Marker.html \"enum rmp::Marker\")\n    Format markers.\n## Constants[\u00a7](https://docs.rs/rmp/latest/rmp/#constants)\n\n[MSGPACK_VERSION](https://docs.rs/rmp/latest/rmp/constant.MSGPACK_VERSION.html \"constant rmp::MSGPACK_VERSION\")\n    Version of the MessagePack [spec](http://github.com/msgpack/msgpack/blob/master/spec.md).\n",
            "markdown_with_citations": "[](https://docs.rs/rmp/latest/rmp/all.html \"show sidebar\")\n# Crate rmpCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\n### \u00a7\u27e84\u27e9The Rust MessagePack Library\nRMP is a pure Rust MessagePack\u27e85\u27e9 implementation of an efficient binary serialization format. This crate provides low-level core functionality, writers and readers for primitive values with direct mapping between binary MessagePack format.\nLooking for Serde support\u27e86\u27e9?\nThis crate represents the very basic functionality needed to work with MessagePack format. Ideologically it is developed as a basis for building high-level abstractions.\n#### \u00a7\u27e87\u27e9Usage\nTo use `rmp`, first add this to your `Cargo.toml`:\n```\n[dependencies.rmp]\nrmp = \"0.8\"\n```\n\n#### \u00a7\u27e88\u27e9Features\n  * **Low-level API**\nRMP is designed to be lightweight and straightforward. There are low-level APIs, which give you full control over the encoding/decoding process. `no-std` environments are supported.\n  * **Zero-copy value decoding**\nRMP allows to decode bytes from a buffer in a zero-copy manner, without any heap allocations. easily and blazingly fast. Rust static checks guarantee that the data will be valid until buffer lives.\n  * **Clear error handling**\nRMP\u2019s error system guarantees that you never receive an error enum with unreachable variant.\n  * **Robust and tested**\nThis project is developed using TDD and CI, so any found bugs will be fixed without breaking existing functionality.\n\n\n#### \u00a7\u27e89\u27e9Detailed\nCurrently there are two large modules: encode and decode. More detail you can find in the corresponding sections.\nFormally every MessagePack message consists of some marker encapsulating a data type and the data itself. Sometimes there are no separate data chunk, for example for booleans. In these cases a marker contains the value. For example, the `true` value is encoded as `0xc3`.\n```\nlet mut buf = Vec::new();\nrmp::encode::write_bool(&mut buf, true).unwrap();\nassert_eq!([0xc3], buf[..]);\n```\n\nSometimes a single value can be encoded in multiple ways. For example a value of `42` can be represented as: `[0x2a], [0xcc, 0x2a], [0xcd, 0x00, 0x2a]` and so on, and all of them are considered as valid representations. To allow fine-grained control over encoding such values the library provides direct mapping functions.\n```\nlet mut bufs = vec![vec![]; 5];\nrmp::encode::write_pfix(&mut bufs[0], 42).unwrap();\nrmp::encode::write_u8(&mut bufs[1], 42).unwrap();\nrmp::encode::write_u16(&mut bufs[2], 42).unwrap();\nrmp::encode::write_u32(&mut bufs[3], 42).unwrap();\nrmp::encode::write_u64(&mut bufs[4], 42).unwrap();\nassert_eq!([0x2a], bufs[0][..]);\nassert_eq!([0xcc, 0x2a], bufs[1][..]);\nassert_eq!([0xcd, 0x00, 0x2a], bufs[2][..]);\nassert_eq!([0xce, 0x00, 0x00, 0x00, 0x2a], bufs[3][..]);\nassert_eq!([0xcf, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2a], bufs[4][..]);\n```\n\nBut they aren\u2019t planned to be widely used. Instead we often need to encode bytes compactly to save space. In these cases RMP provides functions that guarantee that for encoding the most compact representation will be chosen.\n```\nlet mut buf = Vec::new();\nrmp::encode::write_sint(&mut buf, 300).unwrap();\nassert_eq!([0xcd, 0x1, 0x2c], buf[..]);\n```\n\nOn the other hand for deserialization it is not matter in which representation the value is encoded - RMP deals with all of them.\nSometimes you know the exact type representation and want to enforce the deserialization process to make it strongly type safe.\n```\nlet buf = [0xcd, 0x1, 0x2c];\nassert_eq!(300, rmp::decode::read_u16(&mut &buf[..]).unwrap());\n```\n\nHowever if you try to decode such bytearray as other integer type, for example `u32`, there will be type mismatch error.\n```\nlet buf = [0xcd, 0x1, 0x2c];\nrmp::decode::read_u32(&mut &buf[..]).err().unwrap();\n```\n\nBut sometimes all you want is just to encode an integer that _must_ fit in the specified type no matter how it was encoded. RMP provides `such`\u27e810\u27e9 function to ease integration with other MessagePack libraries.\n```\nlet buf = [0xcd, 0x1, 0x2c];\nassert_eq!(300i16, rmp::decode::read_int(&mut &buf[..]).unwrap());\nassert_eq!(300i32, rmp::decode::read_int(&mut &buf[..]).unwrap());\nassert_eq!(300i64, rmp::decode::read_int(&mut &buf[..]).unwrap());\nassert_eq!(300u16, rmp::decode::read_int(&mut &buf[..]).unwrap());\nassert_eq!(300u32, rmp::decode::read_int(&mut &buf[..]).unwrap());\nassert_eq!(300u64, rmp::decode::read_int(&mut &buf[..]).unwrap());\n```\n\n#### \u00a7\u27e811\u27e9API\nAlmost all API are represented as pure functions, which accepts a generic `Write` or `Read` and the value to be encoded/decoded. For example let\u2019s do a round trip for \u03c0 number.\n```\nlet pi = std::f64::consts::PI;\nlet mut buf = Vec::new();\nrmp::encode::write_f64(&mut buf, pi).unwrap();\nassert_eq!([0xcb, 0x40, 0x9, 0x21, 0xfb, 0x54, 0x44, 0x2d, 0x18], buf[..]);\nassert_eq!(pi, rmp::decode::read_f64(&mut &buf[..]).unwrap());\n```\n\nLicense: MIT\n## Modules\u00a7\u27e812\u27e9\n\ndecode\u27e813\u27e9\n    Provides various functions and structs for MessagePack decoding.\n\nencode\u27e814\u27e9\n    Provides various functions and structs for MessagePack encoding.\n## Enums\u00a7\u27e815\u27e9\n\nMarker\u27e816\u27e9\n    Format markers.\n## Constants\u00a7\u27e817\u27e9\n\nMSGPACK_VERSION\u27e818\u27e9\n    Version of the MessagePack spec\u27e819\u27e9.\n",
            "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/rmp/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/rmp/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/rmp/latest/src/rmp/lib.rs.html#1-14: Source\n\u27e84\u27e9 https://docs.rs/rmp/latest/rmp/#the-rust-messagepack-library: \u00a7\n\u27e85\u27e9 http://msgpack.org: MessagePack\n\u27e86\u27e9 https://lib.rs/crates/rmp-serde: Looking for Serde support\n\u27e87\u27e9 https://docs.rs/rmp/latest/rmp/#usage: \u00a7\n\u27e88\u27e9 https://docs.rs/rmp/latest/rmp/#features: \u00a7\n\u27e89\u27e9 https://docs.rs/rmp/latest/rmp/#detailed: \u00a7\n\u27e810\u27e9 https://docs.rs/rmp/latest/rmp/decode/fn.read_int.html: `such`\n\u27e811\u27e9 https://docs.rs/rmp/latest/rmp/#api: \u00a7\n\u27e812\u27e9 https://docs.rs/rmp/latest/rmp/#modules: \u00a7\n\u27e813\u27e9 https://docs.rs/rmp/latest/rmp/decode/index.html: mod rmp::decode - decode\n\u27e814\u27e9 https://docs.rs/rmp/latest/rmp/encode/index.html: mod rmp::encode - encode\n\u27e815\u27e9 https://docs.rs/rmp/latest/rmp/#enums: \u00a7\n\u27e816\u27e9 https://docs.rs/rmp/latest/rmp/enum.Marker.html: enum rmp::Marker - Marker\n\u27e817\u27e9 https://docs.rs/rmp/latest/rmp/#constants: \u00a7\n\u27e818\u27e9 https://docs.rs/rmp/latest/rmp/constant.MSGPACK_VERSION.html: constant rmp::MSGPACK_VERSION - MSGPACK_VERSION\n\u27e819\u27e9 http://github.com/msgpack/msgpack/blob/master/spec.md: spec\n",
            "fit_markdown": "",
            "fit_html": ""
          },
          "downloads": 0,
          "github_stars": 0,
          "dependencies": [],
          "features": {},
          "code_snippets": [],
          "readme_sections": {},
          "librs_downloads": null,
          "source": "crates.io",
          "enhanced_scraping": {},
          "enhanced_features": [],
          "enhanced_dependencies": [],
          "readme_summary": "The `rmp` crate is a lightweight, pure Rust implementation of the MessagePack binary serialization format, offering low-level APIs for efficient encoding and decoding. It supports zero-copy value decoding, clear error handling, and compact data representation, making it ideal for performance-critical applications, including `no-std` environments. The crate provides robust encoding/decoding functions for primitive types, ensuring type safety and compatibility with various MessagePack representations.",
          "feature_summary": null,
          "use_case": "Serialization",
          "score": 6.0,
          "factual_counterfactual": "### Pair 1: Encoding and Decoding Features\n\u2705 Factual: The `rmp` crate supports encoding and decoding of primitive values like integers, booleans, and floating-point numbers, with direct mapping to the MessagePack binary format.  \n\u274c Counterfactual: The `rmp` crate does not support encoding floating-point numbers, as MessagePack does not have a binary representation for them.  \n\n---\n\n### Pair 2: Compact Encoding\n\u2705 Factual: The `rmp` crate provides functions to encode integers in their most compact representation, minimizing storage space. For example, the value `300` can be encoded as `[0xcd, 0x1, 0x2c]`.  \n\u274c Counterfactual: The `rmp` crate always uses fixed-width encoding for integers, resulting in larger byte arrays regardless of the value being encoded.  \n\n---\n\n### Pair 3: Error Handling\n\u2705 Factual: The `rmp` crate has a robust error-handling system that ensures no unreachable error variants are returned during encoding or decoding operations.  \n\u274c Counterfactual: The `rmp` crate does not provide specific error handling for type mismatches during decoding, resulting in silent failures instead of explicit errors.",
          "source_analysis": null,
          "user_behavior": null,
          "security": null
        }
      },
      "irl_score": 8.6,
      "execution_id": "exec-a0ba73e0-388fb624-1751263373",
      "timestamp": "2025-06-30T06:02:53.349081+00:00",
      "canon_version": "1.3.0"
    },
    "rule_zero_compliant": true
  }
]