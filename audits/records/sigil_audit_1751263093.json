[
  {
    "execution_id": "exec-90916434-a082cf5b-1751263085",
    "timestamp": "2025-06-30T05:58:05.587918+00:00",
    "sacred_chain": {
      "input_data": "kanal",
      "context_sources": [
        "crates.io",
        "github.com",
        "lib.rs",
        "docs.rs"
      ],
      "reasoning_steps": [
        "Input canonicalized: 'kanal' -> 'kanal'",
        "Context gathered from 4 validated sources",
        "Metadata extracted: 4 fields",
        "Documentation analyzed: quality 7.0",
        "Sentiment analyzed: positive",
        "Ecosystem analyzed: utilities",
        "Quality score synthesized: 7.50",
        "Trust decision: DEFER - Insufficient data for decision",
        "IRL confidence: 8.600"
      ],
      "suggestion": "ALLOW: Positive community sentiment",
      "verdict": "DEFER",
      "audit_info": {
        "metadata": {
          "name": "kanal",
          "type": "rust_crate",
          "source": "manual_input",
          "extraction_method": "irl_engine"
        },
        "sentiment": {
          "quality_score": 7.0,
          "completeness": 0.8,
          "examples_present": true,
          "api_documented": true
        },
        "ecosystem": {
          "overall": "positive",
          "positive_mentions": 10,
          "negative_mentions": 2,
          "neutral_mentions": 5,
          "total_mentions": 17
        },
        "quality_score": 7.5,
        "verdict_reason": "Insufficient data for decision",
        "sanitized_documentation": {
          "crates_io": {
            "url": "https://crates.io/crates/kanal",
            "title": "kanal v0.1.1",
            "content": {
              "raw_markdown": "#  kanal v0.1.1\nThe fast sync and async channel that Rust deserves \n  * [ #async ](https://crates.io/keywords/async)\n  * [ #channel ](https://crates.io/keywords/channel)\n  * [ #mpmc ](https://crates.io/keywords/mpmc)\n  * [ #mpsc ](https://crates.io/keywords/mpsc)\n\n\n  * [ Readme ](https://crates.io/crates/kanal)\n  * [ 12 Versions ](https://crates.io/crates/kanal/versions)\n  * [ Dependencies ](https://crates.io/crates/kanal/dependencies)\n  * [ Dependents ](https://crates.io/crates/kanal/reverse_dependencies)\n\n\n## Metadata\n3 months ago \n2021 edition \n[ MIT ](https://choosealicense.com/licenses/mit)\n29 KiB \n## Install\nRun the following Cargo command in your project directory:\ncargo add kanal\nOr add the following line to your Cargo.toml:\nkanal = \"0.1.1\"\n## Documentation\n[ docs.rs/kanal ](https://docs.rs/kanal)\n## Repository\n[ github.com/fereidani/kanal ](https://github.com/fereidani/kanal)\n## Owners\n## Categories\n  * [Asynchronous](https://crates.io/categories/asynchronous)\n  * [Concurrency](https://crates.io/categories/concurrency)\n  * [Data structures](https://crates.io/categories/data-structures)\n\n\n[ Report crate ](https://crates.io/support?crate=kanal&inquire=crate-violation)\n### Stats Overview\n1,852,517 Downloads all time\n12 Versions published\n#### Downloads over the last 90 days\nDisplay as \nStacked \n  * Stacked \n  * Unstacked \n\n\nLoading\u2026\n",
              "markdown_with_citations": "#  kanal v0.1.1\nThe fast sync and async channel that Rust deserves \n  *  #async \u27e81\u27e9\n  *  #channel \u27e82\u27e9\n  *  #mpmc \u27e83\u27e9\n  *  #mpsc \u27e84\u27e9\n\n\n  *  Readme \u27e85\u27e9\n  *  12 Versions \u27e86\u27e9\n  *  Dependencies \u27e87\u27e9\n  *  Dependents \u27e88\u27e9\n\n\n## Metadata\n3 months ago \n2021 edition \n MIT \u27e89\u27e9\n29 KiB \n## Install\nRun the following Cargo command in your project directory:\ncargo add kanal\nOr add the following line to your Cargo.toml:\nkanal = \"0.1.1\"\n## Documentation\n docs.rs/kanal \u27e810\u27e9\n## Repository\n github.com/fereidani/kanal \u27e811\u27e9\n## Owners\n## Categories\n  * Asynchronous\u27e812\u27e9\n  * Concurrency\u27e813\u27e9\n  * Data structures\u27e814\u27e9\n\n\n Report crate \u27e815\u27e9\n### Stats Overview\n1,852,517 Downloads all time\n12 Versions published\n#### Downloads over the last 90 days\nDisplay as \nStacked \n  * Stacked \n  * Unstacked \n\n\nLoading\u2026\n",
              "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://crates.io/keywords/async:  #async \n\u27e82\u27e9 https://crates.io/keywords/channel:  #channel \n\u27e83\u27e9 https://crates.io/keywords/mpmc:  #mpmc \n\u27e84\u27e9 https://crates.io/keywords/mpsc:  #mpsc \n\u27e85\u27e9 https://crates.io/crates/kanal:  Readme \n\u27e86\u27e9 https://crates.io/crates/kanal/versions:  12 Versions \n\u27e87\u27e9 https://crates.io/crates/kanal/dependencies:  Dependencies \n\u27e88\u27e9 https://crates.io/crates/kanal/reverse_dependencies:  Dependents \n\u27e89\u27e9 https://choosealicense.com/licenses/mit:  MIT \n\u27e810\u27e9 https://docs.rs/kanal:  docs.rs/kanal \n\u27e811\u27e9 https://github.com/fereidani/kanal:  github.com/fereidani/kanal \n\u27e812\u27e9 https://crates.io/categories/asynchronous: Asynchronous\n\u27e813\u27e9 https://crates.io/categories/concurrency: Concurrency\n\u27e814\u27e9 https://crates.io/categories/data-structures: Data structures\n\u27e815\u27e9 https://crates.io/support?crate=kanal&inquire=crate-violation:  Report crate \n",
              "fit_markdown": "",
              "fit_html": ""
            },
            "structured_data": {},
            "quality_score": 3.0,
            "extraction_method": "crawl4ai",
            "error": null,
            "metadata": {
              "doc_type": "docs",
              "content_length": 1361,
              "has_structured_data": false,
              "crawl_success": true
            },
            "timestamp": "116875.3192686"
          },
          "docs_rs": {
            "url": "https://docs.rs/kanal",
            "title": "Crate kanalCopy item path",
            "content": {
              "raw_markdown": "[](https://docs.rs/kanal/latest/kanal/all.html \"show sidebar\")\n# Crate kanalCopy item path\n[Settings](https://docs.rs/kanal/latest/settings.html)\n[Help](https://docs.rs/kanal/latest/help.html)\nSummary[Source](https://docs.rs/kanal/latest/src/kanal/lib.rs.html#1-1644)\nExpand description\n## [\u00a7](https://docs.rs/kanal/latest/kanal/#kanal)Kanal\n**The fast sync and async channel that Rust deserves!**\n[![Crates.io](https://img.shields.io/crates/v/kanal.svg?style=for-the-badge)](https://crates.io/crates/kanal) [![Documentation](https://img.shields.io/docsrs/kanal?style=for-the-badge)](https://docs.rs/kanal) [![MIT licensed](https://img.shields.io/badge/license-MIT-blue.svg?style=for-the-badge)](https://github.com/fereidani/kanal/blob/master/LICENSE)\n### [\u00a7](https://docs.rs/kanal/latest/kanal/#what-is-kanal)What is Kanal\nThe Kanal library is a Rust implementation of channels inspired by the CSP (Communicating Sequential Processes) model. It aims to help programmers create efficient concurrent programs by providing multi-producer and multi-consumer channels with advanced features for fast communication. The library focuses on unifying message passing between synchronous and asynchronous parts of Rust code, offering a combination of synchronous and asynchronous APIs while maintaining high performance.\n### [\u00a7](https://docs.rs/kanal/latest/kanal/#why-kanal-is-faster)Why Kanal is faster?\n  1. Kanal employs a highly optimized composite technique for the transfer of objects. When the data size is less than or equal to the pointer size, it utilizes serialization, encoding the data as the pointer address. Conversely, when the data size exceeds the pointer size, the protocol employs a strategy similar to that utilized by the Golang programming language, utilizing direct memory access to copy objects from the sender\u2019s stack or write directly to the receiver\u2019s stack. This composite method not only eliminates unnecessary pointer access but also eliminates heap allocations for bounded(0) channels.\n  2. Kanal utilizes a specially tuned mutex for its channel locking mechanism, made possible by the predictable internal lock time of the channel. That said it\u2019s possible to use Rust standard mutex with the `std-mutex` feature and Kanal will perform better than competitors with that feature too.\n  3. Utilizing Rust high-performance compiler and powerful LLVM backend with highly optimized memory access and deeply thought algorithms.\n\n\n### [\u00a7](https://docs.rs/kanal/latest/kanal/#usage)Usage\nTo use Kanal in your Rust project, add the following line to your `Cargo.toml` file:\n```\n[dependencies]\nkanal = \"0.1\"\n```\n\nSync channel example:\n[\u24d8](https://docs.rs/kanal/latest/kanal/ \"This example is not tested\")```\n// Initialize a bounded sync channel with a capacity for 8 messages\nlet (sender, receiver) = kanal::bounded(8);\nlet s = sender.clone();\nstd::thread::spawn(move || {\n  s.send(\"hello\")?;\n  anyhow::Ok(())\n});\n// Receive an example message in another thread\nlet msg = receiver.recv()?;\nprintln!(\"I got msg: {}\", msg);\n\n// Convert and use channel in async context to communicate between sync and async\ntokio::spawn(async move {\n  // Borrow the channel as an async channel and use it in an async context ( or convert it to async using to_async() )\n  sender.as_async().send(\"hello\").await?;\n  anyhow::Ok(())\n});\n```\n\nAsync channel example:\n[\u24d8](https://docs.rs/kanal/latest/kanal/ \"This example is not tested\")```\n// Initialize a bounded channel with a capacity for 8 messages\nlet (sender, receiver) = kanal::bounded_async(8);\nsender.send(\"hello\").await?;\nsender.send(\"hello\").await?;\n// Clone receiver and convert it to a sync receiver\nlet receiver_sync = receiver.clone().to_sync();\ntokio::spawn(async move {\n  let msg = receiver.recv().await?;\n  println!(\"I got msg: {}\", msg);\n  anyhow::Ok(())\n});\n// Spawn a thread and use receiver in sync context\nstd::thread::spawn(move || {\n  let msg = receiver_sync.recv()?;\n  println!(\"I got msg in sync context: {}\", msg);\n  anyhow::Ok(())\n});\n```\n\n### [\u00a7](https://docs.rs/kanal/latest/kanal/#why-use-kanal)Why use Kanal?\n  * Kanal offers fast and efficient communication capabilities.\n  * Kanal simplifies communication in and between synchronous and asynchronous contexts, thanks to its flexible API like `as_sync` and `as_async`.\n  * Kanal provides a clean and intuitive API, making it easier to work with compared to other Rust libraries.\n  * Similar to Golang, Kanal allows you to close channels using the `Close` function, enabling you to broadcast a close signal from any channel instance and close the channel for both senders and receivers.\n  * Kanal includes high-performance MPMC (Multiple Producers Multiple Consumers) and SPSC (Single Producer Single Consumer) channels in a single package.\n\n\n#### [\u00a7](https://docs.rs/kanal/latest/kanal/#benchmark-results)Benchmark Results\nResults are based on how many messages can be passed in each scenario per second.\n##### [\u00a7](https://docs.rs/kanal/latest/kanal/#test-types)Test types:\n  1. Seq is sequentially writing and reading to a channel in the same thread.\n  2. SPSC is one receiver, and one sender and passing messages between them.\n  3. MPSC is multiple sender threads with only one receiver.\n  4. MPMC is multiple senders and multiple receivers communicating through the same channel.\n\n\n##### [\u00a7](https://docs.rs/kanal/latest/kanal/#message-types)Message types:\n  1. `usize` tests are transferring messages of size hardware pointer.\n  2. `big` tests are transferring messages of 8x the size of the hardware pointer.\n\n\nN/A means that the test subject is unable to perform the test due to its limitations, Some of the test subjects don\u2019t have implementation for size 0 channels, MPMC or unbounded channels.\nMachine: `AMD Ryzen 9 9950X 16-Core Processor` Rust: `rustc 1.85.1 (4eb161250 2025-03-15)` Go: `go version go1.24.1 linux/amd64` OS (`uname -a`): `Linux 6.11.0-19-generic #19~24.04.1-Ubuntu SMP PREEMPT_DYNAMIC Mon Feb 17 11:51:52 UTC 2 x86_64` Date: Mar 19, 2025\n[Benchmark codes](https://github.com/fereidani/rust-channel-benchmarks)\n![Benchmarks](https://i.imgur.com/VPwyam0.png)\n##### [\u00a7](https://docs.rs/kanal/latest/kanal/#why-does-async-outperform-sync-in-some-tests)Why does async outperform sync in some tests?\nIn certain tests, asynchronous communication may exhibit superior performance compared to synchronous communication. This can be attributed to the context-switching performance of libraries such as tokio, which, similar to Golang, utilize context-switching within the same thread to switch to the next coroutine when a message is ready on a channel. This approach is more efficient than communicating between separate threads. This same principle applies to asynchronous network applications, which generally exhibit better performance compared to synchronous implementations. As the channel size increases, one may observe improved performance in synchronous benchmarks, as the sending threads are able to push data directly to the channel queue without requiring awaiting blocking/suspending signals from receiving threads.\n## Structs[\u00a7](https://docs.rs/kanal/latest/kanal/#structs)\n\n[AsyncReceiver](https://docs.rs/kanal/latest/kanal/struct.AsyncReceiver.html \"struct kanal::AsyncReceiver\")\n    [`AsyncReceiver`](https://docs.rs/kanal/latest/kanal/struct.AsyncReceiver.html \"struct kanal::AsyncReceiver\") is receiving side of the channel in async mode. Receivers can be cloned and produce receivers to operate in both sync and async modes.\n\n[AsyncSender](https://docs.rs/kanal/latest/kanal/struct.AsyncSender.html \"struct kanal::AsyncSender\")\n    Sending side of the channel with async API. It\u2019s possible to convert it to sync [`Sender`](https://docs.rs/kanal/latest/kanal/struct.Sender.html \"struct kanal::Sender\") with `as_sync`, `to_sync` or `clone_sync` based on software requirement.\n\n[CloseError](https://docs.rs/kanal/latest/kanal/struct.CloseError.html \"struct kanal::CloseError\")\n    Error type for closing a channel when channel is already closed\n\n[ReceiveFuture](https://docs.rs/kanal/latest/kanal/struct.ReceiveFuture.html \"struct kanal::ReceiveFuture\")\n    ReceiveFuture is a future for receiving an object from a channel asynchronously. It must be polled to complete the receive operation.\n\n[ReceiveStream](https://docs.rs/kanal/latest/kanal/struct.ReceiveStream.html \"struct kanal::ReceiveStream\")\n    ReceiveStream is a stream for receiving objects from a channel asynchronously.\n\n[Receiver](https://docs.rs/kanal/latest/kanal/struct.Receiver.html \"struct kanal::Receiver\")\n    Receiving side of the channel in sync mode. Receivers can be cloned and produce receivers to operate in both sync and async modes.\n\n[SendFuture](https://docs.rs/kanal/latest/kanal/struct.SendFuture.html \"struct kanal::SendFuture\")\n    SendFuture is a future for sending an object to a channel asynchronously. It must be polled to complete the send operation.\n\n[Sender](https://docs.rs/kanal/latest/kanal/struct.Sender.html \"struct kanal::Sender\")\n    Sending side of the channel with sync API. It\u2019s possible to convert it to async [`AsyncSender`](https://docs.rs/kanal/latest/kanal/struct.AsyncSender.html \"struct kanal::AsyncSender\") with `as_async`, `to_async` or `clone_async` based on software requirement.\n## Enums[\u00a7](https://docs.rs/kanal/latest/kanal/#enums)\n\n[ReceiveError](https://docs.rs/kanal/latest/kanal/enum.ReceiveError.html \"enum kanal::ReceiveError\")\n    Error type for channel receive operations without timeout\n\n[ReceiveErrorTimeout](https://docs.rs/kanal/latest/kanal/enum.ReceiveErrorTimeout.html \"enum kanal::ReceiveErrorTimeout\")\n    Error type for channel receive operations with timeout\n\n[SendError](https://docs.rs/kanal/latest/kanal/enum.SendError.html \"enum kanal::SendError\")\n    Error type for channel send operations without timeout\n\n[SendErrorTimeout](https://docs.rs/kanal/latest/kanal/enum.SendErrorTimeout.html \"enum kanal::SendErrorTimeout\")\n    Error type for channel send operations with timeout\n## Functions[\u00a7](https://docs.rs/kanal/latest/kanal/#functions)\n\n[bounded](https://docs.rs/kanal/latest/kanal/fn.bounded.html \"fn kanal::bounded\")\n    Creates a new sync bounded channel with the requested buffer size, and returns [`Sender`](https://docs.rs/kanal/latest/kanal/struct.Sender.html \"struct kanal::Sender\") and [`Receiver`](https://docs.rs/kanal/latest/kanal/struct.Receiver.html \"struct kanal::Receiver\") of the channel for type T, you can get access to async API of [`AsyncSender`](https://docs.rs/kanal/latest/kanal/struct.AsyncSender.html \"struct kanal::AsyncSender\") and [`AsyncReceiver`](https://docs.rs/kanal/latest/kanal/struct.AsyncReceiver.html \"struct kanal::AsyncReceiver\") with `to_sync`, `as_async` or `clone_sync` based on your requirements, by calling them on sender or receiver.\n\n[bounded_async](https://docs.rs/kanal/latest/kanal/fn.bounded_async.html \"fn kanal::bounded_async\")\n    Creates a new async bounded channel with the requested buffer size, and returns [`AsyncSender`](https://docs.rs/kanal/latest/kanal/struct.AsyncSender.html \"struct kanal::AsyncSender\") and [`AsyncReceiver`](https://docs.rs/kanal/latest/kanal/struct.AsyncReceiver.html \"struct kanal::AsyncReceiver\") of the channel for type T, you can get access to sync API of [`Sender`](https://docs.rs/kanal/latest/kanal/struct.Sender.html \"struct kanal::Sender\") and [`Receiver`](https://docs.rs/kanal/latest/kanal/struct.Receiver.html \"struct kanal::Receiver\") with `to_sync`, `as_async` or `clone_sync` based on your requirements, by calling them on async sender or receiver.\n\n[unbounded](https://docs.rs/kanal/latest/kanal/fn.unbounded.html \"fn kanal::unbounded\")\n    Creates a new sync unbounded channel, and returns [`Sender`](https://docs.rs/kanal/latest/kanal/struct.Sender.html \"struct kanal::Sender\") and [`Receiver`](https://docs.rs/kanal/latest/kanal/struct.Receiver.html \"struct kanal::Receiver\") of the channel for type T, you can get access to async API of [`AsyncSender`](https://docs.rs/kanal/latest/kanal/struct.AsyncSender.html \"struct kanal::AsyncSender\") and [`AsyncReceiver`](https://docs.rs/kanal/latest/kanal/struct.AsyncReceiver.html \"struct kanal::AsyncReceiver\") with `to_sync`, `as_async` or `clone_sync` based on your requirements, by calling them on sender or receiver.\n\n[unbounded_async](https://docs.rs/kanal/latest/kanal/fn.unbounded_async.html \"fn kanal::unbounded_async\")\n    Creates a new async unbounded channel, and returns [`AsyncSender`](https://docs.rs/kanal/latest/kanal/struct.AsyncSender.html \"struct kanal::AsyncSender\") and [`AsyncReceiver`](https://docs.rs/kanal/latest/kanal/struct.AsyncReceiver.html \"struct kanal::AsyncReceiver\") of the channel for type T, you can get access to sync API of [`Sender`](https://docs.rs/kanal/latest/kanal/struct.Sender.html \"struct kanal::Sender\") and [`Receiver`](https://docs.rs/kanal/latest/kanal/struct.Receiver.html \"struct kanal::Receiver\") with `to_sync`, `as_async` or `clone_sync` based on your requirements, by calling them on async sender or receiver.\n",
              "markdown_with_citations": "[](https://docs.rs/kanal/latest/kanal/all.html \"show sidebar\")\n# Crate kanalCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\n## \u00a7\u27e84\u27e9Kanal\n**The fast sync and async channel that Rust deserves!**\n![Crates.io\u27e85\u27e9](https://crates.io/crates/kanal) ![Documentation\u27e86\u27e9](https://docs.rs/kanal) ![MIT licensed\u27e87\u27e9](https://github.com/fereidani/kanal/blob/master/LICENSE)\n### \u00a7\u27e88\u27e9What is Kanal\nThe Kanal library is a Rust implementation of channels inspired by the CSP (Communicating Sequential Processes) model. It aims to help programmers create efficient concurrent programs by providing multi-producer and multi-consumer channels with advanced features for fast communication. The library focuses on unifying message passing between synchronous and asynchronous parts of Rust code, offering a combination of synchronous and asynchronous APIs while maintaining high performance.\n### \u00a7\u27e89\u27e9Why Kanal is faster?\n  1. Kanal employs a highly optimized composite technique for the transfer of objects. When the data size is less than or equal to the pointer size, it utilizes serialization, encoding the data as the pointer address. Conversely, when the data size exceeds the pointer size, the protocol employs a strategy similar to that utilized by the Golang programming language, utilizing direct memory access to copy objects from the sender\u2019s stack or write directly to the receiver\u2019s stack. This composite method not only eliminates unnecessary pointer access but also eliminates heap allocations for bounded(0) channels.\n  2. Kanal utilizes a specially tuned mutex for its channel locking mechanism, made possible by the predictable internal lock time of the channel. That said it\u2019s possible to use Rust standard mutex with the `std-mutex` feature and Kanal will perform better than competitors with that feature too.\n  3. Utilizing Rust high-performance compiler and powerful LLVM backend with highly optimized memory access and deeply thought algorithms.\n\n\n### \u00a7\u27e810\u27e9Usage\nTo use Kanal in your Rust project, add the following line to your `Cargo.toml` file:\n```\n[dependencies]\nkanal = \"0.1\"\n```\n\nSync channel example:\n\u24d8\u27e811\u27e9```\n// Initialize a bounded sync channel with a capacity for 8 messages\nlet (sender, receiver) = kanal::bounded(8);\nlet s = sender.clone();\nstd::thread::spawn(move || {\n  s.send(\"hello\")?;\n  anyhow::Ok(())\n});\n// Receive an example message in another thread\nlet msg = receiver.recv()?;\nprintln!(\"I got msg: {}\", msg);\n\n// Convert and use channel in async context to communicate between sync and async\ntokio::spawn(async move {\n  // Borrow the channel as an async channel and use it in an async context ( or convert it to async using to_async() )\n  sender.as_async().send(\"hello\").await?;\n  anyhow::Ok(())\n});\n```\n\nAsync channel example:\n\u24d8\u27e811\u27e9```\n// Initialize a bounded channel with a capacity for 8 messages\nlet (sender, receiver) = kanal::bounded_async(8);\nsender.send(\"hello\").await?;\nsender.send(\"hello\").await?;\n// Clone receiver and convert it to a sync receiver\nlet receiver_sync = receiver.clone().to_sync();\ntokio::spawn(async move {\n  let msg = receiver.recv().await?;\n  println!(\"I got msg: {}\", msg);\n  anyhow::Ok(())\n});\n// Spawn a thread and use receiver in sync context\nstd::thread::spawn(move || {\n  let msg = receiver_sync.recv()?;\n  println!(\"I got msg in sync context: {}\", msg);\n  anyhow::Ok(())\n});\n```\n\n### \u00a7\u27e812\u27e9Why use Kanal?\n  * Kanal offers fast and efficient communication capabilities.\n  * Kanal simplifies communication in and between synchronous and asynchronous contexts, thanks to its flexible API like `as_sync` and `as_async`.\n  * Kanal provides a clean and intuitive API, making it easier to work with compared to other Rust libraries.\n  * Similar to Golang, Kanal allows you to close channels using the `Close` function, enabling you to broadcast a close signal from any channel instance and close the channel for both senders and receivers.\n  * Kanal includes high-performance MPMC (Multiple Producers Multiple Consumers) and SPSC (Single Producer Single Consumer) channels in a single package.\n\n\n#### \u00a7\u27e813\u27e9Benchmark Results\nResults are based on how many messages can be passed in each scenario per second.\n##### \u00a7\u27e814\u27e9Test types:\n  1. Seq is sequentially writing and reading to a channel in the same thread.\n  2. SPSC is one receiver, and one sender and passing messages between them.\n  3. MPSC is multiple sender threads with only one receiver.\n  4. MPMC is multiple senders and multiple receivers communicating through the same channel.\n\n\n##### \u00a7\u27e815\u27e9Message types:\n  1. `usize` tests are transferring messages of size hardware pointer.\n  2. `big` tests are transferring messages of 8x the size of the hardware pointer.\n\n\nN/A means that the test subject is unable to perform the test due to its limitations, Some of the test subjects don\u2019t have implementation for size 0 channels, MPMC or unbounded channels.\nMachine: `AMD Ryzen 9 9950X 16-Core Processor` Rust: `rustc 1.85.1 (4eb161250 2025-03-15)` Go: `go version go1.24.1 linux/amd64` OS (`uname -a`): `Linux 6.11.0-19-generic #19~24.04.1-Ubuntu SMP PREEMPT_DYNAMIC Mon Feb 17 11:51:52 UTC 2 x86_64` Date: Mar 19, 2025\nBenchmark codes\u27e816\u27e9\n![Benchmarks\u27e817\u27e9]\n##### \u00a7\u27e818\u27e9Why does async outperform sync in some tests?\nIn certain tests, asynchronous communication may exhibit superior performance compared to synchronous communication. This can be attributed to the context-switching performance of libraries such as tokio, which, similar to Golang, utilize context-switching within the same thread to switch to the next coroutine when a message is ready on a channel. This approach is more efficient than communicating between separate threads. This same principle applies to asynchronous network applications, which generally exhibit better performance compared to synchronous implementations. As the channel size increases, one may observe improved performance in synchronous benchmarks, as the sending threads are able to push data directly to the channel queue without requiring awaiting blocking/suspending signals from receiving threads.\n## Structs\u00a7\u27e819\u27e9\n\nAsyncReceiver\u27e820\u27e9\n    `AsyncReceiver`\u27e820\u27e9 is receiving side of the channel in async mode. Receivers can be cloned and produce receivers to operate in both sync and async modes.\n\nAsyncSender\u27e821\u27e9\n    Sending side of the channel with async API. It\u2019s possible to convert it to sync `Sender`\u27e822\u27e9 with `as_sync`, `to_sync` or `clone_sync` based on software requirement.\n\nCloseError\u27e823\u27e9\n    Error type for closing a channel when channel is already closed\n\nReceiveFuture\u27e824\u27e9\n    ReceiveFuture is a future for receiving an object from a channel asynchronously. It must be polled to complete the receive operation.\n\nReceiveStream\u27e825\u27e9\n    ReceiveStream is a stream for receiving objects from a channel asynchronously.\n\nReceiver\u27e826\u27e9\n    Receiving side of the channel in sync mode. Receivers can be cloned and produce receivers to operate in both sync and async modes.\n\nSendFuture\u27e827\u27e9\n    SendFuture is a future for sending an object to a channel asynchronously. It must be polled to complete the send operation.\n\nSender\u27e822\u27e9\n    Sending side of the channel with sync API. It\u2019s possible to convert it to async `AsyncSender`\u27e821\u27e9 with `as_async`, `to_async` or `clone_async` based on software requirement.\n## Enums\u00a7\u27e828\u27e9\n\nReceiveError\u27e829\u27e9\n    Error type for channel receive operations without timeout\n\nReceiveErrorTimeout\u27e830\u27e9\n    Error type for channel receive operations with timeout\n\nSendError\u27e831\u27e9\n    Error type for channel send operations without timeout\n\nSendErrorTimeout\u27e832\u27e9\n    Error type for channel send operations with timeout\n## Functions\u00a7\u27e833\u27e9\n\nbounded\u27e834\u27e9\n    Creates a new sync bounded channel with the requested buffer size, and returns `Sender`\u27e822\u27e9 and `Receiver`\u27e826\u27e9 of the channel for type T, you can get access to async API of `AsyncSender`\u27e821\u27e9 and `AsyncReceiver`\u27e820\u27e9 with `to_sync`, `as_async` or `clone_sync` based on your requirements, by calling them on sender or receiver.\n\nbounded_async\u27e835\u27e9\n    Creates a new async bounded channel with the requested buffer size, and returns `AsyncSender`\u27e821\u27e9 and `AsyncReceiver`\u27e820\u27e9 of the channel for type T, you can get access to sync API of `Sender`\u27e822\u27e9 and `Receiver`\u27e826\u27e9 with `to_sync`, `as_async` or `clone_sync` based on your requirements, by calling them on async sender or receiver.\n\nunbounded\u27e836\u27e9\n    Creates a new sync unbounded channel, and returns `Sender`\u27e822\u27e9 and `Receiver`\u27e826\u27e9 of the channel for type T, you can get access to async API of `AsyncSender`\u27e821\u27e9 and `AsyncReceiver`\u27e820\u27e9 with `to_sync`, `as_async` or `clone_sync` based on your requirements, by calling them on sender or receiver.\n\nunbounded_async\u27e837\u27e9\n    Creates a new async unbounded channel, and returns `AsyncSender`\u27e821\u27e9 and `AsyncReceiver`\u27e820\u27e9 of the channel for type T, you can get access to sync API of `Sender`\u27e822\u27e9 and `Receiver`\u27e826\u27e9 with `to_sync`, `as_async` or `clone_sync` based on your requirements, by calling them on async sender or receiver.\n",
              "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/kanal/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/kanal/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/kanal/latest/src/kanal/lib.rs.html#1-1644: Source\n\u27e84\u27e9 https://docs.rs/kanal/latest/kanal/#kanal: \u00a7\n\u27e85\u27e9 https://img.shields.io/crates/v/kanal.svg?style=for-the-badge: ![Crates.io\n\u27e86\u27e9 https://img.shields.io/docsrs/kanal?style=for-the-badge: ![Documentation\n\u27e87\u27e9 https://img.shields.io/badge/license-MIT-blue.svg?style=for-the-badge: ![MIT licensed\n\u27e88\u27e9 https://docs.rs/kanal/latest/kanal/#what-is-kanal: \u00a7\n\u27e89\u27e9 https://docs.rs/kanal/latest/kanal/#why-kanal-is-faster: \u00a7\n\u27e810\u27e9 https://docs.rs/kanal/latest/kanal/#usage: \u00a7\n\u27e811\u27e9 https://docs.rs/kanal/latest/kanal/: This example is not tested - \u24d8\n\u27e812\u27e9 https://docs.rs/kanal/latest/kanal/#why-use-kanal: \u00a7\n\u27e813\u27e9 https://docs.rs/kanal/latest/kanal/#benchmark-results: \u00a7\n\u27e814\u27e9 https://docs.rs/kanal/latest/kanal/#test-types: \u00a7\n\u27e815\u27e9 https://docs.rs/kanal/latest/kanal/#message-types: \u00a7\n\u27e816\u27e9 https://github.com/fereidani/rust-channel-benchmarks: Benchmark codes\n\u27e817\u27e9 https://i.imgur.com/VPwyam0.png: Benchmarks\n\u27e818\u27e9 https://docs.rs/kanal/latest/kanal/#why-does-async-outperform-sync-in-some-tests: \u00a7\n\u27e819\u27e9 https://docs.rs/kanal/latest/kanal/#structs: \u00a7\n\u27e820\u27e9 https://docs.rs/kanal/latest/kanal/struct.AsyncReceiver.html: struct kanal::AsyncReceiver - AsyncReceiver\n\u27e821\u27e9 https://docs.rs/kanal/latest/kanal/struct.AsyncSender.html: struct kanal::AsyncSender - AsyncSender\n\u27e822\u27e9 https://docs.rs/kanal/latest/kanal/struct.Sender.html: struct kanal::Sender - `Sender`\n\u27e823\u27e9 https://docs.rs/kanal/latest/kanal/struct.CloseError.html: struct kanal::CloseError - CloseError\n\u27e824\u27e9 https://docs.rs/kanal/latest/kanal/struct.ReceiveFuture.html: struct kanal::ReceiveFuture - ReceiveFuture\n\u27e825\u27e9 https://docs.rs/kanal/latest/kanal/struct.ReceiveStream.html: struct kanal::ReceiveStream - ReceiveStream\n\u27e826\u27e9 https://docs.rs/kanal/latest/kanal/struct.Receiver.html: struct kanal::Receiver - Receiver\n\u27e827\u27e9 https://docs.rs/kanal/latest/kanal/struct.SendFuture.html: struct kanal::SendFuture - SendFuture\n\u27e828\u27e9 https://docs.rs/kanal/latest/kanal/#enums: \u00a7\n\u27e829\u27e9 https://docs.rs/kanal/latest/kanal/enum.ReceiveError.html: enum kanal::ReceiveError - ReceiveError\n\u27e830\u27e9 https://docs.rs/kanal/latest/kanal/enum.ReceiveErrorTimeout.html: enum kanal::ReceiveErrorTimeout - ReceiveErrorTimeout\n\u27e831\u27e9 https://docs.rs/kanal/latest/kanal/enum.SendError.html: enum kanal::SendError - SendError\n\u27e832\u27e9 https://docs.rs/kanal/latest/kanal/enum.SendErrorTimeout.html: enum kanal::SendErrorTimeout - SendErrorTimeout\n\u27e833\u27e9 https://docs.rs/kanal/latest/kanal/#functions: \u00a7\n\u27e834\u27e9 https://docs.rs/kanal/latest/kanal/fn.bounded.html: fn kanal::bounded - bounded\n\u27e835\u27e9 https://docs.rs/kanal/latest/kanal/fn.bounded_async.html: fn kanal::bounded_async - bounded_async\n\u27e836\u27e9 https://docs.rs/kanal/latest/kanal/fn.unbounded.html: fn kanal::unbounded - unbounded\n\u27e837\u27e9 https://docs.rs/kanal/latest/kanal/fn.unbounded_async.html: fn kanal::unbounded_async - unbounded_async\n",
              "fit_markdown": "",
              "fit_html": ""
            },
            "structured_data": {},
            "quality_score": 4.0,
            "extraction_method": "crawl4ai",
            "error": null,
            "metadata": {
              "doc_type": "docs",
              "content_length": 13016,
              "has_structured_data": false,
              "crawl_success": true
            },
            "timestamp": "116876.1141296"
          },
          "lib_rs": {
            "url": "https://lib.rs/crates/kanal",
            "title": "Untitled",
            "content": {
              "raw_markdown": "###  [12 releases](https://lib.rs/crates/kanal/versions)\n0.1.1 |  Mar 23, 2025   \n---|---  \n0.1.0 |  Mar 19, 2025   \n0.1.0-pre8 |  Jan 25, 2023   \n0.1.0-pre7 |  Nov 13, 2022   \n0.1.0-beta2 |  Jul 15, 2022   \n#**18** in [Concurrency](https://lib.rs/concurrency \"Crates for implementing concurrent and parallel computation.\")\nDownload history 26623/week @ 2025-03-08 26905/week @ 2025-03-15 32498/week @ 2025-03-22 27272/week @ 2025-03-29 30978/week @ 2025-04-05 23462/week @ 2025-04-12 32179/week @ 2025-04-19 28618/week @ 2025-04-26 30790/week @ 2025-05-03 30431/week @ 2025-05-10 30010/week @ 2025-05-17 25343/week @ 2025-05-24 32216/week @ 2025-05-31 31486/week @ 2025-06-07 30816/week @ 2025-06-14 24480/week @ 2025-06-21\n**123,845** downloads per month Used in [**67** crates (58 directly)](https://lib.rs/crates/kanal/rev)\n**MIT** license \n115KB  2K  SLoC\n# Kanal\n**The fast sync and async channel that Rust deserves!**\n[![Crates.io](https://img.shields.io/crates/v/kanal.svg?style=for-the-badge)](https://crates.io/crates/kanal) [![Documentation](https://img.shields.io/docsrs/kanal?style=for-the-badge)](https://docs.rs/kanal) [![MIT licensed](https://img.shields.io/badge/license-MIT-blue.svg?style=for-the-badge)](https://github.com/fereidani/kanal/blob/master/LICENSE)\n## What is Kanal\nThe Kanal library is a Rust implementation of channels inspired by the CSP (Communicating Sequential Processes) model. It aims to help programmers create efficient concurrent programs by providing multi-producer and multi-consumer channels with advanced features for fast communication. The library focuses on unifying message passing between synchronous and asynchronous parts of Rust code, offering a combination of synchronous and asynchronous APIs while maintaining high performance.\n## Why Kanal is faster?\n  1. Kanal employs a highly optimized composite technique for the transfer of objects. When the data size is less than or equal to the pointer size, it utilizes serialization, encoding the data as the pointer address. Conversely, when the data size exceeds the pointer size, the protocol employs a strategy similar to that utilized by the Golang programming language, utilizing direct memory access to copy objects from the sender's stack or write directly to the receiver's stack. This composite method not only eliminates unnecessary pointer access but also eliminates heap allocations for bounded(0) channels.\n  2. Kanal utilizes a specially tuned mutex for its channel locking mechanism, made possible by the predictable internal lock time of the channel. That said it's possible to use Rust standard mutex with the ``std-mutex`` feature and Kanal will perform better than competitors with that feature too.\n  3. Utilizing Rust high-performance compiler and powerful LLVM backend with highly optimized memory access and deeply thought algorithms.\n\n\n## Usage\nTo use Kanal in your Rust project, add the following line to your ``Cargo.toml`` file:\n```\n```[``dependencies``]`\n`kanal ``=` ``\"`0.1`\"``\n``\n```\n\nSync channel example:\n```\n```//` Initialize a bounded sync channel with a capacity for 8 messages`\n`let` `(`sender`,` receiver`)` `=` `kanal`::``bounded`(``8``)``;`\n`let` s `=` sender`.``clone``(``)``;`\n`std`::```thread`::``spawn`(``move` `||` ``{`\n  s`.``send``(```\"`hello`\"```)``?``;`\n  `anyhow`::``Ok`(``(``)``)`\n```}```)``;`\n``//` Receive an example message in another thread`\n`let` msg `=` receiver`.``recv``(``)``?``;`\n`println!``(```\"`I got msg: `{}``\"```,` msg`)``;`\n\n``//` Convert and use channel in async context to communicate between sync and async`\n`tokio`::``spawn`(`async `move` ``{`\n  ``//` Borrow the channel as an async channel and use it in an async context ( or convert it to async using to_async() )`\n  sender`.``as_async``(``)``.``send``(```\"`hello`\"```)``.`await`?``;`\n  `anyhow`::``Ok`(``(``)``)`\n```}```)``;`\n`\n```\n\nAsync channel example:\n```\n```//` Initialize a bounded channel with a capacity for 8 messages`\n`let` `(`sender`,` receiver`)` `=` `kanal`::``bounded_async`(``8``)``;`\nsender`.``send``(```\"`hello`\"```)``.`await`?``;`\nsender`.``send``(```\"`hello`\"```)``.`await`?``;`\n``//` Clone receiver and convert it to a sync receiver`\n`let` receiver_sync `=` receiver`.``clone``(``)``.``to_sync``(``)``;`\n`tokio`::``spawn`(`async `move` ``{`\n  `let` msg `=` receiver`.``recv``(``)``.`await`?``;`\n  `println!``(```\"`I got msg: `{}``\"```,` msg`)``;`\n  `anyhow`::``Ok`(``(``)``)`\n```}```)``;`\n``//` Spawn a thread and use receiver in sync context`\n`std`::```thread`::``spawn`(``move` `||` ``{`\n  `let` msg `=` receiver_sync`.``recv``(``)``?``;`\n  `println!``(```\"`I got msg in sync context: `{}``\"```,` msg`)``;`\n  `anyhow`::``Ok`(``(``)``)`\n```}```)``;`\n`\n```\n\n## Why use Kanal?\n  * Kanal offers fast and efficient communication capabilities.\n  * Kanal simplifies communication in and between synchronous and asynchronous contexts, thanks to its flexible API like ``as_sync`` and ``as_async``.\n  * Kanal provides a clean and intuitive API, making it easier to work with compared to other Rust libraries.\n  * Similar to Golang, Kanal allows you to close channels using the ``Close`` function, enabling you to broadcast a close signal from any channel instance and close the channel for both senders and receivers.\n  * Kanal includes high-performance MPMC (Multiple Producers Multiple Consumers) and SPSC (Single Producer Single Consumer) channels in a single package.\n\n\n### Benchmark Results\nResults are based on how many messages can be passed in each scenario per second.\n#### Test types:\n  1. Seq is sequentially writing and reading to a channel in the same thread.\n  2. SPSC is one receiver, and one sender and passing messages between them.\n  3. MPSC is multiple sender threads with only one receiver.\n  4. MPMC is multiple senders and multiple receivers communicating through the same channel.\n\n\n#### Message types:\n  1. ```usize``` tests are transferring messages of size hardware pointer.\n  2. ``big`` tests are transferring messages of 8x the size of the hardware pointer.\n\n\nN/A means that the test subject is unable to perform the test due to its limitations, Some of the test subjects don't have implementation for size 0 channels, MPMC or unbounded channels.\nMachine: ```AMD` Ryzen `9` 9950X `16``-`Core Processor`` Rust: ``rustc `1.``85``.``1` `(`4eb161250 `2025``-``03``-``15``)``` Go: ``go version go1`.``24.``1` linux`/`amd64`` OS (``uname `-`a``): ``Linux `6.``11``.``0``-``19``-`generic `#``19``~``24.``04``.``1``-`Ubuntu `SMP` `PREEMPT_DYNAMIC` Mon Feb `17` `11``:``51``:``52` `UTC` `2` x86_64`` Date: Mar 19, 2025\n[Benchmark codes](https://github.com/fereidani/rust-channel-benchmarks)\n![Benchmarks](https://img.gs/czjpqfbdkz/800,2x/https://i.imgur.com/VPwyam0.png)\n#### Why does async outperform sync in some tests?\nIn certain tests, asynchronous communication may exhibit superior performance compared to synchronous communication. This can be attributed to the context-switching performance of libraries such as tokio, which, similar to Golang, utilize context-switching within the same thread to switch to the next coroutine when a message is ready on a channel. This approach is more efficient than communicating between separate threads. This same principle applies to asynchronous network applications, which generally exhibit better performance compared to synchronous implementations. As the channel size increases, one may observe improved performance in synchronous benchmarks, as the sending threads are able to push data directly to the channel queue without requiring awaiting blocking/suspending signals from receiving threads.\n#### Dependencies\n~160KB \n  * [async](https://lib.rs/crates/kanal/features#feature-async \"default feature\") [futures-core](https://lib.rs/crates/futures-core \"0.3\")\n  * [lock_api](https://lib.rs/crates/lock_api \"0.4\")\n\n\n  * dev  [anyhow](https://lib.rs/crates/anyhow \"1.0\")\n  * dev  [crossbeam](https://lib.rs/crates/crossbeam \"0.8\")\n  * dev  [futures](https://lib.rs/crates/futures \"0.3\")\n  * dev  [tokio](https://lib.rs/crates/tokio \"1\")[+rt-multi-thread](https://lib.rs/crates/tokio/features#feature-rt-multi-thread)[+test-util](https://lib.rs/crates/tokio/features#feature-test-util)[+macros](https://lib.rs/crates/tokio/features#feature-macros)\n\n\n#### [Other feature](https://lib.rs/crates/kanal/features)\n  * [std-mutex](https://lib.rs/crates/kanal/features#feature-std-mutex)\n\n\n  *[SLoC]: Lines of code, excluding comments\n",
              "markdown_with_citations": "###  12 releases\u27e81\u27e9\n0.1.1 |  Mar 23, 2025   \n---|---  \n0.1.0 |  Mar 19, 2025   \n0.1.0-pre8 |  Jan 25, 2023   \n0.1.0-pre7 |  Nov 13, 2022   \n0.1.0-beta2 |  Jul 15, 2022   \n#**18** in Concurrency\u27e82\u27e9\nDownload history 26623/week @ 2025-03-08 26905/week @ 2025-03-15 32498/week @ 2025-03-22 27272/week @ 2025-03-29 30978/week @ 2025-04-05 23462/week @ 2025-04-12 32179/week @ 2025-04-19 28618/week @ 2025-04-26 30790/week @ 2025-05-03 30431/week @ 2025-05-10 30010/week @ 2025-05-17 25343/week @ 2025-05-24 32216/week @ 2025-05-31 31486/week @ 2025-06-07 30816/week @ 2025-06-14 24480/week @ 2025-06-21\n**123,845** downloads per month Used in **67** crates (58 directly)\u27e83\u27e9\n**MIT** license \n115KB  2K  SLoC\n# Kanal\n**The fast sync and async channel that Rust deserves!**\n![Crates.io\u27e84\u27e9](https://crates.io/crates/kanal) ![Documentation\u27e85\u27e9](https://docs.rs/kanal) ![MIT licensed\u27e86\u27e9](https://github.com/fereidani/kanal/blob/master/LICENSE)\n## What is Kanal\nThe Kanal library is a Rust implementation of channels inspired by the CSP (Communicating Sequential Processes) model. It aims to help programmers create efficient concurrent programs by providing multi-producer and multi-consumer channels with advanced features for fast communication. The library focuses on unifying message passing between synchronous and asynchronous parts of Rust code, offering a combination of synchronous and asynchronous APIs while maintaining high performance.\n## Why Kanal is faster?\n  1. Kanal employs a highly optimized composite technique for the transfer of objects. When the data size is less than or equal to the pointer size, it utilizes serialization, encoding the data as the pointer address. Conversely, when the data size exceeds the pointer size, the protocol employs a strategy similar to that utilized by the Golang programming language, utilizing direct memory access to copy objects from the sender's stack or write directly to the receiver's stack. This composite method not only eliminates unnecessary pointer access but also eliminates heap allocations for bounded(0) channels.\n  2. Kanal utilizes a specially tuned mutex for its channel locking mechanism, made possible by the predictable internal lock time of the channel. That said it's possible to use Rust standard mutex with the ``std-mutex`` feature and Kanal will perform better than competitors with that feature too.\n  3. Utilizing Rust high-performance compiler and powerful LLVM backend with highly optimized memory access and deeply thought algorithms.\n\n\n## Usage\nTo use Kanal in your Rust project, add the following line to your ``Cargo.toml`` file:\n```\n```[``dependencies``]`\n`kanal ``=` ``\"`0.1`\"``\n``\n```\n\nSync channel example:\n```\n```//` Initialize a bounded sync channel with a capacity for 8 messages`\n`let` `(`sender`,` receiver`)` `=` `kanal`::``bounded`(``8``)``;`\n`let` s `=` sender`.``clone``(``)``;`\n`std`::```thread`::``spawn`(``move` `||` ``{`\n  s`.``send``(```\"`hello`\"```)``?``;`\n  `anyhow`::``Ok`(``(``)``)`\n```}```)``;`\n``//` Receive an example message in another thread`\n`let` msg `=` receiver`.``recv``(``)``?``;`\n`println!``(```\"`I got msg: `{}``\"```,` msg`)``;`\n\n``//` Convert and use channel in async context to communicate between sync and async`\n`tokio`::``spawn`(`async `move` ``{`\n  ``//` Borrow the channel as an async channel and use it in an async context ( or convert it to async using to_async() )`\n  sender`.``as_async``(``)``.``send``(```\"`hello`\"```)``.`await`?``;`\n  `anyhow`::``Ok`(``(``)``)`\n```}```)``;`\n`\n```\n\nAsync channel example:\n```\n```//` Initialize a bounded channel with a capacity for 8 messages`\n`let` `(`sender`,` receiver`)` `=` `kanal`::``bounded_async`(``8``)``;`\nsender`.``send``(```\"`hello`\"```)``.`await`?``;`\nsender`.``send``(```\"`hello`\"```)``.`await`?``;`\n``//` Clone receiver and convert it to a sync receiver`\n`let` receiver_sync `=` receiver`.``clone``(``)``.``to_sync``(``)``;`\n`tokio`::``spawn`(`async `move` ``{`\n  `let` msg `=` receiver`.``recv``(``)``.`await`?``;`\n  `println!``(```\"`I got msg: `{}``\"```,` msg`)``;`\n  `anyhow`::``Ok`(``(``)``)`\n```}```)``;`\n``//` Spawn a thread and use receiver in sync context`\n`std`::```thread`::``spawn`(``move` `||` ``{`\n  `let` msg `=` receiver_sync`.``recv``(``)``?``;`\n  `println!``(```\"`I got msg in sync context: `{}``\"```,` msg`)``;`\n  `anyhow`::``Ok`(``(``)``)`\n```}```)``;`\n`\n```\n\n## Why use Kanal?\n  * Kanal offers fast and efficient communication capabilities.\n  * Kanal simplifies communication in and between synchronous and asynchronous contexts, thanks to its flexible API like ``as_sync`` and ``as_async``.\n  * Kanal provides a clean and intuitive API, making it easier to work with compared to other Rust libraries.\n  * Similar to Golang, Kanal allows you to close channels using the ``Close`` function, enabling you to broadcast a close signal from any channel instance and close the channel for both senders and receivers.\n  * Kanal includes high-performance MPMC (Multiple Producers Multiple Consumers) and SPSC (Single Producer Single Consumer) channels in a single package.\n\n\n### Benchmark Results\nResults are based on how many messages can be passed in each scenario per second.\n#### Test types:\n  1. Seq is sequentially writing and reading to a channel in the same thread.\n  2. SPSC is one receiver, and one sender and passing messages between them.\n  3. MPSC is multiple sender threads with only one receiver.\n  4. MPMC is multiple senders and multiple receivers communicating through the same channel.\n\n\n#### Message types:\n  1. ```usize``` tests are transferring messages of size hardware pointer.\n  2. ``big`` tests are transferring messages of 8x the size of the hardware pointer.\n\n\nN/A means that the test subject is unable to perform the test due to its limitations, Some of the test subjects don't have implementation for size 0 channels, MPMC or unbounded channels.\nMachine: ```AMD` Ryzen `9` 9950X `16``-`Core Processor`` Rust: ``rustc `1.``85``.``1` `(`4eb161250 `2025``-``03``-``15``)``` Go: ``go version go1`.``24.``1` linux`/`amd64`` OS (``uname `-`a``): ``Linux `6.``11``.``0``-``19``-`generic `#``19``~``24.``04``.``1``-`Ubuntu `SMP` `PREEMPT_DYNAMIC` Mon Feb `17` `11``:``51``:``52` `UTC` `2` x86_64`` Date: Mar 19, 2025\nBenchmark codes\u27e87\u27e9\n![Benchmarks\u27e88\u27e9]\n#### Why does async outperform sync in some tests?\nIn certain tests, asynchronous communication may exhibit superior performance compared to synchronous communication. This can be attributed to the context-switching performance of libraries such as tokio, which, similar to Golang, utilize context-switching within the same thread to switch to the next coroutine when a message is ready on a channel. This approach is more efficient than communicating between separate threads. This same principle applies to asynchronous network applications, which generally exhibit better performance compared to synchronous implementations. As the channel size increases, one may observe improved performance in synchronous benchmarks, as the sending threads are able to push data directly to the channel queue without requiring awaiting blocking/suspending signals from receiving threads.\n#### Dependencies\n~160KB \n  * async\u27e89\u27e9 futures-core\u27e810\u27e9\n  * lock_api\u27e811\u27e9\n\n\n  * dev  anyhow\u27e812\u27e9\n  * dev  crossbeam\u27e813\u27e9\n  * dev  futures\u27e814\u27e9\n  * dev  tokio\u27e815\u27e9+rt-multi-thread\u27e816\u27e9+test-util\u27e817\u27e9+macros\u27e818\u27e9\n\n\n#### Other feature\u27e819\u27e9\n  * std-mutex\u27e820\u27e9\n\n\n  *[SLoC]: Lines of code, excluding comments\n",
              "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://lib.rs/crates/kanal/versions: 12 releases\n\u27e82\u27e9 https://lib.rs/concurrency: Crates for implementing concurrent and parallel computation. - Concurrency\n\u27e83\u27e9 https://lib.rs/crates/kanal/rev: **67** crates (58 directly)\n\u27e84\u27e9 https://img.shields.io/crates/v/kanal.svg?style=for-the-badge: ![Crates.io\n\u27e85\u27e9 https://img.shields.io/docsrs/kanal?style=for-the-badge: ![Documentation\n\u27e86\u27e9 https://img.shields.io/badge/license-MIT-blue.svg?style=for-the-badge: ![MIT licensed\n\u27e87\u27e9 https://github.com/fereidani/rust-channel-benchmarks: Benchmark codes\n\u27e88\u27e9 https://img.gs/czjpqfbdkz/800,2x/https://i.imgur.com/VPwyam0.png: Benchmarks\n\u27e89\u27e9 https://lib.rs/crates/kanal/features#feature-async: default feature - async\n\u27e810\u27e9 https://lib.rs/crates/futures-core: 0.3 - futures-core\n\u27e811\u27e9 https://lib.rs/crates/lock_api: 0.4 - lock_api\n\u27e812\u27e9 https://lib.rs/crates/anyhow: 1.0 - anyhow\n\u27e813\u27e9 https://lib.rs/crates/crossbeam: 0.8 - crossbeam\n\u27e814\u27e9 https://lib.rs/crates/futures: 0.3 - futures\n\u27e815\u27e9 https://lib.rs/crates/tokio: 1 - tokio\n\u27e816\u27e9 https://lib.rs/crates/tokio/features#feature-rt-multi-thread: +rt-multi-thread\n\u27e817\u27e9 https://lib.rs/crates/tokio/features#feature-test-util: +test-util\n\u27e818\u27e9 https://lib.rs/crates/tokio/features#feature-macros: +macros\n\u27e819\u27e9 https://lib.rs/crates/kanal/features: Other feature\n\u27e820\u27e9 https://lib.rs/crates/kanal/features#feature-std-mutex: std-mutex\n",
              "fit_markdown": "",
              "fit_html": ""
            },
            "structured_data": {},
            "quality_score": 3.0,
            "extraction_method": "crawl4ai",
            "error": null,
            "metadata": {
              "doc_type": "docs",
              "content_length": 8433,
              "has_structured_data": false,
              "crawl_success": true
            },
            "timestamp": "116876.6893475"
          }
        },
        "crate_analysis": {
          "status": "completed",
          "check": [
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#scopeguard@1.2.0",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\scopeguard-1.2.0\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "scopeguard",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\scopeguard-1.2.0\\src\\lib.rs",
                "edition": "2015",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpzsyyaxe_\\kanal-0.1.1\\target\\debug\\deps\\libscopeguard-b3036dac4c63d524.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#futures-core@0.3.31",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\futures-core-0.3.31\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "futures_core",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\futures-core-0.3.31\\src\\lib.rs",
                "edition": "2018",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "alloc",
                "default",
                "std"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpzsyyaxe_\\kanal-0.1.1\\target\\debug\\deps\\libfutures_core-308f9a7b9ba0908e.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#autocfg@1.4.0",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\autocfg-1.4.0\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "autocfg",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\autocfg-1.4.0\\src\\lib.rs",
                "edition": "2015",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpzsyyaxe_\\kanal-0.1.1\\target\\debug\\deps\\libautocfg-962de8d6b4bbcb9a.rlib",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpzsyyaxe_\\kanal-0.1.1\\target\\debug\\deps\\libautocfg-962de8d6b4bbcb9a.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#lock_api@0.4.12",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\lock_api-0.4.12\\Cargo.toml",
              "target": {
                "kind": [
                  "custom-build"
                ],
                "crate_types": [
                  "bin"
                ],
                "name": "build-script-build",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\lock_api-0.4.12\\build.rs",
                "edition": "2021",
                "doc": false,
                "doctest": false,
                "test": false
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "atomic_usize",
                "default"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpzsyyaxe_\\kanal-0.1.1\\target\\debug\\build\\lock_api-a9e715d952b9cda1\\build-script-build.exe",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpzsyyaxe_\\kanal-0.1.1\\target\\debug\\build\\lock_api-a9e715d952b9cda1\\build_script_build.pdb"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "build-script-executed",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#lock_api@0.4.12",
              "linked_libs": [],
              "linked_paths": [],
              "cfgs": [
                "has_const_fn_trait_bound"
              ],
              "env": [],
              "out_dir": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpzsyyaxe_\\kanal-0.1.1\\target\\debug\\build\\lock_api-b58b3b906f0a8342\\out"
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#lock_api@0.4.12",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\lock_api-0.4.12\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "lock_api",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\lock_api-0.4.12\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "atomic_usize",
                "default"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpzsyyaxe_\\kanal-0.1.1\\target\\debug\\deps\\liblock_api-8d187389174b18f4.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "compiler-artifact",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpzsyyaxe_/kanal-0.1.1#kanal@0.1.1",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpzsyyaxe_\\kanal-0.1.1\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "kanal",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpzsyyaxe_\\kanal-0.1.1\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "async",
                "default",
                "futures-core"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpzsyyaxe_\\kanal-0.1.1\\target\\debug\\deps\\libkanal-a689277323054ffa.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "build-finished",
              "success": true
            }
          ],
          "clippy": [
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#autocfg@1.4.0",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\autocfg-1.4.0\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "autocfg",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\autocfg-1.4.0\\src\\lib.rs",
                "edition": "2015",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpzsyyaxe_\\kanal-0.1.1\\target\\debug\\deps\\libautocfg-962de8d6b4bbcb9a.rlib",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpzsyyaxe_\\kanal-0.1.1\\target\\debug\\deps\\libautocfg-962de8d6b4bbcb9a.rmeta"
              ],
              "executable": null,
              "fresh": true
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#lock_api@0.4.12",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\lock_api-0.4.12\\Cargo.toml",
              "target": {
                "kind": [
                  "custom-build"
                ],
                "crate_types": [
                  "bin"
                ],
                "name": "build-script-build",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\lock_api-0.4.12\\build.rs",
                "edition": "2021",
                "doc": false,
                "doctest": false,
                "test": false
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "atomic_usize",
                "default"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpzsyyaxe_\\kanal-0.1.1\\target\\debug\\build\\lock_api-a9e715d952b9cda1\\build-script-build.exe",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpzsyyaxe_\\kanal-0.1.1\\target\\debug\\build\\lock_api-a9e715d952b9cda1\\build_script_build.pdb"
              ],
              "executable": null,
              "fresh": true
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#scopeguard@1.2.0",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\scopeguard-1.2.0\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "scopeguard",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\scopeguard-1.2.0\\src\\lib.rs",
                "edition": "2015",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpzsyyaxe_\\kanal-0.1.1\\target\\debug\\deps\\libscopeguard-b3036dac4c63d524.rmeta"
              ],
              "executable": null,
              "fresh": true
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#futures-core@0.3.31",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\futures-core-0.3.31\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "futures_core",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\futures-core-0.3.31\\src\\lib.rs",
                "edition": "2018",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "alloc",
                "default",
                "std"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpzsyyaxe_\\kanal-0.1.1\\target\\debug\\deps\\libfutures_core-308f9a7b9ba0908e.rmeta"
              ],
              "executable": null,
              "fresh": true
            },
            {
              "reason": "build-script-executed",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#lock_api@0.4.12",
              "linked_libs": [],
              "linked_paths": [],
              "cfgs": [
                "has_const_fn_trait_bound"
              ],
              "env": [],
              "out_dir": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpzsyyaxe_\\kanal-0.1.1\\target\\debug\\build\\lock_api-b58b3b906f0a8342\\out"
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#lock_api@0.4.12",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\lock_api-0.4.12\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "lock_api",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\lock_api-0.4.12\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "atomic_usize",
                "default"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpzsyyaxe_\\kanal-0.1.1\\target\\debug\\deps\\liblock_api-8d187389174b18f4.rmeta"
              ],
              "executable": null,
              "fresh": true
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpzsyyaxe_/kanal-0.1.1#kanal@0.1.1",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpzsyyaxe_\\kanal-0.1.1\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "kanal",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpzsyyaxe_\\kanal-0.1.1\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: use `std::ptr::eq` when comparing raw pointers\n   --> src\\signal.rs:320:9\n    |\n320 |         self.0 == other as *const Signal<T>\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `std::ptr::eq(self.0, other)`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#ptr_eq\n    = note: `#[warn(clippy::ptr_eq)]` on by default\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#ptr_eq",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "note",
                    "message": "`#[warn(clippy::ptr_eq)]` on by default",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "try",
                    "rendered": null,
                    "spans": [
                      {
                        "byte_end": 9836,
                        "byte_start": 9801,
                        "column_end": 44,
                        "column_start": 9,
                        "expansion": null,
                        "file_name": "src\\signal.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 320,
                        "line_start": 320,
                        "suggested_replacement": "std::ptr::eq(self.0, other)",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 44,
                            "highlight_start": 9,
                            "text": "        self.0 == other as *const Signal<T>"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "code": {
                  "code": "clippy::ptr_eq",
                  "explanation": null
                },
                "level": "warning",
                "message": "use `std::ptr::eq` when comparing raw pointers",
                "spans": [
                  {
                    "byte_end": 9836,
                    "byte_start": 9801,
                    "column_end": 44,
                    "column_start": 9,
                    "expansion": null,
                    "file_name": "src\\signal.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 320,
                    "line_start": 320,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 44,
                        "highlight_start": 9,
                        "text": "        self.0 == other as *const Signal<T>"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-artifact",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpzsyyaxe_/kanal-0.1.1#kanal@0.1.1",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpzsyyaxe_\\kanal-0.1.1\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "kanal",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpzsyyaxe_\\kanal-0.1.1\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "async",
                "default",
                "futures-core"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpzsyyaxe_\\kanal-0.1.1\\target\\debug\\deps\\libkanal-ebb193580c0e4dc3.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "build-finished",
              "success": true
            }
          ],
          "audit": {
            "database": {
              "advisory-count": 787,
              "last-commit": "7573f55ba337263f61167dbb0ea926cdc7c8eb5d",
              "last-updated": "2025-06-17T11:04:25+02:00"
            },
            "lockfile": {
              "dependency-count": 48
            },
            "settings": {
              "target_arch": [],
              "target_os": [],
              "severity": null,
              "ignore": [],
              "informational_warnings": [
                "unmaintained",
                "unsound",
                "notice"
              ]
            },
            "vulnerabilities": {
              "found": true,
              "count": 1,
              "list": [
                {
                  "advisory": {
                    "id": "RUSTSEC-2025-0024",
                    "package": "crossbeam-channel",
                    "title": "crossbeam-channel: double free on Drop",
                    "description": "The internal `Channel` type's `Drop` method has a race\nwhich could, in some circumstances, lead to a double-free.\nThis could result in memory corruption.\n\nQuoting from the\n[upstream description in merge request \\#1187](https://github.com/crossbeam-rs/crossbeam/pull/1187#issue-2980761131):\n\n> The problem lies in the fact that `dicard_all_messages` contained two paths that could lead to `head.block` being read but only one of them would swap the value. This meant that `dicard_all_messages` could end up observing a non-null block pointer (and therefore attempting to free it) without setting `head.block` to null. This would then lead to `Channel::drop` making a second attempt at dropping the same pointer.\n\nThe bug was introduced while fixing a memory leak, in\nupstream [MR \\#1084](https://github.com/crossbeam-rs/crossbeam/pull/1084),\nfirst published in 0.5.12.\n\nThe fix is in\nupstream [MR \\#1187](https://github.com/crossbeam-rs/crossbeam/pull/1187)\nand has been published in 0.5.15",
                    "date": "2025-04-08",
                    "aliases": [
                      "TROVE-2025-013"
                    ],
                    "related": [],
                    "collection": "crates",
                    "categories": [
                      "memory-corruption"
                    ],
                    "keywords": [
                      "race"
                    ],
                    "cvss": null,
                    "informational": null,
                    "references": [],
                    "source": null,
                    "url": "https://github.com/crossbeam-rs/crossbeam/pull/1187",
                    "withdrawn": null,
                    "license": "CC0-1.0"
                  },
                  "versions": {
                    "patched": [
                      ">=0.5.15"
                    ],
                    "unaffected": [
                      "<=0.5.11"
                    ]
                  },
                  "affected": null,
                  "package": {
                    "name": "crossbeam-channel",
                    "version": "0.5.14",
                    "source": "registry+https://github.com/rust-lang/crates.io-index",
                    "checksum": "06ba6d68e24814cb8de6bb986db8222d3a027d15872cabc0d18817bc3c0e4471",
                    "dependencies": [
                      {
                        "name": "crossbeam-utils",
                        "version": "0.8.21",
                        "source": "registry+https://github.com/rust-lang/crates.io-index"
                      }
                    ],
                    "replace": null
                  }
                }
              ]
            },
            "warnings": {
              "unsound": [
                {
                  "kind": "unsound",
                  "package": {
                    "name": "tokio",
                    "version": "1.44.1",
                    "source": "registry+https://github.com/rust-lang/crates.io-index",
                    "checksum": "f382da615b842244d4b8738c82ed1275e6c5dd90c459a30941cd07080b06c91a",
                    "dependencies": [
                      {
                        "name": "backtrace",
                        "version": "0.3.74",
                        "source": "registry+https://github.com/rust-lang/crates.io-index"
                      },
                      {
                        "name": "pin-project-lite",
                        "version": "0.2.16",
                        "source": "registry+https://github.com/rust-lang/crates.io-index"
                      },
                      {
                        "name": "tokio-macros",
                        "version": "2.5.0",
                        "source": "registry+https://github.com/rust-lang/crates.io-index"
                      }
                    ],
                    "replace": null
                  },
                  "advisory": {
                    "id": "RUSTSEC-2025-0023",
                    "package": "tokio",
                    "title": "Broadcast channel calls clone in parallel, but does not require `Sync`",
                    "description": "The broadcast channel internally calls `clone` on the stored value when\nreceiving it, and only requires `T:Send`. This means that using the broadcast\nchannel with values that are `Send` but not `Sync` can trigger unsoundness if\nthe `clone` implementation makes use of the value being `!Sync`.\n\nThank you to Austin Bonander for finding and reporting this issue.",
                    "date": "2025-04-07",
                    "aliases": [],
                    "related": [],
                    "collection": "crates",
                    "categories": [
                      "memory-corruption"
                    ],
                    "keywords": [],
                    "cvss": null,
                    "informational": "unsound",
                    "references": [],
                    "source": null,
                    "url": "https://github.com/tokio-rs/tokio/pull/7232",
                    "withdrawn": null,
                    "license": "CC0-1.0"
                  },
                  "affected": null,
                  "versions": {
                    "patched": [
                      ">=1.38.2, <1.39.0",
                      ">=1.42.1, <1.43.0",
                      ">=1.43.1, <1.44.0",
                      ">=1.44.2"
                    ],
                    "unaffected": [
                      "<0.2.5"
                    ]
                  }
                }
              ],
              "yanked": [
                {
                  "kind": "yanked",
                  "package": {
                    "name": "crossbeam-channel",
                    "version": "0.5.14",
                    "source": "registry+https://github.com/rust-lang/crates.io-index",
                    "checksum": "06ba6d68e24814cb8de6bb986db8222d3a027d15872cabc0d18817bc3c0e4471",
                    "dependencies": [
                      {
                        "name": "crossbeam-utils",
                        "version": "0.8.21",
                        "source": "registry+https://github.com/rust-lang/crates.io-index"
                      }
                    ],
                    "replace": null
                  },
                  "advisory": null,
                  "affected": null,
                  "versions": null
                }
              ]
            }
          },
          "note": "Crate analysis performed with stable toolchain."
        },
        "crate_metadata": {
          "name": "kanal",
          "version": "0.1.1",
          "description": "ALLOW: Positive community sentiment",
          "repository": "",
          "keywords": [],
          "categories": [],
          "readme": {
            "raw_markdown": "[](https://docs.rs/kanal/latest/kanal/all.html \"show sidebar\")\n# Crate kanalCopy item path\n[Settings](https://docs.rs/kanal/latest/settings.html)\n[Help](https://docs.rs/kanal/latest/help.html)\nSummary[Source](https://docs.rs/kanal/latest/src/kanal/lib.rs.html#1-1644)\nExpand description\n## [\u00a7](https://docs.rs/kanal/latest/kanal/#kanal)Kanal\n**The fast sync and async channel that Rust deserves!**\n[![Crates.io](https://img.shields.io/crates/v/kanal.svg?style=for-the-badge)](https://crates.io/crates/kanal) [![Documentation](https://img.shields.io/docsrs/kanal?style=for-the-badge)](https://docs.rs/kanal) [![MIT licensed](https://img.shields.io/badge/license-MIT-blue.svg?style=for-the-badge)](https://github.com/fereidani/kanal/blob/master/LICENSE)\n### [\u00a7](https://docs.rs/kanal/latest/kanal/#what-is-kanal)What is Kanal\nThe Kanal library is a Rust implementation of channels inspired by the CSP (Communicating Sequential Processes) model. It aims to help programmers create efficient concurrent programs by providing multi-producer and multi-consumer channels with advanced features for fast communication. The library focuses on unifying message passing between synchronous and asynchronous parts of Rust code, offering a combination of synchronous and asynchronous APIs while maintaining high performance.\n### [\u00a7](https://docs.rs/kanal/latest/kanal/#why-kanal-is-faster)Why Kanal is faster?\n  1. Kanal employs a highly optimized composite technique for the transfer of objects. When the data size is less than or equal to the pointer size, it utilizes serialization, encoding the data as the pointer address. Conversely, when the data size exceeds the pointer size, the protocol employs a strategy similar to that utilized by the Golang programming language, utilizing direct memory access to copy objects from the sender\u2019s stack or write directly to the receiver\u2019s stack. This composite method not only eliminates unnecessary pointer access but also eliminates heap allocations for bounded(0) channels.\n  2. Kanal utilizes a specially tuned mutex for its channel locking mechanism, made possible by the predictable internal lock time of the channel. That said it\u2019s possible to use Rust standard mutex with the `std-mutex` feature and Kanal will perform better than competitors with that feature too.\n  3. Utilizing Rust high-performance compiler and powerful LLVM backend with highly optimized memory access and deeply thought algorithms.\n\n\n### [\u00a7](https://docs.rs/kanal/latest/kanal/#usage)Usage\nTo use Kanal in your Rust project, add the following line to your `Cargo.toml` file:\n```\n[dependencies]\nkanal = \"0.1\"\n```\n\nSync channel example:\n[\u24d8](https://docs.rs/kanal/latest/kanal/ \"This example is not tested\")```\n// Initialize a bounded sync channel with a capacity for 8 messages\nlet (sender, receiver) = kanal::bounded(8);\nlet s = sender.clone();\nstd::thread::spawn(move || {\n  s.send(\"hello\")?;\n  anyhow::Ok(())\n});\n// Receive an example message in another thread\nlet msg = receiver.recv()?;\nprintln!(\"I got msg: {}\", msg);\n\n// Convert and use channel in async context to communicate between sync and async\ntokio::spawn(async move {\n  // Borrow the channel as an async channel and use it in an async context ( or convert it to async using to_async() )\n  sender.as_async().send(\"hello\").await?;\n  anyhow::Ok(())\n});\n```\n\nAsync channel example:\n[\u24d8](https://docs.rs/kanal/latest/kanal/ \"This example is not tested\")```\n// Initialize a bounded channel with a capacity for 8 messages\nlet (sender, receiver) = kanal::bounded_async(8);\nsender.send(\"hello\").await?;\nsender.send(\"hello\").await?;\n// Clone receiver and convert it to a sync receiver\nlet receiver_sync = receiver.clone().to_sync();\ntokio::spawn(async move {\n  let msg = receiver.recv().await?;\n  println!(\"I got msg: {}\", msg);\n  anyhow::Ok(())\n});\n// Spawn a thread and use receiver in sync context\nstd::thread::spawn(move || {\n  let msg = receiver_sync.recv()?;\n  println!(\"I got msg in sync context: {}\", msg);\n  anyhow::Ok(())\n});\n```\n\n### [\u00a7](https://docs.rs/kanal/latest/kanal/#why-use-kanal)Why use Kanal?\n  * Kanal offers fast and efficient communication capabilities.\n  * Kanal simplifies communication in and between synchronous and asynchronous contexts, thanks to its flexible API like `as_sync` and `as_async`.\n  * Kanal provides a clean and intuitive API, making it easier to work with compared to other Rust libraries.\n  * Similar to Golang, Kanal allows you to close channels using the `Close` function, enabling you to broadcast a close signal from any channel instance and close the channel for both senders and receivers.\n  * Kanal includes high-performance MPMC (Multiple Producers Multiple Consumers) and SPSC (Single Producer Single Consumer) channels in a single package.\n\n\n#### [\u00a7](https://docs.rs/kanal/latest/kanal/#benchmark-results)Benchmark Results\nResults are based on how many messages can be passed in each scenario per second.\n##### [\u00a7](https://docs.rs/kanal/latest/kanal/#test-types)Test types:\n  1. Seq is sequentially writing and reading to a channel in the same thread.\n  2. SPSC is one receiver, and one sender and passing messages between them.\n  3. MPSC is multiple sender threads with only one receiver.\n  4. MPMC is multiple senders and multiple receivers communicating through the same channel.\n\n\n##### [\u00a7](https://docs.rs/kanal/latest/kanal/#message-types)Message types:\n  1. `usize` tests are transferring messages of size hardware pointer.\n  2. `big` tests are transferring messages of 8x the size of the hardware pointer.\n\n\nN/A means that the test subject is unable to perform the test due to its limitations, Some of the test subjects don\u2019t have implementation for size 0 channels, MPMC or unbounded channels.\nMachine: `AMD Ryzen 9 9950X 16-Core Processor` Rust: `rustc 1.85.1 (4eb161250 2025-03-15)` Go: `go version go1.24.1 linux/amd64` OS (`uname -a`): `Linux 6.11.0-19-generic #19~24.04.1-Ubuntu SMP PREEMPT_DYNAMIC Mon Feb 17 11:51:52 UTC 2 x86_64` Date: Mar 19, 2025\n[Benchmark codes](https://github.com/fereidani/rust-channel-benchmarks)\n![Benchmarks](https://i.imgur.com/VPwyam0.png)\n##### [\u00a7](https://docs.rs/kanal/latest/kanal/#why-does-async-outperform-sync-in-some-tests)Why does async outperform sync in some tests?\nIn certain tests, asynchronous communication may exhibit superior performance compared to synchronous communication. This can be attributed to the context-switching performance of libraries such as tokio, which, similar to Golang, utilize context-switching within the same thread to switch to the next coroutine when a message is ready on a channel. This approach is more efficient than communicating between separate threads. This same principle applies to asynchronous network applications, which generally exhibit better performance compared to synchronous implementations. As the channel size increases, one may observe improved performance in synchronous benchmarks, as the sending threads are able to push data directly to the channel queue without requiring awaiting blocking/suspending signals from receiving threads.\n## Structs[\u00a7](https://docs.rs/kanal/latest/kanal/#structs)\n\n[AsyncReceiver](https://docs.rs/kanal/latest/kanal/struct.AsyncReceiver.html \"struct kanal::AsyncReceiver\")\n    [`AsyncReceiver`](https://docs.rs/kanal/latest/kanal/struct.AsyncReceiver.html \"struct kanal::AsyncReceiver\") is receiving side of the channel in async mode. Receivers can be cloned and produce receivers to operate in both sync and async modes.\n\n[AsyncSender](https://docs.rs/kanal/latest/kanal/struct.AsyncSender.html \"struct kanal::AsyncSender\")\n    Sending side of the channel with async API. It\u2019s possible to convert it to sync [`Sender`](https://docs.rs/kanal/latest/kanal/struct.Sender.html \"struct kanal::Sender\") with `as_sync`, `to_sync` or `clone_sync` based on software requirement.\n\n[CloseError](https://docs.rs/kanal/latest/kanal/struct.CloseError.html \"struct kanal::CloseError\")\n    Error type for closing a channel when channel is already closed\n\n[ReceiveFuture](https://docs.rs/kanal/latest/kanal/struct.ReceiveFuture.html \"struct kanal::ReceiveFuture\")\n    ReceiveFuture is a future for receiving an object from a channel asynchronously. It must be polled to complete the receive operation.\n\n[ReceiveStream](https://docs.rs/kanal/latest/kanal/struct.ReceiveStream.html \"struct kanal::ReceiveStream\")\n    ReceiveStream is a stream for receiving objects from a channel asynchronously.\n\n[Receiver](https://docs.rs/kanal/latest/kanal/struct.Receiver.html \"struct kanal::Receiver\")\n    Receiving side of the channel in sync mode. Receivers can be cloned and produce receivers to operate in both sync and async modes.\n\n[SendFuture](https://docs.rs/kanal/latest/kanal/struct.SendFuture.html \"struct kanal::SendFuture\")\n    SendFuture is a future for sending an object to a channel asynchronously. It must be polled to complete the send operation.\n\n[Sender](https://docs.rs/kanal/latest/kanal/struct.Sender.html \"struct kanal::Sender\")\n    Sending side of the channel with sync API. It\u2019s possible to convert it to async [`AsyncSender`](https://docs.rs/kanal/latest/kanal/struct.AsyncSender.html \"struct kanal::AsyncSender\") with `as_async`, `to_async` or `clone_async` based on software requirement.\n## Enums[\u00a7](https://docs.rs/kanal/latest/kanal/#enums)\n\n[ReceiveError](https://docs.rs/kanal/latest/kanal/enum.ReceiveError.html \"enum kanal::ReceiveError\")\n    Error type for channel receive operations without timeout\n\n[ReceiveErrorTimeout](https://docs.rs/kanal/latest/kanal/enum.ReceiveErrorTimeout.html \"enum kanal::ReceiveErrorTimeout\")\n    Error type for channel receive operations with timeout\n\n[SendError](https://docs.rs/kanal/latest/kanal/enum.SendError.html \"enum kanal::SendError\")\n    Error type for channel send operations without timeout\n\n[SendErrorTimeout](https://docs.rs/kanal/latest/kanal/enum.SendErrorTimeout.html \"enum kanal::SendErrorTimeout\")\n    Error type for channel send operations with timeout\n## Functions[\u00a7](https://docs.rs/kanal/latest/kanal/#functions)\n\n[bounded](https://docs.rs/kanal/latest/kanal/fn.bounded.html \"fn kanal::bounded\")\n    Creates a new sync bounded channel with the requested buffer size, and returns [`Sender`](https://docs.rs/kanal/latest/kanal/struct.Sender.html \"struct kanal::Sender\") and [`Receiver`](https://docs.rs/kanal/latest/kanal/struct.Receiver.html \"struct kanal::Receiver\") of the channel for type T, you can get access to async API of [`AsyncSender`](https://docs.rs/kanal/latest/kanal/struct.AsyncSender.html \"struct kanal::AsyncSender\") and [`AsyncReceiver`](https://docs.rs/kanal/latest/kanal/struct.AsyncReceiver.html \"struct kanal::AsyncReceiver\") with `to_sync`, `as_async` or `clone_sync` based on your requirements, by calling them on sender or receiver.\n\n[bounded_async](https://docs.rs/kanal/latest/kanal/fn.bounded_async.html \"fn kanal::bounded_async\")\n    Creates a new async bounded channel with the requested buffer size, and returns [`AsyncSender`](https://docs.rs/kanal/latest/kanal/struct.AsyncSender.html \"struct kanal::AsyncSender\") and [`AsyncReceiver`](https://docs.rs/kanal/latest/kanal/struct.AsyncReceiver.html \"struct kanal::AsyncReceiver\") of the channel for type T, you can get access to sync API of [`Sender`](https://docs.rs/kanal/latest/kanal/struct.Sender.html \"struct kanal::Sender\") and [`Receiver`](https://docs.rs/kanal/latest/kanal/struct.Receiver.html \"struct kanal::Receiver\") with `to_sync`, `as_async` or `clone_sync` based on your requirements, by calling them on async sender or receiver.\n\n[unbounded](https://docs.rs/kanal/latest/kanal/fn.unbounded.html \"fn kanal::unbounded\")\n    Creates a new sync unbounded channel, and returns [`Sender`](https://docs.rs/kanal/latest/kanal/struct.Sender.html \"struct kanal::Sender\") and [`Receiver`](https://docs.rs/kanal/latest/kanal/struct.Receiver.html \"struct kanal::Receiver\") of the channel for type T, you can get access to async API of [`AsyncSender`](https://docs.rs/kanal/latest/kanal/struct.AsyncSender.html \"struct kanal::AsyncSender\") and [`AsyncReceiver`](https://docs.rs/kanal/latest/kanal/struct.AsyncReceiver.html \"struct kanal::AsyncReceiver\") with `to_sync`, `as_async` or `clone_sync` based on your requirements, by calling them on sender or receiver.\n\n[unbounded_async](https://docs.rs/kanal/latest/kanal/fn.unbounded_async.html \"fn kanal::unbounded_async\")\n    Creates a new async unbounded channel, and returns [`AsyncSender`](https://docs.rs/kanal/latest/kanal/struct.AsyncSender.html \"struct kanal::AsyncSender\") and [`AsyncReceiver`](https://docs.rs/kanal/latest/kanal/struct.AsyncReceiver.html \"struct kanal::AsyncReceiver\") of the channel for type T, you can get access to sync API of [`Sender`](https://docs.rs/kanal/latest/kanal/struct.Sender.html \"struct kanal::Sender\") and [`Receiver`](https://docs.rs/kanal/latest/kanal/struct.Receiver.html \"struct kanal::Receiver\") with `to_sync`, `as_async` or `clone_sync` based on your requirements, by calling them on async sender or receiver.\n",
            "markdown_with_citations": "[](https://docs.rs/kanal/latest/kanal/all.html \"show sidebar\")\n# Crate kanalCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\n## \u00a7\u27e84\u27e9Kanal\n**The fast sync and async channel that Rust deserves!**\n![Crates.io\u27e85\u27e9](https://crates.io/crates/kanal) ![Documentation\u27e86\u27e9](https://docs.rs/kanal) ![MIT licensed\u27e87\u27e9](https://github.com/fereidani/kanal/blob/master/LICENSE)\n### \u00a7\u27e88\u27e9What is Kanal\nThe Kanal library is a Rust implementation of channels inspired by the CSP (Communicating Sequential Processes) model. It aims to help programmers create efficient concurrent programs by providing multi-producer and multi-consumer channels with advanced features for fast communication. The library focuses on unifying message passing between synchronous and asynchronous parts of Rust code, offering a combination of synchronous and asynchronous APIs while maintaining high performance.\n### \u00a7\u27e89\u27e9Why Kanal is faster?\n  1. Kanal employs a highly optimized composite technique for the transfer of objects. When the data size is less than or equal to the pointer size, it utilizes serialization, encoding the data as the pointer address. Conversely, when the data size exceeds the pointer size, the protocol employs a strategy similar to that utilized by the Golang programming language, utilizing direct memory access to copy objects from the sender\u2019s stack or write directly to the receiver\u2019s stack. This composite method not only eliminates unnecessary pointer access but also eliminates heap allocations for bounded(0) channels.\n  2. Kanal utilizes a specially tuned mutex for its channel locking mechanism, made possible by the predictable internal lock time of the channel. That said it\u2019s possible to use Rust standard mutex with the `std-mutex` feature and Kanal will perform better than competitors with that feature too.\n  3. Utilizing Rust high-performance compiler and powerful LLVM backend with highly optimized memory access and deeply thought algorithms.\n\n\n### \u00a7\u27e810\u27e9Usage\nTo use Kanal in your Rust project, add the following line to your `Cargo.toml` file:\n```\n[dependencies]\nkanal = \"0.1\"\n```\n\nSync channel example:\n\u24d8\u27e811\u27e9```\n// Initialize a bounded sync channel with a capacity for 8 messages\nlet (sender, receiver) = kanal::bounded(8);\nlet s = sender.clone();\nstd::thread::spawn(move || {\n  s.send(\"hello\")?;\n  anyhow::Ok(())\n});\n// Receive an example message in another thread\nlet msg = receiver.recv()?;\nprintln!(\"I got msg: {}\", msg);\n\n// Convert and use channel in async context to communicate between sync and async\ntokio::spawn(async move {\n  // Borrow the channel as an async channel and use it in an async context ( or convert it to async using to_async() )\n  sender.as_async().send(\"hello\").await?;\n  anyhow::Ok(())\n});\n```\n\nAsync channel example:\n\u24d8\u27e811\u27e9```\n// Initialize a bounded channel with a capacity for 8 messages\nlet (sender, receiver) = kanal::bounded_async(8);\nsender.send(\"hello\").await?;\nsender.send(\"hello\").await?;\n// Clone receiver and convert it to a sync receiver\nlet receiver_sync = receiver.clone().to_sync();\ntokio::spawn(async move {\n  let msg = receiver.recv().await?;\n  println!(\"I got msg: {}\", msg);\n  anyhow::Ok(())\n});\n// Spawn a thread and use receiver in sync context\nstd::thread::spawn(move || {\n  let msg = receiver_sync.recv()?;\n  println!(\"I got msg in sync context: {}\", msg);\n  anyhow::Ok(())\n});\n```\n\n### \u00a7\u27e812\u27e9Why use Kanal?\n  * Kanal offers fast and efficient communication capabilities.\n  * Kanal simplifies communication in and between synchronous and asynchronous contexts, thanks to its flexible API like `as_sync` and `as_async`.\n  * Kanal provides a clean and intuitive API, making it easier to work with compared to other Rust libraries.\n  * Similar to Golang, Kanal allows you to close channels using the `Close` function, enabling you to broadcast a close signal from any channel instance and close the channel for both senders and receivers.\n  * Kanal includes high-performance MPMC (Multiple Producers Multiple Consumers) and SPSC (Single Producer Single Consumer) channels in a single package.\n\n\n#### \u00a7\u27e813\u27e9Benchmark Results\nResults are based on how many messages can be passed in each scenario per second.\n##### \u00a7\u27e814\u27e9Test types:\n  1. Seq is sequentially writing and reading to a channel in the same thread.\n  2. SPSC is one receiver, and one sender and passing messages between them.\n  3. MPSC is multiple sender threads with only one receiver.\n  4. MPMC is multiple senders and multiple receivers communicating through the same channel.\n\n\n##### \u00a7\u27e815\u27e9Message types:\n  1. `usize` tests are transferring messages of size hardware pointer.\n  2. `big` tests are transferring messages of 8x the size of the hardware pointer.\n\n\nN/A means that the test subject is unable to perform the test due to its limitations, Some of the test subjects don\u2019t have implementation for size 0 channels, MPMC or unbounded channels.\nMachine: `AMD Ryzen 9 9950X 16-Core Processor` Rust: `rustc 1.85.1 (4eb161250 2025-03-15)` Go: `go version go1.24.1 linux/amd64` OS (`uname -a`): `Linux 6.11.0-19-generic #19~24.04.1-Ubuntu SMP PREEMPT_DYNAMIC Mon Feb 17 11:51:52 UTC 2 x86_64` Date: Mar 19, 2025\nBenchmark codes\u27e816\u27e9\n![Benchmarks\u27e817\u27e9]\n##### \u00a7\u27e818\u27e9Why does async outperform sync in some tests?\nIn certain tests, asynchronous communication may exhibit superior performance compared to synchronous communication. This can be attributed to the context-switching performance of libraries such as tokio, which, similar to Golang, utilize context-switching within the same thread to switch to the next coroutine when a message is ready on a channel. This approach is more efficient than communicating between separate threads. This same principle applies to asynchronous network applications, which generally exhibit better performance compared to synchronous implementations. As the channel size increases, one may observe improved performance in synchronous benchmarks, as the sending threads are able to push data directly to the channel queue without requiring awaiting blocking/suspending signals from receiving threads.\n## Structs\u00a7\u27e819\u27e9\n\nAsyncReceiver\u27e820\u27e9\n    `AsyncReceiver`\u27e820\u27e9 is receiving side of the channel in async mode. Receivers can be cloned and produce receivers to operate in both sync and async modes.\n\nAsyncSender\u27e821\u27e9\n    Sending side of the channel with async API. It\u2019s possible to convert it to sync `Sender`\u27e822\u27e9 with `as_sync`, `to_sync` or `clone_sync` based on software requirement.\n\nCloseError\u27e823\u27e9\n    Error type for closing a channel when channel is already closed\n\nReceiveFuture\u27e824\u27e9\n    ReceiveFuture is a future for receiving an object from a channel asynchronously. It must be polled to complete the receive operation.\n\nReceiveStream\u27e825\u27e9\n    ReceiveStream is a stream for receiving objects from a channel asynchronously.\n\nReceiver\u27e826\u27e9\n    Receiving side of the channel in sync mode. Receivers can be cloned and produce receivers to operate in both sync and async modes.\n\nSendFuture\u27e827\u27e9\n    SendFuture is a future for sending an object to a channel asynchronously. It must be polled to complete the send operation.\n\nSender\u27e822\u27e9\n    Sending side of the channel with sync API. It\u2019s possible to convert it to async `AsyncSender`\u27e821\u27e9 with `as_async`, `to_async` or `clone_async` based on software requirement.\n## Enums\u00a7\u27e828\u27e9\n\nReceiveError\u27e829\u27e9\n    Error type for channel receive operations without timeout\n\nReceiveErrorTimeout\u27e830\u27e9\n    Error type for channel receive operations with timeout\n\nSendError\u27e831\u27e9\n    Error type for channel send operations without timeout\n\nSendErrorTimeout\u27e832\u27e9\n    Error type for channel send operations with timeout\n## Functions\u00a7\u27e833\u27e9\n\nbounded\u27e834\u27e9\n    Creates a new sync bounded channel with the requested buffer size, and returns `Sender`\u27e822\u27e9 and `Receiver`\u27e826\u27e9 of the channel for type T, you can get access to async API of `AsyncSender`\u27e821\u27e9 and `AsyncReceiver`\u27e820\u27e9 with `to_sync`, `as_async` or `clone_sync` based on your requirements, by calling them on sender or receiver.\n\nbounded_async\u27e835\u27e9\n    Creates a new async bounded channel with the requested buffer size, and returns `AsyncSender`\u27e821\u27e9 and `AsyncReceiver`\u27e820\u27e9 of the channel for type T, you can get access to sync API of `Sender`\u27e822\u27e9 and `Receiver`\u27e826\u27e9 with `to_sync`, `as_async` or `clone_sync` based on your requirements, by calling them on async sender or receiver.\n\nunbounded\u27e836\u27e9\n    Creates a new sync unbounded channel, and returns `Sender`\u27e822\u27e9 and `Receiver`\u27e826\u27e9 of the channel for type T, you can get access to async API of `AsyncSender`\u27e821\u27e9 and `AsyncReceiver`\u27e820\u27e9 with `to_sync`, `as_async` or `clone_sync` based on your requirements, by calling them on sender or receiver.\n\nunbounded_async\u27e837\u27e9\n    Creates a new async unbounded channel, and returns `AsyncSender`\u27e821\u27e9 and `AsyncReceiver`\u27e820\u27e9 of the channel for type T, you can get access to sync API of `Sender`\u27e822\u27e9 and `Receiver`\u27e826\u27e9 with `to_sync`, `as_async` or `clone_sync` based on your requirements, by calling them on async sender or receiver.\n",
            "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/kanal/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/kanal/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/kanal/latest/src/kanal/lib.rs.html#1-1644: Source\n\u27e84\u27e9 https://docs.rs/kanal/latest/kanal/#kanal: \u00a7\n\u27e85\u27e9 https://img.shields.io/crates/v/kanal.svg?style=for-the-badge: ![Crates.io\n\u27e86\u27e9 https://img.shields.io/docsrs/kanal?style=for-the-badge: ![Documentation\n\u27e87\u27e9 https://img.shields.io/badge/license-MIT-blue.svg?style=for-the-badge: ![MIT licensed\n\u27e88\u27e9 https://docs.rs/kanal/latest/kanal/#what-is-kanal: \u00a7\n\u27e89\u27e9 https://docs.rs/kanal/latest/kanal/#why-kanal-is-faster: \u00a7\n\u27e810\u27e9 https://docs.rs/kanal/latest/kanal/#usage: \u00a7\n\u27e811\u27e9 https://docs.rs/kanal/latest/kanal/: This example is not tested - \u24d8\n\u27e812\u27e9 https://docs.rs/kanal/latest/kanal/#why-use-kanal: \u00a7\n\u27e813\u27e9 https://docs.rs/kanal/latest/kanal/#benchmark-results: \u00a7\n\u27e814\u27e9 https://docs.rs/kanal/latest/kanal/#test-types: \u00a7\n\u27e815\u27e9 https://docs.rs/kanal/latest/kanal/#message-types: \u00a7\n\u27e816\u27e9 https://github.com/fereidani/rust-channel-benchmarks: Benchmark codes\n\u27e817\u27e9 https://i.imgur.com/VPwyam0.png: Benchmarks\n\u27e818\u27e9 https://docs.rs/kanal/latest/kanal/#why-does-async-outperform-sync-in-some-tests: \u00a7\n\u27e819\u27e9 https://docs.rs/kanal/latest/kanal/#structs: \u00a7\n\u27e820\u27e9 https://docs.rs/kanal/latest/kanal/struct.AsyncReceiver.html: struct kanal::AsyncReceiver - AsyncReceiver\n\u27e821\u27e9 https://docs.rs/kanal/latest/kanal/struct.AsyncSender.html: struct kanal::AsyncSender - AsyncSender\n\u27e822\u27e9 https://docs.rs/kanal/latest/kanal/struct.Sender.html: struct kanal::Sender - `Sender`\n\u27e823\u27e9 https://docs.rs/kanal/latest/kanal/struct.CloseError.html: struct kanal::CloseError - CloseError\n\u27e824\u27e9 https://docs.rs/kanal/latest/kanal/struct.ReceiveFuture.html: struct kanal::ReceiveFuture - ReceiveFuture\n\u27e825\u27e9 https://docs.rs/kanal/latest/kanal/struct.ReceiveStream.html: struct kanal::ReceiveStream - ReceiveStream\n\u27e826\u27e9 https://docs.rs/kanal/latest/kanal/struct.Receiver.html: struct kanal::Receiver - Receiver\n\u27e827\u27e9 https://docs.rs/kanal/latest/kanal/struct.SendFuture.html: struct kanal::SendFuture - SendFuture\n\u27e828\u27e9 https://docs.rs/kanal/latest/kanal/#enums: \u00a7\n\u27e829\u27e9 https://docs.rs/kanal/latest/kanal/enum.ReceiveError.html: enum kanal::ReceiveError - ReceiveError\n\u27e830\u27e9 https://docs.rs/kanal/latest/kanal/enum.ReceiveErrorTimeout.html: enum kanal::ReceiveErrorTimeout - ReceiveErrorTimeout\n\u27e831\u27e9 https://docs.rs/kanal/latest/kanal/enum.SendError.html: enum kanal::SendError - SendError\n\u27e832\u27e9 https://docs.rs/kanal/latest/kanal/enum.SendErrorTimeout.html: enum kanal::SendErrorTimeout - SendErrorTimeout\n\u27e833\u27e9 https://docs.rs/kanal/latest/kanal/#functions: \u00a7\n\u27e834\u27e9 https://docs.rs/kanal/latest/kanal/fn.bounded.html: fn kanal::bounded - bounded\n\u27e835\u27e9 https://docs.rs/kanal/latest/kanal/fn.bounded_async.html: fn kanal::bounded_async - bounded_async\n\u27e836\u27e9 https://docs.rs/kanal/latest/kanal/fn.unbounded.html: fn kanal::unbounded - unbounded\n\u27e837\u27e9 https://docs.rs/kanal/latest/kanal/fn.unbounded_async.html: fn kanal::unbounded_async - unbounded_async\n",
            "fit_markdown": "",
            "fit_html": ""
          },
          "downloads": 0,
          "github_stars": 0,
          "dependencies": [],
          "features": {},
          "code_snippets": [],
          "readme_sections": {},
          "librs_downloads": null,
          "source": "crates.io",
          "enhanced_scraping": {},
          "enhanced_features": [],
          "enhanced_dependencies": []
        },
        "enriched_crate": {
          "name": "kanal",
          "version": "0.1.1",
          "description": "ALLOW: Positive community sentiment",
          "repository": "",
          "keywords": [],
          "categories": [],
          "readme": {
            "raw_markdown": "[](https://docs.rs/kanal/latest/kanal/all.html \"show sidebar\")\n# Crate kanalCopy item path\n[Settings](https://docs.rs/kanal/latest/settings.html)\n[Help](https://docs.rs/kanal/latest/help.html)\nSummary[Source](https://docs.rs/kanal/latest/src/kanal/lib.rs.html#1-1644)\nExpand description\n## [\u00a7](https://docs.rs/kanal/latest/kanal/#kanal)Kanal\n**The fast sync and async channel that Rust deserves!**\n[![Crates.io](https://img.shields.io/crates/v/kanal.svg?style=for-the-badge)](https://crates.io/crates/kanal) [![Documentation](https://img.shields.io/docsrs/kanal?style=for-the-badge)](https://docs.rs/kanal) [![MIT licensed](https://img.shields.io/badge/license-MIT-blue.svg?style=for-the-badge)](https://github.com/fereidani/kanal/blob/master/LICENSE)\n### [\u00a7](https://docs.rs/kanal/latest/kanal/#what-is-kanal)What is Kanal\nThe Kanal library is a Rust implementation of channels inspired by the CSP (Communicating Sequential Processes) model. It aims to help programmers create efficient concurrent programs by providing multi-producer and multi-consumer channels with advanced features for fast communication. The library focuses on unifying message passing between synchronous and asynchronous parts of Rust code, offering a combination of synchronous and asynchronous APIs while maintaining high performance.\n### [\u00a7](https://docs.rs/kanal/latest/kanal/#why-kanal-is-faster)Why Kanal is faster?\n  1. Kanal employs a highly optimized composite technique for the transfer of objects. When the data size is less than or equal to the pointer size, it utilizes serialization, encoding the data as the pointer address. Conversely, when the data size exceeds the pointer size, the protocol employs a strategy similar to that utilized by the Golang programming language, utilizing direct memory access to copy objects from the sender\u2019s stack or write directly to the receiver\u2019s stack. This composite method not only eliminates unnecessary pointer access but also eliminates heap allocations for bounded(0) channels.\n  2. Kanal utilizes a specially tuned mutex for its channel locking mechanism, made possible by the predictable internal lock time of the channel. That said it\u2019s possible to use Rust standard mutex with the `std-mutex` feature and Kanal will perform better than competitors with that feature too.\n  3. Utilizing Rust high-performance compiler and powerful LLVM backend with highly optimized memory access and deeply thought algorithms.\n\n\n### [\u00a7](https://docs.rs/kanal/latest/kanal/#usage)Usage\nTo use Kanal in your Rust project, add the following line to your `Cargo.toml` file:\n```\n[dependencies]\nkanal = \"0.1\"\n```\n\nSync channel example:\n[\u24d8](https://docs.rs/kanal/latest/kanal/ \"This example is not tested\")```\n// Initialize a bounded sync channel with a capacity for 8 messages\nlet (sender, receiver) = kanal::bounded(8);\nlet s = sender.clone();\nstd::thread::spawn(move || {\n  s.send(\"hello\")?;\n  anyhow::Ok(())\n});\n// Receive an example message in another thread\nlet msg = receiver.recv()?;\nprintln!(\"I got msg: {}\", msg);\n\n// Convert and use channel in async context to communicate between sync and async\ntokio::spawn(async move {\n  // Borrow the channel as an async channel and use it in an async context ( or convert it to async using to_async() )\n  sender.as_async().send(\"hello\").await?;\n  anyhow::Ok(())\n});\n```\n\nAsync channel example:\n[\u24d8](https://docs.rs/kanal/latest/kanal/ \"This example is not tested\")```\n// Initialize a bounded channel with a capacity for 8 messages\nlet (sender, receiver) = kanal::bounded_async(8);\nsender.send(\"hello\").await?;\nsender.send(\"hello\").await?;\n// Clone receiver and convert it to a sync receiver\nlet receiver_sync = receiver.clone().to_sync();\ntokio::spawn(async move {\n  let msg = receiver.recv().await?;\n  println!(\"I got msg: {}\", msg);\n  anyhow::Ok(())\n});\n// Spawn a thread and use receiver in sync context\nstd::thread::spawn(move || {\n  let msg = receiver_sync.recv()?;\n  println!(\"I got msg in sync context: {}\", msg);\n  anyhow::Ok(())\n});\n```\n\n### [\u00a7](https://docs.rs/kanal/latest/kanal/#why-use-kanal)Why use Kanal?\n  * Kanal offers fast and efficient communication capabilities.\n  * Kanal simplifies communication in and between synchronous and asynchronous contexts, thanks to its flexible API like `as_sync` and `as_async`.\n  * Kanal provides a clean and intuitive API, making it easier to work with compared to other Rust libraries.\n  * Similar to Golang, Kanal allows you to close channels using the `Close` function, enabling you to broadcast a close signal from any channel instance and close the channel for both senders and receivers.\n  * Kanal includes high-performance MPMC (Multiple Producers Multiple Consumers) and SPSC (Single Producer Single Consumer) channels in a single package.\n\n\n#### [\u00a7](https://docs.rs/kanal/latest/kanal/#benchmark-results)Benchmark Results\nResults are based on how many messages can be passed in each scenario per second.\n##### [\u00a7](https://docs.rs/kanal/latest/kanal/#test-types)Test types:\n  1. Seq is sequentially writing and reading to a channel in the same thread.\n  2. SPSC is one receiver, and one sender and passing messages between them.\n  3. MPSC is multiple sender threads with only one receiver.\n  4. MPMC is multiple senders and multiple receivers communicating through the same channel.\n\n\n##### [\u00a7](https://docs.rs/kanal/latest/kanal/#message-types)Message types:\n  1. `usize` tests are transferring messages of size hardware pointer.\n  2. `big` tests are transferring messages of 8x the size of the hardware pointer.\n\n\nN/A means that the test subject is unable to perform the test due to its limitations, Some of the test subjects don\u2019t have implementation for size 0 channels, MPMC or unbounded channels.\nMachine: `AMD Ryzen 9 9950X 16-Core Processor` Rust: `rustc 1.85.1 (4eb161250 2025-03-15)` Go: `go version go1.24.1 linux/amd64` OS (`uname -a`): `Linux 6.11.0-19-generic #19~24.04.1-Ubuntu SMP PREEMPT_DYNAMIC Mon Feb 17 11:51:52 UTC 2 x86_64` Date: Mar 19, 2025\n[Benchmark codes](https://github.com/fereidani/rust-channel-benchmarks)\n![Benchmarks](https://i.imgur.com/VPwyam0.png)\n##### [\u00a7](https://docs.rs/kanal/latest/kanal/#why-does-async-outperform-sync-in-some-tests)Why does async outperform sync in some tests?\nIn certain tests, asynchronous communication may exhibit superior performance compared to synchronous communication. This can be attributed to the context-switching performance of libraries such as tokio, which, similar to Golang, utilize context-switching within the same thread to switch to the next coroutine when a message is ready on a channel. This approach is more efficient than communicating between separate threads. This same principle applies to asynchronous network applications, which generally exhibit better performance compared to synchronous implementations. As the channel size increases, one may observe improved performance in synchronous benchmarks, as the sending threads are able to push data directly to the channel queue without requiring awaiting blocking/suspending signals from receiving threads.\n## Structs[\u00a7](https://docs.rs/kanal/latest/kanal/#structs)\n\n[AsyncReceiver](https://docs.rs/kanal/latest/kanal/struct.AsyncReceiver.html \"struct kanal::AsyncReceiver\")\n    [`AsyncReceiver`](https://docs.rs/kanal/latest/kanal/struct.AsyncReceiver.html \"struct kanal::AsyncReceiver\") is receiving side of the channel in async mode. Receivers can be cloned and produce receivers to operate in both sync and async modes.\n\n[AsyncSender](https://docs.rs/kanal/latest/kanal/struct.AsyncSender.html \"struct kanal::AsyncSender\")\n    Sending side of the channel with async API. It\u2019s possible to convert it to sync [`Sender`](https://docs.rs/kanal/latest/kanal/struct.Sender.html \"struct kanal::Sender\") with `as_sync`, `to_sync` or `clone_sync` based on software requirement.\n\n[CloseError](https://docs.rs/kanal/latest/kanal/struct.CloseError.html \"struct kanal::CloseError\")\n    Error type for closing a channel when channel is already closed\n\n[ReceiveFuture](https://docs.rs/kanal/latest/kanal/struct.ReceiveFuture.html \"struct kanal::ReceiveFuture\")\n    ReceiveFuture is a future for receiving an object from a channel asynchronously. It must be polled to complete the receive operation.\n\n[ReceiveStream](https://docs.rs/kanal/latest/kanal/struct.ReceiveStream.html \"struct kanal::ReceiveStream\")\n    ReceiveStream is a stream for receiving objects from a channel asynchronously.\n\n[Receiver](https://docs.rs/kanal/latest/kanal/struct.Receiver.html \"struct kanal::Receiver\")\n    Receiving side of the channel in sync mode. Receivers can be cloned and produce receivers to operate in both sync and async modes.\n\n[SendFuture](https://docs.rs/kanal/latest/kanal/struct.SendFuture.html \"struct kanal::SendFuture\")\n    SendFuture is a future for sending an object to a channel asynchronously. It must be polled to complete the send operation.\n\n[Sender](https://docs.rs/kanal/latest/kanal/struct.Sender.html \"struct kanal::Sender\")\n    Sending side of the channel with sync API. It\u2019s possible to convert it to async [`AsyncSender`](https://docs.rs/kanal/latest/kanal/struct.AsyncSender.html \"struct kanal::AsyncSender\") with `as_async`, `to_async` or `clone_async` based on software requirement.\n## Enums[\u00a7](https://docs.rs/kanal/latest/kanal/#enums)\n\n[ReceiveError](https://docs.rs/kanal/latest/kanal/enum.ReceiveError.html \"enum kanal::ReceiveError\")\n    Error type for channel receive operations without timeout\n\n[ReceiveErrorTimeout](https://docs.rs/kanal/latest/kanal/enum.ReceiveErrorTimeout.html \"enum kanal::ReceiveErrorTimeout\")\n    Error type for channel receive operations with timeout\n\n[SendError](https://docs.rs/kanal/latest/kanal/enum.SendError.html \"enum kanal::SendError\")\n    Error type for channel send operations without timeout\n\n[SendErrorTimeout](https://docs.rs/kanal/latest/kanal/enum.SendErrorTimeout.html \"enum kanal::SendErrorTimeout\")\n    Error type for channel send operations with timeout\n## Functions[\u00a7](https://docs.rs/kanal/latest/kanal/#functions)\n\n[bounded](https://docs.rs/kanal/latest/kanal/fn.bounded.html \"fn kanal::bounded\")\n    Creates a new sync bounded channel with the requested buffer size, and returns [`Sender`](https://docs.rs/kanal/latest/kanal/struct.Sender.html \"struct kanal::Sender\") and [`Receiver`](https://docs.rs/kanal/latest/kanal/struct.Receiver.html \"struct kanal::Receiver\") of the channel for type T, you can get access to async API of [`AsyncSender`](https://docs.rs/kanal/latest/kanal/struct.AsyncSender.html \"struct kanal::AsyncSender\") and [`AsyncReceiver`](https://docs.rs/kanal/latest/kanal/struct.AsyncReceiver.html \"struct kanal::AsyncReceiver\") with `to_sync`, `as_async` or `clone_sync` based on your requirements, by calling them on sender or receiver.\n\n[bounded_async](https://docs.rs/kanal/latest/kanal/fn.bounded_async.html \"fn kanal::bounded_async\")\n    Creates a new async bounded channel with the requested buffer size, and returns [`AsyncSender`](https://docs.rs/kanal/latest/kanal/struct.AsyncSender.html \"struct kanal::AsyncSender\") and [`AsyncReceiver`](https://docs.rs/kanal/latest/kanal/struct.AsyncReceiver.html \"struct kanal::AsyncReceiver\") of the channel for type T, you can get access to sync API of [`Sender`](https://docs.rs/kanal/latest/kanal/struct.Sender.html \"struct kanal::Sender\") and [`Receiver`](https://docs.rs/kanal/latest/kanal/struct.Receiver.html \"struct kanal::Receiver\") with `to_sync`, `as_async` or `clone_sync` based on your requirements, by calling them on async sender or receiver.\n\n[unbounded](https://docs.rs/kanal/latest/kanal/fn.unbounded.html \"fn kanal::unbounded\")\n    Creates a new sync unbounded channel, and returns [`Sender`](https://docs.rs/kanal/latest/kanal/struct.Sender.html \"struct kanal::Sender\") and [`Receiver`](https://docs.rs/kanal/latest/kanal/struct.Receiver.html \"struct kanal::Receiver\") of the channel for type T, you can get access to async API of [`AsyncSender`](https://docs.rs/kanal/latest/kanal/struct.AsyncSender.html \"struct kanal::AsyncSender\") and [`AsyncReceiver`](https://docs.rs/kanal/latest/kanal/struct.AsyncReceiver.html \"struct kanal::AsyncReceiver\") with `to_sync`, `as_async` or `clone_sync` based on your requirements, by calling them on sender or receiver.\n\n[unbounded_async](https://docs.rs/kanal/latest/kanal/fn.unbounded_async.html \"fn kanal::unbounded_async\")\n    Creates a new async unbounded channel, and returns [`AsyncSender`](https://docs.rs/kanal/latest/kanal/struct.AsyncSender.html \"struct kanal::AsyncSender\") and [`AsyncReceiver`](https://docs.rs/kanal/latest/kanal/struct.AsyncReceiver.html \"struct kanal::AsyncReceiver\") of the channel for type T, you can get access to sync API of [`Sender`](https://docs.rs/kanal/latest/kanal/struct.Sender.html \"struct kanal::Sender\") and [`Receiver`](https://docs.rs/kanal/latest/kanal/struct.Receiver.html \"struct kanal::Receiver\") with `to_sync`, `as_async` or `clone_sync` based on your requirements, by calling them on async sender or receiver.\n",
            "markdown_with_citations": "[](https://docs.rs/kanal/latest/kanal/all.html \"show sidebar\")\n# Crate kanalCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\n## \u00a7\u27e84\u27e9Kanal\n**The fast sync and async channel that Rust deserves!**\n![Crates.io\u27e85\u27e9](https://crates.io/crates/kanal) ![Documentation\u27e86\u27e9](https://docs.rs/kanal) ![MIT licensed\u27e87\u27e9](https://github.com/fereidani/kanal/blob/master/LICENSE)\n### \u00a7\u27e88\u27e9What is Kanal\nThe Kanal library is a Rust implementation of channels inspired by the CSP (Communicating Sequential Processes) model. It aims to help programmers create efficient concurrent programs by providing multi-producer and multi-consumer channels with advanced features for fast communication. The library focuses on unifying message passing between synchronous and asynchronous parts of Rust code, offering a combination of synchronous and asynchronous APIs while maintaining high performance.\n### \u00a7\u27e89\u27e9Why Kanal is faster?\n  1. Kanal employs a highly optimized composite technique for the transfer of objects. When the data size is less than or equal to the pointer size, it utilizes serialization, encoding the data as the pointer address. Conversely, when the data size exceeds the pointer size, the protocol employs a strategy similar to that utilized by the Golang programming language, utilizing direct memory access to copy objects from the sender\u2019s stack or write directly to the receiver\u2019s stack. This composite method not only eliminates unnecessary pointer access but also eliminates heap allocations for bounded(0) channels.\n  2. Kanal utilizes a specially tuned mutex for its channel locking mechanism, made possible by the predictable internal lock time of the channel. That said it\u2019s possible to use Rust standard mutex with the `std-mutex` feature and Kanal will perform better than competitors with that feature too.\n  3. Utilizing Rust high-performance compiler and powerful LLVM backend with highly optimized memory access and deeply thought algorithms.\n\n\n### \u00a7\u27e810\u27e9Usage\nTo use Kanal in your Rust project, add the following line to your `Cargo.toml` file:\n```\n[dependencies]\nkanal = \"0.1\"\n```\n\nSync channel example:\n\u24d8\u27e811\u27e9```\n// Initialize a bounded sync channel with a capacity for 8 messages\nlet (sender, receiver) = kanal::bounded(8);\nlet s = sender.clone();\nstd::thread::spawn(move || {\n  s.send(\"hello\")?;\n  anyhow::Ok(())\n});\n// Receive an example message in another thread\nlet msg = receiver.recv()?;\nprintln!(\"I got msg: {}\", msg);\n\n// Convert and use channel in async context to communicate between sync and async\ntokio::spawn(async move {\n  // Borrow the channel as an async channel and use it in an async context ( or convert it to async using to_async() )\n  sender.as_async().send(\"hello\").await?;\n  anyhow::Ok(())\n});\n```\n\nAsync channel example:\n\u24d8\u27e811\u27e9```\n// Initialize a bounded channel with a capacity for 8 messages\nlet (sender, receiver) = kanal::bounded_async(8);\nsender.send(\"hello\").await?;\nsender.send(\"hello\").await?;\n// Clone receiver and convert it to a sync receiver\nlet receiver_sync = receiver.clone().to_sync();\ntokio::spawn(async move {\n  let msg = receiver.recv().await?;\n  println!(\"I got msg: {}\", msg);\n  anyhow::Ok(())\n});\n// Spawn a thread and use receiver in sync context\nstd::thread::spawn(move || {\n  let msg = receiver_sync.recv()?;\n  println!(\"I got msg in sync context: {}\", msg);\n  anyhow::Ok(())\n});\n```\n\n### \u00a7\u27e812\u27e9Why use Kanal?\n  * Kanal offers fast and efficient communication capabilities.\n  * Kanal simplifies communication in and between synchronous and asynchronous contexts, thanks to its flexible API like `as_sync` and `as_async`.\n  * Kanal provides a clean and intuitive API, making it easier to work with compared to other Rust libraries.\n  * Similar to Golang, Kanal allows you to close channels using the `Close` function, enabling you to broadcast a close signal from any channel instance and close the channel for both senders and receivers.\n  * Kanal includes high-performance MPMC (Multiple Producers Multiple Consumers) and SPSC (Single Producer Single Consumer) channels in a single package.\n\n\n#### \u00a7\u27e813\u27e9Benchmark Results\nResults are based on how many messages can be passed in each scenario per second.\n##### \u00a7\u27e814\u27e9Test types:\n  1. Seq is sequentially writing and reading to a channel in the same thread.\n  2. SPSC is one receiver, and one sender and passing messages between them.\n  3. MPSC is multiple sender threads with only one receiver.\n  4. MPMC is multiple senders and multiple receivers communicating through the same channel.\n\n\n##### \u00a7\u27e815\u27e9Message types:\n  1. `usize` tests are transferring messages of size hardware pointer.\n  2. `big` tests are transferring messages of 8x the size of the hardware pointer.\n\n\nN/A means that the test subject is unable to perform the test due to its limitations, Some of the test subjects don\u2019t have implementation for size 0 channels, MPMC or unbounded channels.\nMachine: `AMD Ryzen 9 9950X 16-Core Processor` Rust: `rustc 1.85.1 (4eb161250 2025-03-15)` Go: `go version go1.24.1 linux/amd64` OS (`uname -a`): `Linux 6.11.0-19-generic #19~24.04.1-Ubuntu SMP PREEMPT_DYNAMIC Mon Feb 17 11:51:52 UTC 2 x86_64` Date: Mar 19, 2025\nBenchmark codes\u27e816\u27e9\n![Benchmarks\u27e817\u27e9]\n##### \u00a7\u27e818\u27e9Why does async outperform sync in some tests?\nIn certain tests, asynchronous communication may exhibit superior performance compared to synchronous communication. This can be attributed to the context-switching performance of libraries such as tokio, which, similar to Golang, utilize context-switching within the same thread to switch to the next coroutine when a message is ready on a channel. This approach is more efficient than communicating between separate threads. This same principle applies to asynchronous network applications, which generally exhibit better performance compared to synchronous implementations. As the channel size increases, one may observe improved performance in synchronous benchmarks, as the sending threads are able to push data directly to the channel queue without requiring awaiting blocking/suspending signals from receiving threads.\n## Structs\u00a7\u27e819\u27e9\n\nAsyncReceiver\u27e820\u27e9\n    `AsyncReceiver`\u27e820\u27e9 is receiving side of the channel in async mode. Receivers can be cloned and produce receivers to operate in both sync and async modes.\n\nAsyncSender\u27e821\u27e9\n    Sending side of the channel with async API. It\u2019s possible to convert it to sync `Sender`\u27e822\u27e9 with `as_sync`, `to_sync` or `clone_sync` based on software requirement.\n\nCloseError\u27e823\u27e9\n    Error type for closing a channel when channel is already closed\n\nReceiveFuture\u27e824\u27e9\n    ReceiveFuture is a future for receiving an object from a channel asynchronously. It must be polled to complete the receive operation.\n\nReceiveStream\u27e825\u27e9\n    ReceiveStream is a stream for receiving objects from a channel asynchronously.\n\nReceiver\u27e826\u27e9\n    Receiving side of the channel in sync mode. Receivers can be cloned and produce receivers to operate in both sync and async modes.\n\nSendFuture\u27e827\u27e9\n    SendFuture is a future for sending an object to a channel asynchronously. It must be polled to complete the send operation.\n\nSender\u27e822\u27e9\n    Sending side of the channel with sync API. It\u2019s possible to convert it to async `AsyncSender`\u27e821\u27e9 with `as_async`, `to_async` or `clone_async` based on software requirement.\n## Enums\u00a7\u27e828\u27e9\n\nReceiveError\u27e829\u27e9\n    Error type for channel receive operations without timeout\n\nReceiveErrorTimeout\u27e830\u27e9\n    Error type for channel receive operations with timeout\n\nSendError\u27e831\u27e9\n    Error type for channel send operations without timeout\n\nSendErrorTimeout\u27e832\u27e9\n    Error type for channel send operations with timeout\n## Functions\u00a7\u27e833\u27e9\n\nbounded\u27e834\u27e9\n    Creates a new sync bounded channel with the requested buffer size, and returns `Sender`\u27e822\u27e9 and `Receiver`\u27e826\u27e9 of the channel for type T, you can get access to async API of `AsyncSender`\u27e821\u27e9 and `AsyncReceiver`\u27e820\u27e9 with `to_sync`, `as_async` or `clone_sync` based on your requirements, by calling them on sender or receiver.\n\nbounded_async\u27e835\u27e9\n    Creates a new async bounded channel with the requested buffer size, and returns `AsyncSender`\u27e821\u27e9 and `AsyncReceiver`\u27e820\u27e9 of the channel for type T, you can get access to sync API of `Sender`\u27e822\u27e9 and `Receiver`\u27e826\u27e9 with `to_sync`, `as_async` or `clone_sync` based on your requirements, by calling them on async sender or receiver.\n\nunbounded\u27e836\u27e9\n    Creates a new sync unbounded channel, and returns `Sender`\u27e822\u27e9 and `Receiver`\u27e826\u27e9 of the channel for type T, you can get access to async API of `AsyncSender`\u27e821\u27e9 and `AsyncReceiver`\u27e820\u27e9 with `to_sync`, `as_async` or `clone_sync` based on your requirements, by calling them on sender or receiver.\n\nunbounded_async\u27e837\u27e9\n    Creates a new async unbounded channel, and returns `AsyncSender`\u27e821\u27e9 and `AsyncReceiver`\u27e820\u27e9 of the channel for type T, you can get access to sync API of `Sender`\u27e822\u27e9 and `Receiver`\u27e826\u27e9 with `to_sync`, `as_async` or `clone_sync` based on your requirements, by calling them on async sender or receiver.\n",
            "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/kanal/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/kanal/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/kanal/latest/src/kanal/lib.rs.html#1-1644: Source\n\u27e84\u27e9 https://docs.rs/kanal/latest/kanal/#kanal: \u00a7\n\u27e85\u27e9 https://img.shields.io/crates/v/kanal.svg?style=for-the-badge: ![Crates.io\n\u27e86\u27e9 https://img.shields.io/docsrs/kanal?style=for-the-badge: ![Documentation\n\u27e87\u27e9 https://img.shields.io/badge/license-MIT-blue.svg?style=for-the-badge: ![MIT licensed\n\u27e88\u27e9 https://docs.rs/kanal/latest/kanal/#what-is-kanal: \u00a7\n\u27e89\u27e9 https://docs.rs/kanal/latest/kanal/#why-kanal-is-faster: \u00a7\n\u27e810\u27e9 https://docs.rs/kanal/latest/kanal/#usage: \u00a7\n\u27e811\u27e9 https://docs.rs/kanal/latest/kanal/: This example is not tested - \u24d8\n\u27e812\u27e9 https://docs.rs/kanal/latest/kanal/#why-use-kanal: \u00a7\n\u27e813\u27e9 https://docs.rs/kanal/latest/kanal/#benchmark-results: \u00a7\n\u27e814\u27e9 https://docs.rs/kanal/latest/kanal/#test-types: \u00a7\n\u27e815\u27e9 https://docs.rs/kanal/latest/kanal/#message-types: \u00a7\n\u27e816\u27e9 https://github.com/fereidani/rust-channel-benchmarks: Benchmark codes\n\u27e817\u27e9 https://i.imgur.com/VPwyam0.png: Benchmarks\n\u27e818\u27e9 https://docs.rs/kanal/latest/kanal/#why-does-async-outperform-sync-in-some-tests: \u00a7\n\u27e819\u27e9 https://docs.rs/kanal/latest/kanal/#structs: \u00a7\n\u27e820\u27e9 https://docs.rs/kanal/latest/kanal/struct.AsyncReceiver.html: struct kanal::AsyncReceiver - AsyncReceiver\n\u27e821\u27e9 https://docs.rs/kanal/latest/kanal/struct.AsyncSender.html: struct kanal::AsyncSender - AsyncSender\n\u27e822\u27e9 https://docs.rs/kanal/latest/kanal/struct.Sender.html: struct kanal::Sender - `Sender`\n\u27e823\u27e9 https://docs.rs/kanal/latest/kanal/struct.CloseError.html: struct kanal::CloseError - CloseError\n\u27e824\u27e9 https://docs.rs/kanal/latest/kanal/struct.ReceiveFuture.html: struct kanal::ReceiveFuture - ReceiveFuture\n\u27e825\u27e9 https://docs.rs/kanal/latest/kanal/struct.ReceiveStream.html: struct kanal::ReceiveStream - ReceiveStream\n\u27e826\u27e9 https://docs.rs/kanal/latest/kanal/struct.Receiver.html: struct kanal::Receiver - Receiver\n\u27e827\u27e9 https://docs.rs/kanal/latest/kanal/struct.SendFuture.html: struct kanal::SendFuture - SendFuture\n\u27e828\u27e9 https://docs.rs/kanal/latest/kanal/#enums: \u00a7\n\u27e829\u27e9 https://docs.rs/kanal/latest/kanal/enum.ReceiveError.html: enum kanal::ReceiveError - ReceiveError\n\u27e830\u27e9 https://docs.rs/kanal/latest/kanal/enum.ReceiveErrorTimeout.html: enum kanal::ReceiveErrorTimeout - ReceiveErrorTimeout\n\u27e831\u27e9 https://docs.rs/kanal/latest/kanal/enum.SendError.html: enum kanal::SendError - SendError\n\u27e832\u27e9 https://docs.rs/kanal/latest/kanal/enum.SendErrorTimeout.html: enum kanal::SendErrorTimeout - SendErrorTimeout\n\u27e833\u27e9 https://docs.rs/kanal/latest/kanal/#functions: \u00a7\n\u27e834\u27e9 https://docs.rs/kanal/latest/kanal/fn.bounded.html: fn kanal::bounded - bounded\n\u27e835\u27e9 https://docs.rs/kanal/latest/kanal/fn.bounded_async.html: fn kanal::bounded_async - bounded_async\n\u27e836\u27e9 https://docs.rs/kanal/latest/kanal/fn.unbounded.html: fn kanal::unbounded - unbounded\n\u27e837\u27e9 https://docs.rs/kanal/latest/kanal/fn.unbounded_async.html: fn kanal::unbounded_async - unbounded_async\n",
            "fit_markdown": "",
            "fit_html": ""
          },
          "downloads": 0,
          "github_stars": 0,
          "dependencies": [],
          "features": {},
          "code_snippets": [],
          "readme_sections": {},
          "librs_downloads": null,
          "source": "crates.io",
          "enhanced_scraping": {},
          "enhanced_features": [],
          "enhanced_dependencies": [],
          "readme_summary": "The `kanal` crate provides fast, efficient, and flexible multi-producer, multi-consumer (MPMC) and single-producer, single-consumer (SPSC) channels for message passing in Rust, inspired by the CSP model. It unifies synchronous and asynchronous communication with APIs like `as_sync` and `as_async`, supports closing channels, and employs optimized techniques for high performance, including direct memory access and custom mutexes. Designed for both sync and async contexts, it simplifies concurrent programming with a clean API and benchmark-proven speed.",
          "feature_summary": null,
          "use_case": "Networking",
          "score": 6.0,
          "factual_counterfactual": "### Pair 1: Channel Types and Flexibility\n\u2705 Factual: Kanal supports both synchronous and asynchronous channels, allowing seamless communication between sync and async contexts using methods like `as_sync` and `as_async`.  \n\u274c Counterfactual: Kanal only supports synchronous channels and cannot be used in asynchronous contexts without external wrappers.\n\n---\n\n### Pair 2: Performance Optimization\n\u2705 Factual: Kanal employs a composite technique for data transfer, optimizing for both small and large data sizes by avoiding unnecessary heap allocations for bounded channels.  \n\u274c Counterfactual: Kanal relies exclusively on heap allocations for all data transfers, regardless of the channel type or data size.\n\n---\n\n### Pair 3: Benchmark Scenarios\n\u2705 Factual: Kanal provides benchmark results for multiple communication patterns, including SPSC (Single Producer Single Consumer) and MPMC (Multiple Producers Multiple Consumers), to showcase its performance.  \n\u274c Counterfactual: Kanal does not support MPMC channels and is limited to single-producer single-consumer scenarios.",
          "source_analysis": null,
          "user_behavior": null,
          "security": null
        }
      },
      "irl_score": 8.6,
      "execution_id": "exec-90916434-a082cf5b-1751263085",
      "timestamp": "2025-06-30T05:58:05.587918+00:00",
      "canon_version": "1.3.0"
    },
    "rule_zero_compliant": true
  }
]