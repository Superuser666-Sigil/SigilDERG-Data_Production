[
  {
    "execution_id": "exec-f2d1c066-32df36ed-1751265740",
    "timestamp": "2025-06-30T06:42:20.715938+00:00",
    "sacred_chain": {
      "input_data": "glam",
      "context_sources": [
        "crates.io",
        "github.com",
        "lib.rs",
        "docs.rs"
      ],
      "reasoning_steps": [
        "Input canonicalized: 'glam' -> 'glam'",
        "Context gathered from 4 validated sources",
        "Metadata extracted: 4 fields",
        "Documentation analyzed: quality 7.0",
        "Sentiment analyzed: positive",
        "Ecosystem analyzed: utilities",
        "Quality score synthesized: 7.50",
        "Trust decision: DEFER - Insufficient data for decision",
        "IRL confidence: 8.600"
      ],
      "suggestion": "ALLOW: Positive community sentiment",
      "verdict": "DEFER",
      "audit_info": {
        "metadata": {
          "name": "glam",
          "type": "rust_crate",
          "source": "manual_input",
          "extraction_method": "irl_engine"
        },
        "sentiment": {
          "quality_score": 7.0,
          "completeness": 0.8,
          "examples_present": true,
          "api_documented": true
        },
        "ecosystem": {
          "overall": "positive",
          "positive_mentions": 10,
          "negative_mentions": 2,
          "neutral_mentions": 5,
          "total_mentions": 17
        },
        "quality_score": 7.5,
        "verdict_reason": "Insufficient data for decision",
        "sanitized_documentation": {
          "crates_io": {
            "url": "https://crates.io/crates/glam",
            "title": "glam v0.30.4",
            "content": {
              "raw_markdown": "#  glam v0.30.4\nA simple and fast 3D math library for games and graphics \n  * [ #gamedev ](https://crates.io/keywords/gamedev)\n  * [ #math ](https://crates.io/keywords/math)\n  * [ #matrix ](https://crates.io/keywords/matrix)\n  * [ #quaternion ](https://crates.io/keywords/quaternion)\n  * [ #vector ](https://crates.io/keywords/vector)\n\n\n  * [ Readme ](https://crates.io/crates/glam)\n  * [ 74 Versions ](https://crates.io/crates/glam/versions)\n  * [ Dependencies ](https://crates.io/crates/glam/dependencies)\n  * [ Dependents ](https://crates.io/crates/glam/reverse_dependencies)\n\n\n## Metadata\n18 days ago \nv1.68.2 \n[ MIT ](https://choosealicense.com/licenses/mit) OR [ Apache-2.0 ](https://choosealicense.com/licenses/apache-2.0)\n737 KiB \n## Install\nRun the following Cargo command in your project directory:\ncargo add glam\nOr add the following line to your Cargo.toml:\nglam = \"0.30.4\"\n## Repository\n[ github.com/bitshifter/glam-rs ](https://github.com/bitshifter/glam-rs)\n## Owners\n## Categories\n  * [No standard library](https://crates.io/categories/no-std)\n  * [Game engines](https://crates.io/categories/game-engines)\n\n\n[ Report crate ](https://crates.io/support?crate=glam&inquire=crate-violation)\n### Stats Overview\n11,028,039 Downloads all time\n74 Versions published\n#### Downloads over the last 90 days\nDisplay as \nStacked \n  * Stacked \n  * Unstacked \n\n\nLoading\u2026\n",
              "markdown_with_citations": "#  glam v0.30.4\nA simple and fast 3D math library for games and graphics \n  *  #gamedev \u27e81\u27e9\n  *  #math \u27e82\u27e9\n  *  #matrix \u27e83\u27e9\n  *  #quaternion \u27e84\u27e9\n  *  #vector \u27e85\u27e9\n\n\n  *  Readme \u27e86\u27e9\n  *  74 Versions \u27e87\u27e9\n  *  Dependencies \u27e88\u27e9\n  *  Dependents \u27e89\u27e9\n\n\n## Metadata\n18 days ago \nv1.68.2 \n MIT \u27e810\u27e9 OR  Apache-2.0 \u27e811\u27e9\n737 KiB \n## Install\nRun the following Cargo command in your project directory:\ncargo add glam\nOr add the following line to your Cargo.toml:\nglam = \"0.30.4\"\n## Repository\n github.com/bitshifter/glam-rs \u27e812\u27e9\n## Owners\n## Categories\n  * No standard library\u27e813\u27e9\n  * Game engines\u27e814\u27e9\n\n\n Report crate \u27e815\u27e9\n### Stats Overview\n11,028,039 Downloads all time\n74 Versions published\n#### Downloads over the last 90 days\nDisplay as \nStacked \n  * Stacked \n  * Unstacked \n\n\nLoading\u2026\n",
              "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://crates.io/keywords/gamedev:  #gamedev \n\u27e82\u27e9 https://crates.io/keywords/math:  #math \n\u27e83\u27e9 https://crates.io/keywords/matrix:  #matrix \n\u27e84\u27e9 https://crates.io/keywords/quaternion:  #quaternion \n\u27e85\u27e9 https://crates.io/keywords/vector:  #vector \n\u27e86\u27e9 https://crates.io/crates/glam:  Readme \n\u27e87\u27e9 https://crates.io/crates/glam/versions:  74 Versions \n\u27e88\u27e9 https://crates.io/crates/glam/dependencies:  Dependencies \n\u27e89\u27e9 https://crates.io/crates/glam/reverse_dependencies:  Dependents \n\u27e810\u27e9 https://choosealicense.com/licenses/mit:  MIT \n\u27e811\u27e9 https://choosealicense.com/licenses/apache-2.0:  Apache-2.0 \n\u27e812\u27e9 https://github.com/bitshifter/glam-rs:  github.com/bitshifter/glam-rs \n\u27e813\u27e9 https://crates.io/categories/no-std: No standard library\n\u27e814\u27e9 https://crates.io/categories/game-engines: Game engines\n\u27e815\u27e9 https://crates.io/support?crate=glam&inquire=crate-violation:  Report crate \n",
              "fit_markdown": "",
              "fit_html": ""
            },
            "structured_data": {},
            "quality_score": 3.0,
            "extraction_method": "crawl4ai",
            "error": null,
            "metadata": {
              "doc_type": "docs",
              "content_length": 1371,
              "has_structured_data": false,
              "crawl_success": true
            },
            "timestamp": "119530.467384"
          },
          "docs_rs": {
            "url": "https://docs.rs/glam",
            "title": "Crate glamCopy item path",
            "content": {
              "raw_markdown": "[](https://docs.rs/glam/latest/glam/all.html \"show sidebar\")\n# Crate glamCopy item path\n[Settings](https://docs.rs/glam/latest/settings.html)\n[Help](https://docs.rs/glam/latest/help.html)\nSummary[Source](https://docs.rs/glam/latest/src/glam/lib.rs.html#1-383)\nExpand description\n## [\u00a7](https://docs.rs/glam/latest/glam/#glam)glam\n`glam` is a simple and fast linear algebra library for games and graphics.\n### [\u00a7](https://docs.rs/glam/latest/glam/#features)Features\n  * [`f32`](https://docs.rs/glam/latest/glam/f32/index.html \"mod glam::f32\") types \n    * vectors: [`Vec2`](https://docs.rs/glam/latest/glam/f32/struct.Vec2.html \"struct glam::f32::Vec2\"), [`Vec3`](https://docs.rs/glam/latest/glam/f32/struct.Vec3.html \"struct glam::f32::Vec3\"), [`Vec3A`](https://docs.rs/glam/latest/glam/f32/struct.Vec3A.html \"struct glam::f32::Vec3A\") and [`Vec4`](https://docs.rs/glam/latest/glam/f32/struct.Vec4.html \"struct glam::f32::Vec4\")\n    * square matrices: [`Mat2`](https://docs.rs/glam/latest/glam/f32/struct.Mat2.html \"struct glam::f32::Mat2\"), [`Mat3`](https://docs.rs/glam/latest/glam/f32/struct.Mat3.html \"struct glam::f32::Mat3\"), [`Mat3A`](https://docs.rs/glam/latest/glam/f32/struct.Mat3A.html \"struct glam::f32::Mat3A\") and [`Mat4`](https://docs.rs/glam/latest/glam/f32/struct.Mat4.html \"struct glam::f32::Mat4\")\n    * a quaternion type: [`Quat`](https://docs.rs/glam/latest/glam/f32/struct.Quat.html \"struct glam::f32::Quat\")\n    * affine transformation types: [`Affine2`](https://docs.rs/glam/latest/glam/f32/struct.Affine2.html \"struct glam::f32::Affine2\") and [`Affine3A`](https://docs.rs/glam/latest/glam/f32/struct.Affine3A.html \"struct glam::f32::Affine3A\")\n  * [`f64`](https://docs.rs/glam/latest/glam/f64/index.html \"mod glam::f64\") types \n    * vectors: [`DVec2`](https://docs.rs/glam/latest/glam/f64/struct.DVec2.html \"struct glam::f64::DVec2\"), [`DVec3`](https://docs.rs/glam/latest/glam/f64/struct.DVec3.html \"struct glam::f64::DVec3\") and [`DVec4`](https://docs.rs/glam/latest/glam/f64/struct.DVec4.html \"struct glam::f64::DVec4\")\n    * square matrices: [`DMat2`](https://docs.rs/glam/latest/glam/f64/struct.DMat2.html \"struct glam::f64::DMat2\"), [`DMat3`](https://docs.rs/glam/latest/glam/f64/struct.DMat3.html \"struct glam::f64::DMat3\") and [`DMat4`](https://docs.rs/glam/latest/glam/f64/struct.DMat4.html \"struct glam::f64::DMat4\")\n    * a quaternion type: [`DQuat`](https://docs.rs/glam/latest/glam/f64/struct.DQuat.html \"struct glam::f64::DQuat\")\n    * affine transformation types: [`DAffine2`](https://docs.rs/glam/latest/glam/f64/struct.DAffine2.html \"struct glam::f64::DAffine2\") and [`DAffine3`](https://docs.rs/glam/latest/glam/f64/struct.DAffine3.html \"struct glam::f64::DAffine3\")\n  * [`i8`](https://docs.rs/glam/latest/glam/i8/index.html \"mod glam::i8\") types \n    * vectors: [`I8Vec2`](https://docs.rs/glam/latest/glam/i8/struct.I8Vec2.html \"struct glam::i8::I8Vec2\"), [`I8Vec3`](https://docs.rs/glam/latest/glam/i8/struct.I8Vec3.html \"struct glam::i8::I8Vec3\") and [`I8Vec4`](https://docs.rs/glam/latest/glam/i8/struct.I8Vec4.html \"struct glam::i8::I8Vec4\")\n  * [`u8`](https://docs.rs/glam/latest/glam/u8/index.html \"mod glam::u8\") types \n    * vectors: [`U8Vec2`](https://docs.rs/glam/latest/glam/u8/struct.U8Vec2.html \"struct glam::u8::U8Vec2\"), [`U8Vec3`](https://docs.rs/glam/latest/glam/u8/struct.U8Vec3.html \"struct glam::u8::U8Vec3\") and [`U8Vec4`](https://docs.rs/glam/latest/glam/u8/struct.U8Vec4.html \"struct glam::u8::U8Vec4\")\n  * [`i16`](https://docs.rs/glam/latest/glam/i16/index.html \"mod glam::i16\") types \n    * vectors: [`I16Vec2`](https://docs.rs/glam/latest/glam/i16/struct.I16Vec2.html \"struct glam::i16::I16Vec2\"), [`I16Vec3`](https://docs.rs/glam/latest/glam/i16/struct.I16Vec3.html \"struct glam::i16::I16Vec3\") and [`I16Vec4`](https://docs.rs/glam/latest/glam/i16/struct.I16Vec4.html \"struct glam::i16::I16Vec4\")\n  * [`u16`](https://docs.rs/glam/latest/glam/u16/index.html \"mod glam::u16\") types \n    * vectors: [`U16Vec2`](https://docs.rs/glam/latest/glam/u16/struct.U16Vec2.html \"struct glam::u16::U16Vec2\"), [`U16Vec3`](https://docs.rs/glam/latest/glam/u16/struct.U16Vec3.html \"struct glam::u16::U16Vec3\") and [`U16Vec4`](https://docs.rs/glam/latest/glam/u16/struct.U16Vec4.html \"struct glam::u16::U16Vec4\")\n  * [`i32`](https://docs.rs/glam/latest/glam/i32/index.html \"mod glam::i32\") types \n    * vectors: [`IVec2`](https://docs.rs/glam/latest/glam/i32/struct.IVec2.html \"struct glam::i32::IVec2\"), [`IVec3`](https://docs.rs/glam/latest/glam/i32/struct.IVec3.html \"struct glam::i32::IVec3\") and [`IVec4`](https://docs.rs/glam/latest/glam/i32/struct.IVec4.html \"struct glam::i32::IVec4\")\n  * [`u32`](https://docs.rs/glam/latest/glam/u32/index.html \"mod glam::u32\") types \n    * vectors: [`UVec2`](https://docs.rs/glam/latest/glam/u32/struct.UVec2.html \"struct glam::u32::UVec2\"), [`UVec3`](https://docs.rs/glam/latest/glam/u32/struct.UVec3.html \"struct glam::u32::UVec3\") and [`UVec4`](https://docs.rs/glam/latest/glam/u32/struct.UVec4.html \"struct glam::u32::UVec4\")\n  * [`i64`](https://docs.rs/glam/latest/glam/i64/index.html \"mod glam::i64\") types \n    * vectors: [`I64Vec2`](https://docs.rs/glam/latest/glam/i64/struct.I64Vec2.html \"struct glam::i64::I64Vec2\"), [`I64Vec3`](https://docs.rs/glam/latest/glam/i64/struct.I64Vec3.html \"struct glam::i64::I64Vec3\") and [`I64Vec4`](https://docs.rs/glam/latest/glam/i64/struct.I64Vec4.html \"struct glam::i64::I64Vec4\")\n  * [`u64`](https://docs.rs/glam/latest/glam/u64/index.html \"mod glam::u64\") types \n    * vectors: [`U64Vec2`](https://docs.rs/glam/latest/glam/u64/struct.U64Vec2.html \"struct glam::u64::U64Vec2\"), [`U64Vec3`](https://docs.rs/glam/latest/glam/u64/struct.U64Vec3.html \"struct glam::u64::U64Vec3\") and [`U64Vec4`](https://docs.rs/glam/latest/glam/u64/struct.U64Vec4.html \"struct glam::u64::U64Vec4\")\n  * [`usize`](https://docs.rs/glam/latest/glam/usize/index.html \"mod glam::usize\") types \n    * vectors: [`USizeVec2`](https://docs.rs/glam/latest/glam/usize/struct.USizeVec2.html \"struct glam::usize::USizeVec2\"), [`USizeVec3`](https://docs.rs/glam/latest/glam/usize/struct.USizeVec3.html \"struct glam::usize::USizeVec3\") and [`USizeVec4`](https://docs.rs/glam/latest/glam/usize/struct.USizeVec4.html \"struct glam::usize::USizeVec4\")\n  * [`bool`](https://docs.rs/glam/latest/glam/bool/index.html \"mod glam::bool\") types \n    * vectors: [`BVec2`](https://docs.rs/glam/latest/glam/bool/struct.BVec2.html \"struct glam::bool::BVec2\"), [`BVec3`](https://docs.rs/glam/latest/glam/bool/struct.BVec3.html \"struct glam::bool::BVec3\") and [`BVec4`](https://docs.rs/glam/latest/glam/bool/struct.BVec4.html \"struct glam::bool::BVec4\")\n\n\n### [\u00a7](https://docs.rs/glam/latest/glam/#simd)SIMD\n`glam` is built with SIMD in mind. Many `f32` types use 128-bit SIMD vector types for storage and/or implementation. The use of SIMD generally enables better performance than using primitive numeric types such as `f32`.\nSome `glam` types use SIMD for storage meaning they are 16 byte aligned, these types include `Mat2`, `Mat3A`, `Mat4`, `Quat`, `Vec3A`, `Vec4`, `Affine2` an `Affine3A`. Types with an `A` suffix are a SIMD alternative to a scalar type, e.g. `Vec3` uses `f32` storage and `Vec3A` uses SIMD storage.\nWhen SIMD is not available on the target the types will maintain 16 byte alignment and internal padding so that object sizes and layouts will not change between architectures. There are scalar math fallback implementations exist when SIMD is not available. It is intended to add support for other SIMD architectures once they appear in stable Rust.\nCurrently only SSE2 on x86/x86_64, NEON on Aarch64, and simd128 on WASM are supported.\n### [\u00a7](https://docs.rs/glam/latest/glam/#vec3a-and-mat3a)Vec3A and Mat3A\n`Vec3A` is a SIMD optimized version of the `Vec3` type, which due to 16 byte alignment results in `Vec3A` containing 4 bytes of padding making it 16 bytes in size in total. `Mat3A` is composed of three `Vec3A` columns.\nType| `f32` bytes| Align bytes| Size bytes| Padding  \n---|---|---|---|---  \n[`Vec3`](https://docs.rs/glam/latest/glam/f32/struct.Vec3.html \"struct glam::f32::Vec3\")| 12| 4| 12| 0  \n[`Vec3A`](https://docs.rs/glam/latest/glam/f32/struct.Vec3A.html \"struct glam::f32::Vec3A\")| 12| 16| 16| 4  \n[`Mat3`](https://docs.rs/glam/latest/glam/f32/struct.Mat3.html \"struct glam::f32::Mat3\")| 36| 4| 36| 0  \n[`Mat3A`](https://docs.rs/glam/latest/glam/f32/struct.Mat3A.html \"struct glam::f32::Mat3A\")| 36| 16| 48| 12  \nDespite this wasted space the SIMD implementations tend to outperform `f32` implementations in [**mathbench**](https://github.com/bitshifter/mathbench-rs) benchmarks.\n`glam` treats [`Vec3`](https://docs.rs/glam/latest/glam/f32/struct.Vec3.html \"struct glam::f32::Vec3\") as the default 3D vector type and [`Vec3A`](https://docs.rs/glam/latest/glam/f32/struct.Vec3A.html \"struct glam::f32::Vec3A\") a special case for optimization. When methods need to return a 3D vector they will generally return [`Vec3`](https://docs.rs/glam/latest/glam/f32/struct.Vec3.html \"struct glam::f32::Vec3\").\nThere are [`From`](https://doc.rust-lang.org/nightly/core/convert/trait.From.html \"trait core::convert::From\") trait implementations for converting from [`Vec4`](https://docs.rs/glam/latest/glam/f32/struct.Vec4.html \"struct glam::f32::Vec4\") to a [`Vec3A`](https://docs.rs/glam/latest/glam/f32/struct.Vec3A.html \"struct glam::f32::Vec3A\") and between [`Vec3`](https://docs.rs/glam/latest/glam/f32/struct.Vec3.html \"struct glam::f32::Vec3\") and [`Vec3A`](https://docs.rs/glam/latest/glam/f32/struct.Vec3A.html \"struct glam::f32::Vec3A\") (and vice versa).\n```\nuse glam::{Vec3, Vec3A, Vec4};\nlet v4 = Vec4::new(1.0, 2.0, 3.0, 4.0);\n// Convert from `Vec4` to `Vec3A`, this is a no-op if SIMD is supported.\n// We use an explicit method here instead of a From impl as data is lost in the conversion.\nlet v3a = Vec3A::from_vec4(v4);\nassert_eq!(Vec3A::new(1.0, 2.0, 3.0), v3a);\n// Convert from `Vec3A` to `Vec3`.\nlet v3 = Vec3::from(v3a);\nassert_eq!(Vec3::new(1.0, 2.0, 3.0), v3);\n// Convert from `Vec3` to `Vec3A`.\nlet v3a = Vec3A::from(v3);\nassert_eq!(Vec3A::new(1.0, 2.0, 3.0), v3a);\n```\n\n### [\u00a7](https://docs.rs/glam/latest/glam/#affine2-and-affine3a)Affine2 and Affine3A\n`Affine2` and `Affine3A` are composed of a linear transform matrix and a vector translation. The represent 2D and 3D affine transformations which are commonly used in games.\nThe table below shows the performance advantage of `Affine2` over `Mat3A` and `Mat3A` over `Mat3`.\noperation| `Mat3`| `Mat3A`| `Affine2`  \n---|---|---|---  \ninverse| 11.4\u00b10.09ns| 7.1\u00b10.09ns| 5.4\u00b10.06ns  \nmul self| 10.5\u00b10.04ns| 5.2\u00b10.05ns| 4.0\u00b10.05ns  \ntransform point2| 2.7\u00b10.02ns| 2.7\u00b10.03ns| 2.8\u00b10.04ns  \ntransform vector2| 2.6\u00b10.01ns| 2.6\u00b10.03ns| 2.3\u00b10.02ns  \nPerformance is much closer between `Mat4` and `Affine3A` with the affine type being faster to invert.\noperation| `Mat4`| `Affine3A`  \n---|---|---  \ninverse| 15.9\u00b10.11ns| 10.8\u00b10.06ns  \nmul self| 7.3\u00b10.05ns| 7.0\u00b10.06ns  \ntransform point3| 3.6\u00b10.02ns| 4.3\u00b10.04ns  \ntransform point3a| 3.0\u00b10.02ns| 3.0\u00b10.04ns  \ntransform vector3| 4.1\u00b10.02ns| 3.9\u00b10.04ns  \ntransform vector3a| 2.8\u00b10.02ns| 2.8\u00b10.02ns  \nBenchmarks were taken on an Intel Core i7-4710HQ.\n### [\u00a7](https://docs.rs/glam/latest/glam/#linear-algebra-conventions)Linear algebra conventions\n`glam` interprets vectors as column matrices (also known as column vectors) meaning when transforming a vector with a matrix the matrix goes on the left.\n```\nuse glam::{Mat3, Vec3};\nlet m = Mat3::IDENTITY;\nlet x = Vec3::X;\nlet v = m * x;\nassert_eq!(v, x);\n```\n\nMatrices are stored in memory in column-major order.\nAll angles are in radians. Rust provides the `f32::to_radians()` and `f64::to_radians()` methods to convert from degrees.\n### [\u00a7](https://docs.rs/glam/latest/glam/#direct-element-access)Direct element access\nBecause some types may internally be implemented using SIMD types, direct access to vector elements is supported by implementing the [`Deref`](https://doc.rust-lang.org/std/ops/trait.Deref.html) and [`DerefMut`](https://doc.rust-lang.org/std/ops/trait.DerefMut.html) traits.\n```\nuse glam::Vec3A;\nlet mut v = Vec3A::new(1.0, 2.0, 3.0);\nassert_eq!(3.0, v.z);\nv.z += 1.0;\nassert_eq!(4.0, v.z);\n```\n\n### [\u00a7](https://docs.rs/glam/latest/glam/#glam-assertions)glam assertions\n`glam` does not enforce validity checks on method parameters at runtime. For example methods that require normalized vectors as input such as `Quat::from_axis_angle(axis, angle)` will not check that axis is a valid normalized vector. To help catch unintended misuse of `glam` the `debug-glam-assert` or `glam-assert` features can be enabled to add checks ensure that inputs to are valid.\n### [\u00a7](https://docs.rs/glam/latest/glam/#vector-swizzles)Vector swizzles\n`glam` vector types have functions allowing elements of vectors to be reordered, this includes creating a vector of a different size from the vectors elements.\nThe swizzle functions are implemented using traits to add them to each vector type. This is primarily because there are a lot of swizzle functions which can obfuscate the other vector functions in documentation and so on. The traits are [`Vec2Swizzles`](https://docs.rs/glam/latest/glam/swizzles/trait.Vec2Swizzles.html \"trait glam::swizzles::Vec2Swizzles\"), [`Vec3Swizzles`](https://docs.rs/glam/latest/glam/swizzles/trait.Vec3Swizzles.html \"trait glam::swizzles::Vec3Swizzles\") and [`Vec4Swizzles`](https://docs.rs/glam/latest/glam/swizzles/trait.Vec4Swizzles.html \"trait glam::swizzles::Vec4Swizzles\").\nNote that the [`Vec3Swizzles`](https://docs.rs/glam/latest/glam/swizzles/trait.Vec3Swizzles.html \"trait glam::swizzles::Vec3Swizzles\") implementation for [`Vec3A`](https://docs.rs/glam/latest/glam/f32/struct.Vec3A.html \"struct glam::f32::Vec3A\") will return a [`Vec3A`](https://docs.rs/glam/latest/glam/f32/struct.Vec3A.html \"struct glam::f32::Vec3A\") for 3 element swizzles, all other implementations will return [`Vec3`](https://docs.rs/glam/latest/glam/f32/struct.Vec3.html \"struct glam::f32::Vec3\").\n```\nuse glam::{swizzles::*, Vec2, Vec3, Vec3A, Vec4};\nlet v = Vec4::new(1.0, 2.0, 3.0, 4.0);\n// Reverse elements of `v`, if SIMD is supported this will use a vector shuffle.\nlet wzyx = v.wzyx();\nassert_eq!(Vec4::new(4.0, 3.0, 2.0, 1.0), wzyx);\n// Swizzle the yzw elements of `v` into a `Vec3`\nlet yzw = v.yzw();\nassert_eq!(Vec3::new(2.0, 3.0, 4.0), yzw);\n// To swizzle a `Vec4` into a `Vec3A` swizzle the `Vec4` first then convert to\n// `Vec3A`. If SIMD is supported this will use a vector shuffle. The last\n// element of the shuffled `Vec4` is ignored by the `Vec3A`.\nlet yzw = Vec3A::from_vec4(v.yzwx());\nassert_eq!(Vec3A::new(2.0, 3.0, 4.0), yzw);\n// You can swizzle from a `Vec4` to a `Vec2`\nlet xy = v.xy();\nassert_eq!(Vec2::new(1.0, 2.0), xy);\n// And back again\nlet yyxx = xy.yyxx();\nassert_eq!(Vec4::new(2.0, 2.0, 1.0, 1.0), yyxx);\n```\n\n### [\u00a7](https://docs.rs/glam/latest/glam/#simd-and-scalar-consistency)SIMD and scalar consistency\n`glam` types implement `serde` `Serialize` and `Deserialize` traits to ensure that they will serialize and deserialize exactly the same whether or not SIMD support is being used.\nThe SIMD versions implement the `core::fmt::Debug` and `core::fmt::Display` traits so they print the same as the scalar version.\n```\nuse glam::Vec4;\nlet a = Vec4::new(1.0, 2.0, 3.0, 4.0);\nassert_eq!(format!(\"{}\", a), \"[1, 2, 3, 4]\");\n```\n\n### [\u00a7](https://docs.rs/glam/latest/glam/#feature-gates)Feature gates\nAll `glam` dependencies are optional, however some are required for tests and benchmarks.\n  * `std` - the default feature, has no dependencies.\n  * `approx` - traits and macros for approximate float comparisons\n  * `bytemuck` - for casting into slices of bytes\n  * `libm` - uses `libm` math functions instead of `std`\n  * `nostd-libm` - uses `libm` math functions if `std` is not available\n  * `mint` - for interoperating with other 3D math libraries\n  * `rand` - implementations of `Distribution` trait for all `glam` types.\n  * `rkyv` - implementations of `Archive`, `Serialize` and `Deserialize` for all `glam` types. Note that serialization is not interoperable with and without the `scalar-math` feature. It should work between all other builds of `glam`. Endian conversion is currently not supported\n  * `bytecheck` - to perform archive validation when using the `rkyv` feature\n  * `serde` - implementations of `Serialize` and `Deserialize` for all `glam` types. Note that serialization should work between builds of `glam` with and without SIMD enabled\n  * `speedy` - implementations of `speedy`\u2019s `Readable` and `Writable` for all `glam` types.\n  * `scalar-math` - disables SIMD support and uses native alignment for all types.\n  * `debug-glam-assert` - adds assertions in debug builds which check the validity of parameters passed to `glam` to help catch runtime errors.\n  * `glam-assert` - adds assertions to all builds which check the validity of parameters passed to `glam` to help catch runtime errors.\n  * `cuda` - forces `glam` types to match expected cuda alignment\n  * `fast-math` - By default, glam attempts to provide bit-for-bit identical results on all platforms. Using this feature will enable platform specific optimizations that may not be identical to other platforms. **Intermediate libraries should not use this feature and defer the decision to the final binary build**.\n  * `core-simd` - enables SIMD support via the portable simd module. This is an unstable feature which requires a nightly Rust toolchain and `std` support.\n\n\n### [\u00a7](https://docs.rs/glam/latest/glam/#minimum-supported-rust-version-msrv)Minimum Supported Rust Version (MSRV)\nThe minimum supported Rust version is `1.68.2`.\n## Re-exports[\u00a7](https://docs.rs/glam/latest/glam/#reexports)\n\n`pub use self::swizzles::Vec2Swizzles[](https://docs.rs/glam/latest/glam/swizzles/trait.Vec2Swizzles.html \"trait glam::swizzles::Vec2Swizzles\");`\n\n\n`pub use self::swizzles::Vec3Swizzles[](https://docs.rs/glam/latest/glam/swizzles/trait.Vec3Swizzles.html \"trait glam::swizzles::Vec3Swizzles\");`\n\n\n`pub use self::swizzles::Vec4Swizzles[](https://docs.rs/glam/latest/glam/swizzles/trait.Vec4Swizzles.html \"trait glam::swizzles::Vec4Swizzles\");`\n\n\n`pub use self::bool[](https://docs.rs/glam/latest/glam/bool/index.html \"mod glam::bool\")::*;`\n\n\n`pub use self::f32[](https://docs.rs/glam/latest/glam/f32/index.html \"mod glam::f32\")::*;`\n\n\n`pub use self::f64[](https://docs.rs/glam/latest/glam/f64/index.html \"mod glam::f64\")::*;`\n\n\n`pub use self::i8[](https://docs.rs/glam/latest/glam/i8/index.html \"mod glam::i8\")::*;`\n\n\n`pub use self::u8[](https://docs.rs/glam/latest/glam/u8/index.html \"mod glam::u8\")::*;`\n\n\n`pub use self::i16[](https://docs.rs/glam/latest/glam/i16/index.html \"mod glam::i16\")::*;`\n\n\n`pub use self::u16[](https://docs.rs/glam/latest/glam/u16/index.html \"mod glam::u16\")::*;`\n\n\n`pub use self::i32[](https://docs.rs/glam/latest/glam/i32/index.html \"mod glam::i32\")::*;`\n\n\n`pub use self::u32[](https://docs.rs/glam/latest/glam/u32/index.html \"mod glam::u32\")::*;`\n\n\n`pub use self::i64[](https://docs.rs/glam/latest/glam/i64/index.html \"mod glam::i64\")::*;`\n\n\n`pub use self::u64[](https://docs.rs/glam/latest/glam/u64/index.html \"mod glam::u64\")::*;`\n\n\n`pub use self::usize[](https://docs.rs/glam/latest/glam/usize/index.html \"mod glam::usize\")::*;`\n\n## Modules[\u00a7](https://docs.rs/glam/latest/glam/#modules)\n\n[bool](https://docs.rs/glam/latest/glam/bool/index.html \"mod glam::bool\")\n    `bool` vector mask types.\n\n[f32](https://docs.rs/glam/latest/glam/f32/index.html \"mod glam::f32\")\n    `f32` vector, quaternion and matrix types.\n\n[f64](https://docs.rs/glam/latest/glam/f64/index.html \"mod glam::f64\")\n    `f64` vector, quaternion and matrix types.\n\n[i8](https://docs.rs/glam/latest/glam/i8/index.html \"mod glam::i8\")\n    `i8` vector types.\n\n[i16](https://docs.rs/glam/latest/glam/i16/index.html \"mod glam::i16\")\n    `i16` vector types.\n\n[i32](https://docs.rs/glam/latest/glam/i32/index.html \"mod glam::i32\")\n    `i32` vector types.\n\n[i64](https://docs.rs/glam/latest/glam/i64/index.html \"mod glam::i64\")\n    `i64` vector types.\n\n[swizzles](https://docs.rs/glam/latest/glam/swizzles/index.html \"mod glam::swizzles\")\n    Traits adding swizzle methods to all vector types.\n\n[u8](https://docs.rs/glam/latest/glam/u8/index.html \"mod glam::u8\")\n    `u8` vector types.\n\n[u16](https://docs.rs/glam/latest/glam/u16/index.html \"mod glam::u16\")\n    `u16` vector types.\n\n[u32](https://docs.rs/glam/latest/glam/u32/index.html \"mod glam::u32\")\n    `u32` vector types.\n\n[u64](https://docs.rs/glam/latest/glam/u64/index.html \"mod glam::u64\")\n    `u64` vector types.\n\n[usize](https://docs.rs/glam/latest/glam/usize/index.html \"mod glam::usize\")\n    `usize` vector types.\n## Enums[\u00a7](https://docs.rs/glam/latest/glam/#enums)\n\n[EulerRot](https://docs.rs/glam/latest/glam/enum.EulerRot.html \"enum glam::EulerRot\")\n    Rotation Helper Euler rotation sequences.\n## Traits[\u00a7](https://docs.rs/glam/latest/glam/#traits)\n\n[FloatExt](https://docs.rs/glam/latest/glam/trait.FloatExt.html \"trait glam::FloatExt\")\n    A trait for extending [`f32`](https://doc.rust-lang.org/nightly/std/primitive.f32.html \"primitive f32\") and [`f64`](https://doc.rust-lang.org/nightly/std/primitive.f64.html \"primitive f64\") with extra methods.\n",
              "markdown_with_citations": "[](https://docs.rs/glam/latest/glam/all.html \"show sidebar\")\n# Crate glamCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\n## \u00a7\u27e84\u27e9glam\n`glam` is a simple and fast linear algebra library for games and graphics.\n### \u00a7\u27e85\u27e9Features\n  * `f32`\u27e86\u27e9 types \n    * vectors: `Vec2`\u27e87\u27e9, `Vec3`\u27e88\u27e9, `Vec3A`\u27e89\u27e9 and `Vec4`\u27e810\u27e9\n    * square matrices: `Mat2`\u27e811\u27e9, `Mat3`\u27e812\u27e9, `Mat3A`\u27e813\u27e9 and `Mat4`\u27e814\u27e9\n    * a quaternion type: `Quat`\u27e815\u27e9\n    * affine transformation types: `Affine2`\u27e816\u27e9 and `Affine3A`\u27e817\u27e9\n  * `f64`\u27e818\u27e9 types \n    * vectors: `DVec2`\u27e819\u27e9, `DVec3`\u27e820\u27e9 and `DVec4`\u27e821\u27e9\n    * square matrices: `DMat2`\u27e822\u27e9, `DMat3`\u27e823\u27e9 and `DMat4`\u27e824\u27e9\n    * a quaternion type: `DQuat`\u27e825\u27e9\n    * affine transformation types: `DAffine2`\u27e826\u27e9 and `DAffine3`\u27e827\u27e9\n  * `i8`\u27e828\u27e9 types \n    * vectors: `I8Vec2`\u27e829\u27e9, `I8Vec3`\u27e830\u27e9 and `I8Vec4`\u27e831\u27e9\n  * `u8`\u27e832\u27e9 types \n    * vectors: `U8Vec2`\u27e833\u27e9, `U8Vec3`\u27e834\u27e9 and `U8Vec4`\u27e835\u27e9\n  * `i16`\u27e836\u27e9 types \n    * vectors: `I16Vec2`\u27e837\u27e9, `I16Vec3`\u27e838\u27e9 and `I16Vec4`\u27e839\u27e9\n  * `u16`\u27e840\u27e9 types \n    * vectors: `U16Vec2`\u27e841\u27e9, `U16Vec3`\u27e842\u27e9 and `U16Vec4`\u27e843\u27e9\n  * `i32`\u27e844\u27e9 types \n    * vectors: `IVec2`\u27e845\u27e9, `IVec3`\u27e846\u27e9 and `IVec4`\u27e847\u27e9\n  * `u32`\u27e848\u27e9 types \n    * vectors: `UVec2`\u27e849\u27e9, `UVec3`\u27e850\u27e9 and `UVec4`\u27e851\u27e9\n  * `i64`\u27e852\u27e9 types \n    * vectors: `I64Vec2`\u27e853\u27e9, `I64Vec3`\u27e854\u27e9 and `I64Vec4`\u27e855\u27e9\n  * `u64`\u27e856\u27e9 types \n    * vectors: `U64Vec2`\u27e857\u27e9, `U64Vec3`\u27e858\u27e9 and `U64Vec4`\u27e859\u27e9\n  * `usize`\u27e860\u27e9 types \n    * vectors: `USizeVec2`\u27e861\u27e9, `USizeVec3`\u27e862\u27e9 and `USizeVec4`\u27e863\u27e9\n  * `bool`\u27e864\u27e9 types \n    * vectors: `BVec2`\u27e865\u27e9, `BVec3`\u27e866\u27e9 and `BVec4`\u27e867\u27e9\n\n\n### \u00a7\u27e868\u27e9SIMD\n`glam` is built with SIMD in mind. Many `f32` types use 128-bit SIMD vector types for storage and/or implementation. The use of SIMD generally enables better performance than using primitive numeric types such as `f32`.\nSome `glam` types use SIMD for storage meaning they are 16 byte aligned, these types include `Mat2`, `Mat3A`, `Mat4`, `Quat`, `Vec3A`, `Vec4`, `Affine2` an `Affine3A`. Types with an `A` suffix are a SIMD alternative to a scalar type, e.g. `Vec3` uses `f32` storage and `Vec3A` uses SIMD storage.\nWhen SIMD is not available on the target the types will maintain 16 byte alignment and internal padding so that object sizes and layouts will not change between architectures. There are scalar math fallback implementations exist when SIMD is not available. It is intended to add support for other SIMD architectures once they appear in stable Rust.\nCurrently only SSE2 on x86/x86_64, NEON on Aarch64, and simd128 on WASM are supported.\n### \u00a7\u27e869\u27e9Vec3A and Mat3A\n`Vec3A` is a SIMD optimized version of the `Vec3` type, which due to 16 byte alignment results in `Vec3A` containing 4 bytes of padding making it 16 bytes in size in total. `Mat3A` is composed of three `Vec3A` columns.\nType| `f32` bytes| Align bytes| Size bytes| Padding  \n---|---|---|---|---  \n`Vec3`\u27e88\u27e9| 12| 4| 12| 0  \n`Vec3A`\u27e89\u27e9| 12| 16| 16| 4  \n`Mat3`\u27e812\u27e9| 36| 4| 36| 0  \n`Mat3A`\u27e813\u27e9| 36| 16| 48| 12  \nDespite this wasted space the SIMD implementations tend to outperform `f32` implementations in **mathbench**\u27e870\u27e9 benchmarks.\n`glam` treats `Vec3`\u27e88\u27e9 as the default 3D vector type and `Vec3A`\u27e89\u27e9 a special case for optimization. When methods need to return a 3D vector they will generally return `Vec3`\u27e88\u27e9.\nThere are `From`\u27e871\u27e9 trait implementations for converting from `Vec4`\u27e810\u27e9 to a `Vec3A`\u27e89\u27e9 and between `Vec3`\u27e88\u27e9 and `Vec3A`\u27e89\u27e9 (and vice versa).\n```\nuse glam::{Vec3, Vec3A, Vec4};\nlet v4 = Vec4::new(1.0, 2.0, 3.0, 4.0);\n// Convert from `Vec4` to `Vec3A`, this is a no-op if SIMD is supported.\n// We use an explicit method here instead of a From impl as data is lost in the conversion.\nlet v3a = Vec3A::from_vec4(v4);\nassert_eq!(Vec3A::new(1.0, 2.0, 3.0), v3a);\n// Convert from `Vec3A` to `Vec3`.\nlet v3 = Vec3::from(v3a);\nassert_eq!(Vec3::new(1.0, 2.0, 3.0), v3);\n// Convert from `Vec3` to `Vec3A`.\nlet v3a = Vec3A::from(v3);\nassert_eq!(Vec3A::new(1.0, 2.0, 3.0), v3a);\n```\n\n### \u00a7\u27e872\u27e9Affine2 and Affine3A\n`Affine2` and `Affine3A` are composed of a linear transform matrix and a vector translation. The represent 2D and 3D affine transformations which are commonly used in games.\nThe table below shows the performance advantage of `Affine2` over `Mat3A` and `Mat3A` over `Mat3`.\noperation| `Mat3`| `Mat3A`| `Affine2`  \n---|---|---|---  \ninverse| 11.4\u00b10.09ns| 7.1\u00b10.09ns| 5.4\u00b10.06ns  \nmul self| 10.5\u00b10.04ns| 5.2\u00b10.05ns| 4.0\u00b10.05ns  \ntransform point2| 2.7\u00b10.02ns| 2.7\u00b10.03ns| 2.8\u00b10.04ns  \ntransform vector2| 2.6\u00b10.01ns| 2.6\u00b10.03ns| 2.3\u00b10.02ns  \nPerformance is much closer between `Mat4` and `Affine3A` with the affine type being faster to invert.\noperation| `Mat4`| `Affine3A`  \n---|---|---  \ninverse| 15.9\u00b10.11ns| 10.8\u00b10.06ns  \nmul self| 7.3\u00b10.05ns| 7.0\u00b10.06ns  \ntransform point3| 3.6\u00b10.02ns| 4.3\u00b10.04ns  \ntransform point3a| 3.0\u00b10.02ns| 3.0\u00b10.04ns  \ntransform vector3| 4.1\u00b10.02ns| 3.9\u00b10.04ns  \ntransform vector3a| 2.8\u00b10.02ns| 2.8\u00b10.02ns  \nBenchmarks were taken on an Intel Core i7-4710HQ.\n### \u00a7\u27e873\u27e9Linear algebra conventions\n`glam` interprets vectors as column matrices (also known as column vectors) meaning when transforming a vector with a matrix the matrix goes on the left.\n```\nuse glam::{Mat3, Vec3};\nlet m = Mat3::IDENTITY;\nlet x = Vec3::X;\nlet v = m * x;\nassert_eq!(v, x);\n```\n\nMatrices are stored in memory in column-major order.\nAll angles are in radians. Rust provides the `f32::to_radians()` and `f64::to_radians()` methods to convert from degrees.\n### \u00a7\u27e874\u27e9Direct element access\nBecause some types may internally be implemented using SIMD types, direct access to vector elements is supported by implementing the `Deref`\u27e875\u27e9 and `DerefMut`\u27e876\u27e9 traits.\n```\nuse glam::Vec3A;\nlet mut v = Vec3A::new(1.0, 2.0, 3.0);\nassert_eq!(3.0, v.z);\nv.z += 1.0;\nassert_eq!(4.0, v.z);\n```\n\n### \u00a7\u27e877\u27e9glam assertions\n`glam` does not enforce validity checks on method parameters at runtime. For example methods that require normalized vectors as input such as `Quat::from_axis_angle(axis, angle)` will not check that axis is a valid normalized vector. To help catch unintended misuse of `glam` the `debug-glam-assert` or `glam-assert` features can be enabled to add checks ensure that inputs to are valid.\n### \u00a7\u27e878\u27e9Vector swizzles\n`glam` vector types have functions allowing elements of vectors to be reordered, this includes creating a vector of a different size from the vectors elements.\nThe swizzle functions are implemented using traits to add them to each vector type. This is primarily because there are a lot of swizzle functions which can obfuscate the other vector functions in documentation and so on. The traits are `Vec2Swizzles`\u27e879\u27e9, `Vec3Swizzles`\u27e880\u27e9 and `Vec4Swizzles`\u27e881\u27e9.\nNote that the `Vec3Swizzles`\u27e880\u27e9 implementation for `Vec3A`\u27e89\u27e9 will return a `Vec3A`\u27e89\u27e9 for 3 element swizzles, all other implementations will return `Vec3`\u27e88\u27e9.\n```\nuse glam::{swizzles::*, Vec2, Vec3, Vec3A, Vec4};\nlet v = Vec4::new(1.0, 2.0, 3.0, 4.0);\n// Reverse elements of `v`, if SIMD is supported this will use a vector shuffle.\nlet wzyx = v.wzyx();\nassert_eq!(Vec4::new(4.0, 3.0, 2.0, 1.0), wzyx);\n// Swizzle the yzw elements of `v` into a `Vec3`\nlet yzw = v.yzw();\nassert_eq!(Vec3::new(2.0, 3.0, 4.0), yzw);\n// To swizzle a `Vec4` into a `Vec3A` swizzle the `Vec4` first then convert to\n// `Vec3A`. If SIMD is supported this will use a vector shuffle. The last\n// element of the shuffled `Vec4` is ignored by the `Vec3A`.\nlet yzw = Vec3A::from_vec4(v.yzwx());\nassert_eq!(Vec3A::new(2.0, 3.0, 4.0), yzw);\n// You can swizzle from a `Vec4` to a `Vec2`\nlet xy = v.xy();\nassert_eq!(Vec2::new(1.0, 2.0), xy);\n// And back again\nlet yyxx = xy.yyxx();\nassert_eq!(Vec4::new(2.0, 2.0, 1.0, 1.0), yyxx);\n```\n\n### \u00a7\u27e882\u27e9SIMD and scalar consistency\n`glam` types implement `serde` `Serialize` and `Deserialize` traits to ensure that they will serialize and deserialize exactly the same whether or not SIMD support is being used.\nThe SIMD versions implement the `core::fmt::Debug` and `core::fmt::Display` traits so they print the same as the scalar version.\n```\nuse glam::Vec4;\nlet a = Vec4::new(1.0, 2.0, 3.0, 4.0);\nassert_eq!(format!(\"{}\", a), \"[1, 2, 3, 4]\");\n```\n\n### \u00a7\u27e883\u27e9Feature gates\nAll `glam` dependencies are optional, however some are required for tests and benchmarks.\n  * `std` - the default feature, has no dependencies.\n  * `approx` - traits and macros for approximate float comparisons\n  * `bytemuck` - for casting into slices of bytes\n  * `libm` - uses `libm` math functions instead of `std`\n  * `nostd-libm` - uses `libm` math functions if `std` is not available\n  * `mint` - for interoperating with other 3D math libraries\n  * `rand` - implementations of `Distribution` trait for all `glam` types.\n  * `rkyv` - implementations of `Archive`, `Serialize` and `Deserialize` for all `glam` types. Note that serialization is not interoperable with and without the `scalar-math` feature. It should work between all other builds of `glam`. Endian conversion is currently not supported\n  * `bytecheck` - to perform archive validation when using the `rkyv` feature\n  * `serde` - implementations of `Serialize` and `Deserialize` for all `glam` types. Note that serialization should work between builds of `glam` with and without SIMD enabled\n  * `speedy` - implementations of `speedy`\u2019s `Readable` and `Writable` for all `glam` types.\n  * `scalar-math` - disables SIMD support and uses native alignment for all types.\n  * `debug-glam-assert` - adds assertions in debug builds which check the validity of parameters passed to `glam` to help catch runtime errors.\n  * `glam-assert` - adds assertions to all builds which check the validity of parameters passed to `glam` to help catch runtime errors.\n  * `cuda` - forces `glam` types to match expected cuda alignment\n  * `fast-math` - By default, glam attempts to provide bit-for-bit identical results on all platforms. Using this feature will enable platform specific optimizations that may not be identical to other platforms. **Intermediate libraries should not use this feature and defer the decision to the final binary build**.\n  * `core-simd` - enables SIMD support via the portable simd module. This is an unstable feature which requires a nightly Rust toolchain and `std` support.\n\n\n### \u00a7\u27e884\u27e9Minimum Supported Rust Version (MSRV)\nThe minimum supported Rust version is `1.68.2`.\n## Re-exports\u00a7\u27e885\u27e9\n\n`pub use self::swizzles::Vec2Swizzles[](https://docs.rs/glam/latest/glam/swizzles/trait.Vec2Swizzles.html \"trait glam::swizzles::Vec2Swizzles\");`\n\n\n`pub use self::swizzles::Vec3Swizzles[](https://docs.rs/glam/latest/glam/swizzles/trait.Vec3Swizzles.html \"trait glam::swizzles::Vec3Swizzles\");`\n\n\n`pub use self::swizzles::Vec4Swizzles[](https://docs.rs/glam/latest/glam/swizzles/trait.Vec4Swizzles.html \"trait glam::swizzles::Vec4Swizzles\");`\n\n\n`pub use self::bool[](https://docs.rs/glam/latest/glam/bool/index.html \"mod glam::bool\")::*;`\n\n\n`pub use self::f32[](https://docs.rs/glam/latest/glam/f32/index.html \"mod glam::f32\")::*;`\n\n\n`pub use self::f64[](https://docs.rs/glam/latest/glam/f64/index.html \"mod glam::f64\")::*;`\n\n\n`pub use self::i8[](https://docs.rs/glam/latest/glam/i8/index.html \"mod glam::i8\")::*;`\n\n\n`pub use self::u8[](https://docs.rs/glam/latest/glam/u8/index.html \"mod glam::u8\")::*;`\n\n\n`pub use self::i16[](https://docs.rs/glam/latest/glam/i16/index.html \"mod glam::i16\")::*;`\n\n\n`pub use self::u16[](https://docs.rs/glam/latest/glam/u16/index.html \"mod glam::u16\")::*;`\n\n\n`pub use self::i32[](https://docs.rs/glam/latest/glam/i32/index.html \"mod glam::i32\")::*;`\n\n\n`pub use self::u32[](https://docs.rs/glam/latest/glam/u32/index.html \"mod glam::u32\")::*;`\n\n\n`pub use self::i64[](https://docs.rs/glam/latest/glam/i64/index.html \"mod glam::i64\")::*;`\n\n\n`pub use self::u64[](https://docs.rs/glam/latest/glam/u64/index.html \"mod glam::u64\")::*;`\n\n\n`pub use self::usize[](https://docs.rs/glam/latest/glam/usize/index.html \"mod glam::usize\")::*;`\n\n## Modules\u00a7\u27e886\u27e9\n\nbool\u27e864\u27e9\n    `bool` vector mask types.\n\nf32\u27e86\u27e9\n    `f32` vector, quaternion and matrix types.\n\nf64\u27e818\u27e9\n    `f64` vector, quaternion and matrix types.\n\ni8\u27e828\u27e9\n    `i8` vector types.\n\ni16\u27e836\u27e9\n    `i16` vector types.\n\ni32\u27e844\u27e9\n    `i32` vector types.\n\ni64\u27e852\u27e9\n    `i64` vector types.\n\nswizzles\u27e887\u27e9\n    Traits adding swizzle methods to all vector types.\n\nu8\u27e832\u27e9\n    `u8` vector types.\n\nu16\u27e840\u27e9\n    `u16` vector types.\n\nu32\u27e848\u27e9\n    `u32` vector types.\n\nu64\u27e856\u27e9\n    `u64` vector types.\n\nusize\u27e860\u27e9\n    `usize` vector types.\n## Enums\u00a7\u27e888\u27e9\n\nEulerRot\u27e889\u27e9\n    Rotation Helper Euler rotation sequences.\n## Traits\u00a7\u27e890\u27e9\n\nFloatExt\u27e891\u27e9\n    A trait for extending `f32`\u27e892\u27e9 and `f64`\u27e893\u27e9 with extra methods.\n",
              "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/glam/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/glam/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/glam/latest/src/glam/lib.rs.html#1-383: Source\n\u27e84\u27e9 https://docs.rs/glam/latest/glam/#glam: \u00a7\n\u27e85\u27e9 https://docs.rs/glam/latest/glam/#features: \u00a7\n\u27e86\u27e9 https://docs.rs/glam/latest/glam/f32/index.html: mod glam::f32 - `f32`\n\u27e87\u27e9 https://docs.rs/glam/latest/glam/f32/struct.Vec2.html: struct glam::f32::Vec2 - `Vec2`\n\u27e88\u27e9 https://docs.rs/glam/latest/glam/f32/struct.Vec3.html: struct glam::f32::Vec3 - `Vec3`\n\u27e89\u27e9 https://docs.rs/glam/latest/glam/f32/struct.Vec3A.html: struct glam::f32::Vec3A - `Vec3A`\n\u27e810\u27e9 https://docs.rs/glam/latest/glam/f32/struct.Vec4.html: struct glam::f32::Vec4 - `Vec4`\n\u27e811\u27e9 https://docs.rs/glam/latest/glam/f32/struct.Mat2.html: struct glam::f32::Mat2 - `Mat2`\n\u27e812\u27e9 https://docs.rs/glam/latest/glam/f32/struct.Mat3.html: struct glam::f32::Mat3 - `Mat3`\n\u27e813\u27e9 https://docs.rs/glam/latest/glam/f32/struct.Mat3A.html: struct glam::f32::Mat3A - `Mat3A`\n\u27e814\u27e9 https://docs.rs/glam/latest/glam/f32/struct.Mat4.html: struct glam::f32::Mat4 - `Mat4`\n\u27e815\u27e9 https://docs.rs/glam/latest/glam/f32/struct.Quat.html: struct glam::f32::Quat - `Quat`\n\u27e816\u27e9 https://docs.rs/glam/latest/glam/f32/struct.Affine2.html: struct glam::f32::Affine2 - `Affine2`\n\u27e817\u27e9 https://docs.rs/glam/latest/glam/f32/struct.Affine3A.html: struct glam::f32::Affine3A - `Affine3A`\n\u27e818\u27e9 https://docs.rs/glam/latest/glam/f64/index.html: mod glam::f64 - `f64`\n\u27e819\u27e9 https://docs.rs/glam/latest/glam/f64/struct.DVec2.html: struct glam::f64::DVec2 - `DVec2`\n\u27e820\u27e9 https://docs.rs/glam/latest/glam/f64/struct.DVec3.html: struct glam::f64::DVec3 - `DVec3`\n\u27e821\u27e9 https://docs.rs/glam/latest/glam/f64/struct.DVec4.html: struct glam::f64::DVec4 - `DVec4`\n\u27e822\u27e9 https://docs.rs/glam/latest/glam/f64/struct.DMat2.html: struct glam::f64::DMat2 - `DMat2`\n\u27e823\u27e9 https://docs.rs/glam/latest/glam/f64/struct.DMat3.html: struct glam::f64::DMat3 - `DMat3`\n\u27e824\u27e9 https://docs.rs/glam/latest/glam/f64/struct.DMat4.html: struct glam::f64::DMat4 - `DMat4`\n\u27e825\u27e9 https://docs.rs/glam/latest/glam/f64/struct.DQuat.html: struct glam::f64::DQuat - `DQuat`\n\u27e826\u27e9 https://docs.rs/glam/latest/glam/f64/struct.DAffine2.html: struct glam::f64::DAffine2 - `DAffine2`\n\u27e827\u27e9 https://docs.rs/glam/latest/glam/f64/struct.DAffine3.html: struct glam::f64::DAffine3 - `DAffine3`\n\u27e828\u27e9 https://docs.rs/glam/latest/glam/i8/index.html: mod glam::i8 - `i8`\n\u27e829\u27e9 https://docs.rs/glam/latest/glam/i8/struct.I8Vec2.html: struct glam::i8::I8Vec2 - `I8Vec2`\n\u27e830\u27e9 https://docs.rs/glam/latest/glam/i8/struct.I8Vec3.html: struct glam::i8::I8Vec3 - `I8Vec3`\n\u27e831\u27e9 https://docs.rs/glam/latest/glam/i8/struct.I8Vec4.html: struct glam::i8::I8Vec4 - `I8Vec4`\n\u27e832\u27e9 https://docs.rs/glam/latest/glam/u8/index.html: mod glam::u8 - `u8`\n\u27e833\u27e9 https://docs.rs/glam/latest/glam/u8/struct.U8Vec2.html: struct glam::u8::U8Vec2 - `U8Vec2`\n\u27e834\u27e9 https://docs.rs/glam/latest/glam/u8/struct.U8Vec3.html: struct glam::u8::U8Vec3 - `U8Vec3`\n\u27e835\u27e9 https://docs.rs/glam/latest/glam/u8/struct.U8Vec4.html: struct glam::u8::U8Vec4 - `U8Vec4`\n\u27e836\u27e9 https://docs.rs/glam/latest/glam/i16/index.html: mod glam::i16 - `i16`\n\u27e837\u27e9 https://docs.rs/glam/latest/glam/i16/struct.I16Vec2.html: struct glam::i16::I16Vec2 - `I16Vec2`\n\u27e838\u27e9 https://docs.rs/glam/latest/glam/i16/struct.I16Vec3.html: struct glam::i16::I16Vec3 - `I16Vec3`\n\u27e839\u27e9 https://docs.rs/glam/latest/glam/i16/struct.I16Vec4.html: struct glam::i16::I16Vec4 - `I16Vec4`\n\u27e840\u27e9 https://docs.rs/glam/latest/glam/u16/index.html: mod glam::u16 - `u16`\n\u27e841\u27e9 https://docs.rs/glam/latest/glam/u16/struct.U16Vec2.html: struct glam::u16::U16Vec2 - `U16Vec2`\n\u27e842\u27e9 https://docs.rs/glam/latest/glam/u16/struct.U16Vec3.html: struct glam::u16::U16Vec3 - `U16Vec3`\n\u27e843\u27e9 https://docs.rs/glam/latest/glam/u16/struct.U16Vec4.html: struct glam::u16::U16Vec4 - `U16Vec4`\n\u27e844\u27e9 https://docs.rs/glam/latest/glam/i32/index.html: mod glam::i32 - `i32`\n\u27e845\u27e9 https://docs.rs/glam/latest/glam/i32/struct.IVec2.html: struct glam::i32::IVec2 - `IVec2`\n\u27e846\u27e9 https://docs.rs/glam/latest/glam/i32/struct.IVec3.html: struct glam::i32::IVec3 - `IVec3`\n\u27e847\u27e9 https://docs.rs/glam/latest/glam/i32/struct.IVec4.html: struct glam::i32::IVec4 - `IVec4`\n\u27e848\u27e9 https://docs.rs/glam/latest/glam/u32/index.html: mod glam::u32 - `u32`\n\u27e849\u27e9 https://docs.rs/glam/latest/glam/u32/struct.UVec2.html: struct glam::u32::UVec2 - `UVec2`\n\u27e850\u27e9 https://docs.rs/glam/latest/glam/u32/struct.UVec3.html: struct glam::u32::UVec3 - `UVec3`\n\u27e851\u27e9 https://docs.rs/glam/latest/glam/u32/struct.UVec4.html: struct glam::u32::UVec4 - `UVec4`\n\u27e852\u27e9 https://docs.rs/glam/latest/glam/i64/index.html: mod glam::i64 - `i64`\n\u27e853\u27e9 https://docs.rs/glam/latest/glam/i64/struct.I64Vec2.html: struct glam::i64::I64Vec2 - `I64Vec2`\n\u27e854\u27e9 https://docs.rs/glam/latest/glam/i64/struct.I64Vec3.html: struct glam::i64::I64Vec3 - `I64Vec3`\n\u27e855\u27e9 https://docs.rs/glam/latest/glam/i64/struct.I64Vec4.html: struct glam::i64::I64Vec4 - `I64Vec4`\n\u27e856\u27e9 https://docs.rs/glam/latest/glam/u64/index.html: mod glam::u64 - `u64`\n\u27e857\u27e9 https://docs.rs/glam/latest/glam/u64/struct.U64Vec2.html: struct glam::u64::U64Vec2 - `U64Vec2`\n\u27e858\u27e9 https://docs.rs/glam/latest/glam/u64/struct.U64Vec3.html: struct glam::u64::U64Vec3 - `U64Vec3`\n\u27e859\u27e9 https://docs.rs/glam/latest/glam/u64/struct.U64Vec4.html: struct glam::u64::U64Vec4 - `U64Vec4`\n\u27e860\u27e9 https://docs.rs/glam/latest/glam/usize/index.html: mod glam::usize - `usize`\n\u27e861\u27e9 https://docs.rs/glam/latest/glam/usize/struct.USizeVec2.html: struct glam::usize::USizeVec2 - `USizeVec2`\n\u27e862\u27e9 https://docs.rs/glam/latest/glam/usize/struct.USizeVec3.html: struct glam::usize::USizeVec3 - `USizeVec3`\n\u27e863\u27e9 https://docs.rs/glam/latest/glam/usize/struct.USizeVec4.html: struct glam::usize::USizeVec4 - `USizeVec4`\n\u27e864\u27e9 https://docs.rs/glam/latest/glam/bool/index.html: mod glam::bool - `bool`\n\u27e865\u27e9 https://docs.rs/glam/latest/glam/bool/struct.BVec2.html: struct glam::bool::BVec2 - `BVec2`\n\u27e866\u27e9 https://docs.rs/glam/latest/glam/bool/struct.BVec3.html: struct glam::bool::BVec3 - `BVec3`\n\u27e867\u27e9 https://docs.rs/glam/latest/glam/bool/struct.BVec4.html: struct glam::bool::BVec4 - `BVec4`\n\u27e868\u27e9 https://docs.rs/glam/latest/glam/#simd: \u00a7\n\u27e869\u27e9 https://docs.rs/glam/latest/glam/#vec3a-and-mat3a: \u00a7\n\u27e870\u27e9 https://github.com/bitshifter/mathbench-rs: **mathbench**\n\u27e871\u27e9 https://doc.rust-lang.org/nightly/core/convert/trait.From.html: trait core::convert::From - `From`\n\u27e872\u27e9 https://docs.rs/glam/latest/glam/#affine2-and-affine3a: \u00a7\n\u27e873\u27e9 https://docs.rs/glam/latest/glam/#linear-algebra-conventions: \u00a7\n\u27e874\u27e9 https://docs.rs/glam/latest/glam/#direct-element-access: \u00a7\n\u27e875\u27e9 https://doc.rust-lang.org/std/ops/trait.Deref.html: `Deref`\n\u27e876\u27e9 https://doc.rust-lang.org/std/ops/trait.DerefMut.html: `DerefMut`\n\u27e877\u27e9 https://docs.rs/glam/latest/glam/#glam-assertions: \u00a7\n\u27e878\u27e9 https://docs.rs/glam/latest/glam/#vector-swizzles: \u00a7\n\u27e879\u27e9 https://docs.rs/glam/latest/glam/swizzles/trait.Vec2Swizzles.html: trait glam::swizzles::Vec2Swizzles - `Vec2Swizzles`\n\u27e880\u27e9 https://docs.rs/glam/latest/glam/swizzles/trait.Vec3Swizzles.html: trait glam::swizzles::Vec3Swizzles - `Vec3Swizzles`\n\u27e881\u27e9 https://docs.rs/glam/latest/glam/swizzles/trait.Vec4Swizzles.html: trait glam::swizzles::Vec4Swizzles - `Vec4Swizzles`\n\u27e882\u27e9 https://docs.rs/glam/latest/glam/#simd-and-scalar-consistency: \u00a7\n\u27e883\u27e9 https://docs.rs/glam/latest/glam/#feature-gates: \u00a7\n\u27e884\u27e9 https://docs.rs/glam/latest/glam/#minimum-supported-rust-version-msrv: \u00a7\n\u27e885\u27e9 https://docs.rs/glam/latest/glam/#reexports: \u00a7\n\u27e886\u27e9 https://docs.rs/glam/latest/glam/#modules: \u00a7\n\u27e887\u27e9 https://docs.rs/glam/latest/glam/swizzles/index.html: mod glam::swizzles - swizzles\n\u27e888\u27e9 https://docs.rs/glam/latest/glam/#enums: \u00a7\n\u27e889\u27e9 https://docs.rs/glam/latest/glam/enum.EulerRot.html: enum glam::EulerRot - EulerRot\n\u27e890\u27e9 https://docs.rs/glam/latest/glam/#traits: \u00a7\n\u27e891\u27e9 https://docs.rs/glam/latest/glam/trait.FloatExt.html: trait glam::FloatExt - FloatExt\n\u27e892\u27e9 https://doc.rust-lang.org/nightly/std/primitive.f32.html: primitive f32 - `f32`\n\u27e893\u27e9 https://doc.rust-lang.org/nightly/std/primitive.f64.html: primitive f64 - `f64`\n",
              "fit_markdown": "",
              "fit_html": ""
            },
            "structured_data": {},
            "quality_score": 4.0,
            "extraction_method": "crawl4ai",
            "error": null,
            "metadata": {
              "doc_type": "docs",
              "content_length": 21232,
              "has_structured_data": false,
              "crawl_success": true
            },
            "timestamp": "119531.2290589"
          },
          "lib_rs": {
            "url": "https://lib.rs/crates/glam",
            "title": "Untitled",
            "content": {
              "raw_markdown": "###  [73 releases](https://lib.rs/crates/glam/versions)\n0.30.4 |  Jun 12, 2025   \n---|---  \n0.30.2 |  Apr 13, 2025   \n0.30.1 |  Mar 20, 2025   \n0.29.2 |  Nov 5, 2024   \n0.7.1 |  Jul 8, 2019   \n#**2** in [Game dev](https://lib.rs/game-development \"Crates for creating games.\")\nDownload history 217186/week @ 2025-03-10 182757/week @ 2025-03-17 175949/week @ 2025-03-24 168728/week @ 2025-03-31 159676/week @ 2025-04-07 144820/week @ 2025-04-14 155995/week @ 2025-04-21 176467/week @ 2025-04-28 157462/week @ 2025-05-05 151984/week @ 2025-05-12 141498/week @ 2025-05-19 127711/week @ 2025-05-26 154051/week @ 2025-06-02 162470/week @ 2025-06-09 173126/week @ 2025-06-16 167475/week @ 2025-06-23\n**664,276** downloads per month Used in [**2,763** crates (606 directly)](https://lib.rs/crates/glam/rev)\n**MIT/Apache**\n5MB  **168K** SLoC\n# glam\n[![Build Status](https://img.gs/czjpqfbdkz/full/https://github.com/bitshifter/glam-rs/actions/workflows/ci.yml/badge.svg)](https://github.com/bitshifter/glam-rs/actions/workflows/ci.yml) [![Coverage Status](https://img.gs/czjpqfbdkz/full/https://coveralls.io/repos/github/bitshifter/glam-rs/badge.svg?branch=main)](https://coveralls.io/github/bitshifter/glam-rs?branch=main) [![Latest Version](https://img.shields.io/crates/v/glam.svg)](https://crates.io/crates/glam/) [![docs](https://img.gs/czjpqfbdkz/full/https://docs.rs/glam/badge.svg)](https://docs.rs/glam/) [![Minimum Supported Rust Version](https://img.shields.io/badge/Rust-1.68.2-blue?color=fc8d62&logo=rust)](https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1682-2023-03-28)\nA simple and fast 3D math library for games and graphics.\n## Development status\n``glam`` is in beta stage. Base functionality has been implemented and the look and feel of the API has solidified.\n## Features\n  * ```f32``` types \n    * vectors: ``Vec2``, ``Vec3``, ``Vec3A`` and ``Vec4``\n    * square matrices: ``Mat2``, ``Mat3``, ``Mat3A`` and ``Mat4``\n    * a quaternion type: ``Quat``\n    * affine transformation types: ``Affine2`` and ``Affine3A``\n  * ```f64``` types \n    * vectors: ``DVec2``, ``DVec3`` and ``DVec4``\n    * square matrices: ``DMat2``, ``DMat3`` and ``DMat4``\n    * a quaternion type: ``DQuat``\n    * affine transformation types: ``DAffine2`` and ``DAffine3``\n  * ```i8``` types \n    * vectors: ``I8Vec2``, ``I8Vec3`` and ``I8Vec4``\n  * ```u8``` types \n    * vectors: ``U16Vec2``, ``U16Vec3`` and ``U16Vec4``\n  * ```i16``` types \n    * vectors: ``I16Vec2``, ``I16Vec3`` and ``I16Vec4``\n  * ```u16``` types \n    * vectors: ``U16Vec2``, ``U16Vec3`` and ``U16Vec4``\n  * ```i32``` types \n    * vectors: ``IVec2``, ``IVec3`` and ``IVec4``\n  * ```u32``` types \n    * vectors: ``UVec2``, ``UVec3`` and ``UVec4``\n  * ```i64``` types \n    * vectors: ``I64Vec2``, ``I64Vec3`` and ``I64Vec4``\n  * ```u64``` types \n    * vectors: ``U64Vec2``, ``U64Vec3`` and ``U64Vec4``\n  * ```usize``` types \n    * vectors: ``USizeVec2``, ``USizeVec3`` and ``USizeVec4``\n  * ```bool``` types \n    * vectors: ``BVec2``, ``BVec3`` and ``BVec4``\n\n\n### SIMD\nThe ``Vec3A``, ``Vec4``, ``Quat``, ``Mat2``, ``Mat3A``, ``Mat4``, ``Affine2`` and ``Affine3A`` types use 128-bit wide SIMD vector types for storage on ``x86``, ``x86_64`` and ``wasm32`` architectures. As a result, these types are all 16 byte aligned and depending on the size of the type or the type's members, they may contain internal padding. This results in some wasted space in the cases of ``Vec3A``, ``Mat3A``, ``Affine2`` and ``Affine3A``. However, the use of SIMD generally results in better performance than scalar math.\n``glam`` outperforms similar Rust libraries for common operations as tested by the [``mathbench``](https://github.com/bitshifter/mathbench-rs) project.\n### Enabling SIMD\nSIMD is supported on ``x86``, ``x86_64`` and ``wasm32`` targets.\n  * ```SSE2``` is enabled by default on ``x86_64`` targets.\n  * To enable ```SSE2``` on ``x86`` targets add ```-`C target`-`feature`=``+`sse2`` to ``RUSTCFLAGS``.\n  * ``NEON`` is enabled by default on ``aarch64`` targets.\n  * To enable ``NEON`` on ``aarch64`` targets add ```-`C target`-`feature`=``+`neon`` to ``RUSTFLAGS``.\n  * To enable ``simd128`` on ``wasm32`` targets add ```-`C target`-`feature`=``+`simd128`` to ``RUSTFLAGS``.\n  * Experimental [portable simd](https://doc.rust-lang.org/core/simd/index.html) support can be enabled with the ``core-simd`` feature. This requires the nightly compiler as it is still unstable in Rust.\n\n\nNote that SIMD on ``wasm32`` passes tests but has not been benchmarked, performance may or may not be better than scalar math.\n### ``no_std`` support\n``no_std`` support can be enabled by compiling with ``--no-default-features`` to disable ``std`` support and ``--features libm`` for math functions that are only defined in ``std``. For example:\n```\n```[``dependencies``]`\n`glam = { version = \"0.30.4\", default-features = false, features ``=` ``[```\"`libm`\"```]`` }\n``\n```\n\nTo support both ``std`` and ``no_std`` builds in project, you can use the following in your ``Cargo.toml``:\n```\n```[``features``]`\n`default ``=` ``[```\"`std`\"```]``\n`std ``=` ``[```\"`glam/std`\"```]``\n`libm ``=` ``[```\"`glam/libm`\"```]``\n```[``dependencies``]`\n`glam = { version = \"0.30.4\", default-features ``=` `false` }\n``\n```\n\nAlternatively, you can use the ``nostd-libm`` feature. This will always include a ``libm`` dependency, but allows the user to still override it with ``std`` if they prefer. This will allow your crate to compile with default features disabled, instead of forcing the user to enable either ``std`` or ``libm``.\n```\n```[``features``]`\n`default ``=` ``[```\"`std`\"```]``\n`std ``=` ``[```\"`glam/std`\"```]``\n`libm ``=` ``[```\"`glam/libm`\"```]``\n```[``dependencies``]`\n`glam = { version = \"0.30.4\", default-features = false, features ``=` ``[```\"`nostd-libm`\"```]`` }\n``\n```\n\n### Optional features\n  * [``approx``](https://docs.rs/approx) - traits and macros for approximate float comparisons\n  * [``bytemuck``](https://docs.rs/bytemuck) - for casting into slices of bytes\n  * [``libm``](https://github.com/rust-lang/libm) - uses ``libm`` math functions instead of ``std``\n  * [``mint``](https://github.com/kvark/mint) - for interoperating with other 3D math libraries\n  * [``rand``](https://github.com/rust-random/rand) - implementations of ``Distribution`` trait for all ``glam`` types.\n  * [``serde``](https://serde.rs) - implementations of ``Serialize`` and ``Deserialize`` for all ``glam`` types. Note that serialization should work between builds of ``glam`` with and without SIMD enabled\n  * [``speedy``](https://docs.rs/speedy) - implementations of ``speedy``'s ``Readable`` and ``Writable`` for all ``glam`` types.\n  * [``rkyv``](https://github.com/rkyv/rkyv) - implementations of ``Archive``, ``Serialize`` and ``Deserialize`` for all ``glam`` types. Note that serialization is not interoperable with and without the ``scalar-math`` feature. It should work between all other builds of ``glam``. Endian conversion is currently not supported\n  * [``bytecheck``](https://github.com/rkyv/bytecheck) - to perform archive validation when using the ``rkyv`` feature\n\n\n### Feature gates\n  * ``scalar-math`` - compiles with SIMD support disabled\n  * ``debug-glam-assert`` - adds assertions in debug builds which check the validity of parameters passed to ``glam`` to help catch runtime errors\n  * ``glam-assert`` - adds validation assertions to all builds\n  * ``nostd-libm`` - uses ``libm`` math functions if ``std`` is not available\n  * ``cuda`` - forces ``glam`` types to match expected [cuda alignment](https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#built-in-vector-types)\n  * ``fast-math`` - By default, glam attempts to provide bit-for-bit identical results on all platforms. Using this feature will enable platform specific optimizations that may not be identical to other platforms. **Intermediate libraries should not use this feature and defer the decision to the final binary build**.\n  * ``core-simd`` - enables SIMD support via the [portable simd](https://doc.rust-lang.org/core/simd/index.html) module. This is an unstable feature which requires a nightly Rust toolchain and ``std`` support.\n\n\n### Minimum Supported Rust Version (MSRV)\nThe minimum supported version of Rust for ``glam`` is ```1.``68``.``2```.\n## Conventions\n### Column vectors\n``glam`` interprets vectors as column matrices (also known as \"column vectors\") meaning when transforming a vector with a matrix the matrix goes on the left, e.g. ``v`'` `=` Mv``. DirectX uses row vectors, OpenGL uses column vectors. There are pros and cons to both.\n### Column-major order\nMatrices are stored in column major format. Each column vector is stored in contiguous memory.\n### Co-ordinate system\n``glam`` is co-ordinate system agnostic and intends to support both right-handed and left-handed conventions.\n## Design Philosophy\nThe design of this library is guided by a desire for simplicity and good performance.\n  * No generics and minimal traits in the public API for simplicity of usage\n  * All dependencies are optional (e.g. ``mint``, ``rand`` and ``serde``)\n  * Follows the [Rust API Guidelines](https://rust-lang-nursery.github.io/api-guidelines/) where possible\n  * Aiming for 100% test [coverage](https://github.com/bitshifter/glam-rs/blob/2adf1d6f48a5dde5405f8a9caca4def167f966f2/coveralls.io)\n  * Common functionality is benchmarked using [Criterion.rs](https://bheisler.github.io/criterion.rs/book/index.html)\n\n\n## Architecture\nSee [ARCHITECTURE.md](https://github.com/bitshifter/glam-rs/blob/2adf1d6f48a5dde5405f8a9caca4def167f966f2/ARCHITECTURE.md) for details on ``glam``'s internals.\n## Inspirations\nThere were many inspirations for the interface and internals of glam from the Rust and C++ worlds. In particular:\n  * [How to write a maths library in 2016](http://www.codersnotes.com/notes/maths-lib-2016/) inspired the initial ``Vec3A`` implementation\n  * [Realtime Math](https://github.com/nfrechette/rtm) - header only C++11 with SSE and NEON SIMD intrinsic support\n  * [DirectXMath](https://docs.microsoft.com/en-us/windows/desktop/dxmath/directxmath-portal) - header only SIMD C++ linear algebra library for use in games and graphics apps\n  * ``glam`` is a play on the name of the popular C++ library [GLM](https://glm.g-truc.net)\n\n\n## License\nLicensed under either of\n  * Apache License, Version 2.0 ([LICENSE-APACHE](https://github.com/bitshifter/glam-rs/blob/2adf1d6f48a5dde5405f8a9caca4def167f966f2/LICENSE-APACHE) or <http://www.apache.org/licenses/LICENSE-2.0>)\n  * MIT license ([LICENSE-MIT](https://github.com/bitshifter/glam-rs/blob/2adf1d6f48a5dde5405f8a9caca4def167f966f2/LICENSE-MIT) or <http://opensource.org/licenses/MIT>)\n\n\nat your option.\n## Contribution\nContributions in any form (issues, pull requests, etc.) to this project must adhere to Rust's [Code of Conduct](https://www.rust-lang.org/en-US/conduct.html).\nUnless you explicitly state otherwise, any contribution intentionally submitted for inclusion in the work by you, as defined in the Apache-2.0 license, shall be dual licensed as above, without any additional terms or conditions.\nIf you are interested in contributing or have a request or suggestion [start a discussion](https://github.com/bitshifter/glam-rs/discussions) on GitHub. See [CONTRIBUTING.md](https://github.com/bitshifter/glam-rs/blob/2adf1d6f48a5dde5405f8a9caca4def167f966f2/CONTRIBUTING.md) for more information for contributors.\nMost code in ``glam`` is generated, see the [codegen README](https://github.com/bitshifter/glam-rs/blob/2adf1d6f48a5dde5405f8a9caca4def167f966f2/codegen/README.md) for details.\nThank you to all of the ``glam`` [contributors](https://github.com/bitshifter/glam-rs/graphs/contributors)!\n## Support\nThe [Game Development in Rust Discord](https://discord.gg/yNtPTb2) and [Bevy Engine Discord](https://discord.gg/gMUk5Ph) servers are not official support channels but can be good places to ask for help with ``glam``.\n## Attribution\n``glam`` contains code ported from the following C++ libraries:\n  * [DirectXMath](https://docs.microsoft.com/en-us/windows/desktop/dxmath/directxmath-portal) - MIT License - Copyright (c) 2011-2020 Microsoft Corp\n  * [Realtime Math](https://github.com/nfrechette/rtm) - MIT License - Copyright (c) 2018 Nicholas Frechette\n  * [GLM](https://glm.g-truc.net) - MIT License - Copyright (c) 2005 - G-Truc Creation\n\n\nSee [ATTRIBUTION.md](https://github.com/bitshifter/glam-rs/blob/2adf1d6f48a5dde5405f8a9caca4def167f966f2/ATTRIBUTION.md) for details.\n#### Dependencies\n  * [ optional ](https://lib.rs/crates/glam/features#feature-approx \"approx is optional feature\") [approx](https://lib.rs/crates/approx \"0.5\")\n  * [bytemuck?](https://lib.rs/crates/glam/features#feature-bytemuck \"optional feature\") [core-simd?](https://lib.rs/crates/glam/features#feature-core-simd \"optional feature\") [bytemuck](https://lib.rs/crates/bytemuck \"1.9\")[+derive](https://lib.rs/crates/bytemuck/features#feature-derive)[+aarch64_simd](https://lib.rs/crates/bytemuck/features#feature-aarch64_simd)[+wasm_simd](https://lib.rs/crates/bytemuck/features#feature-wasm_simd)\n  * [libm?](https://lib.rs/crates/glam/features#feature-libm \"optional feature\") [nostd-libm?](https://lib.rs/crates/glam/features#feature-nostd-libm \"optional feature\") [libm](https://lib.rs/crates/libm \"0.2\")\n  * [ optional ](https://lib.rs/crates/glam/features#feature-mint \"mint is optional feature\") [mint](https://lib.rs/crates/mint \"0.5.8\")\n  * [ optional ](https://lib.rs/crates/glam/features#feature-rand \"rand is optional feature\") [rand](https://lib.rs/crates/rand \"new\") 0.9\n  * [bytecheck?](https://lib.rs/crates/glam/features#feature-bytecheck \"optional feature\") [rkyv](https://lib.rs/crates/rkyv \"new\") 0.8\n  * [ optional ](https://lib.rs/crates/glam/features#feature-serde \"serde is optional feature\") [serde](https://lib.rs/crates/serde \"1.0\")\n  * [ optional ](https://lib.rs/crates/glam/features#feature-speedy \"speedy is optional feature\") [speedy](https://lib.rs/crates/speedy \"0.8\")\n\n\n  * dev  [criterion](https://lib.rs/crates/criterion \"outdated\") 0.5[+html_reports](https://lib.rs/crates/criterion/features#feature-html_reports) not wasm32\n  * dev  [iai-callgrind](https://lib.rs/crates/iai-callgrind \"outdated\") 0.14 not wasm32\n  * dev  [rand_xoshiro](https://lib.rs/crates/rand_xoshiro \"new\") 0.7\n  * dev  [serde_json](https://lib.rs/crates/serde_json \"1.0\")\n  * dev  [wasm-bindgen-test](https://lib.rs/crates/wasm-bindgen-test \"0.3\") wasm32\n\n\n#### [Other features](https://lib.rs/crates/glam/features)\n  * [cuda](https://lib.rs/crates/glam/features#feature-cuda)\n  * [debug-glam-assert](https://lib.rs/crates/glam/features#feature-debug-glam-assert)\n  * [fast-math](https://lib.rs/crates/glam/features#feature-fast-math)\n  * [glam-assert](https://lib.rs/crates/glam/features#feature-glam-assert)\n  * [scalar-math](https://lib.rs/crates/glam/features#feature-scalar-math)\n  * [std](https://lib.rs/crates/glam/features#feature-std)\n\n\n  *[SLoC]: Lines of code, excluding comments\n",
              "markdown_with_citations": "###  73 releases\u27e81\u27e9\n0.30.4 |  Jun 12, 2025   \n---|---  \n0.30.2 |  Apr 13, 2025   \n0.30.1 |  Mar 20, 2025   \n0.29.2 |  Nov 5, 2024   \n0.7.1 |  Jul 8, 2019   \n#**2** in Game dev\u27e82\u27e9\nDownload history 217186/week @ 2025-03-10 182757/week @ 2025-03-17 175949/week @ 2025-03-24 168728/week @ 2025-03-31 159676/week @ 2025-04-07 144820/week @ 2025-04-14 155995/week @ 2025-04-21 176467/week @ 2025-04-28 157462/week @ 2025-05-05 151984/week @ 2025-05-12 141498/week @ 2025-05-19 127711/week @ 2025-05-26 154051/week @ 2025-06-02 162470/week @ 2025-06-09 173126/week @ 2025-06-16 167475/week @ 2025-06-23\n**664,276** downloads per month Used in **2,763** crates (606 directly)\u27e83\u27e9\n**MIT/Apache**\n5MB  **168K** SLoC\n# glam\n![Build Status\u27e84\u27e9](https://github.com/bitshifter/glam-rs/actions/workflows/ci.yml) ![Coverage Status\u27e85\u27e9](https://coveralls.io/github/bitshifter/glam-rs?branch=main) ![Latest Version\u27e86\u27e9](https://crates.io/crates/glam/) ![docs\u27e87\u27e9](https://docs.rs/glam/) ![Minimum Supported Rust Version\u27e88\u27e9](https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1682-2023-03-28)\nA simple and fast 3D math library for games and graphics.\n## Development status\n``glam`` is in beta stage. Base functionality has been implemented and the look and feel of the API has solidified.\n## Features\n  * ```f32``` types \n    * vectors: ``Vec2``, ``Vec3``, ``Vec3A`` and ``Vec4``\n    * square matrices: ``Mat2``, ``Mat3``, ``Mat3A`` and ``Mat4``\n    * a quaternion type: ``Quat``\n    * affine transformation types: ``Affine2`` and ``Affine3A``\n  * ```f64``` types \n    * vectors: ``DVec2``, ``DVec3`` and ``DVec4``\n    * square matrices: ``DMat2``, ``DMat3`` and ``DMat4``\n    * a quaternion type: ``DQuat``\n    * affine transformation types: ``DAffine2`` and ``DAffine3``\n  * ```i8``` types \n    * vectors: ``I8Vec2``, ``I8Vec3`` and ``I8Vec4``\n  * ```u8``` types \n    * vectors: ``U16Vec2``, ``U16Vec3`` and ``U16Vec4``\n  * ```i16``` types \n    * vectors: ``I16Vec2``, ``I16Vec3`` and ``I16Vec4``\n  * ```u16``` types \n    * vectors: ``U16Vec2``, ``U16Vec3`` and ``U16Vec4``\n  * ```i32``` types \n    * vectors: ``IVec2``, ``IVec3`` and ``IVec4``\n  * ```u32``` types \n    * vectors: ``UVec2``, ``UVec3`` and ``UVec4``\n  * ```i64``` types \n    * vectors: ``I64Vec2``, ``I64Vec3`` and ``I64Vec4``\n  * ```u64``` types \n    * vectors: ``U64Vec2``, ``U64Vec3`` and ``U64Vec4``\n  * ```usize``` types \n    * vectors: ``USizeVec2``, ``USizeVec3`` and ``USizeVec4``\n  * ```bool``` types \n    * vectors: ``BVec2``, ``BVec3`` and ``BVec4``\n\n\n### SIMD\nThe ``Vec3A``, ``Vec4``, ``Quat``, ``Mat2``, ``Mat3A``, ``Mat4``, ``Affine2`` and ``Affine3A`` types use 128-bit wide SIMD vector types for storage on ``x86``, ``x86_64`` and ``wasm32`` architectures. As a result, these types are all 16 byte aligned and depending on the size of the type or the type's members, they may contain internal padding. This results in some wasted space in the cases of ``Vec3A``, ``Mat3A``, ``Affine2`` and ``Affine3A``. However, the use of SIMD generally results in better performance than scalar math.\n``glam`` outperforms similar Rust libraries for common operations as tested by the ``mathbench``\u27e89\u27e9 project.\n### Enabling SIMD\nSIMD is supported on ``x86``, ``x86_64`` and ``wasm32`` targets.\n  * ```SSE2``` is enabled by default on ``x86_64`` targets.\n  * To enable ```SSE2``` on ``x86`` targets add ```-`C target`-`feature`=``+`sse2`` to ``RUSTCFLAGS``.\n  * ``NEON`` is enabled by default on ``aarch64`` targets.\n  * To enable ``NEON`` on ``aarch64`` targets add ```-`C target`-`feature`=``+`neon`` to ``RUSTFLAGS``.\n  * To enable ``simd128`` on ``wasm32`` targets add ```-`C target`-`feature`=``+`simd128`` to ``RUSTFLAGS``.\n  * Experimental portable simd\u27e810\u27e9 support can be enabled with the ``core-simd`` feature. This requires the nightly compiler as it is still unstable in Rust.\n\n\nNote that SIMD on ``wasm32`` passes tests but has not been benchmarked, performance may or may not be better than scalar math.\n### ``no_std`` support\n``no_std`` support can be enabled by compiling with ``--no-default-features`` to disable ``std`` support and ``--features libm`` for math functions that are only defined in ``std``. For example:\n```\n```[``dependencies``]`\n`glam = { version = \"0.30.4\", default-features = false, features ``=` ``[```\"`libm`\"```]`` }\n``\n```\n\nTo support both ``std`` and ``no_std`` builds in project, you can use the following in your ``Cargo.toml``:\n```\n```[``features``]`\n`default ``=` ``[```\"`std`\"```]``\n`std ``=` ``[```\"`glam/std`\"```]``\n`libm ``=` ``[```\"`glam/libm`\"```]``\n```[``dependencies``]`\n`glam = { version = \"0.30.4\", default-features ``=` `false` }\n``\n```\n\nAlternatively, you can use the ``nostd-libm`` feature. This will always include a ``libm`` dependency, but allows the user to still override it with ``std`` if they prefer. This will allow your crate to compile with default features disabled, instead of forcing the user to enable either ``std`` or ``libm``.\n```\n```[``features``]`\n`default ``=` ``[```\"`std`\"```]``\n`std ``=` ``[```\"`glam/std`\"```]``\n`libm ``=` ``[```\"`glam/libm`\"```]``\n```[``dependencies``]`\n`glam = { version = \"0.30.4\", default-features = false, features ``=` ``[```\"`nostd-libm`\"```]`` }\n``\n```\n\n### Optional features\n  * ``approx``\u27e811\u27e9 - traits and macros for approximate float comparisons\n  * ``bytemuck``\u27e812\u27e9 - for casting into slices of bytes\n  * ``libm``\u27e813\u27e9 - uses ``libm`` math functions instead of ``std``\n  * ``mint``\u27e814\u27e9 - for interoperating with other 3D math libraries\n  * ``rand``\u27e815\u27e9 - implementations of ``Distribution`` trait for all ``glam`` types.\n  * ``serde``\u27e816\u27e9 - implementations of ``Serialize`` and ``Deserialize`` for all ``glam`` types. Note that serialization should work between builds of ``glam`` with and without SIMD enabled\n  * ``speedy``\u27e817\u27e9 - implementations of ``speedy``'s ``Readable`` and ``Writable`` for all ``glam`` types.\n  * ``rkyv``\u27e818\u27e9 - implementations of ``Archive``, ``Serialize`` and ``Deserialize`` for all ``glam`` types. Note that serialization is not interoperable with and without the ``scalar-math`` feature. It should work between all other builds of ``glam``. Endian conversion is currently not supported\n  * ``bytecheck``\u27e819\u27e9 - to perform archive validation when using the ``rkyv`` feature\n\n\n### Feature gates\n  * ``scalar-math`` - compiles with SIMD support disabled\n  * ``debug-glam-assert`` - adds assertions in debug builds which check the validity of parameters passed to ``glam`` to help catch runtime errors\n  * ``glam-assert`` - adds validation assertions to all builds\n  * ``nostd-libm`` - uses ``libm`` math functions if ``std`` is not available\n  * ``cuda`` - forces ``glam`` types to match expected cuda alignment\u27e820\u27e9\n  * ``fast-math`` - By default, glam attempts to provide bit-for-bit identical results on all platforms. Using this feature will enable platform specific optimizations that may not be identical to other platforms. **Intermediate libraries should not use this feature and defer the decision to the final binary build**.\n  * ``core-simd`` - enables SIMD support via the portable simd\u27e810\u27e9 module. This is an unstable feature which requires a nightly Rust toolchain and ``std`` support.\n\n\n### Minimum Supported Rust Version (MSRV)\nThe minimum supported version of Rust for ``glam`` is ```1.``68``.``2```.\n## Conventions\n### Column vectors\n``glam`` interprets vectors as column matrices (also known as \"column vectors\") meaning when transforming a vector with a matrix the matrix goes on the left, e.g. ``v`'` `=` Mv``. DirectX uses row vectors, OpenGL uses column vectors. There are pros and cons to both.\n### Column-major order\nMatrices are stored in column major format. Each column vector is stored in contiguous memory.\n### Co-ordinate system\n``glam`` is co-ordinate system agnostic and intends to support both right-handed and left-handed conventions.\n## Design Philosophy\nThe design of this library is guided by a desire for simplicity and good performance.\n  * No generics and minimal traits in the public API for simplicity of usage\n  * All dependencies are optional (e.g. ``mint``, ``rand`` and ``serde``)\n  * Follows the Rust API Guidelines\u27e821\u27e9 where possible\n  * Aiming for 100% test coverage\u27e822\u27e9\n  * Common functionality is benchmarked using Criterion.rs\u27e823\u27e9\n\n\n## Architecture\nSee ARCHITECTURE.md\u27e824\u27e9 for details on ``glam``'s internals.\n## Inspirations\nThere were many inspirations for the interface and internals of glam from the Rust and C++ worlds. In particular:\n  * How to write a maths library in 2016\u27e825\u27e9 inspired the initial ``Vec3A`` implementation\n  * Realtime Math\u27e826\u27e9 - header only C++11 with SSE and NEON SIMD intrinsic support\n  * DirectXMath\u27e827\u27e9 - header only SIMD C++ linear algebra library for use in games and graphics apps\n  * ``glam`` is a play on the name of the popular C++ library GLM\u27e828\u27e9\n\n\n## License\nLicensed under either of\n  * Apache License, Version 2.0 (LICENSE-APACHE\u27e829\u27e9 or <http://www.apache.org/licenses/LICENSE-2.0>)\n  * MIT license (LICENSE-MIT\u27e830\u27e9 or <http://opensource.org/licenses/MIT>)\n\n\nat your option.\n## Contribution\nContributions in any form (issues, pull requests, etc.) to this project must adhere to Rust's Code of Conduct\u27e831\u27e9.\nUnless you explicitly state otherwise, any contribution intentionally submitted for inclusion in the work by you, as defined in the Apache-2.0 license, shall be dual licensed as above, without any additional terms or conditions.\nIf you are interested in contributing or have a request or suggestion start a discussion\u27e832\u27e9 on GitHub. See CONTRIBUTING.md\u27e833\u27e9 for more information for contributors.\nMost code in ``glam`` is generated, see the codegen README\u27e834\u27e9 for details.\nThank you to all of the ``glam`` contributors\u27e835\u27e9!\n## Support\nThe Game Development in Rust Discord\u27e836\u27e9 and Bevy Engine Discord\u27e837\u27e9 servers are not official support channels but can be good places to ask for help with ``glam``.\n## Attribution\n``glam`` contains code ported from the following C++ libraries:\n  * DirectXMath\u27e827\u27e9 - MIT License - Copyright (c) 2011-2020 Microsoft Corp\n  * Realtime Math\u27e826\u27e9 - MIT License - Copyright (c) 2018 Nicholas Frechette\n  * GLM\u27e828\u27e9 - MIT License - Copyright (c) 2005 - G-Truc Creation\n\n\nSee ATTRIBUTION.md\u27e838\u27e9 for details.\n#### Dependencies\n  *  optional \u27e839\u27e9 approx\u27e840\u27e9\n  * bytemuck?\u27e841\u27e9 core-simd?\u27e842\u27e9 bytemuck\u27e843\u27e9+derive\u27e844\u27e9+aarch64_simd\u27e845\u27e9+wasm_simd\u27e846\u27e9\n  * libm?\u27e847\u27e9 nostd-libm?\u27e848\u27e9 libm\u27e849\u27e9\n  *  optional \u27e850\u27e9 mint\u27e851\u27e9\n  *  optional \u27e852\u27e9 rand\u27e853\u27e9 0.9\n  * bytecheck?\u27e854\u27e9 rkyv\u27e855\u27e9 0.8\n  *  optional \u27e856\u27e9 serde\u27e857\u27e9\n  *  optional \u27e858\u27e9 speedy\u27e859\u27e9\n\n\n  * dev  criterion\u27e860\u27e9 0.5+html_reports\u27e861\u27e9 not wasm32\n  * dev  iai-callgrind\u27e862\u27e9 0.14 not wasm32\n  * dev  rand_xoshiro\u27e863\u27e9 0.7\n  * dev  serde_json\u27e864\u27e9\n  * dev  wasm-bindgen-test\u27e865\u27e9 wasm32\n\n\n#### Other features\u27e866\u27e9\n  * cuda\u27e867\u27e9\n  * debug-glam-assert\u27e868\u27e9\n  * fast-math\u27e869\u27e9\n  * glam-assert\u27e870\u27e9\n  * scalar-math\u27e871\u27e9\n  * std\u27e872\u27e9\n\n\n  *[SLoC]: Lines of code, excluding comments\n",
              "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://lib.rs/crates/glam/versions: 73 releases\n\u27e82\u27e9 https://lib.rs/game-development: Crates for creating games. - Game dev\n\u27e83\u27e9 https://lib.rs/crates/glam/rev: **2,763** crates (606 directly)\n\u27e84\u27e9 https://img.gs/czjpqfbdkz/full/https://github.com/bitshifter/glam-rs/actions/workflows/ci.yml/badge.svg: ![Build Status\n\u27e85\u27e9 https://img.gs/czjpqfbdkz/full/https://coveralls.io/repos/github/bitshifter/glam-rs/badge.svg?branch=main: ![Coverage Status\n\u27e86\u27e9 https://img.shields.io/crates/v/glam.svg: ![Latest Version\n\u27e87\u27e9 https://img.gs/czjpqfbdkz/full/https://docs.rs/glam/badge.svg: ![docs\n\u27e88\u27e9 https://img.shields.io/badge/Rust-1.68.2-blue?color=fc8d62&logo=rust: ![Minimum Supported Rust Version\n\u27e89\u27e9 https://github.com/bitshifter/mathbench-rs: ``mathbench``\n\u27e810\u27e9 https://doc.rust-lang.org/core/simd/index.html: portable simd\n\u27e811\u27e9 https://docs.rs/approx: ``approx``\n\u27e812\u27e9 https://docs.rs/bytemuck: ``bytemuck``\n\u27e813\u27e9 https://github.com/rust-lang/libm: ``libm``\n\u27e814\u27e9 https://github.com/kvark/mint: ``mint``\n\u27e815\u27e9 https://github.com/rust-random/rand: ``rand``\n\u27e816\u27e9 https://serde.rs: ``serde``\n\u27e817\u27e9 https://docs.rs/speedy: ``speedy``\n\u27e818\u27e9 https://github.com/rkyv/rkyv: ``rkyv``\n\u27e819\u27e9 https://github.com/rkyv/bytecheck: ``bytecheck``\n\u27e820\u27e9 https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#built-in-vector-types: cuda alignment\n\u27e821\u27e9 https://rust-lang-nursery.github.io/api-guidelines/: Rust API Guidelines\n\u27e822\u27e9 https://github.com/bitshifter/glam-rs/blob/2adf1d6f48a5dde5405f8a9caca4def167f966f2/coveralls.io: coverage\n\u27e823\u27e9 https://bheisler.github.io/criterion.rs/book/index.html: Criterion.rs\n\u27e824\u27e9 https://github.com/bitshifter/glam-rs/blob/2adf1d6f48a5dde5405f8a9caca4def167f966f2/ARCHITECTURE.md: ARCHITECTURE.md\n\u27e825\u27e9 http://www.codersnotes.com/notes/maths-lib-2016/: How to write a maths library in 2016\n\u27e826\u27e9 https://github.com/nfrechette/rtm: Realtime Math\n\u27e827\u27e9 https://docs.microsoft.com/en-us/windows/desktop/dxmath/directxmath-portal: DirectXMath\n\u27e828\u27e9 https://glm.g-truc.net: GLM\n\u27e829\u27e9 https://github.com/bitshifter/glam-rs/blob/2adf1d6f48a5dde5405f8a9caca4def167f966f2/LICENSE-APACHE: LICENSE-APACHE\n\u27e830\u27e9 https://github.com/bitshifter/glam-rs/blob/2adf1d6f48a5dde5405f8a9caca4def167f966f2/LICENSE-MIT: LICENSE-MIT\n\u27e831\u27e9 https://www.rust-lang.org/en-US/conduct.html: Code of Conduct\n\u27e832\u27e9 https://github.com/bitshifter/glam-rs/discussions: start a discussion\n\u27e833\u27e9 https://github.com/bitshifter/glam-rs/blob/2adf1d6f48a5dde5405f8a9caca4def167f966f2/CONTRIBUTING.md: CONTRIBUTING.md\n\u27e834\u27e9 https://github.com/bitshifter/glam-rs/blob/2adf1d6f48a5dde5405f8a9caca4def167f966f2/codegen/README.md: codegen README\n\u27e835\u27e9 https://github.com/bitshifter/glam-rs/graphs/contributors: contributors\n\u27e836\u27e9 https://discord.gg/yNtPTb2: Game Development in Rust Discord\n\u27e837\u27e9 https://discord.gg/gMUk5Ph: Bevy Engine Discord\n\u27e838\u27e9 https://github.com/bitshifter/glam-rs/blob/2adf1d6f48a5dde5405f8a9caca4def167f966f2/ATTRIBUTION.md: ATTRIBUTION.md\n\u27e839\u27e9 https://lib.rs/crates/glam/features#feature-approx: approx is optional feature -  optional \n\u27e840\u27e9 https://lib.rs/crates/approx: 0.5 - approx\n\u27e841\u27e9 https://lib.rs/crates/glam/features#feature-bytemuck: optional feature - bytemuck?\n\u27e842\u27e9 https://lib.rs/crates/glam/features#feature-core-simd: optional feature - core-simd?\n\u27e843\u27e9 https://lib.rs/crates/bytemuck: 1.9 - bytemuck\n\u27e844\u27e9 https://lib.rs/crates/bytemuck/features#feature-derive: +derive\n\u27e845\u27e9 https://lib.rs/crates/bytemuck/features#feature-aarch64_simd: +aarch64_simd\n\u27e846\u27e9 https://lib.rs/crates/bytemuck/features#feature-wasm_simd: +wasm_simd\n\u27e847\u27e9 https://lib.rs/crates/glam/features#feature-libm: optional feature - libm?\n\u27e848\u27e9 https://lib.rs/crates/glam/features#feature-nostd-libm: optional feature - nostd-libm?\n\u27e849\u27e9 https://lib.rs/crates/libm: 0.2 - libm\n\u27e850\u27e9 https://lib.rs/crates/glam/features#feature-mint: mint is optional feature -  optional \n\u27e851\u27e9 https://lib.rs/crates/mint: 0.5.8 - mint\n\u27e852\u27e9 https://lib.rs/crates/glam/features#feature-rand: rand is optional feature -  optional \n\u27e853\u27e9 https://lib.rs/crates/rand: new - rand\n\u27e854\u27e9 https://lib.rs/crates/glam/features#feature-bytecheck: optional feature - bytecheck?\n\u27e855\u27e9 https://lib.rs/crates/rkyv: new - rkyv\n\u27e856\u27e9 https://lib.rs/crates/glam/features#feature-serde: serde is optional feature -  optional \n\u27e857\u27e9 https://lib.rs/crates/serde: 1.0 - serde\n\u27e858\u27e9 https://lib.rs/crates/glam/features#feature-speedy: speedy is optional feature -  optional \n\u27e859\u27e9 https://lib.rs/crates/speedy: 0.8 - speedy\n\u27e860\u27e9 https://lib.rs/crates/criterion: outdated - criterion\n\u27e861\u27e9 https://lib.rs/crates/criterion/features#feature-html_reports: +html_reports\n\u27e862\u27e9 https://lib.rs/crates/iai-callgrind: outdated - iai-callgrind\n\u27e863\u27e9 https://lib.rs/crates/rand_xoshiro: new - rand_xoshiro\n\u27e864\u27e9 https://lib.rs/crates/serde_json: 1.0 - serde_json\n\u27e865\u27e9 https://lib.rs/crates/wasm-bindgen-test: 0.3 - wasm-bindgen-test\n\u27e866\u27e9 https://lib.rs/crates/glam/features: Other features\n\u27e867\u27e9 https://lib.rs/crates/glam/features#feature-cuda: cuda\n\u27e868\u27e9 https://lib.rs/crates/glam/features#feature-debug-glam-assert: debug-glam-assert\n\u27e869\u27e9 https://lib.rs/crates/glam/features#feature-fast-math: fast-math\n\u27e870\u27e9 https://lib.rs/crates/glam/features#feature-glam-assert: glam-assert\n\u27e871\u27e9 https://lib.rs/crates/glam/features#feature-scalar-math: scalar-math\n\u27e872\u27e9 https://lib.rs/crates/glam/features#feature-std: std\n",
              "fit_markdown": "",
              "fit_html": ""
            },
            "structured_data": {},
            "quality_score": 3.0,
            "extraction_method": "crawl4ai",
            "error": null,
            "metadata": {
              "doc_type": "docs",
              "content_length": 15003,
              "has_structured_data": false,
              "crawl_success": true
            },
            "timestamp": "119531.8630223"
          }
        },
        "crate_analysis": {
          "status": "completed",
          "check": [
            {
              "reason": "compiler-artifact",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpg29_cztg/glam-0.30.4#glam@0.30.4",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpg29_cztg\\glam-0.30.4\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "glam",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpg29_cztg\\glam-0.30.4\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "default",
                "std"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpg29_cztg\\glam-0.30.4\\target\\debug\\deps\\libglam-f924ad9712c3299c.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "build-finished",
              "success": true
            }
          ],
          "clippy": [
            {
              "reason": "compiler-artifact",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpg29_cztg/glam-0.30.4#glam@0.30.4",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpg29_cztg\\glam-0.30.4\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "glam",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpg29_cztg\\glam-0.30.4\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "default",
                "std"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpg29_cztg\\glam-0.30.4\\target\\debug\\deps\\libglam-83f0c34cc66da79f.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "build-finished",
              "success": true
            }
          ],
          "audit": {
            "database": {
              "advisory-count": 787,
              "last-commit": "7573f55ba337263f61167dbb0ea926cdc7c8eb5d",
              "last-updated": "2025-06-17T11:04:25+02:00"
            },
            "lockfile": {
              "dependency-count": 111
            },
            "settings": {
              "target_arch": [],
              "target_os": [],
              "severity": null,
              "ignore": [],
              "informational_warnings": [
                "unmaintained",
                "unsound",
                "notice"
              ]
            },
            "vulnerabilities": {
              "found": false,
              "count": 0,
              "list": []
            },
            "warnings": {}
          },
          "note": "Crate analysis performed with stable toolchain."
        },
        "crate_metadata": {
          "name": "glam",
          "version": "0.30.4",
          "description": "ALLOW: Positive community sentiment",
          "repository": "",
          "keywords": [],
          "categories": [],
          "readme": {
            "raw_markdown": "[](https://docs.rs/glam/latest/glam/all.html \"show sidebar\")\n# Crate glamCopy item path\n[Settings](https://docs.rs/glam/latest/settings.html)\n[Help](https://docs.rs/glam/latest/help.html)\nSummary[Source](https://docs.rs/glam/latest/src/glam/lib.rs.html#1-383)\nExpand description\n## [\u00a7](https://docs.rs/glam/latest/glam/#glam)glam\n`glam` is a simple and fast linear algebra library for games and graphics.\n### [\u00a7](https://docs.rs/glam/latest/glam/#features)Features\n  * [`f32`](https://docs.rs/glam/latest/glam/f32/index.html \"mod glam::f32\") types \n    * vectors: [`Vec2`](https://docs.rs/glam/latest/glam/f32/struct.Vec2.html \"struct glam::f32::Vec2\"), [`Vec3`](https://docs.rs/glam/latest/glam/f32/struct.Vec3.html \"struct glam::f32::Vec3\"), [`Vec3A`](https://docs.rs/glam/latest/glam/f32/struct.Vec3A.html \"struct glam::f32::Vec3A\") and [`Vec4`](https://docs.rs/glam/latest/glam/f32/struct.Vec4.html \"struct glam::f32::Vec4\")\n    * square matrices: [`Mat2`](https://docs.rs/glam/latest/glam/f32/struct.Mat2.html \"struct glam::f32::Mat2\"), [`Mat3`](https://docs.rs/glam/latest/glam/f32/struct.Mat3.html \"struct glam::f32::Mat3\"), [`Mat3A`](https://docs.rs/glam/latest/glam/f32/struct.Mat3A.html \"struct glam::f32::Mat3A\") and [`Mat4`](https://docs.rs/glam/latest/glam/f32/struct.Mat4.html \"struct glam::f32::Mat4\")\n    * a quaternion type: [`Quat`](https://docs.rs/glam/latest/glam/f32/struct.Quat.html \"struct glam::f32::Quat\")\n    * affine transformation types: [`Affine2`](https://docs.rs/glam/latest/glam/f32/struct.Affine2.html \"struct glam::f32::Affine2\") and [`Affine3A`](https://docs.rs/glam/latest/glam/f32/struct.Affine3A.html \"struct glam::f32::Affine3A\")\n  * [`f64`](https://docs.rs/glam/latest/glam/f64/index.html \"mod glam::f64\") types \n    * vectors: [`DVec2`](https://docs.rs/glam/latest/glam/f64/struct.DVec2.html \"struct glam::f64::DVec2\"), [`DVec3`](https://docs.rs/glam/latest/glam/f64/struct.DVec3.html \"struct glam::f64::DVec3\") and [`DVec4`](https://docs.rs/glam/latest/glam/f64/struct.DVec4.html \"struct glam::f64::DVec4\")\n    * square matrices: [`DMat2`](https://docs.rs/glam/latest/glam/f64/struct.DMat2.html \"struct glam::f64::DMat2\"), [`DMat3`](https://docs.rs/glam/latest/glam/f64/struct.DMat3.html \"struct glam::f64::DMat3\") and [`DMat4`](https://docs.rs/glam/latest/glam/f64/struct.DMat4.html \"struct glam::f64::DMat4\")\n    * a quaternion type: [`DQuat`](https://docs.rs/glam/latest/glam/f64/struct.DQuat.html \"struct glam::f64::DQuat\")\n    * affine transformation types: [`DAffine2`](https://docs.rs/glam/latest/glam/f64/struct.DAffine2.html \"struct glam::f64::DAffine2\") and [`DAffine3`](https://docs.rs/glam/latest/glam/f64/struct.DAffine3.html \"struct glam::f64::DAffine3\")\n  * [`i8`](https://docs.rs/glam/latest/glam/i8/index.html \"mod glam::i8\") types \n    * vectors: [`I8Vec2`](https://docs.rs/glam/latest/glam/i8/struct.I8Vec2.html \"struct glam::i8::I8Vec2\"), [`I8Vec3`](https://docs.rs/glam/latest/glam/i8/struct.I8Vec3.html \"struct glam::i8::I8Vec3\") and [`I8Vec4`](https://docs.rs/glam/latest/glam/i8/struct.I8Vec4.html \"struct glam::i8::I8Vec4\")\n  * [`u8`](https://docs.rs/glam/latest/glam/u8/index.html \"mod glam::u8\") types \n    * vectors: [`U8Vec2`](https://docs.rs/glam/latest/glam/u8/struct.U8Vec2.html \"struct glam::u8::U8Vec2\"), [`U8Vec3`](https://docs.rs/glam/latest/glam/u8/struct.U8Vec3.html \"struct glam::u8::U8Vec3\") and [`U8Vec4`](https://docs.rs/glam/latest/glam/u8/struct.U8Vec4.html \"struct glam::u8::U8Vec4\")\n  * [`i16`](https://docs.rs/glam/latest/glam/i16/index.html \"mod glam::i16\") types \n    * vectors: [`I16Vec2`](https://docs.rs/glam/latest/glam/i16/struct.I16Vec2.html \"struct glam::i16::I16Vec2\"), [`I16Vec3`](https://docs.rs/glam/latest/glam/i16/struct.I16Vec3.html \"struct glam::i16::I16Vec3\") and [`I16Vec4`](https://docs.rs/glam/latest/glam/i16/struct.I16Vec4.html \"struct glam::i16::I16Vec4\")\n  * [`u16`](https://docs.rs/glam/latest/glam/u16/index.html \"mod glam::u16\") types \n    * vectors: [`U16Vec2`](https://docs.rs/glam/latest/glam/u16/struct.U16Vec2.html \"struct glam::u16::U16Vec2\"), [`U16Vec3`](https://docs.rs/glam/latest/glam/u16/struct.U16Vec3.html \"struct glam::u16::U16Vec3\") and [`U16Vec4`](https://docs.rs/glam/latest/glam/u16/struct.U16Vec4.html \"struct glam::u16::U16Vec4\")\n  * [`i32`](https://docs.rs/glam/latest/glam/i32/index.html \"mod glam::i32\") types \n    * vectors: [`IVec2`](https://docs.rs/glam/latest/glam/i32/struct.IVec2.html \"struct glam::i32::IVec2\"), [`IVec3`](https://docs.rs/glam/latest/glam/i32/struct.IVec3.html \"struct glam::i32::IVec3\") and [`IVec4`](https://docs.rs/glam/latest/glam/i32/struct.IVec4.html \"struct glam::i32::IVec4\")\n  * [`u32`](https://docs.rs/glam/latest/glam/u32/index.html \"mod glam::u32\") types \n    * vectors: [`UVec2`](https://docs.rs/glam/latest/glam/u32/struct.UVec2.html \"struct glam::u32::UVec2\"), [`UVec3`](https://docs.rs/glam/latest/glam/u32/struct.UVec3.html \"struct glam::u32::UVec3\") and [`UVec4`](https://docs.rs/glam/latest/glam/u32/struct.UVec4.html \"struct glam::u32::UVec4\")\n  * [`i64`](https://docs.rs/glam/latest/glam/i64/index.html \"mod glam::i64\") types \n    * vectors: [`I64Vec2`](https://docs.rs/glam/latest/glam/i64/struct.I64Vec2.html \"struct glam::i64::I64Vec2\"), [`I64Vec3`](https://docs.rs/glam/latest/glam/i64/struct.I64Vec3.html \"struct glam::i64::I64Vec3\") and [`I64Vec4`](https://docs.rs/glam/latest/glam/i64/struct.I64Vec4.html \"struct glam::i64::I64Vec4\")\n  * [`u64`](https://docs.rs/glam/latest/glam/u64/index.html \"mod glam::u64\") types \n    * vectors: [`U64Vec2`](https://docs.rs/glam/latest/glam/u64/struct.U64Vec2.html \"struct glam::u64::U64Vec2\"), [`U64Vec3`](https://docs.rs/glam/latest/glam/u64/struct.U64Vec3.html \"struct glam::u64::U64Vec3\") and [`U64Vec4`](https://docs.rs/glam/latest/glam/u64/struct.U64Vec4.html \"struct glam::u64::U64Vec4\")\n  * [`usize`](https://docs.rs/glam/latest/glam/usize/index.html \"mod glam::usize\") types \n    * vectors: [`USizeVec2`](https://docs.rs/glam/latest/glam/usize/struct.USizeVec2.html \"struct glam::usize::USizeVec2\"), [`USizeVec3`](https://docs.rs/glam/latest/glam/usize/struct.USizeVec3.html \"struct glam::usize::USizeVec3\") and [`USizeVec4`](https://docs.rs/glam/latest/glam/usize/struct.USizeVec4.html \"struct glam::usize::USizeVec4\")\n  * [`bool`](https://docs.rs/glam/latest/glam/bool/index.html \"mod glam::bool\") types \n    * vectors: [`BVec2`](https://docs.rs/glam/latest/glam/bool/struct.BVec2.html \"struct glam::bool::BVec2\"), [`BVec3`](https://docs.rs/glam/latest/glam/bool/struct.BVec3.html \"struct glam::bool::BVec3\") and [`BVec4`](https://docs.rs/glam/latest/glam/bool/struct.BVec4.html \"struct glam::bool::BVec4\")\n\n\n### [\u00a7](https://docs.rs/glam/latest/glam/#simd)SIMD\n`glam` is built with SIMD in mind. Many `f32` types use 128-bit SIMD vector types for storage and/or implementation. The use of SIMD generally enables better performance than using primitive numeric types such as `f32`.\nSome `glam` types use SIMD for storage meaning they are 16 byte aligned, these types include `Mat2`, `Mat3A`, `Mat4`, `Quat`, `Vec3A`, `Vec4`, `Affine2` an `Affine3A`. Types with an `A` suffix are a SIMD alternative to a scalar type, e.g. `Vec3` uses `f32` storage and `Vec3A` uses SIMD storage.\nWhen SIMD is not available on the target the types will maintain 16 byte alignment and internal padding so that object sizes and layouts will not change between architectures. There are scalar math fallback implementations exist when SIMD is not available. It is intended to add support for other SIMD architectures once they appear in stable Rust.\nCurrently only SSE2 on x86/x86_64, NEON on Aarch64, and simd128 on WASM are supported.\n### [\u00a7](https://docs.rs/glam/latest/glam/#vec3a-and-mat3a)Vec3A and Mat3A\n`Vec3A` is a SIMD optimized version of the `Vec3` type, which due to 16 byte alignment results in `Vec3A` containing 4 bytes of padding making it 16 bytes in size in total. `Mat3A` is composed of three `Vec3A` columns.\nType| `f32` bytes| Align bytes| Size bytes| Padding  \n---|---|---|---|---  \n[`Vec3`](https://docs.rs/glam/latest/glam/f32/struct.Vec3.html \"struct glam::f32::Vec3\")| 12| 4| 12| 0  \n[`Vec3A`](https://docs.rs/glam/latest/glam/f32/struct.Vec3A.html \"struct glam::f32::Vec3A\")| 12| 16| 16| 4  \n[`Mat3`](https://docs.rs/glam/latest/glam/f32/struct.Mat3.html \"struct glam::f32::Mat3\")| 36| 4| 36| 0  \n[`Mat3A`](https://docs.rs/glam/latest/glam/f32/struct.Mat3A.html \"struct glam::f32::Mat3A\")| 36| 16| 48| 12  \nDespite this wasted space the SIMD implementations tend to outperform `f32` implementations in [**mathbench**](https://github.com/bitshifter/mathbench-rs) benchmarks.\n`glam` treats [`Vec3`](https://docs.rs/glam/latest/glam/f32/struct.Vec3.html \"struct glam::f32::Vec3\") as the default 3D vector type and [`Vec3A`](https://docs.rs/glam/latest/glam/f32/struct.Vec3A.html \"struct glam::f32::Vec3A\") a special case for optimization. When methods need to return a 3D vector they will generally return [`Vec3`](https://docs.rs/glam/latest/glam/f32/struct.Vec3.html \"struct glam::f32::Vec3\").\nThere are [`From`](https://doc.rust-lang.org/nightly/core/convert/trait.From.html \"trait core::convert::From\") trait implementations for converting from [`Vec4`](https://docs.rs/glam/latest/glam/f32/struct.Vec4.html \"struct glam::f32::Vec4\") to a [`Vec3A`](https://docs.rs/glam/latest/glam/f32/struct.Vec3A.html \"struct glam::f32::Vec3A\") and between [`Vec3`](https://docs.rs/glam/latest/glam/f32/struct.Vec3.html \"struct glam::f32::Vec3\") and [`Vec3A`](https://docs.rs/glam/latest/glam/f32/struct.Vec3A.html \"struct glam::f32::Vec3A\") (and vice versa).\n```\nuse glam::{Vec3, Vec3A, Vec4};\nlet v4 = Vec4::new(1.0, 2.0, 3.0, 4.0);\n// Convert from `Vec4` to `Vec3A`, this is a no-op if SIMD is supported.\n// We use an explicit method here instead of a From impl as data is lost in the conversion.\nlet v3a = Vec3A::from_vec4(v4);\nassert_eq!(Vec3A::new(1.0, 2.0, 3.0), v3a);\n// Convert from `Vec3A` to `Vec3`.\nlet v3 = Vec3::from(v3a);\nassert_eq!(Vec3::new(1.0, 2.0, 3.0), v3);\n// Convert from `Vec3` to `Vec3A`.\nlet v3a = Vec3A::from(v3);\nassert_eq!(Vec3A::new(1.0, 2.0, 3.0), v3a);\n```\n\n### [\u00a7](https://docs.rs/glam/latest/glam/#affine2-and-affine3a)Affine2 and Affine3A\n`Affine2` and `Affine3A` are composed of a linear transform matrix and a vector translation. The represent 2D and 3D affine transformations which are commonly used in games.\nThe table below shows the performance advantage of `Affine2` over `Mat3A` and `Mat3A` over `Mat3`.\noperation| `Mat3`| `Mat3A`| `Affine2`  \n---|---|---|---  \ninverse| 11.4\u00b10.09ns| 7.1\u00b10.09ns| 5.4\u00b10.06ns  \nmul self| 10.5\u00b10.04ns| 5.2\u00b10.05ns| 4.0\u00b10.05ns  \ntransform point2| 2.7\u00b10.02ns| 2.7\u00b10.03ns| 2.8\u00b10.04ns  \ntransform vector2| 2.6\u00b10.01ns| 2.6\u00b10.03ns| 2.3\u00b10.02ns  \nPerformance is much closer between `Mat4` and `Affine3A` with the affine type being faster to invert.\noperation| `Mat4`| `Affine3A`  \n---|---|---  \ninverse| 15.9\u00b10.11ns| 10.8\u00b10.06ns  \nmul self| 7.3\u00b10.05ns| 7.0\u00b10.06ns  \ntransform point3| 3.6\u00b10.02ns| 4.3\u00b10.04ns  \ntransform point3a| 3.0\u00b10.02ns| 3.0\u00b10.04ns  \ntransform vector3| 4.1\u00b10.02ns| 3.9\u00b10.04ns  \ntransform vector3a| 2.8\u00b10.02ns| 2.8\u00b10.02ns  \nBenchmarks were taken on an Intel Core i7-4710HQ.\n### [\u00a7](https://docs.rs/glam/latest/glam/#linear-algebra-conventions)Linear algebra conventions\n`glam` interprets vectors as column matrices (also known as column vectors) meaning when transforming a vector with a matrix the matrix goes on the left.\n```\nuse glam::{Mat3, Vec3};\nlet m = Mat3::IDENTITY;\nlet x = Vec3::X;\nlet v = m * x;\nassert_eq!(v, x);\n```\n\nMatrices are stored in memory in column-major order.\nAll angles are in radians. Rust provides the `f32::to_radians()` and `f64::to_radians()` methods to convert from degrees.\n### [\u00a7](https://docs.rs/glam/latest/glam/#direct-element-access)Direct element access\nBecause some types may internally be implemented using SIMD types, direct access to vector elements is supported by implementing the [`Deref`](https://doc.rust-lang.org/std/ops/trait.Deref.html) and [`DerefMut`](https://doc.rust-lang.org/std/ops/trait.DerefMut.html) traits.\n```\nuse glam::Vec3A;\nlet mut v = Vec3A::new(1.0, 2.0, 3.0);\nassert_eq!(3.0, v.z);\nv.z += 1.0;\nassert_eq!(4.0, v.z);\n```\n\n### [\u00a7](https://docs.rs/glam/latest/glam/#glam-assertions)glam assertions\n`glam` does not enforce validity checks on method parameters at runtime. For example methods that require normalized vectors as input such as `Quat::from_axis_angle(axis, angle)` will not check that axis is a valid normalized vector. To help catch unintended misuse of `glam` the `debug-glam-assert` or `glam-assert` features can be enabled to add checks ensure that inputs to are valid.\n### [\u00a7](https://docs.rs/glam/latest/glam/#vector-swizzles)Vector swizzles\n`glam` vector types have functions allowing elements of vectors to be reordered, this includes creating a vector of a different size from the vectors elements.\nThe swizzle functions are implemented using traits to add them to each vector type. This is primarily because there are a lot of swizzle functions which can obfuscate the other vector functions in documentation and so on. The traits are [`Vec2Swizzles`](https://docs.rs/glam/latest/glam/swizzles/trait.Vec2Swizzles.html \"trait glam::swizzles::Vec2Swizzles\"), [`Vec3Swizzles`](https://docs.rs/glam/latest/glam/swizzles/trait.Vec3Swizzles.html \"trait glam::swizzles::Vec3Swizzles\") and [`Vec4Swizzles`](https://docs.rs/glam/latest/glam/swizzles/trait.Vec4Swizzles.html \"trait glam::swizzles::Vec4Swizzles\").\nNote that the [`Vec3Swizzles`](https://docs.rs/glam/latest/glam/swizzles/trait.Vec3Swizzles.html \"trait glam::swizzles::Vec3Swizzles\") implementation for [`Vec3A`](https://docs.rs/glam/latest/glam/f32/struct.Vec3A.html \"struct glam::f32::Vec3A\") will return a [`Vec3A`](https://docs.rs/glam/latest/glam/f32/struct.Vec3A.html \"struct glam::f32::Vec3A\") for 3 element swizzles, all other implementations will return [`Vec3`](https://docs.rs/glam/latest/glam/f32/struct.Vec3.html \"struct glam::f32::Vec3\").\n```\nuse glam::{swizzles::*, Vec2, Vec3, Vec3A, Vec4};\nlet v = Vec4::new(1.0, 2.0, 3.0, 4.0);\n// Reverse elements of `v`, if SIMD is supported this will use a vector shuffle.\nlet wzyx = v.wzyx();\nassert_eq!(Vec4::new(4.0, 3.0, 2.0, 1.0), wzyx);\n// Swizzle the yzw elements of `v` into a `Vec3`\nlet yzw = v.yzw();\nassert_eq!(Vec3::new(2.0, 3.0, 4.0), yzw);\n// To swizzle a `Vec4` into a `Vec3A` swizzle the `Vec4` first then convert to\n// `Vec3A`. If SIMD is supported this will use a vector shuffle. The last\n// element of the shuffled `Vec4` is ignored by the `Vec3A`.\nlet yzw = Vec3A::from_vec4(v.yzwx());\nassert_eq!(Vec3A::new(2.0, 3.0, 4.0), yzw);\n// You can swizzle from a `Vec4` to a `Vec2`\nlet xy = v.xy();\nassert_eq!(Vec2::new(1.0, 2.0), xy);\n// And back again\nlet yyxx = xy.yyxx();\nassert_eq!(Vec4::new(2.0, 2.0, 1.0, 1.0), yyxx);\n```\n\n### [\u00a7](https://docs.rs/glam/latest/glam/#simd-and-scalar-consistency)SIMD and scalar consistency\n`glam` types implement `serde` `Serialize` and `Deserialize` traits to ensure that they will serialize and deserialize exactly the same whether or not SIMD support is being used.\nThe SIMD versions implement the `core::fmt::Debug` and `core::fmt::Display` traits so they print the same as the scalar version.\n```\nuse glam::Vec4;\nlet a = Vec4::new(1.0, 2.0, 3.0, 4.0);\nassert_eq!(format!(\"{}\", a), \"[1, 2, 3, 4]\");\n```\n\n### [\u00a7](https://docs.rs/glam/latest/glam/#feature-gates)Feature gates\nAll `glam` dependencies are optional, however some are required for tests and benchmarks.\n  * `std` - the default feature, has no dependencies.\n  * `approx` - traits and macros for approximate float comparisons\n  * `bytemuck` - for casting into slices of bytes\n  * `libm` - uses `libm` math functions instead of `std`\n  * `nostd-libm` - uses `libm` math functions if `std` is not available\n  * `mint` - for interoperating with other 3D math libraries\n  * `rand` - implementations of `Distribution` trait for all `glam` types.\n  * `rkyv` - implementations of `Archive`, `Serialize` and `Deserialize` for all `glam` types. Note that serialization is not interoperable with and without the `scalar-math` feature. It should work between all other builds of `glam`. Endian conversion is currently not supported\n  * `bytecheck` - to perform archive validation when using the `rkyv` feature\n  * `serde` - implementations of `Serialize` and `Deserialize` for all `glam` types. Note that serialization should work between builds of `glam` with and without SIMD enabled\n  * `speedy` - implementations of `speedy`\u2019s `Readable` and `Writable` for all `glam` types.\n  * `scalar-math` - disables SIMD support and uses native alignment for all types.\n  * `debug-glam-assert` - adds assertions in debug builds which check the validity of parameters passed to `glam` to help catch runtime errors.\n  * `glam-assert` - adds assertions to all builds which check the validity of parameters passed to `glam` to help catch runtime errors.\n  * `cuda` - forces `glam` types to match expected cuda alignment\n  * `fast-math` - By default, glam attempts to provide bit-for-bit identical results on all platforms. Using this feature will enable platform specific optimizations that may not be identical to other platforms. **Intermediate libraries should not use this feature and defer the decision to the final binary build**.\n  * `core-simd` - enables SIMD support via the portable simd module. This is an unstable feature which requires a nightly Rust toolchain and `std` support.\n\n\n### [\u00a7](https://docs.rs/glam/latest/glam/#minimum-supported-rust-version-msrv)Minimum Supported Rust Version (MSRV)\nThe minimum supported Rust version is `1.68.2`.\n## Re-exports[\u00a7](https://docs.rs/glam/latest/glam/#reexports)\n\n`pub use self::swizzles::Vec2Swizzles[](https://docs.rs/glam/latest/glam/swizzles/trait.Vec2Swizzles.html \"trait glam::swizzles::Vec2Swizzles\");`\n\n\n`pub use self::swizzles::Vec3Swizzles[](https://docs.rs/glam/latest/glam/swizzles/trait.Vec3Swizzles.html \"trait glam::swizzles::Vec3Swizzles\");`\n\n\n`pub use self::swizzles::Vec4Swizzles[](https://docs.rs/glam/latest/glam/swizzles/trait.Vec4Swizzles.html \"trait glam::swizzles::Vec4Swizzles\");`\n\n\n`pub use self::bool[](https://docs.rs/glam/latest/glam/bool/index.html \"mod glam::bool\")::*;`\n\n\n`pub use self::f32[](https://docs.rs/glam/latest/glam/f32/index.html \"mod glam::f32\")::*;`\n\n\n`pub use self::f64[](https://docs.rs/glam/latest/glam/f64/index.html \"mod glam::f64\")::*;`\n\n\n`pub use self::i8[](https://docs.rs/glam/latest/glam/i8/index.html \"mod glam::i8\")::*;`\n\n\n`pub use self::u8[](https://docs.rs/glam/latest/glam/u8/index.html \"mod glam::u8\")::*;`\n\n\n`pub use self::i16[](https://docs.rs/glam/latest/glam/i16/index.html \"mod glam::i16\")::*;`\n\n\n`pub use self::u16[](https://docs.rs/glam/latest/glam/u16/index.html \"mod glam::u16\")::*;`\n\n\n`pub use self::i32[](https://docs.rs/glam/latest/glam/i32/index.html \"mod glam::i32\")::*;`\n\n\n`pub use self::u32[](https://docs.rs/glam/latest/glam/u32/index.html \"mod glam::u32\")::*;`\n\n\n`pub use self::i64[](https://docs.rs/glam/latest/glam/i64/index.html \"mod glam::i64\")::*;`\n\n\n`pub use self::u64[](https://docs.rs/glam/latest/glam/u64/index.html \"mod glam::u64\")::*;`\n\n\n`pub use self::usize[](https://docs.rs/glam/latest/glam/usize/index.html \"mod glam::usize\")::*;`\n\n## Modules[\u00a7](https://docs.rs/glam/latest/glam/#modules)\n\n[bool](https://docs.rs/glam/latest/glam/bool/index.html \"mod glam::bool\")\n    `bool` vector mask types.\n\n[f32](https://docs.rs/glam/latest/glam/f32/index.html \"mod glam::f32\")\n    `f32` vector, quaternion and matrix types.\n\n[f64](https://docs.rs/glam/latest/glam/f64/index.html \"mod glam::f64\")\n    `f64` vector, quaternion and matrix types.\n\n[i8](https://docs.rs/glam/latest/glam/i8/index.html \"mod glam::i8\")\n    `i8` vector types.\n\n[i16](https://docs.rs/glam/latest/glam/i16/index.html \"mod glam::i16\")\n    `i16` vector types.\n\n[i32](https://docs.rs/glam/latest/glam/i32/index.html \"mod glam::i32\")\n    `i32` vector types.\n\n[i64](https://docs.rs/glam/latest/glam/i64/index.html \"mod glam::i64\")\n    `i64` vector types.\n\n[swizzles](https://docs.rs/glam/latest/glam/swizzles/index.html \"mod glam::swizzles\")\n    Traits adding swizzle methods to all vector types.\n\n[u8](https://docs.rs/glam/latest/glam/u8/index.html \"mod glam::u8\")\n    `u8` vector types.\n\n[u16](https://docs.rs/glam/latest/glam/u16/index.html \"mod glam::u16\")\n    `u16` vector types.\n\n[u32](https://docs.rs/glam/latest/glam/u32/index.html \"mod glam::u32\")\n    `u32` vector types.\n\n[u64](https://docs.rs/glam/latest/glam/u64/index.html \"mod glam::u64\")\n    `u64` vector types.\n\n[usize](https://docs.rs/glam/latest/glam/usize/index.html \"mod glam::usize\")\n    `usize` vector types.\n## Enums[\u00a7](https://docs.rs/glam/latest/glam/#enums)\n\n[EulerRot](https://docs.rs/glam/latest/glam/enum.EulerRot.html \"enum glam::EulerRot\")\n    Rotation Helper Euler rotation sequences.\n## Traits[\u00a7](https://docs.rs/glam/latest/glam/#traits)\n\n[FloatExt](https://docs.rs/glam/latest/glam/trait.FloatExt.html \"trait glam::FloatExt\")\n    A trait for extending [`f32`](https://doc.rust-lang.org/nightly/std/primitive.f32.html \"primitive f32\") and [`f64`](https://doc.rust-lang.org/nightly/std/primitive.f64.html \"primitive f64\") with extra methods.\n",
            "markdown_with_citations": "[](https://docs.rs/glam/latest/glam/all.html \"show sidebar\")\n# Crate glamCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\n## \u00a7\u27e84\u27e9glam\n`glam` is a simple and fast linear algebra library for games and graphics.\n### \u00a7\u27e85\u27e9Features\n  * `f32`\u27e86\u27e9 types \n    * vectors: `Vec2`\u27e87\u27e9, `Vec3`\u27e88\u27e9, `Vec3A`\u27e89\u27e9 and `Vec4`\u27e810\u27e9\n    * square matrices: `Mat2`\u27e811\u27e9, `Mat3`\u27e812\u27e9, `Mat3A`\u27e813\u27e9 and `Mat4`\u27e814\u27e9\n    * a quaternion type: `Quat`\u27e815\u27e9\n    * affine transformation types: `Affine2`\u27e816\u27e9 and `Affine3A`\u27e817\u27e9\n  * `f64`\u27e818\u27e9 types \n    * vectors: `DVec2`\u27e819\u27e9, `DVec3`\u27e820\u27e9 and `DVec4`\u27e821\u27e9\n    * square matrices: `DMat2`\u27e822\u27e9, `DMat3`\u27e823\u27e9 and `DMat4`\u27e824\u27e9\n    * a quaternion type: `DQuat`\u27e825\u27e9\n    * affine transformation types: `DAffine2`\u27e826\u27e9 and `DAffine3`\u27e827\u27e9\n  * `i8`\u27e828\u27e9 types \n    * vectors: `I8Vec2`\u27e829\u27e9, `I8Vec3`\u27e830\u27e9 and `I8Vec4`\u27e831\u27e9\n  * `u8`\u27e832\u27e9 types \n    * vectors: `U8Vec2`\u27e833\u27e9, `U8Vec3`\u27e834\u27e9 and `U8Vec4`\u27e835\u27e9\n  * `i16`\u27e836\u27e9 types \n    * vectors: `I16Vec2`\u27e837\u27e9, `I16Vec3`\u27e838\u27e9 and `I16Vec4`\u27e839\u27e9\n  * `u16`\u27e840\u27e9 types \n    * vectors: `U16Vec2`\u27e841\u27e9, `U16Vec3`\u27e842\u27e9 and `U16Vec4`\u27e843\u27e9\n  * `i32`\u27e844\u27e9 types \n    * vectors: `IVec2`\u27e845\u27e9, `IVec3`\u27e846\u27e9 and `IVec4`\u27e847\u27e9\n  * `u32`\u27e848\u27e9 types \n    * vectors: `UVec2`\u27e849\u27e9, `UVec3`\u27e850\u27e9 and `UVec4`\u27e851\u27e9\n  * `i64`\u27e852\u27e9 types \n    * vectors: `I64Vec2`\u27e853\u27e9, `I64Vec3`\u27e854\u27e9 and `I64Vec4`\u27e855\u27e9\n  * `u64`\u27e856\u27e9 types \n    * vectors: `U64Vec2`\u27e857\u27e9, `U64Vec3`\u27e858\u27e9 and `U64Vec4`\u27e859\u27e9\n  * `usize`\u27e860\u27e9 types \n    * vectors: `USizeVec2`\u27e861\u27e9, `USizeVec3`\u27e862\u27e9 and `USizeVec4`\u27e863\u27e9\n  * `bool`\u27e864\u27e9 types \n    * vectors: `BVec2`\u27e865\u27e9, `BVec3`\u27e866\u27e9 and `BVec4`\u27e867\u27e9\n\n\n### \u00a7\u27e868\u27e9SIMD\n`glam` is built with SIMD in mind. Many `f32` types use 128-bit SIMD vector types for storage and/or implementation. The use of SIMD generally enables better performance than using primitive numeric types such as `f32`.\nSome `glam` types use SIMD for storage meaning they are 16 byte aligned, these types include `Mat2`, `Mat3A`, `Mat4`, `Quat`, `Vec3A`, `Vec4`, `Affine2` an `Affine3A`. Types with an `A` suffix are a SIMD alternative to a scalar type, e.g. `Vec3` uses `f32` storage and `Vec3A` uses SIMD storage.\nWhen SIMD is not available on the target the types will maintain 16 byte alignment and internal padding so that object sizes and layouts will not change between architectures. There are scalar math fallback implementations exist when SIMD is not available. It is intended to add support for other SIMD architectures once they appear in stable Rust.\nCurrently only SSE2 on x86/x86_64, NEON on Aarch64, and simd128 on WASM are supported.\n### \u00a7\u27e869\u27e9Vec3A and Mat3A\n`Vec3A` is a SIMD optimized version of the `Vec3` type, which due to 16 byte alignment results in `Vec3A` containing 4 bytes of padding making it 16 bytes in size in total. `Mat3A` is composed of three `Vec3A` columns.\nType| `f32` bytes| Align bytes| Size bytes| Padding  \n---|---|---|---|---  \n`Vec3`\u27e88\u27e9| 12| 4| 12| 0  \n`Vec3A`\u27e89\u27e9| 12| 16| 16| 4  \n`Mat3`\u27e812\u27e9| 36| 4| 36| 0  \n`Mat3A`\u27e813\u27e9| 36| 16| 48| 12  \nDespite this wasted space the SIMD implementations tend to outperform `f32` implementations in **mathbench**\u27e870\u27e9 benchmarks.\n`glam` treats `Vec3`\u27e88\u27e9 as the default 3D vector type and `Vec3A`\u27e89\u27e9 a special case for optimization. When methods need to return a 3D vector they will generally return `Vec3`\u27e88\u27e9.\nThere are `From`\u27e871\u27e9 trait implementations for converting from `Vec4`\u27e810\u27e9 to a `Vec3A`\u27e89\u27e9 and between `Vec3`\u27e88\u27e9 and `Vec3A`\u27e89\u27e9 (and vice versa).\n```\nuse glam::{Vec3, Vec3A, Vec4};\nlet v4 = Vec4::new(1.0, 2.0, 3.0, 4.0);\n// Convert from `Vec4` to `Vec3A`, this is a no-op if SIMD is supported.\n// We use an explicit method here instead of a From impl as data is lost in the conversion.\nlet v3a = Vec3A::from_vec4(v4);\nassert_eq!(Vec3A::new(1.0, 2.0, 3.0), v3a);\n// Convert from `Vec3A` to `Vec3`.\nlet v3 = Vec3::from(v3a);\nassert_eq!(Vec3::new(1.0, 2.0, 3.0), v3);\n// Convert from `Vec3` to `Vec3A`.\nlet v3a = Vec3A::from(v3);\nassert_eq!(Vec3A::new(1.0, 2.0, 3.0), v3a);\n```\n\n### \u00a7\u27e872\u27e9Affine2 and Affine3A\n`Affine2` and `Affine3A` are composed of a linear transform matrix and a vector translation. The represent 2D and 3D affine transformations which are commonly used in games.\nThe table below shows the performance advantage of `Affine2` over `Mat3A` and `Mat3A` over `Mat3`.\noperation| `Mat3`| `Mat3A`| `Affine2`  \n---|---|---|---  \ninverse| 11.4\u00b10.09ns| 7.1\u00b10.09ns| 5.4\u00b10.06ns  \nmul self| 10.5\u00b10.04ns| 5.2\u00b10.05ns| 4.0\u00b10.05ns  \ntransform point2| 2.7\u00b10.02ns| 2.7\u00b10.03ns| 2.8\u00b10.04ns  \ntransform vector2| 2.6\u00b10.01ns| 2.6\u00b10.03ns| 2.3\u00b10.02ns  \nPerformance is much closer between `Mat4` and `Affine3A` with the affine type being faster to invert.\noperation| `Mat4`| `Affine3A`  \n---|---|---  \ninverse| 15.9\u00b10.11ns| 10.8\u00b10.06ns  \nmul self| 7.3\u00b10.05ns| 7.0\u00b10.06ns  \ntransform point3| 3.6\u00b10.02ns| 4.3\u00b10.04ns  \ntransform point3a| 3.0\u00b10.02ns| 3.0\u00b10.04ns  \ntransform vector3| 4.1\u00b10.02ns| 3.9\u00b10.04ns  \ntransform vector3a| 2.8\u00b10.02ns| 2.8\u00b10.02ns  \nBenchmarks were taken on an Intel Core i7-4710HQ.\n### \u00a7\u27e873\u27e9Linear algebra conventions\n`glam` interprets vectors as column matrices (also known as column vectors) meaning when transforming a vector with a matrix the matrix goes on the left.\n```\nuse glam::{Mat3, Vec3};\nlet m = Mat3::IDENTITY;\nlet x = Vec3::X;\nlet v = m * x;\nassert_eq!(v, x);\n```\n\nMatrices are stored in memory in column-major order.\nAll angles are in radians. Rust provides the `f32::to_radians()` and `f64::to_radians()` methods to convert from degrees.\n### \u00a7\u27e874\u27e9Direct element access\nBecause some types may internally be implemented using SIMD types, direct access to vector elements is supported by implementing the `Deref`\u27e875\u27e9 and `DerefMut`\u27e876\u27e9 traits.\n```\nuse glam::Vec3A;\nlet mut v = Vec3A::new(1.0, 2.0, 3.0);\nassert_eq!(3.0, v.z);\nv.z += 1.0;\nassert_eq!(4.0, v.z);\n```\n\n### \u00a7\u27e877\u27e9glam assertions\n`glam` does not enforce validity checks on method parameters at runtime. For example methods that require normalized vectors as input such as `Quat::from_axis_angle(axis, angle)` will not check that axis is a valid normalized vector. To help catch unintended misuse of `glam` the `debug-glam-assert` or `glam-assert` features can be enabled to add checks ensure that inputs to are valid.\n### \u00a7\u27e878\u27e9Vector swizzles\n`glam` vector types have functions allowing elements of vectors to be reordered, this includes creating a vector of a different size from the vectors elements.\nThe swizzle functions are implemented using traits to add them to each vector type. This is primarily because there are a lot of swizzle functions which can obfuscate the other vector functions in documentation and so on. The traits are `Vec2Swizzles`\u27e879\u27e9, `Vec3Swizzles`\u27e880\u27e9 and `Vec4Swizzles`\u27e881\u27e9.\nNote that the `Vec3Swizzles`\u27e880\u27e9 implementation for `Vec3A`\u27e89\u27e9 will return a `Vec3A`\u27e89\u27e9 for 3 element swizzles, all other implementations will return `Vec3`\u27e88\u27e9.\n```\nuse glam::{swizzles::*, Vec2, Vec3, Vec3A, Vec4};\nlet v = Vec4::new(1.0, 2.0, 3.0, 4.0);\n// Reverse elements of `v`, if SIMD is supported this will use a vector shuffle.\nlet wzyx = v.wzyx();\nassert_eq!(Vec4::new(4.0, 3.0, 2.0, 1.0), wzyx);\n// Swizzle the yzw elements of `v` into a `Vec3`\nlet yzw = v.yzw();\nassert_eq!(Vec3::new(2.0, 3.0, 4.0), yzw);\n// To swizzle a `Vec4` into a `Vec3A` swizzle the `Vec4` first then convert to\n// `Vec3A`. If SIMD is supported this will use a vector shuffle. The last\n// element of the shuffled `Vec4` is ignored by the `Vec3A`.\nlet yzw = Vec3A::from_vec4(v.yzwx());\nassert_eq!(Vec3A::new(2.0, 3.0, 4.0), yzw);\n// You can swizzle from a `Vec4` to a `Vec2`\nlet xy = v.xy();\nassert_eq!(Vec2::new(1.0, 2.0), xy);\n// And back again\nlet yyxx = xy.yyxx();\nassert_eq!(Vec4::new(2.0, 2.0, 1.0, 1.0), yyxx);\n```\n\n### \u00a7\u27e882\u27e9SIMD and scalar consistency\n`glam` types implement `serde` `Serialize` and `Deserialize` traits to ensure that they will serialize and deserialize exactly the same whether or not SIMD support is being used.\nThe SIMD versions implement the `core::fmt::Debug` and `core::fmt::Display` traits so they print the same as the scalar version.\n```\nuse glam::Vec4;\nlet a = Vec4::new(1.0, 2.0, 3.0, 4.0);\nassert_eq!(format!(\"{}\", a), \"[1, 2, 3, 4]\");\n```\n\n### \u00a7\u27e883\u27e9Feature gates\nAll `glam` dependencies are optional, however some are required for tests and benchmarks.\n  * `std` - the default feature, has no dependencies.\n  * `approx` - traits and macros for approximate float comparisons\n  * `bytemuck` - for casting into slices of bytes\n  * `libm` - uses `libm` math functions instead of `std`\n  * `nostd-libm` - uses `libm` math functions if `std` is not available\n  * `mint` - for interoperating with other 3D math libraries\n  * `rand` - implementations of `Distribution` trait for all `glam` types.\n  * `rkyv` - implementations of `Archive`, `Serialize` and `Deserialize` for all `glam` types. Note that serialization is not interoperable with and without the `scalar-math` feature. It should work between all other builds of `glam`. Endian conversion is currently not supported\n  * `bytecheck` - to perform archive validation when using the `rkyv` feature\n  * `serde` - implementations of `Serialize` and `Deserialize` for all `glam` types. Note that serialization should work between builds of `glam` with and without SIMD enabled\n  * `speedy` - implementations of `speedy`\u2019s `Readable` and `Writable` for all `glam` types.\n  * `scalar-math` - disables SIMD support and uses native alignment for all types.\n  * `debug-glam-assert` - adds assertions in debug builds which check the validity of parameters passed to `glam` to help catch runtime errors.\n  * `glam-assert` - adds assertions to all builds which check the validity of parameters passed to `glam` to help catch runtime errors.\n  * `cuda` - forces `glam` types to match expected cuda alignment\n  * `fast-math` - By default, glam attempts to provide bit-for-bit identical results on all platforms. Using this feature will enable platform specific optimizations that may not be identical to other platforms. **Intermediate libraries should not use this feature and defer the decision to the final binary build**.\n  * `core-simd` - enables SIMD support via the portable simd module. This is an unstable feature which requires a nightly Rust toolchain and `std` support.\n\n\n### \u00a7\u27e884\u27e9Minimum Supported Rust Version (MSRV)\nThe minimum supported Rust version is `1.68.2`.\n## Re-exports\u00a7\u27e885\u27e9\n\n`pub use self::swizzles::Vec2Swizzles[](https://docs.rs/glam/latest/glam/swizzles/trait.Vec2Swizzles.html \"trait glam::swizzles::Vec2Swizzles\");`\n\n\n`pub use self::swizzles::Vec3Swizzles[](https://docs.rs/glam/latest/glam/swizzles/trait.Vec3Swizzles.html \"trait glam::swizzles::Vec3Swizzles\");`\n\n\n`pub use self::swizzles::Vec4Swizzles[](https://docs.rs/glam/latest/glam/swizzles/trait.Vec4Swizzles.html \"trait glam::swizzles::Vec4Swizzles\");`\n\n\n`pub use self::bool[](https://docs.rs/glam/latest/glam/bool/index.html \"mod glam::bool\")::*;`\n\n\n`pub use self::f32[](https://docs.rs/glam/latest/glam/f32/index.html \"mod glam::f32\")::*;`\n\n\n`pub use self::f64[](https://docs.rs/glam/latest/glam/f64/index.html \"mod glam::f64\")::*;`\n\n\n`pub use self::i8[](https://docs.rs/glam/latest/glam/i8/index.html \"mod glam::i8\")::*;`\n\n\n`pub use self::u8[](https://docs.rs/glam/latest/glam/u8/index.html \"mod glam::u8\")::*;`\n\n\n`pub use self::i16[](https://docs.rs/glam/latest/glam/i16/index.html \"mod glam::i16\")::*;`\n\n\n`pub use self::u16[](https://docs.rs/glam/latest/glam/u16/index.html \"mod glam::u16\")::*;`\n\n\n`pub use self::i32[](https://docs.rs/glam/latest/glam/i32/index.html \"mod glam::i32\")::*;`\n\n\n`pub use self::u32[](https://docs.rs/glam/latest/glam/u32/index.html \"mod glam::u32\")::*;`\n\n\n`pub use self::i64[](https://docs.rs/glam/latest/glam/i64/index.html \"mod glam::i64\")::*;`\n\n\n`pub use self::u64[](https://docs.rs/glam/latest/glam/u64/index.html \"mod glam::u64\")::*;`\n\n\n`pub use self::usize[](https://docs.rs/glam/latest/glam/usize/index.html \"mod glam::usize\")::*;`\n\n## Modules\u00a7\u27e886\u27e9\n\nbool\u27e864\u27e9\n    `bool` vector mask types.\n\nf32\u27e86\u27e9\n    `f32` vector, quaternion and matrix types.\n\nf64\u27e818\u27e9\n    `f64` vector, quaternion and matrix types.\n\ni8\u27e828\u27e9\n    `i8` vector types.\n\ni16\u27e836\u27e9\n    `i16` vector types.\n\ni32\u27e844\u27e9\n    `i32` vector types.\n\ni64\u27e852\u27e9\n    `i64` vector types.\n\nswizzles\u27e887\u27e9\n    Traits adding swizzle methods to all vector types.\n\nu8\u27e832\u27e9\n    `u8` vector types.\n\nu16\u27e840\u27e9\n    `u16` vector types.\n\nu32\u27e848\u27e9\n    `u32` vector types.\n\nu64\u27e856\u27e9\n    `u64` vector types.\n\nusize\u27e860\u27e9\n    `usize` vector types.\n## Enums\u00a7\u27e888\u27e9\n\nEulerRot\u27e889\u27e9\n    Rotation Helper Euler rotation sequences.\n## Traits\u00a7\u27e890\u27e9\n\nFloatExt\u27e891\u27e9\n    A trait for extending `f32`\u27e892\u27e9 and `f64`\u27e893\u27e9 with extra methods.\n",
            "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/glam/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/glam/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/glam/latest/src/glam/lib.rs.html#1-383: Source\n\u27e84\u27e9 https://docs.rs/glam/latest/glam/#glam: \u00a7\n\u27e85\u27e9 https://docs.rs/glam/latest/glam/#features: \u00a7\n\u27e86\u27e9 https://docs.rs/glam/latest/glam/f32/index.html: mod glam::f32 - `f32`\n\u27e87\u27e9 https://docs.rs/glam/latest/glam/f32/struct.Vec2.html: struct glam::f32::Vec2 - `Vec2`\n\u27e88\u27e9 https://docs.rs/glam/latest/glam/f32/struct.Vec3.html: struct glam::f32::Vec3 - `Vec3`\n\u27e89\u27e9 https://docs.rs/glam/latest/glam/f32/struct.Vec3A.html: struct glam::f32::Vec3A - `Vec3A`\n\u27e810\u27e9 https://docs.rs/glam/latest/glam/f32/struct.Vec4.html: struct glam::f32::Vec4 - `Vec4`\n\u27e811\u27e9 https://docs.rs/glam/latest/glam/f32/struct.Mat2.html: struct glam::f32::Mat2 - `Mat2`\n\u27e812\u27e9 https://docs.rs/glam/latest/glam/f32/struct.Mat3.html: struct glam::f32::Mat3 - `Mat3`\n\u27e813\u27e9 https://docs.rs/glam/latest/glam/f32/struct.Mat3A.html: struct glam::f32::Mat3A - `Mat3A`\n\u27e814\u27e9 https://docs.rs/glam/latest/glam/f32/struct.Mat4.html: struct glam::f32::Mat4 - `Mat4`\n\u27e815\u27e9 https://docs.rs/glam/latest/glam/f32/struct.Quat.html: struct glam::f32::Quat - `Quat`\n\u27e816\u27e9 https://docs.rs/glam/latest/glam/f32/struct.Affine2.html: struct glam::f32::Affine2 - `Affine2`\n\u27e817\u27e9 https://docs.rs/glam/latest/glam/f32/struct.Affine3A.html: struct glam::f32::Affine3A - `Affine3A`\n\u27e818\u27e9 https://docs.rs/glam/latest/glam/f64/index.html: mod glam::f64 - `f64`\n\u27e819\u27e9 https://docs.rs/glam/latest/glam/f64/struct.DVec2.html: struct glam::f64::DVec2 - `DVec2`\n\u27e820\u27e9 https://docs.rs/glam/latest/glam/f64/struct.DVec3.html: struct glam::f64::DVec3 - `DVec3`\n\u27e821\u27e9 https://docs.rs/glam/latest/glam/f64/struct.DVec4.html: struct glam::f64::DVec4 - `DVec4`\n\u27e822\u27e9 https://docs.rs/glam/latest/glam/f64/struct.DMat2.html: struct glam::f64::DMat2 - `DMat2`\n\u27e823\u27e9 https://docs.rs/glam/latest/glam/f64/struct.DMat3.html: struct glam::f64::DMat3 - `DMat3`\n\u27e824\u27e9 https://docs.rs/glam/latest/glam/f64/struct.DMat4.html: struct glam::f64::DMat4 - `DMat4`\n\u27e825\u27e9 https://docs.rs/glam/latest/glam/f64/struct.DQuat.html: struct glam::f64::DQuat - `DQuat`\n\u27e826\u27e9 https://docs.rs/glam/latest/glam/f64/struct.DAffine2.html: struct glam::f64::DAffine2 - `DAffine2`\n\u27e827\u27e9 https://docs.rs/glam/latest/glam/f64/struct.DAffine3.html: struct glam::f64::DAffine3 - `DAffine3`\n\u27e828\u27e9 https://docs.rs/glam/latest/glam/i8/index.html: mod glam::i8 - `i8`\n\u27e829\u27e9 https://docs.rs/glam/latest/glam/i8/struct.I8Vec2.html: struct glam::i8::I8Vec2 - `I8Vec2`\n\u27e830\u27e9 https://docs.rs/glam/latest/glam/i8/struct.I8Vec3.html: struct glam::i8::I8Vec3 - `I8Vec3`\n\u27e831\u27e9 https://docs.rs/glam/latest/glam/i8/struct.I8Vec4.html: struct glam::i8::I8Vec4 - `I8Vec4`\n\u27e832\u27e9 https://docs.rs/glam/latest/glam/u8/index.html: mod glam::u8 - `u8`\n\u27e833\u27e9 https://docs.rs/glam/latest/glam/u8/struct.U8Vec2.html: struct glam::u8::U8Vec2 - `U8Vec2`\n\u27e834\u27e9 https://docs.rs/glam/latest/glam/u8/struct.U8Vec3.html: struct glam::u8::U8Vec3 - `U8Vec3`\n\u27e835\u27e9 https://docs.rs/glam/latest/glam/u8/struct.U8Vec4.html: struct glam::u8::U8Vec4 - `U8Vec4`\n\u27e836\u27e9 https://docs.rs/glam/latest/glam/i16/index.html: mod glam::i16 - `i16`\n\u27e837\u27e9 https://docs.rs/glam/latest/glam/i16/struct.I16Vec2.html: struct glam::i16::I16Vec2 - `I16Vec2`\n\u27e838\u27e9 https://docs.rs/glam/latest/glam/i16/struct.I16Vec3.html: struct glam::i16::I16Vec3 - `I16Vec3`\n\u27e839\u27e9 https://docs.rs/glam/latest/glam/i16/struct.I16Vec4.html: struct glam::i16::I16Vec4 - `I16Vec4`\n\u27e840\u27e9 https://docs.rs/glam/latest/glam/u16/index.html: mod glam::u16 - `u16`\n\u27e841\u27e9 https://docs.rs/glam/latest/glam/u16/struct.U16Vec2.html: struct glam::u16::U16Vec2 - `U16Vec2`\n\u27e842\u27e9 https://docs.rs/glam/latest/glam/u16/struct.U16Vec3.html: struct glam::u16::U16Vec3 - `U16Vec3`\n\u27e843\u27e9 https://docs.rs/glam/latest/glam/u16/struct.U16Vec4.html: struct glam::u16::U16Vec4 - `U16Vec4`\n\u27e844\u27e9 https://docs.rs/glam/latest/glam/i32/index.html: mod glam::i32 - `i32`\n\u27e845\u27e9 https://docs.rs/glam/latest/glam/i32/struct.IVec2.html: struct glam::i32::IVec2 - `IVec2`\n\u27e846\u27e9 https://docs.rs/glam/latest/glam/i32/struct.IVec3.html: struct glam::i32::IVec3 - `IVec3`\n\u27e847\u27e9 https://docs.rs/glam/latest/glam/i32/struct.IVec4.html: struct glam::i32::IVec4 - `IVec4`\n\u27e848\u27e9 https://docs.rs/glam/latest/glam/u32/index.html: mod glam::u32 - `u32`\n\u27e849\u27e9 https://docs.rs/glam/latest/glam/u32/struct.UVec2.html: struct glam::u32::UVec2 - `UVec2`\n\u27e850\u27e9 https://docs.rs/glam/latest/glam/u32/struct.UVec3.html: struct glam::u32::UVec3 - `UVec3`\n\u27e851\u27e9 https://docs.rs/glam/latest/glam/u32/struct.UVec4.html: struct glam::u32::UVec4 - `UVec4`\n\u27e852\u27e9 https://docs.rs/glam/latest/glam/i64/index.html: mod glam::i64 - `i64`\n\u27e853\u27e9 https://docs.rs/glam/latest/glam/i64/struct.I64Vec2.html: struct glam::i64::I64Vec2 - `I64Vec2`\n\u27e854\u27e9 https://docs.rs/glam/latest/glam/i64/struct.I64Vec3.html: struct glam::i64::I64Vec3 - `I64Vec3`\n\u27e855\u27e9 https://docs.rs/glam/latest/glam/i64/struct.I64Vec4.html: struct glam::i64::I64Vec4 - `I64Vec4`\n\u27e856\u27e9 https://docs.rs/glam/latest/glam/u64/index.html: mod glam::u64 - `u64`\n\u27e857\u27e9 https://docs.rs/glam/latest/glam/u64/struct.U64Vec2.html: struct glam::u64::U64Vec2 - `U64Vec2`\n\u27e858\u27e9 https://docs.rs/glam/latest/glam/u64/struct.U64Vec3.html: struct glam::u64::U64Vec3 - `U64Vec3`\n\u27e859\u27e9 https://docs.rs/glam/latest/glam/u64/struct.U64Vec4.html: struct glam::u64::U64Vec4 - `U64Vec4`\n\u27e860\u27e9 https://docs.rs/glam/latest/glam/usize/index.html: mod glam::usize - `usize`\n\u27e861\u27e9 https://docs.rs/glam/latest/glam/usize/struct.USizeVec2.html: struct glam::usize::USizeVec2 - `USizeVec2`\n\u27e862\u27e9 https://docs.rs/glam/latest/glam/usize/struct.USizeVec3.html: struct glam::usize::USizeVec3 - `USizeVec3`\n\u27e863\u27e9 https://docs.rs/glam/latest/glam/usize/struct.USizeVec4.html: struct glam::usize::USizeVec4 - `USizeVec4`\n\u27e864\u27e9 https://docs.rs/glam/latest/glam/bool/index.html: mod glam::bool - `bool`\n\u27e865\u27e9 https://docs.rs/glam/latest/glam/bool/struct.BVec2.html: struct glam::bool::BVec2 - `BVec2`\n\u27e866\u27e9 https://docs.rs/glam/latest/glam/bool/struct.BVec3.html: struct glam::bool::BVec3 - `BVec3`\n\u27e867\u27e9 https://docs.rs/glam/latest/glam/bool/struct.BVec4.html: struct glam::bool::BVec4 - `BVec4`\n\u27e868\u27e9 https://docs.rs/glam/latest/glam/#simd: \u00a7\n\u27e869\u27e9 https://docs.rs/glam/latest/glam/#vec3a-and-mat3a: \u00a7\n\u27e870\u27e9 https://github.com/bitshifter/mathbench-rs: **mathbench**\n\u27e871\u27e9 https://doc.rust-lang.org/nightly/core/convert/trait.From.html: trait core::convert::From - `From`\n\u27e872\u27e9 https://docs.rs/glam/latest/glam/#affine2-and-affine3a: \u00a7\n\u27e873\u27e9 https://docs.rs/glam/latest/glam/#linear-algebra-conventions: \u00a7\n\u27e874\u27e9 https://docs.rs/glam/latest/glam/#direct-element-access: \u00a7\n\u27e875\u27e9 https://doc.rust-lang.org/std/ops/trait.Deref.html: `Deref`\n\u27e876\u27e9 https://doc.rust-lang.org/std/ops/trait.DerefMut.html: `DerefMut`\n\u27e877\u27e9 https://docs.rs/glam/latest/glam/#glam-assertions: \u00a7\n\u27e878\u27e9 https://docs.rs/glam/latest/glam/#vector-swizzles: \u00a7\n\u27e879\u27e9 https://docs.rs/glam/latest/glam/swizzles/trait.Vec2Swizzles.html: trait glam::swizzles::Vec2Swizzles - `Vec2Swizzles`\n\u27e880\u27e9 https://docs.rs/glam/latest/glam/swizzles/trait.Vec3Swizzles.html: trait glam::swizzles::Vec3Swizzles - `Vec3Swizzles`\n\u27e881\u27e9 https://docs.rs/glam/latest/glam/swizzles/trait.Vec4Swizzles.html: trait glam::swizzles::Vec4Swizzles - `Vec4Swizzles`\n\u27e882\u27e9 https://docs.rs/glam/latest/glam/#simd-and-scalar-consistency: \u00a7\n\u27e883\u27e9 https://docs.rs/glam/latest/glam/#feature-gates: \u00a7\n\u27e884\u27e9 https://docs.rs/glam/latest/glam/#minimum-supported-rust-version-msrv: \u00a7\n\u27e885\u27e9 https://docs.rs/glam/latest/glam/#reexports: \u00a7\n\u27e886\u27e9 https://docs.rs/glam/latest/glam/#modules: \u00a7\n\u27e887\u27e9 https://docs.rs/glam/latest/glam/swizzles/index.html: mod glam::swizzles - swizzles\n\u27e888\u27e9 https://docs.rs/glam/latest/glam/#enums: \u00a7\n\u27e889\u27e9 https://docs.rs/glam/latest/glam/enum.EulerRot.html: enum glam::EulerRot - EulerRot\n\u27e890\u27e9 https://docs.rs/glam/latest/glam/#traits: \u00a7\n\u27e891\u27e9 https://docs.rs/glam/latest/glam/trait.FloatExt.html: trait glam::FloatExt - FloatExt\n\u27e892\u27e9 https://doc.rust-lang.org/nightly/std/primitive.f32.html: primitive f32 - `f32`\n\u27e893\u27e9 https://doc.rust-lang.org/nightly/std/primitive.f64.html: primitive f64 - `f64`\n",
            "fit_markdown": "",
            "fit_html": ""
          },
          "downloads": 0,
          "github_stars": 0,
          "dependencies": [],
          "features": {},
          "code_snippets": [],
          "readme_sections": {},
          "librs_downloads": null,
          "source": "crates.io",
          "enhanced_scraping": {},
          "enhanced_features": [],
          "enhanced_dependencies": []
        },
        "enriched_crate": {
          "name": "glam",
          "version": "0.30.4",
          "description": "ALLOW: Positive community sentiment",
          "repository": "",
          "keywords": [],
          "categories": [],
          "readme": {
            "raw_markdown": "[](https://docs.rs/glam/latest/glam/all.html \"show sidebar\")\n# Crate glamCopy item path\n[Settings](https://docs.rs/glam/latest/settings.html)\n[Help](https://docs.rs/glam/latest/help.html)\nSummary[Source](https://docs.rs/glam/latest/src/glam/lib.rs.html#1-383)\nExpand description\n## [\u00a7](https://docs.rs/glam/latest/glam/#glam)glam\n`glam` is a simple and fast linear algebra library for games and graphics.\n### [\u00a7](https://docs.rs/glam/latest/glam/#features)Features\n  * [`f32`](https://docs.rs/glam/latest/glam/f32/index.html \"mod glam::f32\") types \n    * vectors: [`Vec2`](https://docs.rs/glam/latest/glam/f32/struct.Vec2.html \"struct glam::f32::Vec2\"), [`Vec3`](https://docs.rs/glam/latest/glam/f32/struct.Vec3.html \"struct glam::f32::Vec3\"), [`Vec3A`](https://docs.rs/glam/latest/glam/f32/struct.Vec3A.html \"struct glam::f32::Vec3A\") and [`Vec4`](https://docs.rs/glam/latest/glam/f32/struct.Vec4.html \"struct glam::f32::Vec4\")\n    * square matrices: [`Mat2`](https://docs.rs/glam/latest/glam/f32/struct.Mat2.html \"struct glam::f32::Mat2\"), [`Mat3`](https://docs.rs/glam/latest/glam/f32/struct.Mat3.html \"struct glam::f32::Mat3\"), [`Mat3A`](https://docs.rs/glam/latest/glam/f32/struct.Mat3A.html \"struct glam::f32::Mat3A\") and [`Mat4`](https://docs.rs/glam/latest/glam/f32/struct.Mat4.html \"struct glam::f32::Mat4\")\n    * a quaternion type: [`Quat`](https://docs.rs/glam/latest/glam/f32/struct.Quat.html \"struct glam::f32::Quat\")\n    * affine transformation types: [`Affine2`](https://docs.rs/glam/latest/glam/f32/struct.Affine2.html \"struct glam::f32::Affine2\") and [`Affine3A`](https://docs.rs/glam/latest/glam/f32/struct.Affine3A.html \"struct glam::f32::Affine3A\")\n  * [`f64`](https://docs.rs/glam/latest/glam/f64/index.html \"mod glam::f64\") types \n    * vectors: [`DVec2`](https://docs.rs/glam/latest/glam/f64/struct.DVec2.html \"struct glam::f64::DVec2\"), [`DVec3`](https://docs.rs/glam/latest/glam/f64/struct.DVec3.html \"struct glam::f64::DVec3\") and [`DVec4`](https://docs.rs/glam/latest/glam/f64/struct.DVec4.html \"struct glam::f64::DVec4\")\n    * square matrices: [`DMat2`](https://docs.rs/glam/latest/glam/f64/struct.DMat2.html \"struct glam::f64::DMat2\"), [`DMat3`](https://docs.rs/glam/latest/glam/f64/struct.DMat3.html \"struct glam::f64::DMat3\") and [`DMat4`](https://docs.rs/glam/latest/glam/f64/struct.DMat4.html \"struct glam::f64::DMat4\")\n    * a quaternion type: [`DQuat`](https://docs.rs/glam/latest/glam/f64/struct.DQuat.html \"struct glam::f64::DQuat\")\n    * affine transformation types: [`DAffine2`](https://docs.rs/glam/latest/glam/f64/struct.DAffine2.html \"struct glam::f64::DAffine2\") and [`DAffine3`](https://docs.rs/glam/latest/glam/f64/struct.DAffine3.html \"struct glam::f64::DAffine3\")\n  * [`i8`](https://docs.rs/glam/latest/glam/i8/index.html \"mod glam::i8\") types \n    * vectors: [`I8Vec2`](https://docs.rs/glam/latest/glam/i8/struct.I8Vec2.html \"struct glam::i8::I8Vec2\"), [`I8Vec3`](https://docs.rs/glam/latest/glam/i8/struct.I8Vec3.html \"struct glam::i8::I8Vec3\") and [`I8Vec4`](https://docs.rs/glam/latest/glam/i8/struct.I8Vec4.html \"struct glam::i8::I8Vec4\")\n  * [`u8`](https://docs.rs/glam/latest/glam/u8/index.html \"mod glam::u8\") types \n    * vectors: [`U8Vec2`](https://docs.rs/glam/latest/glam/u8/struct.U8Vec2.html \"struct glam::u8::U8Vec2\"), [`U8Vec3`](https://docs.rs/glam/latest/glam/u8/struct.U8Vec3.html \"struct glam::u8::U8Vec3\") and [`U8Vec4`](https://docs.rs/glam/latest/glam/u8/struct.U8Vec4.html \"struct glam::u8::U8Vec4\")\n  * [`i16`](https://docs.rs/glam/latest/glam/i16/index.html \"mod glam::i16\") types \n    * vectors: [`I16Vec2`](https://docs.rs/glam/latest/glam/i16/struct.I16Vec2.html \"struct glam::i16::I16Vec2\"), [`I16Vec3`](https://docs.rs/glam/latest/glam/i16/struct.I16Vec3.html \"struct glam::i16::I16Vec3\") and [`I16Vec4`](https://docs.rs/glam/latest/glam/i16/struct.I16Vec4.html \"struct glam::i16::I16Vec4\")\n  * [`u16`](https://docs.rs/glam/latest/glam/u16/index.html \"mod glam::u16\") types \n    * vectors: [`U16Vec2`](https://docs.rs/glam/latest/glam/u16/struct.U16Vec2.html \"struct glam::u16::U16Vec2\"), [`U16Vec3`](https://docs.rs/glam/latest/glam/u16/struct.U16Vec3.html \"struct glam::u16::U16Vec3\") and [`U16Vec4`](https://docs.rs/glam/latest/glam/u16/struct.U16Vec4.html \"struct glam::u16::U16Vec4\")\n  * [`i32`](https://docs.rs/glam/latest/glam/i32/index.html \"mod glam::i32\") types \n    * vectors: [`IVec2`](https://docs.rs/glam/latest/glam/i32/struct.IVec2.html \"struct glam::i32::IVec2\"), [`IVec3`](https://docs.rs/glam/latest/glam/i32/struct.IVec3.html \"struct glam::i32::IVec3\") and [`IVec4`](https://docs.rs/glam/latest/glam/i32/struct.IVec4.html \"struct glam::i32::IVec4\")\n  * [`u32`](https://docs.rs/glam/latest/glam/u32/index.html \"mod glam::u32\") types \n    * vectors: [`UVec2`](https://docs.rs/glam/latest/glam/u32/struct.UVec2.html \"struct glam::u32::UVec2\"), [`UVec3`](https://docs.rs/glam/latest/glam/u32/struct.UVec3.html \"struct glam::u32::UVec3\") and [`UVec4`](https://docs.rs/glam/latest/glam/u32/struct.UVec4.html \"struct glam::u32::UVec4\")\n  * [`i64`](https://docs.rs/glam/latest/glam/i64/index.html \"mod glam::i64\") types \n    * vectors: [`I64Vec2`](https://docs.rs/glam/latest/glam/i64/struct.I64Vec2.html \"struct glam::i64::I64Vec2\"), [`I64Vec3`](https://docs.rs/glam/latest/glam/i64/struct.I64Vec3.html \"struct glam::i64::I64Vec3\") and [`I64Vec4`](https://docs.rs/glam/latest/glam/i64/struct.I64Vec4.html \"struct glam::i64::I64Vec4\")\n  * [`u64`](https://docs.rs/glam/latest/glam/u64/index.html \"mod glam::u64\") types \n    * vectors: [`U64Vec2`](https://docs.rs/glam/latest/glam/u64/struct.U64Vec2.html \"struct glam::u64::U64Vec2\"), [`U64Vec3`](https://docs.rs/glam/latest/glam/u64/struct.U64Vec3.html \"struct glam::u64::U64Vec3\") and [`U64Vec4`](https://docs.rs/glam/latest/glam/u64/struct.U64Vec4.html \"struct glam::u64::U64Vec4\")\n  * [`usize`](https://docs.rs/glam/latest/glam/usize/index.html \"mod glam::usize\") types \n    * vectors: [`USizeVec2`](https://docs.rs/glam/latest/glam/usize/struct.USizeVec2.html \"struct glam::usize::USizeVec2\"), [`USizeVec3`](https://docs.rs/glam/latest/glam/usize/struct.USizeVec3.html \"struct glam::usize::USizeVec3\") and [`USizeVec4`](https://docs.rs/glam/latest/glam/usize/struct.USizeVec4.html \"struct glam::usize::USizeVec4\")\n  * [`bool`](https://docs.rs/glam/latest/glam/bool/index.html \"mod glam::bool\") types \n    * vectors: [`BVec2`](https://docs.rs/glam/latest/glam/bool/struct.BVec2.html \"struct glam::bool::BVec2\"), [`BVec3`](https://docs.rs/glam/latest/glam/bool/struct.BVec3.html \"struct glam::bool::BVec3\") and [`BVec4`](https://docs.rs/glam/latest/glam/bool/struct.BVec4.html \"struct glam::bool::BVec4\")\n\n\n### [\u00a7](https://docs.rs/glam/latest/glam/#simd)SIMD\n`glam` is built with SIMD in mind. Many `f32` types use 128-bit SIMD vector types for storage and/or implementation. The use of SIMD generally enables better performance than using primitive numeric types such as `f32`.\nSome `glam` types use SIMD for storage meaning they are 16 byte aligned, these types include `Mat2`, `Mat3A`, `Mat4`, `Quat`, `Vec3A`, `Vec4`, `Affine2` an `Affine3A`. Types with an `A` suffix are a SIMD alternative to a scalar type, e.g. `Vec3` uses `f32` storage and `Vec3A` uses SIMD storage.\nWhen SIMD is not available on the target the types will maintain 16 byte alignment and internal padding so that object sizes and layouts will not change between architectures. There are scalar math fallback implementations exist when SIMD is not available. It is intended to add support for other SIMD architectures once they appear in stable Rust.\nCurrently only SSE2 on x86/x86_64, NEON on Aarch64, and simd128 on WASM are supported.\n### [\u00a7](https://docs.rs/glam/latest/glam/#vec3a-and-mat3a)Vec3A and Mat3A\n`Vec3A` is a SIMD optimized version of the `Vec3` type, which due to 16 byte alignment results in `Vec3A` containing 4 bytes of padding making it 16 bytes in size in total. `Mat3A` is composed of three `Vec3A` columns.\nType| `f32` bytes| Align bytes| Size bytes| Padding  \n---|---|---|---|---  \n[`Vec3`](https://docs.rs/glam/latest/glam/f32/struct.Vec3.html \"struct glam::f32::Vec3\")| 12| 4| 12| 0  \n[`Vec3A`](https://docs.rs/glam/latest/glam/f32/struct.Vec3A.html \"struct glam::f32::Vec3A\")| 12| 16| 16| 4  \n[`Mat3`](https://docs.rs/glam/latest/glam/f32/struct.Mat3.html \"struct glam::f32::Mat3\")| 36| 4| 36| 0  \n[`Mat3A`](https://docs.rs/glam/latest/glam/f32/struct.Mat3A.html \"struct glam::f32::Mat3A\")| 36| 16| 48| 12  \nDespite this wasted space the SIMD implementations tend to outperform `f32` implementations in [**mathbench**](https://github.com/bitshifter/mathbench-rs) benchmarks.\n`glam` treats [`Vec3`](https://docs.rs/glam/latest/glam/f32/struct.Vec3.html \"struct glam::f32::Vec3\") as the default 3D vector type and [`Vec3A`](https://docs.rs/glam/latest/glam/f32/struct.Vec3A.html \"struct glam::f32::Vec3A\") a special case for optimization. When methods need to return a 3D vector they will generally return [`Vec3`](https://docs.rs/glam/latest/glam/f32/struct.Vec3.html \"struct glam::f32::Vec3\").\nThere are [`From`](https://doc.rust-lang.org/nightly/core/convert/trait.From.html \"trait core::convert::From\") trait implementations for converting from [`Vec4`](https://docs.rs/glam/latest/glam/f32/struct.Vec4.html \"struct glam::f32::Vec4\") to a [`Vec3A`](https://docs.rs/glam/latest/glam/f32/struct.Vec3A.html \"struct glam::f32::Vec3A\") and between [`Vec3`](https://docs.rs/glam/latest/glam/f32/struct.Vec3.html \"struct glam::f32::Vec3\") and [`Vec3A`](https://docs.rs/glam/latest/glam/f32/struct.Vec3A.html \"struct glam::f32::Vec3A\") (and vice versa).\n```\nuse glam::{Vec3, Vec3A, Vec4};\nlet v4 = Vec4::new(1.0, 2.0, 3.0, 4.0);\n// Convert from `Vec4` to `Vec3A`, this is a no-op if SIMD is supported.\n// We use an explicit method here instead of a From impl as data is lost in the conversion.\nlet v3a = Vec3A::from_vec4(v4);\nassert_eq!(Vec3A::new(1.0, 2.0, 3.0), v3a);\n// Convert from `Vec3A` to `Vec3`.\nlet v3 = Vec3::from(v3a);\nassert_eq!(Vec3::new(1.0, 2.0, 3.0), v3);\n// Convert from `Vec3` to `Vec3A`.\nlet v3a = Vec3A::from(v3);\nassert_eq!(Vec3A::new(1.0, 2.0, 3.0), v3a);\n```\n\n### [\u00a7](https://docs.rs/glam/latest/glam/#affine2-and-affine3a)Affine2 and Affine3A\n`Affine2` and `Affine3A` are composed of a linear transform matrix and a vector translation. The represent 2D and 3D affine transformations which are commonly used in games.\nThe table below shows the performance advantage of `Affine2` over `Mat3A` and `Mat3A` over `Mat3`.\noperation| `Mat3`| `Mat3A`| `Affine2`  \n---|---|---|---  \ninverse| 11.4\u00b10.09ns| 7.1\u00b10.09ns| 5.4\u00b10.06ns  \nmul self| 10.5\u00b10.04ns| 5.2\u00b10.05ns| 4.0\u00b10.05ns  \ntransform point2| 2.7\u00b10.02ns| 2.7\u00b10.03ns| 2.8\u00b10.04ns  \ntransform vector2| 2.6\u00b10.01ns| 2.6\u00b10.03ns| 2.3\u00b10.02ns  \nPerformance is much closer between `Mat4` and `Affine3A` with the affine type being faster to invert.\noperation| `Mat4`| `Affine3A`  \n---|---|---  \ninverse| 15.9\u00b10.11ns| 10.8\u00b10.06ns  \nmul self| 7.3\u00b10.05ns| 7.0\u00b10.06ns  \ntransform point3| 3.6\u00b10.02ns| 4.3\u00b10.04ns  \ntransform point3a| 3.0\u00b10.02ns| 3.0\u00b10.04ns  \ntransform vector3| 4.1\u00b10.02ns| 3.9\u00b10.04ns  \ntransform vector3a| 2.8\u00b10.02ns| 2.8\u00b10.02ns  \nBenchmarks were taken on an Intel Core i7-4710HQ.\n### [\u00a7](https://docs.rs/glam/latest/glam/#linear-algebra-conventions)Linear algebra conventions\n`glam` interprets vectors as column matrices (also known as column vectors) meaning when transforming a vector with a matrix the matrix goes on the left.\n```\nuse glam::{Mat3, Vec3};\nlet m = Mat3::IDENTITY;\nlet x = Vec3::X;\nlet v = m * x;\nassert_eq!(v, x);\n```\n\nMatrices are stored in memory in column-major order.\nAll angles are in radians. Rust provides the `f32::to_radians()` and `f64::to_radians()` methods to convert from degrees.\n### [\u00a7](https://docs.rs/glam/latest/glam/#direct-element-access)Direct element access\nBecause some types may internally be implemented using SIMD types, direct access to vector elements is supported by implementing the [`Deref`](https://doc.rust-lang.org/std/ops/trait.Deref.html) and [`DerefMut`](https://doc.rust-lang.org/std/ops/trait.DerefMut.html) traits.\n```\nuse glam::Vec3A;\nlet mut v = Vec3A::new(1.0, 2.0, 3.0);\nassert_eq!(3.0, v.z);\nv.z += 1.0;\nassert_eq!(4.0, v.z);\n```\n\n### [\u00a7](https://docs.rs/glam/latest/glam/#glam-assertions)glam assertions\n`glam` does not enforce validity checks on method parameters at runtime. For example methods that require normalized vectors as input such as `Quat::from_axis_angle(axis, angle)` will not check that axis is a valid normalized vector. To help catch unintended misuse of `glam` the `debug-glam-assert` or `glam-assert` features can be enabled to add checks ensure that inputs to are valid.\n### [\u00a7](https://docs.rs/glam/latest/glam/#vector-swizzles)Vector swizzles\n`glam` vector types have functions allowing elements of vectors to be reordered, this includes creating a vector of a different size from the vectors elements.\nThe swizzle functions are implemented using traits to add them to each vector type. This is primarily because there are a lot of swizzle functions which can obfuscate the other vector functions in documentation and so on. The traits are [`Vec2Swizzles`](https://docs.rs/glam/latest/glam/swizzles/trait.Vec2Swizzles.html \"trait glam::swizzles::Vec2Swizzles\"), [`Vec3Swizzles`](https://docs.rs/glam/latest/glam/swizzles/trait.Vec3Swizzles.html \"trait glam::swizzles::Vec3Swizzles\") and [`Vec4Swizzles`](https://docs.rs/glam/latest/glam/swizzles/trait.Vec4Swizzles.html \"trait glam::swizzles::Vec4Swizzles\").\nNote that the [`Vec3Swizzles`](https://docs.rs/glam/latest/glam/swizzles/trait.Vec3Swizzles.html \"trait glam::swizzles::Vec3Swizzles\") implementation for [`Vec3A`](https://docs.rs/glam/latest/glam/f32/struct.Vec3A.html \"struct glam::f32::Vec3A\") will return a [`Vec3A`](https://docs.rs/glam/latest/glam/f32/struct.Vec3A.html \"struct glam::f32::Vec3A\") for 3 element swizzles, all other implementations will return [`Vec3`](https://docs.rs/glam/latest/glam/f32/struct.Vec3.html \"struct glam::f32::Vec3\").\n```\nuse glam::{swizzles::*, Vec2, Vec3, Vec3A, Vec4};\nlet v = Vec4::new(1.0, 2.0, 3.0, 4.0);\n// Reverse elements of `v`, if SIMD is supported this will use a vector shuffle.\nlet wzyx = v.wzyx();\nassert_eq!(Vec4::new(4.0, 3.0, 2.0, 1.0), wzyx);\n// Swizzle the yzw elements of `v` into a `Vec3`\nlet yzw = v.yzw();\nassert_eq!(Vec3::new(2.0, 3.0, 4.0), yzw);\n// To swizzle a `Vec4` into a `Vec3A` swizzle the `Vec4` first then convert to\n// `Vec3A`. If SIMD is supported this will use a vector shuffle. The last\n// element of the shuffled `Vec4` is ignored by the `Vec3A`.\nlet yzw = Vec3A::from_vec4(v.yzwx());\nassert_eq!(Vec3A::new(2.0, 3.0, 4.0), yzw);\n// You can swizzle from a `Vec4` to a `Vec2`\nlet xy = v.xy();\nassert_eq!(Vec2::new(1.0, 2.0), xy);\n// And back again\nlet yyxx = xy.yyxx();\nassert_eq!(Vec4::new(2.0, 2.0, 1.0, 1.0), yyxx);\n```\n\n### [\u00a7](https://docs.rs/glam/latest/glam/#simd-and-scalar-consistency)SIMD and scalar consistency\n`glam` types implement `serde` `Serialize` and `Deserialize` traits to ensure that they will serialize and deserialize exactly the same whether or not SIMD support is being used.\nThe SIMD versions implement the `core::fmt::Debug` and `core::fmt::Display` traits so they print the same as the scalar version.\n```\nuse glam::Vec4;\nlet a = Vec4::new(1.0, 2.0, 3.0, 4.0);\nassert_eq!(format!(\"{}\", a), \"[1, 2, 3, 4]\");\n```\n\n### [\u00a7](https://docs.rs/glam/latest/glam/#feature-gates)Feature gates\nAll `glam` dependencies are optional, however some are required for tests and benchmarks.\n  * `std` - the default feature, has no dependencies.\n  * `approx` - traits and macros for approximate float comparisons\n  * `bytemuck` - for casting into slices of bytes\n  * `libm` - uses `libm` math functions instead of `std`\n  * `nostd-libm` - uses `libm` math functions if `std` is not available\n  * `mint` - for interoperating with other 3D math libraries\n  * `rand` - implementations of `Distribution` trait for all `glam` types.\n  * `rkyv` - implementations of `Archive`, `Serialize` and `Deserialize` for all `glam` types. Note that serialization is not interoperable with and without the `scalar-math` feature. It should work between all other builds of `glam`. Endian conversion is currently not supported\n  * `bytecheck` - to perform archive validation when using the `rkyv` feature\n  * `serde` - implementations of `Serialize` and `Deserialize` for all `glam` types. Note that serialization should work between builds of `glam` with and without SIMD enabled\n  * `speedy` - implementations of `speedy`\u2019s `Readable` and `Writable` for all `glam` types.\n  * `scalar-math` - disables SIMD support and uses native alignment for all types.\n  * `debug-glam-assert` - adds assertions in debug builds which check the validity of parameters passed to `glam` to help catch runtime errors.\n  * `glam-assert` - adds assertions to all builds which check the validity of parameters passed to `glam` to help catch runtime errors.\n  * `cuda` - forces `glam` types to match expected cuda alignment\n  * `fast-math` - By default, glam attempts to provide bit-for-bit identical results on all platforms. Using this feature will enable platform specific optimizations that may not be identical to other platforms. **Intermediate libraries should not use this feature and defer the decision to the final binary build**.\n  * `core-simd` - enables SIMD support via the portable simd module. This is an unstable feature which requires a nightly Rust toolchain and `std` support.\n\n\n### [\u00a7](https://docs.rs/glam/latest/glam/#minimum-supported-rust-version-msrv)Minimum Supported Rust Version (MSRV)\nThe minimum supported Rust version is `1.68.2`.\n## Re-exports[\u00a7](https://docs.rs/glam/latest/glam/#reexports)\n\n`pub use self::swizzles::Vec2Swizzles[](https://docs.rs/glam/latest/glam/swizzles/trait.Vec2Swizzles.html \"trait glam::swizzles::Vec2Swizzles\");`\n\n\n`pub use self::swizzles::Vec3Swizzles[](https://docs.rs/glam/latest/glam/swizzles/trait.Vec3Swizzles.html \"trait glam::swizzles::Vec3Swizzles\");`\n\n\n`pub use self::swizzles::Vec4Swizzles[](https://docs.rs/glam/latest/glam/swizzles/trait.Vec4Swizzles.html \"trait glam::swizzles::Vec4Swizzles\");`\n\n\n`pub use self::bool[](https://docs.rs/glam/latest/glam/bool/index.html \"mod glam::bool\")::*;`\n\n\n`pub use self::f32[](https://docs.rs/glam/latest/glam/f32/index.html \"mod glam::f32\")::*;`\n\n\n`pub use self::f64[](https://docs.rs/glam/latest/glam/f64/index.html \"mod glam::f64\")::*;`\n\n\n`pub use self::i8[](https://docs.rs/glam/latest/glam/i8/index.html \"mod glam::i8\")::*;`\n\n\n`pub use self::u8[](https://docs.rs/glam/latest/glam/u8/index.html \"mod glam::u8\")::*;`\n\n\n`pub use self::i16[](https://docs.rs/glam/latest/glam/i16/index.html \"mod glam::i16\")::*;`\n\n\n`pub use self::u16[](https://docs.rs/glam/latest/glam/u16/index.html \"mod glam::u16\")::*;`\n\n\n`pub use self::i32[](https://docs.rs/glam/latest/glam/i32/index.html \"mod glam::i32\")::*;`\n\n\n`pub use self::u32[](https://docs.rs/glam/latest/glam/u32/index.html \"mod glam::u32\")::*;`\n\n\n`pub use self::i64[](https://docs.rs/glam/latest/glam/i64/index.html \"mod glam::i64\")::*;`\n\n\n`pub use self::u64[](https://docs.rs/glam/latest/glam/u64/index.html \"mod glam::u64\")::*;`\n\n\n`pub use self::usize[](https://docs.rs/glam/latest/glam/usize/index.html \"mod glam::usize\")::*;`\n\n## Modules[\u00a7](https://docs.rs/glam/latest/glam/#modules)\n\n[bool](https://docs.rs/glam/latest/glam/bool/index.html \"mod glam::bool\")\n    `bool` vector mask types.\n\n[f32](https://docs.rs/glam/latest/glam/f32/index.html \"mod glam::f32\")\n    `f32` vector, quaternion and matrix types.\n\n[f64](https://docs.rs/glam/latest/glam/f64/index.html \"mod glam::f64\")\n    `f64` vector, quaternion and matrix types.\n\n[i8](https://docs.rs/glam/latest/glam/i8/index.html \"mod glam::i8\")\n    `i8` vector types.\n\n[i16](https://docs.rs/glam/latest/glam/i16/index.html \"mod glam::i16\")\n    `i16` vector types.\n\n[i32](https://docs.rs/glam/latest/glam/i32/index.html \"mod glam::i32\")\n    `i32` vector types.\n\n[i64](https://docs.rs/glam/latest/glam/i64/index.html \"mod glam::i64\")\n    `i64` vector types.\n\n[swizzles](https://docs.rs/glam/latest/glam/swizzles/index.html \"mod glam::swizzles\")\n    Traits adding swizzle methods to all vector types.\n\n[u8](https://docs.rs/glam/latest/glam/u8/index.html \"mod glam::u8\")\n    `u8` vector types.\n\n[u16](https://docs.rs/glam/latest/glam/u16/index.html \"mod glam::u16\")\n    `u16` vector types.\n\n[u32](https://docs.rs/glam/latest/glam/u32/index.html \"mod glam::u32\")\n    `u32` vector types.\n\n[u64](https://docs.rs/glam/latest/glam/u64/index.html \"mod glam::u64\")\n    `u64` vector types.\n\n[usize](https://docs.rs/glam/latest/glam/usize/index.html \"mod glam::usize\")\n    `usize` vector types.\n## Enums[\u00a7](https://docs.rs/glam/latest/glam/#enums)\n\n[EulerRot](https://docs.rs/glam/latest/glam/enum.EulerRot.html \"enum glam::EulerRot\")\n    Rotation Helper Euler rotation sequences.\n## Traits[\u00a7](https://docs.rs/glam/latest/glam/#traits)\n\n[FloatExt](https://docs.rs/glam/latest/glam/trait.FloatExt.html \"trait glam::FloatExt\")\n    A trait for extending [`f32`](https://doc.rust-lang.org/nightly/std/primitive.f32.html \"primitive f32\") and [`f64`](https://doc.rust-lang.org/nightly/std/primitive.f64.html \"primitive f64\") with extra methods.\n",
            "markdown_with_citations": "[](https://docs.rs/glam/latest/glam/all.html \"show sidebar\")\n# Crate glamCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\n## \u00a7\u27e84\u27e9glam\n`glam` is a simple and fast linear algebra library for games and graphics.\n### \u00a7\u27e85\u27e9Features\n  * `f32`\u27e86\u27e9 types \n    * vectors: `Vec2`\u27e87\u27e9, `Vec3`\u27e88\u27e9, `Vec3A`\u27e89\u27e9 and `Vec4`\u27e810\u27e9\n    * square matrices: `Mat2`\u27e811\u27e9, `Mat3`\u27e812\u27e9, `Mat3A`\u27e813\u27e9 and `Mat4`\u27e814\u27e9\n    * a quaternion type: `Quat`\u27e815\u27e9\n    * affine transformation types: `Affine2`\u27e816\u27e9 and `Affine3A`\u27e817\u27e9\n  * `f64`\u27e818\u27e9 types \n    * vectors: `DVec2`\u27e819\u27e9, `DVec3`\u27e820\u27e9 and `DVec4`\u27e821\u27e9\n    * square matrices: `DMat2`\u27e822\u27e9, `DMat3`\u27e823\u27e9 and `DMat4`\u27e824\u27e9\n    * a quaternion type: `DQuat`\u27e825\u27e9\n    * affine transformation types: `DAffine2`\u27e826\u27e9 and `DAffine3`\u27e827\u27e9\n  * `i8`\u27e828\u27e9 types \n    * vectors: `I8Vec2`\u27e829\u27e9, `I8Vec3`\u27e830\u27e9 and `I8Vec4`\u27e831\u27e9\n  * `u8`\u27e832\u27e9 types \n    * vectors: `U8Vec2`\u27e833\u27e9, `U8Vec3`\u27e834\u27e9 and `U8Vec4`\u27e835\u27e9\n  * `i16`\u27e836\u27e9 types \n    * vectors: `I16Vec2`\u27e837\u27e9, `I16Vec3`\u27e838\u27e9 and `I16Vec4`\u27e839\u27e9\n  * `u16`\u27e840\u27e9 types \n    * vectors: `U16Vec2`\u27e841\u27e9, `U16Vec3`\u27e842\u27e9 and `U16Vec4`\u27e843\u27e9\n  * `i32`\u27e844\u27e9 types \n    * vectors: `IVec2`\u27e845\u27e9, `IVec3`\u27e846\u27e9 and `IVec4`\u27e847\u27e9\n  * `u32`\u27e848\u27e9 types \n    * vectors: `UVec2`\u27e849\u27e9, `UVec3`\u27e850\u27e9 and `UVec4`\u27e851\u27e9\n  * `i64`\u27e852\u27e9 types \n    * vectors: `I64Vec2`\u27e853\u27e9, `I64Vec3`\u27e854\u27e9 and `I64Vec4`\u27e855\u27e9\n  * `u64`\u27e856\u27e9 types \n    * vectors: `U64Vec2`\u27e857\u27e9, `U64Vec3`\u27e858\u27e9 and `U64Vec4`\u27e859\u27e9\n  * `usize`\u27e860\u27e9 types \n    * vectors: `USizeVec2`\u27e861\u27e9, `USizeVec3`\u27e862\u27e9 and `USizeVec4`\u27e863\u27e9\n  * `bool`\u27e864\u27e9 types \n    * vectors: `BVec2`\u27e865\u27e9, `BVec3`\u27e866\u27e9 and `BVec4`\u27e867\u27e9\n\n\n### \u00a7\u27e868\u27e9SIMD\n`glam` is built with SIMD in mind. Many `f32` types use 128-bit SIMD vector types for storage and/or implementation. The use of SIMD generally enables better performance than using primitive numeric types such as `f32`.\nSome `glam` types use SIMD for storage meaning they are 16 byte aligned, these types include `Mat2`, `Mat3A`, `Mat4`, `Quat`, `Vec3A`, `Vec4`, `Affine2` an `Affine3A`. Types with an `A` suffix are a SIMD alternative to a scalar type, e.g. `Vec3` uses `f32` storage and `Vec3A` uses SIMD storage.\nWhen SIMD is not available on the target the types will maintain 16 byte alignment and internal padding so that object sizes and layouts will not change between architectures. There are scalar math fallback implementations exist when SIMD is not available. It is intended to add support for other SIMD architectures once they appear in stable Rust.\nCurrently only SSE2 on x86/x86_64, NEON on Aarch64, and simd128 on WASM are supported.\n### \u00a7\u27e869\u27e9Vec3A and Mat3A\n`Vec3A` is a SIMD optimized version of the `Vec3` type, which due to 16 byte alignment results in `Vec3A` containing 4 bytes of padding making it 16 bytes in size in total. `Mat3A` is composed of three `Vec3A` columns.\nType| `f32` bytes| Align bytes| Size bytes| Padding  \n---|---|---|---|---  \n`Vec3`\u27e88\u27e9| 12| 4| 12| 0  \n`Vec3A`\u27e89\u27e9| 12| 16| 16| 4  \n`Mat3`\u27e812\u27e9| 36| 4| 36| 0  \n`Mat3A`\u27e813\u27e9| 36| 16| 48| 12  \nDespite this wasted space the SIMD implementations tend to outperform `f32` implementations in **mathbench**\u27e870\u27e9 benchmarks.\n`glam` treats `Vec3`\u27e88\u27e9 as the default 3D vector type and `Vec3A`\u27e89\u27e9 a special case for optimization. When methods need to return a 3D vector they will generally return `Vec3`\u27e88\u27e9.\nThere are `From`\u27e871\u27e9 trait implementations for converting from `Vec4`\u27e810\u27e9 to a `Vec3A`\u27e89\u27e9 and between `Vec3`\u27e88\u27e9 and `Vec3A`\u27e89\u27e9 (and vice versa).\n```\nuse glam::{Vec3, Vec3A, Vec4};\nlet v4 = Vec4::new(1.0, 2.0, 3.0, 4.0);\n// Convert from `Vec4` to `Vec3A`, this is a no-op if SIMD is supported.\n// We use an explicit method here instead of a From impl as data is lost in the conversion.\nlet v3a = Vec3A::from_vec4(v4);\nassert_eq!(Vec3A::new(1.0, 2.0, 3.0), v3a);\n// Convert from `Vec3A` to `Vec3`.\nlet v3 = Vec3::from(v3a);\nassert_eq!(Vec3::new(1.0, 2.0, 3.0), v3);\n// Convert from `Vec3` to `Vec3A`.\nlet v3a = Vec3A::from(v3);\nassert_eq!(Vec3A::new(1.0, 2.0, 3.0), v3a);\n```\n\n### \u00a7\u27e872\u27e9Affine2 and Affine3A\n`Affine2` and `Affine3A` are composed of a linear transform matrix and a vector translation. The represent 2D and 3D affine transformations which are commonly used in games.\nThe table below shows the performance advantage of `Affine2` over `Mat3A` and `Mat3A` over `Mat3`.\noperation| `Mat3`| `Mat3A`| `Affine2`  \n---|---|---|---  \ninverse| 11.4\u00b10.09ns| 7.1\u00b10.09ns| 5.4\u00b10.06ns  \nmul self| 10.5\u00b10.04ns| 5.2\u00b10.05ns| 4.0\u00b10.05ns  \ntransform point2| 2.7\u00b10.02ns| 2.7\u00b10.03ns| 2.8\u00b10.04ns  \ntransform vector2| 2.6\u00b10.01ns| 2.6\u00b10.03ns| 2.3\u00b10.02ns  \nPerformance is much closer between `Mat4` and `Affine3A` with the affine type being faster to invert.\noperation| `Mat4`| `Affine3A`  \n---|---|---  \ninverse| 15.9\u00b10.11ns| 10.8\u00b10.06ns  \nmul self| 7.3\u00b10.05ns| 7.0\u00b10.06ns  \ntransform point3| 3.6\u00b10.02ns| 4.3\u00b10.04ns  \ntransform point3a| 3.0\u00b10.02ns| 3.0\u00b10.04ns  \ntransform vector3| 4.1\u00b10.02ns| 3.9\u00b10.04ns  \ntransform vector3a| 2.8\u00b10.02ns| 2.8\u00b10.02ns  \nBenchmarks were taken on an Intel Core i7-4710HQ.\n### \u00a7\u27e873\u27e9Linear algebra conventions\n`glam` interprets vectors as column matrices (also known as column vectors) meaning when transforming a vector with a matrix the matrix goes on the left.\n```\nuse glam::{Mat3, Vec3};\nlet m = Mat3::IDENTITY;\nlet x = Vec3::X;\nlet v = m * x;\nassert_eq!(v, x);\n```\n\nMatrices are stored in memory in column-major order.\nAll angles are in radians. Rust provides the `f32::to_radians()` and `f64::to_radians()` methods to convert from degrees.\n### \u00a7\u27e874\u27e9Direct element access\nBecause some types may internally be implemented using SIMD types, direct access to vector elements is supported by implementing the `Deref`\u27e875\u27e9 and `DerefMut`\u27e876\u27e9 traits.\n```\nuse glam::Vec3A;\nlet mut v = Vec3A::new(1.0, 2.0, 3.0);\nassert_eq!(3.0, v.z);\nv.z += 1.0;\nassert_eq!(4.0, v.z);\n```\n\n### \u00a7\u27e877\u27e9glam assertions\n`glam` does not enforce validity checks on method parameters at runtime. For example methods that require normalized vectors as input such as `Quat::from_axis_angle(axis, angle)` will not check that axis is a valid normalized vector. To help catch unintended misuse of `glam` the `debug-glam-assert` or `glam-assert` features can be enabled to add checks ensure that inputs to are valid.\n### \u00a7\u27e878\u27e9Vector swizzles\n`glam` vector types have functions allowing elements of vectors to be reordered, this includes creating a vector of a different size from the vectors elements.\nThe swizzle functions are implemented using traits to add them to each vector type. This is primarily because there are a lot of swizzle functions which can obfuscate the other vector functions in documentation and so on. The traits are `Vec2Swizzles`\u27e879\u27e9, `Vec3Swizzles`\u27e880\u27e9 and `Vec4Swizzles`\u27e881\u27e9.\nNote that the `Vec3Swizzles`\u27e880\u27e9 implementation for `Vec3A`\u27e89\u27e9 will return a `Vec3A`\u27e89\u27e9 for 3 element swizzles, all other implementations will return `Vec3`\u27e88\u27e9.\n```\nuse glam::{swizzles::*, Vec2, Vec3, Vec3A, Vec4};\nlet v = Vec4::new(1.0, 2.0, 3.0, 4.0);\n// Reverse elements of `v`, if SIMD is supported this will use a vector shuffle.\nlet wzyx = v.wzyx();\nassert_eq!(Vec4::new(4.0, 3.0, 2.0, 1.0), wzyx);\n// Swizzle the yzw elements of `v` into a `Vec3`\nlet yzw = v.yzw();\nassert_eq!(Vec3::new(2.0, 3.0, 4.0), yzw);\n// To swizzle a `Vec4` into a `Vec3A` swizzle the `Vec4` first then convert to\n// `Vec3A`. If SIMD is supported this will use a vector shuffle. The last\n// element of the shuffled `Vec4` is ignored by the `Vec3A`.\nlet yzw = Vec3A::from_vec4(v.yzwx());\nassert_eq!(Vec3A::new(2.0, 3.0, 4.0), yzw);\n// You can swizzle from a `Vec4` to a `Vec2`\nlet xy = v.xy();\nassert_eq!(Vec2::new(1.0, 2.0), xy);\n// And back again\nlet yyxx = xy.yyxx();\nassert_eq!(Vec4::new(2.0, 2.0, 1.0, 1.0), yyxx);\n```\n\n### \u00a7\u27e882\u27e9SIMD and scalar consistency\n`glam` types implement `serde` `Serialize` and `Deserialize` traits to ensure that they will serialize and deserialize exactly the same whether or not SIMD support is being used.\nThe SIMD versions implement the `core::fmt::Debug` and `core::fmt::Display` traits so they print the same as the scalar version.\n```\nuse glam::Vec4;\nlet a = Vec4::new(1.0, 2.0, 3.0, 4.0);\nassert_eq!(format!(\"{}\", a), \"[1, 2, 3, 4]\");\n```\n\n### \u00a7\u27e883\u27e9Feature gates\nAll `glam` dependencies are optional, however some are required for tests and benchmarks.\n  * `std` - the default feature, has no dependencies.\n  * `approx` - traits and macros for approximate float comparisons\n  * `bytemuck` - for casting into slices of bytes\n  * `libm` - uses `libm` math functions instead of `std`\n  * `nostd-libm` - uses `libm` math functions if `std` is not available\n  * `mint` - for interoperating with other 3D math libraries\n  * `rand` - implementations of `Distribution` trait for all `glam` types.\n  * `rkyv` - implementations of `Archive`, `Serialize` and `Deserialize` for all `glam` types. Note that serialization is not interoperable with and without the `scalar-math` feature. It should work between all other builds of `glam`. Endian conversion is currently not supported\n  * `bytecheck` - to perform archive validation when using the `rkyv` feature\n  * `serde` - implementations of `Serialize` and `Deserialize` for all `glam` types. Note that serialization should work between builds of `glam` with and without SIMD enabled\n  * `speedy` - implementations of `speedy`\u2019s `Readable` and `Writable` for all `glam` types.\n  * `scalar-math` - disables SIMD support and uses native alignment for all types.\n  * `debug-glam-assert` - adds assertions in debug builds which check the validity of parameters passed to `glam` to help catch runtime errors.\n  * `glam-assert` - adds assertions to all builds which check the validity of parameters passed to `glam` to help catch runtime errors.\n  * `cuda` - forces `glam` types to match expected cuda alignment\n  * `fast-math` - By default, glam attempts to provide bit-for-bit identical results on all platforms. Using this feature will enable platform specific optimizations that may not be identical to other platforms. **Intermediate libraries should not use this feature and defer the decision to the final binary build**.\n  * `core-simd` - enables SIMD support via the portable simd module. This is an unstable feature which requires a nightly Rust toolchain and `std` support.\n\n\n### \u00a7\u27e884\u27e9Minimum Supported Rust Version (MSRV)\nThe minimum supported Rust version is `1.68.2`.\n## Re-exports\u00a7\u27e885\u27e9\n\n`pub use self::swizzles::Vec2Swizzles[](https://docs.rs/glam/latest/glam/swizzles/trait.Vec2Swizzles.html \"trait glam::swizzles::Vec2Swizzles\");`\n\n\n`pub use self::swizzles::Vec3Swizzles[](https://docs.rs/glam/latest/glam/swizzles/trait.Vec3Swizzles.html \"trait glam::swizzles::Vec3Swizzles\");`\n\n\n`pub use self::swizzles::Vec4Swizzles[](https://docs.rs/glam/latest/glam/swizzles/trait.Vec4Swizzles.html \"trait glam::swizzles::Vec4Swizzles\");`\n\n\n`pub use self::bool[](https://docs.rs/glam/latest/glam/bool/index.html \"mod glam::bool\")::*;`\n\n\n`pub use self::f32[](https://docs.rs/glam/latest/glam/f32/index.html \"mod glam::f32\")::*;`\n\n\n`pub use self::f64[](https://docs.rs/glam/latest/glam/f64/index.html \"mod glam::f64\")::*;`\n\n\n`pub use self::i8[](https://docs.rs/glam/latest/glam/i8/index.html \"mod glam::i8\")::*;`\n\n\n`pub use self::u8[](https://docs.rs/glam/latest/glam/u8/index.html \"mod glam::u8\")::*;`\n\n\n`pub use self::i16[](https://docs.rs/glam/latest/glam/i16/index.html \"mod glam::i16\")::*;`\n\n\n`pub use self::u16[](https://docs.rs/glam/latest/glam/u16/index.html \"mod glam::u16\")::*;`\n\n\n`pub use self::i32[](https://docs.rs/glam/latest/glam/i32/index.html \"mod glam::i32\")::*;`\n\n\n`pub use self::u32[](https://docs.rs/glam/latest/glam/u32/index.html \"mod glam::u32\")::*;`\n\n\n`pub use self::i64[](https://docs.rs/glam/latest/glam/i64/index.html \"mod glam::i64\")::*;`\n\n\n`pub use self::u64[](https://docs.rs/glam/latest/glam/u64/index.html \"mod glam::u64\")::*;`\n\n\n`pub use self::usize[](https://docs.rs/glam/latest/glam/usize/index.html \"mod glam::usize\")::*;`\n\n## Modules\u00a7\u27e886\u27e9\n\nbool\u27e864\u27e9\n    `bool` vector mask types.\n\nf32\u27e86\u27e9\n    `f32` vector, quaternion and matrix types.\n\nf64\u27e818\u27e9\n    `f64` vector, quaternion and matrix types.\n\ni8\u27e828\u27e9\n    `i8` vector types.\n\ni16\u27e836\u27e9\n    `i16` vector types.\n\ni32\u27e844\u27e9\n    `i32` vector types.\n\ni64\u27e852\u27e9\n    `i64` vector types.\n\nswizzles\u27e887\u27e9\n    Traits adding swizzle methods to all vector types.\n\nu8\u27e832\u27e9\n    `u8` vector types.\n\nu16\u27e840\u27e9\n    `u16` vector types.\n\nu32\u27e848\u27e9\n    `u32` vector types.\n\nu64\u27e856\u27e9\n    `u64` vector types.\n\nusize\u27e860\u27e9\n    `usize` vector types.\n## Enums\u00a7\u27e888\u27e9\n\nEulerRot\u27e889\u27e9\n    Rotation Helper Euler rotation sequences.\n## Traits\u00a7\u27e890\u27e9\n\nFloatExt\u27e891\u27e9\n    A trait for extending `f32`\u27e892\u27e9 and `f64`\u27e893\u27e9 with extra methods.\n",
            "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/glam/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/glam/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/glam/latest/src/glam/lib.rs.html#1-383: Source\n\u27e84\u27e9 https://docs.rs/glam/latest/glam/#glam: \u00a7\n\u27e85\u27e9 https://docs.rs/glam/latest/glam/#features: \u00a7\n\u27e86\u27e9 https://docs.rs/glam/latest/glam/f32/index.html: mod glam::f32 - `f32`\n\u27e87\u27e9 https://docs.rs/glam/latest/glam/f32/struct.Vec2.html: struct glam::f32::Vec2 - `Vec2`\n\u27e88\u27e9 https://docs.rs/glam/latest/glam/f32/struct.Vec3.html: struct glam::f32::Vec3 - `Vec3`\n\u27e89\u27e9 https://docs.rs/glam/latest/glam/f32/struct.Vec3A.html: struct glam::f32::Vec3A - `Vec3A`\n\u27e810\u27e9 https://docs.rs/glam/latest/glam/f32/struct.Vec4.html: struct glam::f32::Vec4 - `Vec4`\n\u27e811\u27e9 https://docs.rs/glam/latest/glam/f32/struct.Mat2.html: struct glam::f32::Mat2 - `Mat2`\n\u27e812\u27e9 https://docs.rs/glam/latest/glam/f32/struct.Mat3.html: struct glam::f32::Mat3 - `Mat3`\n\u27e813\u27e9 https://docs.rs/glam/latest/glam/f32/struct.Mat3A.html: struct glam::f32::Mat3A - `Mat3A`\n\u27e814\u27e9 https://docs.rs/glam/latest/glam/f32/struct.Mat4.html: struct glam::f32::Mat4 - `Mat4`\n\u27e815\u27e9 https://docs.rs/glam/latest/glam/f32/struct.Quat.html: struct glam::f32::Quat - `Quat`\n\u27e816\u27e9 https://docs.rs/glam/latest/glam/f32/struct.Affine2.html: struct glam::f32::Affine2 - `Affine2`\n\u27e817\u27e9 https://docs.rs/glam/latest/glam/f32/struct.Affine3A.html: struct glam::f32::Affine3A - `Affine3A`\n\u27e818\u27e9 https://docs.rs/glam/latest/glam/f64/index.html: mod glam::f64 - `f64`\n\u27e819\u27e9 https://docs.rs/glam/latest/glam/f64/struct.DVec2.html: struct glam::f64::DVec2 - `DVec2`\n\u27e820\u27e9 https://docs.rs/glam/latest/glam/f64/struct.DVec3.html: struct glam::f64::DVec3 - `DVec3`\n\u27e821\u27e9 https://docs.rs/glam/latest/glam/f64/struct.DVec4.html: struct glam::f64::DVec4 - `DVec4`\n\u27e822\u27e9 https://docs.rs/glam/latest/glam/f64/struct.DMat2.html: struct glam::f64::DMat2 - `DMat2`\n\u27e823\u27e9 https://docs.rs/glam/latest/glam/f64/struct.DMat3.html: struct glam::f64::DMat3 - `DMat3`\n\u27e824\u27e9 https://docs.rs/glam/latest/glam/f64/struct.DMat4.html: struct glam::f64::DMat4 - `DMat4`\n\u27e825\u27e9 https://docs.rs/glam/latest/glam/f64/struct.DQuat.html: struct glam::f64::DQuat - `DQuat`\n\u27e826\u27e9 https://docs.rs/glam/latest/glam/f64/struct.DAffine2.html: struct glam::f64::DAffine2 - `DAffine2`\n\u27e827\u27e9 https://docs.rs/glam/latest/glam/f64/struct.DAffine3.html: struct glam::f64::DAffine3 - `DAffine3`\n\u27e828\u27e9 https://docs.rs/glam/latest/glam/i8/index.html: mod glam::i8 - `i8`\n\u27e829\u27e9 https://docs.rs/glam/latest/glam/i8/struct.I8Vec2.html: struct glam::i8::I8Vec2 - `I8Vec2`\n\u27e830\u27e9 https://docs.rs/glam/latest/glam/i8/struct.I8Vec3.html: struct glam::i8::I8Vec3 - `I8Vec3`\n\u27e831\u27e9 https://docs.rs/glam/latest/glam/i8/struct.I8Vec4.html: struct glam::i8::I8Vec4 - `I8Vec4`\n\u27e832\u27e9 https://docs.rs/glam/latest/glam/u8/index.html: mod glam::u8 - `u8`\n\u27e833\u27e9 https://docs.rs/glam/latest/glam/u8/struct.U8Vec2.html: struct glam::u8::U8Vec2 - `U8Vec2`\n\u27e834\u27e9 https://docs.rs/glam/latest/glam/u8/struct.U8Vec3.html: struct glam::u8::U8Vec3 - `U8Vec3`\n\u27e835\u27e9 https://docs.rs/glam/latest/glam/u8/struct.U8Vec4.html: struct glam::u8::U8Vec4 - `U8Vec4`\n\u27e836\u27e9 https://docs.rs/glam/latest/glam/i16/index.html: mod glam::i16 - `i16`\n\u27e837\u27e9 https://docs.rs/glam/latest/glam/i16/struct.I16Vec2.html: struct glam::i16::I16Vec2 - `I16Vec2`\n\u27e838\u27e9 https://docs.rs/glam/latest/glam/i16/struct.I16Vec3.html: struct glam::i16::I16Vec3 - `I16Vec3`\n\u27e839\u27e9 https://docs.rs/glam/latest/glam/i16/struct.I16Vec4.html: struct glam::i16::I16Vec4 - `I16Vec4`\n\u27e840\u27e9 https://docs.rs/glam/latest/glam/u16/index.html: mod glam::u16 - `u16`\n\u27e841\u27e9 https://docs.rs/glam/latest/glam/u16/struct.U16Vec2.html: struct glam::u16::U16Vec2 - `U16Vec2`\n\u27e842\u27e9 https://docs.rs/glam/latest/glam/u16/struct.U16Vec3.html: struct glam::u16::U16Vec3 - `U16Vec3`\n\u27e843\u27e9 https://docs.rs/glam/latest/glam/u16/struct.U16Vec4.html: struct glam::u16::U16Vec4 - `U16Vec4`\n\u27e844\u27e9 https://docs.rs/glam/latest/glam/i32/index.html: mod glam::i32 - `i32`\n\u27e845\u27e9 https://docs.rs/glam/latest/glam/i32/struct.IVec2.html: struct glam::i32::IVec2 - `IVec2`\n\u27e846\u27e9 https://docs.rs/glam/latest/glam/i32/struct.IVec3.html: struct glam::i32::IVec3 - `IVec3`\n\u27e847\u27e9 https://docs.rs/glam/latest/glam/i32/struct.IVec4.html: struct glam::i32::IVec4 - `IVec4`\n\u27e848\u27e9 https://docs.rs/glam/latest/glam/u32/index.html: mod glam::u32 - `u32`\n\u27e849\u27e9 https://docs.rs/glam/latest/glam/u32/struct.UVec2.html: struct glam::u32::UVec2 - `UVec2`\n\u27e850\u27e9 https://docs.rs/glam/latest/glam/u32/struct.UVec3.html: struct glam::u32::UVec3 - `UVec3`\n\u27e851\u27e9 https://docs.rs/glam/latest/glam/u32/struct.UVec4.html: struct glam::u32::UVec4 - `UVec4`\n\u27e852\u27e9 https://docs.rs/glam/latest/glam/i64/index.html: mod glam::i64 - `i64`\n\u27e853\u27e9 https://docs.rs/glam/latest/glam/i64/struct.I64Vec2.html: struct glam::i64::I64Vec2 - `I64Vec2`\n\u27e854\u27e9 https://docs.rs/glam/latest/glam/i64/struct.I64Vec3.html: struct glam::i64::I64Vec3 - `I64Vec3`\n\u27e855\u27e9 https://docs.rs/glam/latest/glam/i64/struct.I64Vec4.html: struct glam::i64::I64Vec4 - `I64Vec4`\n\u27e856\u27e9 https://docs.rs/glam/latest/glam/u64/index.html: mod glam::u64 - `u64`\n\u27e857\u27e9 https://docs.rs/glam/latest/glam/u64/struct.U64Vec2.html: struct glam::u64::U64Vec2 - `U64Vec2`\n\u27e858\u27e9 https://docs.rs/glam/latest/glam/u64/struct.U64Vec3.html: struct glam::u64::U64Vec3 - `U64Vec3`\n\u27e859\u27e9 https://docs.rs/glam/latest/glam/u64/struct.U64Vec4.html: struct glam::u64::U64Vec4 - `U64Vec4`\n\u27e860\u27e9 https://docs.rs/glam/latest/glam/usize/index.html: mod glam::usize - `usize`\n\u27e861\u27e9 https://docs.rs/glam/latest/glam/usize/struct.USizeVec2.html: struct glam::usize::USizeVec2 - `USizeVec2`\n\u27e862\u27e9 https://docs.rs/glam/latest/glam/usize/struct.USizeVec3.html: struct glam::usize::USizeVec3 - `USizeVec3`\n\u27e863\u27e9 https://docs.rs/glam/latest/glam/usize/struct.USizeVec4.html: struct glam::usize::USizeVec4 - `USizeVec4`\n\u27e864\u27e9 https://docs.rs/glam/latest/glam/bool/index.html: mod glam::bool - `bool`\n\u27e865\u27e9 https://docs.rs/glam/latest/glam/bool/struct.BVec2.html: struct glam::bool::BVec2 - `BVec2`\n\u27e866\u27e9 https://docs.rs/glam/latest/glam/bool/struct.BVec3.html: struct glam::bool::BVec3 - `BVec3`\n\u27e867\u27e9 https://docs.rs/glam/latest/glam/bool/struct.BVec4.html: struct glam::bool::BVec4 - `BVec4`\n\u27e868\u27e9 https://docs.rs/glam/latest/glam/#simd: \u00a7\n\u27e869\u27e9 https://docs.rs/glam/latest/glam/#vec3a-and-mat3a: \u00a7\n\u27e870\u27e9 https://github.com/bitshifter/mathbench-rs: **mathbench**\n\u27e871\u27e9 https://doc.rust-lang.org/nightly/core/convert/trait.From.html: trait core::convert::From - `From`\n\u27e872\u27e9 https://docs.rs/glam/latest/glam/#affine2-and-affine3a: \u00a7\n\u27e873\u27e9 https://docs.rs/glam/latest/glam/#linear-algebra-conventions: \u00a7\n\u27e874\u27e9 https://docs.rs/glam/latest/glam/#direct-element-access: \u00a7\n\u27e875\u27e9 https://doc.rust-lang.org/std/ops/trait.Deref.html: `Deref`\n\u27e876\u27e9 https://doc.rust-lang.org/std/ops/trait.DerefMut.html: `DerefMut`\n\u27e877\u27e9 https://docs.rs/glam/latest/glam/#glam-assertions: \u00a7\n\u27e878\u27e9 https://docs.rs/glam/latest/glam/#vector-swizzles: \u00a7\n\u27e879\u27e9 https://docs.rs/glam/latest/glam/swizzles/trait.Vec2Swizzles.html: trait glam::swizzles::Vec2Swizzles - `Vec2Swizzles`\n\u27e880\u27e9 https://docs.rs/glam/latest/glam/swizzles/trait.Vec3Swizzles.html: trait glam::swizzles::Vec3Swizzles - `Vec3Swizzles`\n\u27e881\u27e9 https://docs.rs/glam/latest/glam/swizzles/trait.Vec4Swizzles.html: trait glam::swizzles::Vec4Swizzles - `Vec4Swizzles`\n\u27e882\u27e9 https://docs.rs/glam/latest/glam/#simd-and-scalar-consistency: \u00a7\n\u27e883\u27e9 https://docs.rs/glam/latest/glam/#feature-gates: \u00a7\n\u27e884\u27e9 https://docs.rs/glam/latest/glam/#minimum-supported-rust-version-msrv: \u00a7\n\u27e885\u27e9 https://docs.rs/glam/latest/glam/#reexports: \u00a7\n\u27e886\u27e9 https://docs.rs/glam/latest/glam/#modules: \u00a7\n\u27e887\u27e9 https://docs.rs/glam/latest/glam/swizzles/index.html: mod glam::swizzles - swizzles\n\u27e888\u27e9 https://docs.rs/glam/latest/glam/#enums: \u00a7\n\u27e889\u27e9 https://docs.rs/glam/latest/glam/enum.EulerRot.html: enum glam::EulerRot - EulerRot\n\u27e890\u27e9 https://docs.rs/glam/latest/glam/#traits: \u00a7\n\u27e891\u27e9 https://docs.rs/glam/latest/glam/trait.FloatExt.html: trait glam::FloatExt - FloatExt\n\u27e892\u27e9 https://doc.rust-lang.org/nightly/std/primitive.f32.html: primitive f32 - `f32`\n\u27e893\u27e9 https://doc.rust-lang.org/nightly/std/primitive.f64.html: primitive f64 - `f64`\n",
            "fit_markdown": "",
            "fit_html": ""
          },
          "downloads": 0,
          "github_stars": 0,
          "dependencies": [],
          "features": {},
          "code_snippets": [],
          "readme_sections": {},
          "librs_downloads": null,
          "source": "crates.io",
          "enhanced_scraping": {},
          "enhanced_features": [],
          "enhanced_dependencies": [],
          "readme_summary": "The `glam` crate is a fast and lightweight linear algebra library designed for games and graphics applications. It provides a wide range of types for vectors, matrices, quaternions, and affine transformations across multiple numeric types (`f32`, `f64`, `i8`, `u8`, etc.), with optional SIMD acceleration for performance. Key features include support for serialization, approximate comparisons, and interoperability with other libraries, alongside configurable feature flags for flexibility in usage.",
          "feature_summary": null,
          "use_case": "Utilities",
          "score": 8.5,
          "factual_counterfactual": "### Pair 1: Feature Gates  \n\u2705 **Factual**: The `glam` crate supports the `serde` feature, which provides implementations of `Serialize` and `Deserialize` for all `glam` types, ensuring compatibility between builds with and without SIMD enabled.  \n\u274c **Counterfactual**: The `serde` feature in `glam` enables serialization and deserialization only for types using the `scalar-math` feature, and is incompatible with SIMD builds.  \n\n---\n\n### Pair 2: SIMD Support  \n\u2705 **Factual**: The `glam` crate offers SIMD support via the `core-simd` feature, enabling portable SIMD operations when using a nightly Rust toolchain with `std`.  \n\u274c **Counterfactual**: The `glam` crate's SIMD support is enabled by default and does not require any specific feature flags or nightly Rust toolchain.  \n\n---\n\n### Pair 3: Quaternion Types  \n\u2705 **Factual**: `glam` provides quaternion types, such as `Quat` for `f32` and `DQuat` for `f64`, which are optimized for 3D rotations and transformations in graphics applications.  \n\u274c **Counterfactual**: `glam` does not support quaternion types, requiring users to rely on external crates for handling 3D rotations and transformations.",
          "source_analysis": null,
          "user_behavior": null,
          "security": null
        }
      },
      "irl_score": 8.6,
      "execution_id": "exec-f2d1c066-32df36ed-1751265740",
      "timestamp": "2025-06-30T06:42:20.715938+00:00",
      "canon_version": "1.3.0"
    },
    "rule_zero_compliant": true
  }
]