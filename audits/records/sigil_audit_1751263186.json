[
  {
    "execution_id": "exec-feb3c8df-833250d4-1751263172",
    "timestamp": "2025-06-30T05:59:32.500297+00:00",
    "sacred_chain": {
      "input_data": "prost",
      "context_sources": [
        "crates.io",
        "github.com",
        "lib.rs",
        "docs.rs"
      ],
      "reasoning_steps": [
        "Input canonicalized: 'prost' -> 'prost'",
        "Context gathered from 4 validated sources",
        "Metadata extracted: 4 fields",
        "Documentation analyzed: quality 7.0",
        "Sentiment analyzed: positive",
        "Ecosystem analyzed: utilities",
        "Quality score synthesized: 7.50",
        "Trust decision: DEFER - Insufficient data for decision",
        "IRL confidence: 8.600"
      ],
      "suggestion": "ALLOW: Positive community sentiment",
      "verdict": "DEFER",
      "audit_info": {
        "metadata": {
          "name": "prost",
          "type": "rust_crate",
          "source": "manual_input",
          "extraction_method": "irl_engine"
        },
        "sentiment": {
          "quality_score": 7.0,
          "completeness": 0.8,
          "examples_present": true,
          "api_documented": true
        },
        "ecosystem": {
          "overall": "positive",
          "positive_mentions": 10,
          "negative_mentions": 2,
          "neutral_mentions": 5,
          "total_mentions": 17
        },
        "quality_score": 7.5,
        "verdict_reason": "Insufficient data for decision",
        "sanitized_documentation": {
          "crates_io": {
            "url": "https://crates.io/crates/prost",
            "title": "prost v0.14.1",
            "content": {
              "raw_markdown": "#  prost v0.14.1\nA Protocol Buffers implementation for the Rust Language. \n  * [ #protobuf ](https://crates.io/keywords/protobuf)\n  * [ #serialization ](https://crates.io/keywords/serialization)\n\n\n  * [ Readme ](https://crates.io/crates/prost)\n  * [ 43 Versions ](https://crates.io/crates/prost/versions)\n  * [ Dependencies ](https://crates.io/crates/prost/dependencies)\n  * [ Dependents ](https://crates.io/crates/prost/reverse_dependencies)\n\n\n## Metadata\n12 days ago \nv1.71.1 \n[ Apache-2.0 ](https://choosealicense.com/licenses/apache-2.0)\n31.7 KiB \n## Install\nRun the following Cargo command in your project directory:\ncargo add prost\nOr add the following line to your Cargo.toml:\nprost = \"0.14.1\"\n## Repository\n[ github.com/tokio-rs/prost ](https://github.com/tokio-rs/prost)\n## Owners\n## Categories\n  * [Encoding](https://crates.io/categories/encoding)\n\n\n[ Report crate ](https://crates.io/support?crate=prost&inquire=crate-violation)\n### Stats Overview\n193,729,042 Downloads all time\n43 Versions published\n#### Downloads over the last 90 days\nDisplay as \nStacked \n  * Stacked \n  * Unstacked \n\n\nLoading\u2026\n",
              "markdown_with_citations": "#  prost v0.14.1\nA Protocol Buffers implementation for the Rust Language. \n  *  #protobuf \u27e81\u27e9\n  *  #serialization \u27e82\u27e9\n\n\n  *  Readme \u27e83\u27e9\n  *  43 Versions \u27e84\u27e9\n  *  Dependencies \u27e85\u27e9\n  *  Dependents \u27e86\u27e9\n\n\n## Metadata\n12 days ago \nv1.71.1 \n Apache-2.0 \u27e87\u27e9\n31.7 KiB \n## Install\nRun the following Cargo command in your project directory:\ncargo add prost\nOr add the following line to your Cargo.toml:\nprost = \"0.14.1\"\n## Repository\n github.com/tokio-rs/prost \u27e88\u27e9\n## Owners\n## Categories\n  * Encoding\u27e89\u27e9\n\n\n Report crate \u27e810\u27e9\n### Stats Overview\n193,729,042 Downloads all time\n43 Versions published\n#### Downloads over the last 90 days\nDisplay as \nStacked \n  * Stacked \n  * Unstacked \n\n\nLoading\u2026\n",
              "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://crates.io/keywords/protobuf:  #protobuf \n\u27e82\u27e9 https://crates.io/keywords/serialization:  #serialization \n\u27e83\u27e9 https://crates.io/crates/prost:  Readme \n\u27e84\u27e9 https://crates.io/crates/prost/versions:  43 Versions \n\u27e85\u27e9 https://crates.io/crates/prost/dependencies:  Dependencies \n\u27e86\u27e9 https://crates.io/crates/prost/reverse_dependencies:  Dependents \n\u27e87\u27e9 https://choosealicense.com/licenses/apache-2.0:  Apache-2.0 \n\u27e88\u27e9 https://github.com/tokio-rs/prost:  github.com/tokio-rs/prost \n\u27e89\u27e9 https://crates.io/categories/encoding: Encoding\n\u27e810\u27e9 https://crates.io/support?crate=prost&inquire=crate-violation:  Report crate \n",
              "fit_markdown": "",
              "fit_html": ""
            },
            "structured_data": {},
            "quality_score": 3.0,
            "extraction_method": "crawl4ai",
            "error": null,
            "metadata": {
              "doc_type": "docs",
              "content_length": 1109,
              "has_structured_data": false,
              "crawl_success": true
            },
            "timestamp": "116962.2166289"
          },
          "docs_rs": {
            "url": "https://docs.rs/prost",
            "title": "Crate prostCopy item path",
            "content": {
              "raw_markdown": "[](https://docs.rs/prost/latest/prost/all.html \"show sidebar\")\n# Crate prostCopy item path\n[Settings](https://docs.rs/prost/latest/settings.html)\n[Help](https://docs.rs/prost/latest/help.html)\nSummary[Source](https://docs.rs/prost/latest/src/prost/lib.rs.html#1-42)\nExpand description\n[![continuous integration](https://github.com/tokio-rs/prost/actions/workflows/ci.yml/badge.svg?branch=master)](https://github.com/tokio-rs/prost/actions/workflows/ci.yml?query=branch%3Amaster) [![Documentation](https://docs.rs/prost/badge.svg)](https://docs.rs/prost/) [![Crate](https://img.shields.io/crates/v/prost.svg)](https://crates.io/crates/prost) [![Dependency Status](https://deps.rs/repo/github/tokio-rs/prost/status.svg)](https://deps.rs/repo/github/tokio-rs/prost) [![Discord](https://img.shields.io/discord/500028886025895936)](https://discord.gg/tokio)\n## [\u00a7](https://docs.rs/prost/latest/prost/#prost) _PROST!_\n`prost` is a [Protocol Buffers](https://developers.google.com/protocol-buffers/) implementation for the [Rust Language](https://www.rust-lang.org/). `prost` generates simple, idiomatic Rust code from `proto2` and `proto3` files.\nCompared to other Protocol Buffers implementations, `prost`\n  * Generates simple, idiomatic, and readable Rust types by taking advantage of Rust `derive` attributes.\n  * Retains comments from `.proto` files in generated Rust code.\n  * Allows existing Rust types (not generated from a `.proto`) to be serialized and deserialized by adding attributes.\n  * Uses the [`bytes::{Buf, BufMut}`](https://github.com/carllerche/bytes) abstractions for serialization instead of `std::io::{Read, Write}`.\n  * Respects the Protobuf `package` specifier when organizing generated code into Rust modules.\n  * Preserves unknown enum values during deserialization.\n  * Does not include support for runtime reflection or message descriptors.\n\n\n### [\u00a7](https://docs.rs/prost/latest/prost/#using-prost-in-a-cargo-project)Using `prost` in a Cargo Project\nFirst, add `prost` and its public dependencies to your `Cargo.toml`:\n[\u24d8](https://docs.rs/prost/latest/prost/ \"This example is not tested\")```\n[dependencies]\nprost = \"0.14\"\nprost-types = \"0.14\"\n```\n\nThe recommended way to add `.proto` compilation to a Cargo project is to use the `prost-build` library. See the [`prost-build` documentation](https://docs.rs/prost-build/latest/prost_build/) for more details and examples.\nSee the [snazzy repository](https://github.com/danburkert/snazzy) for a simple start-to-finish example.\n#### [\u00a7](https://docs.rs/prost/latest/prost/#msrv)MSRV\n`prost` follows the `tokio-rs` project\u2019s MSRV model and supports 1.70. For more information on the tokio msrv policy you can check it out [here](https://github.com/tokio-rs/tokio/#supported-rust-versions)\n### [\u00a7](https://docs.rs/prost/latest/prost/#generated-code)Generated Code\n`prost` generates Rust code from source `.proto` files using the `proto2` or `proto3` syntax. `prost`\u2019s goal is to make the generated code as simple as possible.\n#### [\u00a7](https://docs.rs/prost/latest/prost/#protoc)`protoc`\nWith `prost-build` v0.11 release, `protoc` will be required to invoke `compile_protos` (unless `skip_protoc` is enabled). Prost will no longer provide bundled `protoc` or attempt to compile `protoc` for users. For install instructions for `protoc`, please check out the [protobuf install](https://github.com/protocolbuffers/protobuf#protobuf-compiler-installation) instructions.\n#### [\u00a7](https://docs.rs/prost/latest/prost/#packages)Packages\nProst can now generate code for `.proto` files that don\u2019t have a package spec. `prost` will translate the Protobuf package into a Rust module. For example, given the `package` specifier:\n```\npackage foo.bar;\n```\n\nAll Rust types generated from the file will be in the `foo::bar` module.\n#### [\u00a7](https://docs.rs/prost/latest/prost/#messages)Messages\nGiven a simple message declaration:\n```\n// Sample message.\nmessage Foo {\n}\n```\n\n`prost` will generate the following Rust struct:\n[\u24d8](https://docs.rs/prost/latest/prost/ \"This example is not tested\")```\n/// Sample message.\n#[derive(Clone, Debug, PartialEq, Message)]\npub struct Foo {\n}\n```\n\n#### [\u00a7](https://docs.rs/prost/latest/prost/#fields-1)Fields\nFields in Protobuf messages are translated into Rust as public struct fields of the corresponding type.\n##### [\u00a7](https://docs.rs/prost/latest/prost/#scalar-values)Scalar Values\nScalar value types are converted as follows:\nProtobuf Type| Rust Type  \n---|---  \n`double`| `f64`  \n`float`| `f32`  \n`int32`| `i32`  \n`int64`| `i64`  \n`uint32`| `u32`  \n`uint64`| `u64`  \n`sint32`| `i32`  \n`sint64`| `i64`  \n`fixed32`| `u32`  \n`fixed64`| `u64`  \n`sfixed32`| `i32`  \n`sfixed64`| `i64`  \n`bool`| `bool`  \n`string`| `String`  \n`bytes`| `Vec<u8>`  \n##### [\u00a7](https://docs.rs/prost/latest/prost/#enumerations)Enumerations\nAll `.proto` enumeration types convert to the Rust `i32` type. Additionally, each enumeration type gets a corresponding Rust `enum` type. For example, this `proto` enum:\n```\nenum PhoneType {\n MOBILE = 0;\n HOME = 1;\n WORK = 2;\n}\n```\n\ngets this corresponding Rust enum [1](https://docs.rs/prost/latest/prost/#fn1):\n[\u24d8](https://docs.rs/prost/latest/prost/ \"This example is not tested\")```\npub enum PhoneType {\n  Mobile = 0,\n  Home = 1,\n  Work = 2,\n}\n```\n\nYou can convert a `PhoneType` value to an `i32` by doing:\n[\u24d8](https://docs.rs/prost/latest/prost/ \"This example is not tested\")```\nPhoneType::Mobile as i32\n```\n\nThe `#[derive(::prost::Enumeration)]` annotation added to the generated `PhoneType` adds these associated functions to the type:\n[\u24d8](https://docs.rs/prost/latest/prost/ \"This example is not tested\")```\nimpl PhoneType {\n  pub fn is_valid(value: i32) -> bool { ... }\n  #[deprecated]\n  pub fn from_i32(value: i32) -> Option<PhoneType> { ... }\n}\n```\n\nIt also adds an `impl TryFrom<i32> for PhoneType`, so you can convert an `i32` to its corresponding `PhoneType` value by doing, for example:\n[\u24d8](https://docs.rs/prost/latest/prost/ \"This example is not tested\")```\nlet phone_type = 2i32;\nmatch PhoneType::try_from(phone_type) {\n  Ok(PhoneType::Mobile) => ...,\n  Ok(PhoneType::Home) => ...,\n  Ok(PhoneType::Work) => ...,\n  Err(_) => ...,\n}\n```\n\nAdditionally, wherever a `proto` enum is used as a field in a `Message`, the message will have \u2018accessor\u2019 methods to get/set the value of the field as the Rust enum type. For instance, this proto `PhoneNumber` message that has a field named `type` of type `PhoneType`:\n```\nmessage PhoneNumber {\n string number = 1;\n PhoneType type = 2;\n}\n```\n\nwill become the following Rust type [2](https://docs.rs/prost/latest/prost/#fn2) with methods `type` and `set_type`:\n[\u24d8](https://docs.rs/prost/latest/prost/ \"This example is not tested\")```\npub struct PhoneNumber {\n  pub number: String,\n  pub r#type: i32, // the `r#` is needed because `type` is a Rust keyword\n}\nimpl PhoneNumber {\n  pub fn r#type(&self) -> PhoneType { ... }\n  pub fn set_type(&mut self, value: PhoneType) { ... }\n}\n```\n\nNote that the getter methods will return the Rust enum\u2019s default value if the field has an invalid `i32` value.\nThe `enum` type isn\u2019t used directly as a field, because the Protobuf spec mandates that enumerations values are \u2018open\u2019, and decoding unrecognized enumeration values must be possible.\n##### [\u00a7](https://docs.rs/prost/latest/prost/#field-modifiers)Field Modifiers\nProtobuf scalar value and enumeration message fields can have a modifier depending on the Protobuf version. Modifiers change the corresponding type of the Rust field:\n`.proto` Version| Modifier| Rust Type  \n---|---|---  \n`proto2`| `optional`| `Option<T>`  \n`proto2`| `required`| `T`  \n`proto3`| default| `T` for scalar types, `Option<T>` otherwise  \n`proto3`| `optional`| `Option<T>`  \n`proto2`/`proto3`| `repeated`| `Vec<T>`  \nNote that in `proto3` the default representation for all user-defined message types is `Option<T>`, and for scalar types just `T` (during decoding, a missing value is populated by `T::default()`). If you need a witness of the presence of a scalar type `T`, use the `optional` modifier to enforce an `Option<T>` representation in the generated Rust struct.\n##### [\u00a7](https://docs.rs/prost/latest/prost/#map-fields)Map Fields\nMap fields are converted to a Rust `HashMap` with key and value type converted from the Protobuf key and value types.\n##### [\u00a7](https://docs.rs/prost/latest/prost/#message-fields)Message Fields\nMessage fields are converted to the corresponding struct type. The table of field modifiers above applies to message fields, except that `proto3` message fields without a modifier (the default) will be wrapped in an `Option`. Typically message fields are unboxed. `prost` will automatically box a message field if the field type and the parent type are recursively nested in order to avoid an infinite sized struct.\n##### [\u00a7](https://docs.rs/prost/latest/prost/#oneof-fields)Oneof Fields\nOneof fields convert to a Rust enum. Protobuf `oneof`s types are not named, so `prost` uses the name of the `oneof` field for the resulting Rust enum, and defines the enum in a module under the struct. For example, a `proto3` message such as:\n```\nmessage Foo {\n oneof widget {\n  int32 quux = 1;\n  string bar = 2;\n }\n}\n```\n\ngenerates the following Rust[3](https://docs.rs/prost/latest/prost/#fn3):\n[\u24d8](https://docs.rs/prost/latest/prost/ \"This example is not tested\")```\npub struct Foo {\n  pub widget: Option<foo::Widget>,\n}\npub mod foo {\n  pub enum Widget {\n    Quux(i32),\n    Bar(String),\n  }\n}\n```\n\n`oneof` fields are always wrapped in an `Option`.\n#### [\u00a7](https://docs.rs/prost/latest/prost/#services)Services\n`prost-build` allows a custom code-generator to be used for processing `service` definitions. This can be used to output Rust traits according to an application\u2019s specific needs.\n#### [\u00a7](https://docs.rs/prost/latest/prost/#generated-code-example)Generated Code Example\nExample `.proto` file:\n```\nsyntax = \"proto3\";\npackage tutorial;\nmessage Person {\n string name = 1;\n int32 id = 2; // Unique ID number for this person.\n string email = 3;\n enum PhoneType {\n  MOBILE = 0;\n  HOME = 1;\n  WORK = 2;\n }\n message PhoneNumber {\n  string number = 1;\n  PhoneType type = 2;\n }\n repeated PhoneNumber phones = 4;\n}\n// Our address book file is just one of these.\nmessage AddressBook {\n repeated Person people = 1;\n}\n```\n\nand the generated Rust code (`tutorial.rs`):\n[\u24d8](https://docs.rs/prost/latest/prost/ \"This example is not tested\")```\n#[derive(Clone, PartialEq, ::prost::Message)]\npub struct Person {\n  #[prost(string, tag=\"1\")]\n  pub name: ::prost::alloc::string::String,\n  /// Unique ID number for this person.\n  #[prost(int32, tag=\"2\")]\n  pub id: i32,\n  #[prost(string, tag=\"3\")]\n  pub email: ::prost::alloc::string::String,\n  #[prost(message, repeated, tag=\"4\")]\n  pub phones: ::prost::alloc::vec::Vec<person::PhoneNumber>,\n}\n/// Nested message and enum types in `Person`.\npub mod person {\n  #[derive(Clone, PartialEq, ::prost::Message)]\n  pub struct PhoneNumber {\n    #[prost(string, tag=\"1\")]\n    pub number: ::prost::alloc::string::String,\n    #[prost(enumeration=\"PhoneType\", tag=\"2\")]\n    pub r#type: i32,\n  }\n  #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]\n  #[repr(i32)]\n  pub enum PhoneType {\n    Mobile = 0,\n    Home = 1,\n    Work = 2,\n  }\n}\n/// Our address book file is just one of these.\n#[derive(Clone, PartialEq, ::prost::Message)]\npub struct AddressBook {\n  #[prost(message, repeated, tag=\"1\")]\n  pub people: ::prost::alloc::vec::Vec<Person>,\n}\n```\n\n### [\u00a7](https://docs.rs/prost/latest/prost/#accessing-the-protoc-filedescriptorset)Accessing the `protoc` `FileDescriptorSet`\nThe `prost_build::Config::file_descriptor_set_path` option can be used to emit a file descriptor set during the build & code generation step. When used in conjunction with the `std::include_bytes` macro and the `prost_types::FileDescriptorSet` type, applications and libraries using Prost can implement introspection capabilities requiring details from the original `.proto` files.\n### [\u00a7](https://docs.rs/prost/latest/prost/#using-prost-in-a-no_std-crate)Using `prost` in a `no_std` Crate\n`prost` is compatible with `no_std` crates. To enable `no_std` support, disable the `std` features in `prost` and `prost-types`:\n[\u24d8](https://docs.rs/prost/latest/prost/ \"This example is not tested\")```\n[dependencies]\nprost = { version = \"0.14.1\", default-features = false, features = [\"derive\"] }\nprost-types = { version = \"0.14.1\", default-features = false }\n```\n\nAdditionally, configure `prost-build` to output `BTreeMap`s instead of `HashMap`s for all Protobuf `map` fields in your `build.rs`:\n[\u24d8](https://docs.rs/prost/latest/prost/ \"This example is not tested\")```\nlet mut config = prost_build::Config::new();\nconfig.btree_map(&[\".\"]);\n```\n\nWhen using edition 2015, it may be necessary to add an `extern crate core;` directive to the crate which includes `prost`-generated code.\n### [\u00a7](https://docs.rs/prost/latest/prost/#serializing-existing-types)Serializing Existing Types\n`prost` uses a custom derive macro to handle encoding and decoding types, which means that if your existing Rust type is compatible with Protobuf types, you can serialize and deserialize it by adding the appropriate derive and field annotations.\nCurrently the best documentation on adding annotations is to look at the generated code examples above.\n#### [\u00a7](https://docs.rs/prost/latest/prost/#tag-inference-for-existing-types)Tag Inference for Existing Types\nProst automatically infers tags for the struct.\nFields are tagged sequentially in the order they are specified, starting with `1`.\nYou may skip tags which have been reserved, or where there are gaps between sequentially occurring tag values by specifying the tag number to skip to with the `tag` attribute on the first field after the gap. The following fields will be tagged sequentially starting from the next number.\n[\u24d8](https://docs.rs/prost/latest/prost/ \"This example is not tested\")```\nuse prost;\nuse prost::{Enumeration, Message};\n#[derive(Clone, PartialEq, Message)]\nstruct Person {\n  #[prost(string, tag = \"1\")]\n  pub id: String, // tag=1\n  // NOTE: Old \"name\" field has been removed\n  // pub name: String, // tag=2 (Removed)\n  #[prost(string, tag = \"6\")]\n  pub given_name: String, // tag=6\n  #[prost(string)]\n  pub family_name: String, // tag=7\n  #[prost(string)]\n  pub formatted_name: String, // tag=8\n  #[prost(uint32, tag = \"3\")]\n  pub age: u32, // tag=3\n  #[prost(uint32)]\n  pub height: u32, // tag=4\n  #[prost(enumeration = \"Gender\")]\n  pub gender: i32, // tag=5\n  // NOTE: Skip to less commonly occurring fields\n  #[prost(string, tag = \"16\")]\n  pub name_prefix: String, // tag=16 (eg. mr/mrs/ms)\n  #[prost(string)]\n  pub name_suffix: String, // tag=17 (eg. jr/esq)\n  #[prost(string)]\n  pub maiden_name: String, // tag=18\n}\n#[derive(Clone, Copy, Debug, PartialEq, Eq, Enumeration)]\npub enum Gender {\n  Unknown = 0,\n  Female = 1,\n  Male = 2,\n}\n```\n\n### [\u00a7](https://docs.rs/prost/latest/prost/#nix)Nix\nThe prost project maintains flakes support for local development. Once you have nix and nix flakes setup you can just run `nix develop` to get a shell configured with the required dependencies to compile the whole project.\n### [\u00a7](https://docs.rs/prost/latest/prost/#feature-flags)Feature Flags\n  * `std`: Enable integration with standard library. Disable this feature for `no_std` support. This feature is enabled by default.\n  * `derive`: Enable integration with `prost-derive`. Disable this feature to reduce compile times. This feature is enabled by default.\n  * `prost-derive`: Deprecated. Alias for `derive` feature.\n  * `no-recursion-limit`: Disable the recursion limit. The recursion limit is 100 and cannot be customized.\n\n\n### [\u00a7](https://docs.rs/prost/latest/prost/#faq)FAQ\n  1. **Could`prost` be implemented as a serializer for [Serde](https://serde.rs/)?**\n\n\nProbably not, however I would like to hear from a Serde expert on the matter. There are two complications with trying to serialize Protobuf messages with Serde:\n  * Protobuf fields require a numbered tag, and currently there appears to be no mechanism suitable for this in `serde`.\n  * The mapping of Protobuf type to Rust type is not 1-to-1. As a result, trait-based approaches to dispatching don\u2019t work very well. Example: six different Protobuf field types correspond to a Rust `Vec<i32>`: `repeated int32`, `repeated sint32`, `repeated sfixed32`, and their packed counterparts.\n\n\nBut it is possible to place `serde` derive tags onto the generated types, so the same structure can support both `prost` and `Serde`.\n  1. **I get errors when trying to run`cargo test` on MacOS**\n\n\nIf the errors are about missing `autoreconf` or similar, you can probably fix them by running\n[\u24d8](https://docs.rs/prost/latest/prost/ \"This example is not tested\")```\nbrew install automake\nbrew install libtool\n```\n\n### [\u00a7](https://docs.rs/prost/latest/prost/#license)License\n`prost` is distributed under the terms of the Apache License (Version 2.0).\nSee [LICENSE](https://github.com/tokio-rs/prost/blob/master/LICENSE) for details.\nCopyright 2022 Dan Burkert & Tokio Contributors\n  1. Annotations have been elided for clarity. See below for a full example. [\u21a9](https://docs.rs/prost/latest/prost/#fnref1)\n  2. Annotations have been elided for clarity. See below for a full example. [\u21a9](https://docs.rs/prost/latest/prost/#fnref2)\n  3. Annotations have been elided for clarity. See below for a full example. [\u21a9](https://docs.rs/prost/latest/prost/#fnref3)\n\n\n## Re-exports[\u00a7](https://docs.rs/prost/latest/prost/#reexports)\n\n`pub use bytes[](https://docs.rs/bytes/1.10.1/x86_64-unknown-linux-gnu/bytes/index.html \"mod bytes\");`\n\n## Structs[\u00a7](https://docs.rs/prost/latest/prost/#structs)\n\n[DecodeError](https://docs.rs/prost/latest/prost/struct.DecodeError.html \"struct prost::DecodeError\")\n    A Protobuf message decoding error.\n\n[EncodeError](https://docs.rs/prost/latest/prost/struct.EncodeError.html \"struct prost::EncodeError\")\n    A Protobuf message encoding error.\n\n[UnknownEnumValue](https://docs.rs/prost/latest/prost/struct.UnknownEnumValue.html \"struct prost::UnknownEnumValue\")\n    An error indicating that an unknown enumeration value was encountered.\n## Traits[\u00a7](https://docs.rs/prost/latest/prost/#traits)\n\n[Message](https://docs.rs/prost/latest/prost/trait.Message.html \"trait prost::Message\")\n    A Protocol Buffers message.\n\n[Name](https://docs.rs/prost/latest/prost/trait.Name.html \"trait prost::Name\")\n    Associate a type name with a [`Message`](https://docs.rs/prost/latest/prost/trait.Message.html \"trait prost::Message\") type.\n## Functions[\u00a7](https://docs.rs/prost/latest/prost/#functions)\n\n[decode_length_delimiter](https://docs.rs/prost/latest/prost/fn.decode_length_delimiter.html \"fn prost::decode_length_delimiter\")\n    Decodes a length delimiter from the buffer.\n\n[encode_length_delimiter](https://docs.rs/prost/latest/prost/fn.encode_length_delimiter.html \"fn prost::encode_length_delimiter\")\n    Encodes a length delimiter to the buffer.\n\n[length_delimiter_len](https://docs.rs/prost/latest/prost/fn.length_delimiter_len.html \"fn prost::length_delimiter_len\")\n    Returns the encoded length of a length delimiter.\n",
              "markdown_with_citations": "[](https://docs.rs/prost/latest/prost/all.html \"show sidebar\")\n# Crate prostCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\n![continuous integration\u27e84\u27e9](https://github.com/tokio-rs/prost/actions/workflows/ci.yml?query=branch%3Amaster) ![Documentation\u27e85\u27e9](https://docs.rs/prost/) ![Crate\u27e86\u27e9](https://crates.io/crates/prost) ![Dependency Status\u27e87\u27e9](https://deps.rs/repo/github/tokio-rs/prost) ![Discord\u27e88\u27e9](https://discord.gg/tokio)\n## \u00a7\u27e89\u27e9 _PROST!_\n`prost` is a Protocol Buffers\u27e810\u27e9 implementation for the Rust Language\u27e811\u27e9. `prost` generates simple, idiomatic Rust code from `proto2` and `proto3` files.\nCompared to other Protocol Buffers implementations, `prost`\n  * Generates simple, idiomatic, and readable Rust types by taking advantage of Rust `derive` attributes.\n  * Retains comments from `.proto` files in generated Rust code.\n  * Allows existing Rust types (not generated from a `.proto`) to be serialized and deserialized by adding attributes.\n  * Uses the `bytes::{Buf, BufMut}`\u27e812\u27e9 abstractions for serialization instead of `std::io::{Read, Write}`.\n  * Respects the Protobuf `package` specifier when organizing generated code into Rust modules.\n  * Preserves unknown enum values during deserialization.\n  * Does not include support for runtime reflection or message descriptors.\n\n\n### \u00a7\u27e813\u27e9Using `prost` in a Cargo Project\nFirst, add `prost` and its public dependencies to your `Cargo.toml`:\n\u24d8\u27e814\u27e9```\n[dependencies]\nprost = \"0.14\"\nprost-types = \"0.14\"\n```\n\nThe recommended way to add `.proto` compilation to a Cargo project is to use the `prost-build` library. See the `prost-build` documentation\u27e815\u27e9 for more details and examples.\nSee the snazzy repository\u27e816\u27e9 for a simple start-to-finish example.\n#### \u00a7\u27e817\u27e9MSRV\n`prost` follows the `tokio-rs` project\u2019s MSRV model and supports 1.70. For more information on the tokio msrv policy you can check it out here\u27e818\u27e9\n### \u00a7\u27e819\u27e9Generated Code\n`prost` generates Rust code from source `.proto` files using the `proto2` or `proto3` syntax. `prost`\u2019s goal is to make the generated code as simple as possible.\n#### \u00a7\u27e820\u27e9`protoc`\nWith `prost-build` v0.11 release, `protoc` will be required to invoke `compile_protos` (unless `skip_protoc` is enabled). Prost will no longer provide bundled `protoc` or attempt to compile `protoc` for users. For install instructions for `protoc`, please check out the protobuf install\u27e821\u27e9 instructions.\n#### \u00a7\u27e822\u27e9Packages\nProst can now generate code for `.proto` files that don\u2019t have a package spec. `prost` will translate the Protobuf package into a Rust module. For example, given the `package` specifier:\n```\npackage foo.bar;\n```\n\nAll Rust types generated from the file will be in the `foo::bar` module.\n#### \u00a7\u27e823\u27e9Messages\nGiven a simple message declaration:\n```\n// Sample message.\nmessage Foo {\n}\n```\n\n`prost` will generate the following Rust struct:\n\u24d8\u27e814\u27e9```\n/// Sample message.\n#[derive(Clone, Debug, PartialEq, Message)]\npub struct Foo {\n}\n```\n\n#### \u00a7\u27e824\u27e9Fields\nFields in Protobuf messages are translated into Rust as public struct fields of the corresponding type.\n##### \u00a7\u27e825\u27e9Scalar Values\nScalar value types are converted as follows:\nProtobuf Type| Rust Type  \n---|---  \n`double`| `f64`  \n`float`| `f32`  \n`int32`| `i32`  \n`int64`| `i64`  \n`uint32`| `u32`  \n`uint64`| `u64`  \n`sint32`| `i32`  \n`sint64`| `i64`  \n`fixed32`| `u32`  \n`fixed64`| `u64`  \n`sfixed32`| `i32`  \n`sfixed64`| `i64`  \n`bool`| `bool`  \n`string`| `String`  \n`bytes`| `Vec<u8>`  \n##### \u00a7\u27e826\u27e9Enumerations\nAll `.proto` enumeration types convert to the Rust `i32` type. Additionally, each enumeration type gets a corresponding Rust `enum` type. For example, this `proto` enum:\n```\nenum PhoneType {\n MOBILE = 0;\n HOME = 1;\n WORK = 2;\n}\n```\n\ngets this corresponding Rust enum 1\u27e827\u27e9:\n\u24d8\u27e814\u27e9```\npub enum PhoneType {\n  Mobile = 0,\n  Home = 1,\n  Work = 2,\n}\n```\n\nYou can convert a `PhoneType` value to an `i32` by doing:\n\u24d8\u27e814\u27e9```\nPhoneType::Mobile as i32\n```\n\nThe `#[derive(::prost::Enumeration)]` annotation added to the generated `PhoneType` adds these associated functions to the type:\n\u24d8\u27e814\u27e9```\nimpl PhoneType {\n  pub fn is_valid(value: i32) -> bool { ... }\n  #[deprecated]\n  pub fn from_i32(value: i32) -> Option<PhoneType> { ... }\n}\n```\n\nIt also adds an `impl TryFrom<i32> for PhoneType`, so you can convert an `i32` to its corresponding `PhoneType` value by doing, for example:\n\u24d8\u27e814\u27e9```\nlet phone_type = 2i32;\nmatch PhoneType::try_from(phone_type) {\n  Ok(PhoneType::Mobile) => ...,\n  Ok(PhoneType::Home) => ...,\n  Ok(PhoneType::Work) => ...,\n  Err(_) => ...,\n}\n```\n\nAdditionally, wherever a `proto` enum is used as a field in a `Message`, the message will have \u2018accessor\u2019 methods to get/set the value of the field as the Rust enum type. For instance, this proto `PhoneNumber` message that has a field named `type` of type `PhoneType`:\n```\nmessage PhoneNumber {\n string number = 1;\n PhoneType type = 2;\n}\n```\n\nwill become the following Rust type 2\u27e828\u27e9 with methods `type` and `set_type`:\n\u24d8\u27e814\u27e9```\npub struct PhoneNumber {\n  pub number: String,\n  pub r#type: i32, // the `r#` is needed because `type` is a Rust keyword\n}\nimpl PhoneNumber {\n  pub fn r#type(&self) -> PhoneType { ... }\n  pub fn set_type(&mut self, value: PhoneType) { ... }\n}\n```\n\nNote that the getter methods will return the Rust enum\u2019s default value if the field has an invalid `i32` value.\nThe `enum` type isn\u2019t used directly as a field, because the Protobuf spec mandates that enumerations values are \u2018open\u2019, and decoding unrecognized enumeration values must be possible.\n##### \u00a7\u27e829\u27e9Field Modifiers\nProtobuf scalar value and enumeration message fields can have a modifier depending on the Protobuf version. Modifiers change the corresponding type of the Rust field:\n`.proto` Version| Modifier| Rust Type  \n---|---|---  \n`proto2`| `optional`| `Option<T>`  \n`proto2`| `required`| `T`  \n`proto3`| default| `T` for scalar types, `Option<T>` otherwise  \n`proto3`| `optional`| `Option<T>`  \n`proto2`/`proto3`| `repeated`| `Vec<T>`  \nNote that in `proto3` the default representation for all user-defined message types is `Option<T>`, and for scalar types just `T` (during decoding, a missing value is populated by `T::default()`). If you need a witness of the presence of a scalar type `T`, use the `optional` modifier to enforce an `Option<T>` representation in the generated Rust struct.\n##### \u00a7\u27e830\u27e9Map Fields\nMap fields are converted to a Rust `HashMap` with key and value type converted from the Protobuf key and value types.\n##### \u00a7\u27e831\u27e9Message Fields\nMessage fields are converted to the corresponding struct type. The table of field modifiers above applies to message fields, except that `proto3` message fields without a modifier (the default) will be wrapped in an `Option`. Typically message fields are unboxed. `prost` will automatically box a message field if the field type and the parent type are recursively nested in order to avoid an infinite sized struct.\n##### \u00a7\u27e832\u27e9Oneof Fields\nOneof fields convert to a Rust enum. Protobuf `oneof`s types are not named, so `prost` uses the name of the `oneof` field for the resulting Rust enum, and defines the enum in a module under the struct. For example, a `proto3` message such as:\n```\nmessage Foo {\n oneof widget {\n  int32 quux = 1;\n  string bar = 2;\n }\n}\n```\n\ngenerates the following Rust3\u27e833\u27e9:\n\u24d8\u27e814\u27e9```\npub struct Foo {\n  pub widget: Option<foo::Widget>,\n}\npub mod foo {\n  pub enum Widget {\n    Quux(i32),\n    Bar(String),\n  }\n}\n```\n\n`oneof` fields are always wrapped in an `Option`.\n#### \u00a7\u27e834\u27e9Services\n`prost-build` allows a custom code-generator to be used for processing `service` definitions. This can be used to output Rust traits according to an application\u2019s specific needs.\n#### \u00a7\u27e835\u27e9Generated Code Example\nExample `.proto` file:\n```\nsyntax = \"proto3\";\npackage tutorial;\nmessage Person {\n string name = 1;\n int32 id = 2; // Unique ID number for this person.\n string email = 3;\n enum PhoneType {\n  MOBILE = 0;\n  HOME = 1;\n  WORK = 2;\n }\n message PhoneNumber {\n  string number = 1;\n  PhoneType type = 2;\n }\n repeated PhoneNumber phones = 4;\n}\n// Our address book file is just one of these.\nmessage AddressBook {\n repeated Person people = 1;\n}\n```\n\nand the generated Rust code (`tutorial.rs`):\n\u24d8\u27e814\u27e9```\n#[derive(Clone, PartialEq, ::prost::Message)]\npub struct Person {\n  #[prost(string, tag=\"1\")]\n  pub name: ::prost::alloc::string::String,\n  /// Unique ID number for this person.\n  #[prost(int32, tag=\"2\")]\n  pub id: i32,\n  #[prost(string, tag=\"3\")]\n  pub email: ::prost::alloc::string::String,\n  #[prost(message, repeated, tag=\"4\")]\n  pub phones: ::prost::alloc::vec::Vec<person::PhoneNumber>,\n}\n/// Nested message and enum types in `Person`.\npub mod person {\n  #[derive(Clone, PartialEq, ::prost::Message)]\n  pub struct PhoneNumber {\n    #[prost(string, tag=\"1\")]\n    pub number: ::prost::alloc::string::String,\n    #[prost(enumeration=\"PhoneType\", tag=\"2\")]\n    pub r#type: i32,\n  }\n  #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]\n  #[repr(i32)]\n  pub enum PhoneType {\n    Mobile = 0,\n    Home = 1,\n    Work = 2,\n  }\n}\n/// Our address book file is just one of these.\n#[derive(Clone, PartialEq, ::prost::Message)]\npub struct AddressBook {\n  #[prost(message, repeated, tag=\"1\")]\n  pub people: ::prost::alloc::vec::Vec<Person>,\n}\n```\n\n### \u00a7\u27e836\u27e9Accessing the `protoc` `FileDescriptorSet`\nThe `prost_build::Config::file_descriptor_set_path` option can be used to emit a file descriptor set during the build & code generation step. When used in conjunction with the `std::include_bytes` macro and the `prost_types::FileDescriptorSet` type, applications and libraries using Prost can implement introspection capabilities requiring details from the original `.proto` files.\n### \u00a7\u27e837\u27e9Using `prost` in a `no_std` Crate\n`prost` is compatible with `no_std` crates. To enable `no_std` support, disable the `std` features in `prost` and `prost-types`:\n\u24d8\u27e814\u27e9```\n[dependencies]\nprost = { version = \"0.14.1\", default-features = false, features = [\"derive\"] }\nprost-types = { version = \"0.14.1\", default-features = false }\n```\n\nAdditionally, configure `prost-build` to output `BTreeMap`s instead of `HashMap`s for all Protobuf `map` fields in your `build.rs`:\n\u24d8\u27e814\u27e9```\nlet mut config = prost_build::Config::new();\nconfig.btree_map(&[\".\"]);\n```\n\nWhen using edition 2015, it may be necessary to add an `extern crate core;` directive to the crate which includes `prost`-generated code.\n### \u00a7\u27e838\u27e9Serializing Existing Types\n`prost` uses a custom derive macro to handle encoding and decoding types, which means that if your existing Rust type is compatible with Protobuf types, you can serialize and deserialize it by adding the appropriate derive and field annotations.\nCurrently the best documentation on adding annotations is to look at the generated code examples above.\n#### \u00a7\u27e839\u27e9Tag Inference for Existing Types\nProst automatically infers tags for the struct.\nFields are tagged sequentially in the order they are specified, starting with `1`.\nYou may skip tags which have been reserved, or where there are gaps between sequentially occurring tag values by specifying the tag number to skip to with the `tag` attribute on the first field after the gap. The following fields will be tagged sequentially starting from the next number.\n\u24d8\u27e814\u27e9```\nuse prost;\nuse prost::{Enumeration, Message};\n#[derive(Clone, PartialEq, Message)]\nstruct Person {\n  #[prost(string, tag = \"1\")]\n  pub id: String, // tag=1\n  // NOTE: Old \"name\" field has been removed\n  // pub name: String, // tag=2 (Removed)\n  #[prost(string, tag = \"6\")]\n  pub given_name: String, // tag=6\n  #[prost(string)]\n  pub family_name: String, // tag=7\n  #[prost(string)]\n  pub formatted_name: String, // tag=8\n  #[prost(uint32, tag = \"3\")]\n  pub age: u32, // tag=3\n  #[prost(uint32)]\n  pub height: u32, // tag=4\n  #[prost(enumeration = \"Gender\")]\n  pub gender: i32, // tag=5\n  // NOTE: Skip to less commonly occurring fields\n  #[prost(string, tag = \"16\")]\n  pub name_prefix: String, // tag=16 (eg. mr/mrs/ms)\n  #[prost(string)]\n  pub name_suffix: String, // tag=17 (eg. jr/esq)\n  #[prost(string)]\n  pub maiden_name: String, // tag=18\n}\n#[derive(Clone, Copy, Debug, PartialEq, Eq, Enumeration)]\npub enum Gender {\n  Unknown = 0,\n  Female = 1,\n  Male = 2,\n}\n```\n\n### \u00a7\u27e840\u27e9Nix\nThe prost project maintains flakes support for local development. Once you have nix and nix flakes setup you can just run `nix develop` to get a shell configured with the required dependencies to compile the whole project.\n### \u00a7\u27e841\u27e9Feature Flags\n  * `std`: Enable integration with standard library. Disable this feature for `no_std` support. This feature is enabled by default.\n  * `derive`: Enable integration with `prost-derive`. Disable this feature to reduce compile times. This feature is enabled by default.\n  * `prost-derive`: Deprecated. Alias for `derive` feature.\n  * `no-recursion-limit`: Disable the recursion limit. The recursion limit is 100 and cannot be customized.\n\n\n### \u00a7\u27e842\u27e9FAQ\n  1. **Could`prost` be implemented as a serializer for Serde\u27e843\u27e9?**\n\n\nProbably not, however I would like to hear from a Serde expert on the matter. There are two complications with trying to serialize Protobuf messages with Serde:\n  * Protobuf fields require a numbered tag, and currently there appears to be no mechanism suitable for this in `serde`.\n  * The mapping of Protobuf type to Rust type is not 1-to-1. As a result, trait-based approaches to dispatching don\u2019t work very well. Example: six different Protobuf field types correspond to a Rust `Vec<i32>`: `repeated int32`, `repeated sint32`, `repeated sfixed32`, and their packed counterparts.\n\n\nBut it is possible to place `serde` derive tags onto the generated types, so the same structure can support both `prost` and `Serde`.\n  1. **I get errors when trying to run`cargo test` on MacOS**\n\n\nIf the errors are about missing `autoreconf` or similar, you can probably fix them by running\n\u24d8\u27e814\u27e9```\nbrew install automake\nbrew install libtool\n```\n\n### \u00a7\u27e844\u27e9License\n`prost` is distributed under the terms of the Apache License (Version 2.0).\nSee LICENSE\u27e845\u27e9 for details.\nCopyright 2022 Dan Burkert & Tokio Contributors\n  1. Annotations have been elided for clarity. See below for a full example. \u21a9\u27e846\u27e9\n  2. Annotations have been elided for clarity. See below for a full example. \u21a9\u27e847\u27e9\n  3. Annotations have been elided for clarity. See below for a full example. \u21a9\u27e848\u27e9\n\n\n## Re-exports\u00a7\u27e849\u27e9\n\n`pub use bytes[](https://docs.rs/bytes/1.10.1/x86_64-unknown-linux-gnu/bytes/index.html \"mod bytes\");`\n\n## Structs\u00a7\u27e850\u27e9\n\nDecodeError\u27e851\u27e9\n    A Protobuf message decoding error.\n\nEncodeError\u27e852\u27e9\n    A Protobuf message encoding error.\n\nUnknownEnumValue\u27e853\u27e9\n    An error indicating that an unknown enumeration value was encountered.\n## Traits\u00a7\u27e854\u27e9\n\nMessage\u27e855\u27e9\n    A Protocol Buffers message.\n\nName\u27e856\u27e9\n    Associate a type name with a `Message`\u27e855\u27e9 type.\n## Functions\u00a7\u27e857\u27e9\n\ndecode_length_delimiter\u27e858\u27e9\n    Decodes a length delimiter from the buffer.\n\nencode_length_delimiter\u27e859\u27e9\n    Encodes a length delimiter to the buffer.\n\nlength_delimiter_len\u27e860\u27e9\n    Returns the encoded length of a length delimiter.\n",
              "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/prost/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/prost/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/prost/latest/src/prost/lib.rs.html#1-42: Source\n\u27e84\u27e9 https://github.com/tokio-rs/prost/actions/workflows/ci.yml/badge.svg?branch=master: ![continuous integration\n\u27e85\u27e9 https://docs.rs/prost/badge.svg: ![Documentation\n\u27e86\u27e9 https://img.shields.io/crates/v/prost.svg: ![Crate\n\u27e87\u27e9 https://deps.rs/repo/github/tokio-rs/prost/status.svg: ![Dependency Status\n\u27e88\u27e9 https://img.shields.io/discord/500028886025895936: ![Discord\n\u27e89\u27e9 https://docs.rs/prost/latest/prost/#prost: \u00a7\n\u27e810\u27e9 https://developers.google.com/protocol-buffers/: Protocol Buffers\n\u27e811\u27e9 https://www.rust-lang.org/: Rust Language\n\u27e812\u27e9 https://github.com/carllerche/bytes: `bytes::{Buf, BufMut}`\n\u27e813\u27e9 https://docs.rs/prost/latest/prost/#using-prost-in-a-cargo-project: \u00a7\n\u27e814\u27e9 https://docs.rs/prost/latest/prost/: This example is not tested - \u24d8\n\u27e815\u27e9 https://docs.rs/prost-build/latest/prost_build/: `prost-build` documentation\n\u27e816\u27e9 https://github.com/danburkert/snazzy: snazzy repository\n\u27e817\u27e9 https://docs.rs/prost/latest/prost/#msrv: \u00a7\n\u27e818\u27e9 https://github.com/tokio-rs/tokio/#supported-rust-versions: here\n\u27e819\u27e9 https://docs.rs/prost/latest/prost/#generated-code: \u00a7\n\u27e820\u27e9 https://docs.rs/prost/latest/prost/#protoc: \u00a7\n\u27e821\u27e9 https://github.com/protocolbuffers/protobuf#protobuf-compiler-installation: protobuf install\n\u27e822\u27e9 https://docs.rs/prost/latest/prost/#packages: \u00a7\n\u27e823\u27e9 https://docs.rs/prost/latest/prost/#messages: \u00a7\n\u27e824\u27e9 https://docs.rs/prost/latest/prost/#fields-1: \u00a7\n\u27e825\u27e9 https://docs.rs/prost/latest/prost/#scalar-values: \u00a7\n\u27e826\u27e9 https://docs.rs/prost/latest/prost/#enumerations: \u00a7\n\u27e827\u27e9 https://docs.rs/prost/latest/prost/#fn1: 1\n\u27e828\u27e9 https://docs.rs/prost/latest/prost/#fn2: 2\n\u27e829\u27e9 https://docs.rs/prost/latest/prost/#field-modifiers: \u00a7\n\u27e830\u27e9 https://docs.rs/prost/latest/prost/#map-fields: \u00a7\n\u27e831\u27e9 https://docs.rs/prost/latest/prost/#message-fields: \u00a7\n\u27e832\u27e9 https://docs.rs/prost/latest/prost/#oneof-fields: \u00a7\n\u27e833\u27e9 https://docs.rs/prost/latest/prost/#fn3: 3\n\u27e834\u27e9 https://docs.rs/prost/latest/prost/#services: \u00a7\n\u27e835\u27e9 https://docs.rs/prost/latest/prost/#generated-code-example: \u00a7\n\u27e836\u27e9 https://docs.rs/prost/latest/prost/#accessing-the-protoc-filedescriptorset: \u00a7\n\u27e837\u27e9 https://docs.rs/prost/latest/prost/#using-prost-in-a-no_std-crate: \u00a7\n\u27e838\u27e9 https://docs.rs/prost/latest/prost/#serializing-existing-types: \u00a7\n\u27e839\u27e9 https://docs.rs/prost/latest/prost/#tag-inference-for-existing-types: \u00a7\n\u27e840\u27e9 https://docs.rs/prost/latest/prost/#nix: \u00a7\n\u27e841\u27e9 https://docs.rs/prost/latest/prost/#feature-flags: \u00a7\n\u27e842\u27e9 https://docs.rs/prost/latest/prost/#faq: \u00a7\n\u27e843\u27e9 https://serde.rs/: Serde\n\u27e844\u27e9 https://docs.rs/prost/latest/prost/#license: \u00a7\n\u27e845\u27e9 https://github.com/tokio-rs/prost/blob/master/LICENSE: LICENSE\n\u27e846\u27e9 https://docs.rs/prost/latest/prost/#fnref1: \u21a9\n\u27e847\u27e9 https://docs.rs/prost/latest/prost/#fnref2: \u21a9\n\u27e848\u27e9 https://docs.rs/prost/latest/prost/#fnref3: \u21a9\n\u27e849\u27e9 https://docs.rs/prost/latest/prost/#reexports: \u00a7\n\u27e850\u27e9 https://docs.rs/prost/latest/prost/#structs: \u00a7\n\u27e851\u27e9 https://docs.rs/prost/latest/prost/struct.DecodeError.html: struct prost::DecodeError - DecodeError\n\u27e852\u27e9 https://docs.rs/prost/latest/prost/struct.EncodeError.html: struct prost::EncodeError - EncodeError\n\u27e853\u27e9 https://docs.rs/prost/latest/prost/struct.UnknownEnumValue.html: struct prost::UnknownEnumValue - UnknownEnumValue\n\u27e854\u27e9 https://docs.rs/prost/latest/prost/#traits: \u00a7\n\u27e855\u27e9 https://docs.rs/prost/latest/prost/trait.Message.html: trait prost::Message - Message\n\u27e856\u27e9 https://docs.rs/prost/latest/prost/trait.Name.html: trait prost::Name - Name\n\u27e857\u27e9 https://docs.rs/prost/latest/prost/#functions: \u00a7\n\u27e858\u27e9 https://docs.rs/prost/latest/prost/fn.decode_length_delimiter.html: fn prost::decode_length_delimiter - decode_length_delimiter\n\u27e859\u27e9 https://docs.rs/prost/latest/prost/fn.encode_length_delimiter.html: fn prost::encode_length_delimiter - encode_length_delimiter\n\u27e860\u27e9 https://docs.rs/prost/latest/prost/fn.length_delimiter_len.html: fn prost::length_delimiter_len - length_delimiter_len\n",
              "fit_markdown": "",
              "fit_html": ""
            },
            "structured_data": {},
            "quality_score": 4.0,
            "extraction_method": "crawl4ai",
            "error": null,
            "metadata": {
              "doc_type": "docs",
              "content_length": 19140,
              "has_structured_data": false,
              "crawl_success": true
            },
            "timestamp": "116962.8951624"
          },
          "lib_rs": {
            "url": "https://lib.rs/crates/prost",
            "title": "Untitled",
            "content": {
              "raw_markdown": "###  [39 releases](https://lib.rs/crates/prost/versions)\n0.14.1 |  Jun 18, 2025   \n---|---  \n0.13.5 |  Feb 12, 2025   \n0.13.4 |  Dec 6, 2024   \n0.13.3 |  Sep 21, 2024   \n0.1.0 |  Jun 25, 2017   \n#**3** in [Encoding](https://lib.rs/encoding \"Encoding and/or decoding data from one data format to another.\")\nDownload history 3328084/week @ 2025-03-09 3661980/week @ 2025-03-16 4064370/week @ 2025-03-23 2942031/week @ 2025-03-30 3049750/week @ 2025-04-06 2587235/week @ 2025-04-13 2585283/week @ 2025-04-20 2353676/week @ 2025-04-27 2502195/week @ 2025-05-04 2551963/week @ 2025-05-11 2579713/week @ 2025-05-18 2272360/week @ 2025-05-25 2568135/week @ 2025-06-01 2480950/week @ 2025-06-08 2452064/week @ 2025-06-15 2714838/week @ 2025-06-22\n**10,330,293** downloads per month Used in [**5,381** crates (2,476 directly)](https://lib.rs/crates/prost/rev)\n**Apache-2.0**\n105KB  2.5K  SLoC\n[![continuous integration](https://img.gs/czjpqfbdkz/full/https://github.com/tokio-rs/prost/actions/workflows/ci.yml/badge.svg?branch=master)](https://github.com/tokio-rs/prost/actions/workflows/ci.yml?query=branch%3Amaster) [![Documentation](https://img.gs/czjpqfbdkz/full/https://docs.rs/prost/badge.svg)](https://docs.rs/prost/) [![Crate](https://img.shields.io/crates/v/prost.svg)](https://crates.io/crates/prost) [![Dependency Status](https://img.gs/czjpqfbdkz/full/https://deps.rs/repo/github/tokio-rs/prost/status.svg)](https://deps.rs/repo/github/tokio-rs/prost) [![Discord](https://img.shields.io/discord/500028886025895936)](https://discord.gg/tokio)\n# _PROST!_\n``prost`` is a [Protocol Buffers](https://developers.google.com/protocol-buffers/) implementation for the [Rust Language](https://www.rust-lang.org/). ``prost`` generates simple, idiomatic Rust code from ``proto2`` and ``proto3`` files.\nCompared to other Protocol Buffers implementations, ``prost``\n  * Generates simple, idiomatic, and readable Rust types by taking advantage of Rust ``derive`` attributes.\n  * Retains comments from ```.`proto`` files in generated Rust code.\n  * Allows existing Rust types (not generated from a ```.`proto``) to be serialized and deserialized by adding attributes.\n  * Uses the [```bytes`::````{`Buf`,` BufMut```}````](https://github.com/carllerche/bytes) abstractions for serialization instead of ```std`::```io`::````{`Read`,` Write```}````.\n  * Respects the Protobuf ``package`` specifier when organizing generated code into Rust modules.\n  * Preserves unknown enum values during deserialization.\n  * Does not include support for runtime reflection or message descriptors.\n\n\n## Using ``prost`` in a Cargo Project\nFirst, add ``prost`` and its public dependencies to your ``Cargo.toml``:\n```\n`[dependencies]\nprost = \"0.14\"\n# Only necessary if using Protobuf well-known types:\nprost-types = \"0.14\"\n`\n```\n\nThe recommended way to add ```.`proto`` compilation to a Cargo project is to use the ``prost-build`` library. See the [``prost-build`` documentation](https://docs.rs/prost-build/latest/prost_build/) for more details and examples.\nSee the [snazzy repository](https://github.com/danburkert/snazzy) for a simple start-to-finish example.\n### MSRV\n``prost`` follows the ``tokio-rs`` project's MSRV model and supports 1.70. For more information on the tokio msrv policy you can check it out [here](https://github.com/tokio-rs/tokio/#supported-rust-versions)\n## Generated Code\n``prost`` generates Rust code from source ```.`proto`` files using the ``proto2`` or ``proto3`` syntax. ``prost``'s goal is to make the generated code as simple as possible.\n### ``protoc``\nWith ``prost-build`` v0.11 release, ``protoc`` will be required to invoke ``compile_protos`` (unless ``skip_protoc`` is enabled). Prost will no longer provide bundled ``protoc`` or attempt to compile ``protoc`` for users. For install instructions for ``protoc``, please check out the [protobuf install](https://github.com/protocolbuffers/protobuf#protobuf-compiler-installation) instructions.\n### Packages\nProst can now generate code for ```.`proto`` files that don't have a package spec. ``prost`` will translate the Protobuf package into a Rust module. For example, given the ``package`` specifier:\n```\n`package foo`.`bar`;`\n`\n```\n\nAll Rust types generated from the file will be in the ```foo`::``bar`` module.\n### Messages\nGiven a simple message declaration:\n```\n```//` Sample message.`\nmessage Foo ``{`\n```}``\n`\n```\n\n``prost`` will generate the following Rust struct:\n```\n```///` Sample message.`\n``#``[``derive```(```Clone`,` Debug`,` PartialEq`,` Message```)```]``\n``pub` `struct` ```Foo` ````{`\n```}```\n`\n```\n\n### Fields\nFields in Protobuf messages are translated into Rust as public struct fields of the corresponding type.\n#### Scalar Values\nScalar value types are converted as follows:\nProtobuf Type | Rust Type  \n---|---  \n``double`` | ```f64```  \n``float`` | ```f32```  \n``int32`` | ```i32```  \n``int64`` | ```i64```  \n``uint32`` | ```u32```  \n``uint64`` | ```u64```  \n``sint32`` | ```i32```  \n``sint64`` | ```i64```  \n``fixed32`` | ```u32```  \n``fixed64`` | ```u64```  \n``sfixed32`` | ```i32```  \n``sfixed64`` | ```i64```  \n```bool``` | ```bool```  \n``string`` | ```String```  \n``bytes`` | ````Vec``<``u8``>````  \n#### Enumerations\nAll ```.`proto`` enumeration types convert to the Rust ```i32``` type. Additionally, each enumeration type gets a corresponding Rust ```enum``` type. For example, this ``proto`` enum:\n```\n```enum` `PhoneType` ``{`\n `MOBILE` `=` `0``;`\n `HOME` `=` `1``;`\n `WORK` `=` `2``;`\n```}```\n`\n```\n\ngets this corresponding Rust enum [^1]:\n```\n```pub` `enum` `PhoneType` ``{`\n  Mobile `=` `0``,`\n  Home `=` `1``,`\n  Work `=` `2``,`\n```}```\n`\n```\n\n[^1]: Annotations have been elided for clarity. See below for a full example.\nYou can convert a ``PhoneType`` value to an ```i32``` by doing:\n```\n``PhoneType`::``Mobile `as` `i32`\n`\n```\n\nThe ````#``[``derive```(```::prost::Enumeration```)```]```` annotation added to the generated ``PhoneType`` adds these associated functions to the type:\n```\n```impl` ```PhoneType` ````{`\n  ``pub` `fn` `is_valid`````(``value``:` `i32````)```` ``->` `bool`` ```{` `...` `}``\n  ``#``[``deprecated``]``\n  ``pub` `fn` `from_i32`````(``value``:` `i32````)```` ``->` ``Option``<`PhoneType`>``` ```{` `...` `}``\n```}```\n`\n```\n\nIt also adds an ````impl` ```TryFrom`<``i32``>`` `for``` `PhoneType````, so you can convert an ```i32``` to its corresponding ``PhoneType`` value by doing, for example:\n```\n``let` phone_type `=` `2``i32``;`\n`match` `PhoneType`::``try_from`(`phone_type`)` ``{`\n  `Ok``(``PhoneType`::``Mobile`)` `=>` `...``,`\n  `Ok``(``PhoneType`::``Home`)` `=>` `...``,`\n  `Ok``(``PhoneType`::``Work`)` `=>` `...``,`\n  `Err``(``_``)` `=>` `...``,`\n```}``\n`\n```\n\nAdditionally, wherever a ``proto`` enum is used as a field in a ``Message``, the message will have 'accessor' methods to get/set the value of the field as the Rust enum type. For instance, this proto ``PhoneNumber`` message that has a field named ```type``` of type ``PhoneType``:\n```\n`message PhoneNumber ``{`\n string number `=` `1``;`\n PhoneType `type` `=` `2``;`\n```}``\n`\n```\n\nwill become the following Rust type [^2] with methods ```type``` and ``set_type``:\n```\n```pub` `struct` ```PhoneNumber` ````{`\n  `pub` `number``:` String,\n  `pub` r#`type``:` `i32`, ``//` the `r#` is needed because `type` is a Rust keyword`\n```}```\n``impl` ```PhoneNumber` ````{`\n  ``pub` `fn` `r```#``type``(``&``self``)` ``->` PhoneType` `{` `...` `}`\n  ``pub` `fn` `set_type`````(``&``mut` `self`, `value``:` PhoneType```)`````{` `...` `}``\n```}```\n`\n```\n\nNote that the getter methods will return the Rust enum's default value if the field has an invalid ```i32``` value.\nThe ```enum``` type isn't used directly as a field, because the Protobuf spec mandates that enumerations values are 'open', and decoding unrecognized enumeration values must be possible.\n[^2]: Annotations have been elided for clarity. See below for a full example.\n#### Field Modifiers\nProtobuf scalar value and enumeration message fields can have a modifier depending on the Protobuf version. Modifiers change the corresponding type of the Rust field:\n```.`proto`` Version | Modifier | Rust Type  \n---|---|---  \n``proto2`` | ``optional`` | ````Option``<`T`>````  \n``proto2`` | ``required`` | ``T``  \n``proto3`` | default | ``T`` for scalar types, ````Option``<`T`>```` otherwise  \n``proto3`` | ``optional`` | ````Option``<`T`>````  \n``proto2``/``proto3`` | ``repeated`` | ````Vec``<`T`>````  \nNote that in ``proto3`` the default representation for all user-defined message types is ````Option``<`T`>````, and for scalar types just ``T`` (during decoding, a missing value is populated by ```T`::``default`(``)```). If you need a witness of the presence of a scalar type ``T``, use the ``optional`` modifier to enforce an ````Option``<`T`>```` representation in the generated Rust struct.\n#### Map Fields\nMap fields are converted to a Rust ``HashMap`` with key and value type converted from the Protobuf key and value types.\n#### Message Fields\nMessage fields are converted to the corresponding struct type. The table of field modifiers above applies to message fields, except that ``proto3`` message fields without a modifier (the default) will be wrapped in an ```Option```. Typically message fields are unboxed. ``prost`` will automatically box a message field if the field type and the parent type are recursively nested in order to avoid an infinite sized struct.\n#### Oneof Fields\nOneof fields convert to a Rust enum. Protobuf ``oneof``s types are not named, so ``prost`` uses the name of the ``oneof`` field for the resulting Rust enum, and defines the enum in a module under the struct. For example, a ``proto3`` message such as:\n```\n`message Foo ``{`\n oneof widget `{`\n  int32 quux `=` `1``;`\n  string bar `=` `2``;`\n `}`\n```}``\n`\n```\n\ngenerates the following Rust[^3]:\n```\n```pub` `struct` ```Foo` ````{`\n  `pub` `widget``:` ``Option``<``foo`::``Widget`>``,\n```}```\n``pub` `mod` `foo` ``{`\n  ``pub` `enum` `Widget` `{`\n    Quux`(``i32``)``,`\n    Bar`(``String``)``,`\n  `}``\n```}```\n`\n```\n\n``oneof`` fields are always wrapped in an ```Option```.\n[^3]: Annotations have been elided for clarity. See below for a full example.\n### Services\n``prost-build`` allows a custom code-generator to be used for processing ``service`` definitions. This can be used to output Rust traits according to an application's specific needs.\n### Generated Code Example\nExample ```.`proto`` file:\n```\n`syntax `=` ``\"`proto3`\"```;`\npackage tutorial`;`\nmessage Person ``{`\n string name `=` `1``;`\n int32 id `=` `2``;` ``//` Unique ID number for this person.`\n string email `=` `3``;`\n ``enum` `PhoneType` `{`\n  `MOBILE` `=` `0``;`\n  `HOME` `=` `1``;`\n  `WORK` `=` `2``;`\n `}``\n message PhoneNumber `{`\n  string number `=` `1``;`\n  PhoneType `type` `=` `2``;`\n `}`\n repeated PhoneNumber phones `=` `4``;`\n```}``\n``//` Our address book file is just one of these.`\nmessage AddressBook ``{`\n repeated Person people `=` `1``;`\n```}``\n`\n```\n\nand the generated Rust code (``tutorial.rs``):\n```\n```#``[``derive```(```Clone`,` PartialEq`,` ::prost::Message```)```]``\n``pub` `struct` ```Person` ````{`\n  ``#``[``prost```(```string`,` tag`=```\"`1`\"`````)```]``\n  `pub` `name``:` `:``:``prost`::```alloc`::```string`::``String,\n  ``///` Unique ID number for this person.`\n  ``#``[``prost```(```int32`,` tag`=```\"`2`\"`````)```]``\n  `pub` `id``:` `i32`,\n  ``#``[``prost```(```string`,` tag`=```\"`3`\"`````)```]``\n  `pub` `email``:` `:``:``prost`::```alloc`::```string`::``String,\n  ``#``[``prost```(```message`,` repeated`,` tag`=```\"`4`\"`````)```]``\n  `pub` `phones``:` `:``:``prost`::```alloc`::```vec`::````Vec``<``person`::``PhoneNumber`>``,\n```}```\n``///` Nested message and enum types in `Person`.`\n``pub` `mod` `person` ``{`\n  ``#``[``derive```(```Clone`,` PartialEq`,` ::prost::Message```)```]``\n  ``pub` `struct` ```PhoneNumber` ```{`\n    ``#``[``prost```(```string`,` tag`=```\"`1`\"`````)```]``\n    `pub` `number``:` `:``:``prost`::```alloc`::```string`::``String,\n    ``#``[``prost```(```enumeration`=```\"`PhoneType`\"```,` tag`=```\"`2`\"`````)```]``\n    `pub` r#`type``:` `i32`,\n  `}``\n  ``#``[``derive```(```Clone`,` Copy`,` Debug`,` PartialEq`,` Eq`,` Hash`,` PartialOrd`,` Ord`,` ::prost::Enumeration```)```]``\n  ``#``[``repr```(```i32```)```]``\n  ``pub` `enum` `PhoneType` `{`\n    Mobile `=` `0``,`\n    Home `=` `1``,`\n    Work `=` `2``,`\n  `}``\n```}```\n``///` Our address book file is just one of these.`\n``#``[``derive```(```Clone`,` PartialEq`,` ::prost::Message```)```]``\n``pub` `struct` ```AddressBook` ````{`\n  ``#``[``prost```(```message`,` repeated`,` tag`=```\"`1`\"`````)```]``\n  `pub` `people``:` `:``:``prost`::```alloc`::```vec`::````Vec``<`Person`>``,\n```}```\n`\n```\n\n## Accessing the ``protoc`` ``FileDescriptorSet``\nThe ```prost_build`::```Config`::``file_descriptor_set_path`` option can be used to emit a file descriptor set during the build & code generation step. When used in conjunction with the ```std`::``include_bytes`` macro and the ```prost_types`::``FileDescriptorSet`` type, applications and libraries using Prost can implement introspection capabilities requiring details from the original ```.`proto`` files.\n## Using ``prost`` in a ``no_std`` Crate\n``prost`` is compatible with ``no_std`` crates. To enable ``no_std`` support, disable the ``std`` features in ``prost`` and ``prost-types``:\n```\n`[dependencies]\nprost = { version = \"0.14.1\", default-features = false, features = [\"derive\"] }\n# Only necessary if using Protobuf well-known types:\nprost-types = { version = \"0.14.1\", default-features = false }\n`\n```\n\nAdditionally, configure ``prost-build`` to output ``BTreeMap``s instead of ``HashMap``s for all Protobuf ``map`` fields in your ``build.rs``:\n```\n``let` `mut` config `=` `prost_build`::```Config`::``new`(``)``;`\nconfig`.``btree_map``(``&``[```\"`.`\"```]``)``;`\n`\n```\n\nWhen using edition 2015, it may be necessary to add an ```extern` `crate` core`;``` directive to the crate which includes ``prost``-generated code.\n## Serializing Existing Types\n``prost`` uses a custom derive macro to handle encoding and decoding types, which means that if your existing Rust type is compatible with Protobuf types, you can serialize and deserialize it by adding the appropriate derive and field annotations.\nCurrently the best documentation on adding annotations is to look at the generated code examples above.\n### Tag Inference for Existing Types\nProst automatically infers tags for the struct.\nFields are tagged sequentially in the order they are specified, starting with ```1```.\nYou may skip tags which have been reserved, or where there are gaps between sequentially occurring tag values by specifying the tag number to skip to with the ``tag`` attribute on the first field after the gap. The following fields will be tagged sequentially starting from the next number.\n```\n``use` prost`;`\n`use` `prost`::````{`Enumeration`,` Message```}```;`\n``#``[``derive```(```Clone`,` PartialEq`,` Message```)```]``\n``struct` ```Person` ````{`\n  ``#``[``prost```(```string`,` tag `=` ``\"`1`\"`````)```]``\n  `pub` `id``:` String, ``//` tag=1`\n  ``//` NOTE: Old \"name\" field has been removed`\n  ``//` pub name: String, // tag=2 (Removed)`\n  ``#``[``prost```(```string`,` tag `=` ``\"`6`\"`````)```]``\n  `pub` `given_name``:` String, ``//` tag=6`\n  ``#``[``prost```(```string```)```]``\n  `pub` `family_name``:` String, ``//` tag=7`\n  ``#``[``prost```(```string```)```]``\n  `pub` `formatted_name``:` String, ``//` tag=8`\n  ``#``[``prost```(```uint32`,` tag `=` ``\"`3`\"`````)```]``\n  `pub` `age``:` `u32`, ``//` tag=3`\n  ``#``[``prost```(```uint32```)```]``\n  `pub` `height``:` `u32`, ``//` tag=4`\n  ``#``[``prost```(```enumeration `=` ``\"`Gender`\"`````)```]``\n  `pub` `gender``:` `i32`, ``//` tag=5`\n  ``//` NOTE: Skip to less commonly occurring fields`\n  ``#``[``prost```(```string`,` tag `=` ``\"`16`\"`````)```]``\n  `pub` `name_prefix``:` String, ``//` tag=16 (eg. mr/mrs/ms)`\n  ``#``[``prost```(```string```)```]``\n  `pub` `name_suffix``:` String, ``//` tag=17 (eg. jr/esq)`\n  ``#``[``prost```(```string```)```]``\n  `pub` `maiden_name``:` String, ``//` tag=18`\n```}```\n``#``[``derive```(```Clone`,` Copy`,` Debug`,` PartialEq`,` Eq`,` Enumeration```)```]``\n``pub` `enum` `Gender` ``{`\n  Unknown `=` `0``,`\n  Female `=` `1``,`\n  Male `=` `2``,`\n```}```\n`\n```\n\n## Nix\nThe prost project maintains flakes support for local development. Once you have nix and nix flakes setup you can just run ``nix develop`` to get a shell configured with the required dependencies to compile the whole project.\n## Feature Flags\n  * ``std``: Enable integration with standard library. Disable this feature for ``no_std`` support. This feature is enabled by default.\n  * ``derive``: Enable integration with ``prost-derive``. Disable this feature to reduce compile times. This feature is enabled by default.\n  * ``prost-derive``: Deprecated. Alias for ``derive`` feature.\n  * ``no-recursion-limit``: Disable the recursion limit. The recursion limit is 100 and cannot be customized.\n\n\n## FAQ\n  1. **Could``prost`` be implemented as a serializer for [Serde](https://serde.rs/)?**\n\n\nProbably not, however I would like to hear from a Serde expert on the matter. There are two complications with trying to serialize Protobuf messages with Serde:\n  * Protobuf fields require a numbered tag, and currently there appears to be no mechanism suitable for this in ``serde``.\n  * The mapping of Protobuf type to Rust type is not 1-to-1. As a result, trait-based approaches to dispatching don't work very well. Example: six different Protobuf field types correspond to a Rust ````Vec``<``i32``>````: ``repeated int32``, ``repeated sint32``, ``repeated sfixed32``, and their packed counterparts.\n\n\nBut it is possible to place ``serde`` derive tags onto the generated types, so the same structure can support both ``prost`` and ``Serde``.\n  1. **I get errors when trying to run````cargo``` test``` on MacOS**\n\n\nIf the errors are about missing ``autoreconf`` or similar, you can probably fix them by running\n```\n`brew install automake\nbrew install libtool\n`\n```\n\n## License\n``prost`` is distributed under the terms of the Apache License (Version 2.0).\nSee [LICENSE](https://github.com/tokio-rs/prost/blob/master/LICENSE) for details.\nCopyright 2022 Dan Burkert & Tokio Contributors\n#### Dependencies\n~155\u2013395KB \n  * [bytes](https://lib.rs/crates/bytes \"1\")\n  * [derive](https://lib.rs/crates/prost/features#feature-derive \"default feature\") [prost-derive](https://lib.rs/crates/prost-derive \"new\") 0.14.1\n\n\n  * dev  [criterion](https://lib.rs/crates/criterion \"new\") 0.6\n  * dev  [proptest](https://lib.rs/crates/proptest \"1\")\n  * dev  [rand](https://lib.rs/crates/rand \"new\") 0.9\n\n\n#### [Other features](https://lib.rs/crates/prost/features)\n  * [no-recursion-limit](https://lib.rs/crates/prost/features#feature-no-recursion-limit)\n  * [std](https://lib.rs/crates/prost/features#feature-std)\n\n\n  *[SLoC]: Lines of code, excluding comments\n",
              "markdown_with_citations": "###  39 releases\u27e81\u27e9\n0.14.1 |  Jun 18, 2025   \n---|---  \n0.13.5 |  Feb 12, 2025   \n0.13.4 |  Dec 6, 2024   \n0.13.3 |  Sep 21, 2024   \n0.1.0 |  Jun 25, 2017   \n#**3** in Encoding\u27e82\u27e9\nDownload history 3328084/week @ 2025-03-09 3661980/week @ 2025-03-16 4064370/week @ 2025-03-23 2942031/week @ 2025-03-30 3049750/week @ 2025-04-06 2587235/week @ 2025-04-13 2585283/week @ 2025-04-20 2353676/week @ 2025-04-27 2502195/week @ 2025-05-04 2551963/week @ 2025-05-11 2579713/week @ 2025-05-18 2272360/week @ 2025-05-25 2568135/week @ 2025-06-01 2480950/week @ 2025-06-08 2452064/week @ 2025-06-15 2714838/week @ 2025-06-22\n**10,330,293** downloads per month Used in **5,381** crates (2,476 directly)\u27e83\u27e9\n**Apache-2.0**\n105KB  2.5K  SLoC\n![continuous integration\u27e84\u27e9](https://github.com/tokio-rs/prost/actions/workflows/ci.yml?query=branch%3Amaster) ![Documentation\u27e85\u27e9](https://docs.rs/prost/) ![Crate\u27e86\u27e9](https://crates.io/crates/prost) ![Dependency Status\u27e87\u27e9](https://deps.rs/repo/github/tokio-rs/prost) ![Discord\u27e88\u27e9](https://discord.gg/tokio)\n# _PROST!_\n``prost`` is a Protocol Buffers\u27e89\u27e9 implementation for the Rust Language\u27e810\u27e9. ``prost`` generates simple, idiomatic Rust code from ``proto2`` and ``proto3`` files.\nCompared to other Protocol Buffers implementations, ``prost``\n  * Generates simple, idiomatic, and readable Rust types by taking advantage of Rust ``derive`` attributes.\n  * Retains comments from ```.`proto`` files in generated Rust code.\n  * Allows existing Rust types (not generated from a ```.`proto``) to be serialized and deserialized by adding attributes.\n  * Uses the ```bytes`::````{`Buf`,` BufMut```}````\u27e811\u27e9 abstractions for serialization instead of ```std`::```io`::````{`Read`,` Write```}````.\n  * Respects the Protobuf ``package`` specifier when organizing generated code into Rust modules.\n  * Preserves unknown enum values during deserialization.\n  * Does not include support for runtime reflection or message descriptors.\n\n\n## Using ``prost`` in a Cargo Project\nFirst, add ``prost`` and its public dependencies to your ``Cargo.toml``:\n```\n`[dependencies]\nprost = \"0.14\"\n# Only necessary if using Protobuf well-known types:\nprost-types = \"0.14\"\n`\n```\n\nThe recommended way to add ```.`proto`` compilation to a Cargo project is to use the ``prost-build`` library. See the ``prost-build`` documentation\u27e812\u27e9 for more details and examples.\nSee the snazzy repository\u27e813\u27e9 for a simple start-to-finish example.\n### MSRV\n``prost`` follows the ``tokio-rs`` project's MSRV model and supports 1.70. For more information on the tokio msrv policy you can check it out here\u27e814\u27e9\n## Generated Code\n``prost`` generates Rust code from source ```.`proto`` files using the ``proto2`` or ``proto3`` syntax. ``prost``'s goal is to make the generated code as simple as possible.\n### ``protoc``\nWith ``prost-build`` v0.11 release, ``protoc`` will be required to invoke ``compile_protos`` (unless ``skip_protoc`` is enabled). Prost will no longer provide bundled ``protoc`` or attempt to compile ``protoc`` for users. For install instructions for ``protoc``, please check out the protobuf install\u27e815\u27e9 instructions.\n### Packages\nProst can now generate code for ```.`proto`` files that don't have a package spec. ``prost`` will translate the Protobuf package into a Rust module. For example, given the ``package`` specifier:\n```\n`package foo`.`bar`;`\n`\n```\n\nAll Rust types generated from the file will be in the ```foo`::``bar`` module.\n### Messages\nGiven a simple message declaration:\n```\n```//` Sample message.`\nmessage Foo ``{`\n```}``\n`\n```\n\n``prost`` will generate the following Rust struct:\n```\n```///` Sample message.`\n``#``[``derive```(```Clone`,` Debug`,` PartialEq`,` Message```)```]``\n``pub` `struct` ```Foo` ````{`\n```}```\n`\n```\n\n### Fields\nFields in Protobuf messages are translated into Rust as public struct fields of the corresponding type.\n#### Scalar Values\nScalar value types are converted as follows:\nProtobuf Type | Rust Type  \n---|---  \n``double`` | ```f64```  \n``float`` | ```f32```  \n``int32`` | ```i32```  \n``int64`` | ```i64```  \n``uint32`` | ```u32```  \n``uint64`` | ```u64```  \n``sint32`` | ```i32```  \n``sint64`` | ```i64```  \n``fixed32`` | ```u32```  \n``fixed64`` | ```u64```  \n``sfixed32`` | ```i32```  \n``sfixed64`` | ```i64```  \n```bool``` | ```bool```  \n``string`` | ```String```  \n``bytes`` | ````Vec``<``u8``>````  \n#### Enumerations\nAll ```.`proto`` enumeration types convert to the Rust ```i32``` type. Additionally, each enumeration type gets a corresponding Rust ```enum``` type. For example, this ``proto`` enum:\n```\n```enum` `PhoneType` ``{`\n `MOBILE` `=` `0``;`\n `HOME` `=` `1``;`\n `WORK` `=` `2``;`\n```}```\n`\n```\n\ngets this corresponding Rust enum [^1]:\n```\n```pub` `enum` `PhoneType` ``{`\n  Mobile `=` `0``,`\n  Home `=` `1``,`\n  Work `=` `2``,`\n```}```\n`\n```\n\n[^1]: Annotations have been elided for clarity. See below for a full example.\nYou can convert a ``PhoneType`` value to an ```i32``` by doing:\n```\n``PhoneType`::``Mobile `as` `i32`\n`\n```\n\nThe ````#``[``derive```(```::prost::Enumeration```)```]```` annotation added to the generated ``PhoneType`` adds these associated functions to the type:\n```\n```impl` ```PhoneType` ````{`\n  ``pub` `fn` `is_valid`````(``value``:` `i32````)```` ``->` `bool`` ```{` `...` `}``\n  ``#``[``deprecated``]``\n  ``pub` `fn` `from_i32`````(``value``:` `i32````)```` ``->` ``Option``<`PhoneType`>``` ```{` `...` `}``\n```}```\n`\n```\n\nIt also adds an ````impl` ```TryFrom`<``i32``>`` `for``` `PhoneType````, so you can convert an ```i32``` to its corresponding ``PhoneType`` value by doing, for example:\n```\n``let` phone_type `=` `2``i32``;`\n`match` `PhoneType`::``try_from`(`phone_type`)` ``{`\n  `Ok``(``PhoneType`::``Mobile`)` `=>` `...``,`\n  `Ok``(``PhoneType`::``Home`)` `=>` `...``,`\n  `Ok``(``PhoneType`::``Work`)` `=>` `...``,`\n  `Err``(``_``)` `=>` `...``,`\n```}``\n`\n```\n\nAdditionally, wherever a ``proto`` enum is used as a field in a ``Message``, the message will have 'accessor' methods to get/set the value of the field as the Rust enum type. For instance, this proto ``PhoneNumber`` message that has a field named ```type``` of type ``PhoneType``:\n```\n`message PhoneNumber ``{`\n string number `=` `1``;`\n PhoneType `type` `=` `2``;`\n```}``\n`\n```\n\nwill become the following Rust type [^2] with methods ```type``` and ``set_type``:\n```\n```pub` `struct` ```PhoneNumber` ````{`\n  `pub` `number``:` String,\n  `pub` r#`type``:` `i32`, ``//` the `r#` is needed because `type` is a Rust keyword`\n```}```\n``impl` ```PhoneNumber` ````{`\n  ``pub` `fn` `r```#``type``(``&``self``)` ``->` PhoneType` `{` `...` `}`\n  ``pub` `fn` `set_type`````(``&``mut` `self`, `value``:` PhoneType```)`````{` `...` `}``\n```}```\n`\n```\n\nNote that the getter methods will return the Rust enum's default value if the field has an invalid ```i32``` value.\nThe ```enum``` type isn't used directly as a field, because the Protobuf spec mandates that enumerations values are 'open', and decoding unrecognized enumeration values must be possible.\n[^2]: Annotations have been elided for clarity. See below for a full example.\n#### Field Modifiers\nProtobuf scalar value and enumeration message fields can have a modifier depending on the Protobuf version. Modifiers change the corresponding type of the Rust field:\n```.`proto`` Version | Modifier | Rust Type  \n---|---|---  \n``proto2`` | ``optional`` | ````Option``<`T`>````  \n``proto2`` | ``required`` | ``T``  \n``proto3`` | default | ``T`` for scalar types, ````Option``<`T`>```` otherwise  \n``proto3`` | ``optional`` | ````Option``<`T`>````  \n``proto2``/``proto3`` | ``repeated`` | ````Vec``<`T`>````  \nNote that in ``proto3`` the default representation for all user-defined message types is ````Option``<`T`>````, and for scalar types just ``T`` (during decoding, a missing value is populated by ```T`::``default`(``)```). If you need a witness of the presence of a scalar type ``T``, use the ``optional`` modifier to enforce an ````Option``<`T`>```` representation in the generated Rust struct.\n#### Map Fields\nMap fields are converted to a Rust ``HashMap`` with key and value type converted from the Protobuf key and value types.\n#### Message Fields\nMessage fields are converted to the corresponding struct type. The table of field modifiers above applies to message fields, except that ``proto3`` message fields without a modifier (the default) will be wrapped in an ```Option```. Typically message fields are unboxed. ``prost`` will automatically box a message field if the field type and the parent type are recursively nested in order to avoid an infinite sized struct.\n#### Oneof Fields\nOneof fields convert to a Rust enum. Protobuf ``oneof``s types are not named, so ``prost`` uses the name of the ``oneof`` field for the resulting Rust enum, and defines the enum in a module under the struct. For example, a ``proto3`` message such as:\n```\n`message Foo ``{`\n oneof widget `{`\n  int32 quux `=` `1``;`\n  string bar `=` `2``;`\n `}`\n```}``\n`\n```\n\ngenerates the following Rust[^3]:\n```\n```pub` `struct` ```Foo` ````{`\n  `pub` `widget``:` ``Option``<``foo`::``Widget`>``,\n```}```\n``pub` `mod` `foo` ``{`\n  ``pub` `enum` `Widget` `{`\n    Quux`(``i32``)``,`\n    Bar`(``String``)``,`\n  `}``\n```}```\n`\n```\n\n``oneof`` fields are always wrapped in an ```Option```.\n[^3]: Annotations have been elided for clarity. See below for a full example.\n### Services\n``prost-build`` allows a custom code-generator to be used for processing ``service`` definitions. This can be used to output Rust traits according to an application's specific needs.\n### Generated Code Example\nExample ```.`proto`` file:\n```\n`syntax `=` ``\"`proto3`\"```;`\npackage tutorial`;`\nmessage Person ``{`\n string name `=` `1``;`\n int32 id `=` `2``;` ``//` Unique ID number for this person.`\n string email `=` `3``;`\n ``enum` `PhoneType` `{`\n  `MOBILE` `=` `0``;`\n  `HOME` `=` `1``;`\n  `WORK` `=` `2``;`\n `}``\n message PhoneNumber `{`\n  string number `=` `1``;`\n  PhoneType `type` `=` `2``;`\n `}`\n repeated PhoneNumber phones `=` `4``;`\n```}``\n``//` Our address book file is just one of these.`\nmessage AddressBook ``{`\n repeated Person people `=` `1``;`\n```}``\n`\n```\n\nand the generated Rust code (``tutorial.rs``):\n```\n```#``[``derive```(```Clone`,` PartialEq`,` ::prost::Message```)```]``\n``pub` `struct` ```Person` ````{`\n  ``#``[``prost```(```string`,` tag`=```\"`1`\"`````)```]``\n  `pub` `name``:` `:``:``prost`::```alloc`::```string`::``String,\n  ``///` Unique ID number for this person.`\n  ``#``[``prost```(```int32`,` tag`=```\"`2`\"`````)```]``\n  `pub` `id``:` `i32`,\n  ``#``[``prost```(```string`,` tag`=```\"`3`\"`````)```]``\n  `pub` `email``:` `:``:``prost`::```alloc`::```string`::``String,\n  ``#``[``prost```(```message`,` repeated`,` tag`=```\"`4`\"`````)```]``\n  `pub` `phones``:` `:``:``prost`::```alloc`::```vec`::````Vec``<``person`::``PhoneNumber`>``,\n```}```\n``///` Nested message and enum types in `Person`.`\n``pub` `mod` `person` ``{`\n  ``#``[``derive```(```Clone`,` PartialEq`,` ::prost::Message```)```]``\n  ``pub` `struct` ```PhoneNumber` ```{`\n    ``#``[``prost```(```string`,` tag`=```\"`1`\"`````)```]``\n    `pub` `number``:` `:``:``prost`::```alloc`::```string`::``String,\n    ``#``[``prost```(```enumeration`=```\"`PhoneType`\"```,` tag`=```\"`2`\"`````)```]``\n    `pub` r#`type``:` `i32`,\n  `}``\n  ``#``[``derive```(```Clone`,` Copy`,` Debug`,` PartialEq`,` Eq`,` Hash`,` PartialOrd`,` Ord`,` ::prost::Enumeration```)```]``\n  ``#``[``repr```(```i32```)```]``\n  ``pub` `enum` `PhoneType` `{`\n    Mobile `=` `0``,`\n    Home `=` `1``,`\n    Work `=` `2``,`\n  `}``\n```}```\n``///` Our address book file is just one of these.`\n``#``[``derive```(```Clone`,` PartialEq`,` ::prost::Message```)```]``\n``pub` `struct` ```AddressBook` ````{`\n  ``#``[``prost```(```message`,` repeated`,` tag`=```\"`1`\"`````)```]``\n  `pub` `people``:` `:``:``prost`::```alloc`::```vec`::````Vec``<`Person`>``,\n```}```\n`\n```\n\n## Accessing the ``protoc`` ``FileDescriptorSet``\nThe ```prost_build`::```Config`::``file_descriptor_set_path`` option can be used to emit a file descriptor set during the build & code generation step. When used in conjunction with the ```std`::``include_bytes`` macro and the ```prost_types`::``FileDescriptorSet`` type, applications and libraries using Prost can implement introspection capabilities requiring details from the original ```.`proto`` files.\n## Using ``prost`` in a ``no_std`` Crate\n``prost`` is compatible with ``no_std`` crates. To enable ``no_std`` support, disable the ``std`` features in ``prost`` and ``prost-types``:\n```\n`[dependencies]\nprost = { version = \"0.14.1\", default-features = false, features = [\"derive\"] }\n# Only necessary if using Protobuf well-known types:\nprost-types = { version = \"0.14.1\", default-features = false }\n`\n```\n\nAdditionally, configure ``prost-build`` to output ``BTreeMap``s instead of ``HashMap``s for all Protobuf ``map`` fields in your ``build.rs``:\n```\n``let` `mut` config `=` `prost_build`::```Config`::``new`(``)``;`\nconfig`.``btree_map``(``&``[```\"`.`\"```]``)``;`\n`\n```\n\nWhen using edition 2015, it may be necessary to add an ```extern` `crate` core`;``` directive to the crate which includes ``prost``-generated code.\n## Serializing Existing Types\n``prost`` uses a custom derive macro to handle encoding and decoding types, which means that if your existing Rust type is compatible with Protobuf types, you can serialize and deserialize it by adding the appropriate derive and field annotations.\nCurrently the best documentation on adding annotations is to look at the generated code examples above.\n### Tag Inference for Existing Types\nProst automatically infers tags for the struct.\nFields are tagged sequentially in the order they are specified, starting with ```1```.\nYou may skip tags which have been reserved, or where there are gaps between sequentially occurring tag values by specifying the tag number to skip to with the ``tag`` attribute on the first field after the gap. The following fields will be tagged sequentially starting from the next number.\n```\n``use` prost`;`\n`use` `prost`::````{`Enumeration`,` Message```}```;`\n``#``[``derive```(```Clone`,` PartialEq`,` Message```)```]``\n``struct` ```Person` ````{`\n  ``#``[``prost```(```string`,` tag `=` ``\"`1`\"`````)```]``\n  `pub` `id``:` String, ``//` tag=1`\n  ``//` NOTE: Old \"name\" field has been removed`\n  ``//` pub name: String, // tag=2 (Removed)`\n  ``#``[``prost```(```string`,` tag `=` ``\"`6`\"`````)```]``\n  `pub` `given_name``:` String, ``//` tag=6`\n  ``#``[``prost```(```string```)```]``\n  `pub` `family_name``:` String, ``//` tag=7`\n  ``#``[``prost```(```string```)```]``\n  `pub` `formatted_name``:` String, ``//` tag=8`\n  ``#``[``prost```(```uint32`,` tag `=` ``\"`3`\"`````)```]``\n  `pub` `age``:` `u32`, ``//` tag=3`\n  ``#``[``prost```(```uint32```)```]``\n  `pub` `height``:` `u32`, ``//` tag=4`\n  ``#``[``prost```(```enumeration `=` ``\"`Gender`\"`````)```]``\n  `pub` `gender``:` `i32`, ``//` tag=5`\n  ``//` NOTE: Skip to less commonly occurring fields`\n  ``#``[``prost```(```string`,` tag `=` ``\"`16`\"`````)```]``\n  `pub` `name_prefix``:` String, ``//` tag=16 (eg. mr/mrs/ms)`\n  ``#``[``prost```(```string```)```]``\n  `pub` `name_suffix``:` String, ``//` tag=17 (eg. jr/esq)`\n  ``#``[``prost```(```string```)```]``\n  `pub` `maiden_name``:` String, ``//` tag=18`\n```}```\n``#``[``derive```(```Clone`,` Copy`,` Debug`,` PartialEq`,` Eq`,` Enumeration```)```]``\n``pub` `enum` `Gender` ``{`\n  Unknown `=` `0``,`\n  Female `=` `1``,`\n  Male `=` `2``,`\n```}```\n`\n```\n\n## Nix\nThe prost project maintains flakes support for local development. Once you have nix and nix flakes setup you can just run ``nix develop`` to get a shell configured with the required dependencies to compile the whole project.\n## Feature Flags\n  * ``std``: Enable integration with standard library. Disable this feature for ``no_std`` support. This feature is enabled by default.\n  * ``derive``: Enable integration with ``prost-derive``. Disable this feature to reduce compile times. This feature is enabled by default.\n  * ``prost-derive``: Deprecated. Alias for ``derive`` feature.\n  * ``no-recursion-limit``: Disable the recursion limit. The recursion limit is 100 and cannot be customized.\n\n\n## FAQ\n  1. **Could``prost`` be implemented as a serializer for Serde\u27e816\u27e9?**\n\n\nProbably not, however I would like to hear from a Serde expert on the matter. There are two complications with trying to serialize Protobuf messages with Serde:\n  * Protobuf fields require a numbered tag, and currently there appears to be no mechanism suitable for this in ``serde``.\n  * The mapping of Protobuf type to Rust type is not 1-to-1. As a result, trait-based approaches to dispatching don't work very well. Example: six different Protobuf field types correspond to a Rust ````Vec``<``i32``>````: ``repeated int32``, ``repeated sint32``, ``repeated sfixed32``, and their packed counterparts.\n\n\nBut it is possible to place ``serde`` derive tags onto the generated types, so the same structure can support both ``prost`` and ``Serde``.\n  1. **I get errors when trying to run````cargo``` test``` on MacOS**\n\n\nIf the errors are about missing ``autoreconf`` or similar, you can probably fix them by running\n```\n`brew install automake\nbrew install libtool\n`\n```\n\n## License\n``prost`` is distributed under the terms of the Apache License (Version 2.0).\nSee LICENSE\u27e817\u27e9 for details.\nCopyright 2022 Dan Burkert & Tokio Contributors\n#### Dependencies\n~155\u2013395KB \n  * bytes\u27e818\u27e9\n  * derive\u27e819\u27e9 prost-derive\u27e820\u27e9 0.14.1\n\n\n  * dev  criterion\u27e821\u27e9 0.6\n  * dev  proptest\u27e822\u27e9\n  * dev  rand\u27e823\u27e9 0.9\n\n\n#### Other features\u27e824\u27e9\n  * no-recursion-limit\u27e825\u27e9\n  * std\u27e826\u27e9\n\n\n  *[SLoC]: Lines of code, excluding comments\n",
              "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://lib.rs/crates/prost/versions: 39 releases\n\u27e82\u27e9 https://lib.rs/encoding: Encoding and/or decoding data from one data format to another. - Encoding\n\u27e83\u27e9 https://lib.rs/crates/prost/rev: **5,381** crates (2,476 directly)\n\u27e84\u27e9 https://img.gs/czjpqfbdkz/full/https://github.com/tokio-rs/prost/actions/workflows/ci.yml/badge.svg?branch=master: ![continuous integration\n\u27e85\u27e9 https://img.gs/czjpqfbdkz/full/https://docs.rs/prost/badge.svg: ![Documentation\n\u27e86\u27e9 https://img.shields.io/crates/v/prost.svg: ![Crate\n\u27e87\u27e9 https://img.gs/czjpqfbdkz/full/https://deps.rs/repo/github/tokio-rs/prost/status.svg: ![Dependency Status\n\u27e88\u27e9 https://img.shields.io/discord/500028886025895936: ![Discord\n\u27e89\u27e9 https://developers.google.com/protocol-buffers/: Protocol Buffers\n\u27e810\u27e9 https://www.rust-lang.org/: Rust Language\n\u27e811\u27e9 https://github.com/carllerche/bytes: ```bytes`::````{`Buf`,` BufMut```}````\n\u27e812\u27e9 https://docs.rs/prost-build/latest/prost_build/: ``prost-build`` documentation\n\u27e813\u27e9 https://github.com/danburkert/snazzy: snazzy repository\n\u27e814\u27e9 https://github.com/tokio-rs/tokio/#supported-rust-versions: here\n\u27e815\u27e9 https://github.com/protocolbuffers/protobuf#protobuf-compiler-installation: protobuf install\n\u27e816\u27e9 https://serde.rs/: Serde\n\u27e817\u27e9 https://github.com/tokio-rs/prost/blob/master/LICENSE: LICENSE\n\u27e818\u27e9 https://lib.rs/crates/bytes: 1 - bytes\n\u27e819\u27e9 https://lib.rs/crates/prost/features#feature-derive: default feature - derive\n\u27e820\u27e9 https://lib.rs/crates/prost-derive: new - prost-derive\n\u27e821\u27e9 https://lib.rs/crates/criterion: new - criterion\n\u27e822\u27e9 https://lib.rs/crates/proptest: 1 - proptest\n\u27e823\u27e9 https://lib.rs/crates/rand: new - rand\n\u27e824\u27e9 https://lib.rs/crates/prost/features: Other features\n\u27e825\u27e9 https://lib.rs/crates/prost/features#feature-no-recursion-limit: no-recursion-limit\n\u27e826\u27e9 https://lib.rs/crates/prost/features#feature-std: std\n",
              "fit_markdown": "",
              "fit_html": ""
            },
            "structured_data": {},
            "quality_score": 3.0,
            "extraction_method": "crawl4ai",
            "error": null,
            "metadata": {
              "doc_type": "docs",
              "content_length": 18936,
              "has_structured_data": false,
              "crawl_success": true
            },
            "timestamp": "116963.6027923"
          }
        },
        "crate_analysis": {
          "status": "completed",
          "check": [
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#unicode-ident@1.0.14",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\unicode-ident-1.0.14\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "unicode_ident",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\unicode-ident-1.0.14\\src\\lib.rs",
                "edition": "2018",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpnxzfs7w2\\prost-0.14.1\\target\\debug\\deps\\libunicode_ident-6d74e9fad9aef6d6.rlib",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpnxzfs7w2\\prost-0.14.1\\target\\debug\\deps\\libunicode_ident-6d74e9fad9aef6d6.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#either@1.13.0",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\either-1.13.0\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "either",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\either-1.13.0\\src\\lib.rs",
                "edition": "2018",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "use_std"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpnxzfs7w2\\prost-0.14.1\\target\\debug\\deps\\libeither-c8d9c235f36fd744.rlib",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpnxzfs7w2\\prost-0.14.1\\target\\debug\\deps\\libeither-c8d9c235f36fd744.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#proc-macro2@1.0.92",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\proc-macro2-1.0.92\\Cargo.toml",
              "target": {
                "kind": [
                  "custom-build"
                ],
                "crate_types": [
                  "bin"
                ],
                "name": "build-script-build",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\proc-macro2-1.0.92\\build.rs",
                "edition": "2021",
                "doc": false,
                "doctest": false,
                "test": false
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "default",
                "proc-macro"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpnxzfs7w2\\prost-0.14.1\\target\\debug\\build\\proc-macro2-8c9ab50c3af1cc80\\build-script-build.exe",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpnxzfs7w2\\prost-0.14.1\\target\\debug\\build\\proc-macro2-8c9ab50c3af1cc80\\build_script_build.pdb"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#anyhow@1.0.93",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\anyhow-1.0.93\\Cargo.toml",
              "target": {
                "kind": [
                  "custom-build"
                ],
                "crate_types": [
                  "bin"
                ],
                "name": "build-script-build",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\anyhow-1.0.93\\build.rs",
                "edition": "2018",
                "doc": false,
                "doctest": false,
                "test": false
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "default",
                "std"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpnxzfs7w2\\prost-0.14.1\\target\\debug\\build\\anyhow-64cd7f3e983b421d\\build-script-build.exe",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpnxzfs7w2\\prost-0.14.1\\target\\debug\\build\\anyhow-64cd7f3e983b421d\\build_script_build.pdb"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "build-script-executed",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#proc-macro2@1.0.92",
              "linked_libs": [],
              "linked_paths": [],
              "cfgs": [
                "wrap_proc_macro"
              ],
              "env": [],
              "out_dir": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpnxzfs7w2\\prost-0.14.1\\target\\debug\\build\\proc-macro2-d4cbd6b92c18c9b0\\out"
            },
            {
              "reason": "build-script-executed",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#anyhow@1.0.93",
              "linked_libs": [],
              "linked_paths": [],
              "cfgs": [
                "std_backtrace"
              ],
              "env": [],
              "out_dir": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpnxzfs7w2\\prost-0.14.1\\target\\debug\\build\\anyhow-de9a70ee98cead31\\out"
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#bytes@1.8.0",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\bytes-1.8.0\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "bytes",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\bytes-1.8.0\\src\\lib.rs",
                "edition": "2018",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpnxzfs7w2\\prost-0.14.1\\target\\debug\\deps\\libbytes-8636e0fd25e61635.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#anyhow@1.0.93",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\anyhow-1.0.93\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "anyhow",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\anyhow-1.0.93\\src\\lib.rs",
                "edition": "2018",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "default",
                "std"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpnxzfs7w2\\prost-0.14.1\\target\\debug\\deps\\libanyhow-8b46a6a5b5a74952.rlib",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpnxzfs7w2\\prost-0.14.1\\target\\debug\\deps\\libanyhow-8b46a6a5b5a74952.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#proc-macro2@1.0.92",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\proc-macro2-1.0.92\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "proc_macro2",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\proc-macro2-1.0.92\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "default",
                "proc-macro"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpnxzfs7w2\\prost-0.14.1\\target\\debug\\deps\\libproc_macro2-d5fd467c52aaa1fd.rlib",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpnxzfs7w2\\prost-0.14.1\\target\\debug\\deps\\libproc_macro2-d5fd467c52aaa1fd.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#quote@1.0.37",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\quote-1.0.37\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "quote",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\quote-1.0.37\\src\\lib.rs",
                "edition": "2018",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "default",
                "proc-macro"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpnxzfs7w2\\prost-0.14.1\\target\\debug\\deps\\libquote-ecc6cad931967ccf.rlib",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpnxzfs7w2\\prost-0.14.1\\target\\debug\\deps\\libquote-ecc6cad931967ccf.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#itertools@0.10.5",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\itertools-0.10.5\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "itertools",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\itertools-0.10.5\\src\\lib.rs",
                "edition": "2018",
                "doc": true,
                "doctest": true,
                "test": false
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "default",
                "use_alloc",
                "use_std"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpnxzfs7w2\\prost-0.14.1\\target\\debug\\deps\\libitertools-a5c90c128f44cd78.rlib",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpnxzfs7w2\\prost-0.14.1\\target\\debug\\deps\\libitertools-a5c90c128f44cd78.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#syn@2.0.89",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.89\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "syn",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.89\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "clone-impls",
                "default",
                "derive",
                "extra-traits",
                "parsing",
                "printing",
                "proc-macro"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpnxzfs7w2\\prost-0.14.1\\target\\debug\\deps\\libsyn-8550bcf0660806e2.rlib",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpnxzfs7w2\\prost-0.14.1\\target\\debug\\deps\\libsyn-8550bcf0660806e2.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#prost-derive@0.14.1",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\prost-derive-0.14.1\\Cargo.toml",
              "target": {
                "kind": [
                  "proc-macro"
                ],
                "crate_types": [
                  "proc-macro"
                ],
                "name": "prost_derive",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\prost-derive-0.14.1\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpnxzfs7w2\\prost-0.14.1\\target\\debug\\deps\\prost_derive-976d71f91c3565cd.dll",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpnxzfs7w2\\prost-0.14.1\\target\\debug\\deps\\prost_derive-976d71f91c3565cd.dll.lib",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpnxzfs7w2\\prost-0.14.1\\target\\debug\\deps\\prost_derive-976d71f91c3565cd.dll.exp",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpnxzfs7w2\\prost-0.14.1\\target\\debug\\deps\\prost_derive-976d71f91c3565cd.pdb"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "compiler-artifact",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpnxzfs7w2/prost-0.14.1#prost@0.14.1",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpnxzfs7w2\\prost-0.14.1\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "prost",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpnxzfs7w2\\prost-0.14.1\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "default",
                "derive",
                "std"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpnxzfs7w2\\prost-0.14.1\\target\\debug\\deps\\libprost-244f0a5f60ccbc69.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "build-finished",
              "success": true
            }
          ],
          "clippy": [
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#proc-macro2@1.0.92",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\proc-macro2-1.0.92\\Cargo.toml",
              "target": {
                "kind": [
                  "custom-build"
                ],
                "crate_types": [
                  "bin"
                ],
                "name": "build-script-build",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\proc-macro2-1.0.92\\build.rs",
                "edition": "2021",
                "doc": false,
                "doctest": false,
                "test": false
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "default",
                "proc-macro"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpnxzfs7w2\\prost-0.14.1\\target\\debug\\build\\proc-macro2-8c9ab50c3af1cc80\\build-script-build.exe",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpnxzfs7w2\\prost-0.14.1\\target\\debug\\build\\proc-macro2-8c9ab50c3af1cc80\\build_script_build.pdb"
              ],
              "executable": null,
              "fresh": true
            },
            {
              "reason": "build-script-executed",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#proc-macro2@1.0.92",
              "linked_libs": [],
              "linked_paths": [],
              "cfgs": [
                "wrap_proc_macro"
              ],
              "env": [],
              "out_dir": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpnxzfs7w2\\prost-0.14.1\\target\\debug\\build\\proc-macro2-d4cbd6b92c18c9b0\\out"
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#unicode-ident@1.0.14",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\unicode-ident-1.0.14\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "unicode_ident",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\unicode-ident-1.0.14\\src\\lib.rs",
                "edition": "2018",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpnxzfs7w2\\prost-0.14.1\\target\\debug\\deps\\libunicode_ident-6d74e9fad9aef6d6.rlib",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpnxzfs7w2\\prost-0.14.1\\target\\debug\\deps\\libunicode_ident-6d74e9fad9aef6d6.rmeta"
              ],
              "executable": null,
              "fresh": true
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#anyhow@1.0.93",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\anyhow-1.0.93\\Cargo.toml",
              "target": {
                "kind": [
                  "custom-build"
                ],
                "crate_types": [
                  "bin"
                ],
                "name": "build-script-build",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\anyhow-1.0.93\\build.rs",
                "edition": "2018",
                "doc": false,
                "doctest": false,
                "test": false
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "default",
                "std"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpnxzfs7w2\\prost-0.14.1\\target\\debug\\build\\anyhow-64cd7f3e983b421d\\build-script-build.exe",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpnxzfs7w2\\prost-0.14.1\\target\\debug\\build\\anyhow-64cd7f3e983b421d\\build_script_build.pdb"
              ],
              "executable": null,
              "fresh": true
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#either@1.13.0",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\either-1.13.0\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "either",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\either-1.13.0\\src\\lib.rs",
                "edition": "2018",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "use_std"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpnxzfs7w2\\prost-0.14.1\\target\\debug\\deps\\libeither-c8d9c235f36fd744.rlib",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpnxzfs7w2\\prost-0.14.1\\target\\debug\\deps\\libeither-c8d9c235f36fd744.rmeta"
              ],
              "executable": null,
              "fresh": true
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#bytes@1.8.0",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\bytes-1.8.0\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "bytes",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\bytes-1.8.0\\src\\lib.rs",
                "edition": "2018",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpnxzfs7w2\\prost-0.14.1\\target\\debug\\deps\\libbytes-8636e0fd25e61635.rmeta"
              ],
              "executable": null,
              "fresh": true
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#proc-macro2@1.0.92",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\proc-macro2-1.0.92\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "proc_macro2",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\proc-macro2-1.0.92\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "default",
                "proc-macro"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpnxzfs7w2\\prost-0.14.1\\target\\debug\\deps\\libproc_macro2-d5fd467c52aaa1fd.rlib",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpnxzfs7w2\\prost-0.14.1\\target\\debug\\deps\\libproc_macro2-d5fd467c52aaa1fd.rmeta"
              ],
              "executable": null,
              "fresh": true
            },
            {
              "reason": "build-script-executed",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#anyhow@1.0.93",
              "linked_libs": [],
              "linked_paths": [],
              "cfgs": [
                "std_backtrace"
              ],
              "env": [],
              "out_dir": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpnxzfs7w2\\prost-0.14.1\\target\\debug\\build\\anyhow-de9a70ee98cead31\\out"
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#itertools@0.10.5",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\itertools-0.10.5\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "itertools",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\itertools-0.10.5\\src\\lib.rs",
                "edition": "2018",
                "doc": true,
                "doctest": true,
                "test": false
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "default",
                "use_alloc",
                "use_std"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpnxzfs7w2\\prost-0.14.1\\target\\debug\\deps\\libitertools-a5c90c128f44cd78.rlib",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpnxzfs7w2\\prost-0.14.1\\target\\debug\\deps\\libitertools-a5c90c128f44cd78.rmeta"
              ],
              "executable": null,
              "fresh": true
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#quote@1.0.37",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\quote-1.0.37\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "quote",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\quote-1.0.37\\src\\lib.rs",
                "edition": "2018",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "default",
                "proc-macro"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpnxzfs7w2\\prost-0.14.1\\target\\debug\\deps\\libquote-ecc6cad931967ccf.rlib",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpnxzfs7w2\\prost-0.14.1\\target\\debug\\deps\\libquote-ecc6cad931967ccf.rmeta"
              ],
              "executable": null,
              "fresh": true
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#anyhow@1.0.93",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\anyhow-1.0.93\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "anyhow",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\anyhow-1.0.93\\src\\lib.rs",
                "edition": "2018",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "default",
                "std"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpnxzfs7w2\\prost-0.14.1\\target\\debug\\deps\\libanyhow-8b46a6a5b5a74952.rlib",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpnxzfs7w2\\prost-0.14.1\\target\\debug\\deps\\libanyhow-8b46a6a5b5a74952.rmeta"
              ],
              "executable": null,
              "fresh": true
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#syn@2.0.89",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.89\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "syn",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\syn-2.0.89\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "clone-impls",
                "default",
                "derive",
                "extra-traits",
                "parsing",
                "printing",
                "proc-macro"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpnxzfs7w2\\prost-0.14.1\\target\\debug\\deps\\libsyn-8550bcf0660806e2.rlib",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpnxzfs7w2\\prost-0.14.1\\target\\debug\\deps\\libsyn-8550bcf0660806e2.rmeta"
              ],
              "executable": null,
              "fresh": true
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#prost-derive@0.14.1",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\prost-derive-0.14.1\\Cargo.toml",
              "target": {
                "kind": [
                  "proc-macro"
                ],
                "crate_types": [
                  "proc-macro"
                ],
                "name": "prost_derive",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\prost-derive-0.14.1\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpnxzfs7w2\\prost-0.14.1\\target\\debug\\deps\\prost_derive-976d71f91c3565cd.dll",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpnxzfs7w2\\prost-0.14.1\\target\\debug\\deps\\prost_derive-976d71f91c3565cd.dll.lib",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpnxzfs7w2\\prost-0.14.1\\target\\debug\\deps\\prost_derive-976d71f91c3565cd.dll.exp",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpnxzfs7w2\\prost-0.14.1\\target\\debug\\deps\\prost_derive-976d71f91c3565cd.pdb"
              ],
              "executable": null,
              "fresh": true
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpnxzfs7w2/prost-0.14.1#prost@0.14.1",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpnxzfs7w2\\prost-0.14.1\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "prost",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpnxzfs7w2\\prost-0.14.1\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: variables can be used directly in the `format!` string\n  --> src\\error.rs:68:13\n   |\n68 |             write!(f, \"{}.{}: \", message, field)?;\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#uninlined_format_args\n   = note: `#[warn(clippy::uninlined_format_args)]` on by default\nhelp: change this to\n   |\n68 -             write!(f, \"{}.{}: \", message, field)?;\n68 +             write!(f, \"{message}.{field}: \")?;\n   |\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#uninlined_format_args",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "note",
                    "message": "`#[warn(clippy::uninlined_format_args)]` on by default",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "change this to",
                    "rendered": null,
                    "spans": [
                      {
                        "byte_end": 2164,
                        "byte_start": 2164,
                        "column_end": 25,
                        "column_start": 25,
                        "expansion": null,
                        "file_name": "src\\error.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 68,
                        "line_start": 68,
                        "suggested_replacement": "message",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 25,
                            "highlight_start": 25,
                            "text": "            write!(f, \"{}.{}: \", message, field)?;"
                          }
                        ]
                      },
                      {
                        "byte_end": 2167,
                        "byte_start": 2167,
                        "column_end": 28,
                        "column_start": 28,
                        "expansion": null,
                        "file_name": "src\\error.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 68,
                        "line_start": 68,
                        "suggested_replacement": "field",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 28,
                            "highlight_start": 28,
                            "text": "            write!(f, \"{}.{}: \", message, field)?;"
                          }
                        ]
                      },
                      {
                        "byte_end": 2180,
                        "byte_start": 2171,
                        "column_end": 41,
                        "column_start": 32,
                        "expansion": null,
                        "file_name": "src\\error.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 68,
                        "line_start": 68,
                        "suggested_replacement": "",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 41,
                            "highlight_start": 32,
                            "text": "            write!(f, \"{}.{}: \", message, field)?;"
                          }
                        ]
                      },
                      {
                        "byte_end": 2187,
                        "byte_start": 2180,
                        "column_end": 48,
                        "column_start": 41,
                        "expansion": null,
                        "file_name": "src\\error.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 68,
                        "line_start": 68,
                        "suggested_replacement": "",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 48,
                            "highlight_start": 41,
                            "text": "            write!(f, \"{}.{}: \", message, field)?;"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "code": {
                  "code": "clippy::uninlined_format_args",
                  "explanation": null
                },
                "level": "warning",
                "message": "variables can be used directly in the `format!` string",
                "spans": [
                  {
                    "byte_end": 2188,
                    "byte_start": 2152,
                    "column_end": 49,
                    "column_start": 13,
                    "expansion": null,
                    "file_name": "src\\error.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 68,
                    "line_start": 68,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 49,
                        "highlight_start": 13,
                        "text": "            write!(f, \"{}.{}: \", message, field)?;"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpnxzfs7w2/prost-0.14.1#prost@0.14.1",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpnxzfs7w2\\prost-0.14.1\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "prost",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpnxzfs7w2\\prost-0.14.1\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: variables can be used directly in the `format!` string\n  --> src\\encoding\\wire_type.rs:30:39\n   |\n30 |               _ => Err(DecodeError::new(format!(\n   |  _______________________________________^\n31 | |                 \"invalid wire type value: {}\",\n32 | |                 value\n33 | |             ))),\n   | |_____________^\n   |\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#uninlined_format_args\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#uninlined_format_args",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "change this to",
                    "rendered": null,
                    "spans": [
                      {
                        "byte_end": 871,
                        "byte_start": 871,
                        "column_end": 44,
                        "column_start": 44,
                        "expansion": null,
                        "file_name": "src\\encoding\\wire_type.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 31,
                        "line_start": 31,
                        "suggested_replacement": "value",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 44,
                            "highlight_start": 44,
                            "text": "                \"invalid wire type value: {}\","
                          }
                        ]
                      },
                      {
                        "byte_end": 896,
                        "byte_start": 873,
                        "column_end": 22,
                        "column_start": 46,
                        "expansion": null,
                        "file_name": "src\\encoding\\wire_type.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 32,
                        "line_start": 31,
                        "suggested_replacement": "",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 47,
                            "highlight_start": 46,
                            "text": "                \"invalid wire type value: {}\","
                          },
                          {
                            "highlight_end": 22,
                            "highlight_start": 1,
                            "text": "                value"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "code": {
                  "code": "clippy::uninlined_format_args",
                  "explanation": null
                },
                "level": "warning",
                "message": "variables can be used directly in the `format!` string",
                "spans": [
                  {
                    "byte_end": 910,
                    "byte_start": 819,
                    "column_end": 14,
                    "column_start": 39,
                    "expansion": null,
                    "file_name": "src\\encoding\\wire_type.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 33,
                    "line_start": 30,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 47,
                        "highlight_start": 39,
                        "text": "            _ => Err(DecodeError::new(format!("
                      },
                      {
                        "highlight_end": 47,
                        "highlight_start": 1,
                        "text": "                \"invalid wire type value: {}\","
                      },
                      {
                        "highlight_end": 22,
                        "highlight_start": 1,
                        "text": "                value"
                      },
                      {
                        "highlight_end": 14,
                        "highlight_start": 1,
                        "text": "            ))),"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpnxzfs7w2/prost-0.14.1#prost@0.14.1",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpnxzfs7w2\\prost-0.14.1\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "prost",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpnxzfs7w2\\prost-0.14.1\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: variables can be used directly in the `format!` string\n  --> src\\encoding\\wire_type.rs:43:37\n   |\n43 |           return Err(DecodeError::new(format!(\n   |  _____________________________________^\n44 | |             \"invalid wire type: {:?} (expected {:?})\",\n45 | |             actual, expected\n46 | |         )));\n   | |_________^\n   |\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#uninlined_format_args\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#uninlined_format_args",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "change this to",
                    "rendered": null,
                    "spans": [
                      {
                        "byte_end": 1240,
                        "byte_start": 1240,
                        "column_end": 34,
                        "column_start": 34,
                        "expansion": null,
                        "file_name": "src\\encoding\\wire_type.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 44,
                        "line_start": 44,
                        "suggested_replacement": "actual",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 34,
                            "highlight_start": 34,
                            "text": "            \"invalid wire type: {:?} (expected {:?})\","
                          }
                        ]
                      },
                      {
                        "byte_end": 1255,
                        "byte_start": 1255,
                        "column_end": 49,
                        "column_start": 49,
                        "expansion": null,
                        "file_name": "src\\encoding\\wire_type.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 44,
                        "line_start": 44,
                        "suggested_replacement": "expected",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 49,
                            "highlight_start": 49,
                            "text": "            \"invalid wire type: {:?} (expected {:?})\","
                          }
                        ]
                      },
                      {
                        "byte_end": 1280,
                        "byte_start": 1260,
                        "column_end": 19,
                        "column_start": 54,
                        "expansion": null,
                        "file_name": "src\\encoding\\wire_type.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 45,
                        "line_start": 44,
                        "suggested_replacement": "",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 55,
                            "highlight_start": 54,
                            "text": "            \"invalid wire type: {:?} (expected {:?})\","
                          },
                          {
                            "highlight_end": 19,
                            "highlight_start": 1,
                            "text": "            actual, expected"
                          }
                        ]
                      },
                      {
                        "byte_end": 1290,
                        "byte_start": 1280,
                        "column_end": 29,
                        "column_start": 19,
                        "expansion": null,
                        "file_name": "src\\encoding\\wire_type.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 45,
                        "line_start": 45,
                        "suggested_replacement": "",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 29,
                            "highlight_start": 19,
                            "text": "            actual, expected"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "code": {
                  "code": "clippy::uninlined_format_args",
                  "explanation": null
                },
                "level": "warning",
                "message": "variables can be used directly in the `format!` string",
                "spans": [
                  {
                    "byte_end": 1300,
                    "byte_start": 1198,
                    "column_end": 10,
                    "column_start": 37,
                    "expansion": null,
                    "file_name": "src\\encoding\\wire_type.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 46,
                    "line_start": 43,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 45,
                        "highlight_start": 37,
                        "text": "        return Err(DecodeError::new(format!("
                      },
                      {
                        "highlight_end": 55,
                        "highlight_start": 1,
                        "text": "            \"invalid wire type: {:?} (expected {:?})\","
                      },
                      {
                        "highlight_end": 29,
                        "highlight_start": 1,
                        "text": "            actual, expected"
                      },
                      {
                        "highlight_end": 10,
                        "highlight_start": 1,
                        "text": "        )));"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpnxzfs7w2/prost-0.14.1#prost@0.14.1",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpnxzfs7w2\\prost-0.14.1\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "prost",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpnxzfs7w2\\prost-0.14.1\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: variables can be used directly in the `format!` string\n   --> src\\encoding.rs:118:37\n    |\n118 |         return Err(DecodeError::new(format!(\"invalid key value: {}\", key)));\n    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#uninlined_format_args\nhelp: change this to\n    |\n118 -         return Err(DecodeError::new(format!(\"invalid key value: {}\", key)));\n118 +         return Err(DecodeError::new(format!(\"invalid key value: {key}\")));\n    |\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#uninlined_format_args",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "change this to",
                    "rendered": null,
                    "spans": [
                      {
                        "byte_end": 3818,
                        "byte_start": 3818,
                        "column_end": 66,
                        "column_start": 66,
                        "expansion": null,
                        "file_name": "src\\encoding.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 118,
                        "line_start": 118,
                        "suggested_replacement": "key",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 66,
                            "highlight_start": 66,
                            "text": "        return Err(DecodeError::new(format!(\"invalid key value: {}\", key)));"
                          }
                        ]
                      },
                      {
                        "byte_end": 3825,
                        "byte_start": 3820,
                        "column_end": 73,
                        "column_start": 68,
                        "expansion": null,
                        "file_name": "src\\encoding.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 118,
                        "line_start": 118,
                        "suggested_replacement": "",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 73,
                            "highlight_start": 68,
                            "text": "        return Err(DecodeError::new(format!(\"invalid key value: {}\", key)));"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "code": {
                  "code": "clippy::uninlined_format_args",
                  "explanation": null
                },
                "level": "warning",
                "message": "variables can be used directly in the `format!` string",
                "spans": [
                  {
                    "byte_end": 3826,
                    "byte_start": 3789,
                    "column_end": 74,
                    "column_start": 37,
                    "expansion": null,
                    "file_name": "src\\encoding.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 118,
                    "line_start": 118,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 74,
                        "highlight_start": 37,
                        "text": "        return Err(DecodeError::new(format!(\"invalid key value: {}\", key)));"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpnxzfs7w2/prost-0.14.1#prost@0.14.1",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpnxzfs7w2\\prost-0.14.1\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "prost",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpnxzfs7w2\\prost-0.14.1\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: this function has too many arguments (8/7)\n    --> src\\encoding.rs:1023:9\n     |\n1023 | /         pub fn encode_with_default<K, V, B, KE, KL, VE, VL>(\n1024 | |             key_encode: KE,\n1025 | |             key_encoded_len: KL,\n1026 | |             val_encode: VE,\n...    |\n1031 | |             buf: &mut B,\n1032 | |         ) where\n     | |_________^\n...\n1138 |       map!(HashMap);\n     |       ------------- in this macro invocation\n     |\n     = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#too_many_arguments\n     = note: `#[warn(clippy::too_many_arguments)]` on by default\n     = note: this warning originates in the macro `map` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#too_many_arguments",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "note",
                    "message": "`#[warn(clippy::too_many_arguments)]` on by default",
                    "rendered": null,
                    "spans": []
                  }
                ],
                "code": {
                  "code": "clippy::too_many_arguments",
                  "explanation": null
                },
                "level": "warning",
                "message": "this function has too many arguments (8/7)",
                "spans": [
                  {
                    "byte_end": 31945,
                    "byte_start": 31649,
                    "column_end": 10,
                    "column_start": 9,
                    "expansion": {
                      "def_site_span": {
                        "byte_end": 29299,
                        "byte_start": 29283,
                        "column_end": 17,
                        "column_start": 1,
                        "expansion": null,
                        "file_name": "src\\encoding.rs",
                        "is_primary": false,
                        "label": null,
                        "line_end": 950,
                        "line_start": 950,
                        "suggested_replacement": null,
                        "suggestion_applicability": null,
                        "text": [
                          {
                            "highlight_end": 17,
                            "highlight_start": 1,
                            "text": "macro_rules! map {"
                          }
                        ]
                      },
                      "macro_decl_name": "map!",
                      "span": {
                        "byte_end": 35652,
                        "byte_start": 35639,
                        "column_end": 18,
                        "column_start": 5,
                        "expansion": null,
                        "file_name": "src\\encoding.rs",
                        "is_primary": false,
                        "label": null,
                        "line_end": 1138,
                        "line_start": 1138,
                        "suggested_replacement": null,
                        "suggestion_applicability": null,
                        "text": [
                          {
                            "highlight_end": 18,
                            "highlight_start": 5,
                            "text": "    map!(HashMap);"
                          }
                        ]
                      }
                    },
                    "file_name": "src\\encoding.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 1032,
                    "line_start": 1023,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 61,
                        "highlight_start": 9,
                        "text": "        pub fn encode_with_default<K, V, B, KE, KL, VE, VL>("
                      },
                      {
                        "highlight_end": 28,
                        "highlight_start": 1,
                        "text": "            key_encode: KE,"
                      },
                      {
                        "highlight_end": 33,
                        "highlight_start": 1,
                        "text": "            key_encoded_len: KL,"
                      },
                      {
                        "highlight_end": 28,
                        "highlight_start": 1,
                        "text": "            val_encode: VE,"
                      },
                      {
                        "highlight_end": 33,
                        "highlight_start": 1,
                        "text": "            val_encoded_len: VL,"
                      },
                      {
                        "highlight_end": 29,
                        "highlight_start": 1,
                        "text": "            val_default: &V,"
                      },
                      {
                        "highlight_end": 22,
                        "highlight_start": 1,
                        "text": "            tag: u32,"
                      },
                      {
                        "highlight_end": 36,
                        "highlight_start": 1,
                        "text": "            values: &$map_ty<K, V>,"
                      },
                      {
                        "highlight_end": 25,
                        "highlight_start": 1,
                        "text": "            buf: &mut B,"
                      },
                      {
                        "highlight_end": 10,
                        "highlight_start": 1,
                        "text": "        ) where"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpnxzfs7w2/prost-0.14.1#prost@0.14.1",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpnxzfs7w2\\prost-0.14.1\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "prost",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpnxzfs7w2\\prost-0.14.1\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: this function has too many arguments (8/7)\n    --> src\\encoding.rs:1023:9\n     |\n1023 | /         pub fn encode_with_default<K, V, B, KE, KL, VE, VL>(\n1024 | |             key_encode: KE,\n1025 | |             key_encoded_len: KL,\n1026 | |             val_encode: VE,\n...    |\n1031 | |             buf: &mut B,\n1032 | |         ) where\n     | |_________^\n...\n1142 |       map!(BTreeMap);\n     |       -------------- in this macro invocation\n     |\n     = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#too_many_arguments\n     = note: this warning originates in the macro `map` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#too_many_arguments",
                    "rendered": null,
                    "spans": []
                  }
                ],
                "code": {
                  "code": "clippy::too_many_arguments",
                  "explanation": null
                },
                "level": "warning",
                "message": "this function has too many arguments (8/7)",
                "spans": [
                  {
                    "byte_end": 31945,
                    "byte_start": 31649,
                    "column_end": 10,
                    "column_start": 9,
                    "expansion": {
                      "def_site_span": {
                        "byte_end": 29299,
                        "byte_start": 29283,
                        "column_end": 17,
                        "column_start": 1,
                        "expansion": null,
                        "file_name": "src\\encoding.rs",
                        "is_primary": false,
                        "label": null,
                        "line_end": 950,
                        "line_start": 950,
                        "suggested_replacement": null,
                        "suggestion_applicability": null,
                        "text": [
                          {
                            "highlight_end": 17,
                            "highlight_start": 1,
                            "text": "macro_rules! map {"
                          }
                        ]
                      },
                      "macro_decl_name": "map!",
                      "span": {
                        "byte_end": 35695,
                        "byte_start": 35681,
                        "column_end": 19,
                        "column_start": 5,
                        "expansion": null,
                        "file_name": "src\\encoding.rs",
                        "is_primary": false,
                        "label": null,
                        "line_end": 1142,
                        "line_start": 1142,
                        "suggested_replacement": null,
                        "suggestion_applicability": null,
                        "text": [
                          {
                            "highlight_end": 19,
                            "highlight_start": 5,
                            "text": "    map!(BTreeMap);"
                          }
                        ]
                      }
                    },
                    "file_name": "src\\encoding.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 1032,
                    "line_start": 1023,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 61,
                        "highlight_start": 9,
                        "text": "        pub fn encode_with_default<K, V, B, KE, KL, VE, VL>("
                      },
                      {
                        "highlight_end": 28,
                        "highlight_start": 1,
                        "text": "            key_encode: KE,"
                      },
                      {
                        "highlight_end": 33,
                        "highlight_start": 1,
                        "text": "            key_encoded_len: KL,"
                      },
                      {
                        "highlight_end": 28,
                        "highlight_start": 1,
                        "text": "            val_encode: VE,"
                      },
                      {
                        "highlight_end": 33,
                        "highlight_start": 1,
                        "text": "            val_encoded_len: VL,"
                      },
                      {
                        "highlight_end": 29,
                        "highlight_start": 1,
                        "text": "            val_default: &V,"
                      },
                      {
                        "highlight_end": 22,
                        "highlight_start": 1,
                        "text": "            tag: u32,"
                      },
                      {
                        "highlight_end": 36,
                        "highlight_start": 1,
                        "text": "            values: &$map_ty<K, V>,"
                      },
                      {
                        "highlight_end": 25,
                        "highlight_start": 1,
                        "text": "            buf: &mut B,"
                      },
                      {
                        "highlight_end": 10,
                        "highlight_start": 1,
                        "text": "        ) where"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-artifact",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpnxzfs7w2/prost-0.14.1#prost@0.14.1",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpnxzfs7w2\\prost-0.14.1\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "prost",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpnxzfs7w2\\prost-0.14.1\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "default",
                "derive",
                "std"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpnxzfs7w2\\prost-0.14.1\\target\\debug\\deps\\libprost-a3c16d5f4a5ce3df.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "build-finished",
              "success": true
            }
          ],
          "audit": {
            "database": {
              "advisory-count": 787,
              "last-commit": "7573f55ba337263f61167dbb0ea926cdc7c8eb5d",
              "last-updated": "2025-06-17T11:04:25+02:00"
            },
            "lockfile": {
              "dependency-count": 88
            },
            "settings": {
              "target_arch": [],
              "target_os": [],
              "severity": null,
              "ignore": [],
              "informational_warnings": [
                "unmaintained",
                "unsound",
                "notice"
              ]
            },
            "vulnerabilities": {
              "found": false,
              "count": 0,
              "list": []
            },
            "warnings": {}
          },
          "note": "Crate analysis performed with stable toolchain."
        },
        "crate_metadata": {
          "name": "prost",
          "version": "0.14.1",
          "description": "ALLOW: Positive community sentiment",
          "repository": "",
          "keywords": [],
          "categories": [],
          "readme": {
            "raw_markdown": "[](https://docs.rs/prost/latest/prost/all.html \"show sidebar\")\n# Crate prostCopy item path\n[Settings](https://docs.rs/prost/latest/settings.html)\n[Help](https://docs.rs/prost/latest/help.html)\nSummary[Source](https://docs.rs/prost/latest/src/prost/lib.rs.html#1-42)\nExpand description\n[![continuous integration](https://github.com/tokio-rs/prost/actions/workflows/ci.yml/badge.svg?branch=master)](https://github.com/tokio-rs/prost/actions/workflows/ci.yml?query=branch%3Amaster) [![Documentation](https://docs.rs/prost/badge.svg)](https://docs.rs/prost/) [![Crate](https://img.shields.io/crates/v/prost.svg)](https://crates.io/crates/prost) [![Dependency Status](https://deps.rs/repo/github/tokio-rs/prost/status.svg)](https://deps.rs/repo/github/tokio-rs/prost) [![Discord](https://img.shields.io/discord/500028886025895936)](https://discord.gg/tokio)\n## [\u00a7](https://docs.rs/prost/latest/prost/#prost) _PROST!_\n`prost` is a [Protocol Buffers](https://developers.google.com/protocol-buffers/) implementation for the [Rust Language](https://www.rust-lang.org/). `prost` generates simple, idiomatic Rust code from `proto2` and `proto3` files.\nCompared to other Protocol Buffers implementations, `prost`\n  * Generates simple, idiomatic, and readable Rust types by taking advantage of Rust `derive` attributes.\n  * Retains comments from `.proto` files in generated Rust code.\n  * Allows existing Rust types (not generated from a `.proto`) to be serialized and deserialized by adding attributes.\n  * Uses the [`bytes::{Buf, BufMut}`](https://github.com/carllerche/bytes) abstractions for serialization instead of `std::io::{Read, Write}`.\n  * Respects the Protobuf `package` specifier when organizing generated code into Rust modules.\n  * Preserves unknown enum values during deserialization.\n  * Does not include support for runtime reflection or message descriptors.\n\n\n### [\u00a7](https://docs.rs/prost/latest/prost/#using-prost-in-a-cargo-project)Using `prost` in a Cargo Project\nFirst, add `prost` and its public dependencies to your `Cargo.toml`:\n[\u24d8](https://docs.rs/prost/latest/prost/ \"This example is not tested\")```\n[dependencies]\nprost = \"0.14\"\nprost-types = \"0.14\"\n```\n\nThe recommended way to add `.proto` compilation to a Cargo project is to use the `prost-build` library. See the [`prost-build` documentation](https://docs.rs/prost-build/latest/prost_build/) for more details and examples.\nSee the [snazzy repository](https://github.com/danburkert/snazzy) for a simple start-to-finish example.\n#### [\u00a7](https://docs.rs/prost/latest/prost/#msrv)MSRV\n`prost` follows the `tokio-rs` project\u2019s MSRV model and supports 1.70. For more information on the tokio msrv policy you can check it out [here](https://github.com/tokio-rs/tokio/#supported-rust-versions)\n### [\u00a7](https://docs.rs/prost/latest/prost/#generated-code)Generated Code\n`prost` generates Rust code from source `.proto` files using the `proto2` or `proto3` syntax. `prost`\u2019s goal is to make the generated code as simple as possible.\n#### [\u00a7](https://docs.rs/prost/latest/prost/#protoc)`protoc`\nWith `prost-build` v0.11 release, `protoc` will be required to invoke `compile_protos` (unless `skip_protoc` is enabled). Prost will no longer provide bundled `protoc` or attempt to compile `protoc` for users. For install instructions for `protoc`, please check out the [protobuf install](https://github.com/protocolbuffers/protobuf#protobuf-compiler-installation) instructions.\n#### [\u00a7](https://docs.rs/prost/latest/prost/#packages)Packages\nProst can now generate code for `.proto` files that don\u2019t have a package spec. `prost` will translate the Protobuf package into a Rust module. For example, given the `package` specifier:\n```\npackage foo.bar;\n```\n\nAll Rust types generated from the file will be in the `foo::bar` module.\n#### [\u00a7](https://docs.rs/prost/latest/prost/#messages)Messages\nGiven a simple message declaration:\n```\n// Sample message.\nmessage Foo {\n}\n```\n\n`prost` will generate the following Rust struct:\n[\u24d8](https://docs.rs/prost/latest/prost/ \"This example is not tested\")```\n/// Sample message.\n#[derive(Clone, Debug, PartialEq, Message)]\npub struct Foo {\n}\n```\n\n#### [\u00a7](https://docs.rs/prost/latest/prost/#fields-1)Fields\nFields in Protobuf messages are translated into Rust as public struct fields of the corresponding type.\n##### [\u00a7](https://docs.rs/prost/latest/prost/#scalar-values)Scalar Values\nScalar value types are converted as follows:\nProtobuf Type| Rust Type  \n---|---  \n`double`| `f64`  \n`float`| `f32`  \n`int32`| `i32`  \n`int64`| `i64`  \n`uint32`| `u32`  \n`uint64`| `u64`  \n`sint32`| `i32`  \n`sint64`| `i64`  \n`fixed32`| `u32`  \n`fixed64`| `u64`  \n`sfixed32`| `i32`  \n`sfixed64`| `i64`  \n`bool`| `bool`  \n`string`| `String`  \n`bytes`| `Vec<u8>`  \n##### [\u00a7](https://docs.rs/prost/latest/prost/#enumerations)Enumerations\nAll `.proto` enumeration types convert to the Rust `i32` type. Additionally, each enumeration type gets a corresponding Rust `enum` type. For example, this `proto` enum:\n```\nenum PhoneType {\n MOBILE = 0;\n HOME = 1;\n WORK = 2;\n}\n```\n\ngets this corresponding Rust enum [1](https://docs.rs/prost/latest/prost/#fn1):\n[\u24d8](https://docs.rs/prost/latest/prost/ \"This example is not tested\")```\npub enum PhoneType {\n  Mobile = 0,\n  Home = 1,\n  Work = 2,\n}\n```\n\nYou can convert a `PhoneType` value to an `i32` by doing:\n[\u24d8](https://docs.rs/prost/latest/prost/ \"This example is not tested\")```\nPhoneType::Mobile as i32\n```\n\nThe `#[derive(::prost::Enumeration)]` annotation added to the generated `PhoneType` adds these associated functions to the type:\n[\u24d8](https://docs.rs/prost/latest/prost/ \"This example is not tested\")```\nimpl PhoneType {\n  pub fn is_valid(value: i32) -> bool { ... }\n  #[deprecated]\n  pub fn from_i32(value: i32) -> Option<PhoneType> { ... }\n}\n```\n\nIt also adds an `impl TryFrom<i32> for PhoneType`, so you can convert an `i32` to its corresponding `PhoneType` value by doing, for example:\n[\u24d8](https://docs.rs/prost/latest/prost/ \"This example is not tested\")```\nlet phone_type = 2i32;\nmatch PhoneType::try_from(phone_type) {\n  Ok(PhoneType::Mobile) => ...,\n  Ok(PhoneType::Home) => ...,\n  Ok(PhoneType::Work) => ...,\n  Err(_) => ...,\n}\n```\n\nAdditionally, wherever a `proto` enum is used as a field in a `Message`, the message will have \u2018accessor\u2019 methods to get/set the value of the field as the Rust enum type. For instance, this proto `PhoneNumber` message that has a field named `type` of type `PhoneType`:\n```\nmessage PhoneNumber {\n string number = 1;\n PhoneType type = 2;\n}\n```\n\nwill become the following Rust type [2](https://docs.rs/prost/latest/prost/#fn2) with methods `type` and `set_type`:\n[\u24d8](https://docs.rs/prost/latest/prost/ \"This example is not tested\")```\npub struct PhoneNumber {\n  pub number: String,\n  pub r#type: i32, // the `r#` is needed because `type` is a Rust keyword\n}\nimpl PhoneNumber {\n  pub fn r#type(&self) -> PhoneType { ... }\n  pub fn set_type(&mut self, value: PhoneType) { ... }\n}\n```\n\nNote that the getter methods will return the Rust enum\u2019s default value if the field has an invalid `i32` value.\nThe `enum` type isn\u2019t used directly as a field, because the Protobuf spec mandates that enumerations values are \u2018open\u2019, and decoding unrecognized enumeration values must be possible.\n##### [\u00a7](https://docs.rs/prost/latest/prost/#field-modifiers)Field Modifiers\nProtobuf scalar value and enumeration message fields can have a modifier depending on the Protobuf version. Modifiers change the corresponding type of the Rust field:\n`.proto` Version| Modifier| Rust Type  \n---|---|---  \n`proto2`| `optional`| `Option<T>`  \n`proto2`| `required`| `T`  \n`proto3`| default| `T` for scalar types, `Option<T>` otherwise  \n`proto3`| `optional`| `Option<T>`  \n`proto2`/`proto3`| `repeated`| `Vec<T>`  \nNote that in `proto3` the default representation for all user-defined message types is `Option<T>`, and for scalar types just `T` (during decoding, a missing value is populated by `T::default()`). If you need a witness of the presence of a scalar type `T`, use the `optional` modifier to enforce an `Option<T>` representation in the generated Rust struct.\n##### [\u00a7](https://docs.rs/prost/latest/prost/#map-fields)Map Fields\nMap fields are converted to a Rust `HashMap` with key and value type converted from the Protobuf key and value types.\n##### [\u00a7](https://docs.rs/prost/latest/prost/#message-fields)Message Fields\nMessage fields are converted to the corresponding struct type. The table of field modifiers above applies to message fields, except that `proto3` message fields without a modifier (the default) will be wrapped in an `Option`. Typically message fields are unboxed. `prost` will automatically box a message field if the field type and the parent type are recursively nested in order to avoid an infinite sized struct.\n##### [\u00a7](https://docs.rs/prost/latest/prost/#oneof-fields)Oneof Fields\nOneof fields convert to a Rust enum. Protobuf `oneof`s types are not named, so `prost` uses the name of the `oneof` field for the resulting Rust enum, and defines the enum in a module under the struct. For example, a `proto3` message such as:\n```\nmessage Foo {\n oneof widget {\n  int32 quux = 1;\n  string bar = 2;\n }\n}\n```\n\ngenerates the following Rust[3](https://docs.rs/prost/latest/prost/#fn3):\n[\u24d8](https://docs.rs/prost/latest/prost/ \"This example is not tested\")```\npub struct Foo {\n  pub widget: Option<foo::Widget>,\n}\npub mod foo {\n  pub enum Widget {\n    Quux(i32),\n    Bar(String),\n  }\n}\n```\n\n`oneof` fields are always wrapped in an `Option`.\n#### [\u00a7](https://docs.rs/prost/latest/prost/#services)Services\n`prost-build` allows a custom code-generator to be used for processing `service` definitions. This can be used to output Rust traits according to an application\u2019s specific needs.\n#### [\u00a7](https://docs.rs/prost/latest/prost/#generated-code-example)Generated Code Example\nExample `.proto` file:\n```\nsyntax = \"proto3\";\npackage tutorial;\nmessage Person {\n string name = 1;\n int32 id = 2; // Unique ID number for this person.\n string email = 3;\n enum PhoneType {\n  MOBILE = 0;\n  HOME = 1;\n  WORK = 2;\n }\n message PhoneNumber {\n  string number = 1;\n  PhoneType type = 2;\n }\n repeated PhoneNumber phones = 4;\n}\n// Our address book file is just one of these.\nmessage AddressBook {\n repeated Person people = 1;\n}\n```\n\nand the generated Rust code (`tutorial.rs`):\n[\u24d8](https://docs.rs/prost/latest/prost/ \"This example is not tested\")```\n#[derive(Clone, PartialEq, ::prost::Message)]\npub struct Person {\n  #[prost(string, tag=\"1\")]\n  pub name: ::prost::alloc::string::String,\n  /// Unique ID number for this person.\n  #[prost(int32, tag=\"2\")]\n  pub id: i32,\n  #[prost(string, tag=\"3\")]\n  pub email: ::prost::alloc::string::String,\n  #[prost(message, repeated, tag=\"4\")]\n  pub phones: ::prost::alloc::vec::Vec<person::PhoneNumber>,\n}\n/// Nested message and enum types in `Person`.\npub mod person {\n  #[derive(Clone, PartialEq, ::prost::Message)]\n  pub struct PhoneNumber {\n    #[prost(string, tag=\"1\")]\n    pub number: ::prost::alloc::string::String,\n    #[prost(enumeration=\"PhoneType\", tag=\"2\")]\n    pub r#type: i32,\n  }\n  #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]\n  #[repr(i32)]\n  pub enum PhoneType {\n    Mobile = 0,\n    Home = 1,\n    Work = 2,\n  }\n}\n/// Our address book file is just one of these.\n#[derive(Clone, PartialEq, ::prost::Message)]\npub struct AddressBook {\n  #[prost(message, repeated, tag=\"1\")]\n  pub people: ::prost::alloc::vec::Vec<Person>,\n}\n```\n\n### [\u00a7](https://docs.rs/prost/latest/prost/#accessing-the-protoc-filedescriptorset)Accessing the `protoc` `FileDescriptorSet`\nThe `prost_build::Config::file_descriptor_set_path` option can be used to emit a file descriptor set during the build & code generation step. When used in conjunction with the `std::include_bytes` macro and the `prost_types::FileDescriptorSet` type, applications and libraries using Prost can implement introspection capabilities requiring details from the original `.proto` files.\n### [\u00a7](https://docs.rs/prost/latest/prost/#using-prost-in-a-no_std-crate)Using `prost` in a `no_std` Crate\n`prost` is compatible with `no_std` crates. To enable `no_std` support, disable the `std` features in `prost` and `prost-types`:\n[\u24d8](https://docs.rs/prost/latest/prost/ \"This example is not tested\")```\n[dependencies]\nprost = { version = \"0.14.1\", default-features = false, features = [\"derive\"] }\nprost-types = { version = \"0.14.1\", default-features = false }\n```\n\nAdditionally, configure `prost-build` to output `BTreeMap`s instead of `HashMap`s for all Protobuf `map` fields in your `build.rs`:\n[\u24d8](https://docs.rs/prost/latest/prost/ \"This example is not tested\")```\nlet mut config = prost_build::Config::new();\nconfig.btree_map(&[\".\"]);\n```\n\nWhen using edition 2015, it may be necessary to add an `extern crate core;` directive to the crate which includes `prost`-generated code.\n### [\u00a7](https://docs.rs/prost/latest/prost/#serializing-existing-types)Serializing Existing Types\n`prost` uses a custom derive macro to handle encoding and decoding types, which means that if your existing Rust type is compatible with Protobuf types, you can serialize and deserialize it by adding the appropriate derive and field annotations.\nCurrently the best documentation on adding annotations is to look at the generated code examples above.\n#### [\u00a7](https://docs.rs/prost/latest/prost/#tag-inference-for-existing-types)Tag Inference for Existing Types\nProst automatically infers tags for the struct.\nFields are tagged sequentially in the order they are specified, starting with `1`.\nYou may skip tags which have been reserved, or where there are gaps between sequentially occurring tag values by specifying the tag number to skip to with the `tag` attribute on the first field after the gap. The following fields will be tagged sequentially starting from the next number.\n[\u24d8](https://docs.rs/prost/latest/prost/ \"This example is not tested\")```\nuse prost;\nuse prost::{Enumeration, Message};\n#[derive(Clone, PartialEq, Message)]\nstruct Person {\n  #[prost(string, tag = \"1\")]\n  pub id: String, // tag=1\n  // NOTE: Old \"name\" field has been removed\n  // pub name: String, // tag=2 (Removed)\n  #[prost(string, tag = \"6\")]\n  pub given_name: String, // tag=6\n  #[prost(string)]\n  pub family_name: String, // tag=7\n  #[prost(string)]\n  pub formatted_name: String, // tag=8\n  #[prost(uint32, tag = \"3\")]\n  pub age: u32, // tag=3\n  #[prost(uint32)]\n  pub height: u32, // tag=4\n  #[prost(enumeration = \"Gender\")]\n  pub gender: i32, // tag=5\n  // NOTE: Skip to less commonly occurring fields\n  #[prost(string, tag = \"16\")]\n  pub name_prefix: String, // tag=16 (eg. mr/mrs/ms)\n  #[prost(string)]\n  pub name_suffix: String, // tag=17 (eg. jr/esq)\n  #[prost(string)]\n  pub maiden_name: String, // tag=18\n}\n#[derive(Clone, Copy, Debug, PartialEq, Eq, Enumeration)]\npub enum Gender {\n  Unknown = 0,\n  Female = 1,\n  Male = 2,\n}\n```\n\n### [\u00a7](https://docs.rs/prost/latest/prost/#nix)Nix\nThe prost project maintains flakes support for local development. Once you have nix and nix flakes setup you can just run `nix develop` to get a shell configured with the required dependencies to compile the whole project.\n### [\u00a7](https://docs.rs/prost/latest/prost/#feature-flags)Feature Flags\n  * `std`: Enable integration with standard library. Disable this feature for `no_std` support. This feature is enabled by default.\n  * `derive`: Enable integration with `prost-derive`. Disable this feature to reduce compile times. This feature is enabled by default.\n  * `prost-derive`: Deprecated. Alias for `derive` feature.\n  * `no-recursion-limit`: Disable the recursion limit. The recursion limit is 100 and cannot be customized.\n\n\n### [\u00a7](https://docs.rs/prost/latest/prost/#faq)FAQ\n  1. **Could`prost` be implemented as a serializer for [Serde](https://serde.rs/)?**\n\n\nProbably not, however I would like to hear from a Serde expert on the matter. There are two complications with trying to serialize Protobuf messages with Serde:\n  * Protobuf fields require a numbered tag, and currently there appears to be no mechanism suitable for this in `serde`.\n  * The mapping of Protobuf type to Rust type is not 1-to-1. As a result, trait-based approaches to dispatching don\u2019t work very well. Example: six different Protobuf field types correspond to a Rust `Vec<i32>`: `repeated int32`, `repeated sint32`, `repeated sfixed32`, and their packed counterparts.\n\n\nBut it is possible to place `serde` derive tags onto the generated types, so the same structure can support both `prost` and `Serde`.\n  1. **I get errors when trying to run`cargo test` on MacOS**\n\n\nIf the errors are about missing `autoreconf` or similar, you can probably fix them by running\n[\u24d8](https://docs.rs/prost/latest/prost/ \"This example is not tested\")```\nbrew install automake\nbrew install libtool\n```\n\n### [\u00a7](https://docs.rs/prost/latest/prost/#license)License\n`prost` is distributed under the terms of the Apache License (Version 2.0).\nSee [LICENSE](https://github.com/tokio-rs/prost/blob/master/LICENSE) for details.\nCopyright 2022 Dan Burkert & Tokio Contributors\n  1. Annotations have been elided for clarity. See below for a full example. [\u21a9](https://docs.rs/prost/latest/prost/#fnref1)\n  2. Annotations have been elided for clarity. See below for a full example. [\u21a9](https://docs.rs/prost/latest/prost/#fnref2)\n  3. Annotations have been elided for clarity. See below for a full example. [\u21a9](https://docs.rs/prost/latest/prost/#fnref3)\n\n\n## Re-exports[\u00a7](https://docs.rs/prost/latest/prost/#reexports)\n\n`pub use bytes[](https://docs.rs/bytes/1.10.1/x86_64-unknown-linux-gnu/bytes/index.html \"mod bytes\");`\n\n## Structs[\u00a7](https://docs.rs/prost/latest/prost/#structs)\n\n[DecodeError](https://docs.rs/prost/latest/prost/struct.DecodeError.html \"struct prost::DecodeError\")\n    A Protobuf message decoding error.\n\n[EncodeError](https://docs.rs/prost/latest/prost/struct.EncodeError.html \"struct prost::EncodeError\")\n    A Protobuf message encoding error.\n\n[UnknownEnumValue](https://docs.rs/prost/latest/prost/struct.UnknownEnumValue.html \"struct prost::UnknownEnumValue\")\n    An error indicating that an unknown enumeration value was encountered.\n## Traits[\u00a7](https://docs.rs/prost/latest/prost/#traits)\n\n[Message](https://docs.rs/prost/latest/prost/trait.Message.html \"trait prost::Message\")\n    A Protocol Buffers message.\n\n[Name](https://docs.rs/prost/latest/prost/trait.Name.html \"trait prost::Name\")\n    Associate a type name with a [`Message`](https://docs.rs/prost/latest/prost/trait.Message.html \"trait prost::Message\") type.\n## Functions[\u00a7](https://docs.rs/prost/latest/prost/#functions)\n\n[decode_length_delimiter](https://docs.rs/prost/latest/prost/fn.decode_length_delimiter.html \"fn prost::decode_length_delimiter\")\n    Decodes a length delimiter from the buffer.\n\n[encode_length_delimiter](https://docs.rs/prost/latest/prost/fn.encode_length_delimiter.html \"fn prost::encode_length_delimiter\")\n    Encodes a length delimiter to the buffer.\n\n[length_delimiter_len](https://docs.rs/prost/latest/prost/fn.length_delimiter_len.html \"fn prost::length_delimiter_len\")\n    Returns the encoded length of a length delimiter.\n",
            "markdown_with_citations": "[](https://docs.rs/prost/latest/prost/all.html \"show sidebar\")\n# Crate prostCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\n![continuous integration\u27e84\u27e9](https://github.com/tokio-rs/prost/actions/workflows/ci.yml?query=branch%3Amaster) ![Documentation\u27e85\u27e9](https://docs.rs/prost/) ![Crate\u27e86\u27e9](https://crates.io/crates/prost) ![Dependency Status\u27e87\u27e9](https://deps.rs/repo/github/tokio-rs/prost) ![Discord\u27e88\u27e9](https://discord.gg/tokio)\n## \u00a7\u27e89\u27e9 _PROST!_\n`prost` is a Protocol Buffers\u27e810\u27e9 implementation for the Rust Language\u27e811\u27e9. `prost` generates simple, idiomatic Rust code from `proto2` and `proto3` files.\nCompared to other Protocol Buffers implementations, `prost`\n  * Generates simple, idiomatic, and readable Rust types by taking advantage of Rust `derive` attributes.\n  * Retains comments from `.proto` files in generated Rust code.\n  * Allows existing Rust types (not generated from a `.proto`) to be serialized and deserialized by adding attributes.\n  * Uses the `bytes::{Buf, BufMut}`\u27e812\u27e9 abstractions for serialization instead of `std::io::{Read, Write}`.\n  * Respects the Protobuf `package` specifier when organizing generated code into Rust modules.\n  * Preserves unknown enum values during deserialization.\n  * Does not include support for runtime reflection or message descriptors.\n\n\n### \u00a7\u27e813\u27e9Using `prost` in a Cargo Project\nFirst, add `prost` and its public dependencies to your `Cargo.toml`:\n\u24d8\u27e814\u27e9```\n[dependencies]\nprost = \"0.14\"\nprost-types = \"0.14\"\n```\n\nThe recommended way to add `.proto` compilation to a Cargo project is to use the `prost-build` library. See the `prost-build` documentation\u27e815\u27e9 for more details and examples.\nSee the snazzy repository\u27e816\u27e9 for a simple start-to-finish example.\n#### \u00a7\u27e817\u27e9MSRV\n`prost` follows the `tokio-rs` project\u2019s MSRV model and supports 1.70. For more information on the tokio msrv policy you can check it out here\u27e818\u27e9\n### \u00a7\u27e819\u27e9Generated Code\n`prost` generates Rust code from source `.proto` files using the `proto2` or `proto3` syntax. `prost`\u2019s goal is to make the generated code as simple as possible.\n#### \u00a7\u27e820\u27e9`protoc`\nWith `prost-build` v0.11 release, `protoc` will be required to invoke `compile_protos` (unless `skip_protoc` is enabled). Prost will no longer provide bundled `protoc` or attempt to compile `protoc` for users. For install instructions for `protoc`, please check out the protobuf install\u27e821\u27e9 instructions.\n#### \u00a7\u27e822\u27e9Packages\nProst can now generate code for `.proto` files that don\u2019t have a package spec. `prost` will translate the Protobuf package into a Rust module. For example, given the `package` specifier:\n```\npackage foo.bar;\n```\n\nAll Rust types generated from the file will be in the `foo::bar` module.\n#### \u00a7\u27e823\u27e9Messages\nGiven a simple message declaration:\n```\n// Sample message.\nmessage Foo {\n}\n```\n\n`prost` will generate the following Rust struct:\n\u24d8\u27e814\u27e9```\n/// Sample message.\n#[derive(Clone, Debug, PartialEq, Message)]\npub struct Foo {\n}\n```\n\n#### \u00a7\u27e824\u27e9Fields\nFields in Protobuf messages are translated into Rust as public struct fields of the corresponding type.\n##### \u00a7\u27e825\u27e9Scalar Values\nScalar value types are converted as follows:\nProtobuf Type| Rust Type  \n---|---  \n`double`| `f64`  \n`float`| `f32`  \n`int32`| `i32`  \n`int64`| `i64`  \n`uint32`| `u32`  \n`uint64`| `u64`  \n`sint32`| `i32`  \n`sint64`| `i64`  \n`fixed32`| `u32`  \n`fixed64`| `u64`  \n`sfixed32`| `i32`  \n`sfixed64`| `i64`  \n`bool`| `bool`  \n`string`| `String`  \n`bytes`| `Vec<u8>`  \n##### \u00a7\u27e826\u27e9Enumerations\nAll `.proto` enumeration types convert to the Rust `i32` type. Additionally, each enumeration type gets a corresponding Rust `enum` type. For example, this `proto` enum:\n```\nenum PhoneType {\n MOBILE = 0;\n HOME = 1;\n WORK = 2;\n}\n```\n\ngets this corresponding Rust enum 1\u27e827\u27e9:\n\u24d8\u27e814\u27e9```\npub enum PhoneType {\n  Mobile = 0,\n  Home = 1,\n  Work = 2,\n}\n```\n\nYou can convert a `PhoneType` value to an `i32` by doing:\n\u24d8\u27e814\u27e9```\nPhoneType::Mobile as i32\n```\n\nThe `#[derive(::prost::Enumeration)]` annotation added to the generated `PhoneType` adds these associated functions to the type:\n\u24d8\u27e814\u27e9```\nimpl PhoneType {\n  pub fn is_valid(value: i32) -> bool { ... }\n  #[deprecated]\n  pub fn from_i32(value: i32) -> Option<PhoneType> { ... }\n}\n```\n\nIt also adds an `impl TryFrom<i32> for PhoneType`, so you can convert an `i32` to its corresponding `PhoneType` value by doing, for example:\n\u24d8\u27e814\u27e9```\nlet phone_type = 2i32;\nmatch PhoneType::try_from(phone_type) {\n  Ok(PhoneType::Mobile) => ...,\n  Ok(PhoneType::Home) => ...,\n  Ok(PhoneType::Work) => ...,\n  Err(_) => ...,\n}\n```\n\nAdditionally, wherever a `proto` enum is used as a field in a `Message`, the message will have \u2018accessor\u2019 methods to get/set the value of the field as the Rust enum type. For instance, this proto `PhoneNumber` message that has a field named `type` of type `PhoneType`:\n```\nmessage PhoneNumber {\n string number = 1;\n PhoneType type = 2;\n}\n```\n\nwill become the following Rust type 2\u27e828\u27e9 with methods `type` and `set_type`:\n\u24d8\u27e814\u27e9```\npub struct PhoneNumber {\n  pub number: String,\n  pub r#type: i32, // the `r#` is needed because `type` is a Rust keyword\n}\nimpl PhoneNumber {\n  pub fn r#type(&self) -> PhoneType { ... }\n  pub fn set_type(&mut self, value: PhoneType) { ... }\n}\n```\n\nNote that the getter methods will return the Rust enum\u2019s default value if the field has an invalid `i32` value.\nThe `enum` type isn\u2019t used directly as a field, because the Protobuf spec mandates that enumerations values are \u2018open\u2019, and decoding unrecognized enumeration values must be possible.\n##### \u00a7\u27e829\u27e9Field Modifiers\nProtobuf scalar value and enumeration message fields can have a modifier depending on the Protobuf version. Modifiers change the corresponding type of the Rust field:\n`.proto` Version| Modifier| Rust Type  \n---|---|---  \n`proto2`| `optional`| `Option<T>`  \n`proto2`| `required`| `T`  \n`proto3`| default| `T` for scalar types, `Option<T>` otherwise  \n`proto3`| `optional`| `Option<T>`  \n`proto2`/`proto3`| `repeated`| `Vec<T>`  \nNote that in `proto3` the default representation for all user-defined message types is `Option<T>`, and for scalar types just `T` (during decoding, a missing value is populated by `T::default()`). If you need a witness of the presence of a scalar type `T`, use the `optional` modifier to enforce an `Option<T>` representation in the generated Rust struct.\n##### \u00a7\u27e830\u27e9Map Fields\nMap fields are converted to a Rust `HashMap` with key and value type converted from the Protobuf key and value types.\n##### \u00a7\u27e831\u27e9Message Fields\nMessage fields are converted to the corresponding struct type. The table of field modifiers above applies to message fields, except that `proto3` message fields without a modifier (the default) will be wrapped in an `Option`. Typically message fields are unboxed. `prost` will automatically box a message field if the field type and the parent type are recursively nested in order to avoid an infinite sized struct.\n##### \u00a7\u27e832\u27e9Oneof Fields\nOneof fields convert to a Rust enum. Protobuf `oneof`s types are not named, so `prost` uses the name of the `oneof` field for the resulting Rust enum, and defines the enum in a module under the struct. For example, a `proto3` message such as:\n```\nmessage Foo {\n oneof widget {\n  int32 quux = 1;\n  string bar = 2;\n }\n}\n```\n\ngenerates the following Rust3\u27e833\u27e9:\n\u24d8\u27e814\u27e9```\npub struct Foo {\n  pub widget: Option<foo::Widget>,\n}\npub mod foo {\n  pub enum Widget {\n    Quux(i32),\n    Bar(String),\n  }\n}\n```\n\n`oneof` fields are always wrapped in an `Option`.\n#### \u00a7\u27e834\u27e9Services\n`prost-build` allows a custom code-generator to be used for processing `service` definitions. This can be used to output Rust traits according to an application\u2019s specific needs.\n#### \u00a7\u27e835\u27e9Generated Code Example\nExample `.proto` file:\n```\nsyntax = \"proto3\";\npackage tutorial;\nmessage Person {\n string name = 1;\n int32 id = 2; // Unique ID number for this person.\n string email = 3;\n enum PhoneType {\n  MOBILE = 0;\n  HOME = 1;\n  WORK = 2;\n }\n message PhoneNumber {\n  string number = 1;\n  PhoneType type = 2;\n }\n repeated PhoneNumber phones = 4;\n}\n// Our address book file is just one of these.\nmessage AddressBook {\n repeated Person people = 1;\n}\n```\n\nand the generated Rust code (`tutorial.rs`):\n\u24d8\u27e814\u27e9```\n#[derive(Clone, PartialEq, ::prost::Message)]\npub struct Person {\n  #[prost(string, tag=\"1\")]\n  pub name: ::prost::alloc::string::String,\n  /// Unique ID number for this person.\n  #[prost(int32, tag=\"2\")]\n  pub id: i32,\n  #[prost(string, tag=\"3\")]\n  pub email: ::prost::alloc::string::String,\n  #[prost(message, repeated, tag=\"4\")]\n  pub phones: ::prost::alloc::vec::Vec<person::PhoneNumber>,\n}\n/// Nested message and enum types in `Person`.\npub mod person {\n  #[derive(Clone, PartialEq, ::prost::Message)]\n  pub struct PhoneNumber {\n    #[prost(string, tag=\"1\")]\n    pub number: ::prost::alloc::string::String,\n    #[prost(enumeration=\"PhoneType\", tag=\"2\")]\n    pub r#type: i32,\n  }\n  #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]\n  #[repr(i32)]\n  pub enum PhoneType {\n    Mobile = 0,\n    Home = 1,\n    Work = 2,\n  }\n}\n/// Our address book file is just one of these.\n#[derive(Clone, PartialEq, ::prost::Message)]\npub struct AddressBook {\n  #[prost(message, repeated, tag=\"1\")]\n  pub people: ::prost::alloc::vec::Vec<Person>,\n}\n```\n\n### \u00a7\u27e836\u27e9Accessing the `protoc` `FileDescriptorSet`\nThe `prost_build::Config::file_descriptor_set_path` option can be used to emit a file descriptor set during the build & code generation step. When used in conjunction with the `std::include_bytes` macro and the `prost_types::FileDescriptorSet` type, applications and libraries using Prost can implement introspection capabilities requiring details from the original `.proto` files.\n### \u00a7\u27e837\u27e9Using `prost` in a `no_std` Crate\n`prost` is compatible with `no_std` crates. To enable `no_std` support, disable the `std` features in `prost` and `prost-types`:\n\u24d8\u27e814\u27e9```\n[dependencies]\nprost = { version = \"0.14.1\", default-features = false, features = [\"derive\"] }\nprost-types = { version = \"0.14.1\", default-features = false }\n```\n\nAdditionally, configure `prost-build` to output `BTreeMap`s instead of `HashMap`s for all Protobuf `map` fields in your `build.rs`:\n\u24d8\u27e814\u27e9```\nlet mut config = prost_build::Config::new();\nconfig.btree_map(&[\".\"]);\n```\n\nWhen using edition 2015, it may be necessary to add an `extern crate core;` directive to the crate which includes `prost`-generated code.\n### \u00a7\u27e838\u27e9Serializing Existing Types\n`prost` uses a custom derive macro to handle encoding and decoding types, which means that if your existing Rust type is compatible with Protobuf types, you can serialize and deserialize it by adding the appropriate derive and field annotations.\nCurrently the best documentation on adding annotations is to look at the generated code examples above.\n#### \u00a7\u27e839\u27e9Tag Inference for Existing Types\nProst automatically infers tags for the struct.\nFields are tagged sequentially in the order they are specified, starting with `1`.\nYou may skip tags which have been reserved, or where there are gaps between sequentially occurring tag values by specifying the tag number to skip to with the `tag` attribute on the first field after the gap. The following fields will be tagged sequentially starting from the next number.\n\u24d8\u27e814\u27e9```\nuse prost;\nuse prost::{Enumeration, Message};\n#[derive(Clone, PartialEq, Message)]\nstruct Person {\n  #[prost(string, tag = \"1\")]\n  pub id: String, // tag=1\n  // NOTE: Old \"name\" field has been removed\n  // pub name: String, // tag=2 (Removed)\n  #[prost(string, tag = \"6\")]\n  pub given_name: String, // tag=6\n  #[prost(string)]\n  pub family_name: String, // tag=7\n  #[prost(string)]\n  pub formatted_name: String, // tag=8\n  #[prost(uint32, tag = \"3\")]\n  pub age: u32, // tag=3\n  #[prost(uint32)]\n  pub height: u32, // tag=4\n  #[prost(enumeration = \"Gender\")]\n  pub gender: i32, // tag=5\n  // NOTE: Skip to less commonly occurring fields\n  #[prost(string, tag = \"16\")]\n  pub name_prefix: String, // tag=16 (eg. mr/mrs/ms)\n  #[prost(string)]\n  pub name_suffix: String, // tag=17 (eg. jr/esq)\n  #[prost(string)]\n  pub maiden_name: String, // tag=18\n}\n#[derive(Clone, Copy, Debug, PartialEq, Eq, Enumeration)]\npub enum Gender {\n  Unknown = 0,\n  Female = 1,\n  Male = 2,\n}\n```\n\n### \u00a7\u27e840\u27e9Nix\nThe prost project maintains flakes support for local development. Once you have nix and nix flakes setup you can just run `nix develop` to get a shell configured with the required dependencies to compile the whole project.\n### \u00a7\u27e841\u27e9Feature Flags\n  * `std`: Enable integration with standard library. Disable this feature for `no_std` support. This feature is enabled by default.\n  * `derive`: Enable integration with `prost-derive`. Disable this feature to reduce compile times. This feature is enabled by default.\n  * `prost-derive`: Deprecated. Alias for `derive` feature.\n  * `no-recursion-limit`: Disable the recursion limit. The recursion limit is 100 and cannot be customized.\n\n\n### \u00a7\u27e842\u27e9FAQ\n  1. **Could`prost` be implemented as a serializer for Serde\u27e843\u27e9?**\n\n\nProbably not, however I would like to hear from a Serde expert on the matter. There are two complications with trying to serialize Protobuf messages with Serde:\n  * Protobuf fields require a numbered tag, and currently there appears to be no mechanism suitable for this in `serde`.\n  * The mapping of Protobuf type to Rust type is not 1-to-1. As a result, trait-based approaches to dispatching don\u2019t work very well. Example: six different Protobuf field types correspond to a Rust `Vec<i32>`: `repeated int32`, `repeated sint32`, `repeated sfixed32`, and their packed counterparts.\n\n\nBut it is possible to place `serde` derive tags onto the generated types, so the same structure can support both `prost` and `Serde`.\n  1. **I get errors when trying to run`cargo test` on MacOS**\n\n\nIf the errors are about missing `autoreconf` or similar, you can probably fix them by running\n\u24d8\u27e814\u27e9```\nbrew install automake\nbrew install libtool\n```\n\n### \u00a7\u27e844\u27e9License\n`prost` is distributed under the terms of the Apache License (Version 2.0).\nSee LICENSE\u27e845\u27e9 for details.\nCopyright 2022 Dan Burkert & Tokio Contributors\n  1. Annotations have been elided for clarity. See below for a full example. \u21a9\u27e846\u27e9\n  2. Annotations have been elided for clarity. See below for a full example. \u21a9\u27e847\u27e9\n  3. Annotations have been elided for clarity. See below for a full example. \u21a9\u27e848\u27e9\n\n\n## Re-exports\u00a7\u27e849\u27e9\n\n`pub use bytes[](https://docs.rs/bytes/1.10.1/x86_64-unknown-linux-gnu/bytes/index.html \"mod bytes\");`\n\n## Structs\u00a7\u27e850\u27e9\n\nDecodeError\u27e851\u27e9\n    A Protobuf message decoding error.\n\nEncodeError\u27e852\u27e9\n    A Protobuf message encoding error.\n\nUnknownEnumValue\u27e853\u27e9\n    An error indicating that an unknown enumeration value was encountered.\n## Traits\u00a7\u27e854\u27e9\n\nMessage\u27e855\u27e9\n    A Protocol Buffers message.\n\nName\u27e856\u27e9\n    Associate a type name with a `Message`\u27e855\u27e9 type.\n## Functions\u00a7\u27e857\u27e9\n\ndecode_length_delimiter\u27e858\u27e9\n    Decodes a length delimiter from the buffer.\n\nencode_length_delimiter\u27e859\u27e9\n    Encodes a length delimiter to the buffer.\n\nlength_delimiter_len\u27e860\u27e9\n    Returns the encoded length of a length delimiter.\n",
            "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/prost/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/prost/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/prost/latest/src/prost/lib.rs.html#1-42: Source\n\u27e84\u27e9 https://github.com/tokio-rs/prost/actions/workflows/ci.yml/badge.svg?branch=master: ![continuous integration\n\u27e85\u27e9 https://docs.rs/prost/badge.svg: ![Documentation\n\u27e86\u27e9 https://img.shields.io/crates/v/prost.svg: ![Crate\n\u27e87\u27e9 https://deps.rs/repo/github/tokio-rs/prost/status.svg: ![Dependency Status\n\u27e88\u27e9 https://img.shields.io/discord/500028886025895936: ![Discord\n\u27e89\u27e9 https://docs.rs/prost/latest/prost/#prost: \u00a7\n\u27e810\u27e9 https://developers.google.com/protocol-buffers/: Protocol Buffers\n\u27e811\u27e9 https://www.rust-lang.org/: Rust Language\n\u27e812\u27e9 https://github.com/carllerche/bytes: `bytes::{Buf, BufMut}`\n\u27e813\u27e9 https://docs.rs/prost/latest/prost/#using-prost-in-a-cargo-project: \u00a7\n\u27e814\u27e9 https://docs.rs/prost/latest/prost/: This example is not tested - \u24d8\n\u27e815\u27e9 https://docs.rs/prost-build/latest/prost_build/: `prost-build` documentation\n\u27e816\u27e9 https://github.com/danburkert/snazzy: snazzy repository\n\u27e817\u27e9 https://docs.rs/prost/latest/prost/#msrv: \u00a7\n\u27e818\u27e9 https://github.com/tokio-rs/tokio/#supported-rust-versions: here\n\u27e819\u27e9 https://docs.rs/prost/latest/prost/#generated-code: \u00a7\n\u27e820\u27e9 https://docs.rs/prost/latest/prost/#protoc: \u00a7\n\u27e821\u27e9 https://github.com/protocolbuffers/protobuf#protobuf-compiler-installation: protobuf install\n\u27e822\u27e9 https://docs.rs/prost/latest/prost/#packages: \u00a7\n\u27e823\u27e9 https://docs.rs/prost/latest/prost/#messages: \u00a7\n\u27e824\u27e9 https://docs.rs/prost/latest/prost/#fields-1: \u00a7\n\u27e825\u27e9 https://docs.rs/prost/latest/prost/#scalar-values: \u00a7\n\u27e826\u27e9 https://docs.rs/prost/latest/prost/#enumerations: \u00a7\n\u27e827\u27e9 https://docs.rs/prost/latest/prost/#fn1: 1\n\u27e828\u27e9 https://docs.rs/prost/latest/prost/#fn2: 2\n\u27e829\u27e9 https://docs.rs/prost/latest/prost/#field-modifiers: \u00a7\n\u27e830\u27e9 https://docs.rs/prost/latest/prost/#map-fields: \u00a7\n\u27e831\u27e9 https://docs.rs/prost/latest/prost/#message-fields: \u00a7\n\u27e832\u27e9 https://docs.rs/prost/latest/prost/#oneof-fields: \u00a7\n\u27e833\u27e9 https://docs.rs/prost/latest/prost/#fn3: 3\n\u27e834\u27e9 https://docs.rs/prost/latest/prost/#services: \u00a7\n\u27e835\u27e9 https://docs.rs/prost/latest/prost/#generated-code-example: \u00a7\n\u27e836\u27e9 https://docs.rs/prost/latest/prost/#accessing-the-protoc-filedescriptorset: \u00a7\n\u27e837\u27e9 https://docs.rs/prost/latest/prost/#using-prost-in-a-no_std-crate: \u00a7\n\u27e838\u27e9 https://docs.rs/prost/latest/prost/#serializing-existing-types: \u00a7\n\u27e839\u27e9 https://docs.rs/prost/latest/prost/#tag-inference-for-existing-types: \u00a7\n\u27e840\u27e9 https://docs.rs/prost/latest/prost/#nix: \u00a7\n\u27e841\u27e9 https://docs.rs/prost/latest/prost/#feature-flags: \u00a7\n\u27e842\u27e9 https://docs.rs/prost/latest/prost/#faq: \u00a7\n\u27e843\u27e9 https://serde.rs/: Serde\n\u27e844\u27e9 https://docs.rs/prost/latest/prost/#license: \u00a7\n\u27e845\u27e9 https://github.com/tokio-rs/prost/blob/master/LICENSE: LICENSE\n\u27e846\u27e9 https://docs.rs/prost/latest/prost/#fnref1: \u21a9\n\u27e847\u27e9 https://docs.rs/prost/latest/prost/#fnref2: \u21a9\n\u27e848\u27e9 https://docs.rs/prost/latest/prost/#fnref3: \u21a9\n\u27e849\u27e9 https://docs.rs/prost/latest/prost/#reexports: \u00a7\n\u27e850\u27e9 https://docs.rs/prost/latest/prost/#structs: \u00a7\n\u27e851\u27e9 https://docs.rs/prost/latest/prost/struct.DecodeError.html: struct prost::DecodeError - DecodeError\n\u27e852\u27e9 https://docs.rs/prost/latest/prost/struct.EncodeError.html: struct prost::EncodeError - EncodeError\n\u27e853\u27e9 https://docs.rs/prost/latest/prost/struct.UnknownEnumValue.html: struct prost::UnknownEnumValue - UnknownEnumValue\n\u27e854\u27e9 https://docs.rs/prost/latest/prost/#traits: \u00a7\n\u27e855\u27e9 https://docs.rs/prost/latest/prost/trait.Message.html: trait prost::Message - Message\n\u27e856\u27e9 https://docs.rs/prost/latest/prost/trait.Name.html: trait prost::Name - Name\n\u27e857\u27e9 https://docs.rs/prost/latest/prost/#functions: \u00a7\n\u27e858\u27e9 https://docs.rs/prost/latest/prost/fn.decode_length_delimiter.html: fn prost::decode_length_delimiter - decode_length_delimiter\n\u27e859\u27e9 https://docs.rs/prost/latest/prost/fn.encode_length_delimiter.html: fn prost::encode_length_delimiter - encode_length_delimiter\n\u27e860\u27e9 https://docs.rs/prost/latest/prost/fn.length_delimiter_len.html: fn prost::length_delimiter_len - length_delimiter_len\n",
            "fit_markdown": "",
            "fit_html": ""
          },
          "downloads": 0,
          "github_stars": 0,
          "dependencies": [],
          "features": {},
          "code_snippets": [],
          "readme_sections": {},
          "librs_downloads": null,
          "source": "crates.io",
          "enhanced_scraping": {},
          "enhanced_features": [],
          "enhanced_dependencies": []
        },
        "enriched_crate": {
          "name": "prost",
          "version": "0.14.1",
          "description": "ALLOW: Positive community sentiment",
          "repository": "",
          "keywords": [],
          "categories": [],
          "readme": {
            "raw_markdown": "[](https://docs.rs/prost/latest/prost/all.html \"show sidebar\")\n# Crate prostCopy item path\n[Settings](https://docs.rs/prost/latest/settings.html)\n[Help](https://docs.rs/prost/latest/help.html)\nSummary[Source](https://docs.rs/prost/latest/src/prost/lib.rs.html#1-42)\nExpand description\n[![continuous integration](https://github.com/tokio-rs/prost/actions/workflows/ci.yml/badge.svg?branch=master)](https://github.com/tokio-rs/prost/actions/workflows/ci.yml?query=branch%3Amaster) [![Documentation](https://docs.rs/prost/badge.svg)](https://docs.rs/prost/) [![Crate](https://img.shields.io/crates/v/prost.svg)](https://crates.io/crates/prost) [![Dependency Status](https://deps.rs/repo/github/tokio-rs/prost/status.svg)](https://deps.rs/repo/github/tokio-rs/prost) [![Discord](https://img.shields.io/discord/500028886025895936)](https://discord.gg/tokio)\n## [\u00a7](https://docs.rs/prost/latest/prost/#prost) _PROST!_\n`prost` is a [Protocol Buffers](https://developers.google.com/protocol-buffers/) implementation for the [Rust Language](https://www.rust-lang.org/). `prost` generates simple, idiomatic Rust code from `proto2` and `proto3` files.\nCompared to other Protocol Buffers implementations, `prost`\n  * Generates simple, idiomatic, and readable Rust types by taking advantage of Rust `derive` attributes.\n  * Retains comments from `.proto` files in generated Rust code.\n  * Allows existing Rust types (not generated from a `.proto`) to be serialized and deserialized by adding attributes.\n  * Uses the [`bytes::{Buf, BufMut}`](https://github.com/carllerche/bytes) abstractions for serialization instead of `std::io::{Read, Write}`.\n  * Respects the Protobuf `package` specifier when organizing generated code into Rust modules.\n  * Preserves unknown enum values during deserialization.\n  * Does not include support for runtime reflection or message descriptors.\n\n\n### [\u00a7](https://docs.rs/prost/latest/prost/#using-prost-in-a-cargo-project)Using `prost` in a Cargo Project\nFirst, add `prost` and its public dependencies to your `Cargo.toml`:\n[\u24d8](https://docs.rs/prost/latest/prost/ \"This example is not tested\")```\n[dependencies]\nprost = \"0.14\"\nprost-types = \"0.14\"\n```\n\nThe recommended way to add `.proto` compilation to a Cargo project is to use the `prost-build` library. See the [`prost-build` documentation](https://docs.rs/prost-build/latest/prost_build/) for more details and examples.\nSee the [snazzy repository](https://github.com/danburkert/snazzy) for a simple start-to-finish example.\n#### [\u00a7](https://docs.rs/prost/latest/prost/#msrv)MSRV\n`prost` follows the `tokio-rs` project\u2019s MSRV model and supports 1.70. For more information on the tokio msrv policy you can check it out [here](https://github.com/tokio-rs/tokio/#supported-rust-versions)\n### [\u00a7](https://docs.rs/prost/latest/prost/#generated-code)Generated Code\n`prost` generates Rust code from source `.proto` files using the `proto2` or `proto3` syntax. `prost`\u2019s goal is to make the generated code as simple as possible.\n#### [\u00a7](https://docs.rs/prost/latest/prost/#protoc)`protoc`\nWith `prost-build` v0.11 release, `protoc` will be required to invoke `compile_protos` (unless `skip_protoc` is enabled). Prost will no longer provide bundled `protoc` or attempt to compile `protoc` for users. For install instructions for `protoc`, please check out the [protobuf install](https://github.com/protocolbuffers/protobuf#protobuf-compiler-installation) instructions.\n#### [\u00a7](https://docs.rs/prost/latest/prost/#packages)Packages\nProst can now generate code for `.proto` files that don\u2019t have a package spec. `prost` will translate the Protobuf package into a Rust module. For example, given the `package` specifier:\n```\npackage foo.bar;\n```\n\nAll Rust types generated from the file will be in the `foo::bar` module.\n#### [\u00a7](https://docs.rs/prost/latest/prost/#messages)Messages\nGiven a simple message declaration:\n```\n// Sample message.\nmessage Foo {\n}\n```\n\n`prost` will generate the following Rust struct:\n[\u24d8](https://docs.rs/prost/latest/prost/ \"This example is not tested\")```\n/// Sample message.\n#[derive(Clone, Debug, PartialEq, Message)]\npub struct Foo {\n}\n```\n\n#### [\u00a7](https://docs.rs/prost/latest/prost/#fields-1)Fields\nFields in Protobuf messages are translated into Rust as public struct fields of the corresponding type.\n##### [\u00a7](https://docs.rs/prost/latest/prost/#scalar-values)Scalar Values\nScalar value types are converted as follows:\nProtobuf Type| Rust Type  \n---|---  \n`double`| `f64`  \n`float`| `f32`  \n`int32`| `i32`  \n`int64`| `i64`  \n`uint32`| `u32`  \n`uint64`| `u64`  \n`sint32`| `i32`  \n`sint64`| `i64`  \n`fixed32`| `u32`  \n`fixed64`| `u64`  \n`sfixed32`| `i32`  \n`sfixed64`| `i64`  \n`bool`| `bool`  \n`string`| `String`  \n`bytes`| `Vec<u8>`  \n##### [\u00a7](https://docs.rs/prost/latest/prost/#enumerations)Enumerations\nAll `.proto` enumeration types convert to the Rust `i32` type. Additionally, each enumeration type gets a corresponding Rust `enum` type. For example, this `proto` enum:\n```\nenum PhoneType {\n MOBILE = 0;\n HOME = 1;\n WORK = 2;\n}\n```\n\ngets this corresponding Rust enum [1](https://docs.rs/prost/latest/prost/#fn1):\n[\u24d8](https://docs.rs/prost/latest/prost/ \"This example is not tested\")```\npub enum PhoneType {\n  Mobile = 0,\n  Home = 1,\n  Work = 2,\n}\n```\n\nYou can convert a `PhoneType` value to an `i32` by doing:\n[\u24d8](https://docs.rs/prost/latest/prost/ \"This example is not tested\")```\nPhoneType::Mobile as i32\n```\n\nThe `#[derive(::prost::Enumeration)]` annotation added to the generated `PhoneType` adds these associated functions to the type:\n[\u24d8](https://docs.rs/prost/latest/prost/ \"This example is not tested\")```\nimpl PhoneType {\n  pub fn is_valid(value: i32) -> bool { ... }\n  #[deprecated]\n  pub fn from_i32(value: i32) -> Option<PhoneType> { ... }\n}\n```\n\nIt also adds an `impl TryFrom<i32> for PhoneType`, so you can convert an `i32` to its corresponding `PhoneType` value by doing, for example:\n[\u24d8](https://docs.rs/prost/latest/prost/ \"This example is not tested\")```\nlet phone_type = 2i32;\nmatch PhoneType::try_from(phone_type) {\n  Ok(PhoneType::Mobile) => ...,\n  Ok(PhoneType::Home) => ...,\n  Ok(PhoneType::Work) => ...,\n  Err(_) => ...,\n}\n```\n\nAdditionally, wherever a `proto` enum is used as a field in a `Message`, the message will have \u2018accessor\u2019 methods to get/set the value of the field as the Rust enum type. For instance, this proto `PhoneNumber` message that has a field named `type` of type `PhoneType`:\n```\nmessage PhoneNumber {\n string number = 1;\n PhoneType type = 2;\n}\n```\n\nwill become the following Rust type [2](https://docs.rs/prost/latest/prost/#fn2) with methods `type` and `set_type`:\n[\u24d8](https://docs.rs/prost/latest/prost/ \"This example is not tested\")```\npub struct PhoneNumber {\n  pub number: String,\n  pub r#type: i32, // the `r#` is needed because `type` is a Rust keyword\n}\nimpl PhoneNumber {\n  pub fn r#type(&self) -> PhoneType { ... }\n  pub fn set_type(&mut self, value: PhoneType) { ... }\n}\n```\n\nNote that the getter methods will return the Rust enum\u2019s default value if the field has an invalid `i32` value.\nThe `enum` type isn\u2019t used directly as a field, because the Protobuf spec mandates that enumerations values are \u2018open\u2019, and decoding unrecognized enumeration values must be possible.\n##### [\u00a7](https://docs.rs/prost/latest/prost/#field-modifiers)Field Modifiers\nProtobuf scalar value and enumeration message fields can have a modifier depending on the Protobuf version. Modifiers change the corresponding type of the Rust field:\n`.proto` Version| Modifier| Rust Type  \n---|---|---  \n`proto2`| `optional`| `Option<T>`  \n`proto2`| `required`| `T`  \n`proto3`| default| `T` for scalar types, `Option<T>` otherwise  \n`proto3`| `optional`| `Option<T>`  \n`proto2`/`proto3`| `repeated`| `Vec<T>`  \nNote that in `proto3` the default representation for all user-defined message types is `Option<T>`, and for scalar types just `T` (during decoding, a missing value is populated by `T::default()`). If you need a witness of the presence of a scalar type `T`, use the `optional` modifier to enforce an `Option<T>` representation in the generated Rust struct.\n##### [\u00a7](https://docs.rs/prost/latest/prost/#map-fields)Map Fields\nMap fields are converted to a Rust `HashMap` with key and value type converted from the Protobuf key and value types.\n##### [\u00a7](https://docs.rs/prost/latest/prost/#message-fields)Message Fields\nMessage fields are converted to the corresponding struct type. The table of field modifiers above applies to message fields, except that `proto3` message fields without a modifier (the default) will be wrapped in an `Option`. Typically message fields are unboxed. `prost` will automatically box a message field if the field type and the parent type are recursively nested in order to avoid an infinite sized struct.\n##### [\u00a7](https://docs.rs/prost/latest/prost/#oneof-fields)Oneof Fields\nOneof fields convert to a Rust enum. Protobuf `oneof`s types are not named, so `prost` uses the name of the `oneof` field for the resulting Rust enum, and defines the enum in a module under the struct. For example, a `proto3` message such as:\n```\nmessage Foo {\n oneof widget {\n  int32 quux = 1;\n  string bar = 2;\n }\n}\n```\n\ngenerates the following Rust[3](https://docs.rs/prost/latest/prost/#fn3):\n[\u24d8](https://docs.rs/prost/latest/prost/ \"This example is not tested\")```\npub struct Foo {\n  pub widget: Option<foo::Widget>,\n}\npub mod foo {\n  pub enum Widget {\n    Quux(i32),\n    Bar(String),\n  }\n}\n```\n\n`oneof` fields are always wrapped in an `Option`.\n#### [\u00a7](https://docs.rs/prost/latest/prost/#services)Services\n`prost-build` allows a custom code-generator to be used for processing `service` definitions. This can be used to output Rust traits according to an application\u2019s specific needs.\n#### [\u00a7](https://docs.rs/prost/latest/prost/#generated-code-example)Generated Code Example\nExample `.proto` file:\n```\nsyntax = \"proto3\";\npackage tutorial;\nmessage Person {\n string name = 1;\n int32 id = 2; // Unique ID number for this person.\n string email = 3;\n enum PhoneType {\n  MOBILE = 0;\n  HOME = 1;\n  WORK = 2;\n }\n message PhoneNumber {\n  string number = 1;\n  PhoneType type = 2;\n }\n repeated PhoneNumber phones = 4;\n}\n// Our address book file is just one of these.\nmessage AddressBook {\n repeated Person people = 1;\n}\n```\n\nand the generated Rust code (`tutorial.rs`):\n[\u24d8](https://docs.rs/prost/latest/prost/ \"This example is not tested\")```\n#[derive(Clone, PartialEq, ::prost::Message)]\npub struct Person {\n  #[prost(string, tag=\"1\")]\n  pub name: ::prost::alloc::string::String,\n  /// Unique ID number for this person.\n  #[prost(int32, tag=\"2\")]\n  pub id: i32,\n  #[prost(string, tag=\"3\")]\n  pub email: ::prost::alloc::string::String,\n  #[prost(message, repeated, tag=\"4\")]\n  pub phones: ::prost::alloc::vec::Vec<person::PhoneNumber>,\n}\n/// Nested message and enum types in `Person`.\npub mod person {\n  #[derive(Clone, PartialEq, ::prost::Message)]\n  pub struct PhoneNumber {\n    #[prost(string, tag=\"1\")]\n    pub number: ::prost::alloc::string::String,\n    #[prost(enumeration=\"PhoneType\", tag=\"2\")]\n    pub r#type: i32,\n  }\n  #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]\n  #[repr(i32)]\n  pub enum PhoneType {\n    Mobile = 0,\n    Home = 1,\n    Work = 2,\n  }\n}\n/// Our address book file is just one of these.\n#[derive(Clone, PartialEq, ::prost::Message)]\npub struct AddressBook {\n  #[prost(message, repeated, tag=\"1\")]\n  pub people: ::prost::alloc::vec::Vec<Person>,\n}\n```\n\n### [\u00a7](https://docs.rs/prost/latest/prost/#accessing-the-protoc-filedescriptorset)Accessing the `protoc` `FileDescriptorSet`\nThe `prost_build::Config::file_descriptor_set_path` option can be used to emit a file descriptor set during the build & code generation step. When used in conjunction with the `std::include_bytes` macro and the `prost_types::FileDescriptorSet` type, applications and libraries using Prost can implement introspection capabilities requiring details from the original `.proto` files.\n### [\u00a7](https://docs.rs/prost/latest/prost/#using-prost-in-a-no_std-crate)Using `prost` in a `no_std` Crate\n`prost` is compatible with `no_std` crates. To enable `no_std` support, disable the `std` features in `prost` and `prost-types`:\n[\u24d8](https://docs.rs/prost/latest/prost/ \"This example is not tested\")```\n[dependencies]\nprost = { version = \"0.14.1\", default-features = false, features = [\"derive\"] }\nprost-types = { version = \"0.14.1\", default-features = false }\n```\n\nAdditionally, configure `prost-build` to output `BTreeMap`s instead of `HashMap`s for all Protobuf `map` fields in your `build.rs`:\n[\u24d8](https://docs.rs/prost/latest/prost/ \"This example is not tested\")```\nlet mut config = prost_build::Config::new();\nconfig.btree_map(&[\".\"]);\n```\n\nWhen using edition 2015, it may be necessary to add an `extern crate core;` directive to the crate which includes `prost`-generated code.\n### [\u00a7](https://docs.rs/prost/latest/prost/#serializing-existing-types)Serializing Existing Types\n`prost` uses a custom derive macro to handle encoding and decoding types, which means that if your existing Rust type is compatible with Protobuf types, you can serialize and deserialize it by adding the appropriate derive and field annotations.\nCurrently the best documentation on adding annotations is to look at the generated code examples above.\n#### [\u00a7](https://docs.rs/prost/latest/prost/#tag-inference-for-existing-types)Tag Inference for Existing Types\nProst automatically infers tags for the struct.\nFields are tagged sequentially in the order they are specified, starting with `1`.\nYou may skip tags which have been reserved, or where there are gaps between sequentially occurring tag values by specifying the tag number to skip to with the `tag` attribute on the first field after the gap. The following fields will be tagged sequentially starting from the next number.\n[\u24d8](https://docs.rs/prost/latest/prost/ \"This example is not tested\")```\nuse prost;\nuse prost::{Enumeration, Message};\n#[derive(Clone, PartialEq, Message)]\nstruct Person {\n  #[prost(string, tag = \"1\")]\n  pub id: String, // tag=1\n  // NOTE: Old \"name\" field has been removed\n  // pub name: String, // tag=2 (Removed)\n  #[prost(string, tag = \"6\")]\n  pub given_name: String, // tag=6\n  #[prost(string)]\n  pub family_name: String, // tag=7\n  #[prost(string)]\n  pub formatted_name: String, // tag=8\n  #[prost(uint32, tag = \"3\")]\n  pub age: u32, // tag=3\n  #[prost(uint32)]\n  pub height: u32, // tag=4\n  #[prost(enumeration = \"Gender\")]\n  pub gender: i32, // tag=5\n  // NOTE: Skip to less commonly occurring fields\n  #[prost(string, tag = \"16\")]\n  pub name_prefix: String, // tag=16 (eg. mr/mrs/ms)\n  #[prost(string)]\n  pub name_suffix: String, // tag=17 (eg. jr/esq)\n  #[prost(string)]\n  pub maiden_name: String, // tag=18\n}\n#[derive(Clone, Copy, Debug, PartialEq, Eq, Enumeration)]\npub enum Gender {\n  Unknown = 0,\n  Female = 1,\n  Male = 2,\n}\n```\n\n### [\u00a7](https://docs.rs/prost/latest/prost/#nix)Nix\nThe prost project maintains flakes support for local development. Once you have nix and nix flakes setup you can just run `nix develop` to get a shell configured with the required dependencies to compile the whole project.\n### [\u00a7](https://docs.rs/prost/latest/prost/#feature-flags)Feature Flags\n  * `std`: Enable integration with standard library. Disable this feature for `no_std` support. This feature is enabled by default.\n  * `derive`: Enable integration with `prost-derive`. Disable this feature to reduce compile times. This feature is enabled by default.\n  * `prost-derive`: Deprecated. Alias for `derive` feature.\n  * `no-recursion-limit`: Disable the recursion limit. The recursion limit is 100 and cannot be customized.\n\n\n### [\u00a7](https://docs.rs/prost/latest/prost/#faq)FAQ\n  1. **Could`prost` be implemented as a serializer for [Serde](https://serde.rs/)?**\n\n\nProbably not, however I would like to hear from a Serde expert on the matter. There are two complications with trying to serialize Protobuf messages with Serde:\n  * Protobuf fields require a numbered tag, and currently there appears to be no mechanism suitable for this in `serde`.\n  * The mapping of Protobuf type to Rust type is not 1-to-1. As a result, trait-based approaches to dispatching don\u2019t work very well. Example: six different Protobuf field types correspond to a Rust `Vec<i32>`: `repeated int32`, `repeated sint32`, `repeated sfixed32`, and their packed counterparts.\n\n\nBut it is possible to place `serde` derive tags onto the generated types, so the same structure can support both `prost` and `Serde`.\n  1. **I get errors when trying to run`cargo test` on MacOS**\n\n\nIf the errors are about missing `autoreconf` or similar, you can probably fix them by running\n[\u24d8](https://docs.rs/prost/latest/prost/ \"This example is not tested\")```\nbrew install automake\nbrew install libtool\n```\n\n### [\u00a7](https://docs.rs/prost/latest/prost/#license)License\n`prost` is distributed under the terms of the Apache License (Version 2.0).\nSee [LICENSE](https://github.com/tokio-rs/prost/blob/master/LICENSE) for details.\nCopyright 2022 Dan Burkert & Tokio Contributors\n  1. Annotations have been elided for clarity. See below for a full example. [\u21a9](https://docs.rs/prost/latest/prost/#fnref1)\n  2. Annotations have been elided for clarity. See below for a full example. [\u21a9](https://docs.rs/prost/latest/prost/#fnref2)\n  3. Annotations have been elided for clarity. See below for a full example. [\u21a9](https://docs.rs/prost/latest/prost/#fnref3)\n\n\n## Re-exports[\u00a7](https://docs.rs/prost/latest/prost/#reexports)\n\n`pub use bytes[](https://docs.rs/bytes/1.10.1/x86_64-unknown-linux-gnu/bytes/index.html \"mod bytes\");`\n\n## Structs[\u00a7](https://docs.rs/prost/latest/prost/#structs)\n\n[DecodeError](https://docs.rs/prost/latest/prost/struct.DecodeError.html \"struct prost::DecodeError\")\n    A Protobuf message decoding error.\n\n[EncodeError](https://docs.rs/prost/latest/prost/struct.EncodeError.html \"struct prost::EncodeError\")\n    A Protobuf message encoding error.\n\n[UnknownEnumValue](https://docs.rs/prost/latest/prost/struct.UnknownEnumValue.html \"struct prost::UnknownEnumValue\")\n    An error indicating that an unknown enumeration value was encountered.\n## Traits[\u00a7](https://docs.rs/prost/latest/prost/#traits)\n\n[Message](https://docs.rs/prost/latest/prost/trait.Message.html \"trait prost::Message\")\n    A Protocol Buffers message.\n\n[Name](https://docs.rs/prost/latest/prost/trait.Name.html \"trait prost::Name\")\n    Associate a type name with a [`Message`](https://docs.rs/prost/latest/prost/trait.Message.html \"trait prost::Message\") type.\n## Functions[\u00a7](https://docs.rs/prost/latest/prost/#functions)\n\n[decode_length_delimiter](https://docs.rs/prost/latest/prost/fn.decode_length_delimiter.html \"fn prost::decode_length_delimiter\")\n    Decodes a length delimiter from the buffer.\n\n[encode_length_delimiter](https://docs.rs/prost/latest/prost/fn.encode_length_delimiter.html \"fn prost::encode_length_delimiter\")\n    Encodes a length delimiter to the buffer.\n\n[length_delimiter_len](https://docs.rs/prost/latest/prost/fn.length_delimiter_len.html \"fn prost::length_delimiter_len\")\n    Returns the encoded length of a length delimiter.\n",
            "markdown_with_citations": "[](https://docs.rs/prost/latest/prost/all.html \"show sidebar\")\n# Crate prostCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\n![continuous integration\u27e84\u27e9](https://github.com/tokio-rs/prost/actions/workflows/ci.yml?query=branch%3Amaster) ![Documentation\u27e85\u27e9](https://docs.rs/prost/) ![Crate\u27e86\u27e9](https://crates.io/crates/prost) ![Dependency Status\u27e87\u27e9](https://deps.rs/repo/github/tokio-rs/prost) ![Discord\u27e88\u27e9](https://discord.gg/tokio)\n## \u00a7\u27e89\u27e9 _PROST!_\n`prost` is a Protocol Buffers\u27e810\u27e9 implementation for the Rust Language\u27e811\u27e9. `prost` generates simple, idiomatic Rust code from `proto2` and `proto3` files.\nCompared to other Protocol Buffers implementations, `prost`\n  * Generates simple, idiomatic, and readable Rust types by taking advantage of Rust `derive` attributes.\n  * Retains comments from `.proto` files in generated Rust code.\n  * Allows existing Rust types (not generated from a `.proto`) to be serialized and deserialized by adding attributes.\n  * Uses the `bytes::{Buf, BufMut}`\u27e812\u27e9 abstractions for serialization instead of `std::io::{Read, Write}`.\n  * Respects the Protobuf `package` specifier when organizing generated code into Rust modules.\n  * Preserves unknown enum values during deserialization.\n  * Does not include support for runtime reflection or message descriptors.\n\n\n### \u00a7\u27e813\u27e9Using `prost` in a Cargo Project\nFirst, add `prost` and its public dependencies to your `Cargo.toml`:\n\u24d8\u27e814\u27e9```\n[dependencies]\nprost = \"0.14\"\nprost-types = \"0.14\"\n```\n\nThe recommended way to add `.proto` compilation to a Cargo project is to use the `prost-build` library. See the `prost-build` documentation\u27e815\u27e9 for more details and examples.\nSee the snazzy repository\u27e816\u27e9 for a simple start-to-finish example.\n#### \u00a7\u27e817\u27e9MSRV\n`prost` follows the `tokio-rs` project\u2019s MSRV model and supports 1.70. For more information on the tokio msrv policy you can check it out here\u27e818\u27e9\n### \u00a7\u27e819\u27e9Generated Code\n`prost` generates Rust code from source `.proto` files using the `proto2` or `proto3` syntax. `prost`\u2019s goal is to make the generated code as simple as possible.\n#### \u00a7\u27e820\u27e9`protoc`\nWith `prost-build` v0.11 release, `protoc` will be required to invoke `compile_protos` (unless `skip_protoc` is enabled). Prost will no longer provide bundled `protoc` or attempt to compile `protoc` for users. For install instructions for `protoc`, please check out the protobuf install\u27e821\u27e9 instructions.\n#### \u00a7\u27e822\u27e9Packages\nProst can now generate code for `.proto` files that don\u2019t have a package spec. `prost` will translate the Protobuf package into a Rust module. For example, given the `package` specifier:\n```\npackage foo.bar;\n```\n\nAll Rust types generated from the file will be in the `foo::bar` module.\n#### \u00a7\u27e823\u27e9Messages\nGiven a simple message declaration:\n```\n// Sample message.\nmessage Foo {\n}\n```\n\n`prost` will generate the following Rust struct:\n\u24d8\u27e814\u27e9```\n/// Sample message.\n#[derive(Clone, Debug, PartialEq, Message)]\npub struct Foo {\n}\n```\n\n#### \u00a7\u27e824\u27e9Fields\nFields in Protobuf messages are translated into Rust as public struct fields of the corresponding type.\n##### \u00a7\u27e825\u27e9Scalar Values\nScalar value types are converted as follows:\nProtobuf Type| Rust Type  \n---|---  \n`double`| `f64`  \n`float`| `f32`  \n`int32`| `i32`  \n`int64`| `i64`  \n`uint32`| `u32`  \n`uint64`| `u64`  \n`sint32`| `i32`  \n`sint64`| `i64`  \n`fixed32`| `u32`  \n`fixed64`| `u64`  \n`sfixed32`| `i32`  \n`sfixed64`| `i64`  \n`bool`| `bool`  \n`string`| `String`  \n`bytes`| `Vec<u8>`  \n##### \u00a7\u27e826\u27e9Enumerations\nAll `.proto` enumeration types convert to the Rust `i32` type. Additionally, each enumeration type gets a corresponding Rust `enum` type. For example, this `proto` enum:\n```\nenum PhoneType {\n MOBILE = 0;\n HOME = 1;\n WORK = 2;\n}\n```\n\ngets this corresponding Rust enum 1\u27e827\u27e9:\n\u24d8\u27e814\u27e9```\npub enum PhoneType {\n  Mobile = 0,\n  Home = 1,\n  Work = 2,\n}\n```\n\nYou can convert a `PhoneType` value to an `i32` by doing:\n\u24d8\u27e814\u27e9```\nPhoneType::Mobile as i32\n```\n\nThe `#[derive(::prost::Enumeration)]` annotation added to the generated `PhoneType` adds these associated functions to the type:\n\u24d8\u27e814\u27e9```\nimpl PhoneType {\n  pub fn is_valid(value: i32) -> bool { ... }\n  #[deprecated]\n  pub fn from_i32(value: i32) -> Option<PhoneType> { ... }\n}\n```\n\nIt also adds an `impl TryFrom<i32> for PhoneType`, so you can convert an `i32` to its corresponding `PhoneType` value by doing, for example:\n\u24d8\u27e814\u27e9```\nlet phone_type = 2i32;\nmatch PhoneType::try_from(phone_type) {\n  Ok(PhoneType::Mobile) => ...,\n  Ok(PhoneType::Home) => ...,\n  Ok(PhoneType::Work) => ...,\n  Err(_) => ...,\n}\n```\n\nAdditionally, wherever a `proto` enum is used as a field in a `Message`, the message will have \u2018accessor\u2019 methods to get/set the value of the field as the Rust enum type. For instance, this proto `PhoneNumber` message that has a field named `type` of type `PhoneType`:\n```\nmessage PhoneNumber {\n string number = 1;\n PhoneType type = 2;\n}\n```\n\nwill become the following Rust type 2\u27e828\u27e9 with methods `type` and `set_type`:\n\u24d8\u27e814\u27e9```\npub struct PhoneNumber {\n  pub number: String,\n  pub r#type: i32, // the `r#` is needed because `type` is a Rust keyword\n}\nimpl PhoneNumber {\n  pub fn r#type(&self) -> PhoneType { ... }\n  pub fn set_type(&mut self, value: PhoneType) { ... }\n}\n```\n\nNote that the getter methods will return the Rust enum\u2019s default value if the field has an invalid `i32` value.\nThe `enum` type isn\u2019t used directly as a field, because the Protobuf spec mandates that enumerations values are \u2018open\u2019, and decoding unrecognized enumeration values must be possible.\n##### \u00a7\u27e829\u27e9Field Modifiers\nProtobuf scalar value and enumeration message fields can have a modifier depending on the Protobuf version. Modifiers change the corresponding type of the Rust field:\n`.proto` Version| Modifier| Rust Type  \n---|---|---  \n`proto2`| `optional`| `Option<T>`  \n`proto2`| `required`| `T`  \n`proto3`| default| `T` for scalar types, `Option<T>` otherwise  \n`proto3`| `optional`| `Option<T>`  \n`proto2`/`proto3`| `repeated`| `Vec<T>`  \nNote that in `proto3` the default representation for all user-defined message types is `Option<T>`, and for scalar types just `T` (during decoding, a missing value is populated by `T::default()`). If you need a witness of the presence of a scalar type `T`, use the `optional` modifier to enforce an `Option<T>` representation in the generated Rust struct.\n##### \u00a7\u27e830\u27e9Map Fields\nMap fields are converted to a Rust `HashMap` with key and value type converted from the Protobuf key and value types.\n##### \u00a7\u27e831\u27e9Message Fields\nMessage fields are converted to the corresponding struct type. The table of field modifiers above applies to message fields, except that `proto3` message fields without a modifier (the default) will be wrapped in an `Option`. Typically message fields are unboxed. `prost` will automatically box a message field if the field type and the parent type are recursively nested in order to avoid an infinite sized struct.\n##### \u00a7\u27e832\u27e9Oneof Fields\nOneof fields convert to a Rust enum. Protobuf `oneof`s types are not named, so `prost` uses the name of the `oneof` field for the resulting Rust enum, and defines the enum in a module under the struct. For example, a `proto3` message such as:\n```\nmessage Foo {\n oneof widget {\n  int32 quux = 1;\n  string bar = 2;\n }\n}\n```\n\ngenerates the following Rust3\u27e833\u27e9:\n\u24d8\u27e814\u27e9```\npub struct Foo {\n  pub widget: Option<foo::Widget>,\n}\npub mod foo {\n  pub enum Widget {\n    Quux(i32),\n    Bar(String),\n  }\n}\n```\n\n`oneof` fields are always wrapped in an `Option`.\n#### \u00a7\u27e834\u27e9Services\n`prost-build` allows a custom code-generator to be used for processing `service` definitions. This can be used to output Rust traits according to an application\u2019s specific needs.\n#### \u00a7\u27e835\u27e9Generated Code Example\nExample `.proto` file:\n```\nsyntax = \"proto3\";\npackage tutorial;\nmessage Person {\n string name = 1;\n int32 id = 2; // Unique ID number for this person.\n string email = 3;\n enum PhoneType {\n  MOBILE = 0;\n  HOME = 1;\n  WORK = 2;\n }\n message PhoneNumber {\n  string number = 1;\n  PhoneType type = 2;\n }\n repeated PhoneNumber phones = 4;\n}\n// Our address book file is just one of these.\nmessage AddressBook {\n repeated Person people = 1;\n}\n```\n\nand the generated Rust code (`tutorial.rs`):\n\u24d8\u27e814\u27e9```\n#[derive(Clone, PartialEq, ::prost::Message)]\npub struct Person {\n  #[prost(string, tag=\"1\")]\n  pub name: ::prost::alloc::string::String,\n  /// Unique ID number for this person.\n  #[prost(int32, tag=\"2\")]\n  pub id: i32,\n  #[prost(string, tag=\"3\")]\n  pub email: ::prost::alloc::string::String,\n  #[prost(message, repeated, tag=\"4\")]\n  pub phones: ::prost::alloc::vec::Vec<person::PhoneNumber>,\n}\n/// Nested message and enum types in `Person`.\npub mod person {\n  #[derive(Clone, PartialEq, ::prost::Message)]\n  pub struct PhoneNumber {\n    #[prost(string, tag=\"1\")]\n    pub number: ::prost::alloc::string::String,\n    #[prost(enumeration=\"PhoneType\", tag=\"2\")]\n    pub r#type: i32,\n  }\n  #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]\n  #[repr(i32)]\n  pub enum PhoneType {\n    Mobile = 0,\n    Home = 1,\n    Work = 2,\n  }\n}\n/// Our address book file is just one of these.\n#[derive(Clone, PartialEq, ::prost::Message)]\npub struct AddressBook {\n  #[prost(message, repeated, tag=\"1\")]\n  pub people: ::prost::alloc::vec::Vec<Person>,\n}\n```\n\n### \u00a7\u27e836\u27e9Accessing the `protoc` `FileDescriptorSet`\nThe `prost_build::Config::file_descriptor_set_path` option can be used to emit a file descriptor set during the build & code generation step. When used in conjunction with the `std::include_bytes` macro and the `prost_types::FileDescriptorSet` type, applications and libraries using Prost can implement introspection capabilities requiring details from the original `.proto` files.\n### \u00a7\u27e837\u27e9Using `prost` in a `no_std` Crate\n`prost` is compatible with `no_std` crates. To enable `no_std` support, disable the `std` features in `prost` and `prost-types`:\n\u24d8\u27e814\u27e9```\n[dependencies]\nprost = { version = \"0.14.1\", default-features = false, features = [\"derive\"] }\nprost-types = { version = \"0.14.1\", default-features = false }\n```\n\nAdditionally, configure `prost-build` to output `BTreeMap`s instead of `HashMap`s for all Protobuf `map` fields in your `build.rs`:\n\u24d8\u27e814\u27e9```\nlet mut config = prost_build::Config::new();\nconfig.btree_map(&[\".\"]);\n```\n\nWhen using edition 2015, it may be necessary to add an `extern crate core;` directive to the crate which includes `prost`-generated code.\n### \u00a7\u27e838\u27e9Serializing Existing Types\n`prost` uses a custom derive macro to handle encoding and decoding types, which means that if your existing Rust type is compatible with Protobuf types, you can serialize and deserialize it by adding the appropriate derive and field annotations.\nCurrently the best documentation on adding annotations is to look at the generated code examples above.\n#### \u00a7\u27e839\u27e9Tag Inference for Existing Types\nProst automatically infers tags for the struct.\nFields are tagged sequentially in the order they are specified, starting with `1`.\nYou may skip tags which have been reserved, or where there are gaps between sequentially occurring tag values by specifying the tag number to skip to with the `tag` attribute on the first field after the gap. The following fields will be tagged sequentially starting from the next number.\n\u24d8\u27e814\u27e9```\nuse prost;\nuse prost::{Enumeration, Message};\n#[derive(Clone, PartialEq, Message)]\nstruct Person {\n  #[prost(string, tag = \"1\")]\n  pub id: String, // tag=1\n  // NOTE: Old \"name\" field has been removed\n  // pub name: String, // tag=2 (Removed)\n  #[prost(string, tag = \"6\")]\n  pub given_name: String, // tag=6\n  #[prost(string)]\n  pub family_name: String, // tag=7\n  #[prost(string)]\n  pub formatted_name: String, // tag=8\n  #[prost(uint32, tag = \"3\")]\n  pub age: u32, // tag=3\n  #[prost(uint32)]\n  pub height: u32, // tag=4\n  #[prost(enumeration = \"Gender\")]\n  pub gender: i32, // tag=5\n  // NOTE: Skip to less commonly occurring fields\n  #[prost(string, tag = \"16\")]\n  pub name_prefix: String, // tag=16 (eg. mr/mrs/ms)\n  #[prost(string)]\n  pub name_suffix: String, // tag=17 (eg. jr/esq)\n  #[prost(string)]\n  pub maiden_name: String, // tag=18\n}\n#[derive(Clone, Copy, Debug, PartialEq, Eq, Enumeration)]\npub enum Gender {\n  Unknown = 0,\n  Female = 1,\n  Male = 2,\n}\n```\n\n### \u00a7\u27e840\u27e9Nix\nThe prost project maintains flakes support for local development. Once you have nix and nix flakes setup you can just run `nix develop` to get a shell configured with the required dependencies to compile the whole project.\n### \u00a7\u27e841\u27e9Feature Flags\n  * `std`: Enable integration with standard library. Disable this feature for `no_std` support. This feature is enabled by default.\n  * `derive`: Enable integration with `prost-derive`. Disable this feature to reduce compile times. This feature is enabled by default.\n  * `prost-derive`: Deprecated. Alias for `derive` feature.\n  * `no-recursion-limit`: Disable the recursion limit. The recursion limit is 100 and cannot be customized.\n\n\n### \u00a7\u27e842\u27e9FAQ\n  1. **Could`prost` be implemented as a serializer for Serde\u27e843\u27e9?**\n\n\nProbably not, however I would like to hear from a Serde expert on the matter. There are two complications with trying to serialize Protobuf messages with Serde:\n  * Protobuf fields require a numbered tag, and currently there appears to be no mechanism suitable for this in `serde`.\n  * The mapping of Protobuf type to Rust type is not 1-to-1. As a result, trait-based approaches to dispatching don\u2019t work very well. Example: six different Protobuf field types correspond to a Rust `Vec<i32>`: `repeated int32`, `repeated sint32`, `repeated sfixed32`, and their packed counterparts.\n\n\nBut it is possible to place `serde` derive tags onto the generated types, so the same structure can support both `prost` and `Serde`.\n  1. **I get errors when trying to run`cargo test` on MacOS**\n\n\nIf the errors are about missing `autoreconf` or similar, you can probably fix them by running\n\u24d8\u27e814\u27e9```\nbrew install automake\nbrew install libtool\n```\n\n### \u00a7\u27e844\u27e9License\n`prost` is distributed under the terms of the Apache License (Version 2.0).\nSee LICENSE\u27e845\u27e9 for details.\nCopyright 2022 Dan Burkert & Tokio Contributors\n  1. Annotations have been elided for clarity. See below for a full example. \u21a9\u27e846\u27e9\n  2. Annotations have been elided for clarity. See below for a full example. \u21a9\u27e847\u27e9\n  3. Annotations have been elided for clarity. See below for a full example. \u21a9\u27e848\u27e9\n\n\n## Re-exports\u00a7\u27e849\u27e9\n\n`pub use bytes[](https://docs.rs/bytes/1.10.1/x86_64-unknown-linux-gnu/bytes/index.html \"mod bytes\");`\n\n## Structs\u00a7\u27e850\u27e9\n\nDecodeError\u27e851\u27e9\n    A Protobuf message decoding error.\n\nEncodeError\u27e852\u27e9\n    A Protobuf message encoding error.\n\nUnknownEnumValue\u27e853\u27e9\n    An error indicating that an unknown enumeration value was encountered.\n## Traits\u00a7\u27e854\u27e9\n\nMessage\u27e855\u27e9\n    A Protocol Buffers message.\n\nName\u27e856\u27e9\n    Associate a type name with a `Message`\u27e855\u27e9 type.\n## Functions\u00a7\u27e857\u27e9\n\ndecode_length_delimiter\u27e858\u27e9\n    Decodes a length delimiter from the buffer.\n\nencode_length_delimiter\u27e859\u27e9\n    Encodes a length delimiter to the buffer.\n\nlength_delimiter_len\u27e860\u27e9\n    Returns the encoded length of a length delimiter.\n",
            "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/prost/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/prost/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/prost/latest/src/prost/lib.rs.html#1-42: Source\n\u27e84\u27e9 https://github.com/tokio-rs/prost/actions/workflows/ci.yml/badge.svg?branch=master: ![continuous integration\n\u27e85\u27e9 https://docs.rs/prost/badge.svg: ![Documentation\n\u27e86\u27e9 https://img.shields.io/crates/v/prost.svg: ![Crate\n\u27e87\u27e9 https://deps.rs/repo/github/tokio-rs/prost/status.svg: ![Dependency Status\n\u27e88\u27e9 https://img.shields.io/discord/500028886025895936: ![Discord\n\u27e89\u27e9 https://docs.rs/prost/latest/prost/#prost: \u00a7\n\u27e810\u27e9 https://developers.google.com/protocol-buffers/: Protocol Buffers\n\u27e811\u27e9 https://www.rust-lang.org/: Rust Language\n\u27e812\u27e9 https://github.com/carllerche/bytes: `bytes::{Buf, BufMut}`\n\u27e813\u27e9 https://docs.rs/prost/latest/prost/#using-prost-in-a-cargo-project: \u00a7\n\u27e814\u27e9 https://docs.rs/prost/latest/prost/: This example is not tested - \u24d8\n\u27e815\u27e9 https://docs.rs/prost-build/latest/prost_build/: `prost-build` documentation\n\u27e816\u27e9 https://github.com/danburkert/snazzy: snazzy repository\n\u27e817\u27e9 https://docs.rs/prost/latest/prost/#msrv: \u00a7\n\u27e818\u27e9 https://github.com/tokio-rs/tokio/#supported-rust-versions: here\n\u27e819\u27e9 https://docs.rs/prost/latest/prost/#generated-code: \u00a7\n\u27e820\u27e9 https://docs.rs/prost/latest/prost/#protoc: \u00a7\n\u27e821\u27e9 https://github.com/protocolbuffers/protobuf#protobuf-compiler-installation: protobuf install\n\u27e822\u27e9 https://docs.rs/prost/latest/prost/#packages: \u00a7\n\u27e823\u27e9 https://docs.rs/prost/latest/prost/#messages: \u00a7\n\u27e824\u27e9 https://docs.rs/prost/latest/prost/#fields-1: \u00a7\n\u27e825\u27e9 https://docs.rs/prost/latest/prost/#scalar-values: \u00a7\n\u27e826\u27e9 https://docs.rs/prost/latest/prost/#enumerations: \u00a7\n\u27e827\u27e9 https://docs.rs/prost/latest/prost/#fn1: 1\n\u27e828\u27e9 https://docs.rs/prost/latest/prost/#fn2: 2\n\u27e829\u27e9 https://docs.rs/prost/latest/prost/#field-modifiers: \u00a7\n\u27e830\u27e9 https://docs.rs/prost/latest/prost/#map-fields: \u00a7\n\u27e831\u27e9 https://docs.rs/prost/latest/prost/#message-fields: \u00a7\n\u27e832\u27e9 https://docs.rs/prost/latest/prost/#oneof-fields: \u00a7\n\u27e833\u27e9 https://docs.rs/prost/latest/prost/#fn3: 3\n\u27e834\u27e9 https://docs.rs/prost/latest/prost/#services: \u00a7\n\u27e835\u27e9 https://docs.rs/prost/latest/prost/#generated-code-example: \u00a7\n\u27e836\u27e9 https://docs.rs/prost/latest/prost/#accessing-the-protoc-filedescriptorset: \u00a7\n\u27e837\u27e9 https://docs.rs/prost/latest/prost/#using-prost-in-a-no_std-crate: \u00a7\n\u27e838\u27e9 https://docs.rs/prost/latest/prost/#serializing-existing-types: \u00a7\n\u27e839\u27e9 https://docs.rs/prost/latest/prost/#tag-inference-for-existing-types: \u00a7\n\u27e840\u27e9 https://docs.rs/prost/latest/prost/#nix: \u00a7\n\u27e841\u27e9 https://docs.rs/prost/latest/prost/#feature-flags: \u00a7\n\u27e842\u27e9 https://docs.rs/prost/latest/prost/#faq: \u00a7\n\u27e843\u27e9 https://serde.rs/: Serde\n\u27e844\u27e9 https://docs.rs/prost/latest/prost/#license: \u00a7\n\u27e845\u27e9 https://github.com/tokio-rs/prost/blob/master/LICENSE: LICENSE\n\u27e846\u27e9 https://docs.rs/prost/latest/prost/#fnref1: \u21a9\n\u27e847\u27e9 https://docs.rs/prost/latest/prost/#fnref2: \u21a9\n\u27e848\u27e9 https://docs.rs/prost/latest/prost/#fnref3: \u21a9\n\u27e849\u27e9 https://docs.rs/prost/latest/prost/#reexports: \u00a7\n\u27e850\u27e9 https://docs.rs/prost/latest/prost/#structs: \u00a7\n\u27e851\u27e9 https://docs.rs/prost/latest/prost/struct.DecodeError.html: struct prost::DecodeError - DecodeError\n\u27e852\u27e9 https://docs.rs/prost/latest/prost/struct.EncodeError.html: struct prost::EncodeError - EncodeError\n\u27e853\u27e9 https://docs.rs/prost/latest/prost/struct.UnknownEnumValue.html: struct prost::UnknownEnumValue - UnknownEnumValue\n\u27e854\u27e9 https://docs.rs/prost/latest/prost/#traits: \u00a7\n\u27e855\u27e9 https://docs.rs/prost/latest/prost/trait.Message.html: trait prost::Message - Message\n\u27e856\u27e9 https://docs.rs/prost/latest/prost/trait.Name.html: trait prost::Name - Name\n\u27e857\u27e9 https://docs.rs/prost/latest/prost/#functions: \u00a7\n\u27e858\u27e9 https://docs.rs/prost/latest/prost/fn.decode_length_delimiter.html: fn prost::decode_length_delimiter - decode_length_delimiter\n\u27e859\u27e9 https://docs.rs/prost/latest/prost/fn.encode_length_delimiter.html: fn prost::encode_length_delimiter - encode_length_delimiter\n\u27e860\u27e9 https://docs.rs/prost/latest/prost/fn.length_delimiter_len.html: fn prost::length_delimiter_len - length_delimiter_len\n",
            "fit_markdown": "",
            "fit_html": ""
          },
          "downloads": 0,
          "github_stars": 0,
          "dependencies": [],
          "features": {},
          "code_snippets": [],
          "readme_sections": {},
          "librs_downloads": null,
          "source": "crates.io",
          "enhanced_scraping": {},
          "enhanced_features": [],
          "enhanced_dependencies": [],
          "readme_summary": "The `prost` crate is a Protocol Buffers implementation for Rust that generates simple, idiomatic Rust code from `.proto` files using `proto2` or `proto3` syntax. It supports serialization/deserialization, retains comments from `.proto` files, organizes code into Rust modules based on Protobuf packages, and preserves unknown enum values during deserialization. Key features include integration with `prost-build` for `.proto` compilation, compatibility with `no_std`, and efficient serialization using `bytes::{Buf, BufMut}` abstractions.",
          "feature_summary": null,
          "use_case": "Serialization",
          "score": 8.5,
          "factual_counterfactual": "### Pair 1: Code Generation  \n\u2705 Factual: `prost` generates idiomatic Rust code from `.proto` files, leveraging Rust's `derive` attributes for traits like `Clone`, `PartialEq`, and `Debug`.  \n\u274c Counterfactual: `prost` requires manual implementation of traits like `Clone` and `PartialEq` for the generated Rust structs.  \n\n---\n\n### Pair 2: Serialization  \n\u2705 Factual: `prost` uses the `bytes::{Buf, BufMut}` abstractions for serialization, which are more efficient than relying on `std::io::{Read, Write}`.  \n\u274c Counterfactual: `prost` exclusively relies on `std::io::{Read, Write}` for serialization, making it less performant compared to other Protocol Buffers implementations.  \n\n---\n\n### Pair 3: Enum Handling  \n\u2705 Factual: `prost` preserves unknown enum values during deserialization, ensuring compatibility with future updates to `.proto` definitions.  \n\u274c Counterfactual: `prost` discards unknown enum values during deserialization, potentially causing compatibility issues with newer `.proto` definitions.",
          "source_analysis": null,
          "user_behavior": null,
          "security": null
        }
      },
      "irl_score": 8.6,
      "execution_id": "exec-feb3c8df-833250d4-1751263172",
      "timestamp": "2025-06-30T05:59:32.500297+00:00",
      "canon_version": "1.3.0"
    },
    "rule_zero_compliant": true
  }
]