[
  {
    "execution_id": "exec-ff91df62-f624de90-1751262861",
    "timestamp": "2025-06-30T05:54:21.054941+00:00",
    "sacred_chain": {
      "input_data": "crossbeam-channel",
      "context_sources": [
        "crates.io",
        "github.com",
        "lib.rs",
        "docs.rs"
      ],
      "reasoning_steps": [
        "Input canonicalized: 'crossbeam-channel' -> 'crossbeam-channel'",
        "Context gathered from 4 validated sources",
        "Metadata extracted: 4 fields",
        "Documentation analyzed: quality 7.0",
        "Sentiment analyzed: positive",
        "Ecosystem analyzed: utilities",
        "Quality score synthesized: 7.50",
        "Trust decision: DEFER - Insufficient data for decision",
        "IRL confidence: 8.600"
      ],
      "suggestion": "ALLOW: Positive community sentiment",
      "verdict": "DEFER",
      "audit_info": {
        "metadata": {
          "name": "crossbeam-channel",
          "type": "rust_crate",
          "source": "manual_input",
          "extraction_method": "irl_engine"
        },
        "sentiment": {
          "quality_score": 7.0,
          "completeness": 0.8,
          "examples_present": true,
          "api_documented": true
        },
        "ecosystem": {
          "overall": "positive",
          "positive_mentions": 10,
          "negative_mentions": 2,
          "neutral_mentions": 5,
          "total_mentions": 17
        },
        "quality_score": 7.5,
        "verdict_reason": "Insufficient data for decision",
        "sanitized_documentation": {
          "crates_io": {
            "url": "https://crates.io/crates/crossbeam-channel",
            "title": "crossbeam-channel v0.5.15",
            "content": {
              "raw_markdown": "#  crossbeam-channel v0.5.15\nMulti-producer multi-consumer channels for message passing \n  * [ #channel ](https://crates.io/keywords/channel)\n  * [ #golang ](https://crates.io/keywords/golang)\n  * [ #message ](https://crates.io/keywords/message)\n  * [ #mpmc ](https://crates.io/keywords/mpmc)\n  * [ #select ](https://crates.io/keywords/select)\n\n\n  * [ Readme ](https://crates.io/crates/crossbeam-channel)\n  * [ 42 Versions ](https://crates.io/crates/crossbeam-channel/versions)\n  * [ Dependencies ](https://crates.io/crates/crossbeam-channel/dependencies)\n  * [ Dependents ](https://crates.io/crates/crossbeam-channel/reverse_dependencies)\n\n\n## Metadata\n3 months ago \nv1.60.0 \n[ MIT ](https://choosealicense.com/licenses/mit) OR [ Apache-2.0 ](https://choosealicense.com/licenses/apache-2.0)\n90.5 KiB \n## Install\nRun the following Cargo command in your project directory:\ncargo add crossbeam-channel\nOr add the following line to your Cargo.toml:\ncrossbeam-channel = \"0.5.15\"\n## Homepage\n[ github.com/crossbeam-rs/crossbeam/tree/master/crossbeam-channel ](https://github.com/crossbeam-rs/crossbeam/tree/master/crossbeam-channel)\n## Repository\n[ github.com/crossbeam-rs/crossbeam ](https://github.com/crossbeam-rs/crossbeam)\n## Owners\n## Categories\n  * [Algorithms](https://crates.io/categories/algorithms)\n  * [Concurrency](https://crates.io/categories/concurrency)\n  * [Data structures](https://crates.io/categories/data-structures)\n\n\n[ Report crate ](https://crates.io/support?crate=crossbeam-channel&inquire=crate-violation)\n### Stats Overview\n246,214,448 Downloads all time\n42 Versions published\n#### Downloads over the last 90 days\nDisplay as \nStacked \n  * Stacked \n  * Unstacked \n\n\nLoading\u2026\n",
              "markdown_with_citations": "#  crossbeam-channel v0.5.15\nMulti-producer multi-consumer channels for message passing \n  *  #channel \u27e81\u27e9\n  *  #golang \u27e82\u27e9\n  *  #message \u27e83\u27e9\n  *  #mpmc \u27e84\u27e9\n  *  #select \u27e85\u27e9\n\n\n  *  Readme \u27e86\u27e9\n  *  42 Versions \u27e87\u27e9\n  *  Dependencies \u27e88\u27e9\n  *  Dependents \u27e89\u27e9\n\n\n## Metadata\n3 months ago \nv1.60.0 \n MIT \u27e810\u27e9 OR  Apache-2.0 \u27e811\u27e9\n90.5 KiB \n## Install\nRun the following Cargo command in your project directory:\ncargo add crossbeam-channel\nOr add the following line to your Cargo.toml:\ncrossbeam-channel = \"0.5.15\"\n## Homepage\n github.com/crossbeam-rs/crossbeam/tree/master/crossbeam-channel \u27e812\u27e9\n## Repository\n github.com/crossbeam-rs/crossbeam \u27e813\u27e9\n## Owners\n## Categories\n  * Algorithms\u27e814\u27e9\n  * Concurrency\u27e815\u27e9\n  * Data structures\u27e816\u27e9\n\n\n Report crate \u27e817\u27e9\n### Stats Overview\n246,214,448 Downloads all time\n42 Versions published\n#### Downloads over the last 90 days\nDisplay as \nStacked \n  * Stacked \n  * Unstacked \n\n\nLoading\u2026\n",
              "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://crates.io/keywords/channel:  #channel \n\u27e82\u27e9 https://crates.io/keywords/golang:  #golang \n\u27e83\u27e9 https://crates.io/keywords/message:  #message \n\u27e84\u27e9 https://crates.io/keywords/mpmc:  #mpmc \n\u27e85\u27e9 https://crates.io/keywords/select:  #select \n\u27e86\u27e9 https://crates.io/crates/crossbeam-channel:  Readme \n\u27e87\u27e9 https://crates.io/crates/crossbeam-channel/versions:  42 Versions \n\u27e88\u27e9 https://crates.io/crates/crossbeam-channel/dependencies:  Dependencies \n\u27e89\u27e9 https://crates.io/crates/crossbeam-channel/reverse_dependencies:  Dependents \n\u27e810\u27e9 https://choosealicense.com/licenses/mit:  MIT \n\u27e811\u27e9 https://choosealicense.com/licenses/apache-2.0:  Apache-2.0 \n\u27e812\u27e9 https://github.com/crossbeam-rs/crossbeam/tree/master/crossbeam-channel:  github.com/crossbeam-rs/crossbeam/tree/master/crossbeam-channel \n\u27e813\u27e9 https://github.com/crossbeam-rs/crossbeam:  github.com/crossbeam-rs/crossbeam \n\u27e814\u27e9 https://crates.io/categories/algorithms: Algorithms\n\u27e815\u27e9 https://crates.io/categories/concurrency: Concurrency\n\u27e816\u27e9 https://crates.io/categories/data-structures: Data structures\n\u27e817\u27e9 https://crates.io/support?crate=crossbeam-channel&inquire=crate-violation:  Report crate \n",
              "fit_markdown": "",
              "fit_html": ""
            },
            "structured_data": {},
            "quality_score": 3.0,
            "extraction_method": "crawl4ai",
            "error": null,
            "metadata": {
              "doc_type": "docs",
              "content_length": 1696,
              "has_structured_data": false,
              "crawl_success": true
            },
            "timestamp": "116651.0585882"
          },
          "docs_rs": {
            "url": "https://docs.rs/crossbeam-channel",
            "title": "Crate crossbeam_channelCopy item path",
            "content": {
              "raw_markdown": "[](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/all.html \"show sidebar\")\n# Crate crossbeam_channelCopy item path\n[Settings](https://docs.rs/crossbeam-channel/latest/settings.html)\n[Help](https://docs.rs/crossbeam-channel/latest/help.html)\nSummary[Source](https://docs.rs/crossbeam-channel/latest/src/crossbeam_channel/lib.rs.html#1-378)\nExpand description\nMulti-producer multi-consumer channels for message passing.\nThis crate is an alternative to [`std::sync::mpsc`](https://doc.rust-lang.org/nightly/std/sync/mpsc/index.html \"mod std::sync::mpsc\") with more features and better performance.\n## [\u00a7](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#hello-world)Hello, world!\n```\nuse crossbeam_channel::unbounded;\n// Create a channel of unbounded capacity.\nlet (s, r) = unbounded();\n// Send a message into the channel.\ns.send(\"Hello, world!\").unwrap();\n// Receive the message from the channel.\nassert_eq!(r.recv(), Ok(\"Hello, world!\"));\n```\n\n## [\u00a7](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#channel-types)Channel types\nChannels can be created using two functions:\n  * [`bounded`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/fn.bounded.html \"fn crossbeam_channel::bounded\") creates a channel of bounded capacity, i.e. there is a limit to how many messages it can hold at a time.\n  * [`unbounded`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/fn.unbounded.html \"fn crossbeam_channel::unbounded\") creates a channel of unbounded capacity, i.e. it can hold any number of messages at a time.\n\n\nBoth functions return a [`Sender`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Sender.html \"struct crossbeam_channel::Sender\") and a [`Receiver`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Receiver.html \"struct crossbeam_channel::Receiver\"), which represent the two opposite sides of a channel.\nCreating a bounded channel:\n```\nuse crossbeam_channel::bounded;\n// Create a channel that can hold at most 5 messages at a time.\nlet (s, r) = bounded(5);\n// Can send only 5 messages without blocking.\nfor i in 0..5 {\n  s.send(i).unwrap();\n}\n// Another call to `send` would block because the channel is full.\n// s.send(5).unwrap();\n```\n\nCreating an unbounded channel:\n```\nuse crossbeam_channel::unbounded;\n// Create an unbounded channel.\nlet (s, r) = unbounded();\n// Can send any number of messages into the channel without blocking.\nfor i in 0..1000 {\n  s.send(i).unwrap();\n}\n```\n\nA special case is zero-capacity channel, which cannot hold any messages. Instead, send and receive operations must appear at the same time in order to pair up and pass the message over:\n```\nuse std::thread;\nuse crossbeam_channel::bounded;\n// Create a zero-capacity channel.\nlet (s, r) = bounded(0);\n// Sending blocks until a receive operation appears on the other side.\nthread::spawn(move || s.send(\"Hi!\").unwrap());\n// Receiving blocks until a send operation appears on the other side.\nassert_eq!(r.recv(), Ok(\"Hi!\"));\n```\n\n## [\u00a7](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#sharing-channels)Sharing channels\nSenders and receivers can be cloned and sent to other threads:\n```\nuse std::thread;\nuse crossbeam_channel::bounded;\nlet (s1, r1) = bounded(0);\nlet (s2, r2) = (s1.clone(), r1.clone());\n// Spawn a thread that receives a message and then sends one.\nthread::spawn(move || {\n  r2.recv().unwrap();\n  s2.send(2).unwrap();\n});\n// Send a message and then receive one.\ns1.send(1).unwrap();\nr1.recv().unwrap();\n```\n\nNote that cloning only creates a new handle to the same sending or receiving side. It does not create a separate stream of messages in any way:\n```\nuse crossbeam_channel::unbounded;\nlet (s1, r1) = unbounded();\nlet (s2, r2) = (s1.clone(), r1.clone());\nlet (s3, r3) = (s2.clone(), r2.clone());\ns1.send(10).unwrap();\ns2.send(20).unwrap();\ns3.send(30).unwrap();\nassert_eq!(r3.recv(), Ok(10));\nassert_eq!(r1.recv(), Ok(20));\nassert_eq!(r2.recv(), Ok(30));\n```\n\nIt\u2019s also possible to share senders and receivers by reference:\n```\nuse crossbeam_channel::bounded;\nuse crossbeam_utils::thread::scope;\nlet (s, r) = bounded(0);\nscope(|scope| {\n  // Spawn a thread that receives a message and then sends one.\n  scope.spawn(|_| {\n    r.recv().unwrap();\n    s.send(2).unwrap();\n  });\n  // Send a message and then receive one.\n  s.send(1).unwrap();\n  r.recv().unwrap();\n}).unwrap();\n```\n\n## [\u00a7](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#disconnection)Disconnection\nWhen all senders or all receivers associated with a channel get dropped, the channel becomes disconnected. No more messages can be sent, but any remaining messages can still be received. Send and receive operations on a disconnected channel never block.\n```\nuse crossbeam_channel::{unbounded, RecvError};\nlet (s, r) = unbounded();\ns.send(1).unwrap();\ns.send(2).unwrap();\ns.send(3).unwrap();\n// The only sender is dropped, disconnecting the channel.\ndrop(s);\n// The remaining messages can be received.\nassert_eq!(r.recv(), Ok(1));\nassert_eq!(r.recv(), Ok(2));\nassert_eq!(r.recv(), Ok(3));\n// There are no more messages in the channel.\nassert!(r.is_empty());\n// Note that calling `r.recv()` does not block.\n// Instead, `Err(RecvError)` is returned immediately.\nassert_eq!(r.recv(), Err(RecvError));\n```\n\n## [\u00a7](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#blocking-operations)Blocking operations\nSend and receive operations come in three flavors:\n  * Non-blocking (returns immediately with success or failure).\n  * Blocking (waits until the operation succeeds or the channel becomes disconnected).\n  * Blocking with a timeout (blocks only for a certain duration of time).\n\n\nA simple example showing the difference between non-blocking and blocking operations:\n```\nuse crossbeam_channel::{bounded, RecvError, TryRecvError};\nlet (s, r) = bounded(1);\n// Send a message into the channel.\ns.send(\"foo\").unwrap();\n// This call would block because the channel is full.\n// s.send(\"bar\").unwrap();\n// Receive the message.\nassert_eq!(r.recv(), Ok(\"foo\"));\n// This call would block because the channel is empty.\n// r.recv();\n// Try receiving a message without blocking.\nassert_eq!(r.try_recv(), Err(TryRecvError::Empty));\n// Disconnect the channel.\ndrop(s);\n// This call doesn't block because the channel is now disconnected.\nassert_eq!(r.recv(), Err(RecvError));\n```\n\n## [\u00a7](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#iteration)Iteration\nReceivers can be used as iterators. For example, method [`iter`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Receiver.html#method.iter \"method crossbeam_channel::Receiver::iter\") creates an iterator that receives messages until the channel becomes empty and disconnected. Note that iteration may block waiting for next message to arrive.\n```\nuse std::thread;\nuse crossbeam_channel::unbounded;\nlet (s, r) = unbounded();\nthread::spawn(move || {\n  s.send(1).unwrap();\n  s.send(2).unwrap();\n  s.send(3).unwrap();\n  drop(s); // Disconnect the channel.\n});\n// Collect all messages from the channel.\n// Note that the call to `collect` blocks until the sender is dropped.\nlet v: Vec<_> = r.iter().collect();\nassert_eq!(v, [1, 2, 3]);\n```\n\nA non-blocking iterator can be created using [`try_iter`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Receiver.html#method.try_iter \"method crossbeam_channel::Receiver::try_iter\"), which receives all available messages without blocking:\n```\nuse crossbeam_channel::unbounded;\nlet (s, r) = unbounded();\ns.send(1).unwrap();\ns.send(2).unwrap();\ns.send(3).unwrap();\n// No need to drop the sender.\n// Receive all messages currently in the channel.\nlet v: Vec<_> = r.try_iter().collect();\nassert_eq!(v, [1, 2, 3]);\n```\n\n## [\u00a7](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#selection)Selection\nThe [`select!`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/macro.select.html \"macro crossbeam_channel::select\") macro allows you to define a set of channel operations, wait until any one of them becomes ready, and finally execute it. If multiple operations are ready at the same time, a random one among them is selected.\nIt is also possible to define a `default` case that gets executed if none of the operations are ready, either right away or for a certain duration of time.\nAn operation is considered to be ready if it doesn\u2019t have to block. Note that it is ready even when it will simply return an error because the channel is disconnected.\nAn example of receiving a message from two channels:\n```\nuse std::thread;\nuse std::time::Duration;\nuse crossbeam_channel::{select, unbounded};\nlet (s1, r1) = unbounded();\nlet (s2, r2) = unbounded();\nthread::spawn(move || s1.send(10).unwrap());\nthread::spawn(move || s2.send(20).unwrap());\n// At most one of these two receive operations will be executed.\nselect! {\n  recv(r1) -> msg => assert_eq!(msg, Ok(10)),\n  recv(r2) -> msg => assert_eq!(msg, Ok(20)),\n  default(Duration::from_secs(1)) => println!(\"timed out\"),\n}\n```\n\nIf you need to select over a dynamically created list of channel operations, use [`Select`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Select.html \"struct crossbeam_channel::Select\") instead. The [`select!`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/macro.select.html \"macro crossbeam_channel::select\") macro is just a convenience wrapper around [`Select`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Select.html \"struct crossbeam_channel::Select\").\n## [\u00a7](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#extra-channels)Extra channels\nThree functions can create special kinds of channels, all of which return just a [`Receiver`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Receiver.html \"struct crossbeam_channel::Receiver\") handle:\n  * [`after`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/fn.after.html \"fn crossbeam_channel::after\") creates a channel that delivers a single message after a certain duration of time.\n  * [`tick`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/fn.tick.html \"fn crossbeam_channel::tick\") creates a channel that delivers messages periodically.\n  * [`never`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/fn.never.html \"fn crossbeam_channel::never\") creates a channel that never delivers messages.\n\n\nThese channels are very efficient because messages get lazily generated on receive operations.\nAn example that prints elapsed time every 50 milliseconds for the duration of 1 second:\n```\nuse std::time::{Duration, Instant};\nuse crossbeam_channel::{after, select, tick};\nlet start = Instant::now();\nlet ticker = tick(Duration::from_millis(50));\nlet timeout = after(Duration::from_secs(1));\nloop {\n  select! {\n    recv(ticker) -> _ => println!(\"elapsed: {:?}\", start.elapsed()),\n    recv(timeout) -> _ => break,\n  }\n}\n```\n\n## Macros[\u00a7](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#macros)\n\n[select](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/macro.select.html \"macro crossbeam_channel::select\")\n    Selects from a set of channel operations.\n\n[select_biased](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/macro.select_biased.html \"macro crossbeam_channel::select_biased\")\n    Selects from a set of channel operations.\n## Structs[\u00a7](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#structs)\n\n[IntoIter](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.IntoIter.html \"struct crossbeam_channel::IntoIter\")\n    A blocking iterator over messages in a channel.\n\n[Iter](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Iter.html \"struct crossbeam_channel::Iter\")\n    A blocking iterator over messages in a channel.\n\n[ReadyTimeoutError](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.ReadyTimeoutError.html \"struct crossbeam_channel::ReadyTimeoutError\")\n    An error returned from the [`ready_timeout`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Select.html#method.ready_timeout \"method crossbeam_channel::Select::ready_timeout\") method.\n\n[Receiver](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Receiver.html \"struct crossbeam_channel::Receiver\")\n    The receiving side of a channel.\n\n[RecvError](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.RecvError.html \"struct crossbeam_channel::RecvError\")\n    An error returned from the [`recv`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Receiver.html#method.recv \"method crossbeam_channel::Receiver::recv\") method.\n\n[Select](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Select.html \"struct crossbeam_channel::Select\")\n    Selects from a set of channel operations.\n\n[SelectTimeoutError](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.SelectTimeoutError.html \"struct crossbeam_channel::SelectTimeoutError\")\n    An error returned from the [`select_timeout`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Select.html#method.select_timeout \"method crossbeam_channel::Select::select_timeout\") method.\n\n[SelectedOperation](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.SelectedOperation.html \"struct crossbeam_channel::SelectedOperation\")\n    A selected operation that needs to be completed.\n\n[SendError](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.SendError.html \"struct crossbeam_channel::SendError\")\n    An error returned from the [`send`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Sender.html#method.send \"method crossbeam_channel::Sender::send\") method.\n\n[Sender](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Sender.html \"struct crossbeam_channel::Sender\")\n    The sending side of a channel.\n\n[TryIter](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.TryIter.html \"struct crossbeam_channel::TryIter\")\n    A non-blocking iterator over messages in a channel.\n\n[TryReadyError](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.TryReadyError.html \"struct crossbeam_channel::TryReadyError\")\n    An error returned from the [`try_ready`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Select.html#method.try_ready \"method crossbeam_channel::Select::try_ready\") method.\n\n[TrySelectError](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.TrySelectError.html \"struct crossbeam_channel::TrySelectError\")\n    An error returned from the [`try_select`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Select.html#method.try_select \"method crossbeam_channel::Select::try_select\") method.\n## Enums[\u00a7](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#enums)\n\n[RecvTimeoutError](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/enum.RecvTimeoutError.html \"enum crossbeam_channel::RecvTimeoutError\")\n    An error returned from the [`recv_timeout`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Receiver.html#method.recv_timeout \"method crossbeam_channel::Receiver::recv_timeout\") method.\n\n[SendTimeoutError](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/enum.SendTimeoutError.html \"enum crossbeam_channel::SendTimeoutError\")\n    An error returned from the [`send_timeout`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Sender.html#method.send_timeout \"method crossbeam_channel::Sender::send_timeout\") method.\n\n[TryRecvError](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/enum.TryRecvError.html \"enum crossbeam_channel::TryRecvError\")\n    An error returned from the [`try_recv`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Receiver.html#method.try_recv \"method crossbeam_channel::Receiver::try_recv\") method.\n\n[TrySendError](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/enum.TrySendError.html \"enum crossbeam_channel::TrySendError\")\n    An error returned from the [`try_send`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Sender.html#method.try_send \"method crossbeam_channel::Sender::try_send\") method.\n## Functions[\u00a7](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#functions)\n\n[after](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/fn.after.html \"fn crossbeam_channel::after\")\n    Creates a receiver that delivers a message after a certain duration of time.\n\n[at](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/fn.at.html \"fn crossbeam_channel::at\")\n    Creates a receiver that delivers a message at a certain instant in time.\n\n[bounded](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/fn.bounded.html \"fn crossbeam_channel::bounded\")\n    Creates a channel of bounded capacity.\n\n[never](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/fn.never.html \"fn crossbeam_channel::never\")\n    Creates a receiver that never delivers messages.\n\n[tick](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/fn.tick.html \"fn crossbeam_channel::tick\")\n    Creates a receiver that delivers messages periodically.\n\n[unbounded](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/fn.unbounded.html \"fn crossbeam_channel::unbounded\")\n    Creates a channel of unbounded capacity.\n",
              "markdown_with_citations": "[](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/all.html \"show sidebar\")\n# Crate crossbeam_channelCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nMulti-producer multi-consumer channels for message passing.\nThis crate is an alternative to `std::sync::mpsc`\u27e84\u27e9 with more features and better performance.\n## \u00a7\u27e85\u27e9Hello, world!\n```\nuse crossbeam_channel::unbounded;\n// Create a channel of unbounded capacity.\nlet (s, r) = unbounded();\n// Send a message into the channel.\ns.send(\"Hello, world!\").unwrap();\n// Receive the message from the channel.\nassert_eq!(r.recv(), Ok(\"Hello, world!\"));\n```\n\n## \u00a7\u27e86\u27e9Channel types\nChannels can be created using two functions:\n  * `bounded`\u27e87\u27e9 creates a channel of bounded capacity, i.e. there is a limit to how many messages it can hold at a time.\n  * `unbounded`\u27e88\u27e9 creates a channel of unbounded capacity, i.e. it can hold any number of messages at a time.\n\n\nBoth functions return a `Sender`\u27e89\u27e9 and a `Receiver`\u27e810\u27e9, which represent the two opposite sides of a channel.\nCreating a bounded channel:\n```\nuse crossbeam_channel::bounded;\n// Create a channel that can hold at most 5 messages at a time.\nlet (s, r) = bounded(5);\n// Can send only 5 messages without blocking.\nfor i in 0..5 {\n  s.send(i).unwrap();\n}\n// Another call to `send` would block because the channel is full.\n// s.send(5).unwrap();\n```\n\nCreating an unbounded channel:\n```\nuse crossbeam_channel::unbounded;\n// Create an unbounded channel.\nlet (s, r) = unbounded();\n// Can send any number of messages into the channel without blocking.\nfor i in 0..1000 {\n  s.send(i).unwrap();\n}\n```\n\nA special case is zero-capacity channel, which cannot hold any messages. Instead, send and receive operations must appear at the same time in order to pair up and pass the message over:\n```\nuse std::thread;\nuse crossbeam_channel::bounded;\n// Create a zero-capacity channel.\nlet (s, r) = bounded(0);\n// Sending blocks until a receive operation appears on the other side.\nthread::spawn(move || s.send(\"Hi!\").unwrap());\n// Receiving blocks until a send operation appears on the other side.\nassert_eq!(r.recv(), Ok(\"Hi!\"));\n```\n\n## \u00a7\u27e811\u27e9Sharing channels\nSenders and receivers can be cloned and sent to other threads:\n```\nuse std::thread;\nuse crossbeam_channel::bounded;\nlet (s1, r1) = bounded(0);\nlet (s2, r2) = (s1.clone(), r1.clone());\n// Spawn a thread that receives a message and then sends one.\nthread::spawn(move || {\n  r2.recv().unwrap();\n  s2.send(2).unwrap();\n});\n// Send a message and then receive one.\ns1.send(1).unwrap();\nr1.recv().unwrap();\n```\n\nNote that cloning only creates a new handle to the same sending or receiving side. It does not create a separate stream of messages in any way:\n```\nuse crossbeam_channel::unbounded;\nlet (s1, r1) = unbounded();\nlet (s2, r2) = (s1.clone(), r1.clone());\nlet (s3, r3) = (s2.clone(), r2.clone());\ns1.send(10).unwrap();\ns2.send(20).unwrap();\ns3.send(30).unwrap();\nassert_eq!(r3.recv(), Ok(10));\nassert_eq!(r1.recv(), Ok(20));\nassert_eq!(r2.recv(), Ok(30));\n```\n\nIt\u2019s also possible to share senders and receivers by reference:\n```\nuse crossbeam_channel::bounded;\nuse crossbeam_utils::thread::scope;\nlet (s, r) = bounded(0);\nscope(|scope| {\n  // Spawn a thread that receives a message and then sends one.\n  scope.spawn(|_| {\n    r.recv().unwrap();\n    s.send(2).unwrap();\n  });\n  // Send a message and then receive one.\n  s.send(1).unwrap();\n  r.recv().unwrap();\n}).unwrap();\n```\n\n## \u00a7\u27e812\u27e9Disconnection\nWhen all senders or all receivers associated with a channel get dropped, the channel becomes disconnected. No more messages can be sent, but any remaining messages can still be received. Send and receive operations on a disconnected channel never block.\n```\nuse crossbeam_channel::{unbounded, RecvError};\nlet (s, r) = unbounded();\ns.send(1).unwrap();\ns.send(2).unwrap();\ns.send(3).unwrap();\n// The only sender is dropped, disconnecting the channel.\ndrop(s);\n// The remaining messages can be received.\nassert_eq!(r.recv(), Ok(1));\nassert_eq!(r.recv(), Ok(2));\nassert_eq!(r.recv(), Ok(3));\n// There are no more messages in the channel.\nassert!(r.is_empty());\n// Note that calling `r.recv()` does not block.\n// Instead, `Err(RecvError)` is returned immediately.\nassert_eq!(r.recv(), Err(RecvError));\n```\n\n## \u00a7\u27e813\u27e9Blocking operations\nSend and receive operations come in three flavors:\n  * Non-blocking (returns immediately with success or failure).\n  * Blocking (waits until the operation succeeds or the channel becomes disconnected).\n  * Blocking with a timeout (blocks only for a certain duration of time).\n\n\nA simple example showing the difference between non-blocking and blocking operations:\n```\nuse crossbeam_channel::{bounded, RecvError, TryRecvError};\nlet (s, r) = bounded(1);\n// Send a message into the channel.\ns.send(\"foo\").unwrap();\n// This call would block because the channel is full.\n// s.send(\"bar\").unwrap();\n// Receive the message.\nassert_eq!(r.recv(), Ok(\"foo\"));\n// This call would block because the channel is empty.\n// r.recv();\n// Try receiving a message without blocking.\nassert_eq!(r.try_recv(), Err(TryRecvError::Empty));\n// Disconnect the channel.\ndrop(s);\n// This call doesn't block because the channel is now disconnected.\nassert_eq!(r.recv(), Err(RecvError));\n```\n\n## \u00a7\u27e814\u27e9Iteration\nReceivers can be used as iterators. For example, method `iter`\u27e815\u27e9 creates an iterator that receives messages until the channel becomes empty and disconnected. Note that iteration may block waiting for next message to arrive.\n```\nuse std::thread;\nuse crossbeam_channel::unbounded;\nlet (s, r) = unbounded();\nthread::spawn(move || {\n  s.send(1).unwrap();\n  s.send(2).unwrap();\n  s.send(3).unwrap();\n  drop(s); // Disconnect the channel.\n});\n// Collect all messages from the channel.\n// Note that the call to `collect` blocks until the sender is dropped.\nlet v: Vec<_> = r.iter().collect();\nassert_eq!(v, [1, 2, 3]);\n```\n\nA non-blocking iterator can be created using `try_iter`\u27e816\u27e9, which receives all available messages without blocking:\n```\nuse crossbeam_channel::unbounded;\nlet (s, r) = unbounded();\ns.send(1).unwrap();\ns.send(2).unwrap();\ns.send(3).unwrap();\n// No need to drop the sender.\n// Receive all messages currently in the channel.\nlet v: Vec<_> = r.try_iter().collect();\nassert_eq!(v, [1, 2, 3]);\n```\n\n## \u00a7\u27e817\u27e9Selection\nThe `select!`\u27e818\u27e9 macro allows you to define a set of channel operations, wait until any one of them becomes ready, and finally execute it. If multiple operations are ready at the same time, a random one among them is selected.\nIt is also possible to define a `default` case that gets executed if none of the operations are ready, either right away or for a certain duration of time.\nAn operation is considered to be ready if it doesn\u2019t have to block. Note that it is ready even when it will simply return an error because the channel is disconnected.\nAn example of receiving a message from two channels:\n```\nuse std::thread;\nuse std::time::Duration;\nuse crossbeam_channel::{select, unbounded};\nlet (s1, r1) = unbounded();\nlet (s2, r2) = unbounded();\nthread::spawn(move || s1.send(10).unwrap());\nthread::spawn(move || s2.send(20).unwrap());\n// At most one of these two receive operations will be executed.\nselect! {\n  recv(r1) -> msg => assert_eq!(msg, Ok(10)),\n  recv(r2) -> msg => assert_eq!(msg, Ok(20)),\n  default(Duration::from_secs(1)) => println!(\"timed out\"),\n}\n```\n\nIf you need to select over a dynamically created list of channel operations, use `Select`\u27e819\u27e9 instead. The `select!`\u27e818\u27e9 macro is just a convenience wrapper around `Select`\u27e819\u27e9.\n## \u00a7\u27e820\u27e9Extra channels\nThree functions can create special kinds of channels, all of which return just a `Receiver`\u27e810\u27e9 handle:\n  * `after`\u27e821\u27e9 creates a channel that delivers a single message after a certain duration of time.\n  * `tick`\u27e822\u27e9 creates a channel that delivers messages periodically.\n  * `never`\u27e823\u27e9 creates a channel that never delivers messages.\n\n\nThese channels are very efficient because messages get lazily generated on receive operations.\nAn example that prints elapsed time every 50 milliseconds for the duration of 1 second:\n```\nuse std::time::{Duration, Instant};\nuse crossbeam_channel::{after, select, tick};\nlet start = Instant::now();\nlet ticker = tick(Duration::from_millis(50));\nlet timeout = after(Duration::from_secs(1));\nloop {\n  select! {\n    recv(ticker) -> _ => println!(\"elapsed: {:?}\", start.elapsed()),\n    recv(timeout) -> _ => break,\n  }\n}\n```\n\n## Macros\u00a7\u27e824\u27e9\n\nselect\u27e818\u27e9\n    Selects from a set of channel operations.\n\nselect_biased\u27e825\u27e9\n    Selects from a set of channel operations.\n## Structs\u00a7\u27e826\u27e9\n\nIntoIter\u27e827\u27e9\n    A blocking iterator over messages in a channel.\n\nIter\u27e828\u27e9\n    A blocking iterator over messages in a channel.\n\nReadyTimeoutError\u27e829\u27e9\n    An error returned from the `ready_timeout`\u27e830\u27e9 method.\n\nReceiver\u27e810\u27e9\n    The receiving side of a channel.\n\nRecvError\u27e831\u27e9\n    An error returned from the `recv`\u27e832\u27e9 method.\n\nSelect\u27e819\u27e9\n    Selects from a set of channel operations.\n\nSelectTimeoutError\u27e833\u27e9\n    An error returned from the `select_timeout`\u27e834\u27e9 method.\n\nSelectedOperation\u27e835\u27e9\n    A selected operation that needs to be completed.\n\nSendError\u27e836\u27e9\n    An error returned from the `send`\u27e837\u27e9 method.\n\nSender\u27e89\u27e9\n    The sending side of a channel.\n\nTryIter\u27e838\u27e9\n    A non-blocking iterator over messages in a channel.\n\nTryReadyError\u27e839\u27e9\n    An error returned from the `try_ready`\u27e840\u27e9 method.\n\nTrySelectError\u27e841\u27e9\n    An error returned from the `try_select`\u27e842\u27e9 method.\n## Enums\u00a7\u27e843\u27e9\n\nRecvTimeoutError\u27e844\u27e9\n    An error returned from the `recv_timeout`\u27e845\u27e9 method.\n\nSendTimeoutError\u27e846\u27e9\n    An error returned from the `send_timeout`\u27e847\u27e9 method.\n\nTryRecvError\u27e848\u27e9\n    An error returned from the `try_recv`\u27e849\u27e9 method.\n\nTrySendError\u27e850\u27e9\n    An error returned from the `try_send`\u27e851\u27e9 method.\n## Functions\u00a7\u27e852\u27e9\n\nafter\u27e821\u27e9\n    Creates a receiver that delivers a message after a certain duration of time.\n\nat\u27e853\u27e9\n    Creates a receiver that delivers a message at a certain instant in time.\n\nbounded\u27e87\u27e9\n    Creates a channel of bounded capacity.\n\nnever\u27e823\u27e9\n    Creates a receiver that never delivers messages.\n\ntick\u27e822\u27e9\n    Creates a receiver that delivers messages periodically.\n\nunbounded\u27e88\u27e9\n    Creates a channel of unbounded capacity.\n",
              "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/crossbeam-channel/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/crossbeam-channel/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/crossbeam-channel/latest/src/crossbeam_channel/lib.rs.html#1-378: Source\n\u27e84\u27e9 https://doc.rust-lang.org/nightly/std/sync/mpsc/index.html: mod std::sync::mpsc - `std::sync::mpsc`\n\u27e85\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#hello-world: \u00a7\n\u27e86\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#channel-types: \u00a7\n\u27e87\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/fn.bounded.html: fn crossbeam_channel::bounded - `bounded`\n\u27e88\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/fn.unbounded.html: fn crossbeam_channel::unbounded - `unbounded`\n\u27e89\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Sender.html: struct crossbeam_channel::Sender - `Sender`\n\u27e810\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Receiver.html: struct crossbeam_channel::Receiver - `Receiver`\n\u27e811\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#sharing-channels: \u00a7\n\u27e812\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#disconnection: \u00a7\n\u27e813\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#blocking-operations: \u00a7\n\u27e814\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#iteration: \u00a7\n\u27e815\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Receiver.html#method.iter: method crossbeam_channel::Receiver::iter - `iter`\n\u27e816\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Receiver.html#method.try_iter: method crossbeam_channel::Receiver::try_iter - `try_iter`\n\u27e817\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#selection: \u00a7\n\u27e818\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/macro.select.html: macro crossbeam_channel::select - `select!`\n\u27e819\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Select.html: struct crossbeam_channel::Select - `Select`\n\u27e820\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#extra-channels: \u00a7\n\u27e821\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/fn.after.html: fn crossbeam_channel::after - `after`\n\u27e822\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/fn.tick.html: fn crossbeam_channel::tick - `tick`\n\u27e823\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/fn.never.html: fn crossbeam_channel::never - `never`\n\u27e824\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#macros: \u00a7\n\u27e825\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/macro.select_biased.html: macro crossbeam_channel::select_biased - select_biased\n\u27e826\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#structs: \u00a7\n\u27e827\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.IntoIter.html: struct crossbeam_channel::IntoIter - IntoIter\n\u27e828\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Iter.html: struct crossbeam_channel::Iter - Iter\n\u27e829\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.ReadyTimeoutError.html: struct crossbeam_channel::ReadyTimeoutError - ReadyTimeoutError\n\u27e830\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Select.html#method.ready_timeout: method crossbeam_channel::Select::ready_timeout - `ready_timeout`\n\u27e831\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.RecvError.html: struct crossbeam_channel::RecvError - RecvError\n\u27e832\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Receiver.html#method.recv: method crossbeam_channel::Receiver::recv - `recv`\n\u27e833\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.SelectTimeoutError.html: struct crossbeam_channel::SelectTimeoutError - SelectTimeoutError\n\u27e834\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Select.html#method.select_timeout: method crossbeam_channel::Select::select_timeout - `select_timeout`\n\u27e835\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.SelectedOperation.html: struct crossbeam_channel::SelectedOperation - SelectedOperation\n\u27e836\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.SendError.html: struct crossbeam_channel::SendError - SendError\n\u27e837\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Sender.html#method.send: method crossbeam_channel::Sender::send - `send`\n\u27e838\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.TryIter.html: struct crossbeam_channel::TryIter - TryIter\n\u27e839\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.TryReadyError.html: struct crossbeam_channel::TryReadyError - TryReadyError\n\u27e840\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Select.html#method.try_ready: method crossbeam_channel::Select::try_ready - `try_ready`\n\u27e841\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.TrySelectError.html: struct crossbeam_channel::TrySelectError - TrySelectError\n\u27e842\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Select.html#method.try_select: method crossbeam_channel::Select::try_select - `try_select`\n\u27e843\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#enums: \u00a7\n\u27e844\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/enum.RecvTimeoutError.html: enum crossbeam_channel::RecvTimeoutError - RecvTimeoutError\n\u27e845\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Receiver.html#method.recv_timeout: method crossbeam_channel::Receiver::recv_timeout - `recv_timeout`\n\u27e846\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/enum.SendTimeoutError.html: enum crossbeam_channel::SendTimeoutError - SendTimeoutError\n\u27e847\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Sender.html#method.send_timeout: method crossbeam_channel::Sender::send_timeout - `send_timeout`\n\u27e848\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/enum.TryRecvError.html: enum crossbeam_channel::TryRecvError - TryRecvError\n\u27e849\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Receiver.html#method.try_recv: method crossbeam_channel::Receiver::try_recv - `try_recv`\n\u27e850\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/enum.TrySendError.html: enum crossbeam_channel::TrySendError - TrySendError\n\u27e851\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Sender.html#method.try_send: method crossbeam_channel::Sender::try_send - `try_send`\n\u27e852\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#functions: \u00a7\n\u27e853\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/fn.at.html: fn crossbeam_channel::at - at\n",
              "fit_markdown": "",
              "fit_html": ""
            },
            "structured_data": {},
            "quality_score": 4.0,
            "extraction_method": "crawl4ai",
            "error": null,
            "metadata": {
              "doc_type": "docs",
              "content_length": 17280,
              "has_structured_data": false,
              "crawl_success": true
            },
            "timestamp": "116651.7560472"
          },
          "lib_rs": {
            "url": "https://lib.rs/crates/crossbeam-channel",
            "title": "Untitled",
            "content": {
              "raw_markdown": "###  [29 releases](https://lib.rs/crates/crossbeam-channel/versions)\n0.5.15 |  Apr 8, 2025   \n---|---  \n0.5.14 |  ~~Dec 15, 2024~~  \n0.5.13 |  ~~May 19, 2024~~  \n0.5.12 |  ~~Feb 28, 2024~~  \n0.1.1 |  Nov 27, 2017   \n#**76** in [Concurrency](https://lib.rs/concurrency \"Crates for implementing concurrent and parallel computation.\")\nDownload history 2407451/week @ 2025-03-08 2593872/week @ 2025-03-15 2836784/week @ 2025-03-22 2253206/week @ 2025-03-29 2397980/week @ 2025-04-05 2217875/week @ 2025-04-12 2178209/week @ 2025-04-19 2064607/week @ 2025-04-26 2145127/week @ 2025-05-03 2228391/week @ 2025-05-10 2294861/week @ 2025-05-17 1909466/week @ 2025-05-24 2068321/week @ 2025-05-31 2123130/week @ 2025-06-07 2218289/week @ 2025-06-14 2075985/week @ 2025-06-21\n**8,821,153** downloads per month Used in [**9,934** crates (1,463 directly)](https://lib.rs/crates/crossbeam-channel/rev)\n**MIT/Apache**\n360KB  5.5K  SLoC\n# Crossbeam Channel\n[![Build Status](https://img.gs/czjpqfbdkz/full/https://github.com/crossbeam-rs/crossbeam/workflows/CI/badge.svg)](https://github.com/crossbeam-rs/crossbeam/actions) [![License](https://img.shields.io/badge/license-MIT_OR_Apache--2.0-blue.svg)](https://github.com/crossbeam-rs/crossbeam/tree/master/crossbeam-channel#license) [![Cargo](https://img.shields.io/crates/v/crossbeam-channel.svg)](https://crates.io/crates/crossbeam-channel) [![Documentation](https://img.gs/czjpqfbdkz/full/https://docs.rs/crossbeam-channel/badge.svg)](https://docs.rs/crossbeam-channel) [![Rust 1.60+](https://img.shields.io/badge/rust-1.60+-lightgray.svg)](https://www.rust-lang.org) [![chat](https://img.shields.io/discord/569610676205781012.svg?logo=discord)](https://discord.com/invite/JXYwgWZ)\nThis crate provides multi-producer multi-consumer channels for message passing. It is an alternative to [```std`::```sync`::``mpsc``](https://doc.rust-lang.org/std/sync/mpsc/index.html) with more features and better performance.\nSome highlights:\n  * [``Sender``](https://docs.rs/crossbeam-channel/*/crossbeam_channel/struct.Sender.html)s and [``Receiver``](https://docs.rs/crossbeam-channel/*/crossbeam_channel/struct.Receiver.html)s can be cloned and shared among threads.\n  * Two main kinds of channels are [``bounded``](https://docs.rs/crossbeam-channel/*/crossbeam_channel/fn.bounded.html) and [``unbounded``](https://docs.rs/crossbeam-channel/*/crossbeam_channel/fn.unbounded.html).\n  * Convenient extra channels like [``after``](https://docs.rs/crossbeam-channel/*/crossbeam_channel/fn.after.html), [``never``](https://docs.rs/crossbeam-channel/*/crossbeam_channel/fn.never.html), and [``tick``](https://docs.rs/crossbeam-channel/*/crossbeam_channel/fn.tick.html).\n  * The [``select!``](https://docs.rs/crossbeam-channel/*/crossbeam_channel/macro.select.html) macro can block on multiple channel operations.\n  * [``Select``](https://docs.rs/crossbeam-channel/*/crossbeam_channel/struct.Select.html) can select over a dynamically built list of channel operations.\n  * Channels use locks very sparingly for maximum [performance](https://github.com/crossbeam-rs/crossbeam/blob/d35ffde18a76ae9667f602d8c0127ff89ac2e4d4/crossbeam-channel/benchmarks).\n\n\n## Usage\nAdd this to your ``Cargo.toml``:\n```\n```[``dependencies``]`\n`crossbeam-channel ``=` ``\"`0.5`\"``\n``\n```\n\n## Compatibility\nCrossbeam Channel supports stable Rust releases going back at least six months, and every time the minimum supported Rust version is increased, a new minor version is released. Currently, the minimum supported Rust version is 1.60.\n## License\nLicensed under either of\n  * Apache License, Version 2.0 ([LICENSE-APACHE](https://github.com/crossbeam-rs/crossbeam/blob/d35ffde18a76ae9667f602d8c0127ff89ac2e4d4/crossbeam-channel/LICENSE-APACHE) or <http://www.apache.org/licenses/LICENSE-2.0>)\n  * MIT license ([LICENSE-MIT](https://github.com/crossbeam-rs/crossbeam/blob/d35ffde18a76ae9667f602d8c0127ff89ac2e4d4/crossbeam-channel/LICENSE-MIT) or <http://opensource.org/licenses/MIT>)\n\n\nat your option.\n#### Contribution\nUnless you explicitly state otherwise, any contribution intentionally submitted for inclusion in the work by you, as defined in the Apache-2.0 license, shall be dual licensed as above, without any additional terms or conditions.\n#### Third party software\nThis product includes copies and modifications of software developed by third parties:\n  * [examples/matching.rs](https://github.com/crossbeam-rs/crossbeam/blob/d35ffde18a76ae9667f602d8c0127ff89ac2e4d4/crossbeam-channel/examples/matching.rs) includes [matching.go](http://www.nada.kth.se/~snilsson/concurrency/src/matching.go) by Stefan Nilsson, licensed under Creative Commons Attribution 3.0 Unported License.\n  * [tests/mpsc.rs](https://github.com/crossbeam-rs/crossbeam/blob/d35ffde18a76ae9667f602d8c0127ff89ac2e4d4/crossbeam-channel/tests/mpsc.rs) includes modifications of code from The Rust Programming Language, licensed under the MIT License and the Apache License, Version 2.0.\n  * [tests/golang.rs](https://github.com/crossbeam-rs/crossbeam/blob/d35ffde18a76ae9667f602d8c0127ff89ac2e4d4/crossbeam-channel/tests/golang.rs) is based on code from The Go Programming Language, licensed under the 3-Clause BSD License.\n\n\nSee the source code files for more details.\nCopies of third party licenses can be found in [LICENSE-THIRD-PARTY](https://github.com/crossbeam-rs/crossbeam/blob/d35ffde18a76ae9667f602d8c0127ff89ac2e4d4/crossbeam-channel/LICENSE-THIRD-PARTY).\n#### Dependencies\n  * [crossbeam-utils](https://lib.rs/crates/crossbeam-utils \"0.8.18\")\n\n\n  * dev  [num_cpus](https://lib.rs/crates/num_cpus \"1.13.0\")\n  * dev  [rand](https://lib.rs/crates/rand \"outdated\") 0.8\n  * dev  [signal-hook](https://lib.rs/crates/signal-hook \"0.3\")\n\n\n#### [Other feature](https://lib.rs/crates/crossbeam-channel/features)\n  * [std](https://lib.rs/crates/crossbeam-channel/features#feature-std)\n\n\n  *[SLoC]: Lines of code, excluding comments\n",
              "markdown_with_citations": "###  29 releases\u27e81\u27e9\n0.5.15 |  Apr 8, 2025   \n---|---  \n0.5.14 |  ~~Dec 15, 2024~~  \n0.5.13 |  ~~May 19, 2024~~  \n0.5.12 |  ~~Feb 28, 2024~~  \n0.1.1 |  Nov 27, 2017   \n#**76** in Concurrency\u27e82\u27e9\nDownload history 2407451/week @ 2025-03-08 2593872/week @ 2025-03-15 2836784/week @ 2025-03-22 2253206/week @ 2025-03-29 2397980/week @ 2025-04-05 2217875/week @ 2025-04-12 2178209/week @ 2025-04-19 2064607/week @ 2025-04-26 2145127/week @ 2025-05-03 2228391/week @ 2025-05-10 2294861/week @ 2025-05-17 1909466/week @ 2025-05-24 2068321/week @ 2025-05-31 2123130/week @ 2025-06-07 2218289/week @ 2025-06-14 2075985/week @ 2025-06-21\n**8,821,153** downloads per month Used in **9,934** crates (1,463 directly)\u27e83\u27e9\n**MIT/Apache**\n360KB  5.5K  SLoC\n# Crossbeam Channel\n![Build Status\u27e84\u27e9](https://github.com/crossbeam-rs/crossbeam/actions) ![License\u27e85\u27e9](https://github.com/crossbeam-rs/crossbeam/tree/master/crossbeam-channel#license) ![Cargo\u27e86\u27e9](https://crates.io/crates/crossbeam-channel) ![Documentation\u27e87\u27e9](https://docs.rs/crossbeam-channel) ![Rust 1.60+\u27e88\u27e9](https://www.rust-lang.org) ![chat\u27e89\u27e9](https://discord.com/invite/JXYwgWZ)\nThis crate provides multi-producer multi-consumer channels for message passing. It is an alternative to ```std`::```sync`::``mpsc``\u27e810\u27e9 with more features and better performance.\nSome highlights:\n  * ``Sender``\u27e811\u27e9s and ``Receiver``\u27e812\u27e9s can be cloned and shared among threads.\n  * Two main kinds of channels are ``bounded``\u27e813\u27e9 and ``unbounded``\u27e814\u27e9.\n  * Convenient extra channels like ``after``\u27e815\u27e9, ``never``\u27e816\u27e9, and ``tick``\u27e817\u27e9.\n  * The ``select!``\u27e818\u27e9 macro can block on multiple channel operations.\n  * ``Select``\u27e819\u27e9 can select over a dynamically built list of channel operations.\n  * Channels use locks very sparingly for maximum performance\u27e820\u27e9.\n\n\n## Usage\nAdd this to your ``Cargo.toml``:\n```\n```[``dependencies``]`\n`crossbeam-channel ``=` ``\"`0.5`\"``\n``\n```\n\n## Compatibility\nCrossbeam Channel supports stable Rust releases going back at least six months, and every time the minimum supported Rust version is increased, a new minor version is released. Currently, the minimum supported Rust version is 1.60.\n## License\nLicensed under either of\n  * Apache License, Version 2.0 (LICENSE-APACHE\u27e821\u27e9 or <http://www.apache.org/licenses/LICENSE-2.0>)\n  * MIT license (LICENSE-MIT\u27e822\u27e9 or <http://opensource.org/licenses/MIT>)\n\n\nat your option.\n#### Contribution\nUnless you explicitly state otherwise, any contribution intentionally submitted for inclusion in the work by you, as defined in the Apache-2.0 license, shall be dual licensed as above, without any additional terms or conditions.\n#### Third party software\nThis product includes copies and modifications of software developed by third parties:\n  * examples/matching.rs\u27e823\u27e9 includes matching.go\u27e824\u27e9 by Stefan Nilsson, licensed under Creative Commons Attribution 3.0 Unported License.\n  * tests/mpsc.rs\u27e825\u27e9 includes modifications of code from The Rust Programming Language, licensed under the MIT License and the Apache License, Version 2.0.\n  * tests/golang.rs\u27e826\u27e9 is based on code from The Go Programming Language, licensed under the 3-Clause BSD License.\n\n\nSee the source code files for more details.\nCopies of third party licenses can be found in LICENSE-THIRD-PARTY\u27e827\u27e9.\n#### Dependencies\n  * crossbeam-utils\u27e828\u27e9\n\n\n  * dev  num_cpus\u27e829\u27e9\n  * dev  rand\u27e830\u27e9 0.8\n  * dev  signal-hook\u27e831\u27e9\n\n\n#### Other feature\u27e832\u27e9\n  * std\u27e833\u27e9\n\n\n  *[SLoC]: Lines of code, excluding comments\n",
              "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://lib.rs/crates/crossbeam-channel/versions: 29 releases\n\u27e82\u27e9 https://lib.rs/concurrency: Crates for implementing concurrent and parallel computation. - Concurrency\n\u27e83\u27e9 https://lib.rs/crates/crossbeam-channel/rev: **9,934** crates (1,463 directly)\n\u27e84\u27e9 https://img.gs/czjpqfbdkz/full/https://github.com/crossbeam-rs/crossbeam/workflows/CI/badge.svg: ![Build Status\n\u27e85\u27e9 https://img.shields.io/badge/license-MIT_OR_Apache--2.0-blue.svg: ![License\n\u27e86\u27e9 https://img.shields.io/crates/v/crossbeam-channel.svg: ![Cargo\n\u27e87\u27e9 https://img.gs/czjpqfbdkz/full/https://docs.rs/crossbeam-channel/badge.svg: ![Documentation\n\u27e88\u27e9 https://img.shields.io/badge/rust-1.60+-lightgray.svg: ![Rust 1.60+\n\u27e89\u27e9 https://img.shields.io/discord/569610676205781012.svg?logo=discord: ![chat\n\u27e810\u27e9 https://doc.rust-lang.org/std/sync/mpsc/index.html: ```std`::```sync`::``mpsc``\n\u27e811\u27e9 https://docs.rs/crossbeam-channel/*/crossbeam_channel/struct.Sender.html: ``Sender``\n\u27e812\u27e9 https://docs.rs/crossbeam-channel/*/crossbeam_channel/struct.Receiver.html: ``Receiver``\n\u27e813\u27e9 https://docs.rs/crossbeam-channel/*/crossbeam_channel/fn.bounded.html: ``bounded``\n\u27e814\u27e9 https://docs.rs/crossbeam-channel/*/crossbeam_channel/fn.unbounded.html: ``unbounded``\n\u27e815\u27e9 https://docs.rs/crossbeam-channel/*/crossbeam_channel/fn.after.html: ``after``\n\u27e816\u27e9 https://docs.rs/crossbeam-channel/*/crossbeam_channel/fn.never.html: ``never``\n\u27e817\u27e9 https://docs.rs/crossbeam-channel/*/crossbeam_channel/fn.tick.html: ``tick``\n\u27e818\u27e9 https://docs.rs/crossbeam-channel/*/crossbeam_channel/macro.select.html: ``select!``\n\u27e819\u27e9 https://docs.rs/crossbeam-channel/*/crossbeam_channel/struct.Select.html: ``Select``\n\u27e820\u27e9 https://github.com/crossbeam-rs/crossbeam/blob/d35ffde18a76ae9667f602d8c0127ff89ac2e4d4/crossbeam-channel/benchmarks: performance\n\u27e821\u27e9 https://github.com/crossbeam-rs/crossbeam/blob/d35ffde18a76ae9667f602d8c0127ff89ac2e4d4/crossbeam-channel/LICENSE-APACHE: LICENSE-APACHE\n\u27e822\u27e9 https://github.com/crossbeam-rs/crossbeam/blob/d35ffde18a76ae9667f602d8c0127ff89ac2e4d4/crossbeam-channel/LICENSE-MIT: LICENSE-MIT\n\u27e823\u27e9 https://github.com/crossbeam-rs/crossbeam/blob/d35ffde18a76ae9667f602d8c0127ff89ac2e4d4/crossbeam-channel/examples/matching.rs: examples/matching.rs\n\u27e824\u27e9 http://www.nada.kth.se/~snilsson/concurrency/src/matching.go: matching.go\n\u27e825\u27e9 https://github.com/crossbeam-rs/crossbeam/blob/d35ffde18a76ae9667f602d8c0127ff89ac2e4d4/crossbeam-channel/tests/mpsc.rs: tests/mpsc.rs\n\u27e826\u27e9 https://github.com/crossbeam-rs/crossbeam/blob/d35ffde18a76ae9667f602d8c0127ff89ac2e4d4/crossbeam-channel/tests/golang.rs: tests/golang.rs\n\u27e827\u27e9 https://github.com/crossbeam-rs/crossbeam/blob/d35ffde18a76ae9667f602d8c0127ff89ac2e4d4/crossbeam-channel/LICENSE-THIRD-PARTY: LICENSE-THIRD-PARTY\n\u27e828\u27e9 https://lib.rs/crates/crossbeam-utils: 0.8.18 - crossbeam-utils\n\u27e829\u27e9 https://lib.rs/crates/num_cpus: 1.13.0 - num_cpus\n\u27e830\u27e9 https://lib.rs/crates/rand: outdated - rand\n\u27e831\u27e9 https://lib.rs/crates/signal-hook: 0.3 - signal-hook\n\u27e832\u27e9 https://lib.rs/crates/crossbeam-channel/features: Other feature\n\u27e833\u27e9 https://lib.rs/crates/crossbeam-channel/features#feature-std: std\n",
              "fit_markdown": "",
              "fit_html": ""
            },
            "structured_data": {},
            "quality_score": 3.0,
            "extraction_method": "crawl4ai",
            "error": null,
            "metadata": {
              "doc_type": "docs",
              "content_length": 5908,
              "has_structured_data": false,
              "crawl_success": true
            },
            "timestamp": "116652.1541005"
          }
        },
        "crate_analysis": {
          "status": "completed",
          "check": [
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#crossbeam-utils@0.8.21",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\crossbeam-utils-0.8.21\\Cargo.toml",
              "target": {
                "kind": [
                  "custom-build"
                ],
                "crate_types": [
                  "bin"
                ],
                "name": "build-script-build",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\crossbeam-utils-0.8.21\\build.rs",
                "edition": "2021",
                "doc": false,
                "doctest": false,
                "test": false
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "std"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp_zwb0qyf\\crossbeam-channel-0.5.15\\target\\debug\\build\\crossbeam-utils-fa9754cdc3e3a37a\\build-script-build.exe",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp_zwb0qyf\\crossbeam-channel-0.5.15\\target\\debug\\build\\crossbeam-utils-fa9754cdc3e3a37a\\build_script_build.pdb"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "build-script-executed",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#crossbeam-utils@0.8.21",
              "linked_libs": [],
              "linked_paths": [],
              "cfgs": [],
              "env": [],
              "out_dir": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp_zwb0qyf\\crossbeam-channel-0.5.15\\target\\debug\\build\\crossbeam-utils-c09e493f89b8d7f2\\out"
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#crossbeam-utils@0.8.21",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\crossbeam-utils-0.8.21\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "crossbeam_utils",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\crossbeam-utils-0.8.21\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "std"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp_zwb0qyf\\crossbeam-channel-0.5.15\\target\\debug\\deps\\libcrossbeam_utils-e068025586ae0021.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "compiler-artifact",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmp_zwb0qyf/crossbeam-channel-0.5.15#crossbeam-channel@0.5.15",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp_zwb0qyf\\crossbeam-channel-0.5.15\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "crossbeam_channel",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp_zwb0qyf\\crossbeam-channel-0.5.15\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "default",
                "std"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp_zwb0qyf\\crossbeam-channel-0.5.15\\target\\debug\\deps\\libcrossbeam_channel-2497c4112fe6ccdc.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "build-finished",
              "success": true
            }
          ],
          "clippy": [
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#crossbeam-utils@0.8.21",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\crossbeam-utils-0.8.21\\Cargo.toml",
              "target": {
                "kind": [
                  "custom-build"
                ],
                "crate_types": [
                  "bin"
                ],
                "name": "build-script-build",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\crossbeam-utils-0.8.21\\build.rs",
                "edition": "2021",
                "doc": false,
                "doctest": false,
                "test": false
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "std"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp_zwb0qyf\\crossbeam-channel-0.5.15\\target\\debug\\build\\crossbeam-utils-fa9754cdc3e3a37a\\build-script-build.exe",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp_zwb0qyf\\crossbeam-channel-0.5.15\\target\\debug\\build\\crossbeam-utils-fa9754cdc3e3a37a\\build_script_build.pdb"
              ],
              "executable": null,
              "fresh": true
            },
            {
              "reason": "build-script-executed",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#crossbeam-utils@0.8.21",
              "linked_libs": [],
              "linked_paths": [],
              "cfgs": [],
              "env": [],
              "out_dir": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp_zwb0qyf\\crossbeam-channel-0.5.15\\target\\debug\\build\\crossbeam-utils-c09e493f89b8d7f2\\out"
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#crossbeam-utils@0.8.21",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\crossbeam-utils-0.8.21\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "crossbeam_utils",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\crossbeam-utils-0.8.21\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "std"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp_zwb0qyf\\crossbeam-channel-0.5.15\\target\\debug\\deps\\libcrossbeam_utils-e068025586ae0021.rmeta"
              ],
              "executable": null,
              "fresh": true
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmp_zwb0qyf/crossbeam-channel-0.5.15#crossbeam-channel@0.5.15",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp_zwb0qyf\\crossbeam-channel-0.5.15\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "crossbeam_channel",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp_zwb0qyf\\crossbeam-channel-0.5.15\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: importing legacy numeric constants\n --> src\\counter.rs:4:5\n  |\n4 | use std::isize;\n  |     ^^^^^^^^^^\n  |\n  = help: remove this import\n  = note: then `isize::<CONST>` will resolve to the respective associated constant\n  = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#legacy_numeric_constants\n  = note: `#[warn(clippy::legacy_numeric_constants)]` on by default\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "remove this import",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "note",
                    "message": "then `isize::<CONST>` will resolve to the respective associated constant",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#legacy_numeric_constants",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "note",
                    "message": "`#[warn(clippy::legacy_numeric_constants)]` on by default",
                    "rendered": null,
                    "spans": []
                  }
                ],
                "code": {
                  "code": "clippy::legacy_numeric_constants",
                  "explanation": null
                },
                "level": "warning",
                "message": "importing legacy numeric constants",
                "spans": [
                  {
                    "byte_end": 72,
                    "byte_start": 62,
                    "column_end": 15,
                    "column_start": 5,
                    "expansion": null,
                    "file_name": "src\\counter.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 4,
                    "line_start": 4,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 15,
                        "highlight_start": 5,
                        "text": "use std::isize;"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmp_zwb0qyf/crossbeam-channel-0.5.15#crossbeam-channel@0.5.15",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp_zwb0qyf\\crossbeam-channel-0.5.15\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "crossbeam_channel",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp_zwb0qyf\\crossbeam-channel-0.5.15\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: match expression looks like `matches!` macro\n   --> src\\err.rs:203:9\n    |\n203 | /         match self {\n204 | |             TrySendError::Full(_) => true,\n205 | |             _ => false,\n206 | |         }\n    | |_________^ help: try: `matches!(self, TrySendError::Full(_))`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#match_like_matches_macro\n    = note: `#[warn(clippy::match_like_matches_macro)]` on by default\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#match_like_matches_macro",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "note",
                    "message": "`#[warn(clippy::match_like_matches_macro)]` on by default",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "try",
                    "rendered": null,
                    "spans": [
                      {
                        "byte_end": 6157,
                        "byte_start": 6068,
                        "column_end": 10,
                        "column_start": 9,
                        "expansion": null,
                        "file_name": "src\\err.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 206,
                        "line_start": 203,
                        "suggested_replacement": "matches!(self, TrySendError::Full(_))",
                        "suggestion_applicability": "MaybeIncorrect",
                        "text": [
                          {
                            "highlight_end": 21,
                            "highlight_start": 9,
                            "text": "        match self {"
                          },
                          {
                            "highlight_end": 43,
                            "highlight_start": 1,
                            "text": "            TrySendError::Full(_) => true,"
                          },
                          {
                            "highlight_end": 24,
                            "highlight_start": 1,
                            "text": "            _ => false,"
                          },
                          {
                            "highlight_end": 10,
                            "highlight_start": 1,
                            "text": "        }"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "code": {
                  "code": "clippy::match_like_matches_macro",
                  "explanation": null
                },
                "level": "warning",
                "message": "match expression looks like `matches!` macro",
                "spans": [
                  {
                    "byte_end": 6157,
                    "byte_start": 6068,
                    "column_end": 10,
                    "column_start": 9,
                    "expansion": null,
                    "file_name": "src\\err.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 206,
                    "line_start": 203,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 21,
                        "highlight_start": 9,
                        "text": "        match self {"
                      },
                      {
                        "highlight_end": 43,
                        "highlight_start": 1,
                        "text": "            TrySendError::Full(_) => true,"
                      },
                      {
                        "highlight_end": 24,
                        "highlight_start": 1,
                        "text": "            _ => false,"
                      },
                      {
                        "highlight_end": 10,
                        "highlight_start": 1,
                        "text": "        }"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmp_zwb0qyf/crossbeam-channel-0.5.15#crossbeam-channel@0.5.15",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp_zwb0qyf\\crossbeam-channel-0.5.15\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "crossbeam_channel",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp_zwb0qyf\\crossbeam-channel-0.5.15\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: match expression looks like `matches!` macro\n   --> src\\err.rs:211:9\n    |\n211 | /         match self {\n212 | |             TrySendError::Disconnected(_) => true,\n213 | |             _ => false,\n214 | |         }\n    | |_________^ help: try: `matches!(self, TrySendError::Disconnected(_))`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#match_like_matches_macro\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#match_like_matches_macro",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "try",
                    "rendered": null,
                    "spans": [
                      {
                        "byte_end": 6403,
                        "byte_start": 6306,
                        "column_end": 10,
                        "column_start": 9,
                        "expansion": null,
                        "file_name": "src\\err.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 214,
                        "line_start": 211,
                        "suggested_replacement": "matches!(self, TrySendError::Disconnected(_))",
                        "suggestion_applicability": "MaybeIncorrect",
                        "text": [
                          {
                            "highlight_end": 21,
                            "highlight_start": 9,
                            "text": "        match self {"
                          },
                          {
                            "highlight_end": 51,
                            "highlight_start": 1,
                            "text": "            TrySendError::Disconnected(_) => true,"
                          },
                          {
                            "highlight_end": 24,
                            "highlight_start": 1,
                            "text": "            _ => false,"
                          },
                          {
                            "highlight_end": 10,
                            "highlight_start": 1,
                            "text": "        }"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "code": {
                  "code": "clippy::match_like_matches_macro",
                  "explanation": null
                },
                "level": "warning",
                "message": "match expression looks like `matches!` macro",
                "spans": [
                  {
                    "byte_end": 6403,
                    "byte_start": 6306,
                    "column_end": 10,
                    "column_start": 9,
                    "expansion": null,
                    "file_name": "src\\err.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 214,
                    "line_start": 211,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 21,
                        "highlight_start": 9,
                        "text": "        match self {"
                      },
                      {
                        "highlight_end": 51,
                        "highlight_start": 1,
                        "text": "            TrySendError::Disconnected(_) => true,"
                      },
                      {
                        "highlight_end": 24,
                        "highlight_start": 1,
                        "text": "            _ => false,"
                      },
                      {
                        "highlight_end": 10,
                        "highlight_start": 1,
                        "text": "        }"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmp_zwb0qyf/crossbeam-channel-0.5.15#crossbeam-channel@0.5.15",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp_zwb0qyf\\crossbeam-channel-0.5.15\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "crossbeam_channel",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp_zwb0qyf\\crossbeam-channel-0.5.15\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: match expression looks like `matches!` macro\n   --> src\\err.rs:267:9\n    |\n267 | /         match self {\n268 | |             SendTimeoutError::Timeout(_) => true,\n269 | |             _ => false,\n270 | |         }\n    | |_________^ help: try: `matches!(self, SendTimeoutError::Timeout(_))`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#match_like_matches_macro\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#match_like_matches_macro",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "try",
                    "rendered": null,
                    "spans": [
                      {
                        "byte_end": 7917,
                        "byte_start": 7821,
                        "column_end": 10,
                        "column_start": 9,
                        "expansion": null,
                        "file_name": "src\\err.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 270,
                        "line_start": 267,
                        "suggested_replacement": "matches!(self, SendTimeoutError::Timeout(_))",
                        "suggestion_applicability": "MaybeIncorrect",
                        "text": [
                          {
                            "highlight_end": 21,
                            "highlight_start": 9,
                            "text": "        match self {"
                          },
                          {
                            "highlight_end": 50,
                            "highlight_start": 1,
                            "text": "            SendTimeoutError::Timeout(_) => true,"
                          },
                          {
                            "highlight_end": 24,
                            "highlight_start": 1,
                            "text": "            _ => false,"
                          },
                          {
                            "highlight_end": 10,
                            "highlight_start": 1,
                            "text": "        }"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "code": {
                  "code": "clippy::match_like_matches_macro",
                  "explanation": null
                },
                "level": "warning",
                "message": "match expression looks like `matches!` macro",
                "spans": [
                  {
                    "byte_end": 7917,
                    "byte_start": 7821,
                    "column_end": 10,
                    "column_start": 9,
                    "expansion": null,
                    "file_name": "src\\err.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 270,
                    "line_start": 267,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 21,
                        "highlight_start": 9,
                        "text": "        match self {"
                      },
                      {
                        "highlight_end": 50,
                        "highlight_start": 1,
                        "text": "            SendTimeoutError::Timeout(_) => true,"
                      },
                      {
                        "highlight_end": 24,
                        "highlight_start": 1,
                        "text": "            _ => false,"
                      },
                      {
                        "highlight_end": 10,
                        "highlight_start": 1,
                        "text": "        }"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmp_zwb0qyf/crossbeam-channel-0.5.15#crossbeam-channel@0.5.15",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp_zwb0qyf\\crossbeam-channel-0.5.15\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "crossbeam_channel",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp_zwb0qyf\\crossbeam-channel-0.5.15\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: match expression looks like `matches!` macro\n   --> src\\err.rs:275:9\n    |\n275 | /         match self {\n276 | |             SendTimeoutError::Disconnected(_) => true,\n277 | |             _ => false,\n278 | |         }\n    | |_________^ help: try: `matches!(self, SendTimeoutError::Disconnected(_))`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#match_like_matches_macro\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#match_like_matches_macro",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "try",
                    "rendered": null,
                    "spans": [
                      {
                        "byte_end": 8167,
                        "byte_start": 8066,
                        "column_end": 10,
                        "column_start": 9,
                        "expansion": null,
                        "file_name": "src\\err.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 278,
                        "line_start": 275,
                        "suggested_replacement": "matches!(self, SendTimeoutError::Disconnected(_))",
                        "suggestion_applicability": "MaybeIncorrect",
                        "text": [
                          {
                            "highlight_end": 21,
                            "highlight_start": 9,
                            "text": "        match self {"
                          },
                          {
                            "highlight_end": 55,
                            "highlight_start": 1,
                            "text": "            SendTimeoutError::Disconnected(_) => true,"
                          },
                          {
                            "highlight_end": 24,
                            "highlight_start": 1,
                            "text": "            _ => false,"
                          },
                          {
                            "highlight_end": 10,
                            "highlight_start": 1,
                            "text": "        }"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "code": {
                  "code": "clippy::match_like_matches_macro",
                  "explanation": null
                },
                "level": "warning",
                "message": "match expression looks like `matches!` macro",
                "spans": [
                  {
                    "byte_end": 8167,
                    "byte_start": 8066,
                    "column_end": 10,
                    "column_start": 9,
                    "expansion": null,
                    "file_name": "src\\err.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 278,
                    "line_start": 275,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 21,
                        "highlight_start": 9,
                        "text": "        match self {"
                      },
                      {
                        "highlight_end": 55,
                        "highlight_start": 1,
                        "text": "            SendTimeoutError::Disconnected(_) => true,"
                      },
                      {
                        "highlight_end": 24,
                        "highlight_start": 1,
                        "text": "            _ => false,"
                      },
                      {
                        "highlight_end": 10,
                        "highlight_start": 1,
                        "text": "        }"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmp_zwb0qyf/crossbeam-channel-0.5.15#crossbeam-channel@0.5.15",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp_zwb0qyf\\crossbeam-channel-0.5.15\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "crossbeam_channel",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp_zwb0qyf\\crossbeam-channel-0.5.15\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: match expression looks like `matches!` macro\n   --> src\\err.rs:312:9\n    |\n312 | /         match self {\n313 | |             TryRecvError::Empty => true,\n314 | |             _ => false,\n315 | |         }\n    | |_________^ help: try: `matches!(self, TryRecvError::Empty)`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#match_like_matches_macro\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#match_like_matches_macro",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "try",
                    "rendered": null,
                    "spans": [
                      {
                        "byte_end": 9152,
                        "byte_start": 9065,
                        "column_end": 10,
                        "column_start": 9,
                        "expansion": null,
                        "file_name": "src\\err.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 315,
                        "line_start": 312,
                        "suggested_replacement": "matches!(self, TryRecvError::Empty)",
                        "suggestion_applicability": "MaybeIncorrect",
                        "text": [
                          {
                            "highlight_end": 21,
                            "highlight_start": 9,
                            "text": "        match self {"
                          },
                          {
                            "highlight_end": 41,
                            "highlight_start": 1,
                            "text": "            TryRecvError::Empty => true,"
                          },
                          {
                            "highlight_end": 24,
                            "highlight_start": 1,
                            "text": "            _ => false,"
                          },
                          {
                            "highlight_end": 10,
                            "highlight_start": 1,
                            "text": "        }"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "code": {
                  "code": "clippy::match_like_matches_macro",
                  "explanation": null
                },
                "level": "warning",
                "message": "match expression looks like `matches!` macro",
                "spans": [
                  {
                    "byte_end": 9152,
                    "byte_start": 9065,
                    "column_end": 10,
                    "column_start": 9,
                    "expansion": null,
                    "file_name": "src\\err.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 315,
                    "line_start": 312,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 21,
                        "highlight_start": 9,
                        "text": "        match self {"
                      },
                      {
                        "highlight_end": 41,
                        "highlight_start": 1,
                        "text": "            TryRecvError::Empty => true,"
                      },
                      {
                        "highlight_end": 24,
                        "highlight_start": 1,
                        "text": "            _ => false,"
                      },
                      {
                        "highlight_end": 10,
                        "highlight_start": 1,
                        "text": "        }"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmp_zwb0qyf/crossbeam-channel-0.5.15#crossbeam-channel@0.5.15",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp_zwb0qyf\\crossbeam-channel-0.5.15\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "crossbeam_channel",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp_zwb0qyf\\crossbeam-channel-0.5.15\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: match expression looks like `matches!` macro\n   --> src\\err.rs:320:9\n    |\n320 | /         match self {\n321 | |             TryRecvError::Disconnected => true,\n322 | |             _ => false,\n323 | |         }\n    | |_________^ help: try: `matches!(self, TryRecvError::Disconnected)`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#match_like_matches_macro\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#match_like_matches_macro",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "try",
                    "rendered": null,
                    "spans": [
                      {
                        "byte_end": 9398,
                        "byte_start": 9304,
                        "column_end": 10,
                        "column_start": 9,
                        "expansion": null,
                        "file_name": "src\\err.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 323,
                        "line_start": 320,
                        "suggested_replacement": "matches!(self, TryRecvError::Disconnected)",
                        "suggestion_applicability": "MaybeIncorrect",
                        "text": [
                          {
                            "highlight_end": 21,
                            "highlight_start": 9,
                            "text": "        match self {"
                          },
                          {
                            "highlight_end": 48,
                            "highlight_start": 1,
                            "text": "            TryRecvError::Disconnected => true,"
                          },
                          {
                            "highlight_end": 24,
                            "highlight_start": 1,
                            "text": "            _ => false,"
                          },
                          {
                            "highlight_end": 10,
                            "highlight_start": 1,
                            "text": "        }"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "code": {
                  "code": "clippy::match_like_matches_macro",
                  "explanation": null
                },
                "level": "warning",
                "message": "match expression looks like `matches!` macro",
                "spans": [
                  {
                    "byte_end": 9398,
                    "byte_start": 9304,
                    "column_end": 10,
                    "column_start": 9,
                    "expansion": null,
                    "file_name": "src\\err.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 323,
                    "line_start": 320,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 21,
                        "highlight_start": 9,
                        "text": "        match self {"
                      },
                      {
                        "highlight_end": 48,
                        "highlight_start": 1,
                        "text": "            TryRecvError::Disconnected => true,"
                      },
                      {
                        "highlight_end": 24,
                        "highlight_start": 1,
                        "text": "            _ => false,"
                      },
                      {
                        "highlight_end": 10,
                        "highlight_start": 1,
                        "text": "        }"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmp_zwb0qyf/crossbeam-channel-0.5.15#crossbeam-channel@0.5.15",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp_zwb0qyf\\crossbeam-channel-0.5.15\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "crossbeam_channel",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp_zwb0qyf\\crossbeam-channel-0.5.15\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: match expression looks like `matches!` macro\n   --> src\\err.rs:349:9\n    |\n349 | /         match self {\n350 | |             RecvTimeoutError::Timeout => true,\n351 | |             _ => false,\n352 | |         }\n    | |_________^ help: try: `matches!(self, RecvTimeoutError::Timeout)`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#match_like_matches_macro\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#match_like_matches_macro",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "try",
                    "rendered": null,
                    "spans": [
                      {
                        "byte_end": 10189,
                        "byte_start": 10096,
                        "column_end": 10,
                        "column_start": 9,
                        "expansion": null,
                        "file_name": "src\\err.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 352,
                        "line_start": 349,
                        "suggested_replacement": "matches!(self, RecvTimeoutError::Timeout)",
                        "suggestion_applicability": "MaybeIncorrect",
                        "text": [
                          {
                            "highlight_end": 21,
                            "highlight_start": 9,
                            "text": "        match self {"
                          },
                          {
                            "highlight_end": 47,
                            "highlight_start": 1,
                            "text": "            RecvTimeoutError::Timeout => true,"
                          },
                          {
                            "highlight_end": 24,
                            "highlight_start": 1,
                            "text": "            _ => false,"
                          },
                          {
                            "highlight_end": 10,
                            "highlight_start": 1,
                            "text": "        }"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "code": {
                  "code": "clippy::match_like_matches_macro",
                  "explanation": null
                },
                "level": "warning",
                "message": "match expression looks like `matches!` macro",
                "spans": [
                  {
                    "byte_end": 10189,
                    "byte_start": 10096,
                    "column_end": 10,
                    "column_start": 9,
                    "expansion": null,
                    "file_name": "src\\err.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 352,
                    "line_start": 349,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 21,
                        "highlight_start": 9,
                        "text": "        match self {"
                      },
                      {
                        "highlight_end": 47,
                        "highlight_start": 1,
                        "text": "            RecvTimeoutError::Timeout => true,"
                      },
                      {
                        "highlight_end": 24,
                        "highlight_start": 1,
                        "text": "            _ => false,"
                      },
                      {
                        "highlight_end": 10,
                        "highlight_start": 1,
                        "text": "        }"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmp_zwb0qyf/crossbeam-channel-0.5.15#crossbeam-channel@0.5.15",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp_zwb0qyf\\crossbeam-channel-0.5.15\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "crossbeam_channel",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp_zwb0qyf\\crossbeam-channel-0.5.15\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: match expression looks like `matches!` macro\n   --> src\\err.rs:357:9\n    |\n357 | /         match self {\n358 | |             RecvTimeoutError::Disconnected => true,\n359 | |             _ => false,\n360 | |         }\n    | |_________^ help: try: `matches!(self, RecvTimeoutError::Disconnected)`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#match_like_matches_macro\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#match_like_matches_macro",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "try",
                    "rendered": null,
                    "spans": [
                      {
                        "byte_end": 10439,
                        "byte_start": 10341,
                        "column_end": 10,
                        "column_start": 9,
                        "expansion": null,
                        "file_name": "src\\err.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 360,
                        "line_start": 357,
                        "suggested_replacement": "matches!(self, RecvTimeoutError::Disconnected)",
                        "suggestion_applicability": "MaybeIncorrect",
                        "text": [
                          {
                            "highlight_end": 21,
                            "highlight_start": 9,
                            "text": "        match self {"
                          },
                          {
                            "highlight_end": 52,
                            "highlight_start": 1,
                            "text": "            RecvTimeoutError::Disconnected => true,"
                          },
                          {
                            "highlight_end": 24,
                            "highlight_start": 1,
                            "text": "            _ => false,"
                          },
                          {
                            "highlight_end": 10,
                            "highlight_start": 1,
                            "text": "        }"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "code": {
                  "code": "clippy::match_like_matches_macro",
                  "explanation": null
                },
                "level": "warning",
                "message": "match expression looks like `matches!` macro",
                "spans": [
                  {
                    "byte_end": 10439,
                    "byte_start": 10341,
                    "column_end": 10,
                    "column_start": 9,
                    "expansion": null,
                    "file_name": "src\\err.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 360,
                    "line_start": 357,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 21,
                        "highlight_start": 9,
                        "text": "        match self {"
                      },
                      {
                        "highlight_end": 52,
                        "highlight_start": 1,
                        "text": "            RecvTimeoutError::Disconnected => true,"
                      },
                      {
                        "highlight_end": 24,
                        "highlight_start": 1,
                        "text": "            _ => false,"
                      },
                      {
                        "highlight_end": 10,
                        "highlight_start": 1,
                        "text": "        }"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmp_zwb0qyf/crossbeam-channel-0.5.15#crossbeam-channel@0.5.15",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp_zwb0qyf\\crossbeam-channel-0.5.15\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "crossbeam_channel",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp_zwb0qyf\\crossbeam-channel-0.5.15\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: an implementation of `From` is preferred since it gives you `Into<_>` for free where the reverse isn't true\n  --> src\\select.rs:83:1\n   |\n83 | impl Into<usize> for Selected {\n   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: `impl From<Local> for Foreign` is allowed by the orphan rules, for more information see\n           https://doc.rust-lang.org/reference/items/implementations.html#trait-implementation-coherence\n   = help: replace the `Into` implementation with `From<select::Selected>`\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#from_over_into\n   = note: `#[warn(clippy::from_over_into)]` on by default\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "`impl From<Local> for Foreign` is allowed by the orphan rules, for more information see\nhttps://doc.rust-lang.org/reference/items/implementations.html#trait-implementation-coherence",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "replace the `Into` implementation with `From<select::Selected>`",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#from_over_into",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "note",
                    "message": "`#[warn(clippy::from_over_into)]` on by default",
                    "rendered": null,
                    "spans": []
                  }
                ],
                "code": {
                  "code": "clippy::from_over_into",
                  "explanation": null
                },
                "level": "warning",
                "message": "an implementation of `From` is preferred since it gives you `Into<_>` for free where the reverse isn't true",
                "spans": [
                  {
                    "byte_end": 2653,
                    "byte_start": 2624,
                    "column_end": 30,
                    "column_start": 1,
                    "expansion": null,
                    "file_name": "src\\select.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 83,
                    "line_start": 83,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 30,
                        "highlight_start": 1,
                        "text": "impl Into<usize> for Selected {"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-artifact",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmp_zwb0qyf/crossbeam-channel-0.5.15#crossbeam-channel@0.5.15",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp_zwb0qyf\\crossbeam-channel-0.5.15\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "crossbeam_channel",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp_zwb0qyf\\crossbeam-channel-0.5.15\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "default",
                "std"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp_zwb0qyf\\crossbeam-channel-0.5.15\\target\\debug\\deps\\libcrossbeam_channel-bdf07da5f9708ea6.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "build-finished",
              "success": true
            }
          ],
          "audit": {
            "database": {
              "advisory-count": 787,
              "last-commit": "7573f55ba337263f61167dbb0ea926cdc7c8eb5d",
              "last-updated": "2025-06-17T11:04:25+02:00"
            },
            "lockfile": {
              "dependency-count": 20
            },
            "settings": {
              "target_arch": [],
              "target_os": [],
              "severity": null,
              "ignore": [],
              "informational_warnings": [
                "unmaintained",
                "unsound",
                "notice"
              ]
            },
            "vulnerabilities": {
              "found": false,
              "count": 0,
              "list": []
            },
            "warnings": {}
          },
          "note": "Crate analysis performed with stable toolchain."
        },
        "crate_metadata": {
          "name": "crossbeam-channel",
          "version": "0.5.15",
          "description": "ALLOW: Positive community sentiment",
          "repository": "",
          "keywords": [],
          "categories": [],
          "readme": {
            "raw_markdown": "[](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/all.html \"show sidebar\")\n# Crate crossbeam_channelCopy item path\n[Settings](https://docs.rs/crossbeam-channel/latest/settings.html)\n[Help](https://docs.rs/crossbeam-channel/latest/help.html)\nSummary[Source](https://docs.rs/crossbeam-channel/latest/src/crossbeam_channel/lib.rs.html#1-378)\nExpand description\nMulti-producer multi-consumer channels for message passing.\nThis crate is an alternative to [`std::sync::mpsc`](https://doc.rust-lang.org/nightly/std/sync/mpsc/index.html \"mod std::sync::mpsc\") with more features and better performance.\n## [\u00a7](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#hello-world)Hello, world!\n```\nuse crossbeam_channel::unbounded;\n// Create a channel of unbounded capacity.\nlet (s, r) = unbounded();\n// Send a message into the channel.\ns.send(\"Hello, world!\").unwrap();\n// Receive the message from the channel.\nassert_eq!(r.recv(), Ok(\"Hello, world!\"));\n```\n\n## [\u00a7](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#channel-types)Channel types\nChannels can be created using two functions:\n  * [`bounded`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/fn.bounded.html \"fn crossbeam_channel::bounded\") creates a channel of bounded capacity, i.e. there is a limit to how many messages it can hold at a time.\n  * [`unbounded`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/fn.unbounded.html \"fn crossbeam_channel::unbounded\") creates a channel of unbounded capacity, i.e. it can hold any number of messages at a time.\n\n\nBoth functions return a [`Sender`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Sender.html \"struct crossbeam_channel::Sender\") and a [`Receiver`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Receiver.html \"struct crossbeam_channel::Receiver\"), which represent the two opposite sides of a channel.\nCreating a bounded channel:\n```\nuse crossbeam_channel::bounded;\n// Create a channel that can hold at most 5 messages at a time.\nlet (s, r) = bounded(5);\n// Can send only 5 messages without blocking.\nfor i in 0..5 {\n  s.send(i).unwrap();\n}\n// Another call to `send` would block because the channel is full.\n// s.send(5).unwrap();\n```\n\nCreating an unbounded channel:\n```\nuse crossbeam_channel::unbounded;\n// Create an unbounded channel.\nlet (s, r) = unbounded();\n// Can send any number of messages into the channel without blocking.\nfor i in 0..1000 {\n  s.send(i).unwrap();\n}\n```\n\nA special case is zero-capacity channel, which cannot hold any messages. Instead, send and receive operations must appear at the same time in order to pair up and pass the message over:\n```\nuse std::thread;\nuse crossbeam_channel::bounded;\n// Create a zero-capacity channel.\nlet (s, r) = bounded(0);\n// Sending blocks until a receive operation appears on the other side.\nthread::spawn(move || s.send(\"Hi!\").unwrap());\n// Receiving blocks until a send operation appears on the other side.\nassert_eq!(r.recv(), Ok(\"Hi!\"));\n```\n\n## [\u00a7](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#sharing-channels)Sharing channels\nSenders and receivers can be cloned and sent to other threads:\n```\nuse std::thread;\nuse crossbeam_channel::bounded;\nlet (s1, r1) = bounded(0);\nlet (s2, r2) = (s1.clone(), r1.clone());\n// Spawn a thread that receives a message and then sends one.\nthread::spawn(move || {\n  r2.recv().unwrap();\n  s2.send(2).unwrap();\n});\n// Send a message and then receive one.\ns1.send(1).unwrap();\nr1.recv().unwrap();\n```\n\nNote that cloning only creates a new handle to the same sending or receiving side. It does not create a separate stream of messages in any way:\n```\nuse crossbeam_channel::unbounded;\nlet (s1, r1) = unbounded();\nlet (s2, r2) = (s1.clone(), r1.clone());\nlet (s3, r3) = (s2.clone(), r2.clone());\ns1.send(10).unwrap();\ns2.send(20).unwrap();\ns3.send(30).unwrap();\nassert_eq!(r3.recv(), Ok(10));\nassert_eq!(r1.recv(), Ok(20));\nassert_eq!(r2.recv(), Ok(30));\n```\n\nIt\u2019s also possible to share senders and receivers by reference:\n```\nuse crossbeam_channel::bounded;\nuse crossbeam_utils::thread::scope;\nlet (s, r) = bounded(0);\nscope(|scope| {\n  // Spawn a thread that receives a message and then sends one.\n  scope.spawn(|_| {\n    r.recv().unwrap();\n    s.send(2).unwrap();\n  });\n  // Send a message and then receive one.\n  s.send(1).unwrap();\n  r.recv().unwrap();\n}).unwrap();\n```\n\n## [\u00a7](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#disconnection)Disconnection\nWhen all senders or all receivers associated with a channel get dropped, the channel becomes disconnected. No more messages can be sent, but any remaining messages can still be received. Send and receive operations on a disconnected channel never block.\n```\nuse crossbeam_channel::{unbounded, RecvError};\nlet (s, r) = unbounded();\ns.send(1).unwrap();\ns.send(2).unwrap();\ns.send(3).unwrap();\n// The only sender is dropped, disconnecting the channel.\ndrop(s);\n// The remaining messages can be received.\nassert_eq!(r.recv(), Ok(1));\nassert_eq!(r.recv(), Ok(2));\nassert_eq!(r.recv(), Ok(3));\n// There are no more messages in the channel.\nassert!(r.is_empty());\n// Note that calling `r.recv()` does not block.\n// Instead, `Err(RecvError)` is returned immediately.\nassert_eq!(r.recv(), Err(RecvError));\n```\n\n## [\u00a7](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#blocking-operations)Blocking operations\nSend and receive operations come in three flavors:\n  * Non-blocking (returns immediately with success or failure).\n  * Blocking (waits until the operation succeeds or the channel becomes disconnected).\n  * Blocking with a timeout (blocks only for a certain duration of time).\n\n\nA simple example showing the difference between non-blocking and blocking operations:\n```\nuse crossbeam_channel::{bounded, RecvError, TryRecvError};\nlet (s, r) = bounded(1);\n// Send a message into the channel.\ns.send(\"foo\").unwrap();\n// This call would block because the channel is full.\n// s.send(\"bar\").unwrap();\n// Receive the message.\nassert_eq!(r.recv(), Ok(\"foo\"));\n// This call would block because the channel is empty.\n// r.recv();\n// Try receiving a message without blocking.\nassert_eq!(r.try_recv(), Err(TryRecvError::Empty));\n// Disconnect the channel.\ndrop(s);\n// This call doesn't block because the channel is now disconnected.\nassert_eq!(r.recv(), Err(RecvError));\n```\n\n## [\u00a7](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#iteration)Iteration\nReceivers can be used as iterators. For example, method [`iter`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Receiver.html#method.iter \"method crossbeam_channel::Receiver::iter\") creates an iterator that receives messages until the channel becomes empty and disconnected. Note that iteration may block waiting for next message to arrive.\n```\nuse std::thread;\nuse crossbeam_channel::unbounded;\nlet (s, r) = unbounded();\nthread::spawn(move || {\n  s.send(1).unwrap();\n  s.send(2).unwrap();\n  s.send(3).unwrap();\n  drop(s); // Disconnect the channel.\n});\n// Collect all messages from the channel.\n// Note that the call to `collect` blocks until the sender is dropped.\nlet v: Vec<_> = r.iter().collect();\nassert_eq!(v, [1, 2, 3]);\n```\n\nA non-blocking iterator can be created using [`try_iter`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Receiver.html#method.try_iter \"method crossbeam_channel::Receiver::try_iter\"), which receives all available messages without blocking:\n```\nuse crossbeam_channel::unbounded;\nlet (s, r) = unbounded();\ns.send(1).unwrap();\ns.send(2).unwrap();\ns.send(3).unwrap();\n// No need to drop the sender.\n// Receive all messages currently in the channel.\nlet v: Vec<_> = r.try_iter().collect();\nassert_eq!(v, [1, 2, 3]);\n```\n\n## [\u00a7](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#selection)Selection\nThe [`select!`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/macro.select.html \"macro crossbeam_channel::select\") macro allows you to define a set of channel operations, wait until any one of them becomes ready, and finally execute it. If multiple operations are ready at the same time, a random one among them is selected.\nIt is also possible to define a `default` case that gets executed if none of the operations are ready, either right away or for a certain duration of time.\nAn operation is considered to be ready if it doesn\u2019t have to block. Note that it is ready even when it will simply return an error because the channel is disconnected.\nAn example of receiving a message from two channels:\n```\nuse std::thread;\nuse std::time::Duration;\nuse crossbeam_channel::{select, unbounded};\nlet (s1, r1) = unbounded();\nlet (s2, r2) = unbounded();\nthread::spawn(move || s1.send(10).unwrap());\nthread::spawn(move || s2.send(20).unwrap());\n// At most one of these two receive operations will be executed.\nselect! {\n  recv(r1) -> msg => assert_eq!(msg, Ok(10)),\n  recv(r2) -> msg => assert_eq!(msg, Ok(20)),\n  default(Duration::from_secs(1)) => println!(\"timed out\"),\n}\n```\n\nIf you need to select over a dynamically created list of channel operations, use [`Select`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Select.html \"struct crossbeam_channel::Select\") instead. The [`select!`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/macro.select.html \"macro crossbeam_channel::select\") macro is just a convenience wrapper around [`Select`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Select.html \"struct crossbeam_channel::Select\").\n## [\u00a7](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#extra-channels)Extra channels\nThree functions can create special kinds of channels, all of which return just a [`Receiver`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Receiver.html \"struct crossbeam_channel::Receiver\") handle:\n  * [`after`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/fn.after.html \"fn crossbeam_channel::after\") creates a channel that delivers a single message after a certain duration of time.\n  * [`tick`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/fn.tick.html \"fn crossbeam_channel::tick\") creates a channel that delivers messages periodically.\n  * [`never`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/fn.never.html \"fn crossbeam_channel::never\") creates a channel that never delivers messages.\n\n\nThese channels are very efficient because messages get lazily generated on receive operations.\nAn example that prints elapsed time every 50 milliseconds for the duration of 1 second:\n```\nuse std::time::{Duration, Instant};\nuse crossbeam_channel::{after, select, tick};\nlet start = Instant::now();\nlet ticker = tick(Duration::from_millis(50));\nlet timeout = after(Duration::from_secs(1));\nloop {\n  select! {\n    recv(ticker) -> _ => println!(\"elapsed: {:?}\", start.elapsed()),\n    recv(timeout) -> _ => break,\n  }\n}\n```\n\n## Macros[\u00a7](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#macros)\n\n[select](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/macro.select.html \"macro crossbeam_channel::select\")\n    Selects from a set of channel operations.\n\n[select_biased](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/macro.select_biased.html \"macro crossbeam_channel::select_biased\")\n    Selects from a set of channel operations.\n## Structs[\u00a7](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#structs)\n\n[IntoIter](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.IntoIter.html \"struct crossbeam_channel::IntoIter\")\n    A blocking iterator over messages in a channel.\n\n[Iter](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Iter.html \"struct crossbeam_channel::Iter\")\n    A blocking iterator over messages in a channel.\n\n[ReadyTimeoutError](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.ReadyTimeoutError.html \"struct crossbeam_channel::ReadyTimeoutError\")\n    An error returned from the [`ready_timeout`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Select.html#method.ready_timeout \"method crossbeam_channel::Select::ready_timeout\") method.\n\n[Receiver](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Receiver.html \"struct crossbeam_channel::Receiver\")\n    The receiving side of a channel.\n\n[RecvError](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.RecvError.html \"struct crossbeam_channel::RecvError\")\n    An error returned from the [`recv`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Receiver.html#method.recv \"method crossbeam_channel::Receiver::recv\") method.\n\n[Select](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Select.html \"struct crossbeam_channel::Select\")\n    Selects from a set of channel operations.\n\n[SelectTimeoutError](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.SelectTimeoutError.html \"struct crossbeam_channel::SelectTimeoutError\")\n    An error returned from the [`select_timeout`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Select.html#method.select_timeout \"method crossbeam_channel::Select::select_timeout\") method.\n\n[SelectedOperation](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.SelectedOperation.html \"struct crossbeam_channel::SelectedOperation\")\n    A selected operation that needs to be completed.\n\n[SendError](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.SendError.html \"struct crossbeam_channel::SendError\")\n    An error returned from the [`send`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Sender.html#method.send \"method crossbeam_channel::Sender::send\") method.\n\n[Sender](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Sender.html \"struct crossbeam_channel::Sender\")\n    The sending side of a channel.\n\n[TryIter](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.TryIter.html \"struct crossbeam_channel::TryIter\")\n    A non-blocking iterator over messages in a channel.\n\n[TryReadyError](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.TryReadyError.html \"struct crossbeam_channel::TryReadyError\")\n    An error returned from the [`try_ready`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Select.html#method.try_ready \"method crossbeam_channel::Select::try_ready\") method.\n\n[TrySelectError](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.TrySelectError.html \"struct crossbeam_channel::TrySelectError\")\n    An error returned from the [`try_select`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Select.html#method.try_select \"method crossbeam_channel::Select::try_select\") method.\n## Enums[\u00a7](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#enums)\n\n[RecvTimeoutError](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/enum.RecvTimeoutError.html \"enum crossbeam_channel::RecvTimeoutError\")\n    An error returned from the [`recv_timeout`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Receiver.html#method.recv_timeout \"method crossbeam_channel::Receiver::recv_timeout\") method.\n\n[SendTimeoutError](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/enum.SendTimeoutError.html \"enum crossbeam_channel::SendTimeoutError\")\n    An error returned from the [`send_timeout`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Sender.html#method.send_timeout \"method crossbeam_channel::Sender::send_timeout\") method.\n\n[TryRecvError](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/enum.TryRecvError.html \"enum crossbeam_channel::TryRecvError\")\n    An error returned from the [`try_recv`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Receiver.html#method.try_recv \"method crossbeam_channel::Receiver::try_recv\") method.\n\n[TrySendError](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/enum.TrySendError.html \"enum crossbeam_channel::TrySendError\")\n    An error returned from the [`try_send`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Sender.html#method.try_send \"method crossbeam_channel::Sender::try_send\") method.\n## Functions[\u00a7](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#functions)\n\n[after](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/fn.after.html \"fn crossbeam_channel::after\")\n    Creates a receiver that delivers a message after a certain duration of time.\n\n[at](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/fn.at.html \"fn crossbeam_channel::at\")\n    Creates a receiver that delivers a message at a certain instant in time.\n\n[bounded](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/fn.bounded.html \"fn crossbeam_channel::bounded\")\n    Creates a channel of bounded capacity.\n\n[never](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/fn.never.html \"fn crossbeam_channel::never\")\n    Creates a receiver that never delivers messages.\n\n[tick](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/fn.tick.html \"fn crossbeam_channel::tick\")\n    Creates a receiver that delivers messages periodically.\n\n[unbounded](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/fn.unbounded.html \"fn crossbeam_channel::unbounded\")\n    Creates a channel of unbounded capacity.\n",
            "markdown_with_citations": "[](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/all.html \"show sidebar\")\n# Crate crossbeam_channelCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nMulti-producer multi-consumer channels for message passing.\nThis crate is an alternative to `std::sync::mpsc`\u27e84\u27e9 with more features and better performance.\n## \u00a7\u27e85\u27e9Hello, world!\n```\nuse crossbeam_channel::unbounded;\n// Create a channel of unbounded capacity.\nlet (s, r) = unbounded();\n// Send a message into the channel.\ns.send(\"Hello, world!\").unwrap();\n// Receive the message from the channel.\nassert_eq!(r.recv(), Ok(\"Hello, world!\"));\n```\n\n## \u00a7\u27e86\u27e9Channel types\nChannels can be created using two functions:\n  * `bounded`\u27e87\u27e9 creates a channel of bounded capacity, i.e. there is a limit to how many messages it can hold at a time.\n  * `unbounded`\u27e88\u27e9 creates a channel of unbounded capacity, i.e. it can hold any number of messages at a time.\n\n\nBoth functions return a `Sender`\u27e89\u27e9 and a `Receiver`\u27e810\u27e9, which represent the two opposite sides of a channel.\nCreating a bounded channel:\n```\nuse crossbeam_channel::bounded;\n// Create a channel that can hold at most 5 messages at a time.\nlet (s, r) = bounded(5);\n// Can send only 5 messages without blocking.\nfor i in 0..5 {\n  s.send(i).unwrap();\n}\n// Another call to `send` would block because the channel is full.\n// s.send(5).unwrap();\n```\n\nCreating an unbounded channel:\n```\nuse crossbeam_channel::unbounded;\n// Create an unbounded channel.\nlet (s, r) = unbounded();\n// Can send any number of messages into the channel without blocking.\nfor i in 0..1000 {\n  s.send(i).unwrap();\n}\n```\n\nA special case is zero-capacity channel, which cannot hold any messages. Instead, send and receive operations must appear at the same time in order to pair up and pass the message over:\n```\nuse std::thread;\nuse crossbeam_channel::bounded;\n// Create a zero-capacity channel.\nlet (s, r) = bounded(0);\n// Sending blocks until a receive operation appears on the other side.\nthread::spawn(move || s.send(\"Hi!\").unwrap());\n// Receiving blocks until a send operation appears on the other side.\nassert_eq!(r.recv(), Ok(\"Hi!\"));\n```\n\n## \u00a7\u27e811\u27e9Sharing channels\nSenders and receivers can be cloned and sent to other threads:\n```\nuse std::thread;\nuse crossbeam_channel::bounded;\nlet (s1, r1) = bounded(0);\nlet (s2, r2) = (s1.clone(), r1.clone());\n// Spawn a thread that receives a message and then sends one.\nthread::spawn(move || {\n  r2.recv().unwrap();\n  s2.send(2).unwrap();\n});\n// Send a message and then receive one.\ns1.send(1).unwrap();\nr1.recv().unwrap();\n```\n\nNote that cloning only creates a new handle to the same sending or receiving side. It does not create a separate stream of messages in any way:\n```\nuse crossbeam_channel::unbounded;\nlet (s1, r1) = unbounded();\nlet (s2, r2) = (s1.clone(), r1.clone());\nlet (s3, r3) = (s2.clone(), r2.clone());\ns1.send(10).unwrap();\ns2.send(20).unwrap();\ns3.send(30).unwrap();\nassert_eq!(r3.recv(), Ok(10));\nassert_eq!(r1.recv(), Ok(20));\nassert_eq!(r2.recv(), Ok(30));\n```\n\nIt\u2019s also possible to share senders and receivers by reference:\n```\nuse crossbeam_channel::bounded;\nuse crossbeam_utils::thread::scope;\nlet (s, r) = bounded(0);\nscope(|scope| {\n  // Spawn a thread that receives a message and then sends one.\n  scope.spawn(|_| {\n    r.recv().unwrap();\n    s.send(2).unwrap();\n  });\n  // Send a message and then receive one.\n  s.send(1).unwrap();\n  r.recv().unwrap();\n}).unwrap();\n```\n\n## \u00a7\u27e812\u27e9Disconnection\nWhen all senders or all receivers associated with a channel get dropped, the channel becomes disconnected. No more messages can be sent, but any remaining messages can still be received. Send and receive operations on a disconnected channel never block.\n```\nuse crossbeam_channel::{unbounded, RecvError};\nlet (s, r) = unbounded();\ns.send(1).unwrap();\ns.send(2).unwrap();\ns.send(3).unwrap();\n// The only sender is dropped, disconnecting the channel.\ndrop(s);\n// The remaining messages can be received.\nassert_eq!(r.recv(), Ok(1));\nassert_eq!(r.recv(), Ok(2));\nassert_eq!(r.recv(), Ok(3));\n// There are no more messages in the channel.\nassert!(r.is_empty());\n// Note that calling `r.recv()` does not block.\n// Instead, `Err(RecvError)` is returned immediately.\nassert_eq!(r.recv(), Err(RecvError));\n```\n\n## \u00a7\u27e813\u27e9Blocking operations\nSend and receive operations come in three flavors:\n  * Non-blocking (returns immediately with success or failure).\n  * Blocking (waits until the operation succeeds or the channel becomes disconnected).\n  * Blocking with a timeout (blocks only for a certain duration of time).\n\n\nA simple example showing the difference between non-blocking and blocking operations:\n```\nuse crossbeam_channel::{bounded, RecvError, TryRecvError};\nlet (s, r) = bounded(1);\n// Send a message into the channel.\ns.send(\"foo\").unwrap();\n// This call would block because the channel is full.\n// s.send(\"bar\").unwrap();\n// Receive the message.\nassert_eq!(r.recv(), Ok(\"foo\"));\n// This call would block because the channel is empty.\n// r.recv();\n// Try receiving a message without blocking.\nassert_eq!(r.try_recv(), Err(TryRecvError::Empty));\n// Disconnect the channel.\ndrop(s);\n// This call doesn't block because the channel is now disconnected.\nassert_eq!(r.recv(), Err(RecvError));\n```\n\n## \u00a7\u27e814\u27e9Iteration\nReceivers can be used as iterators. For example, method `iter`\u27e815\u27e9 creates an iterator that receives messages until the channel becomes empty and disconnected. Note that iteration may block waiting for next message to arrive.\n```\nuse std::thread;\nuse crossbeam_channel::unbounded;\nlet (s, r) = unbounded();\nthread::spawn(move || {\n  s.send(1).unwrap();\n  s.send(2).unwrap();\n  s.send(3).unwrap();\n  drop(s); // Disconnect the channel.\n});\n// Collect all messages from the channel.\n// Note that the call to `collect` blocks until the sender is dropped.\nlet v: Vec<_> = r.iter().collect();\nassert_eq!(v, [1, 2, 3]);\n```\n\nA non-blocking iterator can be created using `try_iter`\u27e816\u27e9, which receives all available messages without blocking:\n```\nuse crossbeam_channel::unbounded;\nlet (s, r) = unbounded();\ns.send(1).unwrap();\ns.send(2).unwrap();\ns.send(3).unwrap();\n// No need to drop the sender.\n// Receive all messages currently in the channel.\nlet v: Vec<_> = r.try_iter().collect();\nassert_eq!(v, [1, 2, 3]);\n```\n\n## \u00a7\u27e817\u27e9Selection\nThe `select!`\u27e818\u27e9 macro allows you to define a set of channel operations, wait until any one of them becomes ready, and finally execute it. If multiple operations are ready at the same time, a random one among them is selected.\nIt is also possible to define a `default` case that gets executed if none of the operations are ready, either right away or for a certain duration of time.\nAn operation is considered to be ready if it doesn\u2019t have to block. Note that it is ready even when it will simply return an error because the channel is disconnected.\nAn example of receiving a message from two channels:\n```\nuse std::thread;\nuse std::time::Duration;\nuse crossbeam_channel::{select, unbounded};\nlet (s1, r1) = unbounded();\nlet (s2, r2) = unbounded();\nthread::spawn(move || s1.send(10).unwrap());\nthread::spawn(move || s2.send(20).unwrap());\n// At most one of these two receive operations will be executed.\nselect! {\n  recv(r1) -> msg => assert_eq!(msg, Ok(10)),\n  recv(r2) -> msg => assert_eq!(msg, Ok(20)),\n  default(Duration::from_secs(1)) => println!(\"timed out\"),\n}\n```\n\nIf you need to select over a dynamically created list of channel operations, use `Select`\u27e819\u27e9 instead. The `select!`\u27e818\u27e9 macro is just a convenience wrapper around `Select`\u27e819\u27e9.\n## \u00a7\u27e820\u27e9Extra channels\nThree functions can create special kinds of channels, all of which return just a `Receiver`\u27e810\u27e9 handle:\n  * `after`\u27e821\u27e9 creates a channel that delivers a single message after a certain duration of time.\n  * `tick`\u27e822\u27e9 creates a channel that delivers messages periodically.\n  * `never`\u27e823\u27e9 creates a channel that never delivers messages.\n\n\nThese channels are very efficient because messages get lazily generated on receive operations.\nAn example that prints elapsed time every 50 milliseconds for the duration of 1 second:\n```\nuse std::time::{Duration, Instant};\nuse crossbeam_channel::{after, select, tick};\nlet start = Instant::now();\nlet ticker = tick(Duration::from_millis(50));\nlet timeout = after(Duration::from_secs(1));\nloop {\n  select! {\n    recv(ticker) -> _ => println!(\"elapsed: {:?}\", start.elapsed()),\n    recv(timeout) -> _ => break,\n  }\n}\n```\n\n## Macros\u00a7\u27e824\u27e9\n\nselect\u27e818\u27e9\n    Selects from a set of channel operations.\n\nselect_biased\u27e825\u27e9\n    Selects from a set of channel operations.\n## Structs\u00a7\u27e826\u27e9\n\nIntoIter\u27e827\u27e9\n    A blocking iterator over messages in a channel.\n\nIter\u27e828\u27e9\n    A blocking iterator over messages in a channel.\n\nReadyTimeoutError\u27e829\u27e9\n    An error returned from the `ready_timeout`\u27e830\u27e9 method.\n\nReceiver\u27e810\u27e9\n    The receiving side of a channel.\n\nRecvError\u27e831\u27e9\n    An error returned from the `recv`\u27e832\u27e9 method.\n\nSelect\u27e819\u27e9\n    Selects from a set of channel operations.\n\nSelectTimeoutError\u27e833\u27e9\n    An error returned from the `select_timeout`\u27e834\u27e9 method.\n\nSelectedOperation\u27e835\u27e9\n    A selected operation that needs to be completed.\n\nSendError\u27e836\u27e9\n    An error returned from the `send`\u27e837\u27e9 method.\n\nSender\u27e89\u27e9\n    The sending side of a channel.\n\nTryIter\u27e838\u27e9\n    A non-blocking iterator over messages in a channel.\n\nTryReadyError\u27e839\u27e9\n    An error returned from the `try_ready`\u27e840\u27e9 method.\n\nTrySelectError\u27e841\u27e9\n    An error returned from the `try_select`\u27e842\u27e9 method.\n## Enums\u00a7\u27e843\u27e9\n\nRecvTimeoutError\u27e844\u27e9\n    An error returned from the `recv_timeout`\u27e845\u27e9 method.\n\nSendTimeoutError\u27e846\u27e9\n    An error returned from the `send_timeout`\u27e847\u27e9 method.\n\nTryRecvError\u27e848\u27e9\n    An error returned from the `try_recv`\u27e849\u27e9 method.\n\nTrySendError\u27e850\u27e9\n    An error returned from the `try_send`\u27e851\u27e9 method.\n## Functions\u00a7\u27e852\u27e9\n\nafter\u27e821\u27e9\n    Creates a receiver that delivers a message after a certain duration of time.\n\nat\u27e853\u27e9\n    Creates a receiver that delivers a message at a certain instant in time.\n\nbounded\u27e87\u27e9\n    Creates a channel of bounded capacity.\n\nnever\u27e823\u27e9\n    Creates a receiver that never delivers messages.\n\ntick\u27e822\u27e9\n    Creates a receiver that delivers messages periodically.\n\nunbounded\u27e88\u27e9\n    Creates a channel of unbounded capacity.\n",
            "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/crossbeam-channel/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/crossbeam-channel/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/crossbeam-channel/latest/src/crossbeam_channel/lib.rs.html#1-378: Source\n\u27e84\u27e9 https://doc.rust-lang.org/nightly/std/sync/mpsc/index.html: mod std::sync::mpsc - `std::sync::mpsc`\n\u27e85\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#hello-world: \u00a7\n\u27e86\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#channel-types: \u00a7\n\u27e87\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/fn.bounded.html: fn crossbeam_channel::bounded - `bounded`\n\u27e88\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/fn.unbounded.html: fn crossbeam_channel::unbounded - `unbounded`\n\u27e89\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Sender.html: struct crossbeam_channel::Sender - `Sender`\n\u27e810\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Receiver.html: struct crossbeam_channel::Receiver - `Receiver`\n\u27e811\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#sharing-channels: \u00a7\n\u27e812\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#disconnection: \u00a7\n\u27e813\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#blocking-operations: \u00a7\n\u27e814\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#iteration: \u00a7\n\u27e815\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Receiver.html#method.iter: method crossbeam_channel::Receiver::iter - `iter`\n\u27e816\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Receiver.html#method.try_iter: method crossbeam_channel::Receiver::try_iter - `try_iter`\n\u27e817\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#selection: \u00a7\n\u27e818\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/macro.select.html: macro crossbeam_channel::select - `select!`\n\u27e819\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Select.html: struct crossbeam_channel::Select - `Select`\n\u27e820\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#extra-channels: \u00a7\n\u27e821\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/fn.after.html: fn crossbeam_channel::after - `after`\n\u27e822\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/fn.tick.html: fn crossbeam_channel::tick - `tick`\n\u27e823\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/fn.never.html: fn crossbeam_channel::never - `never`\n\u27e824\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#macros: \u00a7\n\u27e825\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/macro.select_biased.html: macro crossbeam_channel::select_biased - select_biased\n\u27e826\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#structs: \u00a7\n\u27e827\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.IntoIter.html: struct crossbeam_channel::IntoIter - IntoIter\n\u27e828\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Iter.html: struct crossbeam_channel::Iter - Iter\n\u27e829\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.ReadyTimeoutError.html: struct crossbeam_channel::ReadyTimeoutError - ReadyTimeoutError\n\u27e830\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Select.html#method.ready_timeout: method crossbeam_channel::Select::ready_timeout - `ready_timeout`\n\u27e831\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.RecvError.html: struct crossbeam_channel::RecvError - RecvError\n\u27e832\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Receiver.html#method.recv: method crossbeam_channel::Receiver::recv - `recv`\n\u27e833\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.SelectTimeoutError.html: struct crossbeam_channel::SelectTimeoutError - SelectTimeoutError\n\u27e834\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Select.html#method.select_timeout: method crossbeam_channel::Select::select_timeout - `select_timeout`\n\u27e835\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.SelectedOperation.html: struct crossbeam_channel::SelectedOperation - SelectedOperation\n\u27e836\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.SendError.html: struct crossbeam_channel::SendError - SendError\n\u27e837\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Sender.html#method.send: method crossbeam_channel::Sender::send - `send`\n\u27e838\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.TryIter.html: struct crossbeam_channel::TryIter - TryIter\n\u27e839\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.TryReadyError.html: struct crossbeam_channel::TryReadyError - TryReadyError\n\u27e840\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Select.html#method.try_ready: method crossbeam_channel::Select::try_ready - `try_ready`\n\u27e841\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.TrySelectError.html: struct crossbeam_channel::TrySelectError - TrySelectError\n\u27e842\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Select.html#method.try_select: method crossbeam_channel::Select::try_select - `try_select`\n\u27e843\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#enums: \u00a7\n\u27e844\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/enum.RecvTimeoutError.html: enum crossbeam_channel::RecvTimeoutError - RecvTimeoutError\n\u27e845\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Receiver.html#method.recv_timeout: method crossbeam_channel::Receiver::recv_timeout - `recv_timeout`\n\u27e846\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/enum.SendTimeoutError.html: enum crossbeam_channel::SendTimeoutError - SendTimeoutError\n\u27e847\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Sender.html#method.send_timeout: method crossbeam_channel::Sender::send_timeout - `send_timeout`\n\u27e848\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/enum.TryRecvError.html: enum crossbeam_channel::TryRecvError - TryRecvError\n\u27e849\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Receiver.html#method.try_recv: method crossbeam_channel::Receiver::try_recv - `try_recv`\n\u27e850\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/enum.TrySendError.html: enum crossbeam_channel::TrySendError - TrySendError\n\u27e851\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Sender.html#method.try_send: method crossbeam_channel::Sender::try_send - `try_send`\n\u27e852\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#functions: \u00a7\n\u27e853\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/fn.at.html: fn crossbeam_channel::at - at\n",
            "fit_markdown": "",
            "fit_html": ""
          },
          "downloads": 0,
          "github_stars": 0,
          "dependencies": [],
          "features": {},
          "code_snippets": [],
          "readme_sections": {},
          "librs_downloads": null,
          "source": "crates.io",
          "enhanced_scraping": {},
          "enhanced_features": [],
          "enhanced_dependencies": []
        },
        "enriched_crate": {
          "name": "crossbeam-channel",
          "version": "0.5.15",
          "description": "ALLOW: Positive community sentiment",
          "repository": "",
          "keywords": [],
          "categories": [],
          "readme": {
            "raw_markdown": "[](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/all.html \"show sidebar\")\n# Crate crossbeam_channelCopy item path\n[Settings](https://docs.rs/crossbeam-channel/latest/settings.html)\n[Help](https://docs.rs/crossbeam-channel/latest/help.html)\nSummary[Source](https://docs.rs/crossbeam-channel/latest/src/crossbeam_channel/lib.rs.html#1-378)\nExpand description\nMulti-producer multi-consumer channels for message passing.\nThis crate is an alternative to [`std::sync::mpsc`](https://doc.rust-lang.org/nightly/std/sync/mpsc/index.html \"mod std::sync::mpsc\") with more features and better performance.\n## [\u00a7](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#hello-world)Hello, world!\n```\nuse crossbeam_channel::unbounded;\n// Create a channel of unbounded capacity.\nlet (s, r) = unbounded();\n// Send a message into the channel.\ns.send(\"Hello, world!\").unwrap();\n// Receive the message from the channel.\nassert_eq!(r.recv(), Ok(\"Hello, world!\"));\n```\n\n## [\u00a7](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#channel-types)Channel types\nChannels can be created using two functions:\n  * [`bounded`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/fn.bounded.html \"fn crossbeam_channel::bounded\") creates a channel of bounded capacity, i.e. there is a limit to how many messages it can hold at a time.\n  * [`unbounded`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/fn.unbounded.html \"fn crossbeam_channel::unbounded\") creates a channel of unbounded capacity, i.e. it can hold any number of messages at a time.\n\n\nBoth functions return a [`Sender`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Sender.html \"struct crossbeam_channel::Sender\") and a [`Receiver`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Receiver.html \"struct crossbeam_channel::Receiver\"), which represent the two opposite sides of a channel.\nCreating a bounded channel:\n```\nuse crossbeam_channel::bounded;\n// Create a channel that can hold at most 5 messages at a time.\nlet (s, r) = bounded(5);\n// Can send only 5 messages without blocking.\nfor i in 0..5 {\n  s.send(i).unwrap();\n}\n// Another call to `send` would block because the channel is full.\n// s.send(5).unwrap();\n```\n\nCreating an unbounded channel:\n```\nuse crossbeam_channel::unbounded;\n// Create an unbounded channel.\nlet (s, r) = unbounded();\n// Can send any number of messages into the channel without blocking.\nfor i in 0..1000 {\n  s.send(i).unwrap();\n}\n```\n\nA special case is zero-capacity channel, which cannot hold any messages. Instead, send and receive operations must appear at the same time in order to pair up and pass the message over:\n```\nuse std::thread;\nuse crossbeam_channel::bounded;\n// Create a zero-capacity channel.\nlet (s, r) = bounded(0);\n// Sending blocks until a receive operation appears on the other side.\nthread::spawn(move || s.send(\"Hi!\").unwrap());\n// Receiving blocks until a send operation appears on the other side.\nassert_eq!(r.recv(), Ok(\"Hi!\"));\n```\n\n## [\u00a7](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#sharing-channels)Sharing channels\nSenders and receivers can be cloned and sent to other threads:\n```\nuse std::thread;\nuse crossbeam_channel::bounded;\nlet (s1, r1) = bounded(0);\nlet (s2, r2) = (s1.clone(), r1.clone());\n// Spawn a thread that receives a message and then sends one.\nthread::spawn(move || {\n  r2.recv().unwrap();\n  s2.send(2).unwrap();\n});\n// Send a message and then receive one.\ns1.send(1).unwrap();\nr1.recv().unwrap();\n```\n\nNote that cloning only creates a new handle to the same sending or receiving side. It does not create a separate stream of messages in any way:\n```\nuse crossbeam_channel::unbounded;\nlet (s1, r1) = unbounded();\nlet (s2, r2) = (s1.clone(), r1.clone());\nlet (s3, r3) = (s2.clone(), r2.clone());\ns1.send(10).unwrap();\ns2.send(20).unwrap();\ns3.send(30).unwrap();\nassert_eq!(r3.recv(), Ok(10));\nassert_eq!(r1.recv(), Ok(20));\nassert_eq!(r2.recv(), Ok(30));\n```\n\nIt\u2019s also possible to share senders and receivers by reference:\n```\nuse crossbeam_channel::bounded;\nuse crossbeam_utils::thread::scope;\nlet (s, r) = bounded(0);\nscope(|scope| {\n  // Spawn a thread that receives a message and then sends one.\n  scope.spawn(|_| {\n    r.recv().unwrap();\n    s.send(2).unwrap();\n  });\n  // Send a message and then receive one.\n  s.send(1).unwrap();\n  r.recv().unwrap();\n}).unwrap();\n```\n\n## [\u00a7](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#disconnection)Disconnection\nWhen all senders or all receivers associated with a channel get dropped, the channel becomes disconnected. No more messages can be sent, but any remaining messages can still be received. Send and receive operations on a disconnected channel never block.\n```\nuse crossbeam_channel::{unbounded, RecvError};\nlet (s, r) = unbounded();\ns.send(1).unwrap();\ns.send(2).unwrap();\ns.send(3).unwrap();\n// The only sender is dropped, disconnecting the channel.\ndrop(s);\n// The remaining messages can be received.\nassert_eq!(r.recv(), Ok(1));\nassert_eq!(r.recv(), Ok(2));\nassert_eq!(r.recv(), Ok(3));\n// There are no more messages in the channel.\nassert!(r.is_empty());\n// Note that calling `r.recv()` does not block.\n// Instead, `Err(RecvError)` is returned immediately.\nassert_eq!(r.recv(), Err(RecvError));\n```\n\n## [\u00a7](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#blocking-operations)Blocking operations\nSend and receive operations come in three flavors:\n  * Non-blocking (returns immediately with success or failure).\n  * Blocking (waits until the operation succeeds or the channel becomes disconnected).\n  * Blocking with a timeout (blocks only for a certain duration of time).\n\n\nA simple example showing the difference between non-blocking and blocking operations:\n```\nuse crossbeam_channel::{bounded, RecvError, TryRecvError};\nlet (s, r) = bounded(1);\n// Send a message into the channel.\ns.send(\"foo\").unwrap();\n// This call would block because the channel is full.\n// s.send(\"bar\").unwrap();\n// Receive the message.\nassert_eq!(r.recv(), Ok(\"foo\"));\n// This call would block because the channel is empty.\n// r.recv();\n// Try receiving a message without blocking.\nassert_eq!(r.try_recv(), Err(TryRecvError::Empty));\n// Disconnect the channel.\ndrop(s);\n// This call doesn't block because the channel is now disconnected.\nassert_eq!(r.recv(), Err(RecvError));\n```\n\n## [\u00a7](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#iteration)Iteration\nReceivers can be used as iterators. For example, method [`iter`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Receiver.html#method.iter \"method crossbeam_channel::Receiver::iter\") creates an iterator that receives messages until the channel becomes empty and disconnected. Note that iteration may block waiting for next message to arrive.\n```\nuse std::thread;\nuse crossbeam_channel::unbounded;\nlet (s, r) = unbounded();\nthread::spawn(move || {\n  s.send(1).unwrap();\n  s.send(2).unwrap();\n  s.send(3).unwrap();\n  drop(s); // Disconnect the channel.\n});\n// Collect all messages from the channel.\n// Note that the call to `collect` blocks until the sender is dropped.\nlet v: Vec<_> = r.iter().collect();\nassert_eq!(v, [1, 2, 3]);\n```\n\nA non-blocking iterator can be created using [`try_iter`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Receiver.html#method.try_iter \"method crossbeam_channel::Receiver::try_iter\"), which receives all available messages without blocking:\n```\nuse crossbeam_channel::unbounded;\nlet (s, r) = unbounded();\ns.send(1).unwrap();\ns.send(2).unwrap();\ns.send(3).unwrap();\n// No need to drop the sender.\n// Receive all messages currently in the channel.\nlet v: Vec<_> = r.try_iter().collect();\nassert_eq!(v, [1, 2, 3]);\n```\n\n## [\u00a7](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#selection)Selection\nThe [`select!`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/macro.select.html \"macro crossbeam_channel::select\") macro allows you to define a set of channel operations, wait until any one of them becomes ready, and finally execute it. If multiple operations are ready at the same time, a random one among them is selected.\nIt is also possible to define a `default` case that gets executed if none of the operations are ready, either right away or for a certain duration of time.\nAn operation is considered to be ready if it doesn\u2019t have to block. Note that it is ready even when it will simply return an error because the channel is disconnected.\nAn example of receiving a message from two channels:\n```\nuse std::thread;\nuse std::time::Duration;\nuse crossbeam_channel::{select, unbounded};\nlet (s1, r1) = unbounded();\nlet (s2, r2) = unbounded();\nthread::spawn(move || s1.send(10).unwrap());\nthread::spawn(move || s2.send(20).unwrap());\n// At most one of these two receive operations will be executed.\nselect! {\n  recv(r1) -> msg => assert_eq!(msg, Ok(10)),\n  recv(r2) -> msg => assert_eq!(msg, Ok(20)),\n  default(Duration::from_secs(1)) => println!(\"timed out\"),\n}\n```\n\nIf you need to select over a dynamically created list of channel operations, use [`Select`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Select.html \"struct crossbeam_channel::Select\") instead. The [`select!`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/macro.select.html \"macro crossbeam_channel::select\") macro is just a convenience wrapper around [`Select`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Select.html \"struct crossbeam_channel::Select\").\n## [\u00a7](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#extra-channels)Extra channels\nThree functions can create special kinds of channels, all of which return just a [`Receiver`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Receiver.html \"struct crossbeam_channel::Receiver\") handle:\n  * [`after`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/fn.after.html \"fn crossbeam_channel::after\") creates a channel that delivers a single message after a certain duration of time.\n  * [`tick`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/fn.tick.html \"fn crossbeam_channel::tick\") creates a channel that delivers messages periodically.\n  * [`never`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/fn.never.html \"fn crossbeam_channel::never\") creates a channel that never delivers messages.\n\n\nThese channels are very efficient because messages get lazily generated on receive operations.\nAn example that prints elapsed time every 50 milliseconds for the duration of 1 second:\n```\nuse std::time::{Duration, Instant};\nuse crossbeam_channel::{after, select, tick};\nlet start = Instant::now();\nlet ticker = tick(Duration::from_millis(50));\nlet timeout = after(Duration::from_secs(1));\nloop {\n  select! {\n    recv(ticker) -> _ => println!(\"elapsed: {:?}\", start.elapsed()),\n    recv(timeout) -> _ => break,\n  }\n}\n```\n\n## Macros[\u00a7](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#macros)\n\n[select](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/macro.select.html \"macro crossbeam_channel::select\")\n    Selects from a set of channel operations.\n\n[select_biased](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/macro.select_biased.html \"macro crossbeam_channel::select_biased\")\n    Selects from a set of channel operations.\n## Structs[\u00a7](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#structs)\n\n[IntoIter](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.IntoIter.html \"struct crossbeam_channel::IntoIter\")\n    A blocking iterator over messages in a channel.\n\n[Iter](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Iter.html \"struct crossbeam_channel::Iter\")\n    A blocking iterator over messages in a channel.\n\n[ReadyTimeoutError](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.ReadyTimeoutError.html \"struct crossbeam_channel::ReadyTimeoutError\")\n    An error returned from the [`ready_timeout`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Select.html#method.ready_timeout \"method crossbeam_channel::Select::ready_timeout\") method.\n\n[Receiver](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Receiver.html \"struct crossbeam_channel::Receiver\")\n    The receiving side of a channel.\n\n[RecvError](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.RecvError.html \"struct crossbeam_channel::RecvError\")\n    An error returned from the [`recv`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Receiver.html#method.recv \"method crossbeam_channel::Receiver::recv\") method.\n\n[Select](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Select.html \"struct crossbeam_channel::Select\")\n    Selects from a set of channel operations.\n\n[SelectTimeoutError](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.SelectTimeoutError.html \"struct crossbeam_channel::SelectTimeoutError\")\n    An error returned from the [`select_timeout`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Select.html#method.select_timeout \"method crossbeam_channel::Select::select_timeout\") method.\n\n[SelectedOperation](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.SelectedOperation.html \"struct crossbeam_channel::SelectedOperation\")\n    A selected operation that needs to be completed.\n\n[SendError](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.SendError.html \"struct crossbeam_channel::SendError\")\n    An error returned from the [`send`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Sender.html#method.send \"method crossbeam_channel::Sender::send\") method.\n\n[Sender](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Sender.html \"struct crossbeam_channel::Sender\")\n    The sending side of a channel.\n\n[TryIter](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.TryIter.html \"struct crossbeam_channel::TryIter\")\n    A non-blocking iterator over messages in a channel.\n\n[TryReadyError](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.TryReadyError.html \"struct crossbeam_channel::TryReadyError\")\n    An error returned from the [`try_ready`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Select.html#method.try_ready \"method crossbeam_channel::Select::try_ready\") method.\n\n[TrySelectError](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.TrySelectError.html \"struct crossbeam_channel::TrySelectError\")\n    An error returned from the [`try_select`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Select.html#method.try_select \"method crossbeam_channel::Select::try_select\") method.\n## Enums[\u00a7](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#enums)\n\n[RecvTimeoutError](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/enum.RecvTimeoutError.html \"enum crossbeam_channel::RecvTimeoutError\")\n    An error returned from the [`recv_timeout`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Receiver.html#method.recv_timeout \"method crossbeam_channel::Receiver::recv_timeout\") method.\n\n[SendTimeoutError](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/enum.SendTimeoutError.html \"enum crossbeam_channel::SendTimeoutError\")\n    An error returned from the [`send_timeout`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Sender.html#method.send_timeout \"method crossbeam_channel::Sender::send_timeout\") method.\n\n[TryRecvError](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/enum.TryRecvError.html \"enum crossbeam_channel::TryRecvError\")\n    An error returned from the [`try_recv`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Receiver.html#method.try_recv \"method crossbeam_channel::Receiver::try_recv\") method.\n\n[TrySendError](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/enum.TrySendError.html \"enum crossbeam_channel::TrySendError\")\n    An error returned from the [`try_send`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Sender.html#method.try_send \"method crossbeam_channel::Sender::try_send\") method.\n## Functions[\u00a7](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#functions)\n\n[after](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/fn.after.html \"fn crossbeam_channel::after\")\n    Creates a receiver that delivers a message after a certain duration of time.\n\n[at](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/fn.at.html \"fn crossbeam_channel::at\")\n    Creates a receiver that delivers a message at a certain instant in time.\n\n[bounded](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/fn.bounded.html \"fn crossbeam_channel::bounded\")\n    Creates a channel of bounded capacity.\n\n[never](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/fn.never.html \"fn crossbeam_channel::never\")\n    Creates a receiver that never delivers messages.\n\n[tick](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/fn.tick.html \"fn crossbeam_channel::tick\")\n    Creates a receiver that delivers messages periodically.\n\n[unbounded](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/fn.unbounded.html \"fn crossbeam_channel::unbounded\")\n    Creates a channel of unbounded capacity.\n",
            "markdown_with_citations": "[](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/all.html \"show sidebar\")\n# Crate crossbeam_channelCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nMulti-producer multi-consumer channels for message passing.\nThis crate is an alternative to `std::sync::mpsc`\u27e84\u27e9 with more features and better performance.\n## \u00a7\u27e85\u27e9Hello, world!\n```\nuse crossbeam_channel::unbounded;\n// Create a channel of unbounded capacity.\nlet (s, r) = unbounded();\n// Send a message into the channel.\ns.send(\"Hello, world!\").unwrap();\n// Receive the message from the channel.\nassert_eq!(r.recv(), Ok(\"Hello, world!\"));\n```\n\n## \u00a7\u27e86\u27e9Channel types\nChannels can be created using two functions:\n  * `bounded`\u27e87\u27e9 creates a channel of bounded capacity, i.e. there is a limit to how many messages it can hold at a time.\n  * `unbounded`\u27e88\u27e9 creates a channel of unbounded capacity, i.e. it can hold any number of messages at a time.\n\n\nBoth functions return a `Sender`\u27e89\u27e9 and a `Receiver`\u27e810\u27e9, which represent the two opposite sides of a channel.\nCreating a bounded channel:\n```\nuse crossbeam_channel::bounded;\n// Create a channel that can hold at most 5 messages at a time.\nlet (s, r) = bounded(5);\n// Can send only 5 messages without blocking.\nfor i in 0..5 {\n  s.send(i).unwrap();\n}\n// Another call to `send` would block because the channel is full.\n// s.send(5).unwrap();\n```\n\nCreating an unbounded channel:\n```\nuse crossbeam_channel::unbounded;\n// Create an unbounded channel.\nlet (s, r) = unbounded();\n// Can send any number of messages into the channel without blocking.\nfor i in 0..1000 {\n  s.send(i).unwrap();\n}\n```\n\nA special case is zero-capacity channel, which cannot hold any messages. Instead, send and receive operations must appear at the same time in order to pair up and pass the message over:\n```\nuse std::thread;\nuse crossbeam_channel::bounded;\n// Create a zero-capacity channel.\nlet (s, r) = bounded(0);\n// Sending blocks until a receive operation appears on the other side.\nthread::spawn(move || s.send(\"Hi!\").unwrap());\n// Receiving blocks until a send operation appears on the other side.\nassert_eq!(r.recv(), Ok(\"Hi!\"));\n```\n\n## \u00a7\u27e811\u27e9Sharing channels\nSenders and receivers can be cloned and sent to other threads:\n```\nuse std::thread;\nuse crossbeam_channel::bounded;\nlet (s1, r1) = bounded(0);\nlet (s2, r2) = (s1.clone(), r1.clone());\n// Spawn a thread that receives a message and then sends one.\nthread::spawn(move || {\n  r2.recv().unwrap();\n  s2.send(2).unwrap();\n});\n// Send a message and then receive one.\ns1.send(1).unwrap();\nr1.recv().unwrap();\n```\n\nNote that cloning only creates a new handle to the same sending or receiving side. It does not create a separate stream of messages in any way:\n```\nuse crossbeam_channel::unbounded;\nlet (s1, r1) = unbounded();\nlet (s2, r2) = (s1.clone(), r1.clone());\nlet (s3, r3) = (s2.clone(), r2.clone());\ns1.send(10).unwrap();\ns2.send(20).unwrap();\ns3.send(30).unwrap();\nassert_eq!(r3.recv(), Ok(10));\nassert_eq!(r1.recv(), Ok(20));\nassert_eq!(r2.recv(), Ok(30));\n```\n\nIt\u2019s also possible to share senders and receivers by reference:\n```\nuse crossbeam_channel::bounded;\nuse crossbeam_utils::thread::scope;\nlet (s, r) = bounded(0);\nscope(|scope| {\n  // Spawn a thread that receives a message and then sends one.\n  scope.spawn(|_| {\n    r.recv().unwrap();\n    s.send(2).unwrap();\n  });\n  // Send a message and then receive one.\n  s.send(1).unwrap();\n  r.recv().unwrap();\n}).unwrap();\n```\n\n## \u00a7\u27e812\u27e9Disconnection\nWhen all senders or all receivers associated with a channel get dropped, the channel becomes disconnected. No more messages can be sent, but any remaining messages can still be received. Send and receive operations on a disconnected channel never block.\n```\nuse crossbeam_channel::{unbounded, RecvError};\nlet (s, r) = unbounded();\ns.send(1).unwrap();\ns.send(2).unwrap();\ns.send(3).unwrap();\n// The only sender is dropped, disconnecting the channel.\ndrop(s);\n// The remaining messages can be received.\nassert_eq!(r.recv(), Ok(1));\nassert_eq!(r.recv(), Ok(2));\nassert_eq!(r.recv(), Ok(3));\n// There are no more messages in the channel.\nassert!(r.is_empty());\n// Note that calling `r.recv()` does not block.\n// Instead, `Err(RecvError)` is returned immediately.\nassert_eq!(r.recv(), Err(RecvError));\n```\n\n## \u00a7\u27e813\u27e9Blocking operations\nSend and receive operations come in three flavors:\n  * Non-blocking (returns immediately with success or failure).\n  * Blocking (waits until the operation succeeds or the channel becomes disconnected).\n  * Blocking with a timeout (blocks only for a certain duration of time).\n\n\nA simple example showing the difference between non-blocking and blocking operations:\n```\nuse crossbeam_channel::{bounded, RecvError, TryRecvError};\nlet (s, r) = bounded(1);\n// Send a message into the channel.\ns.send(\"foo\").unwrap();\n// This call would block because the channel is full.\n// s.send(\"bar\").unwrap();\n// Receive the message.\nassert_eq!(r.recv(), Ok(\"foo\"));\n// This call would block because the channel is empty.\n// r.recv();\n// Try receiving a message without blocking.\nassert_eq!(r.try_recv(), Err(TryRecvError::Empty));\n// Disconnect the channel.\ndrop(s);\n// This call doesn't block because the channel is now disconnected.\nassert_eq!(r.recv(), Err(RecvError));\n```\n\n## \u00a7\u27e814\u27e9Iteration\nReceivers can be used as iterators. For example, method `iter`\u27e815\u27e9 creates an iterator that receives messages until the channel becomes empty and disconnected. Note that iteration may block waiting for next message to arrive.\n```\nuse std::thread;\nuse crossbeam_channel::unbounded;\nlet (s, r) = unbounded();\nthread::spawn(move || {\n  s.send(1).unwrap();\n  s.send(2).unwrap();\n  s.send(3).unwrap();\n  drop(s); // Disconnect the channel.\n});\n// Collect all messages from the channel.\n// Note that the call to `collect` blocks until the sender is dropped.\nlet v: Vec<_> = r.iter().collect();\nassert_eq!(v, [1, 2, 3]);\n```\n\nA non-blocking iterator can be created using `try_iter`\u27e816\u27e9, which receives all available messages without blocking:\n```\nuse crossbeam_channel::unbounded;\nlet (s, r) = unbounded();\ns.send(1).unwrap();\ns.send(2).unwrap();\ns.send(3).unwrap();\n// No need to drop the sender.\n// Receive all messages currently in the channel.\nlet v: Vec<_> = r.try_iter().collect();\nassert_eq!(v, [1, 2, 3]);\n```\n\n## \u00a7\u27e817\u27e9Selection\nThe `select!`\u27e818\u27e9 macro allows you to define a set of channel operations, wait until any one of them becomes ready, and finally execute it. If multiple operations are ready at the same time, a random one among them is selected.\nIt is also possible to define a `default` case that gets executed if none of the operations are ready, either right away or for a certain duration of time.\nAn operation is considered to be ready if it doesn\u2019t have to block. Note that it is ready even when it will simply return an error because the channel is disconnected.\nAn example of receiving a message from two channels:\n```\nuse std::thread;\nuse std::time::Duration;\nuse crossbeam_channel::{select, unbounded};\nlet (s1, r1) = unbounded();\nlet (s2, r2) = unbounded();\nthread::spawn(move || s1.send(10).unwrap());\nthread::spawn(move || s2.send(20).unwrap());\n// At most one of these two receive operations will be executed.\nselect! {\n  recv(r1) -> msg => assert_eq!(msg, Ok(10)),\n  recv(r2) -> msg => assert_eq!(msg, Ok(20)),\n  default(Duration::from_secs(1)) => println!(\"timed out\"),\n}\n```\n\nIf you need to select over a dynamically created list of channel operations, use `Select`\u27e819\u27e9 instead. The `select!`\u27e818\u27e9 macro is just a convenience wrapper around `Select`\u27e819\u27e9.\n## \u00a7\u27e820\u27e9Extra channels\nThree functions can create special kinds of channels, all of which return just a `Receiver`\u27e810\u27e9 handle:\n  * `after`\u27e821\u27e9 creates a channel that delivers a single message after a certain duration of time.\n  * `tick`\u27e822\u27e9 creates a channel that delivers messages periodically.\n  * `never`\u27e823\u27e9 creates a channel that never delivers messages.\n\n\nThese channels are very efficient because messages get lazily generated on receive operations.\nAn example that prints elapsed time every 50 milliseconds for the duration of 1 second:\n```\nuse std::time::{Duration, Instant};\nuse crossbeam_channel::{after, select, tick};\nlet start = Instant::now();\nlet ticker = tick(Duration::from_millis(50));\nlet timeout = after(Duration::from_secs(1));\nloop {\n  select! {\n    recv(ticker) -> _ => println!(\"elapsed: {:?}\", start.elapsed()),\n    recv(timeout) -> _ => break,\n  }\n}\n```\n\n## Macros\u00a7\u27e824\u27e9\n\nselect\u27e818\u27e9\n    Selects from a set of channel operations.\n\nselect_biased\u27e825\u27e9\n    Selects from a set of channel operations.\n## Structs\u00a7\u27e826\u27e9\n\nIntoIter\u27e827\u27e9\n    A blocking iterator over messages in a channel.\n\nIter\u27e828\u27e9\n    A blocking iterator over messages in a channel.\n\nReadyTimeoutError\u27e829\u27e9\n    An error returned from the `ready_timeout`\u27e830\u27e9 method.\n\nReceiver\u27e810\u27e9\n    The receiving side of a channel.\n\nRecvError\u27e831\u27e9\n    An error returned from the `recv`\u27e832\u27e9 method.\n\nSelect\u27e819\u27e9\n    Selects from a set of channel operations.\n\nSelectTimeoutError\u27e833\u27e9\n    An error returned from the `select_timeout`\u27e834\u27e9 method.\n\nSelectedOperation\u27e835\u27e9\n    A selected operation that needs to be completed.\n\nSendError\u27e836\u27e9\n    An error returned from the `send`\u27e837\u27e9 method.\n\nSender\u27e89\u27e9\n    The sending side of a channel.\n\nTryIter\u27e838\u27e9\n    A non-blocking iterator over messages in a channel.\n\nTryReadyError\u27e839\u27e9\n    An error returned from the `try_ready`\u27e840\u27e9 method.\n\nTrySelectError\u27e841\u27e9\n    An error returned from the `try_select`\u27e842\u27e9 method.\n## Enums\u00a7\u27e843\u27e9\n\nRecvTimeoutError\u27e844\u27e9\n    An error returned from the `recv_timeout`\u27e845\u27e9 method.\n\nSendTimeoutError\u27e846\u27e9\n    An error returned from the `send_timeout`\u27e847\u27e9 method.\n\nTryRecvError\u27e848\u27e9\n    An error returned from the `try_recv`\u27e849\u27e9 method.\n\nTrySendError\u27e850\u27e9\n    An error returned from the `try_send`\u27e851\u27e9 method.\n## Functions\u00a7\u27e852\u27e9\n\nafter\u27e821\u27e9\n    Creates a receiver that delivers a message after a certain duration of time.\n\nat\u27e853\u27e9\n    Creates a receiver that delivers a message at a certain instant in time.\n\nbounded\u27e87\u27e9\n    Creates a channel of bounded capacity.\n\nnever\u27e823\u27e9\n    Creates a receiver that never delivers messages.\n\ntick\u27e822\u27e9\n    Creates a receiver that delivers messages periodically.\n\nunbounded\u27e88\u27e9\n    Creates a channel of unbounded capacity.\n",
            "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/crossbeam-channel/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/crossbeam-channel/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/crossbeam-channel/latest/src/crossbeam_channel/lib.rs.html#1-378: Source\n\u27e84\u27e9 https://doc.rust-lang.org/nightly/std/sync/mpsc/index.html: mod std::sync::mpsc - `std::sync::mpsc`\n\u27e85\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#hello-world: \u00a7\n\u27e86\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#channel-types: \u00a7\n\u27e87\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/fn.bounded.html: fn crossbeam_channel::bounded - `bounded`\n\u27e88\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/fn.unbounded.html: fn crossbeam_channel::unbounded - `unbounded`\n\u27e89\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Sender.html: struct crossbeam_channel::Sender - `Sender`\n\u27e810\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Receiver.html: struct crossbeam_channel::Receiver - `Receiver`\n\u27e811\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#sharing-channels: \u00a7\n\u27e812\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#disconnection: \u00a7\n\u27e813\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#blocking-operations: \u00a7\n\u27e814\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#iteration: \u00a7\n\u27e815\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Receiver.html#method.iter: method crossbeam_channel::Receiver::iter - `iter`\n\u27e816\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Receiver.html#method.try_iter: method crossbeam_channel::Receiver::try_iter - `try_iter`\n\u27e817\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#selection: \u00a7\n\u27e818\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/macro.select.html: macro crossbeam_channel::select - `select!`\n\u27e819\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Select.html: struct crossbeam_channel::Select - `Select`\n\u27e820\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#extra-channels: \u00a7\n\u27e821\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/fn.after.html: fn crossbeam_channel::after - `after`\n\u27e822\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/fn.tick.html: fn crossbeam_channel::tick - `tick`\n\u27e823\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/fn.never.html: fn crossbeam_channel::never - `never`\n\u27e824\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#macros: \u00a7\n\u27e825\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/macro.select_biased.html: macro crossbeam_channel::select_biased - select_biased\n\u27e826\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#structs: \u00a7\n\u27e827\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.IntoIter.html: struct crossbeam_channel::IntoIter - IntoIter\n\u27e828\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Iter.html: struct crossbeam_channel::Iter - Iter\n\u27e829\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.ReadyTimeoutError.html: struct crossbeam_channel::ReadyTimeoutError - ReadyTimeoutError\n\u27e830\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Select.html#method.ready_timeout: method crossbeam_channel::Select::ready_timeout - `ready_timeout`\n\u27e831\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.RecvError.html: struct crossbeam_channel::RecvError - RecvError\n\u27e832\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Receiver.html#method.recv: method crossbeam_channel::Receiver::recv - `recv`\n\u27e833\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.SelectTimeoutError.html: struct crossbeam_channel::SelectTimeoutError - SelectTimeoutError\n\u27e834\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Select.html#method.select_timeout: method crossbeam_channel::Select::select_timeout - `select_timeout`\n\u27e835\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.SelectedOperation.html: struct crossbeam_channel::SelectedOperation - SelectedOperation\n\u27e836\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.SendError.html: struct crossbeam_channel::SendError - SendError\n\u27e837\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Sender.html#method.send: method crossbeam_channel::Sender::send - `send`\n\u27e838\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.TryIter.html: struct crossbeam_channel::TryIter - TryIter\n\u27e839\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.TryReadyError.html: struct crossbeam_channel::TryReadyError - TryReadyError\n\u27e840\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Select.html#method.try_ready: method crossbeam_channel::Select::try_ready - `try_ready`\n\u27e841\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.TrySelectError.html: struct crossbeam_channel::TrySelectError - TrySelectError\n\u27e842\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Select.html#method.try_select: method crossbeam_channel::Select::try_select - `try_select`\n\u27e843\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#enums: \u00a7\n\u27e844\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/enum.RecvTimeoutError.html: enum crossbeam_channel::RecvTimeoutError - RecvTimeoutError\n\u27e845\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Receiver.html#method.recv_timeout: method crossbeam_channel::Receiver::recv_timeout - `recv_timeout`\n\u27e846\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/enum.SendTimeoutError.html: enum crossbeam_channel::SendTimeoutError - SendTimeoutError\n\u27e847\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Sender.html#method.send_timeout: method crossbeam_channel::Sender::send_timeout - `send_timeout`\n\u27e848\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/enum.TryRecvError.html: enum crossbeam_channel::TryRecvError - TryRecvError\n\u27e849\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Receiver.html#method.try_recv: method crossbeam_channel::Receiver::try_recv - `try_recv`\n\u27e850\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/enum.TrySendError.html: enum crossbeam_channel::TrySendError - TrySendError\n\u27e851\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Sender.html#method.try_send: method crossbeam_channel::Sender::try_send - `try_send`\n\u27e852\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#functions: \u00a7\n\u27e853\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/fn.at.html: fn crossbeam_channel::at - at\n",
            "fit_markdown": "",
            "fit_html": ""
          },
          "downloads": 0,
          "github_stars": 0,
          "dependencies": [],
          "features": {},
          "code_snippets": [],
          "readme_sections": {},
          "librs_downloads": null,
          "source": "crates.io",
          "enhanced_scraping": {},
          "enhanced_features": [],
          "enhanced_dependencies": [],
          "readme_summary": "The `crossbeam-channel` crate provides multi-producer, multi-consumer channels for efficient message passing, serving as an enhanced alternative to `std::sync::mpsc`. It supports bounded, unbounded, and zero-capacity channels, offers cloning of senders and receivers for thread sharing, and includes blocking, non-blocking, and timeout-based operations. Additionally, it enables iteration over received messages and handles graceful disconnection when all senders or receivers are dropped.",
          "feature_summary": null,
          "use_case": "Utilities",
          "score": 8.5,
          "factual_counterfactual": "### Pair 1: Channel Types\n\u2705 Factual: The `crossbeam-channel` crate provides two types of channels: `bounded`, which has a fixed capacity, and `unbounded`, which can hold an unlimited number of messages.  \n\u274c Counterfactual: The `crossbeam-channel` crate supports three types of channels: `bounded`, `unbounded`, and `priority`, where messages can be prioritized based on custom criteria.\n\n---\n\n### Pair 2: Zero-Capacity Channels\n\u2705 Factual: A zero-capacity channel in `crossbeam-channel` requires send and receive operations to occur simultaneously, as it cannot store any messages.  \n\u274c Counterfactual: Zero-capacity channels in `crossbeam-channel` allow messages to queue temporarily if the sender and receiver are not synchronized.\n\n---\n\n### Pair 3: Performance Characteristics\n\u2705 Factual: `crossbeam-channel` is designed to outperform Rust's standard library `std::sync::mpsc` channels in both throughput and scalability, especially in multi-threaded scenarios.  \n\u274c Counterfactual: `crossbeam-channel` is optimized for single-threaded use cases and performs worse than `std::sync::mpsc` in multi-threaded environments.",
          "source_analysis": null,
          "user_behavior": null,
          "security": null
        }
      },
      "irl_score": 8.6,
      "execution_id": "exec-ff91df62-f624de90-1751262861",
      "timestamp": "2025-06-30T05:54:21.054941+00:00",
      "canon_version": "1.3.0"
    },
    "rule_zero_compliant": true
  }
]