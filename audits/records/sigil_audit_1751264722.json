[
  {
    "execution_id": "exec-383b2753-307ec8a2-1751264708",
    "timestamp": "2025-06-30T06:25:08.131366+00:00",
    "sacred_chain": {
      "input_data": "secp256k1",
      "context_sources": [
        "crates.io",
        "github.com",
        "lib.rs",
        "docs.rs"
      ],
      "reasoning_steps": [
        "Input canonicalized: 'secp256k1' -> 'secp256k1'",
        "Context gathered from 4 validated sources",
        "Metadata extracted: 4 fields",
        "Documentation analyzed: quality 7.0",
        "Sentiment analyzed: positive",
        "Ecosystem analyzed: utilities",
        "Quality score synthesized: 7.50",
        "Trust decision: DEFER - Insufficient data for decision",
        "IRL confidence: 8.600"
      ],
      "suggestion": "ALLOW: Positive community sentiment",
      "verdict": "DEFER",
      "audit_info": {
        "metadata": {
          "name": "secp256k1",
          "type": "rust_crate",
          "source": "manual_input",
          "extraction_method": "irl_engine"
        },
        "sentiment": {
          "quality_score": 7.0,
          "completeness": 0.8,
          "examples_present": true,
          "api_documented": true
        },
        "ecosystem": {
          "overall": "positive",
          "positive_mentions": 10,
          "negative_mentions": 2,
          "neutral_mentions": 5,
          "total_mentions": 17
        },
        "quality_score": 7.5,
        "verdict_reason": "Insufficient data for decision",
        "sanitized_documentation": {
          "crates_io": {
            "url": "https://crates.io/crates/secp256k1",
            "title": "secp256k1 v0.31.1",
            "content": {
              "raw_markdown": "#  secp256k1 v0.31.1\nRust wrapper library for Pieter Wuille's `libsecp256k1`. Implements ECDSA and BIP 340 signatures for the SECG elliptic curve group secp256k1 and related utilities. \n  * [ #bitcoin ](https://crates.io/keywords/bitcoin)\n  * [ #crypto ](https://crates.io/keywords/crypto)\n  * [ #ecdsa ](https://crates.io/keywords/ecdsa)\n  * [ #libsecp256k1 ](https://crates.io/keywords/libsecp256k1)\n  * [ #secp256k1 ](https://crates.io/keywords/secp256k1)\n\n\n  * [ Readme ](https://crates.io/crates/secp256k1)\n  * [ 95 Versions ](https://crates.io/crates/secp256k1/versions)\n  * [ Dependencies ](https://crates.io/crates/secp256k1/dependencies)\n  * [ Dependents ](https://crates.io/crates/secp256k1/reverse_dependencies)\n\n\n## Metadata\n7 days ago \nv1.63.0 \n[ CC0-1.0 ](https://choosealicense.com/licenses/cc0-1.0)\n91.3 KiB \n## Install\nRun the following Cargo command in your project directory:\ncargo add secp256k1\nOr add the following line to your Cargo.toml:\nsecp256k1 = \"0.31.1\"\n## Documentation\n[ docs.rs/secp256k1 ](https://docs.rs/secp256k1/)\n## Repository\n[ github.com/rust-bitcoin/rust-secp256k1 ](https://github.com/rust-bitcoin/rust-secp256k1/)\n## Owners\n[ Report crate ](https://crates.io/support?crate=secp256k1&inquire=crate-violation)\n### Stats Overview\n28,399,418 Downloads all time\n95 Versions published\n#### Downloads over the last 90 days\nDisplay as \nStacked \n  * Stacked \n  * Unstacked \n\n\nLoading\u2026\n",
              "markdown_with_citations": "#  secp256k1 v0.31.1\nRust wrapper library for Pieter Wuille's `libsecp256k1`. Implements ECDSA and BIP 340 signatures for the SECG elliptic curve group secp256k1 and related utilities. \n  *  #bitcoin \u27e81\u27e9\n  *  #crypto \u27e82\u27e9\n  *  #ecdsa \u27e83\u27e9\n  *  #libsecp256k1 \u27e84\u27e9\n  *  #secp256k1 \u27e85\u27e9\n\n\n  *  Readme \u27e86\u27e9\n  *  95 Versions \u27e87\u27e9\n  *  Dependencies \u27e88\u27e9\n  *  Dependents \u27e89\u27e9\n\n\n## Metadata\n7 days ago \nv1.63.0 \n CC0-1.0 \u27e810\u27e9\n91.3 KiB \n## Install\nRun the following Cargo command in your project directory:\ncargo add secp256k1\nOr add the following line to your Cargo.toml:\nsecp256k1 = \"0.31.1\"\n## Documentation\n docs.rs/secp256k1 \u27e811\u27e9\n## Repository\n github.com/rust-bitcoin/rust-secp256k1 \u27e812\u27e9\n## Owners\n Report crate \u27e813\u27e9\n### Stats Overview\n28,399,418 Downloads all time\n95 Versions published\n#### Downloads over the last 90 days\nDisplay as \nStacked \n  * Stacked \n  * Unstacked \n\n\nLoading\u2026\n",
              "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://crates.io/keywords/bitcoin:  #bitcoin \n\u27e82\u27e9 https://crates.io/keywords/crypto:  #crypto \n\u27e83\u27e9 https://crates.io/keywords/ecdsa:  #ecdsa \n\u27e84\u27e9 https://crates.io/keywords/libsecp256k1:  #libsecp256k1 \n\u27e85\u27e9 https://crates.io/keywords/secp256k1:  #secp256k1 \n\u27e86\u27e9 https://crates.io/crates/secp256k1:  Readme \n\u27e87\u27e9 https://crates.io/crates/secp256k1/versions:  95 Versions \n\u27e88\u27e9 https://crates.io/crates/secp256k1/dependencies:  Dependencies \n\u27e89\u27e9 https://crates.io/crates/secp256k1/reverse_dependencies:  Dependents \n\u27e810\u27e9 https://choosealicense.com/licenses/cc0-1.0:  CC0-1.0 \n\u27e811\u27e9 https://docs.rs/secp256k1/:  docs.rs/secp256k1 \n\u27e812\u27e9 https://github.com/rust-bitcoin/rust-secp256k1/:  github.com/rust-bitcoin/rust-secp256k1 \n\u27e813\u27e9 https://crates.io/support?crate=secp256k1&inquire=crate-violation:  Report crate \n",
              "fit_markdown": "",
              "fit_html": ""
            },
            "structured_data": {},
            "quality_score": 3.0,
            "extraction_method": "crawl4ai",
            "error": null,
            "metadata": {
              "doc_type": "docs",
              "content_length": 1417,
              "has_structured_data": false,
              "crawl_success": true
            },
            "timestamp": "118497.7335014"
          },
          "docs_rs": {
            "url": "https://docs.rs/secp256k1",
            "title": "Crate secp256k1Copy item path",
            "content": {
              "raw_markdown": "[](https://docs.rs/secp256k1/latest/secp256k1/all.html \"show sidebar\")\n# Crate secp256k1Copy item path\n[Settings](https://docs.rs/secp256k1/latest/settings.html)\n[Help](https://docs.rs/secp256k1/latest/help.html)\nSummary[Source](https://docs.rs/secp256k1/latest/src/secp256k1/lib.rs.html#3-1052)\nExpand description\nRust bindings for Pieter Wuille\u2019s secp256k1 library, which is used for fast and accurate manipulation of ECDSA and Schnorr signatures on the secp256k1 curve. Such signatures are used extensively by the Bitcoin network and its derivatives.\nTo minimize dependencies, some functions are feature-gated. To generate random keys or to re-randomize a context object, compile with the `rand` and `std` features. If you are willing to use these features, we have enabled an additional defense-in-depth sidechannel protection for our context objects, which re-blinds certain operations on secret key data. To de/serialize objects with serde, compile with \u201cserde\u201d. **Important** : `serde` encoding is **not** the same as consensus encoding!\nWhere possible, the bindings use the Rust type system to ensure that API usage errors are impossible. For example, the library uses context objects that contain precomputation tables which are created on object construction. Since this is a slow operation (10+ milliseconds, vs ~50 microseconds for typical crypto operations, on a 2.70 Ghz i7-6820HQ) the tables are optional, giving a performance boost for users who only care about signing, only care about verification, or only care about parsing. In the upstream library, if you attempt to sign a message using a context that does not support this, it will trigger an assertion failure and terminate the program. In `rust-secp256k1`, this is caught at compile-time; in fact, it is impossible to compile code that will trigger any assertion failures in the upstream library.\n```\nuse secp256k1::rand;\nuse secp256k1::{Secp256k1, Message};\nuse secp256k1::hashes::{sha256, Hash};\nlet secp = Secp256k1::new();\nlet (secret_key, public_key) = secp.generate_keypair(&mut rand::rng());\nlet digest = sha256::Hash::hash(\"Hello World!\".as_bytes());\nlet message = Message::from_digest(digest.to_byte_array());\nlet sig = secp.sign_ecdsa(message, &secret_key);\nassert!(secp.verify_ecdsa(message, &sig, &public_key).is_ok());\n```\n\nIf the \u201cglobal-context\u201d feature is enabled you have access to an alternate API.\n```\nuse secp256k1::{rand, generate_keypair, Message};\nuse secp256k1::hashes::{sha256, Hash};\nlet (secret_key, public_key) = generate_keypair(&mut rand::rng());\nlet digest = sha256::Hash::hash(\"Hello World!\".as_bytes());\nlet message = Message::from_digest(digest.to_byte_array());\nlet sig = secret_key.sign_ecdsa(message);\nassert!(sig.verify(message, &public_key).is_ok());\n```\n\nThe above code requires `rust-secp256k1` to be compiled with the `rand`, `hashes`, and `std` feature enabled, to get access to [`generate_keypair`](https://docs.rs/secp256k1/latest/secp256k1/struct.Secp256k1.html#method.generate_keypair) Alternately, keys and messages can be parsed from slices, like\n```\nuse secp256k1::{Secp256k1, Message, SecretKey, PublicKey};\nlet secp = Secp256k1::new();\nlet secret_key = SecretKey::from_slice(&[0xcd; 32]).expect(\"32 bytes, within curve order\");\nlet public_key = PublicKey::from_secret_key(&secp, &secret_key);\n// If the supplied byte slice was *not* the output of a cryptographic hash function this would\n// be cryptographically broken. It has been trivially used in the past to execute attacks.\nlet message = Message::from_digest(compute_hash(b\"CSW is not Satoshi\"));\nlet sig = secp.sign_ecdsa(message, &secret_key);\nassert!(secp.verify_ecdsa(message, &sig, &public_key).is_ok());\n```\n\nUsers who only want to verify signatures can use a cheaper context, like so:\n```\nuse secp256k1::{Secp256k1, Message, ecdsa, PublicKey};\nlet secp = Secp256k1::verification_only();\nlet public_key = PublicKey::from_slice(&[\n  0x02,\n  0xc6, 0x6e, 0x7d, 0x89, 0x66, 0xb5, 0xc5, 0x55,\n  0xaf, 0x58, 0x05, 0x98, 0x9d, 0xa9, 0xfb, 0xf8,\n  0xdb, 0x95, 0xe1, 0x56, 0x31, 0xce, 0x35, 0x8c,\n  0x3a, 0x17, 0x10, 0xc9, 0x62, 0x67, 0x90, 0x63,\n]).expect(\"public keys must be 33 or 65 bytes, serialized according to SEC 2\");\nlet message = Message::from_digest([\n  0xaa, 0xdf, 0x7d, 0xe7, 0x82, 0x03, 0x4f, 0xbe,\n  0x3d, 0x3d, 0xb2, 0xcb, 0x13, 0xc0, 0xcd, 0x91,\n  0xbf, 0x41, 0xcb, 0x08, 0xfa, 0xc7, 0xbd, 0x61,\n  0xd5, 0x44, 0x53, 0xcf, 0x6e, 0x82, 0xb4, 0x50,\n]);\nlet sig = ecdsa::Signature::from_compact(&[\n  0xdc, 0x4d, 0xc2, 0x64, 0xa9, 0xfe, 0xf1, 0x7a,\n  0x3f, 0x25, 0x34, 0x49, 0xcf, 0x8c, 0x39, 0x7a,\n  0xb6, 0xf1, 0x6f, 0xb3, 0xd6, 0x3d, 0x86, 0x94,\n  0x0b, 0x55, 0x86, 0x82, 0x3d, 0xfd, 0x02, 0xae,\n  0x3b, 0x46, 0x1b, 0xb4, 0x33, 0x6b, 0x5e, 0xcb,\n  0xae, 0xfd, 0x66, 0x27, 0xaa, 0x92, 0x2e, 0xfc,\n  0x04, 0x8f, 0xec, 0x0c, 0x88, 0x1c, 0x10, 0xc4,\n  0xc9, 0x42, 0x8f, 0xca, 0x69, 0xc1, 0x32, 0xa2,\n]).expect(\"compact signatures are 64 bytes; DER signatures are 68-72 bytes\");\nassert!(secp.verify_ecdsa(message, &sig, &public_key).is_ok());\n```\n\nObserve that the same code using, say [`signing_only`](https://docs.rs/secp256k1/latest/secp256k1/struct.Secp256k1.html#method.signing_only) to generate a context would simply not compile.\n### [\u00a7](https://docs.rs/secp256k1/latest/secp256k1/#crate-featuresoptional-dependencies)Crate features/optional dependencies\nThis crate provides the following opt-in Cargo features:\n  * `std` - use standard Rust library, enabled by default.\n  * `alloc` - use the `alloc` standard Rust library to provide heap allocations.\n  * `rand` - use `rand` library to provide random generator (e.g. to generate keys).\n  * `hashes` - use the `hashes` library.\n  * `recovery` - enable functions that can compute the public key from signature.\n  * `lowmemory` - optimize the library for low-memory environments.\n  * `global-context` - enable use of global secp256k1 context (implies `std`).\n  * `serde` - implements serialization and deserialization for types in this crate using `serde`. **Important** : `serde` encoding is **not** the same as consensus encoding!\n\n\n## Re-exports[\u00a7](https://docs.rs/secp256k1/latest/secp256k1/#reexports)\n\n`pub extern crate hashes[](https://docs.rs/bitcoin_hashes/0.14.0/x86_64-unknown-linux-gnu/bitcoin_hashes/index.html \"mod bitcoin_hashes\");`\n\n\n`pub use crate::scalar::Scalar[](https://docs.rs/secp256k1/latest/secp256k1/scalar/struct.Scalar.html \"struct secp256k1::scalar::Scalar\");`\n\n\n`pub use rand[](https://docs.rs/rand/0.9.1/x86_64-unknown-linux-gnu/rand/index.html \"mod rand\");``rand`\n\n\n`pub use secp256k1_sys[](https://docs.rs/secp256k1-sys/0.11.0/x86_64-unknown-linux-gnu/secp256k1_sys/index.html \"mod secp256k1_sys\") as ffi;`\n\n\n`pub use serde[](https://docs.rs/serde/1.0.219/x86_64-unknown-linux-gnu/serde/index.html \"mod serde\");``serde`\n\n## Modules[\u00a7](https://docs.rs/secp256k1/latest/secp256k1/#modules)\n\n[constants](https://docs.rs/secp256k1/latest/secp256k1/constants/index.html \"mod secp256k1::constants\")\n    Constants related to the API and the underlying curve.\n\n[ecdh](https://docs.rs/secp256k1/latest/secp256k1/ecdh/index.html \"mod secp256k1::ecdh\")\n    Support for shared secret computations.\n\n[ecdsa](https://docs.rs/secp256k1/latest/secp256k1/ecdsa/index.html \"mod secp256k1::ecdsa\")\n    Structs and functionality related to the ECDSA signature algorithm.\n\n[ellswift](https://docs.rs/secp256k1/latest/secp256k1/ellswift/index.html \"mod secp256k1::ellswift\")\n    This module provides an implementation of ElligatorSwift as well as a version of x-only ECDH using it (including compatibility with BIP324).\n\n[global](https://docs.rs/secp256k1/latest/secp256k1/global/index.html \"mod secp256k1::global\")`global-context` and `std`\n    Module implementing a singleton pattern for a global `Secp256k1` context.\n\n[scalar](https://docs.rs/secp256k1/latest/secp256k1/scalar/index.html \"mod secp256k1::scalar\")\n    Provides [`Scalar`](https://docs.rs/secp256k1/latest/secp256k1/scalar/struct.Scalar.html \"struct secp256k1::scalar::Scalar\") and related types.\n\n[schnorr](https://docs.rs/secp256k1/latest/secp256k1/schnorr/index.html \"mod secp256k1::schnorr\")\n    Support for schnorr signatures.\n## Macros[\u00a7](https://docs.rs/secp256k1/latest/secp256k1/#macros)\n\n[impl_array_newtype](https://docs.rs/secp256k1/latest/secp256k1/macro.impl_array_newtype.html \"macro secp256k1::impl_array_newtype\")\n    Implement methods and traits for types that contain an inner array.\n## Structs[\u00a7](https://docs.rs/secp256k1/latest/secp256k1/#structs)\n\n[AllPreallocated](https://docs.rs/secp256k1/latest/secp256k1/struct.AllPreallocated.html \"struct secp256k1::AllPreallocated\")\n    Represents the set of all capabilities (preallocated memory).\n\n[InvalidParityValue](https://docs.rs/secp256k1/latest/secp256k1/struct.InvalidParityValue.html \"struct secp256k1::InvalidParityValue\")\n    Error returned when conversion from an integer to `Parity` fails.\n\n[Keypair](https://docs.rs/secp256k1/latest/secp256k1/struct.Keypair.html \"struct secp256k1::Keypair\")\n    Opaque data structure that holds a keypair consisting of a secret and a public key.\n\n[Message](https://docs.rs/secp256k1/latest/secp256k1/struct.Message.html \"struct secp256k1::Message\")\n    A (hashed) message input to an ECDSA signature.\n\n[PublicKey](https://docs.rs/secp256k1/latest/secp256k1/struct.PublicKey.html \"struct secp256k1::PublicKey\")\n    Public key - used to verify ECDSA signatures and to do Taproot tweaks.\n\n[Secp256k1](https://docs.rs/secp256k1/latest/secp256k1/struct.Secp256k1.html \"struct secp256k1::Secp256k1\")\n    The secp256k1 engine, used to execute all signature operations.\n\n[SecretKey](https://docs.rs/secp256k1/latest/secp256k1/struct.SecretKey.html \"struct secp256k1::SecretKey\")\n    Secret key - a 256-bit key used to create ECDSA and Taproot signatures.\n\n[SignOnlyPreallocated](https://docs.rs/secp256k1/latest/secp256k1/struct.SignOnlyPreallocated.html \"struct secp256k1::SignOnlyPreallocated\")\n    Represents the set of capabilities needed for signing (preallocated memory).\n\n[VerifyOnlyPreallocated](https://docs.rs/secp256k1/latest/secp256k1/struct.VerifyOnlyPreallocated.html \"struct secp256k1::VerifyOnlyPreallocated\")\n    Represents the set of capabilities needed for verification (preallocated memory).\n\n[XOnlyPublicKey](https://docs.rs/secp256k1/latest/secp256k1/struct.XOnlyPublicKey.html \"struct secp256k1::XOnlyPublicKey\")\n    An x-only public key, used for verification of Taproot signatures and serialized according to BIP-340.\n## Enums[\u00a7](https://docs.rs/secp256k1/latest/secp256k1/#enums)\n\n[All](https://docs.rs/secp256k1/latest/secp256k1/enum.All.html \"enum secp256k1::All\")`alloc`\n    Represents the set of all capabilities.\n\n[Error](https://docs.rs/secp256k1/latest/secp256k1/enum.Error.html \"enum secp256k1::Error\")\n    The main error type for this library.\n\n[Parity](https://docs.rs/secp256k1/latest/secp256k1/enum.Parity.html \"enum secp256k1::Parity\")\n    Represents the parity passed between FFI function calls.\n\n[SignOnly](https://docs.rs/secp256k1/latest/secp256k1/enum.SignOnly.html \"enum secp256k1::SignOnly\")`alloc`\n    Represents the set of capabilities needed for signing.\n\n[VerifyOnly](https://docs.rs/secp256k1/latest/secp256k1/enum.VerifyOnly.html \"enum secp256k1::VerifyOnly\")`alloc`\n    Represents the set of capabilities needed for verification.\n## Statics[\u00a7](https://docs.rs/secp256k1/latest/secp256k1/#statics)\n\n[SECP256K1](https://docs.rs/secp256k1/latest/secp256k1/static.SECP256K1.html \"static secp256k1::SECP256K1\")`global-context` and `std`\n    A global static context to avoid repeatedly creating contexts.\n## Traits[\u00a7](https://docs.rs/secp256k1/latest/secp256k1/#traits)\n\n[Context](https://docs.rs/secp256k1/latest/secp256k1/trait.Context.html \"trait secp256k1::Context\")\n    A trait for all kinds of contexts that lets you define the exact flags and a function to deallocate memory. It isn\u2019t possible to implement this for types outside this crate.\n\n[PreallocatedContext](https://docs.rs/secp256k1/latest/secp256k1/trait.PreallocatedContext.html \"trait secp256k1::PreallocatedContext\")\n    Trait marking that a particular context object internally points to memory that must outlive `'a`\n\n[Signing](https://docs.rs/secp256k1/latest/secp256k1/trait.Signing.html \"trait secp256k1::Signing\")\n    Marker trait for indicating that an instance of [`Secp256k1`](https://docs.rs/secp256k1/latest/secp256k1/struct.Secp256k1.html \"struct secp256k1::Secp256k1\") can be used for signing.\n\n[ThirtyTwoByteHash](https://docs.rs/secp256k1/latest/secp256k1/trait.ThirtyTwoByteHash.html \"trait secp256k1::ThirtyTwoByteHash\")Deprecated\n    Trait describing something that promises to be a 32-byte uniformly random number.\n\n[Verification](https://docs.rs/secp256k1/latest/secp256k1/trait.Verification.html \"trait secp256k1::Verification\")\n    Marker trait for indicating that an instance of [`Secp256k1`](https://docs.rs/secp256k1/latest/secp256k1/struct.Secp256k1.html \"struct secp256k1::Secp256k1\") can be used for verification.\n## Functions[\u00a7](https://docs.rs/secp256k1/latest/secp256k1/#functions)\n\n[generate_keypair](https://docs.rs/secp256k1/latest/secp256k1/fn.generate_keypair.html \"fn secp256k1::generate_keypair\")`global-context` and `rand`\n    Generates a random keypair using the global [`SECP256K1`](https://docs.rs/secp256k1/latest/secp256k1/static.SECP256K1.html \"static secp256k1::SECP256K1\") context.\n",
              "markdown_with_citations": "[](https://docs.rs/secp256k1/latest/secp256k1/all.html \"show sidebar\")\n# Crate secp256k1Copy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nRust bindings for Pieter Wuille\u2019s secp256k1 library, which is used for fast and accurate manipulation of ECDSA and Schnorr signatures on the secp256k1 curve. Such signatures are used extensively by the Bitcoin network and its derivatives.\nTo minimize dependencies, some functions are feature-gated. To generate random keys or to re-randomize a context object, compile with the `rand` and `std` features. If you are willing to use these features, we have enabled an additional defense-in-depth sidechannel protection for our context objects, which re-blinds certain operations on secret key data. To de/serialize objects with serde, compile with \u201cserde\u201d. **Important** : `serde` encoding is **not** the same as consensus encoding!\nWhere possible, the bindings use the Rust type system to ensure that API usage errors are impossible. For example, the library uses context objects that contain precomputation tables which are created on object construction. Since this is a slow operation (10+ milliseconds, vs ~50 microseconds for typical crypto operations, on a 2.70 Ghz i7-6820HQ) the tables are optional, giving a performance boost for users who only care about signing, only care about verification, or only care about parsing. In the upstream library, if you attempt to sign a message using a context that does not support this, it will trigger an assertion failure and terminate the program. In `rust-secp256k1`, this is caught at compile-time; in fact, it is impossible to compile code that will trigger any assertion failures in the upstream library.\n```\nuse secp256k1::rand;\nuse secp256k1::{Secp256k1, Message};\nuse secp256k1::hashes::{sha256, Hash};\nlet secp = Secp256k1::new();\nlet (secret_key, public_key) = secp.generate_keypair(&mut rand::rng());\nlet digest = sha256::Hash::hash(\"Hello World!\".as_bytes());\nlet message = Message::from_digest(digest.to_byte_array());\nlet sig = secp.sign_ecdsa(message, &secret_key);\nassert!(secp.verify_ecdsa(message, &sig, &public_key).is_ok());\n```\n\nIf the \u201cglobal-context\u201d feature is enabled you have access to an alternate API.\n```\nuse secp256k1::{rand, generate_keypair, Message};\nuse secp256k1::hashes::{sha256, Hash};\nlet (secret_key, public_key) = generate_keypair(&mut rand::rng());\nlet digest = sha256::Hash::hash(\"Hello World!\".as_bytes());\nlet message = Message::from_digest(digest.to_byte_array());\nlet sig = secret_key.sign_ecdsa(message);\nassert!(sig.verify(message, &public_key).is_ok());\n```\n\nThe above code requires `rust-secp256k1` to be compiled with the `rand`, `hashes`, and `std` feature enabled, to get access to `generate_keypair`\u27e84\u27e9 Alternately, keys and messages can be parsed from slices, like\n```\nuse secp256k1::{Secp256k1, Message, SecretKey, PublicKey};\nlet secp = Secp256k1::new();\nlet secret_key = SecretKey::from_slice(&[0xcd; 32]).expect(\"32 bytes, within curve order\");\nlet public_key = PublicKey::from_secret_key(&secp, &secret_key);\n// If the supplied byte slice was *not* the output of a cryptographic hash function this would\n// be cryptographically broken. It has been trivially used in the past to execute attacks.\nlet message = Message::from_digest(compute_hash(b\"CSW is not Satoshi\"));\nlet sig = secp.sign_ecdsa(message, &secret_key);\nassert!(secp.verify_ecdsa(message, &sig, &public_key).is_ok());\n```\n\nUsers who only want to verify signatures can use a cheaper context, like so:\n```\nuse secp256k1::{Secp256k1, Message, ecdsa, PublicKey};\nlet secp = Secp256k1::verification_only();\nlet public_key = PublicKey::from_slice(&[\n  0x02,\n  0xc6, 0x6e, 0x7d, 0x89, 0x66, 0xb5, 0xc5, 0x55,\n  0xaf, 0x58, 0x05, 0x98, 0x9d, 0xa9, 0xfb, 0xf8,\n  0xdb, 0x95, 0xe1, 0x56, 0x31, 0xce, 0x35, 0x8c,\n  0x3a, 0x17, 0x10, 0xc9, 0x62, 0x67, 0x90, 0x63,\n]).expect(\"public keys must be 33 or 65 bytes, serialized according to SEC 2\");\nlet message = Message::from_digest([\n  0xaa, 0xdf, 0x7d, 0xe7, 0x82, 0x03, 0x4f, 0xbe,\n  0x3d, 0x3d, 0xb2, 0xcb, 0x13, 0xc0, 0xcd, 0x91,\n  0xbf, 0x41, 0xcb, 0x08, 0xfa, 0xc7, 0xbd, 0x61,\n  0xd5, 0x44, 0x53, 0xcf, 0x6e, 0x82, 0xb4, 0x50,\n]);\nlet sig = ecdsa::Signature::from_compact(&[\n  0xdc, 0x4d, 0xc2, 0x64, 0xa9, 0xfe, 0xf1, 0x7a,\n  0x3f, 0x25, 0x34, 0x49, 0xcf, 0x8c, 0x39, 0x7a,\n  0xb6, 0xf1, 0x6f, 0xb3, 0xd6, 0x3d, 0x86, 0x94,\n  0x0b, 0x55, 0x86, 0x82, 0x3d, 0xfd, 0x02, 0xae,\n  0x3b, 0x46, 0x1b, 0xb4, 0x33, 0x6b, 0x5e, 0xcb,\n  0xae, 0xfd, 0x66, 0x27, 0xaa, 0x92, 0x2e, 0xfc,\n  0x04, 0x8f, 0xec, 0x0c, 0x88, 0x1c, 0x10, 0xc4,\n  0xc9, 0x42, 0x8f, 0xca, 0x69, 0xc1, 0x32, 0xa2,\n]).expect(\"compact signatures are 64 bytes; DER signatures are 68-72 bytes\");\nassert!(secp.verify_ecdsa(message, &sig, &public_key).is_ok());\n```\n\nObserve that the same code using, say `signing_only`\u27e85\u27e9 to generate a context would simply not compile.\n### \u00a7\u27e86\u27e9Crate features/optional dependencies\nThis crate provides the following opt-in Cargo features:\n  * `std` - use standard Rust library, enabled by default.\n  * `alloc` - use the `alloc` standard Rust library to provide heap allocations.\n  * `rand` - use `rand` library to provide random generator (e.g. to generate keys).\n  * `hashes` - use the `hashes` library.\n  * `recovery` - enable functions that can compute the public key from signature.\n  * `lowmemory` - optimize the library for low-memory environments.\n  * `global-context` - enable use of global secp256k1 context (implies `std`).\n  * `serde` - implements serialization and deserialization for types in this crate using `serde`. **Important** : `serde` encoding is **not** the same as consensus encoding!\n\n\n## Re-exports\u00a7\u27e87\u27e9\n\n`pub extern crate hashes[](https://docs.rs/bitcoin_hashes/0.14.0/x86_64-unknown-linux-gnu/bitcoin_hashes/index.html \"mod bitcoin_hashes\");`\n\n\n`pub use crate::scalar::Scalar[](https://docs.rs/secp256k1/latest/secp256k1/scalar/struct.Scalar.html \"struct secp256k1::scalar::Scalar\");`\n\n\n`pub use rand[](https://docs.rs/rand/0.9.1/x86_64-unknown-linux-gnu/rand/index.html \"mod rand\");``rand`\n\n\n`pub use secp256k1_sys[](https://docs.rs/secp256k1-sys/0.11.0/x86_64-unknown-linux-gnu/secp256k1_sys/index.html \"mod secp256k1_sys\") as ffi;`\n\n\n`pub use serde[](https://docs.rs/serde/1.0.219/x86_64-unknown-linux-gnu/serde/index.html \"mod serde\");``serde`\n\n## Modules\u00a7\u27e88\u27e9\n\nconstants\u27e89\u27e9\n    Constants related to the API and the underlying curve.\n\necdh\u27e810\u27e9\n    Support for shared secret computations.\n\necdsa\u27e811\u27e9\n    Structs and functionality related to the ECDSA signature algorithm.\n\nellswift\u27e812\u27e9\n    This module provides an implementation of ElligatorSwift as well as a version of x-only ECDH using it (including compatibility with BIP324).\n\nglobal\u27e813\u27e9`global-context` and `std`\n    Module implementing a singleton pattern for a global `Secp256k1` context.\n\nscalar\u27e814\u27e9\n    Provides `Scalar`\u27e815\u27e9 and related types.\n\nschnorr\u27e816\u27e9\n    Support for schnorr signatures.\n## Macros\u00a7\u27e817\u27e9\n\nimpl_array_newtype\u27e818\u27e9\n    Implement methods and traits for types that contain an inner array.\n## Structs\u00a7\u27e819\u27e9\n\nAllPreallocated\u27e820\u27e9\n    Represents the set of all capabilities (preallocated memory).\n\nInvalidParityValue\u27e821\u27e9\n    Error returned when conversion from an integer to `Parity` fails.\n\nKeypair\u27e822\u27e9\n    Opaque data structure that holds a keypair consisting of a secret and a public key.\n\nMessage\u27e823\u27e9\n    A (hashed) message input to an ECDSA signature.\n\nPublicKey\u27e824\u27e9\n    Public key - used to verify ECDSA signatures and to do Taproot tweaks.\n\nSecp256k1\u27e825\u27e9\n    The secp256k1 engine, used to execute all signature operations.\n\nSecretKey\u27e826\u27e9\n    Secret key - a 256-bit key used to create ECDSA and Taproot signatures.\n\nSignOnlyPreallocated\u27e827\u27e9\n    Represents the set of capabilities needed for signing (preallocated memory).\n\nVerifyOnlyPreallocated\u27e828\u27e9\n    Represents the set of capabilities needed for verification (preallocated memory).\n\nXOnlyPublicKey\u27e829\u27e9\n    An x-only public key, used for verification of Taproot signatures and serialized according to BIP-340.\n## Enums\u00a7\u27e830\u27e9\n\nAll\u27e831\u27e9`alloc`\n    Represents the set of all capabilities.\n\nError\u27e832\u27e9\n    The main error type for this library.\n\nParity\u27e833\u27e9\n    Represents the parity passed between FFI function calls.\n\nSignOnly\u27e834\u27e9`alloc`\n    Represents the set of capabilities needed for signing.\n\nVerifyOnly\u27e835\u27e9`alloc`\n    Represents the set of capabilities needed for verification.\n## Statics\u00a7\u27e836\u27e9\n\nSECP256K1\u27e837\u27e9`global-context` and `std`\n    A global static context to avoid repeatedly creating contexts.\n## Traits\u00a7\u27e838\u27e9\n\nContext\u27e839\u27e9\n    A trait for all kinds of contexts that lets you define the exact flags and a function to deallocate memory. It isn\u2019t possible to implement this for types outside this crate.\n\nPreallocatedContext\u27e840\u27e9\n    Trait marking that a particular context object internally points to memory that must outlive `'a`\n\nSigning\u27e841\u27e9\n    Marker trait for indicating that an instance of `Secp256k1`\u27e825\u27e9 can be used for signing.\n\nThirtyTwoByteHash\u27e842\u27e9Deprecated\n    Trait describing something that promises to be a 32-byte uniformly random number.\n\nVerification\u27e843\u27e9\n    Marker trait for indicating that an instance of `Secp256k1`\u27e825\u27e9 can be used for verification.\n## Functions\u00a7\u27e844\u27e9\n\ngenerate_keypair\u27e845\u27e9`global-context` and `rand`\n    Generates a random keypair using the global `SECP256K1`\u27e837\u27e9 context.\n",
              "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/secp256k1/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/secp256k1/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/secp256k1/latest/src/secp256k1/lib.rs.html#3-1052: Source\n\u27e84\u27e9 https://docs.rs/secp256k1/latest/secp256k1/struct.Secp256k1.html#method.generate_keypair: `generate_keypair`\n\u27e85\u27e9 https://docs.rs/secp256k1/latest/secp256k1/struct.Secp256k1.html#method.signing_only: `signing_only`\n\u27e86\u27e9 https://docs.rs/secp256k1/latest/secp256k1/#crate-featuresoptional-dependencies: \u00a7\n\u27e87\u27e9 https://docs.rs/secp256k1/latest/secp256k1/#reexports: \u00a7\n\u27e88\u27e9 https://docs.rs/secp256k1/latest/secp256k1/#modules: \u00a7\n\u27e89\u27e9 https://docs.rs/secp256k1/latest/secp256k1/constants/index.html: mod secp256k1::constants - constants\n\u27e810\u27e9 https://docs.rs/secp256k1/latest/secp256k1/ecdh/index.html: mod secp256k1::ecdh - ecdh\n\u27e811\u27e9 https://docs.rs/secp256k1/latest/secp256k1/ecdsa/index.html: mod secp256k1::ecdsa - ecdsa\n\u27e812\u27e9 https://docs.rs/secp256k1/latest/secp256k1/ellswift/index.html: mod secp256k1::ellswift - ellswift\n\u27e813\u27e9 https://docs.rs/secp256k1/latest/secp256k1/global/index.html: mod secp256k1::global - global\n\u27e814\u27e9 https://docs.rs/secp256k1/latest/secp256k1/scalar/index.html: mod secp256k1::scalar - scalar\n\u27e815\u27e9 https://docs.rs/secp256k1/latest/secp256k1/scalar/struct.Scalar.html: struct secp256k1::scalar::Scalar - `Scalar`\n\u27e816\u27e9 https://docs.rs/secp256k1/latest/secp256k1/schnorr/index.html: mod secp256k1::schnorr - schnorr\n\u27e817\u27e9 https://docs.rs/secp256k1/latest/secp256k1/#macros: \u00a7\n\u27e818\u27e9 https://docs.rs/secp256k1/latest/secp256k1/macro.impl_array_newtype.html: macro secp256k1::impl_array_newtype - impl_array_newtype\n\u27e819\u27e9 https://docs.rs/secp256k1/latest/secp256k1/#structs: \u00a7\n\u27e820\u27e9 https://docs.rs/secp256k1/latest/secp256k1/struct.AllPreallocated.html: struct secp256k1::AllPreallocated - AllPreallocated\n\u27e821\u27e9 https://docs.rs/secp256k1/latest/secp256k1/struct.InvalidParityValue.html: struct secp256k1::InvalidParityValue - InvalidParityValue\n\u27e822\u27e9 https://docs.rs/secp256k1/latest/secp256k1/struct.Keypair.html: struct secp256k1::Keypair - Keypair\n\u27e823\u27e9 https://docs.rs/secp256k1/latest/secp256k1/struct.Message.html: struct secp256k1::Message - Message\n\u27e824\u27e9 https://docs.rs/secp256k1/latest/secp256k1/struct.PublicKey.html: struct secp256k1::PublicKey - PublicKey\n\u27e825\u27e9 https://docs.rs/secp256k1/latest/secp256k1/struct.Secp256k1.html: struct secp256k1::Secp256k1 - Secp256k1\n\u27e826\u27e9 https://docs.rs/secp256k1/latest/secp256k1/struct.SecretKey.html: struct secp256k1::SecretKey - SecretKey\n\u27e827\u27e9 https://docs.rs/secp256k1/latest/secp256k1/struct.SignOnlyPreallocated.html: struct secp256k1::SignOnlyPreallocated - SignOnlyPreallocated\n\u27e828\u27e9 https://docs.rs/secp256k1/latest/secp256k1/struct.VerifyOnlyPreallocated.html: struct secp256k1::VerifyOnlyPreallocated - VerifyOnlyPreallocated\n\u27e829\u27e9 https://docs.rs/secp256k1/latest/secp256k1/struct.XOnlyPublicKey.html: struct secp256k1::XOnlyPublicKey - XOnlyPublicKey\n\u27e830\u27e9 https://docs.rs/secp256k1/latest/secp256k1/#enums: \u00a7\n\u27e831\u27e9 https://docs.rs/secp256k1/latest/secp256k1/enum.All.html: enum secp256k1::All - All\n\u27e832\u27e9 https://docs.rs/secp256k1/latest/secp256k1/enum.Error.html: enum secp256k1::Error - Error\n\u27e833\u27e9 https://docs.rs/secp256k1/latest/secp256k1/enum.Parity.html: enum secp256k1::Parity - Parity\n\u27e834\u27e9 https://docs.rs/secp256k1/latest/secp256k1/enum.SignOnly.html: enum secp256k1::SignOnly - SignOnly\n\u27e835\u27e9 https://docs.rs/secp256k1/latest/secp256k1/enum.VerifyOnly.html: enum secp256k1::VerifyOnly - VerifyOnly\n\u27e836\u27e9 https://docs.rs/secp256k1/latest/secp256k1/#statics: \u00a7\n\u27e837\u27e9 https://docs.rs/secp256k1/latest/secp256k1/static.SECP256K1.html: static secp256k1::SECP256K1 - SECP256K1\n\u27e838\u27e9 https://docs.rs/secp256k1/latest/secp256k1/#traits: \u00a7\n\u27e839\u27e9 https://docs.rs/secp256k1/latest/secp256k1/trait.Context.html: trait secp256k1::Context - Context\n\u27e840\u27e9 https://docs.rs/secp256k1/latest/secp256k1/trait.PreallocatedContext.html: trait secp256k1::PreallocatedContext - PreallocatedContext\n\u27e841\u27e9 https://docs.rs/secp256k1/latest/secp256k1/trait.Signing.html: trait secp256k1::Signing - Signing\n\u27e842\u27e9 https://docs.rs/secp256k1/latest/secp256k1/trait.ThirtyTwoByteHash.html: trait secp256k1::ThirtyTwoByteHash - ThirtyTwoByteHash\n\u27e843\u27e9 https://docs.rs/secp256k1/latest/secp256k1/trait.Verification.html: trait secp256k1::Verification - Verification\n\u27e844\u27e9 https://docs.rs/secp256k1/latest/secp256k1/#functions: \u00a7\n\u27e845\u27e9 https://docs.rs/secp256k1/latest/secp256k1/fn.generate_keypair.html: fn secp256k1::generate_keypair - generate_keypair\n",
              "fit_markdown": "",
              "fit_html": ""
            },
            "structured_data": {},
            "quality_score": 4.0,
            "extraction_method": "crawl4ai",
            "error": null,
            "metadata": {
              "doc_type": "docs",
              "content_length": 13374,
              "has_structured_data": false,
              "crawl_success": true
            },
            "timestamp": "118498.6207084"
          },
          "lib_rs": {
            "url": "https://lib.rs/crates/secp256k1",
            "title": "Untitled",
            "content": {
              "raw_markdown": "###  [89 releases](https://lib.rs/crates/secp256k1/versions)\n[ new 0.31.1 ](https://github.com/rust-bitcoin/rust-secp256k1/blob/HEAD/CHANGELOG.md) |  Jun 23, 2025   \n---|---  \n0.30.0 |  Oct 9, 2024   \n0.29.0 |  Apr 2, 2024   \n0.28.2 |  Jan 31, 2024   \n0.1.2 |  May 4, 2015   \n#**2** in [#bitcoin](https://lib.rs/keywords/bitcoin)\nDownload history 274327/week @ 2025-03-07 264901/week @ 2025-03-14 268708/week @ 2025-03-21 257981/week @ 2025-03-28 285946/week @ 2025-04-04 246416/week @ 2025-04-11 246285/week @ 2025-04-18 279079/week @ 2025-04-25 256210/week @ 2025-05-02 276120/week @ 2025-05-09 304953/week @ 2025-05-16 276246/week @ 2025-05-23 270455/week @ 2025-05-30 279652/week @ 2025-06-06 299380/week @ 2025-06-13 329955/week @ 2025-06-20\n**1,226,448** downloads per month Used in [**2,517** crates (425 directly)](https://lib.rs/crates/secp256k1/rev)\n**CC0** license \n**3.5MB** **36K** SLoC\nC 27K SLoC // 0.0% comments  Rust 7K SLoC // 0.0% comments  GNU Style Assembly 753 SLoC // 0.1% comments  Python 444 SLoC // 0.3% comments  Shell 386 SLoC // 0.2% comments  Automake 253 SLoC // 0.1% comments  M4 67 SLoC // 0.2% comments  Just 20 SLoC // 0.3% comments \n# Rust Secp256k1\n[![Crate Info](https://img.shields.io/crates/v/secp256k1.svg)](https://crates.io/crates/secp256k1) [![CC0 1.0 Universal Licensed](https://img.shields.io/badge/license-CC0--1.0-blue.svg)](https://github.com/rust-bitcoin/rust-secp256k1/blob/master/LICENSE) [![CI Status](https://img.gs/czjpqfbdkz/full/https://github.com/rust-bitcoin/rust-secp256k1/workflows/Continuous%20integration/badge.svg)](https://github.com/rust-bitcoin/rust-secp256k1/actions?query=workflow%3AContinuous%20integration) [![API Docs](https://img.shields.io/badge/docs.rs-secp256k1-green)](https://docs.rs/secp256k1) [![Rustc Version 1.56.1+](https://img.shields.io/badge/rustc-1.56.1.0%2B-lightgrey.svg)](https://blog.rust-lang.org/2020/02/27/Rust-1.56.1.html)\n``rust-secp256k1`` is a wrapper around [libsecp256k1](https://github.com/bitcoin-core/secp256k1), a C library implementing various cryptographic functions using the [SECG](https://www.secg.org/) curve [secp256k1](https://en.bitcoin.it/wiki/Secp256k1).\nThis library:\n  * exposes type-safe Rust bindings for all ``libsecp256k1`` functions\n  * implements key generation\n  * implements deterministic nonce generation via RFC6979\n  * implements many unit tests, adding to those already present in ``libsecp256k1``\n  * makes no allocations (except in unit tests) for efficiency and use in freestanding implementations\n\n\n### Contributing\nContributions to this library are welcome. A few guidelines:\n  * Any breaking changes must have an accompanied entry in CHANGELOG.md\n  * No new dependencies, please.\n  * No crypto should be implemented in Rust, with the possible exception of hash functions. Cryptographic contributions should be directed upstream to libsecp256k1.\n  * This library should always compile with any combination of features on **Rust 1.56.1**.\n\n\n### Githooks\nTo assist devs in catching errors _before_ running CI we provide some githooks. If you do not already have locally configured githooks you can use the ones in this repository by running, in the root directory of the repository:\n```\n```git``` config`` --`local` core.hooksPath githooks/`\n`\n```\n\nAlternatively add symlinks in your ```.`git`/`hooks`` directory to any of the githooks we provide.\n### Benchmarks\nWe use a custom Rust compiler configuration conditional to guard the bench mark code. To run the bench marks use: ```RUSTFLAGS``=````'`--cfg=bench`'``` ``cargo``` +nightly bench`` --`features``=`recovery```.\n### A note on ``non_secure_erase``\nThis crate's secret types (``SecretKey``, ``Keypair``, ``SharedSecret``, ``Scalar``, and ``DisplaySecret``) have a method called ``non_secure_erase`` that _attempts_ to overwrite the contained secret. This method is provided to assist other libraries in building secure secret erasure. However, this library makes no guarantees about the security of using ``non_secure_erase``. In particular, the compiler doesn't have any concept of secrets and in most cases can arbitrarily move or copy values anywhere it pleases. For more information, consult the [``zeroize``](https://docs.rs/zeroize) documentation.\n## Fuzzing\nIf you want to fuzz this library, or any library which depends on it, you will probably want to disable the actual cryptography, since fuzzers are unable to forge signatures and therefore won't test many interesting codepaths. To instead use a trivially-broken but fuzzer-accessible signature scheme, compile with ``--cfg=secp256k1_fuzz`` in your ``RUSTFLAGS`` variable.\nNote that ````cargo``` hfuzz``` does **not** set this config flag automatically. In 0.27.0 and earlier versions, we used the ``--cfg=fuzzing`` which honggfuzz does set, but we changed this because there was no way to override it.\n#### Dependencies\n  * [hashes?](https://lib.rs/crates/secp256k1/features#feature-hashes \"optional feature\") [std?](https://lib.rs/crates/secp256k1/features#feature-std \"optional feature\") [bitcoin_hashes](https://lib.rs/crates/bitcoin_hashes \"renamed hashes, obsolete\") 0.14\n  * [rand?](https://lib.rs/crates/secp256k1/features#feature-rand \"optional feature\") [std?](https://lib.rs/crates/secp256k1/features#feature-std \"optional feature\") [rand](https://lib.rs/crates/rand \"new\") 0.9\n  * [secp256k1-sys](https://lib.rs/crates/secp256k1-sys \"new\") 0.11\n  * [ optional ](https://lib.rs/crates/secp256k1/features#feature-serde \"serde is optional feature\") [serde](https://lib.rs/crates/serde \"1.0.103\")\n\n\n  * dev  [bincode](https://lib.rs/crates/bincode \"1.3.3\")\n  * dev  [getrandom](https://lib.rs/crates/getrandom \"new\") 0.3[+wasm_js](https://lib.rs/crates/getrandom/features#feature-wasm_js) wasm32-unknown-unknown\n  * dev  [hex_lit](https://lib.rs/crates/hex_lit \"0.1.1\")\n  * dev  [rand_core](https://lib.rs/crates/rand_core \"new\") 0.9\n  * dev  [serde_cbor](https://lib.rs/crates/serde_cbor \"obsolete\") 0.10\n  * dev  [serde_test](https://lib.rs/crates/serde_test \"1.0.19\")\n  * dev  [wasm-bindgen-test](https://lib.rs/crates/wasm-bindgen-test \"0.3\") wasm32-unknown-unknown\n\n\n#### [Other features](https://lib.rs/crates/secp256k1/features)\n  * [alloc](https://lib.rs/crates/secp256k1/features#feature-alloc)\n  * [global-context](https://lib.rs/crates/secp256k1/features#feature-global-context)\n  * [global-context-less-secure](https://lib.rs/crates/secp256k1/features#feature-global-context-less-secure)\n  * [lowmemory](https://lib.rs/crates/secp256k1/features#feature-lowmemory)\n  * [recovery](https://lib.rs/crates/secp256k1/features#feature-recovery)\n\n\n  *[SLoC]: Lines of code, excluding comments\n",
              "markdown_with_citations": "###  89 releases\u27e81\u27e9\n new 0.31.1 \u27e82\u27e9 |  Jun 23, 2025   \n---|---  \n0.30.0 |  Oct 9, 2024   \n0.29.0 |  Apr 2, 2024   \n0.28.2 |  Jan 31, 2024   \n0.1.2 |  May 4, 2015   \n#**2** in #bitcoin\u27e83\u27e9\nDownload history 274327/week @ 2025-03-07 264901/week @ 2025-03-14 268708/week @ 2025-03-21 257981/week @ 2025-03-28 285946/week @ 2025-04-04 246416/week @ 2025-04-11 246285/week @ 2025-04-18 279079/week @ 2025-04-25 256210/week @ 2025-05-02 276120/week @ 2025-05-09 304953/week @ 2025-05-16 276246/week @ 2025-05-23 270455/week @ 2025-05-30 279652/week @ 2025-06-06 299380/week @ 2025-06-13 329955/week @ 2025-06-20\n**1,226,448** downloads per month Used in **2,517** crates (425 directly)\u27e84\u27e9\n**CC0** license \n**3.5MB** **36K** SLoC\nC 27K SLoC // 0.0% comments  Rust 7K SLoC // 0.0% comments  GNU Style Assembly 753 SLoC // 0.1% comments  Python 444 SLoC // 0.3% comments  Shell 386 SLoC // 0.2% comments  Automake 253 SLoC // 0.1% comments  M4 67 SLoC // 0.2% comments  Just 20 SLoC // 0.3% comments \n# Rust Secp256k1\n![Crate Info\u27e85\u27e9](https://crates.io/crates/secp256k1) ![CC0 1.0 Universal Licensed\u27e86\u27e9](https://github.com/rust-bitcoin/rust-secp256k1/blob/master/LICENSE) ![CI Status\u27e87\u27e9](https://github.com/rust-bitcoin/rust-secp256k1/actions?query=workflow%3AContinuous%20integration) ![API Docs\u27e88\u27e9](https://docs.rs/secp256k1) ![Rustc Version 1.56.1+\u27e89\u27e9](https://blog.rust-lang.org/2020/02/27/Rust-1.56.1.html)\n``rust-secp256k1`` is a wrapper around libsecp256k1\u27e810\u27e9, a C library implementing various cryptographic functions using the SECG\u27e811\u27e9 curve secp256k1\u27e812\u27e9.\nThis library:\n  * exposes type-safe Rust bindings for all ``libsecp256k1`` functions\n  * implements key generation\n  * implements deterministic nonce generation via RFC6979\n  * implements many unit tests, adding to those already present in ``libsecp256k1``\n  * makes no allocations (except in unit tests) for efficiency and use in freestanding implementations\n\n\n### Contributing\nContributions to this library are welcome. A few guidelines:\n  * Any breaking changes must have an accompanied entry in CHANGELOG.md\n  * No new dependencies, please.\n  * No crypto should be implemented in Rust, with the possible exception of hash functions. Cryptographic contributions should be directed upstream to libsecp256k1.\n  * This library should always compile with any combination of features on **Rust 1.56.1**.\n\n\n### Githooks\nTo assist devs in catching errors _before_ running CI we provide some githooks. If you do not already have locally configured githooks you can use the ones in this repository by running, in the root directory of the repository:\n```\n```git``` config`` --`local` core.hooksPath githooks/`\n`\n```\n\nAlternatively add symlinks in your ```.`git`/`hooks`` directory to any of the githooks we provide.\n### Benchmarks\nWe use a custom Rust compiler configuration conditional to guard the bench mark code. To run the bench marks use: ```RUSTFLAGS``=````'`--cfg=bench`'``` ``cargo``` +nightly bench`` --`features``=`recovery```.\n### A note on ``non_secure_erase``\nThis crate's secret types (``SecretKey``, ``Keypair``, ``SharedSecret``, ``Scalar``, and ``DisplaySecret``) have a method called ``non_secure_erase`` that _attempts_ to overwrite the contained secret. This method is provided to assist other libraries in building secure secret erasure. However, this library makes no guarantees about the security of using ``non_secure_erase``. In particular, the compiler doesn't have any concept of secrets and in most cases can arbitrarily move or copy values anywhere it pleases. For more information, consult the ``zeroize``\u27e813\u27e9 documentation.\n## Fuzzing\nIf you want to fuzz this library, or any library which depends on it, you will probably want to disable the actual cryptography, since fuzzers are unable to forge signatures and therefore won't test many interesting codepaths. To instead use a trivially-broken but fuzzer-accessible signature scheme, compile with ``--cfg=secp256k1_fuzz`` in your ``RUSTFLAGS`` variable.\nNote that ````cargo``` hfuzz``` does **not** set this config flag automatically. In 0.27.0 and earlier versions, we used the ``--cfg=fuzzing`` which honggfuzz does set, but we changed this because there was no way to override it.\n#### Dependencies\n  * hashes?\u27e814\u27e9 std?\u27e815\u27e9 bitcoin_hashes\u27e816\u27e9 0.14\n  * rand?\u27e817\u27e9 std?\u27e815\u27e9 rand\u27e818\u27e9 0.9\n  * secp256k1-sys\u27e819\u27e9 0.11\n  *  optional \u27e820\u27e9 serde\u27e821\u27e9\n\n\n  * dev  bincode\u27e822\u27e9\n  * dev  getrandom\u27e823\u27e9 0.3+wasm_js\u27e824\u27e9 wasm32-unknown-unknown\n  * dev  hex_lit\u27e825\u27e9\n  * dev  rand_core\u27e826\u27e9 0.9\n  * dev  serde_cbor\u27e827\u27e9 0.10\n  * dev  serde_test\u27e828\u27e9\n  * dev  wasm-bindgen-test\u27e829\u27e9 wasm32-unknown-unknown\n\n\n#### Other features\u27e830\u27e9\n  * alloc\u27e831\u27e9\n  * global-context\u27e832\u27e9\n  * global-context-less-secure\u27e833\u27e9\n  * lowmemory\u27e834\u27e9\n  * recovery\u27e835\u27e9\n\n\n  *[SLoC]: Lines of code, excluding comments\n",
              "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://lib.rs/crates/secp256k1/versions: 89 releases\n\u27e82\u27e9 https://github.com/rust-bitcoin/rust-secp256k1/blob/HEAD/CHANGELOG.md:  new 0.31.1 \n\u27e83\u27e9 https://lib.rs/keywords/bitcoin: #bitcoin\n\u27e84\u27e9 https://lib.rs/crates/secp256k1/rev: **2,517** crates (425 directly)\n\u27e85\u27e9 https://img.shields.io/crates/v/secp256k1.svg: ![Crate Info\n\u27e86\u27e9 https://img.shields.io/badge/license-CC0--1.0-blue.svg: ![CC0 1.0 Universal Licensed\n\u27e87\u27e9 https://img.gs/czjpqfbdkz/full/https://github.com/rust-bitcoin/rust-secp256k1/workflows/Continuous%20integration/badge.svg: ![CI Status\n\u27e88\u27e9 https://img.shields.io/badge/docs.rs-secp256k1-green: ![API Docs\n\u27e89\u27e9 https://img.shields.io/badge/rustc-1.56.1.0%2B-lightgrey.svg: ![Rustc Version 1.56.1+\n\u27e810\u27e9 https://github.com/bitcoin-core/secp256k1: libsecp256k1\n\u27e811\u27e9 https://www.secg.org/: SECG\n\u27e812\u27e9 https://en.bitcoin.it/wiki/Secp256k1: secp256k1\n\u27e813\u27e9 https://docs.rs/zeroize: ``zeroize``\n\u27e814\u27e9 https://lib.rs/crates/secp256k1/features#feature-hashes: optional feature - hashes?\n\u27e815\u27e9 https://lib.rs/crates/secp256k1/features#feature-std: optional feature - std?\n\u27e816\u27e9 https://lib.rs/crates/bitcoin_hashes: renamed hashes, obsolete - bitcoin_hashes\n\u27e817\u27e9 https://lib.rs/crates/secp256k1/features#feature-rand: optional feature - rand?\n\u27e818\u27e9 https://lib.rs/crates/rand: new - rand\n\u27e819\u27e9 https://lib.rs/crates/secp256k1-sys: new - secp256k1-sys\n\u27e820\u27e9 https://lib.rs/crates/secp256k1/features#feature-serde: serde is optional feature -  optional \n\u27e821\u27e9 https://lib.rs/crates/serde: 1.0.103 - serde\n\u27e822\u27e9 https://lib.rs/crates/bincode: 1.3.3 - bincode\n\u27e823\u27e9 https://lib.rs/crates/getrandom: new - getrandom\n\u27e824\u27e9 https://lib.rs/crates/getrandom/features#feature-wasm_js: +wasm_js\n\u27e825\u27e9 https://lib.rs/crates/hex_lit: 0.1.1 - hex_lit\n\u27e826\u27e9 https://lib.rs/crates/rand_core: new - rand_core\n\u27e827\u27e9 https://lib.rs/crates/serde_cbor: obsolete - serde_cbor\n\u27e828\u27e9 https://lib.rs/crates/serde_test: 1.0.19 - serde_test\n\u27e829\u27e9 https://lib.rs/crates/wasm-bindgen-test: 0.3 - wasm-bindgen-test\n\u27e830\u27e9 https://lib.rs/crates/secp256k1/features: Other features\n\u27e831\u27e9 https://lib.rs/crates/secp256k1/features#feature-alloc: alloc\n\u27e832\u27e9 https://lib.rs/crates/secp256k1/features#feature-global-context: global-context\n\u27e833\u27e9 https://lib.rs/crates/secp256k1/features#feature-global-context-less-secure: global-context-less-secure\n\u27e834\u27e9 https://lib.rs/crates/secp256k1/features#feature-lowmemory: lowmemory\n\u27e835\u27e9 https://lib.rs/crates/secp256k1/features#feature-recovery: recovery\n",
              "fit_markdown": "",
              "fit_html": ""
            },
            "structured_data": {},
            "quality_score": 3.0,
            "extraction_method": "crawl4ai",
            "error": null,
            "metadata": {
              "doc_type": "docs",
              "content_length": 6657,
              "has_structured_data": false,
              "crawl_success": true
            },
            "timestamp": "118499.2500543"
          }
        },
        "crate_analysis": {
          "status": "completed",
          "check": [
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#shlex@1.3.0",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\shlex-1.3.0\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "shlex",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\shlex-1.3.0\\src\\lib.rs",
                "edition": "2015",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "default",
                "std"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp403dor5l\\secp256k1-0.31.1\\target\\debug\\deps\\libshlex-25724775bd6ea405.rlib",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp403dor5l\\secp256k1-0.31.1\\target\\debug\\deps\\libshlex-25724775bd6ea405.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#cc@1.2.22",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\cc-1.2.22\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "cc",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\cc-1.2.22\\src\\lib.rs",
                "edition": "2018",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp403dor5l\\secp256k1-0.31.1\\target\\debug\\deps\\libcc-0540a6c27d718959.rlib",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp403dor5l\\secp256k1-0.31.1\\target\\debug\\deps\\libcc-0540a6c27d718959.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#secp256k1-sys@0.11.0",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\secp256k1-sys-0.11.0\\Cargo.toml",
              "target": {
                "kind": [
                  "custom-build"
                ],
                "crate_types": [
                  "bin"
                ],
                "name": "build-script-build",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\secp256k1-sys-0.11.0\\build.rs",
                "edition": "2021",
                "doc": false,
                "doctest": false,
                "test": false
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "alloc",
                "std"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp403dor5l\\secp256k1-0.31.1\\target\\debug\\build\\secp256k1-sys-c5c63a25559c9bc1\\build-script-build.exe",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp403dor5l\\secp256k1-0.31.1\\target\\debug\\build\\secp256k1-sys-c5c63a25559c9bc1\\build_script_build.pdb"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "build-script-executed",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#secp256k1-sys@0.11.0",
              "linked_libs": [
                "static=secp256k1"
              ],
              "linked_paths": [
                "native=C:\\Users\\davet\\AppData\\Local\\Temp\\tmp403dor5l\\secp256k1-0.31.1\\target\\debug\\build\\secp256k1-sys-559a4ecbf28b85b7\\out"
              ],
              "cfgs": [],
              "env": [],
              "out_dir": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp403dor5l\\secp256k1-0.31.1\\target\\debug\\build\\secp256k1-sys-559a4ecbf28b85b7\\out"
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#secp256k1-sys@0.11.0",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\secp256k1-sys-0.11.0\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "secp256k1_sys",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\secp256k1-sys-0.11.0\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "alloc",
                "std"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp403dor5l\\secp256k1-0.31.1\\target\\debug\\deps\\libsecp256k1_sys-5d62fdd9a1f3a88c.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "compiler-artifact",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmp403dor5l/secp256k1-0.31.1#secp256k1@0.31.1",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp403dor5l\\secp256k1-0.31.1\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "secp256k1",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp403dor5l\\secp256k1-0.31.1\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "alloc",
                "default",
                "std"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp403dor5l\\secp256k1-0.31.1\\target\\debug\\deps\\libsecp256k1-974895d26c322830.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "build-finished",
              "success": true
            }
          ],
          "clippy": [
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#shlex@1.3.0",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\shlex-1.3.0\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "shlex",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\shlex-1.3.0\\src\\lib.rs",
                "edition": "2015",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "default",
                "std"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp403dor5l\\secp256k1-0.31.1\\target\\debug\\deps\\libshlex-25724775bd6ea405.rlib",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp403dor5l\\secp256k1-0.31.1\\target\\debug\\deps\\libshlex-25724775bd6ea405.rmeta"
              ],
              "executable": null,
              "fresh": true
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#cc@1.2.22",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\cc-1.2.22\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "cc",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\cc-1.2.22\\src\\lib.rs",
                "edition": "2018",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp403dor5l\\secp256k1-0.31.1\\target\\debug\\deps\\libcc-0540a6c27d718959.rlib",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp403dor5l\\secp256k1-0.31.1\\target\\debug\\deps\\libcc-0540a6c27d718959.rmeta"
              ],
              "executable": null,
              "fresh": true
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#secp256k1-sys@0.11.0",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\secp256k1-sys-0.11.0\\Cargo.toml",
              "target": {
                "kind": [
                  "custom-build"
                ],
                "crate_types": [
                  "bin"
                ],
                "name": "build-script-build",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\secp256k1-sys-0.11.0\\build.rs",
                "edition": "2021",
                "doc": false,
                "doctest": false,
                "test": false
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "alloc",
                "std"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp403dor5l\\secp256k1-0.31.1\\target\\debug\\build\\secp256k1-sys-c5c63a25559c9bc1\\build-script-build.exe",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp403dor5l\\secp256k1-0.31.1\\target\\debug\\build\\secp256k1-sys-c5c63a25559c9bc1\\build_script_build.pdb"
              ],
              "executable": null,
              "fresh": true
            },
            {
              "reason": "build-script-executed",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#secp256k1-sys@0.11.0",
              "linked_libs": [
                "static=secp256k1"
              ],
              "linked_paths": [
                "native=C:\\Users\\davet\\AppData\\Local\\Temp\\tmp403dor5l\\secp256k1-0.31.1\\target\\debug\\build\\secp256k1-sys-559a4ecbf28b85b7\\out"
              ],
              "cfgs": [],
              "env": [],
              "out_dir": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp403dor5l\\secp256k1-0.31.1\\target\\debug\\build\\secp256k1-sys-559a4ecbf28b85b7\\out"
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#secp256k1-sys@0.11.0",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\secp256k1-sys-0.11.0\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "secp256k1_sys",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\secp256k1-sys-0.11.0\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "alloc",
                "std"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp403dor5l\\secp256k1-0.31.1\\target\\debug\\deps\\libsecp256k1_sys-5d62fdd9a1f3a88c.rmeta"
              ],
              "executable": null,
              "fresh": true
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmp403dor5l/secp256k1-0.31.1#secp256k1@0.31.1",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp403dor5l\\secp256k1-0.31.1\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "secp256k1",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp403dor5l\\secp256k1-0.31.1\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: variables can be used directly in the `format!` string\n  --> src\\secret.rs:72:13\n   |\n72 |             write!(f, \"{:02x}\", byte)?;\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#uninlined_format_args\n   = note: `#[warn(clippy::uninlined_format_args)]` on by default\nhelp: change this to\n   |\n72 -             write!(f, \"{:02x}\", byte)?;\n72 +             write!(f, \"{byte:02x}\")?;\n   |\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#uninlined_format_args",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "note",
                    "message": "`#[warn(clippy::uninlined_format_args)]` on by default",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "change this to",
                    "rendered": null,
                    "spans": [
                      {
                        "byte_end": 2653,
                        "byte_start": 2653,
                        "column_end": 25,
                        "column_start": 25,
                        "expansion": null,
                        "file_name": "src\\secret.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 72,
                        "line_start": 72,
                        "suggested_replacement": "byte",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 25,
                            "highlight_start": 25,
                            "text": "            write!(f, \"{:02x}\", byte)?;"
                          }
                        ]
                      },
                      {
                        "byte_end": 2665,
                        "byte_start": 2659,
                        "column_end": 37,
                        "column_start": 31,
                        "expansion": null,
                        "file_name": "src\\secret.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 72,
                        "line_start": 72,
                        "suggested_replacement": "",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 37,
                            "highlight_start": 31,
                            "text": "            write!(f, \"{:02x}\", byte)?;"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "code": {
                  "code": "clippy::uninlined_format_args",
                  "explanation": null
                },
                "level": "warning",
                "message": "variables can be used directly in the `format!` string",
                "spans": [
                  {
                    "byte_end": 2666,
                    "byte_start": 2641,
                    "column_end": 38,
                    "column_start": 13,
                    "expansion": null,
                    "file_name": "src\\secret.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 72,
                    "line_start": 72,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 38,
                        "highlight_start": 13,
                        "text": "            write!(f, \"{:02x}\", byte)?;"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmp403dor5l/secp256k1-0.31.1#secp256k1@0.31.1",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp403dor5l\\secp256k1-0.31.1\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "secp256k1",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp403dor5l\\secp256k1-0.31.1\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: variables can be used directly in the `format!` string\n  --> src\\ecdsa\\serialized_signature.rs:34:13\n   |\n34 |             write!(f, \"{:02x}\", v)?;\n   |             ^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#uninlined_format_args\nhelp: change this to\n   |\n34 -             write!(f, \"{:02x}\", v)?;\n34 +             write!(f, \"{v:02x}\")?;\n   |\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#uninlined_format_args",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "change this to",
                    "rendered": null,
                    "spans": [
                      {
                        "byte_end": 1034,
                        "byte_start": 1034,
                        "column_end": 25,
                        "column_start": 25,
                        "expansion": null,
                        "file_name": "src\\ecdsa\\serialized_signature.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 34,
                        "line_start": 34,
                        "suggested_replacement": "v",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 25,
                            "highlight_start": 25,
                            "text": "            write!(f, \"{:02x}\", v)?;"
                          }
                        ]
                      },
                      {
                        "byte_end": 1043,
                        "byte_start": 1040,
                        "column_end": 34,
                        "column_start": 31,
                        "expansion": null,
                        "file_name": "src\\ecdsa\\serialized_signature.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 34,
                        "line_start": 34,
                        "suggested_replacement": "",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 34,
                            "highlight_start": 31,
                            "text": "            write!(f, \"{:02x}\", v)?;"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "code": {
                  "code": "clippy::uninlined_format_args",
                  "explanation": null
                },
                "level": "warning",
                "message": "variables can be used directly in the `format!` string",
                "spans": [
                  {
                    "byte_end": 1044,
                    "byte_start": 1022,
                    "column_end": 35,
                    "column_start": 13,
                    "expansion": null,
                    "file_name": "src\\ecdsa\\serialized_signature.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 34,
                    "line_start": 34,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 35,
                        "highlight_start": 13,
                        "text": "            write!(f, \"{:02x}\", v)?;"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmp403dor5l/secp256k1-0.31.1#secp256k1@0.31.1",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp403dor5l\\secp256k1-0.31.1\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "secp256k1",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp403dor5l\\secp256k1-0.31.1\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: variables can be used directly in the `format!` string\n   --> src\\ecdsa\\serialized_signature.rs:146:9\n    |\n146 |         assert!(len <= MAX_LEN, \"attempt to set length to {} but the maximum is {}\", len, MAX_LEN);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#uninlined_format_args\nhelp: change this to\n    |\n146 -         assert!(len <= MAX_LEN, \"attempt to set length to {} but the maximum is {}\", len, MAX_LEN);\n146 +         assert!(len <= MAX_LEN, \"attempt to set length to {len} but the maximum is {MAX_LEN}\");\n    |\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#uninlined_format_args",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "change this to",
                    "rendered": null,
                    "spans": [
                      {
                        "byte_end": 3946,
                        "byte_start": 3946,
                        "column_end": 60,
                        "column_start": 60,
                        "expansion": null,
                        "file_name": "src\\ecdsa\\serialized_signature.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 146,
                        "line_start": 146,
                        "suggested_replacement": "len",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 60,
                            "highlight_start": 60,
                            "text": "        assert!(len <= MAX_LEN, \"attempt to set length to {} but the maximum is {}\", len, MAX_LEN);"
                          }
                        ]
                      },
                      {
                        "byte_end": 3968,
                        "byte_start": 3968,
                        "column_end": 82,
                        "column_start": 82,
                        "expansion": null,
                        "file_name": "src\\ecdsa\\serialized_signature.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 146,
                        "line_start": 146,
                        "suggested_replacement": "MAX_LEN",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 82,
                            "highlight_start": 82,
                            "text": "        assert!(len <= MAX_LEN, \"attempt to set length to {} but the maximum is {}\", len, MAX_LEN);"
                          }
                        ]
                      },
                      {
                        "byte_end": 3975,
                        "byte_start": 3970,
                        "column_end": 89,
                        "column_start": 84,
                        "expansion": null,
                        "file_name": "src\\ecdsa\\serialized_signature.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 146,
                        "line_start": 146,
                        "suggested_replacement": "",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 89,
                            "highlight_start": 84,
                            "text": "        assert!(len <= MAX_LEN, \"attempt to set length to {} but the maximum is {}\", len, MAX_LEN);"
                          }
                        ]
                      },
                      {
                        "byte_end": 3984,
                        "byte_start": 3975,
                        "column_end": 98,
                        "column_start": 89,
                        "expansion": null,
                        "file_name": "src\\ecdsa\\serialized_signature.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 146,
                        "line_start": 146,
                        "suggested_replacement": "",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 98,
                            "highlight_start": 89,
                            "text": "        assert!(len <= MAX_LEN, \"attempt to set length to {} but the maximum is {}\", len, MAX_LEN);"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "code": {
                  "code": "clippy::uninlined_format_args",
                  "explanation": null
                },
                "level": "warning",
                "message": "variables can be used directly in the `format!` string",
                "spans": [
                  {
                    "byte_end": 3985,
                    "byte_start": 3895,
                    "column_end": 99,
                    "column_start": 9,
                    "expansion": null,
                    "file_name": "src\\ecdsa\\serialized_signature.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 146,
                    "line_start": 146,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 99,
                        "highlight_start": 9,
                        "text": "        assert!(len <= MAX_LEN, \"attempt to set length to {} but the maximum is {}\", len, MAX_LEN);"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmp403dor5l/secp256k1-0.31.1#secp256k1@0.31.1",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp403dor5l\\secp256k1-0.31.1\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "secp256k1",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp403dor5l\\secp256k1-0.31.1\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: variables can be used directly in the `format!` string\n   --> src\\ellswift.rs:348:13\n    |\n348 |             write!(f, \"{:02x}\", ch)?;\n    |             ^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#uninlined_format_args\nhelp: change this to\n    |\n348 -             write!(f, \"{:02x}\", ch)?;\n348 +             write!(f, \"{ch:02x}\")?;\n    |\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#uninlined_format_args",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "change this to",
                    "rendered": null,
                    "spans": [
                      {
                        "byte_end": 13335,
                        "byte_start": 13335,
                        "column_end": 25,
                        "column_start": 25,
                        "expansion": null,
                        "file_name": "src\\ellswift.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 348,
                        "line_start": 348,
                        "suggested_replacement": "ch",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 25,
                            "highlight_start": 25,
                            "text": "            write!(f, \"{:02x}\", ch)?;"
                          }
                        ]
                      },
                      {
                        "byte_end": 13345,
                        "byte_start": 13341,
                        "column_end": 35,
                        "column_start": 31,
                        "expansion": null,
                        "file_name": "src\\ellswift.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 348,
                        "line_start": 348,
                        "suggested_replacement": "",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 35,
                            "highlight_start": 31,
                            "text": "            write!(f, \"{:02x}\", ch)?;"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "code": {
                  "code": "clippy::uninlined_format_args",
                  "explanation": null
                },
                "level": "warning",
                "message": "variables can be used directly in the `format!` string",
                "spans": [
                  {
                    "byte_end": 13346,
                    "byte_start": 13323,
                    "column_end": 36,
                    "column_start": 13,
                    "expansion": null,
                    "file_name": "src\\ellswift.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 348,
                    "line_start": 348,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 36,
                        "highlight_start": 13,
                        "text": "            write!(f, \"{:02x}\", ch)?;"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmp403dor5l/secp256k1-0.31.1#secp256k1@0.31.1",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp403dor5l\\secp256k1-0.31.1\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "secp256k1",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp403dor5l\\secp256k1-0.31.1\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: variables can be used directly in the `format!` string\n  --> src\\schnorr.rs:54:13\n   |\n54 |             write!(f, \"{:02x}\", ch)?;\n   |             ^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#uninlined_format_args\nhelp: change this to\n   |\n54 -             write!(f, \"{:02x}\", ch)?;\n54 +             write!(f, \"{ch:02x}\")?;\n   |\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#uninlined_format_args",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "change this to",
                    "rendered": null,
                    "spans": [
                      {
                        "byte_end": 1696,
                        "byte_start": 1696,
                        "column_end": 25,
                        "column_start": 25,
                        "expansion": null,
                        "file_name": "src\\schnorr.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 54,
                        "line_start": 54,
                        "suggested_replacement": "ch",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 25,
                            "highlight_start": 25,
                            "text": "            write!(f, \"{:02x}\", ch)?;"
                          }
                        ]
                      },
                      {
                        "byte_end": 1706,
                        "byte_start": 1702,
                        "column_end": 35,
                        "column_start": 31,
                        "expansion": null,
                        "file_name": "src\\schnorr.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 54,
                        "line_start": 54,
                        "suggested_replacement": "",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 35,
                            "highlight_start": 31,
                            "text": "            write!(f, \"{:02x}\", ch)?;"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "code": {
                  "code": "clippy::uninlined_format_args",
                  "explanation": null
                },
                "level": "warning",
                "message": "variables can be used directly in the `format!` string",
                "spans": [
                  {
                    "byte_end": 1707,
                    "byte_start": 1684,
                    "column_end": 36,
                    "column_start": 13,
                    "expansion": null,
                    "file_name": "src\\schnorr.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 54,
                    "line_start": 54,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 36,
                        "highlight_start": 13,
                        "text": "            write!(f, \"{:02x}\", ch)?;"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-message",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmp403dor5l/secp256k1-0.31.1#secp256k1@0.31.1",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp403dor5l\\secp256k1-0.31.1\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "secp256k1",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp403dor5l\\secp256k1-0.31.1\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "message": {
                "rendered": "warning: variables can be used directly in the `format!` string\n   --> src\\lib.rs:273:13\n    |\n273 |             write!(f, \"{:02x}\", byte)?;\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#uninlined_format_args\nhelp: change this to\n    |\n273 -             write!(f, \"{:02x}\", byte)?;\n273 +             write!(f, \"{byte:02x}\")?;\n    |\n\n",
                "$message_type": "diagnostic",
                "children": [
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#uninlined_format_args",
                    "rendered": null,
                    "spans": []
                  },
                  {
                    "children": [],
                    "code": null,
                    "level": "help",
                    "message": "change this to",
                    "rendered": null,
                    "spans": [
                      {
                        "byte_end": 11209,
                        "byte_start": 11209,
                        "column_end": 25,
                        "column_start": 25,
                        "expansion": null,
                        "file_name": "src\\lib.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 273,
                        "line_start": 273,
                        "suggested_replacement": "byte",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 25,
                            "highlight_start": 25,
                            "text": "            write!(f, \"{:02x}\", byte)?;"
                          }
                        ]
                      },
                      {
                        "byte_end": 11221,
                        "byte_start": 11215,
                        "column_end": 37,
                        "column_start": 31,
                        "expansion": null,
                        "file_name": "src\\lib.rs",
                        "is_primary": true,
                        "label": null,
                        "line_end": 273,
                        "line_start": 273,
                        "suggested_replacement": "",
                        "suggestion_applicability": "MachineApplicable",
                        "text": [
                          {
                            "highlight_end": 37,
                            "highlight_start": 31,
                            "text": "            write!(f, \"{:02x}\", byte)?;"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "code": {
                  "code": "clippy::uninlined_format_args",
                  "explanation": null
                },
                "level": "warning",
                "message": "variables can be used directly in the `format!` string",
                "spans": [
                  {
                    "byte_end": 11222,
                    "byte_start": 11197,
                    "column_end": 38,
                    "column_start": 13,
                    "expansion": null,
                    "file_name": "src\\lib.rs",
                    "is_primary": true,
                    "label": null,
                    "line_end": 273,
                    "line_start": 273,
                    "suggested_replacement": null,
                    "suggestion_applicability": null,
                    "text": [
                      {
                        "highlight_end": 38,
                        "highlight_start": 13,
                        "text": "            write!(f, \"{:02x}\", byte)?;"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "reason": "compiler-artifact",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmp403dor5l/secp256k1-0.31.1#secp256k1@0.31.1",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp403dor5l\\secp256k1-0.31.1\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "secp256k1",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp403dor5l\\secp256k1-0.31.1\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "alloc",
                "default",
                "std"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmp403dor5l\\secp256k1-0.31.1\\target\\debug\\deps\\libsecp256k1-4eb7ae72add71e3a.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "build-finished",
              "success": true
            }
          ],
          "audit": {
            "database": {
              "advisory-count": 787,
              "last-commit": "7573f55ba337263f61167dbb0ea926cdc7c8eb5d",
              "last-updated": "2025-06-17T11:04:25+02:00"
            },
            "lockfile": {
              "dependency-count": 60
            },
            "settings": {
              "target_arch": [],
              "target_os": [],
              "severity": null,
              "ignore": [],
              "informational_warnings": [
                "unmaintained",
                "unsound",
                "notice"
              ]
            },
            "vulnerabilities": {
              "found": false,
              "count": 0,
              "list": []
            },
            "warnings": {
              "unmaintained": [
                {
                  "kind": "unmaintained",
                  "package": {
                    "name": "serde_cbor",
                    "version": "0.10.2",
                    "source": "registry+https://github.com/rust-lang/crates.io-index",
                    "checksum": "f7081ed758ec726a6ed8ee7e92f5d3f6e6f8c3901b1f972e3a4a2f2599fad14f",
                    "dependencies": [
                      {
                        "name": "byteorder",
                        "version": "1.5.0",
                        "source": "registry+https://github.com/rust-lang/crates.io-index"
                      },
                      {
                        "name": "half",
                        "version": "1.8.3",
                        "source": "registry+https://github.com/rust-lang/crates.io-index"
                      },
                      {
                        "name": "serde",
                        "version": "1.0.219",
                        "source": "registry+https://github.com/rust-lang/crates.io-index"
                      }
                    ],
                    "replace": null
                  },
                  "advisory": {
                    "id": "RUSTSEC-2021-0127",
                    "package": "serde_cbor",
                    "title": "serde_cbor is unmaintained",
                    "description": "The `serde_cbor` crate is unmaintained. The author has archived the github repository.\n\nAlternatives proposed by the author:\n\n * [`ciborium`](https://crates.io/crates/ciborium)\n * [`minicbor`](https://crates.io/crates/minicbor)",
                    "date": "2021-08-15",
                    "aliases": [],
                    "related": [],
                    "collection": "crates",
                    "categories": [],
                    "keywords": [],
                    "cvss": null,
                    "informational": "unmaintained",
                    "references": [],
                    "source": null,
                    "url": "https://github.com/pyfisch/cbor",
                    "withdrawn": null,
                    "license": "CC0-1.0"
                  },
                  "affected": null,
                  "versions": {
                    "patched": [],
                    "unaffected": []
                  }
                }
              ]
            }
          },
          "note": "Crate analysis performed with stable toolchain."
        },
        "crate_metadata": {
          "name": "secp256k1",
          "version": "0.31.1",
          "description": "ALLOW: Positive community sentiment",
          "repository": "",
          "keywords": [],
          "categories": [],
          "readme": {
            "raw_markdown": "[](https://docs.rs/secp256k1/latest/secp256k1/all.html \"show sidebar\")\n# Crate secp256k1Copy item path\n[Settings](https://docs.rs/secp256k1/latest/settings.html)\n[Help](https://docs.rs/secp256k1/latest/help.html)\nSummary[Source](https://docs.rs/secp256k1/latest/src/secp256k1/lib.rs.html#3-1052)\nExpand description\nRust bindings for Pieter Wuille\u2019s secp256k1 library, which is used for fast and accurate manipulation of ECDSA and Schnorr signatures on the secp256k1 curve. Such signatures are used extensively by the Bitcoin network and its derivatives.\nTo minimize dependencies, some functions are feature-gated. To generate random keys or to re-randomize a context object, compile with the `rand` and `std` features. If you are willing to use these features, we have enabled an additional defense-in-depth sidechannel protection for our context objects, which re-blinds certain operations on secret key data. To de/serialize objects with serde, compile with \u201cserde\u201d. **Important** : `serde` encoding is **not** the same as consensus encoding!\nWhere possible, the bindings use the Rust type system to ensure that API usage errors are impossible. For example, the library uses context objects that contain precomputation tables which are created on object construction. Since this is a slow operation (10+ milliseconds, vs ~50 microseconds for typical crypto operations, on a 2.70 Ghz i7-6820HQ) the tables are optional, giving a performance boost for users who only care about signing, only care about verification, or only care about parsing. In the upstream library, if you attempt to sign a message using a context that does not support this, it will trigger an assertion failure and terminate the program. In `rust-secp256k1`, this is caught at compile-time; in fact, it is impossible to compile code that will trigger any assertion failures in the upstream library.\n```\nuse secp256k1::rand;\nuse secp256k1::{Secp256k1, Message};\nuse secp256k1::hashes::{sha256, Hash};\nlet secp = Secp256k1::new();\nlet (secret_key, public_key) = secp.generate_keypair(&mut rand::rng());\nlet digest = sha256::Hash::hash(\"Hello World!\".as_bytes());\nlet message = Message::from_digest(digest.to_byte_array());\nlet sig = secp.sign_ecdsa(message, &secret_key);\nassert!(secp.verify_ecdsa(message, &sig, &public_key).is_ok());\n```\n\nIf the \u201cglobal-context\u201d feature is enabled you have access to an alternate API.\n```\nuse secp256k1::{rand, generate_keypair, Message};\nuse secp256k1::hashes::{sha256, Hash};\nlet (secret_key, public_key) = generate_keypair(&mut rand::rng());\nlet digest = sha256::Hash::hash(\"Hello World!\".as_bytes());\nlet message = Message::from_digest(digest.to_byte_array());\nlet sig = secret_key.sign_ecdsa(message);\nassert!(sig.verify(message, &public_key).is_ok());\n```\n\nThe above code requires `rust-secp256k1` to be compiled with the `rand`, `hashes`, and `std` feature enabled, to get access to [`generate_keypair`](https://docs.rs/secp256k1/latest/secp256k1/struct.Secp256k1.html#method.generate_keypair) Alternately, keys and messages can be parsed from slices, like\n```\nuse secp256k1::{Secp256k1, Message, SecretKey, PublicKey};\nlet secp = Secp256k1::new();\nlet secret_key = SecretKey::from_slice(&[0xcd; 32]).expect(\"32 bytes, within curve order\");\nlet public_key = PublicKey::from_secret_key(&secp, &secret_key);\n// If the supplied byte slice was *not* the output of a cryptographic hash function this would\n// be cryptographically broken. It has been trivially used in the past to execute attacks.\nlet message = Message::from_digest(compute_hash(b\"CSW is not Satoshi\"));\nlet sig = secp.sign_ecdsa(message, &secret_key);\nassert!(secp.verify_ecdsa(message, &sig, &public_key).is_ok());\n```\n\nUsers who only want to verify signatures can use a cheaper context, like so:\n```\nuse secp256k1::{Secp256k1, Message, ecdsa, PublicKey};\nlet secp = Secp256k1::verification_only();\nlet public_key = PublicKey::from_slice(&[\n  0x02,\n  0xc6, 0x6e, 0x7d, 0x89, 0x66, 0xb5, 0xc5, 0x55,\n  0xaf, 0x58, 0x05, 0x98, 0x9d, 0xa9, 0xfb, 0xf8,\n  0xdb, 0x95, 0xe1, 0x56, 0x31, 0xce, 0x35, 0x8c,\n  0x3a, 0x17, 0x10, 0xc9, 0x62, 0x67, 0x90, 0x63,\n]).expect(\"public keys must be 33 or 65 bytes, serialized according to SEC 2\");\nlet message = Message::from_digest([\n  0xaa, 0xdf, 0x7d, 0xe7, 0x82, 0x03, 0x4f, 0xbe,\n  0x3d, 0x3d, 0xb2, 0xcb, 0x13, 0xc0, 0xcd, 0x91,\n  0xbf, 0x41, 0xcb, 0x08, 0xfa, 0xc7, 0xbd, 0x61,\n  0xd5, 0x44, 0x53, 0xcf, 0x6e, 0x82, 0xb4, 0x50,\n]);\nlet sig = ecdsa::Signature::from_compact(&[\n  0xdc, 0x4d, 0xc2, 0x64, 0xa9, 0xfe, 0xf1, 0x7a,\n  0x3f, 0x25, 0x34, 0x49, 0xcf, 0x8c, 0x39, 0x7a,\n  0xb6, 0xf1, 0x6f, 0xb3, 0xd6, 0x3d, 0x86, 0x94,\n  0x0b, 0x55, 0x86, 0x82, 0x3d, 0xfd, 0x02, 0xae,\n  0x3b, 0x46, 0x1b, 0xb4, 0x33, 0x6b, 0x5e, 0xcb,\n  0xae, 0xfd, 0x66, 0x27, 0xaa, 0x92, 0x2e, 0xfc,\n  0x04, 0x8f, 0xec, 0x0c, 0x88, 0x1c, 0x10, 0xc4,\n  0xc9, 0x42, 0x8f, 0xca, 0x69, 0xc1, 0x32, 0xa2,\n]).expect(\"compact signatures are 64 bytes; DER signatures are 68-72 bytes\");\nassert!(secp.verify_ecdsa(message, &sig, &public_key).is_ok());\n```\n\nObserve that the same code using, say [`signing_only`](https://docs.rs/secp256k1/latest/secp256k1/struct.Secp256k1.html#method.signing_only) to generate a context would simply not compile.\n### [\u00a7](https://docs.rs/secp256k1/latest/secp256k1/#crate-featuresoptional-dependencies)Crate features/optional dependencies\nThis crate provides the following opt-in Cargo features:\n  * `std` - use standard Rust library, enabled by default.\n  * `alloc` - use the `alloc` standard Rust library to provide heap allocations.\n  * `rand` - use `rand` library to provide random generator (e.g. to generate keys).\n  * `hashes` - use the `hashes` library.\n  * `recovery` - enable functions that can compute the public key from signature.\n  * `lowmemory` - optimize the library for low-memory environments.\n  * `global-context` - enable use of global secp256k1 context (implies `std`).\n  * `serde` - implements serialization and deserialization for types in this crate using `serde`. **Important** : `serde` encoding is **not** the same as consensus encoding!\n\n\n## Re-exports[\u00a7](https://docs.rs/secp256k1/latest/secp256k1/#reexports)\n\n`pub extern crate hashes[](https://docs.rs/bitcoin_hashes/0.14.0/x86_64-unknown-linux-gnu/bitcoin_hashes/index.html \"mod bitcoin_hashes\");`\n\n\n`pub use crate::scalar::Scalar[](https://docs.rs/secp256k1/latest/secp256k1/scalar/struct.Scalar.html \"struct secp256k1::scalar::Scalar\");`\n\n\n`pub use rand[](https://docs.rs/rand/0.9.1/x86_64-unknown-linux-gnu/rand/index.html \"mod rand\");``rand`\n\n\n`pub use secp256k1_sys[](https://docs.rs/secp256k1-sys/0.11.0/x86_64-unknown-linux-gnu/secp256k1_sys/index.html \"mod secp256k1_sys\") as ffi;`\n\n\n`pub use serde[](https://docs.rs/serde/1.0.219/x86_64-unknown-linux-gnu/serde/index.html \"mod serde\");``serde`\n\n## Modules[\u00a7](https://docs.rs/secp256k1/latest/secp256k1/#modules)\n\n[constants](https://docs.rs/secp256k1/latest/secp256k1/constants/index.html \"mod secp256k1::constants\")\n    Constants related to the API and the underlying curve.\n\n[ecdh](https://docs.rs/secp256k1/latest/secp256k1/ecdh/index.html \"mod secp256k1::ecdh\")\n    Support for shared secret computations.\n\n[ecdsa](https://docs.rs/secp256k1/latest/secp256k1/ecdsa/index.html \"mod secp256k1::ecdsa\")\n    Structs and functionality related to the ECDSA signature algorithm.\n\n[ellswift](https://docs.rs/secp256k1/latest/secp256k1/ellswift/index.html \"mod secp256k1::ellswift\")\n    This module provides an implementation of ElligatorSwift as well as a version of x-only ECDH using it (including compatibility with BIP324).\n\n[global](https://docs.rs/secp256k1/latest/secp256k1/global/index.html \"mod secp256k1::global\")`global-context` and `std`\n    Module implementing a singleton pattern for a global `Secp256k1` context.\n\n[scalar](https://docs.rs/secp256k1/latest/secp256k1/scalar/index.html \"mod secp256k1::scalar\")\n    Provides [`Scalar`](https://docs.rs/secp256k1/latest/secp256k1/scalar/struct.Scalar.html \"struct secp256k1::scalar::Scalar\") and related types.\n\n[schnorr](https://docs.rs/secp256k1/latest/secp256k1/schnorr/index.html \"mod secp256k1::schnorr\")\n    Support for schnorr signatures.\n## Macros[\u00a7](https://docs.rs/secp256k1/latest/secp256k1/#macros)\n\n[impl_array_newtype](https://docs.rs/secp256k1/latest/secp256k1/macro.impl_array_newtype.html \"macro secp256k1::impl_array_newtype\")\n    Implement methods and traits for types that contain an inner array.\n## Structs[\u00a7](https://docs.rs/secp256k1/latest/secp256k1/#structs)\n\n[AllPreallocated](https://docs.rs/secp256k1/latest/secp256k1/struct.AllPreallocated.html \"struct secp256k1::AllPreallocated\")\n    Represents the set of all capabilities (preallocated memory).\n\n[InvalidParityValue](https://docs.rs/secp256k1/latest/secp256k1/struct.InvalidParityValue.html \"struct secp256k1::InvalidParityValue\")\n    Error returned when conversion from an integer to `Parity` fails.\n\n[Keypair](https://docs.rs/secp256k1/latest/secp256k1/struct.Keypair.html \"struct secp256k1::Keypair\")\n    Opaque data structure that holds a keypair consisting of a secret and a public key.\n\n[Message](https://docs.rs/secp256k1/latest/secp256k1/struct.Message.html \"struct secp256k1::Message\")\n    A (hashed) message input to an ECDSA signature.\n\n[PublicKey](https://docs.rs/secp256k1/latest/secp256k1/struct.PublicKey.html \"struct secp256k1::PublicKey\")\n    Public key - used to verify ECDSA signatures and to do Taproot tweaks.\n\n[Secp256k1](https://docs.rs/secp256k1/latest/secp256k1/struct.Secp256k1.html \"struct secp256k1::Secp256k1\")\n    The secp256k1 engine, used to execute all signature operations.\n\n[SecretKey](https://docs.rs/secp256k1/latest/secp256k1/struct.SecretKey.html \"struct secp256k1::SecretKey\")\n    Secret key - a 256-bit key used to create ECDSA and Taproot signatures.\n\n[SignOnlyPreallocated](https://docs.rs/secp256k1/latest/secp256k1/struct.SignOnlyPreallocated.html \"struct secp256k1::SignOnlyPreallocated\")\n    Represents the set of capabilities needed for signing (preallocated memory).\n\n[VerifyOnlyPreallocated](https://docs.rs/secp256k1/latest/secp256k1/struct.VerifyOnlyPreallocated.html \"struct secp256k1::VerifyOnlyPreallocated\")\n    Represents the set of capabilities needed for verification (preallocated memory).\n\n[XOnlyPublicKey](https://docs.rs/secp256k1/latest/secp256k1/struct.XOnlyPublicKey.html \"struct secp256k1::XOnlyPublicKey\")\n    An x-only public key, used for verification of Taproot signatures and serialized according to BIP-340.\n## Enums[\u00a7](https://docs.rs/secp256k1/latest/secp256k1/#enums)\n\n[All](https://docs.rs/secp256k1/latest/secp256k1/enum.All.html \"enum secp256k1::All\")`alloc`\n    Represents the set of all capabilities.\n\n[Error](https://docs.rs/secp256k1/latest/secp256k1/enum.Error.html \"enum secp256k1::Error\")\n    The main error type for this library.\n\n[Parity](https://docs.rs/secp256k1/latest/secp256k1/enum.Parity.html \"enum secp256k1::Parity\")\n    Represents the parity passed between FFI function calls.\n\n[SignOnly](https://docs.rs/secp256k1/latest/secp256k1/enum.SignOnly.html \"enum secp256k1::SignOnly\")`alloc`\n    Represents the set of capabilities needed for signing.\n\n[VerifyOnly](https://docs.rs/secp256k1/latest/secp256k1/enum.VerifyOnly.html \"enum secp256k1::VerifyOnly\")`alloc`\n    Represents the set of capabilities needed for verification.\n## Statics[\u00a7](https://docs.rs/secp256k1/latest/secp256k1/#statics)\n\n[SECP256K1](https://docs.rs/secp256k1/latest/secp256k1/static.SECP256K1.html \"static secp256k1::SECP256K1\")`global-context` and `std`\n    A global static context to avoid repeatedly creating contexts.\n## Traits[\u00a7](https://docs.rs/secp256k1/latest/secp256k1/#traits)\n\n[Context](https://docs.rs/secp256k1/latest/secp256k1/trait.Context.html \"trait secp256k1::Context\")\n    A trait for all kinds of contexts that lets you define the exact flags and a function to deallocate memory. It isn\u2019t possible to implement this for types outside this crate.\n\n[PreallocatedContext](https://docs.rs/secp256k1/latest/secp256k1/trait.PreallocatedContext.html \"trait secp256k1::PreallocatedContext\")\n    Trait marking that a particular context object internally points to memory that must outlive `'a`\n\n[Signing](https://docs.rs/secp256k1/latest/secp256k1/trait.Signing.html \"trait secp256k1::Signing\")\n    Marker trait for indicating that an instance of [`Secp256k1`](https://docs.rs/secp256k1/latest/secp256k1/struct.Secp256k1.html \"struct secp256k1::Secp256k1\") can be used for signing.\n\n[ThirtyTwoByteHash](https://docs.rs/secp256k1/latest/secp256k1/trait.ThirtyTwoByteHash.html \"trait secp256k1::ThirtyTwoByteHash\")Deprecated\n    Trait describing something that promises to be a 32-byte uniformly random number.\n\n[Verification](https://docs.rs/secp256k1/latest/secp256k1/trait.Verification.html \"trait secp256k1::Verification\")\n    Marker trait for indicating that an instance of [`Secp256k1`](https://docs.rs/secp256k1/latest/secp256k1/struct.Secp256k1.html \"struct secp256k1::Secp256k1\") can be used for verification.\n## Functions[\u00a7](https://docs.rs/secp256k1/latest/secp256k1/#functions)\n\n[generate_keypair](https://docs.rs/secp256k1/latest/secp256k1/fn.generate_keypair.html \"fn secp256k1::generate_keypair\")`global-context` and `rand`\n    Generates a random keypair using the global [`SECP256K1`](https://docs.rs/secp256k1/latest/secp256k1/static.SECP256K1.html \"static secp256k1::SECP256K1\") context.\n",
            "markdown_with_citations": "[](https://docs.rs/secp256k1/latest/secp256k1/all.html \"show sidebar\")\n# Crate secp256k1Copy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nRust bindings for Pieter Wuille\u2019s secp256k1 library, which is used for fast and accurate manipulation of ECDSA and Schnorr signatures on the secp256k1 curve. Such signatures are used extensively by the Bitcoin network and its derivatives.\nTo minimize dependencies, some functions are feature-gated. To generate random keys or to re-randomize a context object, compile with the `rand` and `std` features. If you are willing to use these features, we have enabled an additional defense-in-depth sidechannel protection for our context objects, which re-blinds certain operations on secret key data. To de/serialize objects with serde, compile with \u201cserde\u201d. **Important** : `serde` encoding is **not** the same as consensus encoding!\nWhere possible, the bindings use the Rust type system to ensure that API usage errors are impossible. For example, the library uses context objects that contain precomputation tables which are created on object construction. Since this is a slow operation (10+ milliseconds, vs ~50 microseconds for typical crypto operations, on a 2.70 Ghz i7-6820HQ) the tables are optional, giving a performance boost for users who only care about signing, only care about verification, or only care about parsing. In the upstream library, if you attempt to sign a message using a context that does not support this, it will trigger an assertion failure and terminate the program. In `rust-secp256k1`, this is caught at compile-time; in fact, it is impossible to compile code that will trigger any assertion failures in the upstream library.\n```\nuse secp256k1::rand;\nuse secp256k1::{Secp256k1, Message};\nuse secp256k1::hashes::{sha256, Hash};\nlet secp = Secp256k1::new();\nlet (secret_key, public_key) = secp.generate_keypair(&mut rand::rng());\nlet digest = sha256::Hash::hash(\"Hello World!\".as_bytes());\nlet message = Message::from_digest(digest.to_byte_array());\nlet sig = secp.sign_ecdsa(message, &secret_key);\nassert!(secp.verify_ecdsa(message, &sig, &public_key).is_ok());\n```\n\nIf the \u201cglobal-context\u201d feature is enabled you have access to an alternate API.\n```\nuse secp256k1::{rand, generate_keypair, Message};\nuse secp256k1::hashes::{sha256, Hash};\nlet (secret_key, public_key) = generate_keypair(&mut rand::rng());\nlet digest = sha256::Hash::hash(\"Hello World!\".as_bytes());\nlet message = Message::from_digest(digest.to_byte_array());\nlet sig = secret_key.sign_ecdsa(message);\nassert!(sig.verify(message, &public_key).is_ok());\n```\n\nThe above code requires `rust-secp256k1` to be compiled with the `rand`, `hashes`, and `std` feature enabled, to get access to `generate_keypair`\u27e84\u27e9 Alternately, keys and messages can be parsed from slices, like\n```\nuse secp256k1::{Secp256k1, Message, SecretKey, PublicKey};\nlet secp = Secp256k1::new();\nlet secret_key = SecretKey::from_slice(&[0xcd; 32]).expect(\"32 bytes, within curve order\");\nlet public_key = PublicKey::from_secret_key(&secp, &secret_key);\n// If the supplied byte slice was *not* the output of a cryptographic hash function this would\n// be cryptographically broken. It has been trivially used in the past to execute attacks.\nlet message = Message::from_digest(compute_hash(b\"CSW is not Satoshi\"));\nlet sig = secp.sign_ecdsa(message, &secret_key);\nassert!(secp.verify_ecdsa(message, &sig, &public_key).is_ok());\n```\n\nUsers who only want to verify signatures can use a cheaper context, like so:\n```\nuse secp256k1::{Secp256k1, Message, ecdsa, PublicKey};\nlet secp = Secp256k1::verification_only();\nlet public_key = PublicKey::from_slice(&[\n  0x02,\n  0xc6, 0x6e, 0x7d, 0x89, 0x66, 0xb5, 0xc5, 0x55,\n  0xaf, 0x58, 0x05, 0x98, 0x9d, 0xa9, 0xfb, 0xf8,\n  0xdb, 0x95, 0xe1, 0x56, 0x31, 0xce, 0x35, 0x8c,\n  0x3a, 0x17, 0x10, 0xc9, 0x62, 0x67, 0x90, 0x63,\n]).expect(\"public keys must be 33 or 65 bytes, serialized according to SEC 2\");\nlet message = Message::from_digest([\n  0xaa, 0xdf, 0x7d, 0xe7, 0x82, 0x03, 0x4f, 0xbe,\n  0x3d, 0x3d, 0xb2, 0xcb, 0x13, 0xc0, 0xcd, 0x91,\n  0xbf, 0x41, 0xcb, 0x08, 0xfa, 0xc7, 0xbd, 0x61,\n  0xd5, 0x44, 0x53, 0xcf, 0x6e, 0x82, 0xb4, 0x50,\n]);\nlet sig = ecdsa::Signature::from_compact(&[\n  0xdc, 0x4d, 0xc2, 0x64, 0xa9, 0xfe, 0xf1, 0x7a,\n  0x3f, 0x25, 0x34, 0x49, 0xcf, 0x8c, 0x39, 0x7a,\n  0xb6, 0xf1, 0x6f, 0xb3, 0xd6, 0x3d, 0x86, 0x94,\n  0x0b, 0x55, 0x86, 0x82, 0x3d, 0xfd, 0x02, 0xae,\n  0x3b, 0x46, 0x1b, 0xb4, 0x33, 0x6b, 0x5e, 0xcb,\n  0xae, 0xfd, 0x66, 0x27, 0xaa, 0x92, 0x2e, 0xfc,\n  0x04, 0x8f, 0xec, 0x0c, 0x88, 0x1c, 0x10, 0xc4,\n  0xc9, 0x42, 0x8f, 0xca, 0x69, 0xc1, 0x32, 0xa2,\n]).expect(\"compact signatures are 64 bytes; DER signatures are 68-72 bytes\");\nassert!(secp.verify_ecdsa(message, &sig, &public_key).is_ok());\n```\n\nObserve that the same code using, say `signing_only`\u27e85\u27e9 to generate a context would simply not compile.\n### \u00a7\u27e86\u27e9Crate features/optional dependencies\nThis crate provides the following opt-in Cargo features:\n  * `std` - use standard Rust library, enabled by default.\n  * `alloc` - use the `alloc` standard Rust library to provide heap allocations.\n  * `rand` - use `rand` library to provide random generator (e.g. to generate keys).\n  * `hashes` - use the `hashes` library.\n  * `recovery` - enable functions that can compute the public key from signature.\n  * `lowmemory` - optimize the library for low-memory environments.\n  * `global-context` - enable use of global secp256k1 context (implies `std`).\n  * `serde` - implements serialization and deserialization for types in this crate using `serde`. **Important** : `serde` encoding is **not** the same as consensus encoding!\n\n\n## Re-exports\u00a7\u27e87\u27e9\n\n`pub extern crate hashes[](https://docs.rs/bitcoin_hashes/0.14.0/x86_64-unknown-linux-gnu/bitcoin_hashes/index.html \"mod bitcoin_hashes\");`\n\n\n`pub use crate::scalar::Scalar[](https://docs.rs/secp256k1/latest/secp256k1/scalar/struct.Scalar.html \"struct secp256k1::scalar::Scalar\");`\n\n\n`pub use rand[](https://docs.rs/rand/0.9.1/x86_64-unknown-linux-gnu/rand/index.html \"mod rand\");``rand`\n\n\n`pub use secp256k1_sys[](https://docs.rs/secp256k1-sys/0.11.0/x86_64-unknown-linux-gnu/secp256k1_sys/index.html \"mod secp256k1_sys\") as ffi;`\n\n\n`pub use serde[](https://docs.rs/serde/1.0.219/x86_64-unknown-linux-gnu/serde/index.html \"mod serde\");``serde`\n\n## Modules\u00a7\u27e88\u27e9\n\nconstants\u27e89\u27e9\n    Constants related to the API and the underlying curve.\n\necdh\u27e810\u27e9\n    Support for shared secret computations.\n\necdsa\u27e811\u27e9\n    Structs and functionality related to the ECDSA signature algorithm.\n\nellswift\u27e812\u27e9\n    This module provides an implementation of ElligatorSwift as well as a version of x-only ECDH using it (including compatibility with BIP324).\n\nglobal\u27e813\u27e9`global-context` and `std`\n    Module implementing a singleton pattern for a global `Secp256k1` context.\n\nscalar\u27e814\u27e9\n    Provides `Scalar`\u27e815\u27e9 and related types.\n\nschnorr\u27e816\u27e9\n    Support for schnorr signatures.\n## Macros\u00a7\u27e817\u27e9\n\nimpl_array_newtype\u27e818\u27e9\n    Implement methods and traits for types that contain an inner array.\n## Structs\u00a7\u27e819\u27e9\n\nAllPreallocated\u27e820\u27e9\n    Represents the set of all capabilities (preallocated memory).\n\nInvalidParityValue\u27e821\u27e9\n    Error returned when conversion from an integer to `Parity` fails.\n\nKeypair\u27e822\u27e9\n    Opaque data structure that holds a keypair consisting of a secret and a public key.\n\nMessage\u27e823\u27e9\n    A (hashed) message input to an ECDSA signature.\n\nPublicKey\u27e824\u27e9\n    Public key - used to verify ECDSA signatures and to do Taproot tweaks.\n\nSecp256k1\u27e825\u27e9\n    The secp256k1 engine, used to execute all signature operations.\n\nSecretKey\u27e826\u27e9\n    Secret key - a 256-bit key used to create ECDSA and Taproot signatures.\n\nSignOnlyPreallocated\u27e827\u27e9\n    Represents the set of capabilities needed for signing (preallocated memory).\n\nVerifyOnlyPreallocated\u27e828\u27e9\n    Represents the set of capabilities needed for verification (preallocated memory).\n\nXOnlyPublicKey\u27e829\u27e9\n    An x-only public key, used for verification of Taproot signatures and serialized according to BIP-340.\n## Enums\u00a7\u27e830\u27e9\n\nAll\u27e831\u27e9`alloc`\n    Represents the set of all capabilities.\n\nError\u27e832\u27e9\n    The main error type for this library.\n\nParity\u27e833\u27e9\n    Represents the parity passed between FFI function calls.\n\nSignOnly\u27e834\u27e9`alloc`\n    Represents the set of capabilities needed for signing.\n\nVerifyOnly\u27e835\u27e9`alloc`\n    Represents the set of capabilities needed for verification.\n## Statics\u00a7\u27e836\u27e9\n\nSECP256K1\u27e837\u27e9`global-context` and `std`\n    A global static context to avoid repeatedly creating contexts.\n## Traits\u00a7\u27e838\u27e9\n\nContext\u27e839\u27e9\n    A trait for all kinds of contexts that lets you define the exact flags and a function to deallocate memory. It isn\u2019t possible to implement this for types outside this crate.\n\nPreallocatedContext\u27e840\u27e9\n    Trait marking that a particular context object internally points to memory that must outlive `'a`\n\nSigning\u27e841\u27e9\n    Marker trait for indicating that an instance of `Secp256k1`\u27e825\u27e9 can be used for signing.\n\nThirtyTwoByteHash\u27e842\u27e9Deprecated\n    Trait describing something that promises to be a 32-byte uniformly random number.\n\nVerification\u27e843\u27e9\n    Marker trait for indicating that an instance of `Secp256k1`\u27e825\u27e9 can be used for verification.\n## Functions\u00a7\u27e844\u27e9\n\ngenerate_keypair\u27e845\u27e9`global-context` and `rand`\n    Generates a random keypair using the global `SECP256K1`\u27e837\u27e9 context.\n",
            "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/secp256k1/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/secp256k1/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/secp256k1/latest/src/secp256k1/lib.rs.html#3-1052: Source\n\u27e84\u27e9 https://docs.rs/secp256k1/latest/secp256k1/struct.Secp256k1.html#method.generate_keypair: `generate_keypair`\n\u27e85\u27e9 https://docs.rs/secp256k1/latest/secp256k1/struct.Secp256k1.html#method.signing_only: `signing_only`\n\u27e86\u27e9 https://docs.rs/secp256k1/latest/secp256k1/#crate-featuresoptional-dependencies: \u00a7\n\u27e87\u27e9 https://docs.rs/secp256k1/latest/secp256k1/#reexports: \u00a7\n\u27e88\u27e9 https://docs.rs/secp256k1/latest/secp256k1/#modules: \u00a7\n\u27e89\u27e9 https://docs.rs/secp256k1/latest/secp256k1/constants/index.html: mod secp256k1::constants - constants\n\u27e810\u27e9 https://docs.rs/secp256k1/latest/secp256k1/ecdh/index.html: mod secp256k1::ecdh - ecdh\n\u27e811\u27e9 https://docs.rs/secp256k1/latest/secp256k1/ecdsa/index.html: mod secp256k1::ecdsa - ecdsa\n\u27e812\u27e9 https://docs.rs/secp256k1/latest/secp256k1/ellswift/index.html: mod secp256k1::ellswift - ellswift\n\u27e813\u27e9 https://docs.rs/secp256k1/latest/secp256k1/global/index.html: mod secp256k1::global - global\n\u27e814\u27e9 https://docs.rs/secp256k1/latest/secp256k1/scalar/index.html: mod secp256k1::scalar - scalar\n\u27e815\u27e9 https://docs.rs/secp256k1/latest/secp256k1/scalar/struct.Scalar.html: struct secp256k1::scalar::Scalar - `Scalar`\n\u27e816\u27e9 https://docs.rs/secp256k1/latest/secp256k1/schnorr/index.html: mod secp256k1::schnorr - schnorr\n\u27e817\u27e9 https://docs.rs/secp256k1/latest/secp256k1/#macros: \u00a7\n\u27e818\u27e9 https://docs.rs/secp256k1/latest/secp256k1/macro.impl_array_newtype.html: macro secp256k1::impl_array_newtype - impl_array_newtype\n\u27e819\u27e9 https://docs.rs/secp256k1/latest/secp256k1/#structs: \u00a7\n\u27e820\u27e9 https://docs.rs/secp256k1/latest/secp256k1/struct.AllPreallocated.html: struct secp256k1::AllPreallocated - AllPreallocated\n\u27e821\u27e9 https://docs.rs/secp256k1/latest/secp256k1/struct.InvalidParityValue.html: struct secp256k1::InvalidParityValue - InvalidParityValue\n\u27e822\u27e9 https://docs.rs/secp256k1/latest/secp256k1/struct.Keypair.html: struct secp256k1::Keypair - Keypair\n\u27e823\u27e9 https://docs.rs/secp256k1/latest/secp256k1/struct.Message.html: struct secp256k1::Message - Message\n\u27e824\u27e9 https://docs.rs/secp256k1/latest/secp256k1/struct.PublicKey.html: struct secp256k1::PublicKey - PublicKey\n\u27e825\u27e9 https://docs.rs/secp256k1/latest/secp256k1/struct.Secp256k1.html: struct secp256k1::Secp256k1 - Secp256k1\n\u27e826\u27e9 https://docs.rs/secp256k1/latest/secp256k1/struct.SecretKey.html: struct secp256k1::SecretKey - SecretKey\n\u27e827\u27e9 https://docs.rs/secp256k1/latest/secp256k1/struct.SignOnlyPreallocated.html: struct secp256k1::SignOnlyPreallocated - SignOnlyPreallocated\n\u27e828\u27e9 https://docs.rs/secp256k1/latest/secp256k1/struct.VerifyOnlyPreallocated.html: struct secp256k1::VerifyOnlyPreallocated - VerifyOnlyPreallocated\n\u27e829\u27e9 https://docs.rs/secp256k1/latest/secp256k1/struct.XOnlyPublicKey.html: struct secp256k1::XOnlyPublicKey - XOnlyPublicKey\n\u27e830\u27e9 https://docs.rs/secp256k1/latest/secp256k1/#enums: \u00a7\n\u27e831\u27e9 https://docs.rs/secp256k1/latest/secp256k1/enum.All.html: enum secp256k1::All - All\n\u27e832\u27e9 https://docs.rs/secp256k1/latest/secp256k1/enum.Error.html: enum secp256k1::Error - Error\n\u27e833\u27e9 https://docs.rs/secp256k1/latest/secp256k1/enum.Parity.html: enum secp256k1::Parity - Parity\n\u27e834\u27e9 https://docs.rs/secp256k1/latest/secp256k1/enum.SignOnly.html: enum secp256k1::SignOnly - SignOnly\n\u27e835\u27e9 https://docs.rs/secp256k1/latest/secp256k1/enum.VerifyOnly.html: enum secp256k1::VerifyOnly - VerifyOnly\n\u27e836\u27e9 https://docs.rs/secp256k1/latest/secp256k1/#statics: \u00a7\n\u27e837\u27e9 https://docs.rs/secp256k1/latest/secp256k1/static.SECP256K1.html: static secp256k1::SECP256K1 - SECP256K1\n\u27e838\u27e9 https://docs.rs/secp256k1/latest/secp256k1/#traits: \u00a7\n\u27e839\u27e9 https://docs.rs/secp256k1/latest/secp256k1/trait.Context.html: trait secp256k1::Context - Context\n\u27e840\u27e9 https://docs.rs/secp256k1/latest/secp256k1/trait.PreallocatedContext.html: trait secp256k1::PreallocatedContext - PreallocatedContext\n\u27e841\u27e9 https://docs.rs/secp256k1/latest/secp256k1/trait.Signing.html: trait secp256k1::Signing - Signing\n\u27e842\u27e9 https://docs.rs/secp256k1/latest/secp256k1/trait.ThirtyTwoByteHash.html: trait secp256k1::ThirtyTwoByteHash - ThirtyTwoByteHash\n\u27e843\u27e9 https://docs.rs/secp256k1/latest/secp256k1/trait.Verification.html: trait secp256k1::Verification - Verification\n\u27e844\u27e9 https://docs.rs/secp256k1/latest/secp256k1/#functions: \u00a7\n\u27e845\u27e9 https://docs.rs/secp256k1/latest/secp256k1/fn.generate_keypair.html: fn secp256k1::generate_keypair - generate_keypair\n",
            "fit_markdown": "",
            "fit_html": ""
          },
          "downloads": 0,
          "github_stars": 0,
          "dependencies": [],
          "features": {},
          "code_snippets": [],
          "readme_sections": {},
          "librs_downloads": null,
          "source": "crates.io",
          "enhanced_scraping": {},
          "enhanced_features": [],
          "enhanced_dependencies": []
        },
        "enriched_crate": {
          "name": "secp256k1",
          "version": "0.31.1",
          "description": "ALLOW: Positive community sentiment",
          "repository": "",
          "keywords": [],
          "categories": [],
          "readme": {
            "raw_markdown": "[](https://docs.rs/secp256k1/latest/secp256k1/all.html \"show sidebar\")\n# Crate secp256k1Copy item path\n[Settings](https://docs.rs/secp256k1/latest/settings.html)\n[Help](https://docs.rs/secp256k1/latest/help.html)\nSummary[Source](https://docs.rs/secp256k1/latest/src/secp256k1/lib.rs.html#3-1052)\nExpand description\nRust bindings for Pieter Wuille\u2019s secp256k1 library, which is used for fast and accurate manipulation of ECDSA and Schnorr signatures on the secp256k1 curve. Such signatures are used extensively by the Bitcoin network and its derivatives.\nTo minimize dependencies, some functions are feature-gated. To generate random keys or to re-randomize a context object, compile with the `rand` and `std` features. If you are willing to use these features, we have enabled an additional defense-in-depth sidechannel protection for our context objects, which re-blinds certain operations on secret key data. To de/serialize objects with serde, compile with \u201cserde\u201d. **Important** : `serde` encoding is **not** the same as consensus encoding!\nWhere possible, the bindings use the Rust type system to ensure that API usage errors are impossible. For example, the library uses context objects that contain precomputation tables which are created on object construction. Since this is a slow operation (10+ milliseconds, vs ~50 microseconds for typical crypto operations, on a 2.70 Ghz i7-6820HQ) the tables are optional, giving a performance boost for users who only care about signing, only care about verification, or only care about parsing. In the upstream library, if you attempt to sign a message using a context that does not support this, it will trigger an assertion failure and terminate the program. In `rust-secp256k1`, this is caught at compile-time; in fact, it is impossible to compile code that will trigger any assertion failures in the upstream library.\n```\nuse secp256k1::rand;\nuse secp256k1::{Secp256k1, Message};\nuse secp256k1::hashes::{sha256, Hash};\nlet secp = Secp256k1::new();\nlet (secret_key, public_key) = secp.generate_keypair(&mut rand::rng());\nlet digest = sha256::Hash::hash(\"Hello World!\".as_bytes());\nlet message = Message::from_digest(digest.to_byte_array());\nlet sig = secp.sign_ecdsa(message, &secret_key);\nassert!(secp.verify_ecdsa(message, &sig, &public_key).is_ok());\n```\n\nIf the \u201cglobal-context\u201d feature is enabled you have access to an alternate API.\n```\nuse secp256k1::{rand, generate_keypair, Message};\nuse secp256k1::hashes::{sha256, Hash};\nlet (secret_key, public_key) = generate_keypair(&mut rand::rng());\nlet digest = sha256::Hash::hash(\"Hello World!\".as_bytes());\nlet message = Message::from_digest(digest.to_byte_array());\nlet sig = secret_key.sign_ecdsa(message);\nassert!(sig.verify(message, &public_key).is_ok());\n```\n\nThe above code requires `rust-secp256k1` to be compiled with the `rand`, `hashes`, and `std` feature enabled, to get access to [`generate_keypair`](https://docs.rs/secp256k1/latest/secp256k1/struct.Secp256k1.html#method.generate_keypair) Alternately, keys and messages can be parsed from slices, like\n```\nuse secp256k1::{Secp256k1, Message, SecretKey, PublicKey};\nlet secp = Secp256k1::new();\nlet secret_key = SecretKey::from_slice(&[0xcd; 32]).expect(\"32 bytes, within curve order\");\nlet public_key = PublicKey::from_secret_key(&secp, &secret_key);\n// If the supplied byte slice was *not* the output of a cryptographic hash function this would\n// be cryptographically broken. It has been trivially used in the past to execute attacks.\nlet message = Message::from_digest(compute_hash(b\"CSW is not Satoshi\"));\nlet sig = secp.sign_ecdsa(message, &secret_key);\nassert!(secp.verify_ecdsa(message, &sig, &public_key).is_ok());\n```\n\nUsers who only want to verify signatures can use a cheaper context, like so:\n```\nuse secp256k1::{Secp256k1, Message, ecdsa, PublicKey};\nlet secp = Secp256k1::verification_only();\nlet public_key = PublicKey::from_slice(&[\n  0x02,\n  0xc6, 0x6e, 0x7d, 0x89, 0x66, 0xb5, 0xc5, 0x55,\n  0xaf, 0x58, 0x05, 0x98, 0x9d, 0xa9, 0xfb, 0xf8,\n  0xdb, 0x95, 0xe1, 0x56, 0x31, 0xce, 0x35, 0x8c,\n  0x3a, 0x17, 0x10, 0xc9, 0x62, 0x67, 0x90, 0x63,\n]).expect(\"public keys must be 33 or 65 bytes, serialized according to SEC 2\");\nlet message = Message::from_digest([\n  0xaa, 0xdf, 0x7d, 0xe7, 0x82, 0x03, 0x4f, 0xbe,\n  0x3d, 0x3d, 0xb2, 0xcb, 0x13, 0xc0, 0xcd, 0x91,\n  0xbf, 0x41, 0xcb, 0x08, 0xfa, 0xc7, 0xbd, 0x61,\n  0xd5, 0x44, 0x53, 0xcf, 0x6e, 0x82, 0xb4, 0x50,\n]);\nlet sig = ecdsa::Signature::from_compact(&[\n  0xdc, 0x4d, 0xc2, 0x64, 0xa9, 0xfe, 0xf1, 0x7a,\n  0x3f, 0x25, 0x34, 0x49, 0xcf, 0x8c, 0x39, 0x7a,\n  0xb6, 0xf1, 0x6f, 0xb3, 0xd6, 0x3d, 0x86, 0x94,\n  0x0b, 0x55, 0x86, 0x82, 0x3d, 0xfd, 0x02, 0xae,\n  0x3b, 0x46, 0x1b, 0xb4, 0x33, 0x6b, 0x5e, 0xcb,\n  0xae, 0xfd, 0x66, 0x27, 0xaa, 0x92, 0x2e, 0xfc,\n  0x04, 0x8f, 0xec, 0x0c, 0x88, 0x1c, 0x10, 0xc4,\n  0xc9, 0x42, 0x8f, 0xca, 0x69, 0xc1, 0x32, 0xa2,\n]).expect(\"compact signatures are 64 bytes; DER signatures are 68-72 bytes\");\nassert!(secp.verify_ecdsa(message, &sig, &public_key).is_ok());\n```\n\nObserve that the same code using, say [`signing_only`](https://docs.rs/secp256k1/latest/secp256k1/struct.Secp256k1.html#method.signing_only) to generate a context would simply not compile.\n### [\u00a7](https://docs.rs/secp256k1/latest/secp256k1/#crate-featuresoptional-dependencies)Crate features/optional dependencies\nThis crate provides the following opt-in Cargo features:\n  * `std` - use standard Rust library, enabled by default.\n  * `alloc` - use the `alloc` standard Rust library to provide heap allocations.\n  * `rand` - use `rand` library to provide random generator (e.g. to generate keys).\n  * `hashes` - use the `hashes` library.\n  * `recovery` - enable functions that can compute the public key from signature.\n  * `lowmemory` - optimize the library for low-memory environments.\n  * `global-context` - enable use of global secp256k1 context (implies `std`).\n  * `serde` - implements serialization and deserialization for types in this crate using `serde`. **Important** : `serde` encoding is **not** the same as consensus encoding!\n\n\n## Re-exports[\u00a7](https://docs.rs/secp256k1/latest/secp256k1/#reexports)\n\n`pub extern crate hashes[](https://docs.rs/bitcoin_hashes/0.14.0/x86_64-unknown-linux-gnu/bitcoin_hashes/index.html \"mod bitcoin_hashes\");`\n\n\n`pub use crate::scalar::Scalar[](https://docs.rs/secp256k1/latest/secp256k1/scalar/struct.Scalar.html \"struct secp256k1::scalar::Scalar\");`\n\n\n`pub use rand[](https://docs.rs/rand/0.9.1/x86_64-unknown-linux-gnu/rand/index.html \"mod rand\");``rand`\n\n\n`pub use secp256k1_sys[](https://docs.rs/secp256k1-sys/0.11.0/x86_64-unknown-linux-gnu/secp256k1_sys/index.html \"mod secp256k1_sys\") as ffi;`\n\n\n`pub use serde[](https://docs.rs/serde/1.0.219/x86_64-unknown-linux-gnu/serde/index.html \"mod serde\");``serde`\n\n## Modules[\u00a7](https://docs.rs/secp256k1/latest/secp256k1/#modules)\n\n[constants](https://docs.rs/secp256k1/latest/secp256k1/constants/index.html \"mod secp256k1::constants\")\n    Constants related to the API and the underlying curve.\n\n[ecdh](https://docs.rs/secp256k1/latest/secp256k1/ecdh/index.html \"mod secp256k1::ecdh\")\n    Support for shared secret computations.\n\n[ecdsa](https://docs.rs/secp256k1/latest/secp256k1/ecdsa/index.html \"mod secp256k1::ecdsa\")\n    Structs and functionality related to the ECDSA signature algorithm.\n\n[ellswift](https://docs.rs/secp256k1/latest/secp256k1/ellswift/index.html \"mod secp256k1::ellswift\")\n    This module provides an implementation of ElligatorSwift as well as a version of x-only ECDH using it (including compatibility with BIP324).\n\n[global](https://docs.rs/secp256k1/latest/secp256k1/global/index.html \"mod secp256k1::global\")`global-context` and `std`\n    Module implementing a singleton pattern for a global `Secp256k1` context.\n\n[scalar](https://docs.rs/secp256k1/latest/secp256k1/scalar/index.html \"mod secp256k1::scalar\")\n    Provides [`Scalar`](https://docs.rs/secp256k1/latest/secp256k1/scalar/struct.Scalar.html \"struct secp256k1::scalar::Scalar\") and related types.\n\n[schnorr](https://docs.rs/secp256k1/latest/secp256k1/schnorr/index.html \"mod secp256k1::schnorr\")\n    Support for schnorr signatures.\n## Macros[\u00a7](https://docs.rs/secp256k1/latest/secp256k1/#macros)\n\n[impl_array_newtype](https://docs.rs/secp256k1/latest/secp256k1/macro.impl_array_newtype.html \"macro secp256k1::impl_array_newtype\")\n    Implement methods and traits for types that contain an inner array.\n## Structs[\u00a7](https://docs.rs/secp256k1/latest/secp256k1/#structs)\n\n[AllPreallocated](https://docs.rs/secp256k1/latest/secp256k1/struct.AllPreallocated.html \"struct secp256k1::AllPreallocated\")\n    Represents the set of all capabilities (preallocated memory).\n\n[InvalidParityValue](https://docs.rs/secp256k1/latest/secp256k1/struct.InvalidParityValue.html \"struct secp256k1::InvalidParityValue\")\n    Error returned when conversion from an integer to `Parity` fails.\n\n[Keypair](https://docs.rs/secp256k1/latest/secp256k1/struct.Keypair.html \"struct secp256k1::Keypair\")\n    Opaque data structure that holds a keypair consisting of a secret and a public key.\n\n[Message](https://docs.rs/secp256k1/latest/secp256k1/struct.Message.html \"struct secp256k1::Message\")\n    A (hashed) message input to an ECDSA signature.\n\n[PublicKey](https://docs.rs/secp256k1/latest/secp256k1/struct.PublicKey.html \"struct secp256k1::PublicKey\")\n    Public key - used to verify ECDSA signatures and to do Taproot tweaks.\n\n[Secp256k1](https://docs.rs/secp256k1/latest/secp256k1/struct.Secp256k1.html \"struct secp256k1::Secp256k1\")\n    The secp256k1 engine, used to execute all signature operations.\n\n[SecretKey](https://docs.rs/secp256k1/latest/secp256k1/struct.SecretKey.html \"struct secp256k1::SecretKey\")\n    Secret key - a 256-bit key used to create ECDSA and Taproot signatures.\n\n[SignOnlyPreallocated](https://docs.rs/secp256k1/latest/secp256k1/struct.SignOnlyPreallocated.html \"struct secp256k1::SignOnlyPreallocated\")\n    Represents the set of capabilities needed for signing (preallocated memory).\n\n[VerifyOnlyPreallocated](https://docs.rs/secp256k1/latest/secp256k1/struct.VerifyOnlyPreallocated.html \"struct secp256k1::VerifyOnlyPreallocated\")\n    Represents the set of capabilities needed for verification (preallocated memory).\n\n[XOnlyPublicKey](https://docs.rs/secp256k1/latest/secp256k1/struct.XOnlyPublicKey.html \"struct secp256k1::XOnlyPublicKey\")\n    An x-only public key, used for verification of Taproot signatures and serialized according to BIP-340.\n## Enums[\u00a7](https://docs.rs/secp256k1/latest/secp256k1/#enums)\n\n[All](https://docs.rs/secp256k1/latest/secp256k1/enum.All.html \"enum secp256k1::All\")`alloc`\n    Represents the set of all capabilities.\n\n[Error](https://docs.rs/secp256k1/latest/secp256k1/enum.Error.html \"enum secp256k1::Error\")\n    The main error type for this library.\n\n[Parity](https://docs.rs/secp256k1/latest/secp256k1/enum.Parity.html \"enum secp256k1::Parity\")\n    Represents the parity passed between FFI function calls.\n\n[SignOnly](https://docs.rs/secp256k1/latest/secp256k1/enum.SignOnly.html \"enum secp256k1::SignOnly\")`alloc`\n    Represents the set of capabilities needed for signing.\n\n[VerifyOnly](https://docs.rs/secp256k1/latest/secp256k1/enum.VerifyOnly.html \"enum secp256k1::VerifyOnly\")`alloc`\n    Represents the set of capabilities needed for verification.\n## Statics[\u00a7](https://docs.rs/secp256k1/latest/secp256k1/#statics)\n\n[SECP256K1](https://docs.rs/secp256k1/latest/secp256k1/static.SECP256K1.html \"static secp256k1::SECP256K1\")`global-context` and `std`\n    A global static context to avoid repeatedly creating contexts.\n## Traits[\u00a7](https://docs.rs/secp256k1/latest/secp256k1/#traits)\n\n[Context](https://docs.rs/secp256k1/latest/secp256k1/trait.Context.html \"trait secp256k1::Context\")\n    A trait for all kinds of contexts that lets you define the exact flags and a function to deallocate memory. It isn\u2019t possible to implement this for types outside this crate.\n\n[PreallocatedContext](https://docs.rs/secp256k1/latest/secp256k1/trait.PreallocatedContext.html \"trait secp256k1::PreallocatedContext\")\n    Trait marking that a particular context object internally points to memory that must outlive `'a`\n\n[Signing](https://docs.rs/secp256k1/latest/secp256k1/trait.Signing.html \"trait secp256k1::Signing\")\n    Marker trait for indicating that an instance of [`Secp256k1`](https://docs.rs/secp256k1/latest/secp256k1/struct.Secp256k1.html \"struct secp256k1::Secp256k1\") can be used for signing.\n\n[ThirtyTwoByteHash](https://docs.rs/secp256k1/latest/secp256k1/trait.ThirtyTwoByteHash.html \"trait secp256k1::ThirtyTwoByteHash\")Deprecated\n    Trait describing something that promises to be a 32-byte uniformly random number.\n\n[Verification](https://docs.rs/secp256k1/latest/secp256k1/trait.Verification.html \"trait secp256k1::Verification\")\n    Marker trait for indicating that an instance of [`Secp256k1`](https://docs.rs/secp256k1/latest/secp256k1/struct.Secp256k1.html \"struct secp256k1::Secp256k1\") can be used for verification.\n## Functions[\u00a7](https://docs.rs/secp256k1/latest/secp256k1/#functions)\n\n[generate_keypair](https://docs.rs/secp256k1/latest/secp256k1/fn.generate_keypair.html \"fn secp256k1::generate_keypair\")`global-context` and `rand`\n    Generates a random keypair using the global [`SECP256K1`](https://docs.rs/secp256k1/latest/secp256k1/static.SECP256K1.html \"static secp256k1::SECP256K1\") context.\n",
            "markdown_with_citations": "[](https://docs.rs/secp256k1/latest/secp256k1/all.html \"show sidebar\")\n# Crate secp256k1Copy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nRust bindings for Pieter Wuille\u2019s secp256k1 library, which is used for fast and accurate manipulation of ECDSA and Schnorr signatures on the secp256k1 curve. Such signatures are used extensively by the Bitcoin network and its derivatives.\nTo minimize dependencies, some functions are feature-gated. To generate random keys or to re-randomize a context object, compile with the `rand` and `std` features. If you are willing to use these features, we have enabled an additional defense-in-depth sidechannel protection for our context objects, which re-blinds certain operations on secret key data. To de/serialize objects with serde, compile with \u201cserde\u201d. **Important** : `serde` encoding is **not** the same as consensus encoding!\nWhere possible, the bindings use the Rust type system to ensure that API usage errors are impossible. For example, the library uses context objects that contain precomputation tables which are created on object construction. Since this is a slow operation (10+ milliseconds, vs ~50 microseconds for typical crypto operations, on a 2.70 Ghz i7-6820HQ) the tables are optional, giving a performance boost for users who only care about signing, only care about verification, or only care about parsing. In the upstream library, if you attempt to sign a message using a context that does not support this, it will trigger an assertion failure and terminate the program. In `rust-secp256k1`, this is caught at compile-time; in fact, it is impossible to compile code that will trigger any assertion failures in the upstream library.\n```\nuse secp256k1::rand;\nuse secp256k1::{Secp256k1, Message};\nuse secp256k1::hashes::{sha256, Hash};\nlet secp = Secp256k1::new();\nlet (secret_key, public_key) = secp.generate_keypair(&mut rand::rng());\nlet digest = sha256::Hash::hash(\"Hello World!\".as_bytes());\nlet message = Message::from_digest(digest.to_byte_array());\nlet sig = secp.sign_ecdsa(message, &secret_key);\nassert!(secp.verify_ecdsa(message, &sig, &public_key).is_ok());\n```\n\nIf the \u201cglobal-context\u201d feature is enabled you have access to an alternate API.\n```\nuse secp256k1::{rand, generate_keypair, Message};\nuse secp256k1::hashes::{sha256, Hash};\nlet (secret_key, public_key) = generate_keypair(&mut rand::rng());\nlet digest = sha256::Hash::hash(\"Hello World!\".as_bytes());\nlet message = Message::from_digest(digest.to_byte_array());\nlet sig = secret_key.sign_ecdsa(message);\nassert!(sig.verify(message, &public_key).is_ok());\n```\n\nThe above code requires `rust-secp256k1` to be compiled with the `rand`, `hashes`, and `std` feature enabled, to get access to `generate_keypair`\u27e84\u27e9 Alternately, keys and messages can be parsed from slices, like\n```\nuse secp256k1::{Secp256k1, Message, SecretKey, PublicKey};\nlet secp = Secp256k1::new();\nlet secret_key = SecretKey::from_slice(&[0xcd; 32]).expect(\"32 bytes, within curve order\");\nlet public_key = PublicKey::from_secret_key(&secp, &secret_key);\n// If the supplied byte slice was *not* the output of a cryptographic hash function this would\n// be cryptographically broken. It has been trivially used in the past to execute attacks.\nlet message = Message::from_digest(compute_hash(b\"CSW is not Satoshi\"));\nlet sig = secp.sign_ecdsa(message, &secret_key);\nassert!(secp.verify_ecdsa(message, &sig, &public_key).is_ok());\n```\n\nUsers who only want to verify signatures can use a cheaper context, like so:\n```\nuse secp256k1::{Secp256k1, Message, ecdsa, PublicKey};\nlet secp = Secp256k1::verification_only();\nlet public_key = PublicKey::from_slice(&[\n  0x02,\n  0xc6, 0x6e, 0x7d, 0x89, 0x66, 0xb5, 0xc5, 0x55,\n  0xaf, 0x58, 0x05, 0x98, 0x9d, 0xa9, 0xfb, 0xf8,\n  0xdb, 0x95, 0xe1, 0x56, 0x31, 0xce, 0x35, 0x8c,\n  0x3a, 0x17, 0x10, 0xc9, 0x62, 0x67, 0x90, 0x63,\n]).expect(\"public keys must be 33 or 65 bytes, serialized according to SEC 2\");\nlet message = Message::from_digest([\n  0xaa, 0xdf, 0x7d, 0xe7, 0x82, 0x03, 0x4f, 0xbe,\n  0x3d, 0x3d, 0xb2, 0xcb, 0x13, 0xc0, 0xcd, 0x91,\n  0xbf, 0x41, 0xcb, 0x08, 0xfa, 0xc7, 0xbd, 0x61,\n  0xd5, 0x44, 0x53, 0xcf, 0x6e, 0x82, 0xb4, 0x50,\n]);\nlet sig = ecdsa::Signature::from_compact(&[\n  0xdc, 0x4d, 0xc2, 0x64, 0xa9, 0xfe, 0xf1, 0x7a,\n  0x3f, 0x25, 0x34, 0x49, 0xcf, 0x8c, 0x39, 0x7a,\n  0xb6, 0xf1, 0x6f, 0xb3, 0xd6, 0x3d, 0x86, 0x94,\n  0x0b, 0x55, 0x86, 0x82, 0x3d, 0xfd, 0x02, 0xae,\n  0x3b, 0x46, 0x1b, 0xb4, 0x33, 0x6b, 0x5e, 0xcb,\n  0xae, 0xfd, 0x66, 0x27, 0xaa, 0x92, 0x2e, 0xfc,\n  0x04, 0x8f, 0xec, 0x0c, 0x88, 0x1c, 0x10, 0xc4,\n  0xc9, 0x42, 0x8f, 0xca, 0x69, 0xc1, 0x32, 0xa2,\n]).expect(\"compact signatures are 64 bytes; DER signatures are 68-72 bytes\");\nassert!(secp.verify_ecdsa(message, &sig, &public_key).is_ok());\n```\n\nObserve that the same code using, say `signing_only`\u27e85\u27e9 to generate a context would simply not compile.\n### \u00a7\u27e86\u27e9Crate features/optional dependencies\nThis crate provides the following opt-in Cargo features:\n  * `std` - use standard Rust library, enabled by default.\n  * `alloc` - use the `alloc` standard Rust library to provide heap allocations.\n  * `rand` - use `rand` library to provide random generator (e.g. to generate keys).\n  * `hashes` - use the `hashes` library.\n  * `recovery` - enable functions that can compute the public key from signature.\n  * `lowmemory` - optimize the library for low-memory environments.\n  * `global-context` - enable use of global secp256k1 context (implies `std`).\n  * `serde` - implements serialization and deserialization for types in this crate using `serde`. **Important** : `serde` encoding is **not** the same as consensus encoding!\n\n\n## Re-exports\u00a7\u27e87\u27e9\n\n`pub extern crate hashes[](https://docs.rs/bitcoin_hashes/0.14.0/x86_64-unknown-linux-gnu/bitcoin_hashes/index.html \"mod bitcoin_hashes\");`\n\n\n`pub use crate::scalar::Scalar[](https://docs.rs/secp256k1/latest/secp256k1/scalar/struct.Scalar.html \"struct secp256k1::scalar::Scalar\");`\n\n\n`pub use rand[](https://docs.rs/rand/0.9.1/x86_64-unknown-linux-gnu/rand/index.html \"mod rand\");``rand`\n\n\n`pub use secp256k1_sys[](https://docs.rs/secp256k1-sys/0.11.0/x86_64-unknown-linux-gnu/secp256k1_sys/index.html \"mod secp256k1_sys\") as ffi;`\n\n\n`pub use serde[](https://docs.rs/serde/1.0.219/x86_64-unknown-linux-gnu/serde/index.html \"mod serde\");``serde`\n\n## Modules\u00a7\u27e88\u27e9\n\nconstants\u27e89\u27e9\n    Constants related to the API and the underlying curve.\n\necdh\u27e810\u27e9\n    Support for shared secret computations.\n\necdsa\u27e811\u27e9\n    Structs and functionality related to the ECDSA signature algorithm.\n\nellswift\u27e812\u27e9\n    This module provides an implementation of ElligatorSwift as well as a version of x-only ECDH using it (including compatibility with BIP324).\n\nglobal\u27e813\u27e9`global-context` and `std`\n    Module implementing a singleton pattern for a global `Secp256k1` context.\n\nscalar\u27e814\u27e9\n    Provides `Scalar`\u27e815\u27e9 and related types.\n\nschnorr\u27e816\u27e9\n    Support for schnorr signatures.\n## Macros\u00a7\u27e817\u27e9\n\nimpl_array_newtype\u27e818\u27e9\n    Implement methods and traits for types that contain an inner array.\n## Structs\u00a7\u27e819\u27e9\n\nAllPreallocated\u27e820\u27e9\n    Represents the set of all capabilities (preallocated memory).\n\nInvalidParityValue\u27e821\u27e9\n    Error returned when conversion from an integer to `Parity` fails.\n\nKeypair\u27e822\u27e9\n    Opaque data structure that holds a keypair consisting of a secret and a public key.\n\nMessage\u27e823\u27e9\n    A (hashed) message input to an ECDSA signature.\n\nPublicKey\u27e824\u27e9\n    Public key - used to verify ECDSA signatures and to do Taproot tweaks.\n\nSecp256k1\u27e825\u27e9\n    The secp256k1 engine, used to execute all signature operations.\n\nSecretKey\u27e826\u27e9\n    Secret key - a 256-bit key used to create ECDSA and Taproot signatures.\n\nSignOnlyPreallocated\u27e827\u27e9\n    Represents the set of capabilities needed for signing (preallocated memory).\n\nVerifyOnlyPreallocated\u27e828\u27e9\n    Represents the set of capabilities needed for verification (preallocated memory).\n\nXOnlyPublicKey\u27e829\u27e9\n    An x-only public key, used for verification of Taproot signatures and serialized according to BIP-340.\n## Enums\u00a7\u27e830\u27e9\n\nAll\u27e831\u27e9`alloc`\n    Represents the set of all capabilities.\n\nError\u27e832\u27e9\n    The main error type for this library.\n\nParity\u27e833\u27e9\n    Represents the parity passed between FFI function calls.\n\nSignOnly\u27e834\u27e9`alloc`\n    Represents the set of capabilities needed for signing.\n\nVerifyOnly\u27e835\u27e9`alloc`\n    Represents the set of capabilities needed for verification.\n## Statics\u00a7\u27e836\u27e9\n\nSECP256K1\u27e837\u27e9`global-context` and `std`\n    A global static context to avoid repeatedly creating contexts.\n## Traits\u00a7\u27e838\u27e9\n\nContext\u27e839\u27e9\n    A trait for all kinds of contexts that lets you define the exact flags and a function to deallocate memory. It isn\u2019t possible to implement this for types outside this crate.\n\nPreallocatedContext\u27e840\u27e9\n    Trait marking that a particular context object internally points to memory that must outlive `'a`\n\nSigning\u27e841\u27e9\n    Marker trait for indicating that an instance of `Secp256k1`\u27e825\u27e9 can be used for signing.\n\nThirtyTwoByteHash\u27e842\u27e9Deprecated\n    Trait describing something that promises to be a 32-byte uniformly random number.\n\nVerification\u27e843\u27e9\n    Marker trait for indicating that an instance of `Secp256k1`\u27e825\u27e9 can be used for verification.\n## Functions\u00a7\u27e844\u27e9\n\ngenerate_keypair\u27e845\u27e9`global-context` and `rand`\n    Generates a random keypair using the global `SECP256K1`\u27e837\u27e9 context.\n",
            "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/secp256k1/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/secp256k1/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/secp256k1/latest/src/secp256k1/lib.rs.html#3-1052: Source\n\u27e84\u27e9 https://docs.rs/secp256k1/latest/secp256k1/struct.Secp256k1.html#method.generate_keypair: `generate_keypair`\n\u27e85\u27e9 https://docs.rs/secp256k1/latest/secp256k1/struct.Secp256k1.html#method.signing_only: `signing_only`\n\u27e86\u27e9 https://docs.rs/secp256k1/latest/secp256k1/#crate-featuresoptional-dependencies: \u00a7\n\u27e87\u27e9 https://docs.rs/secp256k1/latest/secp256k1/#reexports: \u00a7\n\u27e88\u27e9 https://docs.rs/secp256k1/latest/secp256k1/#modules: \u00a7\n\u27e89\u27e9 https://docs.rs/secp256k1/latest/secp256k1/constants/index.html: mod secp256k1::constants - constants\n\u27e810\u27e9 https://docs.rs/secp256k1/latest/secp256k1/ecdh/index.html: mod secp256k1::ecdh - ecdh\n\u27e811\u27e9 https://docs.rs/secp256k1/latest/secp256k1/ecdsa/index.html: mod secp256k1::ecdsa - ecdsa\n\u27e812\u27e9 https://docs.rs/secp256k1/latest/secp256k1/ellswift/index.html: mod secp256k1::ellswift - ellswift\n\u27e813\u27e9 https://docs.rs/secp256k1/latest/secp256k1/global/index.html: mod secp256k1::global - global\n\u27e814\u27e9 https://docs.rs/secp256k1/latest/secp256k1/scalar/index.html: mod secp256k1::scalar - scalar\n\u27e815\u27e9 https://docs.rs/secp256k1/latest/secp256k1/scalar/struct.Scalar.html: struct secp256k1::scalar::Scalar - `Scalar`\n\u27e816\u27e9 https://docs.rs/secp256k1/latest/secp256k1/schnorr/index.html: mod secp256k1::schnorr - schnorr\n\u27e817\u27e9 https://docs.rs/secp256k1/latest/secp256k1/#macros: \u00a7\n\u27e818\u27e9 https://docs.rs/secp256k1/latest/secp256k1/macro.impl_array_newtype.html: macro secp256k1::impl_array_newtype - impl_array_newtype\n\u27e819\u27e9 https://docs.rs/secp256k1/latest/secp256k1/#structs: \u00a7\n\u27e820\u27e9 https://docs.rs/secp256k1/latest/secp256k1/struct.AllPreallocated.html: struct secp256k1::AllPreallocated - AllPreallocated\n\u27e821\u27e9 https://docs.rs/secp256k1/latest/secp256k1/struct.InvalidParityValue.html: struct secp256k1::InvalidParityValue - InvalidParityValue\n\u27e822\u27e9 https://docs.rs/secp256k1/latest/secp256k1/struct.Keypair.html: struct secp256k1::Keypair - Keypair\n\u27e823\u27e9 https://docs.rs/secp256k1/latest/secp256k1/struct.Message.html: struct secp256k1::Message - Message\n\u27e824\u27e9 https://docs.rs/secp256k1/latest/secp256k1/struct.PublicKey.html: struct secp256k1::PublicKey - PublicKey\n\u27e825\u27e9 https://docs.rs/secp256k1/latest/secp256k1/struct.Secp256k1.html: struct secp256k1::Secp256k1 - Secp256k1\n\u27e826\u27e9 https://docs.rs/secp256k1/latest/secp256k1/struct.SecretKey.html: struct secp256k1::SecretKey - SecretKey\n\u27e827\u27e9 https://docs.rs/secp256k1/latest/secp256k1/struct.SignOnlyPreallocated.html: struct secp256k1::SignOnlyPreallocated - SignOnlyPreallocated\n\u27e828\u27e9 https://docs.rs/secp256k1/latest/secp256k1/struct.VerifyOnlyPreallocated.html: struct secp256k1::VerifyOnlyPreallocated - VerifyOnlyPreallocated\n\u27e829\u27e9 https://docs.rs/secp256k1/latest/secp256k1/struct.XOnlyPublicKey.html: struct secp256k1::XOnlyPublicKey - XOnlyPublicKey\n\u27e830\u27e9 https://docs.rs/secp256k1/latest/secp256k1/#enums: \u00a7\n\u27e831\u27e9 https://docs.rs/secp256k1/latest/secp256k1/enum.All.html: enum secp256k1::All - All\n\u27e832\u27e9 https://docs.rs/secp256k1/latest/secp256k1/enum.Error.html: enum secp256k1::Error - Error\n\u27e833\u27e9 https://docs.rs/secp256k1/latest/secp256k1/enum.Parity.html: enum secp256k1::Parity - Parity\n\u27e834\u27e9 https://docs.rs/secp256k1/latest/secp256k1/enum.SignOnly.html: enum secp256k1::SignOnly - SignOnly\n\u27e835\u27e9 https://docs.rs/secp256k1/latest/secp256k1/enum.VerifyOnly.html: enum secp256k1::VerifyOnly - VerifyOnly\n\u27e836\u27e9 https://docs.rs/secp256k1/latest/secp256k1/#statics: \u00a7\n\u27e837\u27e9 https://docs.rs/secp256k1/latest/secp256k1/static.SECP256K1.html: static secp256k1::SECP256K1 - SECP256K1\n\u27e838\u27e9 https://docs.rs/secp256k1/latest/secp256k1/#traits: \u00a7\n\u27e839\u27e9 https://docs.rs/secp256k1/latest/secp256k1/trait.Context.html: trait secp256k1::Context - Context\n\u27e840\u27e9 https://docs.rs/secp256k1/latest/secp256k1/trait.PreallocatedContext.html: trait secp256k1::PreallocatedContext - PreallocatedContext\n\u27e841\u27e9 https://docs.rs/secp256k1/latest/secp256k1/trait.Signing.html: trait secp256k1::Signing - Signing\n\u27e842\u27e9 https://docs.rs/secp256k1/latest/secp256k1/trait.ThirtyTwoByteHash.html: trait secp256k1::ThirtyTwoByteHash - ThirtyTwoByteHash\n\u27e843\u27e9 https://docs.rs/secp256k1/latest/secp256k1/trait.Verification.html: trait secp256k1::Verification - Verification\n\u27e844\u27e9 https://docs.rs/secp256k1/latest/secp256k1/#functions: \u00a7\n\u27e845\u27e9 https://docs.rs/secp256k1/latest/secp256k1/fn.generate_keypair.html: fn secp256k1::generate_keypair - generate_keypair\n",
            "fit_markdown": "",
            "fit_html": ""
          },
          "downloads": 0,
          "github_stars": 0,
          "dependencies": [],
          "features": {},
          "code_snippets": [],
          "readme_sections": {},
          "librs_downloads": null,
          "source": "crates.io",
          "enhanced_scraping": {},
          "enhanced_features": [],
          "enhanced_dependencies": [],
          "readme_summary": "The `secp256k1` crate provides Rust bindings for Pieter Wuille's secp256k1 library, enabling fast and secure manipulation of ECDSA and Schnorr signatures on the secp256k1 curve, widely used in Bitcoin and related systems. It leverages Rust's type system to prevent API misuse at compile-time and offers feature-gated functionality for random key generation, serialization (via `serde`), and low-memory optimization. Key features include customizable contexts for signing, verification, or parsing, support for shared secret computations (ECDH), and optional global context usage.",
          "feature_summary": null,
          "use_case": "Cryptography",
          "score": 8.5,
          "factual_counterfactual": "### Pair 1: Key Generation and Contexts\n\u2705 Factual: The `secp256k1` crate allows users to generate key pairs using the `generate_keypair` method, but this requires the `rand` and `std` features to be enabled for random number generation.  \n\u274c Counterfactual: The `secp256k1` crate provides key pair generation without requiring any optional features, as random number generation is built into the core library.\n\n---\n\n### Pair 2: Sidechannel Protection\n\u2705 Factual: When compiled with the `rand` and `std` features, the `secp256k1` crate includes sidechannel protections that re-blind certain operations on secret key data to enhance security.  \n\u274c Counterfactual: Sidechannel protections in the `secp256k1` crate are enabled by default, regardless of whether optional features like `rand` or `std` are enabled.\n\n---\n\n### Pair 3: Serde Encoding\n\u2705 Factual: The `secp256k1` crate supports serialization and deserialization of objects using the `serde` feature, but the encoding differs from Bitcoin's consensus encoding.  \n\u274c Counterfactual: The `serde` feature in the `secp256k1` crate ensures that serialized objects are fully compatible with Bitcoin's consensus encoding.",
          "source_analysis": null,
          "user_behavior": null,
          "security": null
        }
      },
      "irl_score": 8.6,
      "execution_id": "exec-383b2753-307ec8a2-1751264708",
      "timestamp": "2025-06-30T06:25:08.131366+00:00",
      "canon_version": "1.3.0"
    },
    "rule_zero_compliant": true
  }
]