[
  {
    "execution_id": "exec-54445c66-a1bc3ec9-1751258907",
    "timestamp": "2025-06-30T04:48:27.041256+00:00",
    "sacred_chain": {
      "input_data": "serde_json",
      "context_sources": [
        "crates.io",
        "github.com",
        "lib.rs",
        "docs.rs"
      ],
      "reasoning_steps": [
        "Input canonicalized: 'serde_json' -> 'serde_json'",
        "Context gathered from 4 validated sources",
        "Metadata extracted: 4 fields",
        "Documentation analyzed: quality 7.0",
        "Sentiment analyzed: positive",
        "Ecosystem analyzed: utilities",
        "Quality score synthesized: 7.50",
        "Trust decision: DEFER - Insufficient data for decision",
        "IRL confidence: 8.600"
      ],
      "suggestion": "ALLOW: Positive community sentiment",
      "verdict": "DEFER",
      "audit_info": {
        "metadata": {
          "name": "serde_json",
          "type": "rust_crate",
          "source": "manual_input",
          "extraction_method": "irl_engine"
        },
        "sentiment": {
          "quality_score": 7.0,
          "completeness": 0.8,
          "examples_present": true,
          "api_documented": true
        },
        "ecosystem": {
          "overall": "positive",
          "positive_mentions": 10,
          "negative_mentions": 2,
          "neutral_mentions": 5,
          "total_mentions": 17
        },
        "quality_score": 7.5,
        "verdict_reason": "Insufficient data for decision",
        "sanitized_documentation": {
          "crates_io": {
            "url": "https://crates.io/crates/serde_json",
            "title": "serde_json v1.0.140",
            "content": {
              "raw_markdown": "#  serde_json v1.0.140\nA JSON serialization file format \n  * [ #json ](https://crates.io/keywords/json)\n  * [ #serde ](https://crates.io/keywords/serde)\n  * [ #serialization ](https://crates.io/keywords/serialization)\n\n\n  * [ Readme ](https://crates.io/crates/serde_json)\n  * [ 172 Versions ](https://crates.io/crates/serde_json/versions)\n  * [ Dependencies ](https://crates.io/crates/serde_json/dependencies)\n  * [ Dependents ](https://crates.io/crates/serde_json/reverse_dependencies)\n\n\n## Metadata\n4 months ago \nv1.56.0 \n[ MIT ](https://choosealicense.com/licenses/mit) OR [ Apache-2.0 ](https://choosealicense.com/licenses/apache-2.0)\n151 KiB \n## Install\nRun the following Cargo command in your project directory:\ncargo add serde_json\nOr add the following line to your Cargo.toml:\nserde_json = \"1.0.140\"\n## Documentation\n[ docs.rs/serde_json ](https://docs.rs/serde_json)\n## Repository\n[ github.com/serde-rs/json ](https://github.com/serde-rs/json)\n## Owners\n## Categories\n  * [Encoding](https://crates.io/categories/encoding)\n  * [No standard library](https://crates.io/categories/no-std)\n  * [Parser implementations](https://crates.io/categories/parser-implementations)\n\n\n[ Report crate ](https://crates.io/support?crate=serde_json&inquire=crate-violation)\n### Stats Overview\n492,386,229 Downloads all time\n172 Versions published\n#### Downloads over the last 90 days\nDisplay as \nStacked \n  * Stacked \n  * Unstacked \n\n\nLoading\u2026\n",
              "markdown_with_citations": "#  serde_json v1.0.140\nA JSON serialization file format \n  *  #json \u27e81\u27e9\n  *  #serde \u27e82\u27e9\n  *  #serialization \u27e83\u27e9\n\n\n  *  Readme \u27e84\u27e9\n  *  172 Versions \u27e85\u27e9\n  *  Dependencies \u27e86\u27e9\n  *  Dependents \u27e87\u27e9\n\n\n## Metadata\n4 months ago \nv1.56.0 \n MIT \u27e88\u27e9 OR  Apache-2.0 \u27e89\u27e9\n151 KiB \n## Install\nRun the following Cargo command in your project directory:\ncargo add serde_json\nOr add the following line to your Cargo.toml:\nserde_json = \"1.0.140\"\n## Documentation\n docs.rs/serde_json \u27e810\u27e9\n## Repository\n github.com/serde-rs/json \u27e811\u27e9\n## Owners\n## Categories\n  * Encoding\u27e812\u27e9\n  * No standard library\u27e813\u27e9\n  * Parser implementations\u27e814\u27e9\n\n\n Report crate \u27e815\u27e9\n### Stats Overview\n492,386,229 Downloads all time\n172 Versions published\n#### Downloads over the last 90 days\nDisplay as \nStacked \n  * Stacked \n  * Unstacked \n\n\nLoading\u2026\n",
              "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://crates.io/keywords/json:  #json \n\u27e82\u27e9 https://crates.io/keywords/serde:  #serde \n\u27e83\u27e9 https://crates.io/keywords/serialization:  #serialization \n\u27e84\u27e9 https://crates.io/crates/serde_json:  Readme \n\u27e85\u27e9 https://crates.io/crates/serde_json/versions:  172 Versions \n\u27e86\u27e9 https://crates.io/crates/serde_json/dependencies:  Dependencies \n\u27e87\u27e9 https://crates.io/crates/serde_json/reverse_dependencies:  Dependents \n\u27e88\u27e9 https://choosealicense.com/licenses/mit:  MIT \n\u27e89\u27e9 https://choosealicense.com/licenses/apache-2.0:  Apache-2.0 \n\u27e810\u27e9 https://docs.rs/serde_json:  docs.rs/serde_json \n\u27e811\u27e9 https://github.com/serde-rs/json:  github.com/serde-rs/json \n\u27e812\u27e9 https://crates.io/categories/encoding: Encoding\n\u27e813\u27e9 https://crates.io/categories/no-std: No standard library\n\u27e814\u27e9 https://crates.io/categories/parser-implementations: Parser implementations\n\u27e815\u27e9 https://crates.io/support?crate=serde_json&inquire=crate-violation:  Report crate \n",
              "fit_markdown": "",
              "fit_html": ""
            },
            "structured_data": {},
            "quality_score": 3.0,
            "extraction_method": "crawl4ai",
            "error": null,
            "metadata": {
              "doc_type": "docs",
              "content_length": 1433,
              "has_structured_data": false,
              "crawl_success": true
            },
            "timestamp": "112696.9495207"
          },
          "docs_rs": {
            "url": "https://docs.rs/serde_json",
            "title": "Crate serde_jsonCopy item path",
            "content": {
              "raw_markdown": "[](https://docs.rs/serde_json/latest/serde_json/all.html \"show sidebar\")\n# Crate serde_jsonCopy item path\n[Settings](https://docs.rs/serde_json/latest/settings.html)\n[Help](https://docs.rs/serde_json/latest/help.html)\nSummary[Source](https://docs.rs/serde_json/latest/src/serde_json/lib.rs.html#1-437)\nExpand description\n## [\u00a7](https://docs.rs/serde_json/latest/serde_json/#serde-json)Serde JSON\nJSON is a ubiquitous open-standard format that uses human-readable text to transmit data objects consisting of key-value pairs.\n```\n{\n  \"name\": \"John Doe\",\n  \"age\": 43,\n  \"address\": {\n    \"street\": \"10 Downing Street\",\n    \"city\": \"London\"\n  },\n  \"phones\": [\n    \"+44 1234567\",\n    \"+44 2345678\"\n  ]\n}\n```\n\nThere are three common ways that you might find yourself needing to work with JSON data in Rust.\n  * **As text data.** An unprocessed string of JSON data that you receive on an HTTP endpoint, read from a file, or prepare to send to a remote server.\n  * **As an untyped or loosely typed representation.** Maybe you want to check that some JSON data is valid before passing it on, but without knowing the structure of what it contains. Or you want to do very basic manipulations like insert a key in a particular spot.\n  * **As a strongly typed Rust data structure.** When you expect all or most of your data to conform to a particular structure and want to get real work done without JSON\u2019s loosey-goosey nature tripping you up.\n\n\nSerde JSON provides efficient, flexible, safe ways of converting data between each of these representations.\n## [\u00a7](https://docs.rs/serde_json/latest/serde_json/#operating-on-untyped-json-values)Operating on untyped JSON values\nAny valid JSON data can be manipulated in the following recursive enum representation. This data structure is [`serde_json::Value`](https://docs.rs/serde_json/latest/serde_json/enum.Value.html \"enum serde_json::Value\").\n```\nenum Value {\n  Null,\n  Bool(bool),\n  Number(Number),\n  String(String),\n  Array(Vec<Value>),\n  Object(Map<String, Value>),\n}\n```\n\nA string of JSON data can be parsed into a `serde_json::Value` by the [`serde_json::from_str`](https://docs.rs/serde_json/latest/serde_json/fn.from_str.html \"fn serde_json::from_str\") function. There is also [`from_slice`](https://docs.rs/serde_json/latest/serde_json/fn.from_slice.html \"fn serde_json::from_slice\") for parsing from a byte slice `&[u8]` and [`from_reader`](https://docs.rs/serde_json/latest/serde_json/fn.from_reader.html \"fn serde_json::from_reader\") for parsing from any `io::Read` like a File or a TCP stream.\n```\nuse serde_json::{Result, Value};\nfn untyped_example() -> Result<()> {\n  // Some JSON input data as a &str. Maybe this comes from the user.\n  let data = r#\"\n    {\n      \"name\": \"John Doe\",\n      \"age\": 43,\n      \"phones\": [\n        \"+44 1234567\",\n        \"+44 2345678\"\n      ]\n    }\"#;\n  // Parse the string of data into serde_json::Value.\n  let v: Value = serde_json::from_str(data)?;\n  // Access parts of the data by indexing with square brackets.\n  println!(\"Please call {} at the number {}\", v[\"name\"], v[\"phones\"][0]);\n  Ok(())\n}\n```\n\nThe result of square bracket indexing like `v[\"name\"]` is a borrow of the data at that index, so the type is `&Value`. A JSON map can be indexed with string keys, while a JSON array can be indexed with integer keys. If the type of the data is not right for the type with which it is being indexed, or if a map does not contain the key being indexed, or if the index into a vector is out of bounds, the returned element is `Value::Null`.\nWhen a `Value` is printed, it is printed as a JSON string. So in the code above, the output looks like `Please call \"John Doe\" at the number \"+44 1234567\"`. The quotation marks appear because `v[\"name\"]` is a `&Value` containing a JSON string and its JSON representation is `\"John Doe\"`. Printing as a plain string without quotation marks involves converting from a JSON string to a Rust string with [`as_str()`](https://docs.rs/serde_json/latest/serde_json/enum.Value.html#method.as_str \"method serde_json::Value::as_str\") or avoiding the use of `Value` as described in the following section.\nThe `Value` representation is sufficient for very basic tasks but can be tedious to work with for anything more significant. Error handling is verbose to implement correctly, for example imagine trying to detect the presence of unrecognized fields in the input data. The compiler is powerless to help you when you make a mistake, for example imagine typoing `v[\"name\"]` as `v[\"nmae\"]` in one of the dozens of places it is used in your code.\n## [\u00a7](https://docs.rs/serde_json/latest/serde_json/#parsing-json-as-strongly-typed-data-structures)Parsing JSON as strongly typed data structures\nSerde provides a powerful way of mapping JSON data into Rust data structures largely automatically.\n```\nuse serde::{Deserialize, Serialize};\nuse serde_json::Result;\n#[derive(Serialize, Deserialize)]\nstruct Person {\n  name: String,\n  age: u8,\n  phones: Vec<String>,\n}\nfn typed_example() -> Result<()> {\n  // Some JSON input data as a &str. Maybe this comes from the user.\n  let data = r#\"\n    {\n      \"name\": \"John Doe\",\n      \"age\": 43,\n      \"phones\": [\n        \"+44 1234567\",\n        \"+44 2345678\"\n      ]\n    }\"#;\n  // Parse the string of data into a Person object. This is exactly the\n  // same function as the one that produced serde_json::Value above, but\n  // now we are asking it for a Person as output.\n  let p: Person = serde_json::from_str(data)?;\n  // Do things just like with any other Rust data structure.\n  println!(\"Please call {} at the number {}\", p.name, p.phones[0]);\n  Ok(())\n}\n```\n\nThis is the same `serde_json::from_str` function as before, but this time we assign the return value to a variable of type `Person` so Serde will automatically interpret the input data as a `Person` and produce informative error messages if the layout does not conform to what a `Person` is expected to look like.\nAny type that implements Serde\u2019s `Deserialize` trait can be deserialized this way. This includes built-in Rust standard library types like `Vec<T>` and `HashMap<K, V>`, as well as any structs or enums annotated with `#[derive(Deserialize)]`.\nOnce we have `p` of type `Person`, our IDE and the Rust compiler can help us use it correctly like they do for any other Rust code. The IDE can autocomplete field names to prevent typos, which was impossible in the `serde_json::Value` representation. And the Rust compiler can check that when we write `p.phones[0]`, then `p.phones` is guaranteed to be a `Vec<String>` so indexing into it makes sense and produces a `String`.\n## [\u00a7](https://docs.rs/serde_json/latest/serde_json/#constructing-json-values)Constructing JSON values\nSerde JSON provides a [`json!` macro](https://docs.rs/serde_json/latest/serde_json/macro.json.html \"macro serde_json::json\") to build `serde_json::Value` objects with very natural JSON syntax.\n```\nuse serde_json::json;\nfn main() {\n  // The type of `john` is `serde_json::Value`\n  let john = json!({\n    \"name\": \"John Doe\",\n    \"age\": 43,\n    \"phones\": [\n      \"+44 1234567\",\n      \"+44 2345678\"\n    ]\n  });\n  println!(\"first phone number: {}\", john[\"phones\"][0]);\n  // Convert to a string of JSON and print it out\n  println!(\"{}\", john.to_string());\n}\n```\n\nThe `Value::to_string()` function converts a `serde_json::Value` into a `String` of JSON text.\nOne neat thing about the `json!` macro is that variables and expressions can be interpolated directly into the JSON value as you are building it. Serde will check at compile time that the value you are interpolating is able to be represented as JSON.\n```\nlet full_name = \"John Doe\";\nlet age_last_year = 42;\n// The type of `john` is `serde_json::Value`\nlet john = json!({\n  \"name\": full_name,\n  \"age\": age_last_year + 1,\n  \"phones\": [\n    format!(\"+44 {}\", random_phone())\n  ]\n});\n```\n\nThis is amazingly convenient, but we have the problem we had before with `Value`: the IDE and Rust compiler cannot help us if we get it wrong. Serde JSON provides a better way of serializing strongly-typed data structures into JSON text.\n## [\u00a7](https://docs.rs/serde_json/latest/serde_json/#creating-json-by-serializing-data-structures)Creating JSON by serializing data structures\nA data structure can be converted to a JSON string by [`serde_json::to_string`](https://docs.rs/serde_json/latest/serde_json/fn.to_string.html \"fn serde_json::to_string\"). There is also [`serde_json::to_vec`](https://docs.rs/serde_json/latest/serde_json/fn.to_vec.html \"fn serde_json::to_vec\") which serializes to a `Vec<u8>` and [`serde_json::to_writer`](https://docs.rs/serde_json/latest/serde_json/fn.to_writer.html \"fn serde_json::to_writer\") which serializes to any `io::Write` such as a File or a TCP stream.\n```\nuse serde::{Deserialize, Serialize};\nuse serde_json::Result;\n#[derive(Serialize, Deserialize)]\nstruct Address {\n  street: String,\n  city: String,\n}\nfn print_an_address() -> Result<()> {\n  // Some data structure.\n  let address = Address {\n    street: \"10 Downing Street\".to_owned(),\n    city: \"London\".to_owned(),\n  };\n  // Serialize it to a JSON string.\n  let j = serde_json::to_string(&address)?;\n  // Print, write to a file, or send to an HTTP server.\n  println!(\"{}\", j);\n  Ok(())\n}\n```\n\nAny type that implements Serde\u2019s `Serialize` trait can be serialized this way. This includes built-in Rust standard library types like `Vec<T>` and `HashMap<K, V>`, as well as any structs or enums annotated with `#[derive(Serialize)]`.\n## [\u00a7](https://docs.rs/serde_json/latest/serde_json/#no-std-support)No-std support\nAs long as there is a memory allocator, it is possible to use serde_json without the rest of the Rust standard library. Disable the default \u201cstd\u201d feature and enable the \u201calloc\u201d feature:\n```\n[dependencies]\nserde_json = { version = \"1.0\", default-features = false, features = [\"alloc\"] }\n```\n\nFor JSON support in Serde without a memory allocator, please see the [`serde-json-core`](https://github.com/rust-embedded-community/serde-json-core) crate.\n## Modules[\u00a7](https://docs.rs/serde_json/latest/serde_json/#modules)\n\n[de](https://docs.rs/serde_json/latest/serde_json/de/index.html \"mod serde_json::de\")\n    Deserialize JSON data to a Rust data structure.\n\n[error](https://docs.rs/serde_json/latest/serde_json/error/index.html \"mod serde_json::error\")\n    When serializing or deserializing JSON goes wrong.\n\n[map](https://docs.rs/serde_json/latest/serde_json/map/index.html \"mod serde_json::map\")\n    A map of String to serde_json::Value.\n\n[ser](https://docs.rs/serde_json/latest/serde_json/ser/index.html \"mod serde_json::ser\")`std`\n    Serialize a Rust data structure into JSON data.\n\n[value](https://docs.rs/serde_json/latest/serde_json/value/index.html \"mod serde_json::value\")\n    The Value enum, a loosely typed way of representing any valid JSON value.\n## Macros[\u00a7](https://docs.rs/serde_json/latest/serde_json/#macros)\n\n[json](https://docs.rs/serde_json/latest/serde_json/macro.json.html \"macro serde_json::json\")\n    Construct a `serde_json::Value` from a JSON literal.\n## Structs[\u00a7](https://docs.rs/serde_json/latest/serde_json/#structs)\n\n[Deserializer](https://docs.rs/serde_json/latest/serde_json/struct.Deserializer.html \"struct serde_json::Deserializer\")\n    A structure that deserializes JSON into Rust values.\n\n[Error](https://docs.rs/serde_json/latest/serde_json/struct.Error.html \"struct serde_json::Error\")\n    This type represents all possible errors that can occur when serializing or deserializing JSON data.\n\n[Map](https://docs.rs/serde_json/latest/serde_json/struct.Map.html \"struct serde_json::Map\")\n    Represents a JSON key/value type.\n\n[Number](https://docs.rs/serde_json/latest/serde_json/struct.Number.html \"struct serde_json::Number\")\n    Represents a JSON number, whether integer or floating point.\n\n[Serializer](https://docs.rs/serde_json/latest/serde_json/struct.Serializer.html \"struct serde_json::Serializer\")`std`\n    A structure for serializing Rust values into JSON.\n\n[StreamDeserializer](https://docs.rs/serde_json/latest/serde_json/struct.StreamDeserializer.html \"struct serde_json::StreamDeserializer\")\n    Iterator that deserializes a stream into multiple JSON values.\n## Enums[\u00a7](https://docs.rs/serde_json/latest/serde_json/#enums)\n\n[Value](https://docs.rs/serde_json/latest/serde_json/enum.Value.html \"enum serde_json::Value\")\n    Represents any valid JSON value.\n## Functions[\u00a7](https://docs.rs/serde_json/latest/serde_json/#functions)\n\n[from_reader](https://docs.rs/serde_json/latest/serde_json/fn.from_reader.html \"fn serde_json::from_reader\")`std`\n    Deserialize an instance of type `T` from an I/O stream of JSON.\n\n[from_slice](https://docs.rs/serde_json/latest/serde_json/fn.from_slice.html \"fn serde_json::from_slice\")\n    Deserialize an instance of type `T` from bytes of JSON text.\n\n[from_str](https://docs.rs/serde_json/latest/serde_json/fn.from_str.html \"fn serde_json::from_str\")\n    Deserialize an instance of type `T` from a string of JSON text.\n\n[from_value](https://docs.rs/serde_json/latest/serde_json/fn.from_value.html \"fn serde_json::from_value\")\n    Interpret a `serde_json::Value` as an instance of type `T`.\n\n[to_string](https://docs.rs/serde_json/latest/serde_json/fn.to_string.html \"fn serde_json::to_string\")`std`\n    Serialize the given data structure as a String of JSON.\n\n[to_string_pretty](https://docs.rs/serde_json/latest/serde_json/fn.to_string_pretty.html \"fn serde_json::to_string_pretty\")`std`\n    Serialize the given data structure as a pretty-printed String of JSON.\n\n[to_value](https://docs.rs/serde_json/latest/serde_json/fn.to_value.html \"fn serde_json::to_value\")\n    Convert a `T` into `serde_json::Value` which is an enum that can represent any valid JSON data.\n\n[to_vec](https://docs.rs/serde_json/latest/serde_json/fn.to_vec.html \"fn serde_json::to_vec\")`std`\n    Serialize the given data structure as a JSON byte vector.\n\n[to_vec_pretty](https://docs.rs/serde_json/latest/serde_json/fn.to_vec_pretty.html \"fn serde_json::to_vec_pretty\")`std`\n    Serialize the given data structure as a pretty-printed JSON byte vector.\n\n[to_writer](https://docs.rs/serde_json/latest/serde_json/fn.to_writer.html \"fn serde_json::to_writer\")`std`\n    Serialize the given data structure as JSON into the I/O stream.\n\n[to_writer_pretty](https://docs.rs/serde_json/latest/serde_json/fn.to_writer_pretty.html \"fn serde_json::to_writer_pretty\")`std`\n    Serialize the given data structure as pretty-printed JSON into the I/O stream.\n## Type Aliases[\u00a7](https://docs.rs/serde_json/latest/serde_json/#types)\n\n[Result](https://docs.rs/serde_json/latest/serde_json/type.Result.html \"type serde_json::Result\")\n    Alias for a `Result` with the error type `serde_json::Error`.\n",
              "markdown_with_citations": "[](https://docs.rs/serde_json/latest/serde_json/all.html \"show sidebar\")\n# Crate serde_jsonCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\n## \u00a7\u27e84\u27e9Serde JSON\nJSON is a ubiquitous open-standard format that uses human-readable text to transmit data objects consisting of key-value pairs.\n```\n{\n  \"name\": \"John Doe\",\n  \"age\": 43,\n  \"address\": {\n    \"street\": \"10 Downing Street\",\n    \"city\": \"London\"\n  },\n  \"phones\": [\n    \"+44 1234567\",\n    \"+44 2345678\"\n  ]\n}\n```\n\nThere are three common ways that you might find yourself needing to work with JSON data in Rust.\n  * **As text data.** An unprocessed string of JSON data that you receive on an HTTP endpoint, read from a file, or prepare to send to a remote server.\n  * **As an untyped or loosely typed representation.** Maybe you want to check that some JSON data is valid before passing it on, but without knowing the structure of what it contains. Or you want to do very basic manipulations like insert a key in a particular spot.\n  * **As a strongly typed Rust data structure.** When you expect all or most of your data to conform to a particular structure and want to get real work done without JSON\u2019s loosey-goosey nature tripping you up.\n\n\nSerde JSON provides efficient, flexible, safe ways of converting data between each of these representations.\n## \u00a7\u27e85\u27e9Operating on untyped JSON values\nAny valid JSON data can be manipulated in the following recursive enum representation. This data structure is `serde_json::Value`\u27e86\u27e9.\n```\nenum Value {\n  Null,\n  Bool(bool),\n  Number(Number),\n  String(String),\n  Array(Vec<Value>),\n  Object(Map<String, Value>),\n}\n```\n\nA string of JSON data can be parsed into a `serde_json::Value` by the `serde_json::from_str`\u27e87\u27e9 function. There is also `from_slice`\u27e88\u27e9 for parsing from a byte slice `&[u8]` and `from_reader`\u27e89\u27e9 for parsing from any `io::Read` like a File or a TCP stream.\n```\nuse serde_json::{Result, Value};\nfn untyped_example() -> Result<()> {\n  // Some JSON input data as a &str. Maybe this comes from the user.\n  let data = r#\"\n    {\n      \"name\": \"John Doe\",\n      \"age\": 43,\n      \"phones\": [\n        \"+44 1234567\",\n        \"+44 2345678\"\n      ]\n    }\"#;\n  // Parse the string of data into serde_json::Value.\n  let v: Value = serde_json::from_str(data)?;\n  // Access parts of the data by indexing with square brackets.\n  println!(\"Please call {} at the number {}\", v[\"name\"], v[\"phones\"][0]);\n  Ok(())\n}\n```\n\nThe result of square bracket indexing like `v[\"name\"]` is a borrow of the data at that index, so the type is `&Value`. A JSON map can be indexed with string keys, while a JSON array can be indexed with integer keys. If the type of the data is not right for the type with which it is being indexed, or if a map does not contain the key being indexed, or if the index into a vector is out of bounds, the returned element is `Value::Null`.\nWhen a `Value` is printed, it is printed as a JSON string. So in the code above, the output looks like `Please call \"John Doe\" at the number \"+44 1234567\"`. The quotation marks appear because `v[\"name\"]` is a `&Value` containing a JSON string and its JSON representation is `\"John Doe\"`. Printing as a plain string without quotation marks involves converting from a JSON string to a Rust string with `as_str()`\u27e810\u27e9 or avoiding the use of `Value` as described in the following section.\nThe `Value` representation is sufficient for very basic tasks but can be tedious to work with for anything more significant. Error handling is verbose to implement correctly, for example imagine trying to detect the presence of unrecognized fields in the input data. The compiler is powerless to help you when you make a mistake, for example imagine typoing `v[\"name\"]` as `v[\"nmae\"]` in one of the dozens of places it is used in your code.\n## \u00a7\u27e811\u27e9Parsing JSON as strongly typed data structures\nSerde provides a powerful way of mapping JSON data into Rust data structures largely automatically.\n```\nuse serde::{Deserialize, Serialize};\nuse serde_json::Result;\n#[derive(Serialize, Deserialize)]\nstruct Person {\n  name: String,\n  age: u8,\n  phones: Vec<String>,\n}\nfn typed_example() -> Result<()> {\n  // Some JSON input data as a &str. Maybe this comes from the user.\n  let data = r#\"\n    {\n      \"name\": \"John Doe\",\n      \"age\": 43,\n      \"phones\": [\n        \"+44 1234567\",\n        \"+44 2345678\"\n      ]\n    }\"#;\n  // Parse the string of data into a Person object. This is exactly the\n  // same function as the one that produced serde_json::Value above, but\n  // now we are asking it for a Person as output.\n  let p: Person = serde_json::from_str(data)?;\n  // Do things just like with any other Rust data structure.\n  println!(\"Please call {} at the number {}\", p.name, p.phones[0]);\n  Ok(())\n}\n```\n\nThis is the same `serde_json::from_str` function as before, but this time we assign the return value to a variable of type `Person` so Serde will automatically interpret the input data as a `Person` and produce informative error messages if the layout does not conform to what a `Person` is expected to look like.\nAny type that implements Serde\u2019s `Deserialize` trait can be deserialized this way. This includes built-in Rust standard library types like `Vec<T>` and `HashMap<K, V>`, as well as any structs or enums annotated with `#[derive(Deserialize)]`.\nOnce we have `p` of type `Person`, our IDE and the Rust compiler can help us use it correctly like they do for any other Rust code. The IDE can autocomplete field names to prevent typos, which was impossible in the `serde_json::Value` representation. And the Rust compiler can check that when we write `p.phones[0]`, then `p.phones` is guaranteed to be a `Vec<String>` so indexing into it makes sense and produces a `String`.\n## \u00a7\u27e812\u27e9Constructing JSON values\nSerde JSON provides a `json!` macro\u27e813\u27e9 to build `serde_json::Value` objects with very natural JSON syntax.\n```\nuse serde_json::json;\nfn main() {\n  // The type of `john` is `serde_json::Value`\n  let john = json!({\n    \"name\": \"John Doe\",\n    \"age\": 43,\n    \"phones\": [\n      \"+44 1234567\",\n      \"+44 2345678\"\n    ]\n  });\n  println!(\"first phone number: {}\", john[\"phones\"][0]);\n  // Convert to a string of JSON and print it out\n  println!(\"{}\", john.to_string());\n}\n```\n\nThe `Value::to_string()` function converts a `serde_json::Value` into a `String` of JSON text.\nOne neat thing about the `json!` macro is that variables and expressions can be interpolated directly into the JSON value as you are building it. Serde will check at compile time that the value you are interpolating is able to be represented as JSON.\n```\nlet full_name = \"John Doe\";\nlet age_last_year = 42;\n// The type of `john` is `serde_json::Value`\nlet john = json!({\n  \"name\": full_name,\n  \"age\": age_last_year + 1,\n  \"phones\": [\n    format!(\"+44 {}\", random_phone())\n  ]\n});\n```\n\nThis is amazingly convenient, but we have the problem we had before with `Value`: the IDE and Rust compiler cannot help us if we get it wrong. Serde JSON provides a better way of serializing strongly-typed data structures into JSON text.\n## \u00a7\u27e814\u27e9Creating JSON by serializing data structures\nA data structure can be converted to a JSON string by `serde_json::to_string`\u27e815\u27e9. There is also `serde_json::to_vec`\u27e816\u27e9 which serializes to a `Vec<u8>` and `serde_json::to_writer`\u27e817\u27e9 which serializes to any `io::Write` such as a File or a TCP stream.\n```\nuse serde::{Deserialize, Serialize};\nuse serde_json::Result;\n#[derive(Serialize, Deserialize)]\nstruct Address {\n  street: String,\n  city: String,\n}\nfn print_an_address() -> Result<()> {\n  // Some data structure.\n  let address = Address {\n    street: \"10 Downing Street\".to_owned(),\n    city: \"London\".to_owned(),\n  };\n  // Serialize it to a JSON string.\n  let j = serde_json::to_string(&address)?;\n  // Print, write to a file, or send to an HTTP server.\n  println!(\"{}\", j);\n  Ok(())\n}\n```\n\nAny type that implements Serde\u2019s `Serialize` trait can be serialized this way. This includes built-in Rust standard library types like `Vec<T>` and `HashMap<K, V>`, as well as any structs or enums annotated with `#[derive(Serialize)]`.\n## \u00a7\u27e818\u27e9No-std support\nAs long as there is a memory allocator, it is possible to use serde_json without the rest of the Rust standard library. Disable the default \u201cstd\u201d feature and enable the \u201calloc\u201d feature:\n```\n[dependencies]\nserde_json = { version = \"1.0\", default-features = false, features = [\"alloc\"] }\n```\n\nFor JSON support in Serde without a memory allocator, please see the `serde-json-core`\u27e819\u27e9 crate.\n## Modules\u00a7\u27e820\u27e9\n\nde\u27e821\u27e9\n    Deserialize JSON data to a Rust data structure.\n\nerror\u27e822\u27e9\n    When serializing or deserializing JSON goes wrong.\n\nmap\u27e823\u27e9\n    A map of String to serde_json::Value.\n\nser\u27e824\u27e9`std`\n    Serialize a Rust data structure into JSON data.\n\nvalue\u27e825\u27e9\n    The Value enum, a loosely typed way of representing any valid JSON value.\n## Macros\u00a7\u27e826\u27e9\n\njson\u27e813\u27e9\n    Construct a `serde_json::Value` from a JSON literal.\n## Structs\u00a7\u27e827\u27e9\n\nDeserializer\u27e828\u27e9\n    A structure that deserializes JSON into Rust values.\n\nError\u27e829\u27e9\n    This type represents all possible errors that can occur when serializing or deserializing JSON data.\n\nMap\u27e830\u27e9\n    Represents a JSON key/value type.\n\nNumber\u27e831\u27e9\n    Represents a JSON number, whether integer or floating point.\n\nSerializer\u27e832\u27e9`std`\n    A structure for serializing Rust values into JSON.\n\nStreamDeserializer\u27e833\u27e9\n    Iterator that deserializes a stream into multiple JSON values.\n## Enums\u00a7\u27e834\u27e9\n\nValue\u27e86\u27e9\n    Represents any valid JSON value.\n## Functions\u00a7\u27e835\u27e9\n\nfrom_reader\u27e89\u27e9`std`\n    Deserialize an instance of type `T` from an I/O stream of JSON.\n\nfrom_slice\u27e88\u27e9\n    Deserialize an instance of type `T` from bytes of JSON text.\n\nfrom_str\u27e87\u27e9\n    Deserialize an instance of type `T` from a string of JSON text.\n\nfrom_value\u27e836\u27e9\n    Interpret a `serde_json::Value` as an instance of type `T`.\n\nto_string\u27e815\u27e9`std`\n    Serialize the given data structure as a String of JSON.\n\nto_string_pretty\u27e837\u27e9`std`\n    Serialize the given data structure as a pretty-printed String of JSON.\n\nto_value\u27e838\u27e9\n    Convert a `T` into `serde_json::Value` which is an enum that can represent any valid JSON data.\n\nto_vec\u27e816\u27e9`std`\n    Serialize the given data structure as a JSON byte vector.\n\nto_vec_pretty\u27e839\u27e9`std`\n    Serialize the given data structure as a pretty-printed JSON byte vector.\n\nto_writer\u27e817\u27e9`std`\n    Serialize the given data structure as JSON into the I/O stream.\n\nto_writer_pretty\u27e840\u27e9`std`\n    Serialize the given data structure as pretty-printed JSON into the I/O stream.\n## Type Aliases\u00a7\u27e841\u27e9\n\nResult\u27e842\u27e9\n    Alias for a `Result` with the error type `serde_json::Error`.\n",
              "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/serde_json/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/serde_json/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/serde_json/latest/src/serde_json/lib.rs.html#1-437: Source\n\u27e84\u27e9 https://docs.rs/serde_json/latest/serde_json/#serde-json: \u00a7\n\u27e85\u27e9 https://docs.rs/serde_json/latest/serde_json/#operating-on-untyped-json-values: \u00a7\n\u27e86\u27e9 https://docs.rs/serde_json/latest/serde_json/enum.Value.html: enum serde_json::Value - `serde_json::Value`\n\u27e87\u27e9 https://docs.rs/serde_json/latest/serde_json/fn.from_str.html: fn serde_json::from_str - `serde_json::from_str`\n\u27e88\u27e9 https://docs.rs/serde_json/latest/serde_json/fn.from_slice.html: fn serde_json::from_slice - `from_slice`\n\u27e89\u27e9 https://docs.rs/serde_json/latest/serde_json/fn.from_reader.html: fn serde_json::from_reader - `from_reader`\n\u27e810\u27e9 https://docs.rs/serde_json/latest/serde_json/enum.Value.html#method.as_str: method serde_json::Value::as_str - `as_str()`\n\u27e811\u27e9 https://docs.rs/serde_json/latest/serde_json/#parsing-json-as-strongly-typed-data-structures: \u00a7\n\u27e812\u27e9 https://docs.rs/serde_json/latest/serde_json/#constructing-json-values: \u00a7\n\u27e813\u27e9 https://docs.rs/serde_json/latest/serde_json/macro.json.html: macro serde_json::json - `json!` macro\n\u27e814\u27e9 https://docs.rs/serde_json/latest/serde_json/#creating-json-by-serializing-data-structures: \u00a7\n\u27e815\u27e9 https://docs.rs/serde_json/latest/serde_json/fn.to_string.html: fn serde_json::to_string - `serde_json::to_string`\n\u27e816\u27e9 https://docs.rs/serde_json/latest/serde_json/fn.to_vec.html: fn serde_json::to_vec - `serde_json::to_vec`\n\u27e817\u27e9 https://docs.rs/serde_json/latest/serde_json/fn.to_writer.html: fn serde_json::to_writer - `serde_json::to_writer`\n\u27e818\u27e9 https://docs.rs/serde_json/latest/serde_json/#no-std-support: \u00a7\n\u27e819\u27e9 https://github.com/rust-embedded-community/serde-json-core: `serde-json-core`\n\u27e820\u27e9 https://docs.rs/serde_json/latest/serde_json/#modules: \u00a7\n\u27e821\u27e9 https://docs.rs/serde_json/latest/serde_json/de/index.html: mod serde_json::de - de\n\u27e822\u27e9 https://docs.rs/serde_json/latest/serde_json/error/index.html: mod serde_json::error - error\n\u27e823\u27e9 https://docs.rs/serde_json/latest/serde_json/map/index.html: mod serde_json::map - map\n\u27e824\u27e9 https://docs.rs/serde_json/latest/serde_json/ser/index.html: mod serde_json::ser - ser\n\u27e825\u27e9 https://docs.rs/serde_json/latest/serde_json/value/index.html: mod serde_json::value - value\n\u27e826\u27e9 https://docs.rs/serde_json/latest/serde_json/#macros: \u00a7\n\u27e827\u27e9 https://docs.rs/serde_json/latest/serde_json/#structs: \u00a7\n\u27e828\u27e9 https://docs.rs/serde_json/latest/serde_json/struct.Deserializer.html: struct serde_json::Deserializer - Deserializer\n\u27e829\u27e9 https://docs.rs/serde_json/latest/serde_json/struct.Error.html: struct serde_json::Error - Error\n\u27e830\u27e9 https://docs.rs/serde_json/latest/serde_json/struct.Map.html: struct serde_json::Map - Map\n\u27e831\u27e9 https://docs.rs/serde_json/latest/serde_json/struct.Number.html: struct serde_json::Number - Number\n\u27e832\u27e9 https://docs.rs/serde_json/latest/serde_json/struct.Serializer.html: struct serde_json::Serializer - Serializer\n\u27e833\u27e9 https://docs.rs/serde_json/latest/serde_json/struct.StreamDeserializer.html: struct serde_json::StreamDeserializer - StreamDeserializer\n\u27e834\u27e9 https://docs.rs/serde_json/latest/serde_json/#enums: \u00a7\n\u27e835\u27e9 https://docs.rs/serde_json/latest/serde_json/#functions: \u00a7\n\u27e836\u27e9 https://docs.rs/serde_json/latest/serde_json/fn.from_value.html: fn serde_json::from_value - from_value\n\u27e837\u27e9 https://docs.rs/serde_json/latest/serde_json/fn.to_string_pretty.html: fn serde_json::to_string_pretty - to_string_pretty\n\u27e838\u27e9 https://docs.rs/serde_json/latest/serde_json/fn.to_value.html: fn serde_json::to_value - to_value\n\u27e839\u27e9 https://docs.rs/serde_json/latest/serde_json/fn.to_vec_pretty.html: fn serde_json::to_vec_pretty - to_vec_pretty\n\u27e840\u27e9 https://docs.rs/serde_json/latest/serde_json/fn.to_writer_pretty.html: fn serde_json::to_writer_pretty - to_writer_pretty\n\u27e841\u27e9 https://docs.rs/serde_json/latest/serde_json/#types: \u00a7\n\u27e842\u27e9 https://docs.rs/serde_json/latest/serde_json/type.Result.html: type serde_json::Result - Result\n",
              "fit_markdown": "",
              "fit_html": ""
            },
            "structured_data": {},
            "quality_score": 4.0,
            "extraction_method": "crawl4ai",
            "error": null,
            "metadata": {
              "doc_type": "docs",
              "content_length": 14681,
              "has_structured_data": false,
              "crawl_success": true
            },
            "timestamp": "112697.50581"
          },
          "lib_rs": {
            "url": "https://lib.rs/crates/serde_json",
            "title": "Untitled",
            "content": {
              "raw_markdown": "###  [140 stable releases](https://lib.rs/crates/serde_json/versions)\n1.0.140 |  Mar 3, 2025   \n---|---  \n1.0.138 |  Jan 28, 2025   \n1.0.134 |  Dec 21, 2024   \n1.0.133 |  Nov 17, 2024   \n0.6.0 |  Aug 31, 2015   \n#**1** in [Encoding](https://lib.rs/encoding \"Encoding and/or decoding data from one data format to another.\")\nDownload history 5001795/week @ 2025-03-08 5356656/week @ 2025-03-15 5424939/week @ 2025-03-22 4982612/week @ 2025-03-29 5355124/week @ 2025-04-05 4943083/week @ 2025-04-12 4887079/week @ 2025-04-19 4843174/week @ 2025-04-26 4711919/week @ 2025-05-03 4912812/week @ 2025-05-10 5162430/week @ 2025-05-17 4298016/week @ 2025-05-24 4386333/week @ 2025-05-31 4931178/week @ 2025-06-07 5669172/week @ 2025-06-14 5918068/week @ 2025-06-21\n**21,668,053** downloads per month Used in [**64,940** crates (36,524 directly)](https://lib.rs/crates/serde_json/rev)\n**MIT/Apache**\n570KB  13K  SLoC\n# Serde JSON [![Build Status](https://img.shields.io/github/actions/workflow/status/serde-rs/json/ci.yml?branch=master)](https://github.com/serde-rs/json/actions?query=branch%3Amaster) [![Latest Version](https://img.shields.io/crates/v/serde_json.svg)](https://crates.io/crates/serde_json) [![Rustc Version 1.36+](https://img.shields.io/badge/rustc-1.36+-lightgray.svg)](https://blog.rust-lang.org/2019/07/04/Rust-1.36.0.html)\n**Serde is a framework for _ser_ ializing and _de_ serializing Rust data structures efficiently and generically.**\n```\n```[``dependencies``]`\n`serde_json ``=` ``\"`1.0`\"``\n``\n```\n\nYou may be looking for:\n  * [JSON API documentation](https://docs.rs/serde_json)\n  * [Serde API documentation](https://docs.rs/serde)\n  * [Detailed documentation about Serde](https://serde.rs/)\n  * [Setting up ````#``[``derive```(```Serialize`,` Deserialize```)```]````](https://serde.rs/derive.html)\n  * [Release notes](https://github.com/serde-rs/json/releases)\n\n\nJSON is a ubiquitous open-standard format that uses human-readable text to transmit data objects consisting of key-value pairs.\n```\n```{`\n  ````\"`name`\"`````:` ```\"`John Doe`\"````,`\n  ```\"`age`\"````:` ``43```,`\n  ```\"`address`\"````:` ```{`\n````\"`street`\"`````:` ```\"`10 Downing Street`\"````,`\n```\"`city`\"````:` ```\"`London`\"```\n  `}``,`\n  ```\"`phones`\"````:` ```[`\n    ``\"`+44 1234567`\"```,`\n    ``\"`+44 2345678`\"``\n  `]```\n`}`\n\n```\n\nThere are three common ways that you might find yourself needing to work with JSON data in Rust.\n  * **As text data.** An unprocessed string of JSON data that you receive on an HTTP endpoint, read from a file, or prepare to send to a remote server.\n  * **As an untyped or loosely typed representation.** Maybe you want to check that some JSON data is valid before passing it on, but without knowing the structure of what it contains. Or you want to do very basic manipulations like insert a key in a particular spot.\n  * **As a strongly typed Rust data structure.** When you expect all or most of your data to conform to a particular structure and want to get real work done without JSON's loosey-goosey nature tripping you up.\n\n\nSerde JSON provides efficient, flexible, safe ways of converting data between each of these representations.\n## Operating on untyped JSON values\nAny valid JSON data can be manipulated in the following recursive enum representation. This data structure is [```serde_json`::``Value``](https://docs.rs/serde_json/1/serde_json/value/enum.Value.html).\n```\n```enum` `Value` ``{`\n  Null`,`\n  Bool`(``bool``)``,`\n  Number`(`Number`)``,`\n  `String``(``String``)``,`\n  Array`(```Vec``<`Value`>```)``,`\n  Object`(``Map`<``String`, Value`>```)``,`\n```}```\n`\n```\n\nA string of JSON data can be parsed into a ```serde_json`::``Value`` by the [```serde_json`::``from_str``](https://docs.rs/serde_json/1/serde_json/de/fn.from_str.html) function. There is also [``from_slice``](https://docs.rs/serde_json/1/serde_json/de/fn.from_slice.html) for parsing from a byte slice ```&``[``u8``]``` and [``from_reader``](https://docs.rs/serde_json/1/serde_json/de/fn.from_reader.html) for parsing from any ```io`::``Read`` like a File or a TCP stream.\n[ ![](https://img.gs/czjpqfbdkz/85/https://raw.githubusercontent.com/serde-rs/serde-rs.github.io/master/img/runtab.png) ](https://play.rust-lang.org/?edition=2018&gist=d69d8e3156d4bb81c4461b60b772ab72)\n```\n``use` `serde_json`::````{``Result``,` Value```}```;`\n``fn` `untyped_example`````(````)```` ``->` ``Result``<``(``)``>``` ````{`\n  ``//` Some JSON input data as a &str. Maybe this comes from the user.`\n  `let` data `=` ``r``#\"`\n    {\n      \"name\": \"John Doe\",\n      \"age\": 43,\n      \"phones\": [\n        \"+44 1234567\",\n        \"+44 2345678\"\n      ]\n    }`\"#```;`\n  ``//` Parse the string of data into serde_json::Value.`\n  `let` v`:` Value `=` `serde_json`::``from_str`(`data`)``?``;`\n  ``//` Access parts of the data by indexing with square brackets.`\n  `println!``(```\"`Please call `{}` at the number `{}``\"```,` v`[```\"`name`\"```]``,` v`[```\"`phones`\"```]``[``0``]``)``;`\n  `Ok``(``(``)``)`\n```}```\n`\n```\n\nThe result of square bracket indexing like ``v`[```\"`name`\"```]``` is a borrow of the data at that index, so the type is ```&`Value``. A JSON map can be indexed with string keys, while a JSON array can be indexed with integer keys. If the type of the data is not right for the type with which it is being indexed, or if a map does not contain the key being indexed, or if the index into a vector is out of bounds, the returned element is ```Value`::``Null``.\nWhen a ``Value`` is printed, it is printed as a JSON string. So in the code above, the output looks like ``Please call ``\"`John Doe`\"`` at the number ``\"`+44 1234567`\"````. The quotation marks appear because ``v`[```\"`name`\"```]``` is a ```&`Value`` containing a JSON string and its JSON representation is ````\"`John Doe`\"````. Printing as a plain string without quotation marks involves converting from a JSON string to a Rust string with [```as_str``(``)```](https://docs.rs/serde_json/1/serde_json/enum.Value.html#method.as_str) or avoiding the use of ``Value`` as described in the following section.\nThe ``Value`` representation is sufficient for very basic tasks but can be tedious to work with for anything more significant. Error handling is verbose to implement correctly, for example imagine trying to detect the presence of unrecognized fields in the input data. The compiler is powerless to help you when you make a mistake, for example imagine typoing ``v`[```\"`name`\"```]``` as ``v`[```\"`nmae`\"```]``` in one of the dozens of places it is used in your code.\n## Parsing JSON as strongly typed data structures\nSerde provides a powerful way of mapping JSON data into Rust data structures largely automatically.\n[ ![](https://img.gs/czjpqfbdkz/85/https://raw.githubusercontent.com/serde-rs/serde-rs.github.io/master/img/runtab.png) ](https://play.rust-lang.org/?edition=2018&gist=15cfab66d38ff8a15a9cf1d8d897ac68)\n```\n``use` `serde`::````{`Deserialize`,` Serialize```}```;`\n`use` `serde_json`::``Result`;`\n``#``[``derive```(```Serialize`,` Deserialize```)```]``\n``struct` ```Person` ````{`\n  `name``:` String,\n  `age``:` `u8`,\n  `phones``:` ``Vec``<``String``>``,\n```}```\n``fn` `typed_example`````(````)```` ``->` ``Result``<``(``)``>``` ````{`\n  ``//` Some JSON input data as a &str. Maybe this comes from the user.`\n  `let` data `=` ``r``#\"`\n    {\n      \"name\": \"John Doe\",\n      \"age\": 43,\n      \"phones\": [\n        \"+44 1234567\",\n        \"+44 2345678\"\n      ]\n    }`\"#```;`\n  ``//` Parse the string of data into a Person object. This is exactly the`\n  ``//` same function as the one that produced serde_json::Value above, but`\n  ``//` now we are asking it for a Person as output.`\n  `let` p`:` Person `=` `serde_json`::``from_str`(`data`)``?``;`\n  ``//` Do things just like with any other Rust data structure.`\n  `println!``(```\"`Please call `{}` at the number `{}``\"```,` p`.`name`,` p`.`phones`[``0``]``)``;`\n  `Ok``(``(``)``)`\n```}```\n`\n```\n\nThis is the same ```serde_json`::``from_str`` function as before, but this time we assign the return value to a variable of type ``Person`` so Serde will automatically interpret the input data as a ``Person`` and produce informative error messages if the layout does not conform to what a ``Person`` is expected to look like.\nAny type that implements Serde's ``Deserialize`` trait can be deserialized this way. This includes built-in Rust standard library types like ````Vec``<`T`>```` and ```HashMap`<`K, V`>````, as well as any structs or enums annotated with ````#``[``derive```(```Deserialize```)```]````.\nOnce we have ``p`` of type ``Person``, our IDE and the Rust compiler can help us use it correctly like they do for any other Rust code. The IDE can autocomplete field names to prevent typos, which was impossible in the ```serde_json`::``Value`` representation. And the Rust compiler can check that when we write ``p`.`phones`[``0``]```, then ``p`.`phones`` is guaranteed to be a ````Vec``<``String``>```` so indexing into it makes sense and produces a ```String```.\nThe necessary setup for using Serde's derive macros is explained on the _[Using derive](https://serde.rs/derive.html)_ page of the Serde site.\n## Constructing JSON values\nSerde JSON provides a [``json!`` macro](https://docs.rs/serde_json/1/serde_json/macro.json.html) to build ```serde_json`::``Value`` objects with very natural JSON syntax.\n[ ![](https://img.gs/czjpqfbdkz/85/https://raw.githubusercontent.com/serde-rs/serde-rs.github.io/master/img/runtab.png) ](https://play.rust-lang.org/?edition=2018&gist=6ccafad431d72b62e77cc34c8e879b24)\n```\n``use` `serde_json`::``json`;`\n``fn` `main`````(````)``````{`\n  ``//` The type of `john` is `serde_json::Value``\n  `let` john `=` `json!``(``{`\n    ``\"`name`\"```:` ``\"`John Doe`\"```,`\n    ``\"`age`\"```:` `43``,`\n    ``\"`phones`\"```:` `[`\n      ``\"`+44 1234567`\"```,`\n      ``\"`+44 2345678`\"``\n    `]`\n  `}``)``;`\n  `println!``(```\"`first phone number: `{}``\"```,` john`[```\"`phones`\"```]``[``0``]``)``;`\n  ``//` Convert to a string of JSON and print it out`\n  `println!``(```\"``{}``\"```,` john`.``to_string``(``)``)``;`\n```}```\n`\n```\n\nThe ```Value`::``to_string`(``)``` function converts a ```serde_json`::``Value`` into a ```String``` of JSON text.\nOne neat thing about the ``json!`` macro is that variables and expressions can be interpolated directly into the JSON value as you are building it. Serde will check at compile time that the value you are interpolating is able to be represented as JSON.\n[ ![](https://img.gs/czjpqfbdkz/85/https://raw.githubusercontent.com/serde-rs/serde-rs.github.io/master/img/runtab.png) ](https://play.rust-lang.org/?edition=2018&gist=f9101a6e61dfc9e02c6a67f315ed24f2)\n```\n``let` full_name `=` ``\"`John Doe`\"```;`\n`let` age_last_year `=` `42``;`\n``//` The type of `john` is `serde_json::Value``\n`let` john `=` `json!``(```{`\n  ``\"`name`\"```:` full_name`,`\n  ``\"`age`\"```:` age_last_year `+` `1``,`\n  ``\"`phones`\"```:` `[`\n    `format!``(```\"`+44 `{}``\"```,` `random_phone``(``)``)`\n  `]`\n```}```)``;`\n`\n```\n\nThis is amazingly convenient, but we have the problem we had before with ``Value``: the IDE and Rust compiler cannot help us if we get it wrong. Serde JSON provides a better way of serializing strongly-typed data structures into JSON text.\n## Creating JSON by serializing data structures\nA data structure can be converted to a JSON string by [```serde_json`::``to_string``](https://docs.rs/serde_json/1/serde_json/ser/fn.to_string.html). There is also [```serde_json`::``to_vec``](https://docs.rs/serde_json/1/serde_json/ser/fn.to_vec.html) which serializes to a ````Vec``<``u8``>```` and [```serde_json`::``to_writer``](https://docs.rs/serde_json/1/serde_json/ser/fn.to_writer.html) which serializes to any ```io`::``Write`` such as a File or a TCP stream.\n[ ![](https://img.gs/czjpqfbdkz/85/https://raw.githubusercontent.com/serde-rs/serde-rs.github.io/master/img/runtab.png) ](https://play.rust-lang.org/?edition=2018&gist=3472242a08ed2ff88a944f2a2283b0ee)\n```\n``use` `serde`::````{`Deserialize`,` Serialize```}```;`\n`use` `serde_json`::``Result`;`\n``#``[``derive```(```Serialize`,` Deserialize```)```]``\n``struct` ```Address` ````{`\n  `street``:` String,\n  `city``:` String,\n```}```\n``fn` `print_an_address`````(````)```` ``->` ``Result``<``(``)``>``` ````{`\n  ``//` Some data structure.`\n  `let` address `=` Address `{`\n    street`:` ``\"`10 Downing Street`\"```.``to_owned``(``)``,`\n    city`:` ``\"`London`\"```.``to_owned``(``)``,`\n  `}``;`\n  ``//` Serialize it to a JSON string.`\n  `let` j `=` `serde_json`::``to_string`(``&`address`)``?``;`\n  ``//` Print, write to a file, or send to an HTTP server.`\n  `println!``(```\"``{}``\"```,` j`)``;`\n  `Ok``(``(``)``)`\n```}```\n`\n```\n\nAny type that implements Serde's ``Serialize`` trait can be serialized this way. This includes built-in Rust standard library types like ````Vec``<`T`>```` and ```HashMap`<`K, V`>````, as well as any structs or enums annotated with ````#``[``derive```(```Serialize```)```]````.\n## Performance\nIt is fast. You should expect in the ballpark of 500 to 1000 megabytes per second deserialization and 600 to 900 megabytes per second serialization, depending on the characteristics of your data. This is competitive with the fastest C and C++ JSON libraries or even 30% faster for many use cases. Benchmarks live in the [serde-rs/json-benchmark](https://github.com/serde-rs/json-benchmark) repo.\n## Getting help\nSerde is one of the most widely used Rust libraries, so any place that Rustaceans congregate will be able to help you out. For chat, consider trying the [#rust-questions](https://discord.com/channels/273534239310479360/274215136414400513) or [#rust-beginners](https://discord.com/channels/273534239310479360/273541522815713281) channels of the unofficial community Discord (invite: <https://discord.gg/rust-lang-community>), the [#rust-usage](https://discord.com/channels/442252698964721669/443150878111694848) or [#beginners](https://discord.com/channels/442252698964721669/448238009733742612) channels of the official Rust Project Discord (invite: <https://discord.gg/rust-lang>), or the [#general](https://rust-lang.zulipchat.com/#narrow/stream/122651-general) stream in Zulip. For asynchronous, consider the [[rust] tag on StackOverflow](https://stackoverflow.com/questions/tagged/rust), the [/r/rust](https://www.reddit.com/r/rust) subreddit which has a pinned weekly easy questions post, or the Rust [Discourse forum](https://users.rust-lang.org). It's acceptable to file a support issue in this repo, but they tend not to get as many eyes as any of the above and may get closed without a response after some time.\n## No-std support\nAs long as there is a memory allocator, it is possible to use serde_json without the rest of the Rust standard library. Disable the default \"std\" feature and enable the \"alloc\" feature:\n```\n```[``dependencies``]`\n`serde_json = { version = \"1.0\", default-features = false, features ``=` ``[```\"`alloc`\"```]`` }\n``\n```\n\nFor JSON support in Serde without a memory allocator, please see the [``serde-json-core``](https://github.com/rust-embedded-community/serde-json-core) crate.\n#### License\nLicensed under either of [Apache License, Version 2.0](https://github.com/serde-rs/json/blob/762783414e6c4f8d670c9d87eb04913efb80d3be/LICENSE-APACHE) or [MIT license](https://github.com/serde-rs/json/blob/762783414e6c4f8d670c9d87eb04913efb80d3be/LICENSE-MIT) at your option.  Unless you explicitly state otherwise, any contribution intentionally submitted for inclusion in this crate by you, as defined in the Apache-2.0 license, shall be dual licensed as above, without any additional terms or conditions. \n#### Dependencies\n~230\u2013790KB  ~15K SLoC\n  * [preserve_order?](https://lib.rs/crates/serde_json/features#feature-preserve_order \"optional feature\") [indexmap](https://lib.rs/crates/indexmap \"new\") 2.2\n  * [itoa](https://lib.rs/crates/itoa \"1.0\")\n  * [memchr](https://lib.rs/crates/memchr \"2\")\n  * [ryu](https://lib.rs/crates/ryu \"1.0\")\n  * [serde](https://lib.rs/crates/serde \"1.0.194\")\n\n\n  * build `build.rs`\n  * dev  [automod](https://lib.rs/crates/automod \"1.0.11\")\n  * dev  [indoc](https://lib.rs/crates/indoc \"2.0.2\")\n  * dev  [ref-cast](https://lib.rs/crates/ref-cast \"1.0.18\")\n  * dev  [rustversion](https://lib.rs/crates/rustversion \"1.0.13\")\n  * dev  [serde_bytes](https://lib.rs/crates/serde_bytes \"0.11.10\")\n  * dev  [serde_derive](https://lib.rs/crates/serde_derive \"1.0.166\")\n  * dev  [serde_stacker](https://lib.rs/crates/serde_stacker \"0.1.8\")\n  * dev  [trybuild](https://lib.rs/crates/trybuild \"1.0.81\")[+diff](https://lib.rs/crates/trybuild/features#feature-diff)\n\n\n#### [Other features](https://lib.rs/crates/serde_json/features)\n  * [alloc](https://lib.rs/crates/serde_json/features#feature-alloc)\n  * [arbitrary_precision](https://lib.rs/crates/serde_json/features#feature-arbitrary_precision)\n  * [float_roundtrip](https://lib.rs/crates/serde_json/features#feature-float_roundtrip)\n  * [raw_value](https://lib.rs/crates/serde_json/features#feature-raw_value)\n  * [std](https://lib.rs/crates/serde_json/features#feature-std)\n  * [unbounded_depth](https://lib.rs/crates/serde_json/features#feature-unbounded_depth)\n\n\n  *[SLoC]: approx. additional lines of code\n",
              "markdown_with_citations": "###  140 stable releases\u27e81\u27e9\n1.0.140 |  Mar 3, 2025   \n---|---  \n1.0.138 |  Jan 28, 2025   \n1.0.134 |  Dec 21, 2024   \n1.0.133 |  Nov 17, 2024   \n0.6.0 |  Aug 31, 2015   \n#**1** in Encoding\u27e82\u27e9\nDownload history 5001795/week @ 2025-03-08 5356656/week @ 2025-03-15 5424939/week @ 2025-03-22 4982612/week @ 2025-03-29 5355124/week @ 2025-04-05 4943083/week @ 2025-04-12 4887079/week @ 2025-04-19 4843174/week @ 2025-04-26 4711919/week @ 2025-05-03 4912812/week @ 2025-05-10 5162430/week @ 2025-05-17 4298016/week @ 2025-05-24 4386333/week @ 2025-05-31 4931178/week @ 2025-06-07 5669172/week @ 2025-06-14 5918068/week @ 2025-06-21\n**21,668,053** downloads per month Used in **64,940** crates (36,524 directly)\u27e83\u27e9\n**MIT/Apache**\n570KB  13K  SLoC\n# Serde JSON ![Build Status\u27e84\u27e9](https://github.com/serde-rs/json/actions?query=branch%3Amaster) ![Latest Version\u27e85\u27e9](https://crates.io/crates/serde_json) ![Rustc Version 1.36+\u27e86\u27e9](https://blog.rust-lang.org/2019/07/04/Rust-1.36.0.html)\n**Serde is a framework for _ser_ ializing and _de_ serializing Rust data structures efficiently and generically.**\n```\n```[``dependencies``]`\n`serde_json ``=` ``\"`1.0`\"``\n``\n```\n\nYou may be looking for:\n  * JSON API documentation\u27e87\u27e9\n  * Serde API documentation\u27e88\u27e9\n  * Detailed documentation about Serde\u27e89\u27e9\n  * [Setting up ````#``[``derive```(```Serialize`,` Deserialize```)```]````](https://serde.rs/derive.html)\n  * Release notes\u27e810\u27e9\n\n\nJSON is a ubiquitous open-standard format that uses human-readable text to transmit data objects consisting of key-value pairs.\n```\n```{`\n  ````\"`name`\"`````:` ```\"`John Doe`\"````,`\n  ```\"`age`\"````:` ``43```,`\n  ```\"`address`\"````:` ```{`\n````\"`street`\"`````:` ```\"`10 Downing Street`\"````,`\n```\"`city`\"````:` ```\"`London`\"```\n  `}``,`\n  ```\"`phones`\"````:` ```[`\n    ``\"`+44 1234567`\"```,`\n    ``\"`+44 2345678`\"``\n  `]```\n`}`\n\n```\n\nThere are three common ways that you might find yourself needing to work with JSON data in Rust.\n  * **As text data.** An unprocessed string of JSON data that you receive on an HTTP endpoint, read from a file, or prepare to send to a remote server.\n  * **As an untyped or loosely typed representation.** Maybe you want to check that some JSON data is valid before passing it on, but without knowing the structure of what it contains. Or you want to do very basic manipulations like insert a key in a particular spot.\n  * **As a strongly typed Rust data structure.** When you expect all or most of your data to conform to a particular structure and want to get real work done without JSON's loosey-goosey nature tripping you up.\n\n\nSerde JSON provides efficient, flexible, safe ways of converting data between each of these representations.\n## Operating on untyped JSON values\nAny valid JSON data can be manipulated in the following recursive enum representation. This data structure is ```serde_json`::``Value``\u27e811\u27e9.\n```\n```enum` `Value` ``{`\n  Null`,`\n  Bool`(``bool``)``,`\n  Number`(`Number`)``,`\n  `String``(``String``)``,`\n  Array`(```Vec``<`Value`>```)``,`\n  Object`(``Map`<``String`, Value`>```)``,`\n```}```\n`\n```\n\nA string of JSON data can be parsed into a ```serde_json`::``Value`` by the ```serde_json`::``from_str``\u27e812\u27e9 function. There is also ``from_slice``\u27e813\u27e9 for parsing from a byte slice ```&``[``u8``]``` and ``from_reader``\u27e814\u27e9 for parsing from any ```io`::``Read`` like a File or a TCP stream.\n ![\u27e815\u27e9 ](https://play.rust-lang.org/?edition=2018&gist=d69d8e3156d4bb81c4461b60b772ab72)\n```\n``use` `serde_json`::````{``Result``,` Value```}```;`\n``fn` `untyped_example`````(````)```` ``->` ``Result``<``(``)``>``` ````{`\n  ``//` Some JSON input data as a &str. Maybe this comes from the user.`\n  `let` data `=` ``r``#\"`\n    {\n      \"name\": \"John Doe\",\n      \"age\": 43,\n      \"phones\": [\n        \"+44 1234567\",\n        \"+44 2345678\"\n      ]\n    }`\"#```;`\n  ``//` Parse the string of data into serde_json::Value.`\n  `let` v`:` Value `=` `serde_json`::``from_str`(`data`)``?``;`\n  ``//` Access parts of the data by indexing with square brackets.`\n  `println!``(```\"`Please call `{}` at the number `{}``\"```,` v`[```\"`name`\"```]``,` v`[```\"`phones`\"```]``[``0``]``)``;`\n  `Ok``(``(``)``)`\n```}```\n`\n```\n\nThe result of square bracket indexing like ``v`[```\"`name`\"```]``` is a borrow of the data at that index, so the type is ```&`Value``. A JSON map can be indexed with string keys, while a JSON array can be indexed with integer keys. If the type of the data is not right for the type with which it is being indexed, or if a map does not contain the key being indexed, or if the index into a vector is out of bounds, the returned element is ```Value`::``Null``.\nWhen a ``Value`` is printed, it is printed as a JSON string. So in the code above, the output looks like ``Please call ``\"`John Doe`\"`` at the number ``\"`+44 1234567`\"````. The quotation marks appear because ``v`[```\"`name`\"```]``` is a ```&`Value`` containing a JSON string and its JSON representation is ````\"`John Doe`\"````. Printing as a plain string without quotation marks involves converting from a JSON string to a Rust string with ```as_str``(``)```\u27e816\u27e9 or avoiding the use of ``Value`` as described in the following section.\nThe ``Value`` representation is sufficient for very basic tasks but can be tedious to work with for anything more significant. Error handling is verbose to implement correctly, for example imagine trying to detect the presence of unrecognized fields in the input data. The compiler is powerless to help you when you make a mistake, for example imagine typoing ``v`[```\"`name`\"```]``` as ``v`[```\"`nmae`\"```]``` in one of the dozens of places it is used in your code.\n## Parsing JSON as strongly typed data structures\nSerde provides a powerful way of mapping JSON data into Rust data structures largely automatically.\n ![\u27e815\u27e9 ](https://play.rust-lang.org/?edition=2018&gist=15cfab66d38ff8a15a9cf1d8d897ac68)\n```\n``use` `serde`::````{`Deserialize`,` Serialize```}```;`\n`use` `serde_json`::``Result`;`\n``#``[``derive```(```Serialize`,` Deserialize```)```]``\n``struct` ```Person` ````{`\n  `name``:` String,\n  `age``:` `u8`,\n  `phones``:` ``Vec``<``String``>``,\n```}```\n``fn` `typed_example`````(````)```` ``->` ``Result``<``(``)``>``` ````{`\n  ``//` Some JSON input data as a &str. Maybe this comes from the user.`\n  `let` data `=` ``r``#\"`\n    {\n      \"name\": \"John Doe\",\n      \"age\": 43,\n      \"phones\": [\n        \"+44 1234567\",\n        \"+44 2345678\"\n      ]\n    }`\"#```;`\n  ``//` Parse the string of data into a Person object. This is exactly the`\n  ``//` same function as the one that produced serde_json::Value above, but`\n  ``//` now we are asking it for a Person as output.`\n  `let` p`:` Person `=` `serde_json`::``from_str`(`data`)``?``;`\n  ``//` Do things just like with any other Rust data structure.`\n  `println!``(```\"`Please call `{}` at the number `{}``\"```,` p`.`name`,` p`.`phones`[``0``]``)``;`\n  `Ok``(``(``)``)`\n```}```\n`\n```\n\nThis is the same ```serde_json`::``from_str`` function as before, but this time we assign the return value to a variable of type ``Person`` so Serde will automatically interpret the input data as a ``Person`` and produce informative error messages if the layout does not conform to what a ``Person`` is expected to look like.\nAny type that implements Serde's ``Deserialize`` trait can be deserialized this way. This includes built-in Rust standard library types like ````Vec``<`T`>```` and ```HashMap`<`K, V`>````, as well as any structs or enums annotated with ````#``[``derive```(```Deserialize```)```]````.\nOnce we have ``p`` of type ``Person``, our IDE and the Rust compiler can help us use it correctly like they do for any other Rust code. The IDE can autocomplete field names to prevent typos, which was impossible in the ```serde_json`::``Value`` representation. And the Rust compiler can check that when we write ``p`.`phones`[``0``]```, then ``p`.`phones`` is guaranteed to be a ````Vec``<``String``>```` so indexing into it makes sense and produces a ```String```.\nThe necessary setup for using Serde's derive macros is explained on the _Using derive\u27e817\u27e9_ page of the Serde site.\n## Constructing JSON values\nSerde JSON provides a ``json!`` macro\u27e818\u27e9 to build ```serde_json`::``Value`` objects with very natural JSON syntax.\n ![\u27e815\u27e9 ](https://play.rust-lang.org/?edition=2018&gist=6ccafad431d72b62e77cc34c8e879b24)\n```\n``use` `serde_json`::``json`;`\n``fn` `main`````(````)``````{`\n  ``//` The type of `john` is `serde_json::Value``\n  `let` john `=` `json!``(``{`\n    ``\"`name`\"```:` ``\"`John Doe`\"```,`\n    ``\"`age`\"```:` `43``,`\n    ``\"`phones`\"```:` `[`\n      ``\"`+44 1234567`\"```,`\n      ``\"`+44 2345678`\"``\n    `]`\n  `}``)``;`\n  `println!``(```\"`first phone number: `{}``\"```,` john`[```\"`phones`\"```]``[``0``]``)``;`\n  ``//` Convert to a string of JSON and print it out`\n  `println!``(```\"``{}``\"```,` john`.``to_string``(``)``)``;`\n```}```\n`\n```\n\nThe ```Value`::``to_string`(``)``` function converts a ```serde_json`::``Value`` into a ```String``` of JSON text.\nOne neat thing about the ``json!`` macro is that variables and expressions can be interpolated directly into the JSON value as you are building it. Serde will check at compile time that the value you are interpolating is able to be represented as JSON.\n ![\u27e815\u27e9 ](https://play.rust-lang.org/?edition=2018&gist=f9101a6e61dfc9e02c6a67f315ed24f2)\n```\n``let` full_name `=` ``\"`John Doe`\"```;`\n`let` age_last_year `=` `42``;`\n``//` The type of `john` is `serde_json::Value``\n`let` john `=` `json!``(```{`\n  ``\"`name`\"```:` full_name`,`\n  ``\"`age`\"```:` age_last_year `+` `1``,`\n  ``\"`phones`\"```:` `[`\n    `format!``(```\"`+44 `{}``\"```,` `random_phone``(``)``)`\n  `]`\n```}```)``;`\n`\n```\n\nThis is amazingly convenient, but we have the problem we had before with ``Value``: the IDE and Rust compiler cannot help us if we get it wrong. Serde JSON provides a better way of serializing strongly-typed data structures into JSON text.\n## Creating JSON by serializing data structures\nA data structure can be converted to a JSON string by ```serde_json`::``to_string``\u27e819\u27e9. There is also ```serde_json`::``to_vec``\u27e820\u27e9 which serializes to a ````Vec``<``u8``>```` and ```serde_json`::``to_writer``\u27e821\u27e9 which serializes to any ```io`::``Write`` such as a File or a TCP stream.\n ![\u27e815\u27e9 ](https://play.rust-lang.org/?edition=2018&gist=3472242a08ed2ff88a944f2a2283b0ee)\n```\n``use` `serde`::````{`Deserialize`,` Serialize```}```;`\n`use` `serde_json`::``Result`;`\n``#``[``derive```(```Serialize`,` Deserialize```)```]``\n``struct` ```Address` ````{`\n  `street``:` String,\n  `city``:` String,\n```}```\n``fn` `print_an_address`````(````)```` ``->` ``Result``<``(``)``>``` ````{`\n  ``//` Some data structure.`\n  `let` address `=` Address `{`\n    street`:` ``\"`10 Downing Street`\"```.``to_owned``(``)``,`\n    city`:` ``\"`London`\"```.``to_owned``(``)``,`\n  `}``;`\n  ``//` Serialize it to a JSON string.`\n  `let` j `=` `serde_json`::``to_string`(``&`address`)``?``;`\n  ``//` Print, write to a file, or send to an HTTP server.`\n  `println!``(```\"``{}``\"```,` j`)``;`\n  `Ok``(``(``)``)`\n```}```\n`\n```\n\nAny type that implements Serde's ``Serialize`` trait can be serialized this way. This includes built-in Rust standard library types like ````Vec``<`T`>```` and ```HashMap`<`K, V`>````, as well as any structs or enums annotated with ````#``[``derive```(```Serialize```)```]````.\n## Performance\nIt is fast. You should expect in the ballpark of 500 to 1000 megabytes per second deserialization and 600 to 900 megabytes per second serialization, depending on the characteristics of your data. This is competitive with the fastest C and C++ JSON libraries or even 30% faster for many use cases. Benchmarks live in the serde-rs/json-benchmark\u27e822\u27e9 repo.\n## Getting help\nSerde is one of the most widely used Rust libraries, so any place that Rustaceans congregate will be able to help you out. For chat, consider trying the #rust-questions\u27e823\u27e9 or #rust-beginners\u27e824\u27e9 channels of the unofficial community Discord (invite: <https://discord.gg/rust-lang-community>), the #rust-usage\u27e825\u27e9 or #beginners\u27e826\u27e9 channels of the official Rust Project Discord (invite: <https://discord.gg/rust-lang>), or the #general\u27e827\u27e9 stream in Zulip. For asynchronous, consider the [[rust] tag on StackOverflow](https://stackoverflow.com/questions/tagged/rust), the /r/rust\u27e828\u27e9 subreddit which has a pinned weekly easy questions post, or the Rust Discourse forum\u27e829\u27e9. It's acceptable to file a support issue in this repo, but they tend not to get as many eyes as any of the above and may get closed without a response after some time.\n## No-std support\nAs long as there is a memory allocator, it is possible to use serde_json without the rest of the Rust standard library. Disable the default \"std\" feature and enable the \"alloc\" feature:\n```\n```[``dependencies``]`\n`serde_json = { version = \"1.0\", default-features = false, features ``=` ``[```\"`alloc`\"```]`` }\n``\n```\n\nFor JSON support in Serde without a memory allocator, please see the ``serde-json-core``\u27e830\u27e9 crate.\n#### License\nLicensed under either of Apache License, Version 2.0\u27e831\u27e9 or MIT license\u27e832\u27e9 at your option.  Unless you explicitly state otherwise, any contribution intentionally submitted for inclusion in this crate by you, as defined in the Apache-2.0 license, shall be dual licensed as above, without any additional terms or conditions. \n#### Dependencies\n~230\u2013790KB  ~15K SLoC\n  * preserve_order?\u27e833\u27e9 indexmap\u27e834\u27e9 2.2\n  * itoa\u27e835\u27e9\n  * memchr\u27e836\u27e9\n  * ryu\u27e837\u27e9\n  * serde\u27e838\u27e9\n\n\n  * build `build.rs`\n  * dev  automod\u27e839\u27e9\n  * dev  indoc\u27e840\u27e9\n  * dev  ref-cast\u27e841\u27e9\n  * dev  rustversion\u27e842\u27e9\n  * dev  serde_bytes\u27e843\u27e9\n  * dev  serde_derive\u27e844\u27e9\n  * dev  serde_stacker\u27e845\u27e9\n  * dev  trybuild\u27e846\u27e9+diff\u27e847\u27e9\n\n\n#### Other features\u27e848\u27e9\n  * alloc\u27e849\u27e9\n  * arbitrary_precision\u27e850\u27e9\n  * float_roundtrip\u27e851\u27e9\n  * raw_value\u27e852\u27e9\n  * std\u27e853\u27e9\n  * unbounded_depth\u27e854\u27e9\n\n\n  *[SLoC]: approx. additional lines of code\n",
              "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://lib.rs/crates/serde_json/versions: 140 stable releases\n\u27e82\u27e9 https://lib.rs/encoding: Encoding and/or decoding data from one data format to another. - Encoding\n\u27e83\u27e9 https://lib.rs/crates/serde_json/rev: **64,940** crates (36,524 directly)\n\u27e84\u27e9 https://img.shields.io/github/actions/workflow/status/serde-rs/json/ci.yml?branch=master: ![Build Status\n\u27e85\u27e9 https://img.shields.io/crates/v/serde_json.svg: ![Latest Version\n\u27e86\u27e9 https://img.shields.io/badge/rustc-1.36+-lightgray.svg: ![Rustc Version 1.36+\n\u27e87\u27e9 https://docs.rs/serde_json: JSON API documentation\n\u27e88\u27e9 https://docs.rs/serde: Serde API documentation\n\u27e89\u27e9 https://serde.rs/: Detailed documentation about Serde\n\u27e810\u27e9 https://github.com/serde-rs/json/releases: Release notes\n\u27e811\u27e9 https://docs.rs/serde_json/1/serde_json/value/enum.Value.html: ```serde_json`::``Value``\n\u27e812\u27e9 https://docs.rs/serde_json/1/serde_json/de/fn.from_str.html: ```serde_json`::``from_str``\n\u27e813\u27e9 https://docs.rs/serde_json/1/serde_json/de/fn.from_slice.html: ``from_slice``\n\u27e814\u27e9 https://docs.rs/serde_json/1/serde_json/de/fn.from_reader.html: ``from_reader``\n\u27e815\u27e9 https://img.gs/czjpqfbdkz/85/https://raw.githubusercontent.com/serde-rs/serde-rs.github.io/master/img/runtab.png:  ![\n\u27e816\u27e9 https://docs.rs/serde_json/1/serde_json/enum.Value.html#method.as_str: ```as_str``(``)```\n\u27e817\u27e9 https://serde.rs/derive.html: Using derive\n\u27e818\u27e9 https://docs.rs/serde_json/1/serde_json/macro.json.html: ``json!`` macro\n\u27e819\u27e9 https://docs.rs/serde_json/1/serde_json/ser/fn.to_string.html: ```serde_json`::``to_string``\n\u27e820\u27e9 https://docs.rs/serde_json/1/serde_json/ser/fn.to_vec.html: ```serde_json`::``to_vec``\n\u27e821\u27e9 https://docs.rs/serde_json/1/serde_json/ser/fn.to_writer.html: ```serde_json`::``to_writer``\n\u27e822\u27e9 https://github.com/serde-rs/json-benchmark: serde-rs/json-benchmark\n\u27e823\u27e9 https://discord.com/channels/273534239310479360/274215136414400513: #rust-questions\n\u27e824\u27e9 https://discord.com/channels/273534239310479360/273541522815713281: #rust-beginners\n\u27e825\u27e9 https://discord.com/channels/442252698964721669/443150878111694848: #rust-usage\n\u27e826\u27e9 https://discord.com/channels/442252698964721669/448238009733742612: #beginners\n\u27e827\u27e9 https://rust-lang.zulipchat.com/#narrow/stream/122651-general: #general\n\u27e828\u27e9 https://www.reddit.com/r/rust: /r/rust\n\u27e829\u27e9 https://users.rust-lang.org: Discourse forum\n\u27e830\u27e9 https://github.com/rust-embedded-community/serde-json-core: ``serde-json-core``\n\u27e831\u27e9 https://github.com/serde-rs/json/blob/762783414e6c4f8d670c9d87eb04913efb80d3be/LICENSE-APACHE: Apache License, Version 2.0\n\u27e832\u27e9 https://github.com/serde-rs/json/blob/762783414e6c4f8d670c9d87eb04913efb80d3be/LICENSE-MIT: MIT license\n\u27e833\u27e9 https://lib.rs/crates/serde_json/features#feature-preserve_order: optional feature - preserve_order?\n\u27e834\u27e9 https://lib.rs/crates/indexmap: new - indexmap\n\u27e835\u27e9 https://lib.rs/crates/itoa: 1.0 - itoa\n\u27e836\u27e9 https://lib.rs/crates/memchr: 2 - memchr\n\u27e837\u27e9 https://lib.rs/crates/ryu: 1.0 - ryu\n\u27e838\u27e9 https://lib.rs/crates/serde: 1.0.194 - serde\n\u27e839\u27e9 https://lib.rs/crates/automod: 1.0.11 - automod\n\u27e840\u27e9 https://lib.rs/crates/indoc: 2.0.2 - indoc\n\u27e841\u27e9 https://lib.rs/crates/ref-cast: 1.0.18 - ref-cast\n\u27e842\u27e9 https://lib.rs/crates/rustversion: 1.0.13 - rustversion\n\u27e843\u27e9 https://lib.rs/crates/serde_bytes: 0.11.10 - serde_bytes\n\u27e844\u27e9 https://lib.rs/crates/serde_derive: 1.0.166 - serde_derive\n\u27e845\u27e9 https://lib.rs/crates/serde_stacker: 0.1.8 - serde_stacker\n\u27e846\u27e9 https://lib.rs/crates/trybuild: 1.0.81 - trybuild\n\u27e847\u27e9 https://lib.rs/crates/trybuild/features#feature-diff: +diff\n\u27e848\u27e9 https://lib.rs/crates/serde_json/features: Other features\n\u27e849\u27e9 https://lib.rs/crates/serde_json/features#feature-alloc: alloc\n\u27e850\u27e9 https://lib.rs/crates/serde_json/features#feature-arbitrary_precision: arbitrary_precision\n\u27e851\u27e9 https://lib.rs/crates/serde_json/features#feature-float_roundtrip: float_roundtrip\n\u27e852\u27e9 https://lib.rs/crates/serde_json/features#feature-raw_value: raw_value\n\u27e853\u27e9 https://lib.rs/crates/serde_json/features#feature-std: std\n\u27e854\u27e9 https://lib.rs/crates/serde_json/features#feature-unbounded_depth: unbounded_depth\n",
              "fit_markdown": "",
              "fit_html": ""
            },
            "structured_data": {},
            "quality_score": 3.0,
            "extraction_method": "crawl4ai",
            "error": null,
            "metadata": {
              "doc_type": "docs",
              "content_length": 17165,
              "has_structured_data": false,
              "crawl_success": true
            },
            "timestamp": "112698.0977612"
          }
        },
        "crate_analysis": {
          "status": "completed",
          "check": [
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#itoa@1.0.14",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\itoa-1.0.14\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "itoa",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\itoa-1.0.14\\src\\lib.rs",
                "edition": "2018",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpmwm7qmuk\\serde_json-1.0.140\\target\\debug\\deps\\libitoa-af991b26e9b1ce36.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "compiler-artifact",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpmwm7qmuk/serde_json-1.0.140#serde_json@1.0.140",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpmwm7qmuk\\serde_json-1.0.140\\Cargo.toml",
              "target": {
                "kind": [
                  "custom-build"
                ],
                "crate_types": [
                  "bin"
                ],
                "name": "build-script-build",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpmwm7qmuk\\serde_json-1.0.140\\build.rs",
                "edition": "2021",
                "doc": false,
                "doctest": false,
                "test": false
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "default",
                "std"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpmwm7qmuk\\serde_json-1.0.140\\target\\debug\\build\\serde_json-06cd79b31336c447\\build-script-build.exe",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpmwm7qmuk\\serde_json-1.0.140\\target\\debug\\build\\serde_json-06cd79b31336c447\\build_script_build.pdb"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#ryu@1.0.19",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\ryu-1.0.19\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "ryu",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\ryu-1.0.19\\src\\lib.rs",
                "edition": "2018",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpmwm7qmuk\\serde_json-1.0.140\\target\\debug\\deps\\libryu-9783c46d74806147.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#serde@1.0.218",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde-1.0.218\\Cargo.toml",
              "target": {
                "kind": [
                  "custom-build"
                ],
                "crate_types": [
                  "bin"
                ],
                "name": "build-script-build",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde-1.0.218\\build.rs",
                "edition": "2018",
                "doc": false,
                "doctest": false,
                "test": false
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "std"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpmwm7qmuk\\serde_json-1.0.140\\target\\debug\\build\\serde-b955f592938e2d5b\\build-script-build.exe",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpmwm7qmuk\\serde_json-1.0.140\\target\\debug\\build\\serde-b955f592938e2d5b\\build_script_build.pdb"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "build-script-executed",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpmwm7qmuk/serde_json-1.0.140#serde_json@1.0.140",
              "linked_libs": [],
              "linked_paths": [],
              "cfgs": [
                "fast_arithmetic=\"64\""
              ],
              "env": [],
              "out_dir": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpmwm7qmuk\\serde_json-1.0.140\\target\\debug\\build\\serde_json-13e657b039eabcd8\\out"
            },
            {
              "reason": "build-script-executed",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#serde@1.0.218",
              "linked_libs": [],
              "linked_paths": [],
              "cfgs": [],
              "env": [],
              "out_dir": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpmwm7qmuk\\serde_json-1.0.140\\target\\debug\\build\\serde-188544501a3fd185\\out"
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#memchr@2.7.4",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\memchr-2.7.4\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "memchr",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\memchr-2.7.4\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "alloc",
                "std"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpmwm7qmuk\\serde_json-1.0.140\\target\\debug\\deps\\libmemchr-1582e0d0cb00c2d8.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#serde@1.0.218",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde-1.0.218\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "serde",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde-1.0.218\\src\\lib.rs",
                "edition": "2018",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "std"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpmwm7qmuk\\serde_json-1.0.140\\target\\debug\\deps\\libserde-94bc1acceaa8f19a.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "compiler-artifact",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpmwm7qmuk/serde_json-1.0.140#serde_json@1.0.140",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpmwm7qmuk\\serde_json-1.0.140\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "serde_json",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpmwm7qmuk\\serde_json-1.0.140\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "default",
                "std"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpmwm7qmuk\\serde_json-1.0.140\\target\\debug\\deps\\libserde_json-ecac076e8194b620.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "build-finished",
              "success": true
            }
          ],
          "clippy": [
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#serde@1.0.218",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde-1.0.218\\Cargo.toml",
              "target": {
                "kind": [
                  "custom-build"
                ],
                "crate_types": [
                  "bin"
                ],
                "name": "build-script-build",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde-1.0.218\\build.rs",
                "edition": "2018",
                "doc": false,
                "doctest": false,
                "test": false
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "std"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpmwm7qmuk\\serde_json-1.0.140\\target\\debug\\build\\serde-b955f592938e2d5b\\build-script-build.exe",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpmwm7qmuk\\serde_json-1.0.140\\target\\debug\\build\\serde-b955f592938e2d5b\\build_script_build.pdb"
              ],
              "executable": null,
              "fresh": true
            },
            {
              "reason": "build-script-executed",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#serde@1.0.218",
              "linked_libs": [],
              "linked_paths": [],
              "cfgs": [],
              "env": [],
              "out_dir": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpmwm7qmuk\\serde_json-1.0.140\\target\\debug\\build\\serde-188544501a3fd185\\out"
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#memchr@2.7.4",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\memchr-2.7.4\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "memchr",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\memchr-2.7.4\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "alloc",
                "std"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpmwm7qmuk\\serde_json-1.0.140\\target\\debug\\deps\\libmemchr-1582e0d0cb00c2d8.rmeta"
              ],
              "executable": null,
              "fresh": true
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#ryu@1.0.19",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\ryu-1.0.19\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "ryu",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\ryu-1.0.19\\src\\lib.rs",
                "edition": "2018",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpmwm7qmuk\\serde_json-1.0.140\\target\\debug\\deps\\libryu-9783c46d74806147.rmeta"
              ],
              "executable": null,
              "fresh": true
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#itoa@1.0.14",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\itoa-1.0.14\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "itoa",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\itoa-1.0.14\\src\\lib.rs",
                "edition": "2018",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpmwm7qmuk\\serde_json-1.0.140\\target\\debug\\deps\\libitoa-af991b26e9b1ce36.rmeta"
              ],
              "executable": null,
              "fresh": true
            },
            {
              "reason": "compiler-artifact",
              "package_id": "registry+https://github.com/rust-lang/crates.io-index#serde@1.0.218",
              "manifest_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde-1.0.218\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "serde",
                "src_path": "C:\\Users\\davet\\.cargo\\registry\\src\\index.crates.io-1949cf8c6b5b557f\\serde-1.0.218\\src\\lib.rs",
                "edition": "2018",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "std"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpmwm7qmuk\\serde_json-1.0.140\\target\\debug\\deps\\libserde-94bc1acceaa8f19a.rmeta"
              ],
              "executable": null,
              "fresh": true
            },
            {
              "reason": "compiler-artifact",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpmwm7qmuk/serde_json-1.0.140#serde_json@1.0.140",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpmwm7qmuk\\serde_json-1.0.140\\Cargo.toml",
              "target": {
                "kind": [
                  "custom-build"
                ],
                "crate_types": [
                  "bin"
                ],
                "name": "build-script-build",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpmwm7qmuk\\serde_json-1.0.140\\build.rs",
                "edition": "2021",
                "doc": false,
                "doctest": false,
                "test": false
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 0,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "default",
                "std"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpmwm7qmuk\\serde_json-1.0.140\\target\\debug\\build\\serde_json-35a24e6c0d34d6e5\\build-script-build.exe",
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpmwm7qmuk\\serde_json-1.0.140\\target\\debug\\build\\serde_json-35a24e6c0d34d6e5\\build_script_build.pdb"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "build-script-executed",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpmwm7qmuk/serde_json-1.0.140#serde_json@1.0.140",
              "linked_libs": [],
              "linked_paths": [],
              "cfgs": [
                "fast_arithmetic=\"64\""
              ],
              "env": [],
              "out_dir": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpmwm7qmuk\\serde_json-1.0.140\\target\\debug\\build\\serde_json-3a90cb97088ebe2c\\out"
            },
            {
              "reason": "compiler-artifact",
              "package_id": "path+file:///C:/Users/davet/AppData/Local/Temp/tmpmwm7qmuk/serde_json-1.0.140#serde_json@1.0.140",
              "manifest_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpmwm7qmuk\\serde_json-1.0.140\\Cargo.toml",
              "target": {
                "kind": [
                  "lib"
                ],
                "crate_types": [
                  "lib"
                ],
                "name": "serde_json",
                "src_path": "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpmwm7qmuk\\serde_json-1.0.140\\src\\lib.rs",
                "edition": "2021",
                "doc": true,
                "doctest": true,
                "test": true
              },
              "profile": {
                "opt_level": "0",
                "debuginfo": 2,
                "debug_assertions": true,
                "overflow_checks": true,
                "test": false
              },
              "features": [
                "default",
                "std"
              ],
              "filenames": [
                "C:\\Users\\davet\\AppData\\Local\\Temp\\tmpmwm7qmuk\\serde_json-1.0.140\\target\\debug\\deps\\libserde_json-27b920df9de7fb2f.rmeta"
              ],
              "executable": null,
              "fresh": false
            },
            {
              "reason": "build-finished",
              "success": true
            }
          ],
          "audit": {
            "database": {
              "advisory-count": 787,
              "last-commit": "7573f55ba337263f61167dbb0ea926cdc7c8eb5d",
              "last-updated": "2025-06-17T11:04:25+02:00"
            },
            "lockfile": {
              "dependency-count": 48
            },
            "settings": {
              "target_arch": [],
              "target_os": [],
              "severity": null,
              "ignore": [],
              "informational_warnings": [
                "unmaintained",
                "unsound",
                "notice"
              ]
            },
            "vulnerabilities": {
              "found": false,
              "count": 0,
              "list": []
            },
            "warnings": {}
          },
          "note": "Crate analysis performed with stable toolchain."
        },
        "crate_metadata": {
          "name": "serde_json",
          "version": "1.0.140",
          "description": "ALLOW: Positive community sentiment",
          "repository": "",
          "keywords": [],
          "categories": [],
          "readme": {
            "raw_markdown": "[](https://docs.rs/serde_json/latest/serde_json/all.html \"show sidebar\")\n# Crate serde_jsonCopy item path\n[Settings](https://docs.rs/serde_json/latest/settings.html)\n[Help](https://docs.rs/serde_json/latest/help.html)\nSummary[Source](https://docs.rs/serde_json/latest/src/serde_json/lib.rs.html#1-437)\nExpand description\n## [\u00a7](https://docs.rs/serde_json/latest/serde_json/#serde-json)Serde JSON\nJSON is a ubiquitous open-standard format that uses human-readable text to transmit data objects consisting of key-value pairs.\n```\n{\n  \"name\": \"John Doe\",\n  \"age\": 43,\n  \"address\": {\n    \"street\": \"10 Downing Street\",\n    \"city\": \"London\"\n  },\n  \"phones\": [\n    \"+44 1234567\",\n    \"+44 2345678\"\n  ]\n}\n```\n\nThere are three common ways that you might find yourself needing to work with JSON data in Rust.\n  * **As text data.** An unprocessed string of JSON data that you receive on an HTTP endpoint, read from a file, or prepare to send to a remote server.\n  * **As an untyped or loosely typed representation.** Maybe you want to check that some JSON data is valid before passing it on, but without knowing the structure of what it contains. Or you want to do very basic manipulations like insert a key in a particular spot.\n  * **As a strongly typed Rust data structure.** When you expect all or most of your data to conform to a particular structure and want to get real work done without JSON\u2019s loosey-goosey nature tripping you up.\n\n\nSerde JSON provides efficient, flexible, safe ways of converting data between each of these representations.\n## [\u00a7](https://docs.rs/serde_json/latest/serde_json/#operating-on-untyped-json-values)Operating on untyped JSON values\nAny valid JSON data can be manipulated in the following recursive enum representation. This data structure is [`serde_json::Value`](https://docs.rs/serde_json/latest/serde_json/enum.Value.html \"enum serde_json::Value\").\n```\nenum Value {\n  Null,\n  Bool(bool),\n  Number(Number),\n  String(String),\n  Array(Vec<Value>),\n  Object(Map<String, Value>),\n}\n```\n\nA string of JSON data can be parsed into a `serde_json::Value` by the [`serde_json::from_str`](https://docs.rs/serde_json/latest/serde_json/fn.from_str.html \"fn serde_json::from_str\") function. There is also [`from_slice`](https://docs.rs/serde_json/latest/serde_json/fn.from_slice.html \"fn serde_json::from_slice\") for parsing from a byte slice `&[u8]` and [`from_reader`](https://docs.rs/serde_json/latest/serde_json/fn.from_reader.html \"fn serde_json::from_reader\") for parsing from any `io::Read` like a File or a TCP stream.\n```\nuse serde_json::{Result, Value};\nfn untyped_example() -> Result<()> {\n  // Some JSON input data as a &str. Maybe this comes from the user.\n  let data = r#\"\n    {\n      \"name\": \"John Doe\",\n      \"age\": 43,\n      \"phones\": [\n        \"+44 1234567\",\n        \"+44 2345678\"\n      ]\n    }\"#;\n  // Parse the string of data into serde_json::Value.\n  let v: Value = serde_json::from_str(data)?;\n  // Access parts of the data by indexing with square brackets.\n  println!(\"Please call {} at the number {}\", v[\"name\"], v[\"phones\"][0]);\n  Ok(())\n}\n```\n\nThe result of square bracket indexing like `v[\"name\"]` is a borrow of the data at that index, so the type is `&Value`. A JSON map can be indexed with string keys, while a JSON array can be indexed with integer keys. If the type of the data is not right for the type with which it is being indexed, or if a map does not contain the key being indexed, or if the index into a vector is out of bounds, the returned element is `Value::Null`.\nWhen a `Value` is printed, it is printed as a JSON string. So in the code above, the output looks like `Please call \"John Doe\" at the number \"+44 1234567\"`. The quotation marks appear because `v[\"name\"]` is a `&Value` containing a JSON string and its JSON representation is `\"John Doe\"`. Printing as a plain string without quotation marks involves converting from a JSON string to a Rust string with [`as_str()`](https://docs.rs/serde_json/latest/serde_json/enum.Value.html#method.as_str \"method serde_json::Value::as_str\") or avoiding the use of `Value` as described in the following section.\nThe `Value` representation is sufficient for very basic tasks but can be tedious to work with for anything more significant. Error handling is verbose to implement correctly, for example imagine trying to detect the presence of unrecognized fields in the input data. The compiler is powerless to help you when you make a mistake, for example imagine typoing `v[\"name\"]` as `v[\"nmae\"]` in one of the dozens of places it is used in your code.\n## [\u00a7](https://docs.rs/serde_json/latest/serde_json/#parsing-json-as-strongly-typed-data-structures)Parsing JSON as strongly typed data structures\nSerde provides a powerful way of mapping JSON data into Rust data structures largely automatically.\n```\nuse serde::{Deserialize, Serialize};\nuse serde_json::Result;\n#[derive(Serialize, Deserialize)]\nstruct Person {\n  name: String,\n  age: u8,\n  phones: Vec<String>,\n}\nfn typed_example() -> Result<()> {\n  // Some JSON input data as a &str. Maybe this comes from the user.\n  let data = r#\"\n    {\n      \"name\": \"John Doe\",\n      \"age\": 43,\n      \"phones\": [\n        \"+44 1234567\",\n        \"+44 2345678\"\n      ]\n    }\"#;\n  // Parse the string of data into a Person object. This is exactly the\n  // same function as the one that produced serde_json::Value above, but\n  // now we are asking it for a Person as output.\n  let p: Person = serde_json::from_str(data)?;\n  // Do things just like with any other Rust data structure.\n  println!(\"Please call {} at the number {}\", p.name, p.phones[0]);\n  Ok(())\n}\n```\n\nThis is the same `serde_json::from_str` function as before, but this time we assign the return value to a variable of type `Person` so Serde will automatically interpret the input data as a `Person` and produce informative error messages if the layout does not conform to what a `Person` is expected to look like.\nAny type that implements Serde\u2019s `Deserialize` trait can be deserialized this way. This includes built-in Rust standard library types like `Vec<T>` and `HashMap<K, V>`, as well as any structs or enums annotated with `#[derive(Deserialize)]`.\nOnce we have `p` of type `Person`, our IDE and the Rust compiler can help us use it correctly like they do for any other Rust code. The IDE can autocomplete field names to prevent typos, which was impossible in the `serde_json::Value` representation. And the Rust compiler can check that when we write `p.phones[0]`, then `p.phones` is guaranteed to be a `Vec<String>` so indexing into it makes sense and produces a `String`.\n## [\u00a7](https://docs.rs/serde_json/latest/serde_json/#constructing-json-values)Constructing JSON values\nSerde JSON provides a [`json!` macro](https://docs.rs/serde_json/latest/serde_json/macro.json.html \"macro serde_json::json\") to build `serde_json::Value` objects with very natural JSON syntax.\n```\nuse serde_json::json;\nfn main() {\n  // The type of `john` is `serde_json::Value`\n  let john = json!({\n    \"name\": \"John Doe\",\n    \"age\": 43,\n    \"phones\": [\n      \"+44 1234567\",\n      \"+44 2345678\"\n    ]\n  });\n  println!(\"first phone number: {}\", john[\"phones\"][0]);\n  // Convert to a string of JSON and print it out\n  println!(\"{}\", john.to_string());\n}\n```\n\nThe `Value::to_string()` function converts a `serde_json::Value` into a `String` of JSON text.\nOne neat thing about the `json!` macro is that variables and expressions can be interpolated directly into the JSON value as you are building it. Serde will check at compile time that the value you are interpolating is able to be represented as JSON.\n```\nlet full_name = \"John Doe\";\nlet age_last_year = 42;\n// The type of `john` is `serde_json::Value`\nlet john = json!({\n  \"name\": full_name,\n  \"age\": age_last_year + 1,\n  \"phones\": [\n    format!(\"+44 {}\", random_phone())\n  ]\n});\n```\n\nThis is amazingly convenient, but we have the problem we had before with `Value`: the IDE and Rust compiler cannot help us if we get it wrong. Serde JSON provides a better way of serializing strongly-typed data structures into JSON text.\n## [\u00a7](https://docs.rs/serde_json/latest/serde_json/#creating-json-by-serializing-data-structures)Creating JSON by serializing data structures\nA data structure can be converted to a JSON string by [`serde_json::to_string`](https://docs.rs/serde_json/latest/serde_json/fn.to_string.html \"fn serde_json::to_string\"). There is also [`serde_json::to_vec`](https://docs.rs/serde_json/latest/serde_json/fn.to_vec.html \"fn serde_json::to_vec\") which serializes to a `Vec<u8>` and [`serde_json::to_writer`](https://docs.rs/serde_json/latest/serde_json/fn.to_writer.html \"fn serde_json::to_writer\") which serializes to any `io::Write` such as a File or a TCP stream.\n```\nuse serde::{Deserialize, Serialize};\nuse serde_json::Result;\n#[derive(Serialize, Deserialize)]\nstruct Address {\n  street: String,\n  city: String,\n}\nfn print_an_address() -> Result<()> {\n  // Some data structure.\n  let address = Address {\n    street: \"10 Downing Street\".to_owned(),\n    city: \"London\".to_owned(),\n  };\n  // Serialize it to a JSON string.\n  let j = serde_json::to_string(&address)?;\n  // Print, write to a file, or send to an HTTP server.\n  println!(\"{}\", j);\n  Ok(())\n}\n```\n\nAny type that implements Serde\u2019s `Serialize` trait can be serialized this way. This includes built-in Rust standard library types like `Vec<T>` and `HashMap<K, V>`, as well as any structs or enums annotated with `#[derive(Serialize)]`.\n## [\u00a7](https://docs.rs/serde_json/latest/serde_json/#no-std-support)No-std support\nAs long as there is a memory allocator, it is possible to use serde_json without the rest of the Rust standard library. Disable the default \u201cstd\u201d feature and enable the \u201calloc\u201d feature:\n```\n[dependencies]\nserde_json = { version = \"1.0\", default-features = false, features = [\"alloc\"] }\n```\n\nFor JSON support in Serde without a memory allocator, please see the [`serde-json-core`](https://github.com/rust-embedded-community/serde-json-core) crate.\n## Modules[\u00a7](https://docs.rs/serde_json/latest/serde_json/#modules)\n\n[de](https://docs.rs/serde_json/latest/serde_json/de/index.html \"mod serde_json::de\")\n    Deserialize JSON data to a Rust data structure.\n\n[error](https://docs.rs/serde_json/latest/serde_json/error/index.html \"mod serde_json::error\")\n    When serializing or deserializing JSON goes wrong.\n\n[map](https://docs.rs/serde_json/latest/serde_json/map/index.html \"mod serde_json::map\")\n    A map of String to serde_json::Value.\n\n[ser](https://docs.rs/serde_json/latest/serde_json/ser/index.html \"mod serde_json::ser\")`std`\n    Serialize a Rust data structure into JSON data.\n\n[value](https://docs.rs/serde_json/latest/serde_json/value/index.html \"mod serde_json::value\")\n    The Value enum, a loosely typed way of representing any valid JSON value.\n## Macros[\u00a7](https://docs.rs/serde_json/latest/serde_json/#macros)\n\n[json](https://docs.rs/serde_json/latest/serde_json/macro.json.html \"macro serde_json::json\")\n    Construct a `serde_json::Value` from a JSON literal.\n## Structs[\u00a7](https://docs.rs/serde_json/latest/serde_json/#structs)\n\n[Deserializer](https://docs.rs/serde_json/latest/serde_json/struct.Deserializer.html \"struct serde_json::Deserializer\")\n    A structure that deserializes JSON into Rust values.\n\n[Error](https://docs.rs/serde_json/latest/serde_json/struct.Error.html \"struct serde_json::Error\")\n    This type represents all possible errors that can occur when serializing or deserializing JSON data.\n\n[Map](https://docs.rs/serde_json/latest/serde_json/struct.Map.html \"struct serde_json::Map\")\n    Represents a JSON key/value type.\n\n[Number](https://docs.rs/serde_json/latest/serde_json/struct.Number.html \"struct serde_json::Number\")\n    Represents a JSON number, whether integer or floating point.\n\n[Serializer](https://docs.rs/serde_json/latest/serde_json/struct.Serializer.html \"struct serde_json::Serializer\")`std`\n    A structure for serializing Rust values into JSON.\n\n[StreamDeserializer](https://docs.rs/serde_json/latest/serde_json/struct.StreamDeserializer.html \"struct serde_json::StreamDeserializer\")\n    Iterator that deserializes a stream into multiple JSON values.\n## Enums[\u00a7](https://docs.rs/serde_json/latest/serde_json/#enums)\n\n[Value](https://docs.rs/serde_json/latest/serde_json/enum.Value.html \"enum serde_json::Value\")\n    Represents any valid JSON value.\n## Functions[\u00a7](https://docs.rs/serde_json/latest/serde_json/#functions)\n\n[from_reader](https://docs.rs/serde_json/latest/serde_json/fn.from_reader.html \"fn serde_json::from_reader\")`std`\n    Deserialize an instance of type `T` from an I/O stream of JSON.\n\n[from_slice](https://docs.rs/serde_json/latest/serde_json/fn.from_slice.html \"fn serde_json::from_slice\")\n    Deserialize an instance of type `T` from bytes of JSON text.\n\n[from_str](https://docs.rs/serde_json/latest/serde_json/fn.from_str.html \"fn serde_json::from_str\")\n    Deserialize an instance of type `T` from a string of JSON text.\n\n[from_value](https://docs.rs/serde_json/latest/serde_json/fn.from_value.html \"fn serde_json::from_value\")\n    Interpret a `serde_json::Value` as an instance of type `T`.\n\n[to_string](https://docs.rs/serde_json/latest/serde_json/fn.to_string.html \"fn serde_json::to_string\")`std`\n    Serialize the given data structure as a String of JSON.\n\n[to_string_pretty](https://docs.rs/serde_json/latest/serde_json/fn.to_string_pretty.html \"fn serde_json::to_string_pretty\")`std`\n    Serialize the given data structure as a pretty-printed String of JSON.\n\n[to_value](https://docs.rs/serde_json/latest/serde_json/fn.to_value.html \"fn serde_json::to_value\")\n    Convert a `T` into `serde_json::Value` which is an enum that can represent any valid JSON data.\n\n[to_vec](https://docs.rs/serde_json/latest/serde_json/fn.to_vec.html \"fn serde_json::to_vec\")`std`\n    Serialize the given data structure as a JSON byte vector.\n\n[to_vec_pretty](https://docs.rs/serde_json/latest/serde_json/fn.to_vec_pretty.html \"fn serde_json::to_vec_pretty\")`std`\n    Serialize the given data structure as a pretty-printed JSON byte vector.\n\n[to_writer](https://docs.rs/serde_json/latest/serde_json/fn.to_writer.html \"fn serde_json::to_writer\")`std`\n    Serialize the given data structure as JSON into the I/O stream.\n\n[to_writer_pretty](https://docs.rs/serde_json/latest/serde_json/fn.to_writer_pretty.html \"fn serde_json::to_writer_pretty\")`std`\n    Serialize the given data structure as pretty-printed JSON into the I/O stream.\n## Type Aliases[\u00a7](https://docs.rs/serde_json/latest/serde_json/#types)\n\n[Result](https://docs.rs/serde_json/latest/serde_json/type.Result.html \"type serde_json::Result\")\n    Alias for a `Result` with the error type `serde_json::Error`.\n",
            "markdown_with_citations": "[](https://docs.rs/serde_json/latest/serde_json/all.html \"show sidebar\")\n# Crate serde_jsonCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\n## \u00a7\u27e84\u27e9Serde JSON\nJSON is a ubiquitous open-standard format that uses human-readable text to transmit data objects consisting of key-value pairs.\n```\n{\n  \"name\": \"John Doe\",\n  \"age\": 43,\n  \"address\": {\n    \"street\": \"10 Downing Street\",\n    \"city\": \"London\"\n  },\n  \"phones\": [\n    \"+44 1234567\",\n    \"+44 2345678\"\n  ]\n}\n```\n\nThere are three common ways that you might find yourself needing to work with JSON data in Rust.\n  * **As text data.** An unprocessed string of JSON data that you receive on an HTTP endpoint, read from a file, or prepare to send to a remote server.\n  * **As an untyped or loosely typed representation.** Maybe you want to check that some JSON data is valid before passing it on, but without knowing the structure of what it contains. Or you want to do very basic manipulations like insert a key in a particular spot.\n  * **As a strongly typed Rust data structure.** When you expect all or most of your data to conform to a particular structure and want to get real work done without JSON\u2019s loosey-goosey nature tripping you up.\n\n\nSerde JSON provides efficient, flexible, safe ways of converting data between each of these representations.\n## \u00a7\u27e85\u27e9Operating on untyped JSON values\nAny valid JSON data can be manipulated in the following recursive enum representation. This data structure is `serde_json::Value`\u27e86\u27e9.\n```\nenum Value {\n  Null,\n  Bool(bool),\n  Number(Number),\n  String(String),\n  Array(Vec<Value>),\n  Object(Map<String, Value>),\n}\n```\n\nA string of JSON data can be parsed into a `serde_json::Value` by the `serde_json::from_str`\u27e87\u27e9 function. There is also `from_slice`\u27e88\u27e9 for parsing from a byte slice `&[u8]` and `from_reader`\u27e89\u27e9 for parsing from any `io::Read` like a File or a TCP stream.\n```\nuse serde_json::{Result, Value};\nfn untyped_example() -> Result<()> {\n  // Some JSON input data as a &str. Maybe this comes from the user.\n  let data = r#\"\n    {\n      \"name\": \"John Doe\",\n      \"age\": 43,\n      \"phones\": [\n        \"+44 1234567\",\n        \"+44 2345678\"\n      ]\n    }\"#;\n  // Parse the string of data into serde_json::Value.\n  let v: Value = serde_json::from_str(data)?;\n  // Access parts of the data by indexing with square brackets.\n  println!(\"Please call {} at the number {}\", v[\"name\"], v[\"phones\"][0]);\n  Ok(())\n}\n```\n\nThe result of square bracket indexing like `v[\"name\"]` is a borrow of the data at that index, so the type is `&Value`. A JSON map can be indexed with string keys, while a JSON array can be indexed with integer keys. If the type of the data is not right for the type with which it is being indexed, or if a map does not contain the key being indexed, or if the index into a vector is out of bounds, the returned element is `Value::Null`.\nWhen a `Value` is printed, it is printed as a JSON string. So in the code above, the output looks like `Please call \"John Doe\" at the number \"+44 1234567\"`. The quotation marks appear because `v[\"name\"]` is a `&Value` containing a JSON string and its JSON representation is `\"John Doe\"`. Printing as a plain string without quotation marks involves converting from a JSON string to a Rust string with `as_str()`\u27e810\u27e9 or avoiding the use of `Value` as described in the following section.\nThe `Value` representation is sufficient for very basic tasks but can be tedious to work with for anything more significant. Error handling is verbose to implement correctly, for example imagine trying to detect the presence of unrecognized fields in the input data. The compiler is powerless to help you when you make a mistake, for example imagine typoing `v[\"name\"]` as `v[\"nmae\"]` in one of the dozens of places it is used in your code.\n## \u00a7\u27e811\u27e9Parsing JSON as strongly typed data structures\nSerde provides a powerful way of mapping JSON data into Rust data structures largely automatically.\n```\nuse serde::{Deserialize, Serialize};\nuse serde_json::Result;\n#[derive(Serialize, Deserialize)]\nstruct Person {\n  name: String,\n  age: u8,\n  phones: Vec<String>,\n}\nfn typed_example() -> Result<()> {\n  // Some JSON input data as a &str. Maybe this comes from the user.\n  let data = r#\"\n    {\n      \"name\": \"John Doe\",\n      \"age\": 43,\n      \"phones\": [\n        \"+44 1234567\",\n        \"+44 2345678\"\n      ]\n    }\"#;\n  // Parse the string of data into a Person object. This is exactly the\n  // same function as the one that produced serde_json::Value above, but\n  // now we are asking it for a Person as output.\n  let p: Person = serde_json::from_str(data)?;\n  // Do things just like with any other Rust data structure.\n  println!(\"Please call {} at the number {}\", p.name, p.phones[0]);\n  Ok(())\n}\n```\n\nThis is the same `serde_json::from_str` function as before, but this time we assign the return value to a variable of type `Person` so Serde will automatically interpret the input data as a `Person` and produce informative error messages if the layout does not conform to what a `Person` is expected to look like.\nAny type that implements Serde\u2019s `Deserialize` trait can be deserialized this way. This includes built-in Rust standard library types like `Vec<T>` and `HashMap<K, V>`, as well as any structs or enums annotated with `#[derive(Deserialize)]`.\nOnce we have `p` of type `Person`, our IDE and the Rust compiler can help us use it correctly like they do for any other Rust code. The IDE can autocomplete field names to prevent typos, which was impossible in the `serde_json::Value` representation. And the Rust compiler can check that when we write `p.phones[0]`, then `p.phones` is guaranteed to be a `Vec<String>` so indexing into it makes sense and produces a `String`.\n## \u00a7\u27e812\u27e9Constructing JSON values\nSerde JSON provides a `json!` macro\u27e813\u27e9 to build `serde_json::Value` objects with very natural JSON syntax.\n```\nuse serde_json::json;\nfn main() {\n  // The type of `john` is `serde_json::Value`\n  let john = json!({\n    \"name\": \"John Doe\",\n    \"age\": 43,\n    \"phones\": [\n      \"+44 1234567\",\n      \"+44 2345678\"\n    ]\n  });\n  println!(\"first phone number: {}\", john[\"phones\"][0]);\n  // Convert to a string of JSON and print it out\n  println!(\"{}\", john.to_string());\n}\n```\n\nThe `Value::to_string()` function converts a `serde_json::Value` into a `String` of JSON text.\nOne neat thing about the `json!` macro is that variables and expressions can be interpolated directly into the JSON value as you are building it. Serde will check at compile time that the value you are interpolating is able to be represented as JSON.\n```\nlet full_name = \"John Doe\";\nlet age_last_year = 42;\n// The type of `john` is `serde_json::Value`\nlet john = json!({\n  \"name\": full_name,\n  \"age\": age_last_year + 1,\n  \"phones\": [\n    format!(\"+44 {}\", random_phone())\n  ]\n});\n```\n\nThis is amazingly convenient, but we have the problem we had before with `Value`: the IDE and Rust compiler cannot help us if we get it wrong. Serde JSON provides a better way of serializing strongly-typed data structures into JSON text.\n## \u00a7\u27e814\u27e9Creating JSON by serializing data structures\nA data structure can be converted to a JSON string by `serde_json::to_string`\u27e815\u27e9. There is also `serde_json::to_vec`\u27e816\u27e9 which serializes to a `Vec<u8>` and `serde_json::to_writer`\u27e817\u27e9 which serializes to any `io::Write` such as a File or a TCP stream.\n```\nuse serde::{Deserialize, Serialize};\nuse serde_json::Result;\n#[derive(Serialize, Deserialize)]\nstruct Address {\n  street: String,\n  city: String,\n}\nfn print_an_address() -> Result<()> {\n  // Some data structure.\n  let address = Address {\n    street: \"10 Downing Street\".to_owned(),\n    city: \"London\".to_owned(),\n  };\n  // Serialize it to a JSON string.\n  let j = serde_json::to_string(&address)?;\n  // Print, write to a file, or send to an HTTP server.\n  println!(\"{}\", j);\n  Ok(())\n}\n```\n\nAny type that implements Serde\u2019s `Serialize` trait can be serialized this way. This includes built-in Rust standard library types like `Vec<T>` and `HashMap<K, V>`, as well as any structs or enums annotated with `#[derive(Serialize)]`.\n## \u00a7\u27e818\u27e9No-std support\nAs long as there is a memory allocator, it is possible to use serde_json without the rest of the Rust standard library. Disable the default \u201cstd\u201d feature and enable the \u201calloc\u201d feature:\n```\n[dependencies]\nserde_json = { version = \"1.0\", default-features = false, features = [\"alloc\"] }\n```\n\nFor JSON support in Serde without a memory allocator, please see the `serde-json-core`\u27e819\u27e9 crate.\n## Modules\u00a7\u27e820\u27e9\n\nde\u27e821\u27e9\n    Deserialize JSON data to a Rust data structure.\n\nerror\u27e822\u27e9\n    When serializing or deserializing JSON goes wrong.\n\nmap\u27e823\u27e9\n    A map of String to serde_json::Value.\n\nser\u27e824\u27e9`std`\n    Serialize a Rust data structure into JSON data.\n\nvalue\u27e825\u27e9\n    The Value enum, a loosely typed way of representing any valid JSON value.\n## Macros\u00a7\u27e826\u27e9\n\njson\u27e813\u27e9\n    Construct a `serde_json::Value` from a JSON literal.\n## Structs\u00a7\u27e827\u27e9\n\nDeserializer\u27e828\u27e9\n    A structure that deserializes JSON into Rust values.\n\nError\u27e829\u27e9\n    This type represents all possible errors that can occur when serializing or deserializing JSON data.\n\nMap\u27e830\u27e9\n    Represents a JSON key/value type.\n\nNumber\u27e831\u27e9\n    Represents a JSON number, whether integer or floating point.\n\nSerializer\u27e832\u27e9`std`\n    A structure for serializing Rust values into JSON.\n\nStreamDeserializer\u27e833\u27e9\n    Iterator that deserializes a stream into multiple JSON values.\n## Enums\u00a7\u27e834\u27e9\n\nValue\u27e86\u27e9\n    Represents any valid JSON value.\n## Functions\u00a7\u27e835\u27e9\n\nfrom_reader\u27e89\u27e9`std`\n    Deserialize an instance of type `T` from an I/O stream of JSON.\n\nfrom_slice\u27e88\u27e9\n    Deserialize an instance of type `T` from bytes of JSON text.\n\nfrom_str\u27e87\u27e9\n    Deserialize an instance of type `T` from a string of JSON text.\n\nfrom_value\u27e836\u27e9\n    Interpret a `serde_json::Value` as an instance of type `T`.\n\nto_string\u27e815\u27e9`std`\n    Serialize the given data structure as a String of JSON.\n\nto_string_pretty\u27e837\u27e9`std`\n    Serialize the given data structure as a pretty-printed String of JSON.\n\nto_value\u27e838\u27e9\n    Convert a `T` into `serde_json::Value` which is an enum that can represent any valid JSON data.\n\nto_vec\u27e816\u27e9`std`\n    Serialize the given data structure as a JSON byte vector.\n\nto_vec_pretty\u27e839\u27e9`std`\n    Serialize the given data structure as a pretty-printed JSON byte vector.\n\nto_writer\u27e817\u27e9`std`\n    Serialize the given data structure as JSON into the I/O stream.\n\nto_writer_pretty\u27e840\u27e9`std`\n    Serialize the given data structure as pretty-printed JSON into the I/O stream.\n## Type Aliases\u00a7\u27e841\u27e9\n\nResult\u27e842\u27e9\n    Alias for a `Result` with the error type `serde_json::Error`.\n",
            "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/serde_json/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/serde_json/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/serde_json/latest/src/serde_json/lib.rs.html#1-437: Source\n\u27e84\u27e9 https://docs.rs/serde_json/latest/serde_json/#serde-json: \u00a7\n\u27e85\u27e9 https://docs.rs/serde_json/latest/serde_json/#operating-on-untyped-json-values: \u00a7\n\u27e86\u27e9 https://docs.rs/serde_json/latest/serde_json/enum.Value.html: enum serde_json::Value - `serde_json::Value`\n\u27e87\u27e9 https://docs.rs/serde_json/latest/serde_json/fn.from_str.html: fn serde_json::from_str - `serde_json::from_str`\n\u27e88\u27e9 https://docs.rs/serde_json/latest/serde_json/fn.from_slice.html: fn serde_json::from_slice - `from_slice`\n\u27e89\u27e9 https://docs.rs/serde_json/latest/serde_json/fn.from_reader.html: fn serde_json::from_reader - `from_reader`\n\u27e810\u27e9 https://docs.rs/serde_json/latest/serde_json/enum.Value.html#method.as_str: method serde_json::Value::as_str - `as_str()`\n\u27e811\u27e9 https://docs.rs/serde_json/latest/serde_json/#parsing-json-as-strongly-typed-data-structures: \u00a7\n\u27e812\u27e9 https://docs.rs/serde_json/latest/serde_json/#constructing-json-values: \u00a7\n\u27e813\u27e9 https://docs.rs/serde_json/latest/serde_json/macro.json.html: macro serde_json::json - `json!` macro\n\u27e814\u27e9 https://docs.rs/serde_json/latest/serde_json/#creating-json-by-serializing-data-structures: \u00a7\n\u27e815\u27e9 https://docs.rs/serde_json/latest/serde_json/fn.to_string.html: fn serde_json::to_string - `serde_json::to_string`\n\u27e816\u27e9 https://docs.rs/serde_json/latest/serde_json/fn.to_vec.html: fn serde_json::to_vec - `serde_json::to_vec`\n\u27e817\u27e9 https://docs.rs/serde_json/latest/serde_json/fn.to_writer.html: fn serde_json::to_writer - `serde_json::to_writer`\n\u27e818\u27e9 https://docs.rs/serde_json/latest/serde_json/#no-std-support: \u00a7\n\u27e819\u27e9 https://github.com/rust-embedded-community/serde-json-core: `serde-json-core`\n\u27e820\u27e9 https://docs.rs/serde_json/latest/serde_json/#modules: \u00a7\n\u27e821\u27e9 https://docs.rs/serde_json/latest/serde_json/de/index.html: mod serde_json::de - de\n\u27e822\u27e9 https://docs.rs/serde_json/latest/serde_json/error/index.html: mod serde_json::error - error\n\u27e823\u27e9 https://docs.rs/serde_json/latest/serde_json/map/index.html: mod serde_json::map - map\n\u27e824\u27e9 https://docs.rs/serde_json/latest/serde_json/ser/index.html: mod serde_json::ser - ser\n\u27e825\u27e9 https://docs.rs/serde_json/latest/serde_json/value/index.html: mod serde_json::value - value\n\u27e826\u27e9 https://docs.rs/serde_json/latest/serde_json/#macros: \u00a7\n\u27e827\u27e9 https://docs.rs/serde_json/latest/serde_json/#structs: \u00a7\n\u27e828\u27e9 https://docs.rs/serde_json/latest/serde_json/struct.Deserializer.html: struct serde_json::Deserializer - Deserializer\n\u27e829\u27e9 https://docs.rs/serde_json/latest/serde_json/struct.Error.html: struct serde_json::Error - Error\n\u27e830\u27e9 https://docs.rs/serde_json/latest/serde_json/struct.Map.html: struct serde_json::Map - Map\n\u27e831\u27e9 https://docs.rs/serde_json/latest/serde_json/struct.Number.html: struct serde_json::Number - Number\n\u27e832\u27e9 https://docs.rs/serde_json/latest/serde_json/struct.Serializer.html: struct serde_json::Serializer - Serializer\n\u27e833\u27e9 https://docs.rs/serde_json/latest/serde_json/struct.StreamDeserializer.html: struct serde_json::StreamDeserializer - StreamDeserializer\n\u27e834\u27e9 https://docs.rs/serde_json/latest/serde_json/#enums: \u00a7\n\u27e835\u27e9 https://docs.rs/serde_json/latest/serde_json/#functions: \u00a7\n\u27e836\u27e9 https://docs.rs/serde_json/latest/serde_json/fn.from_value.html: fn serde_json::from_value - from_value\n\u27e837\u27e9 https://docs.rs/serde_json/latest/serde_json/fn.to_string_pretty.html: fn serde_json::to_string_pretty - to_string_pretty\n\u27e838\u27e9 https://docs.rs/serde_json/latest/serde_json/fn.to_value.html: fn serde_json::to_value - to_value\n\u27e839\u27e9 https://docs.rs/serde_json/latest/serde_json/fn.to_vec_pretty.html: fn serde_json::to_vec_pretty - to_vec_pretty\n\u27e840\u27e9 https://docs.rs/serde_json/latest/serde_json/fn.to_writer_pretty.html: fn serde_json::to_writer_pretty - to_writer_pretty\n\u27e841\u27e9 https://docs.rs/serde_json/latest/serde_json/#types: \u00a7\n\u27e842\u27e9 https://docs.rs/serde_json/latest/serde_json/type.Result.html: type serde_json::Result - Result\n",
            "fit_markdown": "",
            "fit_html": ""
          },
          "downloads": 0,
          "github_stars": 0,
          "dependencies": [],
          "features": {},
          "code_snippets": [],
          "readme_sections": {},
          "librs_downloads": null,
          "source": "crates.io",
          "enhanced_scraping": {},
          "enhanced_features": [],
          "enhanced_dependencies": []
        },
        "enriched_crate": {
          "name": "serde_json",
          "version": "1.0.140",
          "description": "ALLOW: Positive community sentiment",
          "repository": "",
          "keywords": [],
          "categories": [],
          "readme": {
            "raw_markdown": "[](https://docs.rs/serde_json/latest/serde_json/all.html \"show sidebar\")\n# Crate serde_jsonCopy item path\n[Settings](https://docs.rs/serde_json/latest/settings.html)\n[Help](https://docs.rs/serde_json/latest/help.html)\nSummary[Source](https://docs.rs/serde_json/latest/src/serde_json/lib.rs.html#1-437)\nExpand description\n## [\u00a7](https://docs.rs/serde_json/latest/serde_json/#serde-json)Serde JSON\nJSON is a ubiquitous open-standard format that uses human-readable text to transmit data objects consisting of key-value pairs.\n```\n{\n  \"name\": \"John Doe\",\n  \"age\": 43,\n  \"address\": {\n    \"street\": \"10 Downing Street\",\n    \"city\": \"London\"\n  },\n  \"phones\": [\n    \"+44 1234567\",\n    \"+44 2345678\"\n  ]\n}\n```\n\nThere are three common ways that you might find yourself needing to work with JSON data in Rust.\n  * **As text data.** An unprocessed string of JSON data that you receive on an HTTP endpoint, read from a file, or prepare to send to a remote server.\n  * **As an untyped or loosely typed representation.** Maybe you want to check that some JSON data is valid before passing it on, but without knowing the structure of what it contains. Or you want to do very basic manipulations like insert a key in a particular spot.\n  * **As a strongly typed Rust data structure.** When you expect all or most of your data to conform to a particular structure and want to get real work done without JSON\u2019s loosey-goosey nature tripping you up.\n\n\nSerde JSON provides efficient, flexible, safe ways of converting data between each of these representations.\n## [\u00a7](https://docs.rs/serde_json/latest/serde_json/#operating-on-untyped-json-values)Operating on untyped JSON values\nAny valid JSON data can be manipulated in the following recursive enum representation. This data structure is [`serde_json::Value`](https://docs.rs/serde_json/latest/serde_json/enum.Value.html \"enum serde_json::Value\").\n```\nenum Value {\n  Null,\n  Bool(bool),\n  Number(Number),\n  String(String),\n  Array(Vec<Value>),\n  Object(Map<String, Value>),\n}\n```\n\nA string of JSON data can be parsed into a `serde_json::Value` by the [`serde_json::from_str`](https://docs.rs/serde_json/latest/serde_json/fn.from_str.html \"fn serde_json::from_str\") function. There is also [`from_slice`](https://docs.rs/serde_json/latest/serde_json/fn.from_slice.html \"fn serde_json::from_slice\") for parsing from a byte slice `&[u8]` and [`from_reader`](https://docs.rs/serde_json/latest/serde_json/fn.from_reader.html \"fn serde_json::from_reader\") for parsing from any `io::Read` like a File or a TCP stream.\n```\nuse serde_json::{Result, Value};\nfn untyped_example() -> Result<()> {\n  // Some JSON input data as a &str. Maybe this comes from the user.\n  let data = r#\"\n    {\n      \"name\": \"John Doe\",\n      \"age\": 43,\n      \"phones\": [\n        \"+44 1234567\",\n        \"+44 2345678\"\n      ]\n    }\"#;\n  // Parse the string of data into serde_json::Value.\n  let v: Value = serde_json::from_str(data)?;\n  // Access parts of the data by indexing with square brackets.\n  println!(\"Please call {} at the number {}\", v[\"name\"], v[\"phones\"][0]);\n  Ok(())\n}\n```\n\nThe result of square bracket indexing like `v[\"name\"]` is a borrow of the data at that index, so the type is `&Value`. A JSON map can be indexed with string keys, while a JSON array can be indexed with integer keys. If the type of the data is not right for the type with which it is being indexed, or if a map does not contain the key being indexed, or if the index into a vector is out of bounds, the returned element is `Value::Null`.\nWhen a `Value` is printed, it is printed as a JSON string. So in the code above, the output looks like `Please call \"John Doe\" at the number \"+44 1234567\"`. The quotation marks appear because `v[\"name\"]` is a `&Value` containing a JSON string and its JSON representation is `\"John Doe\"`. Printing as a plain string without quotation marks involves converting from a JSON string to a Rust string with [`as_str()`](https://docs.rs/serde_json/latest/serde_json/enum.Value.html#method.as_str \"method serde_json::Value::as_str\") or avoiding the use of `Value` as described in the following section.\nThe `Value` representation is sufficient for very basic tasks but can be tedious to work with for anything more significant. Error handling is verbose to implement correctly, for example imagine trying to detect the presence of unrecognized fields in the input data. The compiler is powerless to help you when you make a mistake, for example imagine typoing `v[\"name\"]` as `v[\"nmae\"]` in one of the dozens of places it is used in your code.\n## [\u00a7](https://docs.rs/serde_json/latest/serde_json/#parsing-json-as-strongly-typed-data-structures)Parsing JSON as strongly typed data structures\nSerde provides a powerful way of mapping JSON data into Rust data structures largely automatically.\n```\nuse serde::{Deserialize, Serialize};\nuse serde_json::Result;\n#[derive(Serialize, Deserialize)]\nstruct Person {\n  name: String,\n  age: u8,\n  phones: Vec<String>,\n}\nfn typed_example() -> Result<()> {\n  // Some JSON input data as a &str. Maybe this comes from the user.\n  let data = r#\"\n    {\n      \"name\": \"John Doe\",\n      \"age\": 43,\n      \"phones\": [\n        \"+44 1234567\",\n        \"+44 2345678\"\n      ]\n    }\"#;\n  // Parse the string of data into a Person object. This is exactly the\n  // same function as the one that produced serde_json::Value above, but\n  // now we are asking it for a Person as output.\n  let p: Person = serde_json::from_str(data)?;\n  // Do things just like with any other Rust data structure.\n  println!(\"Please call {} at the number {}\", p.name, p.phones[0]);\n  Ok(())\n}\n```\n\nThis is the same `serde_json::from_str` function as before, but this time we assign the return value to a variable of type `Person` so Serde will automatically interpret the input data as a `Person` and produce informative error messages if the layout does not conform to what a `Person` is expected to look like.\nAny type that implements Serde\u2019s `Deserialize` trait can be deserialized this way. This includes built-in Rust standard library types like `Vec<T>` and `HashMap<K, V>`, as well as any structs or enums annotated with `#[derive(Deserialize)]`.\nOnce we have `p` of type `Person`, our IDE and the Rust compiler can help us use it correctly like they do for any other Rust code. The IDE can autocomplete field names to prevent typos, which was impossible in the `serde_json::Value` representation. And the Rust compiler can check that when we write `p.phones[0]`, then `p.phones` is guaranteed to be a `Vec<String>` so indexing into it makes sense and produces a `String`.\n## [\u00a7](https://docs.rs/serde_json/latest/serde_json/#constructing-json-values)Constructing JSON values\nSerde JSON provides a [`json!` macro](https://docs.rs/serde_json/latest/serde_json/macro.json.html \"macro serde_json::json\") to build `serde_json::Value` objects with very natural JSON syntax.\n```\nuse serde_json::json;\nfn main() {\n  // The type of `john` is `serde_json::Value`\n  let john = json!({\n    \"name\": \"John Doe\",\n    \"age\": 43,\n    \"phones\": [\n      \"+44 1234567\",\n      \"+44 2345678\"\n    ]\n  });\n  println!(\"first phone number: {}\", john[\"phones\"][0]);\n  // Convert to a string of JSON and print it out\n  println!(\"{}\", john.to_string());\n}\n```\n\nThe `Value::to_string()` function converts a `serde_json::Value` into a `String` of JSON text.\nOne neat thing about the `json!` macro is that variables and expressions can be interpolated directly into the JSON value as you are building it. Serde will check at compile time that the value you are interpolating is able to be represented as JSON.\n```\nlet full_name = \"John Doe\";\nlet age_last_year = 42;\n// The type of `john` is `serde_json::Value`\nlet john = json!({\n  \"name\": full_name,\n  \"age\": age_last_year + 1,\n  \"phones\": [\n    format!(\"+44 {}\", random_phone())\n  ]\n});\n```\n\nThis is amazingly convenient, but we have the problem we had before with `Value`: the IDE and Rust compiler cannot help us if we get it wrong. Serde JSON provides a better way of serializing strongly-typed data structures into JSON text.\n## [\u00a7](https://docs.rs/serde_json/latest/serde_json/#creating-json-by-serializing-data-structures)Creating JSON by serializing data structures\nA data structure can be converted to a JSON string by [`serde_json::to_string`](https://docs.rs/serde_json/latest/serde_json/fn.to_string.html \"fn serde_json::to_string\"). There is also [`serde_json::to_vec`](https://docs.rs/serde_json/latest/serde_json/fn.to_vec.html \"fn serde_json::to_vec\") which serializes to a `Vec<u8>` and [`serde_json::to_writer`](https://docs.rs/serde_json/latest/serde_json/fn.to_writer.html \"fn serde_json::to_writer\") which serializes to any `io::Write` such as a File or a TCP stream.\n```\nuse serde::{Deserialize, Serialize};\nuse serde_json::Result;\n#[derive(Serialize, Deserialize)]\nstruct Address {\n  street: String,\n  city: String,\n}\nfn print_an_address() -> Result<()> {\n  // Some data structure.\n  let address = Address {\n    street: \"10 Downing Street\".to_owned(),\n    city: \"London\".to_owned(),\n  };\n  // Serialize it to a JSON string.\n  let j = serde_json::to_string(&address)?;\n  // Print, write to a file, or send to an HTTP server.\n  println!(\"{}\", j);\n  Ok(())\n}\n```\n\nAny type that implements Serde\u2019s `Serialize` trait can be serialized this way. This includes built-in Rust standard library types like `Vec<T>` and `HashMap<K, V>`, as well as any structs or enums annotated with `#[derive(Serialize)]`.\n## [\u00a7](https://docs.rs/serde_json/latest/serde_json/#no-std-support)No-std support\nAs long as there is a memory allocator, it is possible to use serde_json without the rest of the Rust standard library. Disable the default \u201cstd\u201d feature and enable the \u201calloc\u201d feature:\n```\n[dependencies]\nserde_json = { version = \"1.0\", default-features = false, features = [\"alloc\"] }\n```\n\nFor JSON support in Serde without a memory allocator, please see the [`serde-json-core`](https://github.com/rust-embedded-community/serde-json-core) crate.\n## Modules[\u00a7](https://docs.rs/serde_json/latest/serde_json/#modules)\n\n[de](https://docs.rs/serde_json/latest/serde_json/de/index.html \"mod serde_json::de\")\n    Deserialize JSON data to a Rust data structure.\n\n[error](https://docs.rs/serde_json/latest/serde_json/error/index.html \"mod serde_json::error\")\n    When serializing or deserializing JSON goes wrong.\n\n[map](https://docs.rs/serde_json/latest/serde_json/map/index.html \"mod serde_json::map\")\n    A map of String to serde_json::Value.\n\n[ser](https://docs.rs/serde_json/latest/serde_json/ser/index.html \"mod serde_json::ser\")`std`\n    Serialize a Rust data structure into JSON data.\n\n[value](https://docs.rs/serde_json/latest/serde_json/value/index.html \"mod serde_json::value\")\n    The Value enum, a loosely typed way of representing any valid JSON value.\n## Macros[\u00a7](https://docs.rs/serde_json/latest/serde_json/#macros)\n\n[json](https://docs.rs/serde_json/latest/serde_json/macro.json.html \"macro serde_json::json\")\n    Construct a `serde_json::Value` from a JSON literal.\n## Structs[\u00a7](https://docs.rs/serde_json/latest/serde_json/#structs)\n\n[Deserializer](https://docs.rs/serde_json/latest/serde_json/struct.Deserializer.html \"struct serde_json::Deserializer\")\n    A structure that deserializes JSON into Rust values.\n\n[Error](https://docs.rs/serde_json/latest/serde_json/struct.Error.html \"struct serde_json::Error\")\n    This type represents all possible errors that can occur when serializing or deserializing JSON data.\n\n[Map](https://docs.rs/serde_json/latest/serde_json/struct.Map.html \"struct serde_json::Map\")\n    Represents a JSON key/value type.\n\n[Number](https://docs.rs/serde_json/latest/serde_json/struct.Number.html \"struct serde_json::Number\")\n    Represents a JSON number, whether integer or floating point.\n\n[Serializer](https://docs.rs/serde_json/latest/serde_json/struct.Serializer.html \"struct serde_json::Serializer\")`std`\n    A structure for serializing Rust values into JSON.\n\n[StreamDeserializer](https://docs.rs/serde_json/latest/serde_json/struct.StreamDeserializer.html \"struct serde_json::StreamDeserializer\")\n    Iterator that deserializes a stream into multiple JSON values.\n## Enums[\u00a7](https://docs.rs/serde_json/latest/serde_json/#enums)\n\n[Value](https://docs.rs/serde_json/latest/serde_json/enum.Value.html \"enum serde_json::Value\")\n    Represents any valid JSON value.\n## Functions[\u00a7](https://docs.rs/serde_json/latest/serde_json/#functions)\n\n[from_reader](https://docs.rs/serde_json/latest/serde_json/fn.from_reader.html \"fn serde_json::from_reader\")`std`\n    Deserialize an instance of type `T` from an I/O stream of JSON.\n\n[from_slice](https://docs.rs/serde_json/latest/serde_json/fn.from_slice.html \"fn serde_json::from_slice\")\n    Deserialize an instance of type `T` from bytes of JSON text.\n\n[from_str](https://docs.rs/serde_json/latest/serde_json/fn.from_str.html \"fn serde_json::from_str\")\n    Deserialize an instance of type `T` from a string of JSON text.\n\n[from_value](https://docs.rs/serde_json/latest/serde_json/fn.from_value.html \"fn serde_json::from_value\")\n    Interpret a `serde_json::Value` as an instance of type `T`.\n\n[to_string](https://docs.rs/serde_json/latest/serde_json/fn.to_string.html \"fn serde_json::to_string\")`std`\n    Serialize the given data structure as a String of JSON.\n\n[to_string_pretty](https://docs.rs/serde_json/latest/serde_json/fn.to_string_pretty.html \"fn serde_json::to_string_pretty\")`std`\n    Serialize the given data structure as a pretty-printed String of JSON.\n\n[to_value](https://docs.rs/serde_json/latest/serde_json/fn.to_value.html \"fn serde_json::to_value\")\n    Convert a `T` into `serde_json::Value` which is an enum that can represent any valid JSON data.\n\n[to_vec](https://docs.rs/serde_json/latest/serde_json/fn.to_vec.html \"fn serde_json::to_vec\")`std`\n    Serialize the given data structure as a JSON byte vector.\n\n[to_vec_pretty](https://docs.rs/serde_json/latest/serde_json/fn.to_vec_pretty.html \"fn serde_json::to_vec_pretty\")`std`\n    Serialize the given data structure as a pretty-printed JSON byte vector.\n\n[to_writer](https://docs.rs/serde_json/latest/serde_json/fn.to_writer.html \"fn serde_json::to_writer\")`std`\n    Serialize the given data structure as JSON into the I/O stream.\n\n[to_writer_pretty](https://docs.rs/serde_json/latest/serde_json/fn.to_writer_pretty.html \"fn serde_json::to_writer_pretty\")`std`\n    Serialize the given data structure as pretty-printed JSON into the I/O stream.\n## Type Aliases[\u00a7](https://docs.rs/serde_json/latest/serde_json/#types)\n\n[Result](https://docs.rs/serde_json/latest/serde_json/type.Result.html \"type serde_json::Result\")\n    Alias for a `Result` with the error type `serde_json::Error`.\n",
            "markdown_with_citations": "[](https://docs.rs/serde_json/latest/serde_json/all.html \"show sidebar\")\n# Crate serde_jsonCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\n## \u00a7\u27e84\u27e9Serde JSON\nJSON is a ubiquitous open-standard format that uses human-readable text to transmit data objects consisting of key-value pairs.\n```\n{\n  \"name\": \"John Doe\",\n  \"age\": 43,\n  \"address\": {\n    \"street\": \"10 Downing Street\",\n    \"city\": \"London\"\n  },\n  \"phones\": [\n    \"+44 1234567\",\n    \"+44 2345678\"\n  ]\n}\n```\n\nThere are three common ways that you might find yourself needing to work with JSON data in Rust.\n  * **As text data.** An unprocessed string of JSON data that you receive on an HTTP endpoint, read from a file, or prepare to send to a remote server.\n  * **As an untyped or loosely typed representation.** Maybe you want to check that some JSON data is valid before passing it on, but without knowing the structure of what it contains. Or you want to do very basic manipulations like insert a key in a particular spot.\n  * **As a strongly typed Rust data structure.** When you expect all or most of your data to conform to a particular structure and want to get real work done without JSON\u2019s loosey-goosey nature tripping you up.\n\n\nSerde JSON provides efficient, flexible, safe ways of converting data between each of these representations.\n## \u00a7\u27e85\u27e9Operating on untyped JSON values\nAny valid JSON data can be manipulated in the following recursive enum representation. This data structure is `serde_json::Value`\u27e86\u27e9.\n```\nenum Value {\n  Null,\n  Bool(bool),\n  Number(Number),\n  String(String),\n  Array(Vec<Value>),\n  Object(Map<String, Value>),\n}\n```\n\nA string of JSON data can be parsed into a `serde_json::Value` by the `serde_json::from_str`\u27e87\u27e9 function. There is also `from_slice`\u27e88\u27e9 for parsing from a byte slice `&[u8]` and `from_reader`\u27e89\u27e9 for parsing from any `io::Read` like a File or a TCP stream.\n```\nuse serde_json::{Result, Value};\nfn untyped_example() -> Result<()> {\n  // Some JSON input data as a &str. Maybe this comes from the user.\n  let data = r#\"\n    {\n      \"name\": \"John Doe\",\n      \"age\": 43,\n      \"phones\": [\n        \"+44 1234567\",\n        \"+44 2345678\"\n      ]\n    }\"#;\n  // Parse the string of data into serde_json::Value.\n  let v: Value = serde_json::from_str(data)?;\n  // Access parts of the data by indexing with square brackets.\n  println!(\"Please call {} at the number {}\", v[\"name\"], v[\"phones\"][0]);\n  Ok(())\n}\n```\n\nThe result of square bracket indexing like `v[\"name\"]` is a borrow of the data at that index, so the type is `&Value`. A JSON map can be indexed with string keys, while a JSON array can be indexed with integer keys. If the type of the data is not right for the type with which it is being indexed, or if a map does not contain the key being indexed, or if the index into a vector is out of bounds, the returned element is `Value::Null`.\nWhen a `Value` is printed, it is printed as a JSON string. So in the code above, the output looks like `Please call \"John Doe\" at the number \"+44 1234567\"`. The quotation marks appear because `v[\"name\"]` is a `&Value` containing a JSON string and its JSON representation is `\"John Doe\"`. Printing as a plain string without quotation marks involves converting from a JSON string to a Rust string with `as_str()`\u27e810\u27e9 or avoiding the use of `Value` as described in the following section.\nThe `Value` representation is sufficient for very basic tasks but can be tedious to work with for anything more significant. Error handling is verbose to implement correctly, for example imagine trying to detect the presence of unrecognized fields in the input data. The compiler is powerless to help you when you make a mistake, for example imagine typoing `v[\"name\"]` as `v[\"nmae\"]` in one of the dozens of places it is used in your code.\n## \u00a7\u27e811\u27e9Parsing JSON as strongly typed data structures\nSerde provides a powerful way of mapping JSON data into Rust data structures largely automatically.\n```\nuse serde::{Deserialize, Serialize};\nuse serde_json::Result;\n#[derive(Serialize, Deserialize)]\nstruct Person {\n  name: String,\n  age: u8,\n  phones: Vec<String>,\n}\nfn typed_example() -> Result<()> {\n  // Some JSON input data as a &str. Maybe this comes from the user.\n  let data = r#\"\n    {\n      \"name\": \"John Doe\",\n      \"age\": 43,\n      \"phones\": [\n        \"+44 1234567\",\n        \"+44 2345678\"\n      ]\n    }\"#;\n  // Parse the string of data into a Person object. This is exactly the\n  // same function as the one that produced serde_json::Value above, but\n  // now we are asking it for a Person as output.\n  let p: Person = serde_json::from_str(data)?;\n  // Do things just like with any other Rust data structure.\n  println!(\"Please call {} at the number {}\", p.name, p.phones[0]);\n  Ok(())\n}\n```\n\nThis is the same `serde_json::from_str` function as before, but this time we assign the return value to a variable of type `Person` so Serde will automatically interpret the input data as a `Person` and produce informative error messages if the layout does not conform to what a `Person` is expected to look like.\nAny type that implements Serde\u2019s `Deserialize` trait can be deserialized this way. This includes built-in Rust standard library types like `Vec<T>` and `HashMap<K, V>`, as well as any structs or enums annotated with `#[derive(Deserialize)]`.\nOnce we have `p` of type `Person`, our IDE and the Rust compiler can help us use it correctly like they do for any other Rust code. The IDE can autocomplete field names to prevent typos, which was impossible in the `serde_json::Value` representation. And the Rust compiler can check that when we write `p.phones[0]`, then `p.phones` is guaranteed to be a `Vec<String>` so indexing into it makes sense and produces a `String`.\n## \u00a7\u27e812\u27e9Constructing JSON values\nSerde JSON provides a `json!` macro\u27e813\u27e9 to build `serde_json::Value` objects with very natural JSON syntax.\n```\nuse serde_json::json;\nfn main() {\n  // The type of `john` is `serde_json::Value`\n  let john = json!({\n    \"name\": \"John Doe\",\n    \"age\": 43,\n    \"phones\": [\n      \"+44 1234567\",\n      \"+44 2345678\"\n    ]\n  });\n  println!(\"first phone number: {}\", john[\"phones\"][0]);\n  // Convert to a string of JSON and print it out\n  println!(\"{}\", john.to_string());\n}\n```\n\nThe `Value::to_string()` function converts a `serde_json::Value` into a `String` of JSON text.\nOne neat thing about the `json!` macro is that variables and expressions can be interpolated directly into the JSON value as you are building it. Serde will check at compile time that the value you are interpolating is able to be represented as JSON.\n```\nlet full_name = \"John Doe\";\nlet age_last_year = 42;\n// The type of `john` is `serde_json::Value`\nlet john = json!({\n  \"name\": full_name,\n  \"age\": age_last_year + 1,\n  \"phones\": [\n    format!(\"+44 {}\", random_phone())\n  ]\n});\n```\n\nThis is amazingly convenient, but we have the problem we had before with `Value`: the IDE and Rust compiler cannot help us if we get it wrong. Serde JSON provides a better way of serializing strongly-typed data structures into JSON text.\n## \u00a7\u27e814\u27e9Creating JSON by serializing data structures\nA data structure can be converted to a JSON string by `serde_json::to_string`\u27e815\u27e9. There is also `serde_json::to_vec`\u27e816\u27e9 which serializes to a `Vec<u8>` and `serde_json::to_writer`\u27e817\u27e9 which serializes to any `io::Write` such as a File or a TCP stream.\n```\nuse serde::{Deserialize, Serialize};\nuse serde_json::Result;\n#[derive(Serialize, Deserialize)]\nstruct Address {\n  street: String,\n  city: String,\n}\nfn print_an_address() -> Result<()> {\n  // Some data structure.\n  let address = Address {\n    street: \"10 Downing Street\".to_owned(),\n    city: \"London\".to_owned(),\n  };\n  // Serialize it to a JSON string.\n  let j = serde_json::to_string(&address)?;\n  // Print, write to a file, or send to an HTTP server.\n  println!(\"{}\", j);\n  Ok(())\n}\n```\n\nAny type that implements Serde\u2019s `Serialize` trait can be serialized this way. This includes built-in Rust standard library types like `Vec<T>` and `HashMap<K, V>`, as well as any structs or enums annotated with `#[derive(Serialize)]`.\n## \u00a7\u27e818\u27e9No-std support\nAs long as there is a memory allocator, it is possible to use serde_json without the rest of the Rust standard library. Disable the default \u201cstd\u201d feature and enable the \u201calloc\u201d feature:\n```\n[dependencies]\nserde_json = { version = \"1.0\", default-features = false, features = [\"alloc\"] }\n```\n\nFor JSON support in Serde without a memory allocator, please see the `serde-json-core`\u27e819\u27e9 crate.\n## Modules\u00a7\u27e820\u27e9\n\nde\u27e821\u27e9\n    Deserialize JSON data to a Rust data structure.\n\nerror\u27e822\u27e9\n    When serializing or deserializing JSON goes wrong.\n\nmap\u27e823\u27e9\n    A map of String to serde_json::Value.\n\nser\u27e824\u27e9`std`\n    Serialize a Rust data structure into JSON data.\n\nvalue\u27e825\u27e9\n    The Value enum, a loosely typed way of representing any valid JSON value.\n## Macros\u00a7\u27e826\u27e9\n\njson\u27e813\u27e9\n    Construct a `serde_json::Value` from a JSON literal.\n## Structs\u00a7\u27e827\u27e9\n\nDeserializer\u27e828\u27e9\n    A structure that deserializes JSON into Rust values.\n\nError\u27e829\u27e9\n    This type represents all possible errors that can occur when serializing or deserializing JSON data.\n\nMap\u27e830\u27e9\n    Represents a JSON key/value type.\n\nNumber\u27e831\u27e9\n    Represents a JSON number, whether integer or floating point.\n\nSerializer\u27e832\u27e9`std`\n    A structure for serializing Rust values into JSON.\n\nStreamDeserializer\u27e833\u27e9\n    Iterator that deserializes a stream into multiple JSON values.\n## Enums\u00a7\u27e834\u27e9\n\nValue\u27e86\u27e9\n    Represents any valid JSON value.\n## Functions\u00a7\u27e835\u27e9\n\nfrom_reader\u27e89\u27e9`std`\n    Deserialize an instance of type `T` from an I/O stream of JSON.\n\nfrom_slice\u27e88\u27e9\n    Deserialize an instance of type `T` from bytes of JSON text.\n\nfrom_str\u27e87\u27e9\n    Deserialize an instance of type `T` from a string of JSON text.\n\nfrom_value\u27e836\u27e9\n    Interpret a `serde_json::Value` as an instance of type `T`.\n\nto_string\u27e815\u27e9`std`\n    Serialize the given data structure as a String of JSON.\n\nto_string_pretty\u27e837\u27e9`std`\n    Serialize the given data structure as a pretty-printed String of JSON.\n\nto_value\u27e838\u27e9\n    Convert a `T` into `serde_json::Value` which is an enum that can represent any valid JSON data.\n\nto_vec\u27e816\u27e9`std`\n    Serialize the given data structure as a JSON byte vector.\n\nto_vec_pretty\u27e839\u27e9`std`\n    Serialize the given data structure as a pretty-printed JSON byte vector.\n\nto_writer\u27e817\u27e9`std`\n    Serialize the given data structure as JSON into the I/O stream.\n\nto_writer_pretty\u27e840\u27e9`std`\n    Serialize the given data structure as pretty-printed JSON into the I/O stream.\n## Type Aliases\u00a7\u27e841\u27e9\n\nResult\u27e842\u27e9\n    Alias for a `Result` with the error type `serde_json::Error`.\n",
            "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/serde_json/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/serde_json/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/serde_json/latest/src/serde_json/lib.rs.html#1-437: Source\n\u27e84\u27e9 https://docs.rs/serde_json/latest/serde_json/#serde-json: \u00a7\n\u27e85\u27e9 https://docs.rs/serde_json/latest/serde_json/#operating-on-untyped-json-values: \u00a7\n\u27e86\u27e9 https://docs.rs/serde_json/latest/serde_json/enum.Value.html: enum serde_json::Value - `serde_json::Value`\n\u27e87\u27e9 https://docs.rs/serde_json/latest/serde_json/fn.from_str.html: fn serde_json::from_str - `serde_json::from_str`\n\u27e88\u27e9 https://docs.rs/serde_json/latest/serde_json/fn.from_slice.html: fn serde_json::from_slice - `from_slice`\n\u27e89\u27e9 https://docs.rs/serde_json/latest/serde_json/fn.from_reader.html: fn serde_json::from_reader - `from_reader`\n\u27e810\u27e9 https://docs.rs/serde_json/latest/serde_json/enum.Value.html#method.as_str: method serde_json::Value::as_str - `as_str()`\n\u27e811\u27e9 https://docs.rs/serde_json/latest/serde_json/#parsing-json-as-strongly-typed-data-structures: \u00a7\n\u27e812\u27e9 https://docs.rs/serde_json/latest/serde_json/#constructing-json-values: \u00a7\n\u27e813\u27e9 https://docs.rs/serde_json/latest/serde_json/macro.json.html: macro serde_json::json - `json!` macro\n\u27e814\u27e9 https://docs.rs/serde_json/latest/serde_json/#creating-json-by-serializing-data-structures: \u00a7\n\u27e815\u27e9 https://docs.rs/serde_json/latest/serde_json/fn.to_string.html: fn serde_json::to_string - `serde_json::to_string`\n\u27e816\u27e9 https://docs.rs/serde_json/latest/serde_json/fn.to_vec.html: fn serde_json::to_vec - `serde_json::to_vec`\n\u27e817\u27e9 https://docs.rs/serde_json/latest/serde_json/fn.to_writer.html: fn serde_json::to_writer - `serde_json::to_writer`\n\u27e818\u27e9 https://docs.rs/serde_json/latest/serde_json/#no-std-support: \u00a7\n\u27e819\u27e9 https://github.com/rust-embedded-community/serde-json-core: `serde-json-core`\n\u27e820\u27e9 https://docs.rs/serde_json/latest/serde_json/#modules: \u00a7\n\u27e821\u27e9 https://docs.rs/serde_json/latest/serde_json/de/index.html: mod serde_json::de - de\n\u27e822\u27e9 https://docs.rs/serde_json/latest/serde_json/error/index.html: mod serde_json::error - error\n\u27e823\u27e9 https://docs.rs/serde_json/latest/serde_json/map/index.html: mod serde_json::map - map\n\u27e824\u27e9 https://docs.rs/serde_json/latest/serde_json/ser/index.html: mod serde_json::ser - ser\n\u27e825\u27e9 https://docs.rs/serde_json/latest/serde_json/value/index.html: mod serde_json::value - value\n\u27e826\u27e9 https://docs.rs/serde_json/latest/serde_json/#macros: \u00a7\n\u27e827\u27e9 https://docs.rs/serde_json/latest/serde_json/#structs: \u00a7\n\u27e828\u27e9 https://docs.rs/serde_json/latest/serde_json/struct.Deserializer.html: struct serde_json::Deserializer - Deserializer\n\u27e829\u27e9 https://docs.rs/serde_json/latest/serde_json/struct.Error.html: struct serde_json::Error - Error\n\u27e830\u27e9 https://docs.rs/serde_json/latest/serde_json/struct.Map.html: struct serde_json::Map - Map\n\u27e831\u27e9 https://docs.rs/serde_json/latest/serde_json/struct.Number.html: struct serde_json::Number - Number\n\u27e832\u27e9 https://docs.rs/serde_json/latest/serde_json/struct.Serializer.html: struct serde_json::Serializer - Serializer\n\u27e833\u27e9 https://docs.rs/serde_json/latest/serde_json/struct.StreamDeserializer.html: struct serde_json::StreamDeserializer - StreamDeserializer\n\u27e834\u27e9 https://docs.rs/serde_json/latest/serde_json/#enums: \u00a7\n\u27e835\u27e9 https://docs.rs/serde_json/latest/serde_json/#functions: \u00a7\n\u27e836\u27e9 https://docs.rs/serde_json/latest/serde_json/fn.from_value.html: fn serde_json::from_value - from_value\n\u27e837\u27e9 https://docs.rs/serde_json/latest/serde_json/fn.to_string_pretty.html: fn serde_json::to_string_pretty - to_string_pretty\n\u27e838\u27e9 https://docs.rs/serde_json/latest/serde_json/fn.to_value.html: fn serde_json::to_value - to_value\n\u27e839\u27e9 https://docs.rs/serde_json/latest/serde_json/fn.to_vec_pretty.html: fn serde_json::to_vec_pretty - to_vec_pretty\n\u27e840\u27e9 https://docs.rs/serde_json/latest/serde_json/fn.to_writer_pretty.html: fn serde_json::to_writer_pretty - to_writer_pretty\n\u27e841\u27e9 https://docs.rs/serde_json/latest/serde_json/#types: \u00a7\n\u27e842\u27e9 https://docs.rs/serde_json/latest/serde_json/type.Result.html: type serde_json::Result - Result\n",
            "fit_markdown": "",
            "fit_html": ""
          },
          "downloads": 0,
          "github_stars": 0,
          "dependencies": [],
          "features": {},
          "code_snippets": [],
          "readme_sections": {},
          "librs_downloads": null,
          "source": "crates.io",
          "enhanced_scraping": {},
          "enhanced_features": [],
          "enhanced_dependencies": [],
          "readme_summary": "The `serde_json` crate provides efficient and flexible tools for working with JSON data in Rust, supporting three key use cases: handling raw JSON text, manipulating untyped JSON via the `serde_json::Value` enum, and mapping JSON to strongly-typed Rust data structures using Serde's `Deserialize` and `Serialize` traits. It includes features like parsing JSON from strings, slices, or readers, constructing JSON with the `json!` macro, and converting JSON to and from Rust types seamlessly, enabling safe and ergonomic JSON handling.",
          "feature_summary": null,
          "use_case": "Serialization",
          "score": 9.5,
          "factual_counterfactual": "### Pair 1: Parsing JSON into Rust data structures\n\u2705 **Factual:** The `serde_json` crate allows parsing JSON data directly into strongly typed Rust data structures using the `serde::Deserialize` trait, enabling safe and efficient data handling.  \n\u274c **Counterfactual:** The `serde_json` crate requires manual implementation of parsing logic for each field in a JSON object, as it does not support automatic deserialization into Rust structs.\n\n---\n\n### Pair 2: Handling untyped JSON values\n\u2705 **Factual:** The `serde_json::Value` enum provides a flexible way to work with untyped JSON data, supporting recursive structures like arrays and objects.  \n\u274c **Counterfactual:** The `serde_json::Value` enum only supports flat JSON structures and cannot represent nested arrays or objects.\n\n---\n\n### Pair 3: Error handling during JSON parsing\n\u2705 **Factual:** When parsing JSON data with `serde_json::from_str`, errors such as invalid syntax or type mismatches are returned as a `serde_json::Error`, which can be handled using Rust's `Result` type.  \n\u274c **Counterfactual:** The `serde_json::from_str` function silently ignores errors during JSON parsing and returns a default value instead of propagating an error.",
          "source_analysis": null,
          "user_behavior": null,
          "security": null
        }
      },
      "irl_score": 8.6,
      "execution_id": "exec-54445c66-a1bc3ec9-1751258907",
      "timestamp": "2025-06-30T04:48:27.041256+00:00",
      "canon_version": "1.3.0"
    },
    "rule_zero_compliant": true
  }
]