{
    "name": "crossterm",
    "version": "0.29.0",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/crossterm/latest/crossterm/all.html \"show sidebar\")\n# Crate crosstermCopy item path\n[Settings](https://docs.rs/crossterm/latest/settings.html)\n[Help](https://docs.rs/crossterm/latest/help.html)\nSummary[Source](https://docs.rs/crossterm/latest/src/crossterm/lib.rs.html#1-263)\nExpand description\n## [\u00a7](https://docs.rs/crossterm/latest/crossterm/#cross-platform-terminal-manipulation-library)Cross-platform Terminal Manipulation Library\nCrossterm is a pure-rust, terminal manipulation library that makes it possible to write cross-platform text-based interfaces.\nThis crate supports all UNIX and Windows terminals down to Windows 7 (not all terminals are tested see [Tested Terminals](https://github.com/crossterm-rs/crossterm#tested-terminals) for more info).\n### [\u00a7](https://docs.rs/crossterm/latest/crossterm/#command-api)Command API\nThe command API makes the use of `crossterm` much easier and offers more control over when and how a command is executed. A command is just an action you can perform on the terminal e.g. cursor movement.\nThe command API offers:\n  * Better Performance.\n  * Complete control over when to flush.\n  * Complete control over where the ANSI escape commands are executed to.\n  * Way easier and nicer API.\n\n\nThere are two ways to use the API command:\n  * Functions can execute commands on types that implement Write. Functions are easier to use and debug. There is a disadvantage, and that is that there is a boilerplate code involved.\n  * Macros are generally seen as more difficult and aren\u2019t always well supported by editors but offer an API with less boilerplate code. If you are not afraid of macros, this is a recommendation.\n\n\nLinux and Windows 10 systems support ANSI escape codes. Those ANSI escape codes are strings or rather a byte sequence. When we `write` and `flush` those to the terminal we can perform some action. For older windows systems a WinAPI call is made.\n#### [\u00a7](https://docs.rs/crossterm/latest/crossterm/#supported-commands)Supported Commands\n  * Module [`cursor`](https://docs.rs/crossterm/latest/crossterm/cursor/index.html)\n    * Visibility - [`Show`](https://docs.rs/crossterm/latest/crossterm/cursor/struct.Show.html), [`Hide`](https://docs.rs/crossterm/latest/crossterm/cursor/struct.Hide.html)\n    * Appearance - [`EnableBlinking`](https://docs.rs/crossterm/latest/crossterm/cursor/struct.EnableBlinking.html), [`DisableBlinking`](https://docs.rs/crossterm/latest/crossterm/cursor/struct.DisableBlinking.html), [`SetCursorStyle`](https://docs.rs/crossterm/latest/crossterm/cursor/enum.SetCursorStyle.html)\n    * Position - [`SavePosition`](https://docs.rs/crossterm/latest/crossterm/cursor/struct.SavePosition.html), [`RestorePosition`](https://docs.rs/crossterm/latest/crossterm/cursor/struct.RestorePosition.html), [`MoveUp`](https://docs.rs/crossterm/latest/crossterm/cursor/struct.MoveUp.html), [`MoveDown`](https://docs.rs/crossterm/latest/crossterm/cursor/struct.MoveDown.html), [`MoveLeft`](https://docs.rs/crossterm/latest/crossterm/cursor/struct.MoveLeft.html), [`MoveRight`](https://docs.rs/crossterm/latest/crossterm/cursor/struct.MoveRight.html), [`MoveTo`](https://docs.rs/crossterm/latest/crossterm/cursor/struct.MoveTo.html), [`MoveToColumn`](https://docs.rs/crossterm/latest/crossterm/cursor/struct.MoveToColumn.html),[`MoveToRow`](https://docs.rs/crossterm/latest/crossterm/cursor/struct.MoveToRow.html), [`MoveToNextLine`](https://docs.rs/crossterm/latest/crossterm/cursor/struct.MoveToNextLine.html), [`MoveToPreviousLine`](https://docs.rs/crossterm/latest/crossterm/cursor/struct.MoveToPreviousLine.html)\n  * Module [`event`](https://docs.rs/crossterm/latest/crossterm/event/index.html)\n    * Keyboard events - [`PushKeyboardEnhancementFlags`](https://docs.rs/crossterm/latest/crossterm/event/struct.PushKeyboardEnhancementFlags.html), [`PopKeyboardEnhancementFlags`](https://docs.rs/crossterm/latest/crossterm/event/struct.PopKeyboardEnhancementFlags.html)\n    * Mouse events - [`EnableMouseCapture`](https://docs.rs/crossterm/latest/crossterm/event/struct.EnableMouseCapture.html), [`DisableMouseCapture`](https://docs.rs/crossterm/latest/crossterm/event/struct.DisableMouseCapture.html)\n  * Module [`style`](https://docs.rs/crossterm/latest/crossterm/style/index.html)\n    * Colors - [`SetForegroundColor`](https://docs.rs/crossterm/latest/crossterm/style/struct.SetForegroundColor.html), [`SetBackgroundColor`](https://docs.rs/crossterm/latest/crossterm/style/struct.SetBackgroundColor.html), [`ResetColor`](https://docs.rs/crossterm/latest/crossterm/style/struct.ResetColor.html), [`SetColors`](https://docs.rs/crossterm/latest/crossterm/style/struct.SetColors.html)\n    * Attributes - [`SetAttribute`](https://docs.rs/crossterm/latest/crossterm/style/struct.SetAttribute.html), [`SetAttributes`](https://docs.rs/crossterm/latest/crossterm/style/struct.SetAttributes.html), [`PrintStyledContent`](https://docs.rs/crossterm/latest/crossterm/style/struct.PrintStyledContent.html)\n  * Module [`terminal`](https://docs.rs/crossterm/latest/crossterm/terminal/index.html)\n    * Scrolling - [`ScrollUp`](https://docs.rs/crossterm/latest/crossterm/terminal/struct.ScrollUp.html), [`ScrollDown`](https://docs.rs/crossterm/latest/crossterm/terminal/struct.ScrollDown.html)\n    * Miscellaneous - [`Clear`](https://docs.rs/crossterm/latest/crossterm/terminal/struct.Clear.html), [`SetSize`](https://docs.rs/crossterm/latest/crossterm/terminal/struct.SetSize.html), [`SetTitle`](https://docs.rs/crossterm/latest/crossterm/terminal/struct.SetTitle.html), [`DisableLineWrap`](https://docs.rs/crossterm/latest/crossterm/terminal/struct.DisableLineWrap.html), [`EnableLineWrap`](https://docs.rs/crossterm/latest/crossterm/terminal/struct.EnableLineWrap.html)\n    * Alternate screen - [`EnterAlternateScreen`](https://docs.rs/crossterm/latest/crossterm/terminal/struct.EnterAlternateScreen.html), [`LeaveAlternateScreen`](https://docs.rs/crossterm/latest/crossterm/terminal/struct.LeaveAlternateScreen.html)\n  * Module [`clipboard`](https://docs.rs/crossterm/latest/crossterm/clipboard/index.html) (requires [`feature = \"osc52\"`](https://docs.rs/crossterm/latest/crossterm/#optional-features)) \n    * Clipboard - [`CopyToClipboard`](https://docs.rs/crossterm/latest/crossterm/clipboard/struct.CopyToClipboard.html)\n\n\n#### [\u00a7](https://docs.rs/crossterm/latest/crossterm/#command-execution)Command Execution\nThere are two different ways to execute commands:\n  * [Lazy Execution](https://docs.rs/crossterm/latest/crossterm/#lazy-execution)\n  * [Direct Execution](https://docs.rs/crossterm/latest/crossterm/#direct-execution)\n\n\n##### [\u00a7](https://docs.rs/crossterm/latest/crossterm/#lazy-execution)Lazy Execution\nFlushing bytes to the terminal buffer is a heavy system call. If we perform a lot of actions with the terminal, we want to do this periodically - like with a TUI editor - so that we can flush more data to the terminal buffer at the same time.\nCrossterm offers the possibility to do this with `queue`. With `queue` you can queue commands, and when you call [Write::flush](https://doc.rust-lang.org/std/io/trait.Write.html#tymethod.flush) these commands will be executed.\nYou can pass a custom buffer implementing [std::io::Write](https://doc.rust-lang.org/std/io/trait.Write.html) to this `queue` operation. The commands will be executed on that buffer. The most common buffer is [std::io::stdout](https://doc.rust-lang.org/std/io/fn.stdout.html) however, [std::io::stderr](https://doc.rust-lang.org/std/io/fn.stderr.html) is used sometimes as well.\n###### [\u00a7](https://docs.rs/crossterm/latest/crossterm/#examples)Examples\nA simple demonstration that shows the command API in action with cursor commands.\nFunctions:\n```\nuse std::io::{Write, stdout};\nuse crossterm::{QueueableCommand, cursor};\nlet mut stdout = stdout();\nstdout.queue(cursor::MoveTo(5,5));\n// some other code ...\nstdout.flush();\n```\n\nThe [queue](https://docs.rs/crossterm/latest/crossterm/trait.QueueableCommand.html) function returns itself, therefore you can use this to queue another command. Like `stdout.queue(Goto(5,5)).queue(Clear(ClearType::All))`.\nMacros:\n```\nuse std::io::{Write, stdout};\nuse crossterm::{queue, QueueableCommand, cursor};\nlet mut stdout = stdout();\nqueue!(stdout, cursor::MoveTo(5, 5));\n// some other code ...\n// move operation is performed only if we flush the buffer.\nstdout.flush();\n```\n\nYou can pass more than one command into the [queue](https://docs.rs/crossterm/latest/crossterm/macro.queue.html) macro like `queue!(stdout, MoveTo(5, 5), Clear(ClearType::All))` and they will be executed in the given order from left to right.\n##### [\u00a7](https://docs.rs/crossterm/latest/crossterm/#direct-execution)Direct Execution\nFor many applications it is not at all important to be efficient with \u2018flush\u2019 operations. For this use case there is the `execute` operation. This operation executes the command immediately, and calls the `flush` under water.\nYou can pass a custom buffer implementing [std::io::Write](https://doc.rust-lang.org/std/io/trait.Write.html) to this `execute` operation. The commands will be executed on that buffer. The most common buffer is [std::io::stdout](https://doc.rust-lang.org/std/io/fn.stdout.html) however, [std::io::stderr](https://doc.rust-lang.org/std/io/fn.stderr.html) is used sometimes as well.\n###### [\u00a7](https://docs.rs/crossterm/latest/crossterm/#examples-1)Examples\nFunctions:\n```\nuse std::io::{Write, stdout};\nuse crossterm::{ExecutableCommand, cursor};\nlet mut stdout = stdout();\nstdout.execute(cursor::MoveTo(5,5));\n```\n\nThe [execute](https://docs.rs/crossterm/latest/crossterm/trait.ExecutableCommand.html) function returns itself, therefore you can use this to queue another command. Like `stdout.execute(Goto(5,5))?.execute(Clear(ClearType::All))`.\nMacros:\n```\nuse std::io::{stdout, Write};\nuse crossterm::{execute, ExecutableCommand, cursor};\nlet mut stdout = stdout();\nexecute!(stdout, cursor::MoveTo(5, 5));\n```\n\nYou can pass more than one command into the [execute](https://docs.rs/crossterm/latest/crossterm/macro.execute.html) macro like `execute!(stdout, MoveTo(5, 5), Clear(ClearType::All))` and they will be executed in the given order from left to right.\n### [\u00a7](https://docs.rs/crossterm/latest/crossterm/#examples-2)Examples\nPrint a rectangle colored with magenta and use both direct execution and lazy execution.\nFunctions:\n```\nuse std::io::{self, Write};\nuse crossterm::{\n  ExecutableCommand, QueueableCommand,\n  terminal, cursor, style::{self, Stylize}\n};\nfn main() -> io::Result<()> {\n let mut stdout = io::stdout();\n stdout.execute(terminal::Clear(terminal::ClearType::All))?;\n for y in 0..40 {\n  for x in 0..150 {\n   if (y == 0 || y == 40 - 1) || (x == 0 || x == 150 - 1) {\n    // in this loop we are more efficient by not flushing the buffer.\n    stdout\n     .queue(cursor::MoveTo(x,y))?\n     .queue(style::PrintStyledContent( \"\u2588\".magenta()))?;\n   }\n  }\n }\n stdout.flush()?;\n Ok(())\n}\n```\n\nMacros:\n```\nuse std::io::{self, Write};\nuse crossterm::{\n  execute, queue,\n  style::{self, Stylize}, cursor, terminal\n};\nfn main() -> io::Result<()> {\n let mut stdout = io::stdout();\n execute!(stdout, terminal::Clear(terminal::ClearType::All))?;\n for y in 0..40 {\n  for x in 0..150 {\n   if (y == 0 || y == 40 - 1) || (x == 0 || x == 150 - 1) {\n    // in this loop we are more efficient by not flushing the buffer.\n    queue!(stdout, cursor::MoveTo(x,y), style::PrintStyledContent( \"\u2588\".magenta()))?;\n   }\n  }\n }\n stdout.flush()?;\n Ok(())\n}\n```\n\n### [\u00a7](https://docs.rs/crossterm/latest/crossterm/#feature-flags)Feature Flags\n#### [\u00a7](https://docs.rs/crossterm/latest/crossterm/#default-features)Default features\n  * **`bracketed-paste`**_(enabled by default)_ \u2014 Enables triggering [`Event::Paste`](https://docs.rs/crossterm/latest/crossterm/event/enum.Event.html#variant.Paste \"variant crossterm::event::Event::Paste\") when pasting text into the terminal.\n  * **`events`**_(enabled by default)_ \u2014 Enables reading input/events from the system using the [`event`](https://docs.rs/crossterm/latest/crossterm/event/index.html \"mod crossterm::event\") module.\n  * **`windows`**_(enabled by default)_ \u2014 Enables windows specific crates.\n\n\n#### [\u00a7](https://docs.rs/crossterm/latest/crossterm/#optional-features)Optional Features\n  * **`event-stream`**\u2014 Enables the[EventStream](https://docs.rs/crossterm/latest/crossterm/event/struct.EventStream.html \"struct crossterm::event::EventStream\") struct for async event reading.\n  * **`serde`**\u2014 Enables[`serde`](https://docs.rs/serde/1.0.219/x86_64-unknown-linux-gnu/serde/index.html \"mod serde\") for various types.\n  * **`use-dev-tty`**\u2014 Enables raw file descriptor polling / selecting instead of mio.\n  * **`derive-more`**_(enabled by default)_ \u2014 Enables `is_*` helper functions for event enums.\n  * **`osc52`**\u2014 Enables interacting with a host clipboard via[`clipboard`](https://docs.rs/crossterm/latest/crossterm/clipboard/index.html)\n\n\n## Modules[\u00a7](https://docs.rs/crossterm/latest/crossterm/#modules)\n\n[clipboard](https://docs.rs/crossterm/latest/crossterm/clipboard/index.html \"mod crossterm::clipboard\")\n    A module for clipboard interaction\n\n[cursor](https://docs.rs/crossterm/latest/crossterm/cursor/index.html \"mod crossterm::cursor\")\n    A module to work with the terminal cursor\n\n[event](https://docs.rs/crossterm/latest/crossterm/event/index.html \"mod crossterm::event\")\n    A module to read events.\n\n[style](https://docs.rs/crossterm/latest/crossterm/style/index.html \"mod crossterm::style\")\n    A module to apply attributes and colors on your text.\n\n[terminal](https://docs.rs/crossterm/latest/crossterm/terminal/index.html \"mod crossterm::terminal\")\n    A module to work with the terminal.\n\n[tty](https://docs.rs/crossterm/latest/crossterm/tty/index.html \"mod crossterm::tty\")\n    A module to query if the current instance is a tty. Making it a little more convenient and safe to query whether something is a terminal teletype or not. This module defines the IsTty trait and the is_tty method to return true if the item represents a terminal.\n## Macros[\u00a7](https://docs.rs/crossterm/latest/crossterm/#macros)\n\n[execute](https://docs.rs/crossterm/latest/crossterm/macro.execute.html \"macro crossterm::execute\")\n    Executes one or more command(s).\n\n[queue](https://docs.rs/crossterm/latest/crossterm/macro.queue.html \"macro crossterm::queue\")\n    Queues one or more command(s) for further execution.\n## Traits[\u00a7](https://docs.rs/crossterm/latest/crossterm/#traits)\n\n[Command](https://docs.rs/crossterm/latest/crossterm/trait.Command.html \"trait crossterm::Command\")\n    An interface for a command that performs an action on the terminal.\n\n[ExecutableCommand](https://docs.rs/crossterm/latest/crossterm/trait.ExecutableCommand.html \"trait crossterm::ExecutableCommand\")\n    An interface for types that can directly execute commands.\n\n[QueueableCommand](https://docs.rs/crossterm/latest/crossterm/trait.QueueableCommand.html \"trait crossterm::QueueableCommand\")\n    An interface for types that can queue commands for further execution.\n\n[SynchronizedUpdate](https://docs.rs/crossterm/latest/crossterm/trait.SynchronizedUpdate.html \"trait crossterm::SynchronizedUpdate\")\n    An interface for types that support synchronized updates.\n",
        "markdown_with_citations": "[](https://docs.rs/crossterm/latest/crossterm/all.html \"show sidebar\")\n# Crate crosstermCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\n## \u00a7\u27e84\u27e9Cross-platform Terminal Manipulation Library\nCrossterm is a pure-rust, terminal manipulation library that makes it possible to write cross-platform text-based interfaces.\nThis crate supports all UNIX and Windows terminals down to Windows 7 (not all terminals are tested see Tested Terminals\u27e85\u27e9 for more info).\n### \u00a7\u27e86\u27e9Command API\nThe command API makes the use of `crossterm` much easier and offers more control over when and how a command is executed. A command is just an action you can perform on the terminal e.g. cursor movement.\nThe command API offers:\n  * Better Performance.\n  * Complete control over when to flush.\n  * Complete control over where the ANSI escape commands are executed to.\n  * Way easier and nicer API.\n\n\nThere are two ways to use the API command:\n  * Functions can execute commands on types that implement Write. Functions are easier to use and debug. There is a disadvantage, and that is that there is a boilerplate code involved.\n  * Macros are generally seen as more difficult and aren\u2019t always well supported by editors but offer an API with less boilerplate code. If you are not afraid of macros, this is a recommendation.\n\n\nLinux and Windows 10 systems support ANSI escape codes. Those ANSI escape codes are strings or rather a byte sequence. When we `write` and `flush` those to the terminal we can perform some action. For older windows systems a WinAPI call is made.\n#### \u00a7\u27e87\u27e9Supported Commands\n  * Module `cursor`\u27e88\u27e9\n    * Visibility - `Show`\u27e89\u27e9, `Hide`\u27e810\u27e9\n    * Appearance - `EnableBlinking`\u27e811\u27e9, `DisableBlinking`\u27e812\u27e9, `SetCursorStyle`\u27e813\u27e9\n    * Position - `SavePosition`\u27e814\u27e9, `RestorePosition`\u27e815\u27e9, `MoveUp`\u27e816\u27e9, `MoveDown`\u27e817\u27e9, `MoveLeft`\u27e818\u27e9, `MoveRight`\u27e819\u27e9, `MoveTo`\u27e820\u27e9, `MoveToColumn`\u27e821\u27e9,`MoveToRow`\u27e822\u27e9, `MoveToNextLine`\u27e823\u27e9, `MoveToPreviousLine`\u27e824\u27e9\n  * Module `event`\u27e825\u27e9\n    * Keyboard events - `PushKeyboardEnhancementFlags`\u27e826\u27e9, `PopKeyboardEnhancementFlags`\u27e827\u27e9\n    * Mouse events - `EnableMouseCapture`\u27e828\u27e9, `DisableMouseCapture`\u27e829\u27e9\n  * Module `style`\u27e830\u27e9\n    * Colors - `SetForegroundColor`\u27e831\u27e9, `SetBackgroundColor`\u27e832\u27e9, `ResetColor`\u27e833\u27e9, `SetColors`\u27e834\u27e9\n    * Attributes - `SetAttribute`\u27e835\u27e9, `SetAttributes`\u27e836\u27e9, `PrintStyledContent`\u27e837\u27e9\n  * Module `terminal`\u27e838\u27e9\n    * Scrolling - `ScrollUp`\u27e839\u27e9, `ScrollDown`\u27e840\u27e9\n    * Miscellaneous - `Clear`\u27e841\u27e9, `SetSize`\u27e842\u27e9, `SetTitle`\u27e843\u27e9, `DisableLineWrap`\u27e844\u27e9, `EnableLineWrap`\u27e845\u27e9\n    * Alternate screen - `EnterAlternateScreen`\u27e846\u27e9, `LeaveAlternateScreen`\u27e847\u27e9\n  * Module `clipboard`\u27e848\u27e9 (requires `feature = \"osc52\"`\u27e849\u27e9) \n    * Clipboard - `CopyToClipboard`\u27e850\u27e9\n\n\n#### \u00a7\u27e851\u27e9Command Execution\nThere are two different ways to execute commands:\n  * Lazy Execution\u27e852\u27e9\n  * Direct Execution\u27e853\u27e9\n\n\n##### \u00a7\u27e852\u27e9Lazy Execution\nFlushing bytes to the terminal buffer is a heavy system call. If we perform a lot of actions with the terminal, we want to do this periodically - like with a TUI editor - so that we can flush more data to the terminal buffer at the same time.\nCrossterm offers the possibility to do this with `queue`. With `queue` you can queue commands, and when you call Write::flush\u27e854\u27e9 these commands will be executed.\nYou can pass a custom buffer implementing std::io::Write\u27e855\u27e9 to this `queue` operation. The commands will be executed on that buffer. The most common buffer is std::io::stdout\u27e856\u27e9 however, std::io::stderr\u27e857\u27e9 is used sometimes as well.\n###### \u00a7\u27e858\u27e9Examples\nA simple demonstration that shows the command API in action with cursor commands.\nFunctions:\n```\nuse std::io::{Write, stdout};\nuse crossterm::{QueueableCommand, cursor};\nlet mut stdout = stdout();\nstdout.queue(cursor::MoveTo(5,5));\n// some other code ...\nstdout.flush();\n```\n\nThe queue\u27e859\u27e9 function returns itself, therefore you can use this to queue another command. Like `stdout.queue(Goto(5,5)).queue(Clear(ClearType::All))`.\nMacros:\n```\nuse std::io::{Write, stdout};\nuse crossterm::{queue, QueueableCommand, cursor};\nlet mut stdout = stdout();\nqueue!(stdout, cursor::MoveTo(5, 5));\n// some other code ...\n// move operation is performed only if we flush the buffer.\nstdout.flush();\n```\n\nYou can pass more than one command into the queue\u27e860\u27e9 macro like `queue!(stdout, MoveTo(5, 5), Clear(ClearType::All))` and they will be executed in the given order from left to right.\n##### \u00a7\u27e853\u27e9Direct Execution\nFor many applications it is not at all important to be efficient with \u2018flush\u2019 operations. For this use case there is the `execute` operation. This operation executes the command immediately, and calls the `flush` under water.\nYou can pass a custom buffer implementing std::io::Write\u27e855\u27e9 to this `execute` operation. The commands will be executed on that buffer. The most common buffer is std::io::stdout\u27e856\u27e9 however, std::io::stderr\u27e857\u27e9 is used sometimes as well.\n###### \u00a7\u27e861\u27e9Examples\nFunctions:\n```\nuse std::io::{Write, stdout};\nuse crossterm::{ExecutableCommand, cursor};\nlet mut stdout = stdout();\nstdout.execute(cursor::MoveTo(5,5));\n```\n\nThe execute\u27e862\u27e9 function returns itself, therefore you can use this to queue another command. Like `stdout.execute(Goto(5,5))?.execute(Clear(ClearType::All))`.\nMacros:\n```\nuse std::io::{stdout, Write};\nuse crossterm::{execute, ExecutableCommand, cursor};\nlet mut stdout = stdout();\nexecute!(stdout, cursor::MoveTo(5, 5));\n```\n\nYou can pass more than one command into the execute\u27e863\u27e9 macro like `execute!(stdout, MoveTo(5, 5), Clear(ClearType::All))` and they will be executed in the given order from left to right.\n### \u00a7\u27e864\u27e9Examples\nPrint a rectangle colored with magenta and use both direct execution and lazy execution.\nFunctions:\n```\nuse std::io::{self, Write};\nuse crossterm::{\n  ExecutableCommand, QueueableCommand,\n  terminal, cursor, style::{self, Stylize}\n};\nfn main() -> io::Result<()> {\n let mut stdout = io::stdout();\n stdout.execute(terminal::Clear(terminal::ClearType::All))?;\n for y in 0..40 {\n  for x in 0..150 {\n   if (y == 0 || y == 40 - 1) || (x == 0 || x == 150 - 1) {\n    // in this loop we are more efficient by not flushing the buffer.\n    stdout\n     .queue(cursor::MoveTo(x,y))?\n     .queue(style::PrintStyledContent( \"\u2588\".magenta()))?;\n   }\n  }\n }\n stdout.flush()?;\n Ok(())\n}\n```\n\nMacros:\n```\nuse std::io::{self, Write};\nuse crossterm::{\n  execute, queue,\n  style::{self, Stylize}, cursor, terminal\n};\nfn main() -> io::Result<()> {\n let mut stdout = io::stdout();\n execute!(stdout, terminal::Clear(terminal::ClearType::All))?;\n for y in 0..40 {\n  for x in 0..150 {\n   if (y == 0 || y == 40 - 1) || (x == 0 || x == 150 - 1) {\n    // in this loop we are more efficient by not flushing the buffer.\n    queue!(stdout, cursor::MoveTo(x,y), style::PrintStyledContent( \"\u2588\".magenta()))?;\n   }\n  }\n }\n stdout.flush()?;\n Ok(())\n}\n```\n\n### \u00a7\u27e865\u27e9Feature Flags\n#### \u00a7\u27e866\u27e9Default features\n  * **`bracketed-paste`**_(enabled by default)_ \u2014 Enables triggering `Event::Paste`\u27e867\u27e9 when pasting text into the terminal.\n  * **`events`**_(enabled by default)_ \u2014 Enables reading input/events from the system using the `event`\u27e825\u27e9 module.\n  * **`windows`**_(enabled by default)_ \u2014 Enables windows specific crates.\n\n\n#### \u00a7\u27e849\u27e9Optional Features\n  * **`event-stream`**\u2014 Enables theEventStream\u27e868\u27e9 struct for async event reading.\n  * **`serde`**\u2014 Enables`serde`\u27e869\u27e9 for various types.\n  * **`use-dev-tty`**\u2014 Enables raw file descriptor polling / selecting instead of mio.\n  * **`derive-more`**_(enabled by default)_ \u2014 Enables `is_*` helper functions for event enums.\n  * **`osc52`**\u2014 Enables interacting with a host clipboard via`clipboard`\u27e848\u27e9\n\n\n## Modules\u00a7\u27e870\u27e9\n\nclipboard\u27e848\u27e9\n    A module for clipboard interaction\n\ncursor\u27e88\u27e9\n    A module to work with the terminal cursor\n\nevent\u27e825\u27e9\n    A module to read events.\n\nstyle\u27e830\u27e9\n    A module to apply attributes and colors on your text.\n\nterminal\u27e838\u27e9\n    A module to work with the terminal.\n\ntty\u27e871\u27e9\n    A module to query if the current instance is a tty. Making it a little more convenient and safe to query whether something is a terminal teletype or not. This module defines the IsTty trait and the is_tty method to return true if the item represents a terminal.\n## Macros\u00a7\u27e872\u27e9\n\nexecute\u27e863\u27e9\n    Executes one or more command(s).\n\nqueue\u27e860\u27e9\n    Queues one or more command(s) for further execution.\n## Traits\u00a7\u27e873\u27e9\n\nCommand\u27e874\u27e9\n    An interface for a command that performs an action on the terminal.\n\nExecutableCommand\u27e862\u27e9\n    An interface for types that can directly execute commands.\n\nQueueableCommand\u27e859\u27e9\n    An interface for types that can queue commands for further execution.\n\nSynchronizedUpdate\u27e875\u27e9\n    An interface for types that support synchronized updates.\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/crossterm/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/crossterm/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/crossterm/latest/src/crossterm/lib.rs.html#1-263: Source\n\u27e84\u27e9 https://docs.rs/crossterm/latest/crossterm/#cross-platform-terminal-manipulation-library: \u00a7\n\u27e85\u27e9 https://github.com/crossterm-rs/crossterm#tested-terminals: Tested Terminals\n\u27e86\u27e9 https://docs.rs/crossterm/latest/crossterm/#command-api: \u00a7\n\u27e87\u27e9 https://docs.rs/crossterm/latest/crossterm/#supported-commands: \u00a7\n\u27e88\u27e9 https://docs.rs/crossterm/latest/crossterm/cursor/index.html: `cursor`\n\u27e89\u27e9 https://docs.rs/crossterm/latest/crossterm/cursor/struct.Show.html: `Show`\n\u27e810\u27e9 https://docs.rs/crossterm/latest/crossterm/cursor/struct.Hide.html: `Hide`\n\u27e811\u27e9 https://docs.rs/crossterm/latest/crossterm/cursor/struct.EnableBlinking.html: `EnableBlinking`\n\u27e812\u27e9 https://docs.rs/crossterm/latest/crossterm/cursor/struct.DisableBlinking.html: `DisableBlinking`\n\u27e813\u27e9 https://docs.rs/crossterm/latest/crossterm/cursor/enum.SetCursorStyle.html: `SetCursorStyle`\n\u27e814\u27e9 https://docs.rs/crossterm/latest/crossterm/cursor/struct.SavePosition.html: `SavePosition`\n\u27e815\u27e9 https://docs.rs/crossterm/latest/crossterm/cursor/struct.RestorePosition.html: `RestorePosition`\n\u27e816\u27e9 https://docs.rs/crossterm/latest/crossterm/cursor/struct.MoveUp.html: `MoveUp`\n\u27e817\u27e9 https://docs.rs/crossterm/latest/crossterm/cursor/struct.MoveDown.html: `MoveDown`\n\u27e818\u27e9 https://docs.rs/crossterm/latest/crossterm/cursor/struct.MoveLeft.html: `MoveLeft`\n\u27e819\u27e9 https://docs.rs/crossterm/latest/crossterm/cursor/struct.MoveRight.html: `MoveRight`\n\u27e820\u27e9 https://docs.rs/crossterm/latest/crossterm/cursor/struct.MoveTo.html: `MoveTo`\n\u27e821\u27e9 https://docs.rs/crossterm/latest/crossterm/cursor/struct.MoveToColumn.html: `MoveToColumn`\n\u27e822\u27e9 https://docs.rs/crossterm/latest/crossterm/cursor/struct.MoveToRow.html: `MoveToRow`\n\u27e823\u27e9 https://docs.rs/crossterm/latest/crossterm/cursor/struct.MoveToNextLine.html: `MoveToNextLine`\n\u27e824\u27e9 https://docs.rs/crossterm/latest/crossterm/cursor/struct.MoveToPreviousLine.html: `MoveToPreviousLine`\n\u27e825\u27e9 https://docs.rs/crossterm/latest/crossterm/event/index.html: `event`\n\u27e826\u27e9 https://docs.rs/crossterm/latest/crossterm/event/struct.PushKeyboardEnhancementFlags.html: `PushKeyboardEnhancementFlags`\n\u27e827\u27e9 https://docs.rs/crossterm/latest/crossterm/event/struct.PopKeyboardEnhancementFlags.html: `PopKeyboardEnhancementFlags`\n\u27e828\u27e9 https://docs.rs/crossterm/latest/crossterm/event/struct.EnableMouseCapture.html: `EnableMouseCapture`\n\u27e829\u27e9 https://docs.rs/crossterm/latest/crossterm/event/struct.DisableMouseCapture.html: `DisableMouseCapture`\n\u27e830\u27e9 https://docs.rs/crossterm/latest/crossterm/style/index.html: `style`\n\u27e831\u27e9 https://docs.rs/crossterm/latest/crossterm/style/struct.SetForegroundColor.html: `SetForegroundColor`\n\u27e832\u27e9 https://docs.rs/crossterm/latest/crossterm/style/struct.SetBackgroundColor.html: `SetBackgroundColor`\n\u27e833\u27e9 https://docs.rs/crossterm/latest/crossterm/style/struct.ResetColor.html: `ResetColor`\n\u27e834\u27e9 https://docs.rs/crossterm/latest/crossterm/style/struct.SetColors.html: `SetColors`\n\u27e835\u27e9 https://docs.rs/crossterm/latest/crossterm/style/struct.SetAttribute.html: `SetAttribute`\n\u27e836\u27e9 https://docs.rs/crossterm/latest/crossterm/style/struct.SetAttributes.html: `SetAttributes`\n\u27e837\u27e9 https://docs.rs/crossterm/latest/crossterm/style/struct.PrintStyledContent.html: `PrintStyledContent`\n\u27e838\u27e9 https://docs.rs/crossterm/latest/crossterm/terminal/index.html: `terminal`\n\u27e839\u27e9 https://docs.rs/crossterm/latest/crossterm/terminal/struct.ScrollUp.html: `ScrollUp`\n\u27e840\u27e9 https://docs.rs/crossterm/latest/crossterm/terminal/struct.ScrollDown.html: `ScrollDown`\n\u27e841\u27e9 https://docs.rs/crossterm/latest/crossterm/terminal/struct.Clear.html: `Clear`\n\u27e842\u27e9 https://docs.rs/crossterm/latest/crossterm/terminal/struct.SetSize.html: `SetSize`\n\u27e843\u27e9 https://docs.rs/crossterm/latest/crossterm/terminal/struct.SetTitle.html: `SetTitle`\n\u27e844\u27e9 https://docs.rs/crossterm/latest/crossterm/terminal/struct.DisableLineWrap.html: `DisableLineWrap`\n\u27e845\u27e9 https://docs.rs/crossterm/latest/crossterm/terminal/struct.EnableLineWrap.html: `EnableLineWrap`\n\u27e846\u27e9 https://docs.rs/crossterm/latest/crossterm/terminal/struct.EnterAlternateScreen.html: `EnterAlternateScreen`\n\u27e847\u27e9 https://docs.rs/crossterm/latest/crossterm/terminal/struct.LeaveAlternateScreen.html: `LeaveAlternateScreen`\n\u27e848\u27e9 https://docs.rs/crossterm/latest/crossterm/clipboard/index.html: `clipboard`\n\u27e849\u27e9 https://docs.rs/crossterm/latest/crossterm/#optional-features: `feature = \"osc52\"`\n\u27e850\u27e9 https://docs.rs/crossterm/latest/crossterm/clipboard/struct.CopyToClipboard.html: `CopyToClipboard`\n\u27e851\u27e9 https://docs.rs/crossterm/latest/crossterm/#command-execution: \u00a7\n\u27e852\u27e9 https://docs.rs/crossterm/latest/crossterm/#lazy-execution: Lazy Execution\n\u27e853\u27e9 https://docs.rs/crossterm/latest/crossterm/#direct-execution: Direct Execution\n\u27e854\u27e9 https://doc.rust-lang.org/std/io/trait.Write.html#tymethod.flush: Write::flush\n\u27e855\u27e9 https://doc.rust-lang.org/std/io/trait.Write.html: std::io::Write\n\u27e856\u27e9 https://doc.rust-lang.org/std/io/fn.stdout.html: std::io::stdout\n\u27e857\u27e9 https://doc.rust-lang.org/std/io/fn.stderr.html: std::io::stderr\n\u27e858\u27e9 https://docs.rs/crossterm/latest/crossterm/#examples: \u00a7\n\u27e859\u27e9 https://docs.rs/crossterm/latest/crossterm/trait.QueueableCommand.html: queue\n\u27e860\u27e9 https://docs.rs/crossterm/latest/crossterm/macro.queue.html: queue\n\u27e861\u27e9 https://docs.rs/crossterm/latest/crossterm/#examples-1: \u00a7\n\u27e862\u27e9 https://docs.rs/crossterm/latest/crossterm/trait.ExecutableCommand.html: execute\n\u27e863\u27e9 https://docs.rs/crossterm/latest/crossterm/macro.execute.html: execute\n\u27e864\u27e9 https://docs.rs/crossterm/latest/crossterm/#examples-2: \u00a7\n\u27e865\u27e9 https://docs.rs/crossterm/latest/crossterm/#feature-flags: \u00a7\n\u27e866\u27e9 https://docs.rs/crossterm/latest/crossterm/#default-features: \u00a7\n\u27e867\u27e9 https://docs.rs/crossterm/latest/crossterm/event/enum.Event.html#variant.Paste: variant crossterm::event::Event::Paste - `Event::Paste`\n\u27e868\u27e9 https://docs.rs/crossterm/latest/crossterm/event/struct.EventStream.html: struct crossterm::event::EventStream - EventStream\n\u27e869\u27e9 https://docs.rs/serde/1.0.219/x86_64-unknown-linux-gnu/serde/index.html: mod serde - `serde`\n\u27e870\u27e9 https://docs.rs/crossterm/latest/crossterm/#modules: \u00a7\n\u27e871\u27e9 https://docs.rs/crossterm/latest/crossterm/tty/index.html: mod crossterm::tty - tty\n\u27e872\u27e9 https://docs.rs/crossterm/latest/crossterm/#macros: \u00a7\n\u27e873\u27e9 https://docs.rs/crossterm/latest/crossterm/#traits: \u00a7\n\u27e874\u27e9 https://docs.rs/crossterm/latest/crossterm/trait.Command.html: trait crossterm::Command - Command\n\u27e875\u27e9 https://docs.rs/crossterm/latest/crossterm/trait.SynchronizedUpdate.html: trait crossterm::SynchronizedUpdate - SynchronizedUpdate\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `crossterm` crate is a cross-platform terminal manipulation library written in pure Rust, supporting both UNIX and Windows systems (including Windows 7). It provides APIs for terminal control, including cursor movement, text styling, event handling, and clipboard interaction, with support for both lazy and direct command execution. Key features include efficient ANSI escape code handling, modular design (e.g., `cursor`, `event`, `style`, `terminal`), and optional features like async event streams and clipboard integration.",
    "feature_summary": null,
    "use_case": "Utilities",
    "score": 8.5,
    "factual_counterfactual": "### Pair 1: Command Execution\n\u2705 **Factual**: Crossterm supports two modes of command execution: lazy execution using `queue` for batching commands and direct execution using `execute` for immediate command execution.  \n\u274c **Counterfactual**: Crossterm only supports lazy execution and does not provide an option for direct execution of commands.  \n\n---\n\n### Pair 2: Platform Compatibility\n\u2705 **Factual**: Crossterm is a cross-platform terminal manipulation library that supports both UNIX and Windows systems, including older versions like Windows 7.  \n\u274c **Counterfactual**: Crossterm is only compatible with UNIX systems and does not support Windows terminals.  \n\n---\n\n### Pair 3: ANSI Escape Code Support\n\u2705 **Factual**: Crossterm uses ANSI escape codes for terminal manipulation on Linux and Windows 10 systems, while relying on WinAPI calls for older Windows systems.  \n\u274c **Counterfactual**: Crossterm exclusively uses WinAPI calls for terminal manipulation on all Windows systems, including Windows 10.",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}