{
    "name": "kanal",
    "version": "0.1.1",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/kanal/latest/kanal/all.html \"show sidebar\")\n# Crate kanalCopy item path\n[Settings](https://docs.rs/kanal/latest/settings.html)\n[Help](https://docs.rs/kanal/latest/help.html)\nSummary[Source](https://docs.rs/kanal/latest/src/kanal/lib.rs.html#1-1644)\nExpand description\n## [\u00a7](https://docs.rs/kanal/latest/kanal/#kanal)Kanal\n**The fast sync and async channel that Rust deserves!**\n[![Crates.io](https://img.shields.io/crates/v/kanal.svg?style=for-the-badge)](https://crates.io/crates/kanal) [![Documentation](https://img.shields.io/docsrs/kanal?style=for-the-badge)](https://docs.rs/kanal) [![MIT licensed](https://img.shields.io/badge/license-MIT-blue.svg?style=for-the-badge)](https://github.com/fereidani/kanal/blob/master/LICENSE)\n### [\u00a7](https://docs.rs/kanal/latest/kanal/#what-is-kanal)What is Kanal\nThe Kanal library is a Rust implementation of channels inspired by the CSP (Communicating Sequential Processes) model. It aims to help programmers create efficient concurrent programs by providing multi-producer and multi-consumer channels with advanced features for fast communication. The library focuses on unifying message passing between synchronous and asynchronous parts of Rust code, offering a combination of synchronous and asynchronous APIs while maintaining high performance.\n### [\u00a7](https://docs.rs/kanal/latest/kanal/#why-kanal-is-faster)Why Kanal is faster?\n  1. Kanal employs a highly optimized composite technique for the transfer of objects. When the data size is less than or equal to the pointer size, it utilizes serialization, encoding the data as the pointer address. Conversely, when the data size exceeds the pointer size, the protocol employs a strategy similar to that utilized by the Golang programming language, utilizing direct memory access to copy objects from the sender\u2019s stack or write directly to the receiver\u2019s stack. This composite method not only eliminates unnecessary pointer access but also eliminates heap allocations for bounded(0) channels.\n  2. Kanal utilizes a specially tuned mutex for its channel locking mechanism, made possible by the predictable internal lock time of the channel. That said it\u2019s possible to use Rust standard mutex with the `std-mutex` feature and Kanal will perform better than competitors with that feature too.\n  3. Utilizing Rust high-performance compiler and powerful LLVM backend with highly optimized memory access and deeply thought algorithms.\n\n\n### [\u00a7](https://docs.rs/kanal/latest/kanal/#usage)Usage\nTo use Kanal in your Rust project, add the following line to your `Cargo.toml` file:\n```\n[dependencies]\nkanal = \"0.1\"\n```\n\nSync channel example:\n[\u24d8](https://docs.rs/kanal/latest/kanal/ \"This example is not tested\")```\n// Initialize a bounded sync channel with a capacity for 8 messages\nlet (sender, receiver) = kanal::bounded(8);\nlet s = sender.clone();\nstd::thread::spawn(move || {\n  s.send(\"hello\")?;\n  anyhow::Ok(())\n});\n// Receive an example message in another thread\nlet msg = receiver.recv()?;\nprintln!(\"I got msg: {}\", msg);\n\n// Convert and use channel in async context to communicate between sync and async\ntokio::spawn(async move {\n  // Borrow the channel as an async channel and use it in an async context ( or convert it to async using to_async() )\n  sender.as_async().send(\"hello\").await?;\n  anyhow::Ok(())\n});\n```\n\nAsync channel example:\n[\u24d8](https://docs.rs/kanal/latest/kanal/ \"This example is not tested\")```\n// Initialize a bounded channel with a capacity for 8 messages\nlet (sender, receiver) = kanal::bounded_async(8);\nsender.send(\"hello\").await?;\nsender.send(\"hello\").await?;\n// Clone receiver and convert it to a sync receiver\nlet receiver_sync = receiver.clone().to_sync();\ntokio::spawn(async move {\n  let msg = receiver.recv().await?;\n  println!(\"I got msg: {}\", msg);\n  anyhow::Ok(())\n});\n// Spawn a thread and use receiver in sync context\nstd::thread::spawn(move || {\n  let msg = receiver_sync.recv()?;\n  println!(\"I got msg in sync context: {}\", msg);\n  anyhow::Ok(())\n});\n```\n\n### [\u00a7](https://docs.rs/kanal/latest/kanal/#why-use-kanal)Why use Kanal?\n  * Kanal offers fast and efficient communication capabilities.\n  * Kanal simplifies communication in and between synchronous and asynchronous contexts, thanks to its flexible API like `as_sync` and `as_async`.\n  * Kanal provides a clean and intuitive API, making it easier to work with compared to other Rust libraries.\n  * Similar to Golang, Kanal allows you to close channels using the `Close` function, enabling you to broadcast a close signal from any channel instance and close the channel for both senders and receivers.\n  * Kanal includes high-performance MPMC (Multiple Producers Multiple Consumers) and SPSC (Single Producer Single Consumer) channels in a single package.\n\n\n#### [\u00a7](https://docs.rs/kanal/latest/kanal/#benchmark-results)Benchmark Results\nResults are based on how many messages can be passed in each scenario per second.\n##### [\u00a7](https://docs.rs/kanal/latest/kanal/#test-types)Test types:\n  1. Seq is sequentially writing and reading to a channel in the same thread.\n  2. SPSC is one receiver, and one sender and passing messages between them.\n  3. MPSC is multiple sender threads with only one receiver.\n  4. MPMC is multiple senders and multiple receivers communicating through the same channel.\n\n\n##### [\u00a7](https://docs.rs/kanal/latest/kanal/#message-types)Message types:\n  1. `usize` tests are transferring messages of size hardware pointer.\n  2. `big` tests are transferring messages of 8x the size of the hardware pointer.\n\n\nN/A means that the test subject is unable to perform the test due to its limitations, Some of the test subjects don\u2019t have implementation for size 0 channels, MPMC or unbounded channels.\nMachine: `AMD Ryzen 9 9950X 16-Core Processor` Rust: `rustc 1.85.1 (4eb161250 2025-03-15)` Go: `go version go1.24.1 linux/amd64` OS (`uname -a`): `Linux 6.11.0-19-generic #19~24.04.1-Ubuntu SMP PREEMPT_DYNAMIC Mon Feb 17 11:51:52 UTC 2 x86_64` Date: Mar 19, 2025\n[Benchmark codes](https://github.com/fereidani/rust-channel-benchmarks)\n![Benchmarks](https://i.imgur.com/VPwyam0.png)\n##### [\u00a7](https://docs.rs/kanal/latest/kanal/#why-does-async-outperform-sync-in-some-tests)Why does async outperform sync in some tests?\nIn certain tests, asynchronous communication may exhibit superior performance compared to synchronous communication. This can be attributed to the context-switching performance of libraries such as tokio, which, similar to Golang, utilize context-switching within the same thread to switch to the next coroutine when a message is ready on a channel. This approach is more efficient than communicating between separate threads. This same principle applies to asynchronous network applications, which generally exhibit better performance compared to synchronous implementations. As the channel size increases, one may observe improved performance in synchronous benchmarks, as the sending threads are able to push data directly to the channel queue without requiring awaiting blocking/suspending signals from receiving threads.\n## Structs[\u00a7](https://docs.rs/kanal/latest/kanal/#structs)\n\n[AsyncReceiver](https://docs.rs/kanal/latest/kanal/struct.AsyncReceiver.html \"struct kanal::AsyncReceiver\")\n    [`AsyncReceiver`](https://docs.rs/kanal/latest/kanal/struct.AsyncReceiver.html \"struct kanal::AsyncReceiver\") is receiving side of the channel in async mode. Receivers can be cloned and produce receivers to operate in both sync and async modes.\n\n[AsyncSender](https://docs.rs/kanal/latest/kanal/struct.AsyncSender.html \"struct kanal::AsyncSender\")\n    Sending side of the channel with async API. It\u2019s possible to convert it to sync [`Sender`](https://docs.rs/kanal/latest/kanal/struct.Sender.html \"struct kanal::Sender\") with `as_sync`, `to_sync` or `clone_sync` based on software requirement.\n\n[CloseError](https://docs.rs/kanal/latest/kanal/struct.CloseError.html \"struct kanal::CloseError\")\n    Error type for closing a channel when channel is already closed\n\n[ReceiveFuture](https://docs.rs/kanal/latest/kanal/struct.ReceiveFuture.html \"struct kanal::ReceiveFuture\")\n    ReceiveFuture is a future for receiving an object from a channel asynchronously. It must be polled to complete the receive operation.\n\n[ReceiveStream](https://docs.rs/kanal/latest/kanal/struct.ReceiveStream.html \"struct kanal::ReceiveStream\")\n    ReceiveStream is a stream for receiving objects from a channel asynchronously.\n\n[Receiver](https://docs.rs/kanal/latest/kanal/struct.Receiver.html \"struct kanal::Receiver\")\n    Receiving side of the channel in sync mode. Receivers can be cloned and produce receivers to operate in both sync and async modes.\n\n[SendFuture](https://docs.rs/kanal/latest/kanal/struct.SendFuture.html \"struct kanal::SendFuture\")\n    SendFuture is a future for sending an object to a channel asynchronously. It must be polled to complete the send operation.\n\n[Sender](https://docs.rs/kanal/latest/kanal/struct.Sender.html \"struct kanal::Sender\")\n    Sending side of the channel with sync API. It\u2019s possible to convert it to async [`AsyncSender`](https://docs.rs/kanal/latest/kanal/struct.AsyncSender.html \"struct kanal::AsyncSender\") with `as_async`, `to_async` or `clone_async` based on software requirement.\n## Enums[\u00a7](https://docs.rs/kanal/latest/kanal/#enums)\n\n[ReceiveError](https://docs.rs/kanal/latest/kanal/enum.ReceiveError.html \"enum kanal::ReceiveError\")\n    Error type for channel receive operations without timeout\n\n[ReceiveErrorTimeout](https://docs.rs/kanal/latest/kanal/enum.ReceiveErrorTimeout.html \"enum kanal::ReceiveErrorTimeout\")\n    Error type for channel receive operations with timeout\n\n[SendError](https://docs.rs/kanal/latest/kanal/enum.SendError.html \"enum kanal::SendError\")\n    Error type for channel send operations without timeout\n\n[SendErrorTimeout](https://docs.rs/kanal/latest/kanal/enum.SendErrorTimeout.html \"enum kanal::SendErrorTimeout\")\n    Error type for channel send operations with timeout\n## Functions[\u00a7](https://docs.rs/kanal/latest/kanal/#functions)\n\n[bounded](https://docs.rs/kanal/latest/kanal/fn.bounded.html \"fn kanal::bounded\")\n    Creates a new sync bounded channel with the requested buffer size, and returns [`Sender`](https://docs.rs/kanal/latest/kanal/struct.Sender.html \"struct kanal::Sender\") and [`Receiver`](https://docs.rs/kanal/latest/kanal/struct.Receiver.html \"struct kanal::Receiver\") of the channel for type T, you can get access to async API of [`AsyncSender`](https://docs.rs/kanal/latest/kanal/struct.AsyncSender.html \"struct kanal::AsyncSender\") and [`AsyncReceiver`](https://docs.rs/kanal/latest/kanal/struct.AsyncReceiver.html \"struct kanal::AsyncReceiver\") with `to_sync`, `as_async` or `clone_sync` based on your requirements, by calling them on sender or receiver.\n\n[bounded_async](https://docs.rs/kanal/latest/kanal/fn.bounded_async.html \"fn kanal::bounded_async\")\n    Creates a new async bounded channel with the requested buffer size, and returns [`AsyncSender`](https://docs.rs/kanal/latest/kanal/struct.AsyncSender.html \"struct kanal::AsyncSender\") and [`AsyncReceiver`](https://docs.rs/kanal/latest/kanal/struct.AsyncReceiver.html \"struct kanal::AsyncReceiver\") of the channel for type T, you can get access to sync API of [`Sender`](https://docs.rs/kanal/latest/kanal/struct.Sender.html \"struct kanal::Sender\") and [`Receiver`](https://docs.rs/kanal/latest/kanal/struct.Receiver.html \"struct kanal::Receiver\") with `to_sync`, `as_async` or `clone_sync` based on your requirements, by calling them on async sender or receiver.\n\n[unbounded](https://docs.rs/kanal/latest/kanal/fn.unbounded.html \"fn kanal::unbounded\")\n    Creates a new sync unbounded channel, and returns [`Sender`](https://docs.rs/kanal/latest/kanal/struct.Sender.html \"struct kanal::Sender\") and [`Receiver`](https://docs.rs/kanal/latest/kanal/struct.Receiver.html \"struct kanal::Receiver\") of the channel for type T, you can get access to async API of [`AsyncSender`](https://docs.rs/kanal/latest/kanal/struct.AsyncSender.html \"struct kanal::AsyncSender\") and [`AsyncReceiver`](https://docs.rs/kanal/latest/kanal/struct.AsyncReceiver.html \"struct kanal::AsyncReceiver\") with `to_sync`, `as_async` or `clone_sync` based on your requirements, by calling them on sender or receiver.\n\n[unbounded_async](https://docs.rs/kanal/latest/kanal/fn.unbounded_async.html \"fn kanal::unbounded_async\")\n    Creates a new async unbounded channel, and returns [`AsyncSender`](https://docs.rs/kanal/latest/kanal/struct.AsyncSender.html \"struct kanal::AsyncSender\") and [`AsyncReceiver`](https://docs.rs/kanal/latest/kanal/struct.AsyncReceiver.html \"struct kanal::AsyncReceiver\") of the channel for type T, you can get access to sync API of [`Sender`](https://docs.rs/kanal/latest/kanal/struct.Sender.html \"struct kanal::Sender\") and [`Receiver`](https://docs.rs/kanal/latest/kanal/struct.Receiver.html \"struct kanal::Receiver\") with `to_sync`, `as_async` or `clone_sync` based on your requirements, by calling them on async sender or receiver.\n",
        "markdown_with_citations": "[](https://docs.rs/kanal/latest/kanal/all.html \"show sidebar\")\n# Crate kanalCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\n## \u00a7\u27e84\u27e9Kanal\n**The fast sync and async channel that Rust deserves!**\n![Crates.io\u27e85\u27e9](https://crates.io/crates/kanal) ![Documentation\u27e86\u27e9](https://docs.rs/kanal) ![MIT licensed\u27e87\u27e9](https://github.com/fereidani/kanal/blob/master/LICENSE)\n### \u00a7\u27e88\u27e9What is Kanal\nThe Kanal library is a Rust implementation of channels inspired by the CSP (Communicating Sequential Processes) model. It aims to help programmers create efficient concurrent programs by providing multi-producer and multi-consumer channels with advanced features for fast communication. The library focuses on unifying message passing between synchronous and asynchronous parts of Rust code, offering a combination of synchronous and asynchronous APIs while maintaining high performance.\n### \u00a7\u27e89\u27e9Why Kanal is faster?\n  1. Kanal employs a highly optimized composite technique for the transfer of objects. When the data size is less than or equal to the pointer size, it utilizes serialization, encoding the data as the pointer address. Conversely, when the data size exceeds the pointer size, the protocol employs a strategy similar to that utilized by the Golang programming language, utilizing direct memory access to copy objects from the sender\u2019s stack or write directly to the receiver\u2019s stack. This composite method not only eliminates unnecessary pointer access but also eliminates heap allocations for bounded(0) channels.\n  2. Kanal utilizes a specially tuned mutex for its channel locking mechanism, made possible by the predictable internal lock time of the channel. That said it\u2019s possible to use Rust standard mutex with the `std-mutex` feature and Kanal will perform better than competitors with that feature too.\n  3. Utilizing Rust high-performance compiler and powerful LLVM backend with highly optimized memory access and deeply thought algorithms.\n\n\n### \u00a7\u27e810\u27e9Usage\nTo use Kanal in your Rust project, add the following line to your `Cargo.toml` file:\n```\n[dependencies]\nkanal = \"0.1\"\n```\n\nSync channel example:\n\u24d8\u27e811\u27e9```\n// Initialize a bounded sync channel with a capacity for 8 messages\nlet (sender, receiver) = kanal::bounded(8);\nlet s = sender.clone();\nstd::thread::spawn(move || {\n  s.send(\"hello\")?;\n  anyhow::Ok(())\n});\n// Receive an example message in another thread\nlet msg = receiver.recv()?;\nprintln!(\"I got msg: {}\", msg);\n\n// Convert and use channel in async context to communicate between sync and async\ntokio::spawn(async move {\n  // Borrow the channel as an async channel and use it in an async context ( or convert it to async using to_async() )\n  sender.as_async().send(\"hello\").await?;\n  anyhow::Ok(())\n});\n```\n\nAsync channel example:\n\u24d8\u27e811\u27e9```\n// Initialize a bounded channel with a capacity for 8 messages\nlet (sender, receiver) = kanal::bounded_async(8);\nsender.send(\"hello\").await?;\nsender.send(\"hello\").await?;\n// Clone receiver and convert it to a sync receiver\nlet receiver_sync = receiver.clone().to_sync();\ntokio::spawn(async move {\n  let msg = receiver.recv().await?;\n  println!(\"I got msg: {}\", msg);\n  anyhow::Ok(())\n});\n// Spawn a thread and use receiver in sync context\nstd::thread::spawn(move || {\n  let msg = receiver_sync.recv()?;\n  println!(\"I got msg in sync context: {}\", msg);\n  anyhow::Ok(())\n});\n```\n\n### \u00a7\u27e812\u27e9Why use Kanal?\n  * Kanal offers fast and efficient communication capabilities.\n  * Kanal simplifies communication in and between synchronous and asynchronous contexts, thanks to its flexible API like `as_sync` and `as_async`.\n  * Kanal provides a clean and intuitive API, making it easier to work with compared to other Rust libraries.\n  * Similar to Golang, Kanal allows you to close channels using the `Close` function, enabling you to broadcast a close signal from any channel instance and close the channel for both senders and receivers.\n  * Kanal includes high-performance MPMC (Multiple Producers Multiple Consumers) and SPSC (Single Producer Single Consumer) channels in a single package.\n\n\n#### \u00a7\u27e813\u27e9Benchmark Results\nResults are based on how many messages can be passed in each scenario per second.\n##### \u00a7\u27e814\u27e9Test types:\n  1. Seq is sequentially writing and reading to a channel in the same thread.\n  2. SPSC is one receiver, and one sender and passing messages between them.\n  3. MPSC is multiple sender threads with only one receiver.\n  4. MPMC is multiple senders and multiple receivers communicating through the same channel.\n\n\n##### \u00a7\u27e815\u27e9Message types:\n  1. `usize` tests are transferring messages of size hardware pointer.\n  2. `big` tests are transferring messages of 8x the size of the hardware pointer.\n\n\nN/A means that the test subject is unable to perform the test due to its limitations, Some of the test subjects don\u2019t have implementation for size 0 channels, MPMC or unbounded channels.\nMachine: `AMD Ryzen 9 9950X 16-Core Processor` Rust: `rustc 1.85.1 (4eb161250 2025-03-15)` Go: `go version go1.24.1 linux/amd64` OS (`uname -a`): `Linux 6.11.0-19-generic #19~24.04.1-Ubuntu SMP PREEMPT_DYNAMIC Mon Feb 17 11:51:52 UTC 2 x86_64` Date: Mar 19, 2025\nBenchmark codes\u27e816\u27e9\n![Benchmarks\u27e817\u27e9]\n##### \u00a7\u27e818\u27e9Why does async outperform sync in some tests?\nIn certain tests, asynchronous communication may exhibit superior performance compared to synchronous communication. This can be attributed to the context-switching performance of libraries such as tokio, which, similar to Golang, utilize context-switching within the same thread to switch to the next coroutine when a message is ready on a channel. This approach is more efficient than communicating between separate threads. This same principle applies to asynchronous network applications, which generally exhibit better performance compared to synchronous implementations. As the channel size increases, one may observe improved performance in synchronous benchmarks, as the sending threads are able to push data directly to the channel queue without requiring awaiting blocking/suspending signals from receiving threads.\n## Structs\u00a7\u27e819\u27e9\n\nAsyncReceiver\u27e820\u27e9\n    `AsyncReceiver`\u27e820\u27e9 is receiving side of the channel in async mode. Receivers can be cloned and produce receivers to operate in both sync and async modes.\n\nAsyncSender\u27e821\u27e9\n    Sending side of the channel with async API. It\u2019s possible to convert it to sync `Sender`\u27e822\u27e9 with `as_sync`, `to_sync` or `clone_sync` based on software requirement.\n\nCloseError\u27e823\u27e9\n    Error type for closing a channel when channel is already closed\n\nReceiveFuture\u27e824\u27e9\n    ReceiveFuture is a future for receiving an object from a channel asynchronously. It must be polled to complete the receive operation.\n\nReceiveStream\u27e825\u27e9\n    ReceiveStream is a stream for receiving objects from a channel asynchronously.\n\nReceiver\u27e826\u27e9\n    Receiving side of the channel in sync mode. Receivers can be cloned and produce receivers to operate in both sync and async modes.\n\nSendFuture\u27e827\u27e9\n    SendFuture is a future for sending an object to a channel asynchronously. It must be polled to complete the send operation.\n\nSender\u27e822\u27e9\n    Sending side of the channel with sync API. It\u2019s possible to convert it to async `AsyncSender`\u27e821\u27e9 with `as_async`, `to_async` or `clone_async` based on software requirement.\n## Enums\u00a7\u27e828\u27e9\n\nReceiveError\u27e829\u27e9\n    Error type for channel receive operations without timeout\n\nReceiveErrorTimeout\u27e830\u27e9\n    Error type for channel receive operations with timeout\n\nSendError\u27e831\u27e9\n    Error type for channel send operations without timeout\n\nSendErrorTimeout\u27e832\u27e9\n    Error type for channel send operations with timeout\n## Functions\u00a7\u27e833\u27e9\n\nbounded\u27e834\u27e9\n    Creates a new sync bounded channel with the requested buffer size, and returns `Sender`\u27e822\u27e9 and `Receiver`\u27e826\u27e9 of the channel for type T, you can get access to async API of `AsyncSender`\u27e821\u27e9 and `AsyncReceiver`\u27e820\u27e9 with `to_sync`, `as_async` or `clone_sync` based on your requirements, by calling them on sender or receiver.\n\nbounded_async\u27e835\u27e9\n    Creates a new async bounded channel with the requested buffer size, and returns `AsyncSender`\u27e821\u27e9 and `AsyncReceiver`\u27e820\u27e9 of the channel for type T, you can get access to sync API of `Sender`\u27e822\u27e9 and `Receiver`\u27e826\u27e9 with `to_sync`, `as_async` or `clone_sync` based on your requirements, by calling them on async sender or receiver.\n\nunbounded\u27e836\u27e9\n    Creates a new sync unbounded channel, and returns `Sender`\u27e822\u27e9 and `Receiver`\u27e826\u27e9 of the channel for type T, you can get access to async API of `AsyncSender`\u27e821\u27e9 and `AsyncReceiver`\u27e820\u27e9 with `to_sync`, `as_async` or `clone_sync` based on your requirements, by calling them on sender or receiver.\n\nunbounded_async\u27e837\u27e9\n    Creates a new async unbounded channel, and returns `AsyncSender`\u27e821\u27e9 and `AsyncReceiver`\u27e820\u27e9 of the channel for type T, you can get access to sync API of `Sender`\u27e822\u27e9 and `Receiver`\u27e826\u27e9 with `to_sync`, `as_async` or `clone_sync` based on your requirements, by calling them on async sender or receiver.\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/kanal/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/kanal/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/kanal/latest/src/kanal/lib.rs.html#1-1644: Source\n\u27e84\u27e9 https://docs.rs/kanal/latest/kanal/#kanal: \u00a7\n\u27e85\u27e9 https://img.shields.io/crates/v/kanal.svg?style=for-the-badge: ![Crates.io\n\u27e86\u27e9 https://img.shields.io/docsrs/kanal?style=for-the-badge: ![Documentation\n\u27e87\u27e9 https://img.shields.io/badge/license-MIT-blue.svg?style=for-the-badge: ![MIT licensed\n\u27e88\u27e9 https://docs.rs/kanal/latest/kanal/#what-is-kanal: \u00a7\n\u27e89\u27e9 https://docs.rs/kanal/latest/kanal/#why-kanal-is-faster: \u00a7\n\u27e810\u27e9 https://docs.rs/kanal/latest/kanal/#usage: \u00a7\n\u27e811\u27e9 https://docs.rs/kanal/latest/kanal/: This example is not tested - \u24d8\n\u27e812\u27e9 https://docs.rs/kanal/latest/kanal/#why-use-kanal: \u00a7\n\u27e813\u27e9 https://docs.rs/kanal/latest/kanal/#benchmark-results: \u00a7\n\u27e814\u27e9 https://docs.rs/kanal/latest/kanal/#test-types: \u00a7\n\u27e815\u27e9 https://docs.rs/kanal/latest/kanal/#message-types: \u00a7\n\u27e816\u27e9 https://github.com/fereidani/rust-channel-benchmarks: Benchmark codes\n\u27e817\u27e9 https://i.imgur.com/VPwyam0.png: Benchmarks\n\u27e818\u27e9 https://docs.rs/kanal/latest/kanal/#why-does-async-outperform-sync-in-some-tests: \u00a7\n\u27e819\u27e9 https://docs.rs/kanal/latest/kanal/#structs: \u00a7\n\u27e820\u27e9 https://docs.rs/kanal/latest/kanal/struct.AsyncReceiver.html: struct kanal::AsyncReceiver - AsyncReceiver\n\u27e821\u27e9 https://docs.rs/kanal/latest/kanal/struct.AsyncSender.html: struct kanal::AsyncSender - AsyncSender\n\u27e822\u27e9 https://docs.rs/kanal/latest/kanal/struct.Sender.html: struct kanal::Sender - `Sender`\n\u27e823\u27e9 https://docs.rs/kanal/latest/kanal/struct.CloseError.html: struct kanal::CloseError - CloseError\n\u27e824\u27e9 https://docs.rs/kanal/latest/kanal/struct.ReceiveFuture.html: struct kanal::ReceiveFuture - ReceiveFuture\n\u27e825\u27e9 https://docs.rs/kanal/latest/kanal/struct.ReceiveStream.html: struct kanal::ReceiveStream - ReceiveStream\n\u27e826\u27e9 https://docs.rs/kanal/latest/kanal/struct.Receiver.html: struct kanal::Receiver - Receiver\n\u27e827\u27e9 https://docs.rs/kanal/latest/kanal/struct.SendFuture.html: struct kanal::SendFuture - SendFuture\n\u27e828\u27e9 https://docs.rs/kanal/latest/kanal/#enums: \u00a7\n\u27e829\u27e9 https://docs.rs/kanal/latest/kanal/enum.ReceiveError.html: enum kanal::ReceiveError - ReceiveError\n\u27e830\u27e9 https://docs.rs/kanal/latest/kanal/enum.ReceiveErrorTimeout.html: enum kanal::ReceiveErrorTimeout - ReceiveErrorTimeout\n\u27e831\u27e9 https://docs.rs/kanal/latest/kanal/enum.SendError.html: enum kanal::SendError - SendError\n\u27e832\u27e9 https://docs.rs/kanal/latest/kanal/enum.SendErrorTimeout.html: enum kanal::SendErrorTimeout - SendErrorTimeout\n\u27e833\u27e9 https://docs.rs/kanal/latest/kanal/#functions: \u00a7\n\u27e834\u27e9 https://docs.rs/kanal/latest/kanal/fn.bounded.html: fn kanal::bounded - bounded\n\u27e835\u27e9 https://docs.rs/kanal/latest/kanal/fn.bounded_async.html: fn kanal::bounded_async - bounded_async\n\u27e836\u27e9 https://docs.rs/kanal/latest/kanal/fn.unbounded.html: fn kanal::unbounded - unbounded\n\u27e837\u27e9 https://docs.rs/kanal/latest/kanal/fn.unbounded_async.html: fn kanal::unbounded_async - unbounded_async\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `kanal` crate provides high-performance synchronous and asynchronous channels for Rust, inspired by the CSP model. It supports multi-producer/multi-consumer (MPMC) and single-producer/single-consumer (SPSC) communication, with APIs that seamlessly unify sync and async contexts. Key features include optimized memory handling, low-latency locking mechanisms, and flexible conversion between sync and async modes (`as_sync`, `as_async`).",
    "feature_summary": null,
    "use_case": "Networking",
    "score": 6.0,
    "factual_counterfactual": "### Pair 1: Channel Conversion\n\u2705 Factual: Kanal allows seamless conversion between synchronous and asynchronous channels using methods like `as_sync`, `to_sync`, and `clone_sync` for `AsyncSender` and `AsyncReceiver`.\n\u274c Counterfactual: Kanal requires separate channel types for synchronous and asynchronous communication, and does not support conversion between them.\n\n---\n\n### Pair 2: Performance Optimization\n\u2705 Factual: Kanal employs a composite technique for transferring objects, utilizing direct memory access for large data sizes and pointer encoding for smaller data sizes, reducing heap allocations for bounded(0) channels.\n\u274c Counterfactual: Kanal exclusively relies on heap allocations for all channel operations, regardless of the data size or channel type.\n\n---\n\n### Pair 3: Benchmark Results\n\u2705 Factual: Kanal benchmarks show that asynchronous communication can outperform synchronous communication due to efficient context-switching within the same thread, especially with libraries like tokio.\n\u274c Counterfactual: Kanal benchmarks indicate that synchronous communication always outperforms asynchronous communication, regardless of the scenario or channel size.",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}