{
    "name": "rumqttc",
    "version": "0.24.0",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/rumqttc/latest/rumqttc/all.html \"show sidebar\")\n# Crate rumqttcCopy item path\n[Settings](https://docs.rs/rumqttc/latest/settings.html)\n[Help](https://docs.rs/rumqttc/latest/help.html)\nSummary[Source](https://docs.rs/rumqttc/latest/src/rumqttc/lib.rs.html#1-1016)\nExpand description\nA pure rust MQTT client which strives to be robust, efficient and easy to use. This library is backed by an async (tokio) eventloop which handles all the robustness and and efficiency parts of MQTT but naturally fits into both sync and async worlds as we\u2019ll see\nLet\u2019s jump into examples right away\n### [\u00a7](https://docs.rs/rumqttc/latest/rumqttc/#a-simple-synchronous-publish-and-subscribe)A simple synchronous publish and subscribe\n```\nuse rumqttc::{MqttOptions, Client, QoS};\nuse std::time::Duration;\nuse std::thread;\nlet mut mqttoptions = MqttOptions::new(\"rumqtt-sync\", \"test.mosquitto.org\", 1883);\nmqttoptions.set_keep_alive(Duration::from_secs(5));\nlet (mut client, mut connection) = Client::new(mqttoptions, 10);\nclient.subscribe(\"hello/rumqtt\", QoS::AtMostOnce).unwrap();\nthread::spawn(move || for i in 0..10 {\n  client.publish(\"hello/rumqtt\", QoS::AtLeastOnce, false, vec![i; i as usize]).unwrap();\n  thread::sleep(Duration::from_millis(100));\n});\n// Iterate to poll the eventloop for connection progress\nfor (i, notification) in connection.iter().enumerate() {\n  println!(\"Notification = {:?}\", notification);\n}\n```\n\n### [\u00a7](https://docs.rs/rumqttc/latest/rumqttc/#a-simple-asynchronous-publish-and-subscribe)A simple asynchronous publish and subscribe\n```\nuse rumqttc::{MqttOptions, AsyncClient, QoS};\nuse tokio::{task, time};\nuse std::time::Duration;\nuse std::error::Error;\nlet mut mqttoptions = MqttOptions::new(\"rumqtt-async\", \"test.mosquitto.org\", 1883);\nmqttoptions.set_keep_alive(Duration::from_secs(5));\nlet (mut client, mut eventloop) = AsyncClient::new(mqttoptions, 10);\nclient.subscribe(\"hello/rumqtt\", QoS::AtMostOnce).await.unwrap();\ntask::spawn(async move {\n  for i in 0..10 {\n    client.publish(\"hello/rumqtt\", QoS::AtLeastOnce, false, vec![i; i as usize]).await.unwrap();\n    time::sleep(Duration::from_millis(100)).await;\n  }\n});\nloop {\n  let notification = eventloop.poll().await.unwrap();\n  println!(\"Received = {:?}\", notification);\n}\n```\n\nQuick overview of features\n  * Eventloop orchestrates outgoing/incoming packets concurrently and handles the state\n  * Pings the broker when necessary and detects client side half open connections as well\n  * Throttling of outgoing packets (todo)\n  * Queue size based flow control on outgoing packets\n  * Automatic reconnections by just continuing the `eventloop.poll()`/`connection.iter()` loop\n  * Natural backpressure to client APIs during bad network\n\n\nIn short, everything necessary to maintain a robust connection\nSince the eventloop is externally polled (with `iter()/poll()` in a loop) out side the library and `Eventloop` is accessible, users can\n  * Distribute incoming messages based on topics\n  * Stop it when required\n  * Access internal state for use cases like graceful shutdown or to modify options before reconnection\n\n\n### [\u00a7](https://docs.rs/rumqttc/latest/rumqttc/#important-notes)Important notes\n  * Looping on `connection.iter()`/`eventloop.poll()` is necessary to run the event loop and make progress. It yields incoming and outgoing activity notifications which allows customization as you see fit.\n  * Blocking inside the `connection.iter()`/`eventloop.poll()` loop will block connection progress.\n\n\n### [\u00a7](https://docs.rs/rumqttc/latest/rumqttc/#faq)FAQ\n**Connecting to a broker using raw ip doesn\u2019t work**\nYou cannot create a TLS connection to a bare IP address with a self-signed certificate. This is a [limitation of rustls](https://github.com/ctz/rustls/issues/184). One workaround, which only works under *nix/BSD-like systems, is to add an entry to wherever your DNS resolver looks (e.g. `/etc/hosts`) for the bare IP address and use that name in your code.\n## Re-exports[\u00a7](https://docs.rs/rumqttc/latest/rumqttc/#reexports)\n\n`pub use tokio_rustls[](https://docs.rs/tokio-rustls/0.25.0/x86_64-unknown-linux-gnu/tokio_rustls/index.html \"mod tokio_rustls\");`\n\n\n`pub use mqttbytes::v4[](https://docs.rs/rumqttc/latest/rumqttc/mqttbytes/v4/index.html \"mod rumqttc::mqttbytes::v4\")::*;`\n\n\n`pub use mqttbytes[](https://docs.rs/rumqttc/latest/rumqttc/mqttbytes/index.html \"mod rumqttc::mqttbytes\")::*;`\n\n## Modules[\u00a7](https://docs.rs/rumqttc/latest/rumqttc/#modules)\n\n[mqttbytes](https://docs.rs/rumqttc/latest/rumqttc/mqttbytes/index.html \"mod rumqttc::mqttbytes\")\n    mqttbytes\n\n[v5](https://docs.rs/rumqttc/latest/rumqttc/v5/index.html \"mod rumqttc::v5\")\n\n## Structs[\u00a7](https://docs.rs/rumqttc/latest/rumqttc/#structs)\n\n[AsyncClient](https://docs.rs/rumqttc/latest/rumqttc/struct.AsyncClient.html \"struct rumqttc::AsyncClient\")\n    An asynchronous client, communicates with MQTT `EventLoop`.\n\n[Client](https://docs.rs/rumqttc/latest/rumqttc/struct.Client.html \"struct rumqttc::Client\")\n    A synchronous client, communicates with MQTT `EventLoop`.\n\n[Connection](https://docs.rs/rumqttc/latest/rumqttc/struct.Connection.html \"struct rumqttc::Connection\")\n    MQTT connection. Maintains all the necessary state\n\n[EventLoop](https://docs.rs/rumqttc/latest/rumqttc/struct.EventLoop.html \"struct rumqttc::EventLoop\")\n    Eventloop with all the state of a connection\n\n[Iter](https://docs.rs/rumqttc/latest/rumqttc/struct.Iter.html \"struct rumqttc::Iter\")\n    Iterator which polls the `EventLoop` for connection progress\n\n[MqttOptions](https://docs.rs/rumqttc/latest/rumqttc/struct.MqttOptions.html \"struct rumqttc::MqttOptions\")\n    Options to configure the behaviour of MQTT connection\n\n[MqttState](https://docs.rs/rumqttc/latest/rumqttc/struct.MqttState.html \"struct rumqttc::MqttState\")\n    State of the mqtt connection.\n\n[NetworkOptions](https://docs.rs/rumqttc/latest/rumqttc/struct.NetworkOptions.html \"struct rumqttc::NetworkOptions\")\n    Provides a way to configure low level network connection configurations\n\n[Proxy](https://docs.rs/rumqttc/latest/rumqttc/struct.Proxy.html \"struct rumqttc::Proxy\")\n\n\n[RecvError](https://docs.rs/rumqttc/latest/rumqttc/struct.RecvError.html \"struct rumqttc::RecvError\")\n    Error type returned by [`Connection::recv`](https://docs.rs/rumqttc/latest/rumqttc/struct.Connection.html#method.recv \"method rumqttc::Connection::recv\")\n## Enums[\u00a7](https://docs.rs/rumqttc/latest/rumqttc/#enums)\n\n[ClientError](https://docs.rs/rumqttc/latest/rumqttc/enum.ClientError.html \"enum rumqttc::ClientError\")\n    Client Error\n\n[ConnectionError](https://docs.rs/rumqttc/latest/rumqttc/enum.ConnectionError.html \"enum rumqttc::ConnectionError\")\n    Critical errors during eventloop polling\n\n[Event](https://docs.rs/rumqttc/latest/rumqttc/enum.Event.html \"enum rumqttc::Event\")\n    Events which can be yielded by the event loop\n\n[OptionError](https://docs.rs/rumqttc/latest/rumqttc/enum.OptionError.html \"enum rumqttc::OptionError\")\n\n\n[Outgoing](https://docs.rs/rumqttc/latest/rumqttc/enum.Outgoing.html \"enum rumqttc::Outgoing\")\n    Current outgoing activity on the eventloop\n\n[ProxyAuth](https://docs.rs/rumqttc/latest/rumqttc/enum.ProxyAuth.html \"enum rumqttc::ProxyAuth\")\n\n\n[ProxyType](https://docs.rs/rumqttc/latest/rumqttc/enum.ProxyType.html \"enum rumqttc::ProxyType\")\n\n\n[RecvTimeoutError](https://docs.rs/rumqttc/latest/rumqttc/enum.RecvTimeoutError.html \"enum rumqttc::RecvTimeoutError\")\n    Error type returned by [`Connection::recv_timeout`](https://docs.rs/rumqttc/latest/rumqttc/struct.Connection.html#method.recv_timeout \"method rumqttc::Connection::recv_timeout\")\n\n[Request](https://docs.rs/rumqttc/latest/rumqttc/enum.Request.html \"enum rumqttc::Request\")\n    Requests by the client to mqtt event loop. Request are handled one by one.\n\n[StateError](https://docs.rs/rumqttc/latest/rumqttc/enum.StateError.html \"enum rumqttc::StateError\")\n    Errors during state handling\n\n[TlsConfiguration](https://docs.rs/rumqttc/latest/rumqttc/enum.TlsConfiguration.html \"enum rumqttc::TlsConfiguration\")\n    TLS configuration method\n\n[TlsError](https://docs.rs/rumqttc/latest/rumqttc/enum.TlsError.html \"enum rumqttc::TlsError\")\n\n\n[Transport](https://docs.rs/rumqttc/latest/rumqttc/enum.Transport.html \"enum rumqttc::Transport\")\n    Transport methods. Defaults to TCP.\n\n[TryRecvError](https://docs.rs/rumqttc/latest/rumqttc/enum.TryRecvError.html \"enum rumqttc::TryRecvError\")\n    Error type returned by [`Connection::try_recv`](https://docs.rs/rumqttc/latest/rumqttc/struct.Connection.html#method.try_recv \"method rumqttc::Connection::try_recv\")\n## Type Aliases[\u00a7](https://docs.rs/rumqttc/latest/rumqttc/#types)\n\n[Incoming](https://docs.rs/rumqttc/latest/rumqttc/type.Incoming.html \"type rumqttc::Incoming\")\n\n",
        "markdown_with_citations": "[](https://docs.rs/rumqttc/latest/rumqttc/all.html \"show sidebar\")\n# Crate rumqttcCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nA pure rust MQTT client which strives to be robust, efficient and easy to use. This library is backed by an async (tokio) eventloop which handles all the robustness and and efficiency parts of MQTT but naturally fits into both sync and async worlds as we\u2019ll see\nLet\u2019s jump into examples right away\n### \u00a7\u27e84\u27e9A simple synchronous publish and subscribe\n```\nuse rumqttc::{MqttOptions, Client, QoS};\nuse std::time::Duration;\nuse std::thread;\nlet mut mqttoptions = MqttOptions::new(\"rumqtt-sync\", \"test.mosquitto.org\", 1883);\nmqttoptions.set_keep_alive(Duration::from_secs(5));\nlet (mut client, mut connection) = Client::new(mqttoptions, 10);\nclient.subscribe(\"hello/rumqtt\", QoS::AtMostOnce).unwrap();\nthread::spawn(move || for i in 0..10 {\n  client.publish(\"hello/rumqtt\", QoS::AtLeastOnce, false, vec![i; i as usize]).unwrap();\n  thread::sleep(Duration::from_millis(100));\n});\n// Iterate to poll the eventloop for connection progress\nfor (i, notification) in connection.iter().enumerate() {\n  println!(\"Notification = {:?}\", notification);\n}\n```\n\n### \u00a7\u27e85\u27e9A simple asynchronous publish and subscribe\n```\nuse rumqttc::{MqttOptions, AsyncClient, QoS};\nuse tokio::{task, time};\nuse std::time::Duration;\nuse std::error::Error;\nlet mut mqttoptions = MqttOptions::new(\"rumqtt-async\", \"test.mosquitto.org\", 1883);\nmqttoptions.set_keep_alive(Duration::from_secs(5));\nlet (mut client, mut eventloop) = AsyncClient::new(mqttoptions, 10);\nclient.subscribe(\"hello/rumqtt\", QoS::AtMostOnce).await.unwrap();\ntask::spawn(async move {\n  for i in 0..10 {\n    client.publish(\"hello/rumqtt\", QoS::AtLeastOnce, false, vec![i; i as usize]).await.unwrap();\n    time::sleep(Duration::from_millis(100)).await;\n  }\n});\nloop {\n  let notification = eventloop.poll().await.unwrap();\n  println!(\"Received = {:?}\", notification);\n}\n```\n\nQuick overview of features\n  * Eventloop orchestrates outgoing/incoming packets concurrently and handles the state\n  * Pings the broker when necessary and detects client side half open connections as well\n  * Throttling of outgoing packets (todo)\n  * Queue size based flow control on outgoing packets\n  * Automatic reconnections by just continuing the `eventloop.poll()`/`connection.iter()` loop\n  * Natural backpressure to client APIs during bad network\n\n\nIn short, everything necessary to maintain a robust connection\nSince the eventloop is externally polled (with `iter()/poll()` in a loop) out side the library and `Eventloop` is accessible, users can\n  * Distribute incoming messages based on topics\n  * Stop it when required\n  * Access internal state for use cases like graceful shutdown or to modify options before reconnection\n\n\n### \u00a7\u27e86\u27e9Important notes\n  * Looping on `connection.iter()`/`eventloop.poll()` is necessary to run the event loop and make progress. It yields incoming and outgoing activity notifications which allows customization as you see fit.\n  * Blocking inside the `connection.iter()`/`eventloop.poll()` loop will block connection progress.\n\n\n### \u00a7\u27e87\u27e9FAQ\n**Connecting to a broker using raw ip doesn\u2019t work**\nYou cannot create a TLS connection to a bare IP address with a self-signed certificate. This is a limitation of rustls\u27e88\u27e9. One workaround, which only works under *nix/BSD-like systems, is to add an entry to wherever your DNS resolver looks (e.g. `/etc/hosts`) for the bare IP address and use that name in your code.\n## Re-exports\u00a7\u27e89\u27e9\n\n`pub use tokio_rustls[](https://docs.rs/tokio-rustls/0.25.0/x86_64-unknown-linux-gnu/tokio_rustls/index.html \"mod tokio_rustls\");`\n\n\n`pub use mqttbytes::v4[](https://docs.rs/rumqttc/latest/rumqttc/mqttbytes/v4/index.html \"mod rumqttc::mqttbytes::v4\")::*;`\n\n\n`pub use mqttbytes[](https://docs.rs/rumqttc/latest/rumqttc/mqttbytes/index.html \"mod rumqttc::mqttbytes\")::*;`\n\n## Modules\u00a7\u27e810\u27e9\n\nmqttbytes\u27e811\u27e9\n    mqttbytes\n\nv5\u27e812\u27e9\n\n## Structs\u00a7\u27e813\u27e9\n\nAsyncClient\u27e814\u27e9\n    An asynchronous client, communicates with MQTT `EventLoop`.\n\nClient\u27e815\u27e9\n    A synchronous client, communicates with MQTT `EventLoop`.\n\nConnection\u27e816\u27e9\n    MQTT connection. Maintains all the necessary state\n\nEventLoop\u27e817\u27e9\n    Eventloop with all the state of a connection\n\nIter\u27e818\u27e9\n    Iterator which polls the `EventLoop` for connection progress\n\nMqttOptions\u27e819\u27e9\n    Options to configure the behaviour of MQTT connection\n\nMqttState\u27e820\u27e9\n    State of the mqtt connection.\n\nNetworkOptions\u27e821\u27e9\n    Provides a way to configure low level network connection configurations\n\nProxy\u27e822\u27e9\n\n\nRecvError\u27e823\u27e9\n    Error type returned by `Connection::recv`\u27e824\u27e9\n## Enums\u00a7\u27e825\u27e9\n\nClientError\u27e826\u27e9\n    Client Error\n\nConnectionError\u27e827\u27e9\n    Critical errors during eventloop polling\n\nEvent\u27e828\u27e9\n    Events which can be yielded by the event loop\n\nOptionError\u27e829\u27e9\n\n\nOutgoing\u27e830\u27e9\n    Current outgoing activity on the eventloop\n\nProxyAuth\u27e831\u27e9\n\n\nProxyType\u27e832\u27e9\n\n\nRecvTimeoutError\u27e833\u27e9\n    Error type returned by `Connection::recv_timeout`\u27e834\u27e9\n\nRequest\u27e835\u27e9\n    Requests by the client to mqtt event loop. Request are handled one by one.\n\nStateError\u27e836\u27e9\n    Errors during state handling\n\nTlsConfiguration\u27e837\u27e9\n    TLS configuration method\n\nTlsError\u27e838\u27e9\n\n\nTransport\u27e839\u27e9\n    Transport methods. Defaults to TCP.\n\nTryRecvError\u27e840\u27e9\n    Error type returned by `Connection::try_recv`\u27e841\u27e9\n## Type Aliases\u00a7\u27e842\u27e9\n\nIncoming\u27e843\u27e9\n\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/rumqttc/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/rumqttc/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/rumqttc/latest/src/rumqttc/lib.rs.html#1-1016: Source\n\u27e84\u27e9 https://docs.rs/rumqttc/latest/rumqttc/#a-simple-synchronous-publish-and-subscribe: \u00a7\n\u27e85\u27e9 https://docs.rs/rumqttc/latest/rumqttc/#a-simple-asynchronous-publish-and-subscribe: \u00a7\n\u27e86\u27e9 https://docs.rs/rumqttc/latest/rumqttc/#important-notes: \u00a7\n\u27e87\u27e9 https://docs.rs/rumqttc/latest/rumqttc/#faq: \u00a7\n\u27e88\u27e9 https://github.com/ctz/rustls/issues/184: limitation of rustls\n\u27e89\u27e9 https://docs.rs/rumqttc/latest/rumqttc/#reexports: \u00a7\n\u27e810\u27e9 https://docs.rs/rumqttc/latest/rumqttc/#modules: \u00a7\n\u27e811\u27e9 https://docs.rs/rumqttc/latest/rumqttc/mqttbytes/index.html: mod rumqttc::mqttbytes - mqttbytes\n\u27e812\u27e9 https://docs.rs/rumqttc/latest/rumqttc/v5/index.html: mod rumqttc::v5 - v5\n\u27e813\u27e9 https://docs.rs/rumqttc/latest/rumqttc/#structs: \u00a7\n\u27e814\u27e9 https://docs.rs/rumqttc/latest/rumqttc/struct.AsyncClient.html: struct rumqttc::AsyncClient - AsyncClient\n\u27e815\u27e9 https://docs.rs/rumqttc/latest/rumqttc/struct.Client.html: struct rumqttc::Client - Client\n\u27e816\u27e9 https://docs.rs/rumqttc/latest/rumqttc/struct.Connection.html: struct rumqttc::Connection - Connection\n\u27e817\u27e9 https://docs.rs/rumqttc/latest/rumqttc/struct.EventLoop.html: struct rumqttc::EventLoop - EventLoop\n\u27e818\u27e9 https://docs.rs/rumqttc/latest/rumqttc/struct.Iter.html: struct rumqttc::Iter - Iter\n\u27e819\u27e9 https://docs.rs/rumqttc/latest/rumqttc/struct.MqttOptions.html: struct rumqttc::MqttOptions - MqttOptions\n\u27e820\u27e9 https://docs.rs/rumqttc/latest/rumqttc/struct.MqttState.html: struct rumqttc::MqttState - MqttState\n\u27e821\u27e9 https://docs.rs/rumqttc/latest/rumqttc/struct.NetworkOptions.html: struct rumqttc::NetworkOptions - NetworkOptions\n\u27e822\u27e9 https://docs.rs/rumqttc/latest/rumqttc/struct.Proxy.html: struct rumqttc::Proxy - Proxy\n\u27e823\u27e9 https://docs.rs/rumqttc/latest/rumqttc/struct.RecvError.html: struct rumqttc::RecvError - RecvError\n\u27e824\u27e9 https://docs.rs/rumqttc/latest/rumqttc/struct.Connection.html#method.recv: method rumqttc::Connection::recv - `Connection::recv`\n\u27e825\u27e9 https://docs.rs/rumqttc/latest/rumqttc/#enums: \u00a7\n\u27e826\u27e9 https://docs.rs/rumqttc/latest/rumqttc/enum.ClientError.html: enum rumqttc::ClientError - ClientError\n\u27e827\u27e9 https://docs.rs/rumqttc/latest/rumqttc/enum.ConnectionError.html: enum rumqttc::ConnectionError - ConnectionError\n\u27e828\u27e9 https://docs.rs/rumqttc/latest/rumqttc/enum.Event.html: enum rumqttc::Event - Event\n\u27e829\u27e9 https://docs.rs/rumqttc/latest/rumqttc/enum.OptionError.html: enum rumqttc::OptionError - OptionError\n\u27e830\u27e9 https://docs.rs/rumqttc/latest/rumqttc/enum.Outgoing.html: enum rumqttc::Outgoing - Outgoing\n\u27e831\u27e9 https://docs.rs/rumqttc/latest/rumqttc/enum.ProxyAuth.html: enum rumqttc::ProxyAuth - ProxyAuth\n\u27e832\u27e9 https://docs.rs/rumqttc/latest/rumqttc/enum.ProxyType.html: enum rumqttc::ProxyType - ProxyType\n\u27e833\u27e9 https://docs.rs/rumqttc/latest/rumqttc/enum.RecvTimeoutError.html: enum rumqttc::RecvTimeoutError - RecvTimeoutError\n\u27e834\u27e9 https://docs.rs/rumqttc/latest/rumqttc/struct.Connection.html#method.recv_timeout: method rumqttc::Connection::recv_timeout - `Connection::recv_timeout`\n\u27e835\u27e9 https://docs.rs/rumqttc/latest/rumqttc/enum.Request.html: enum rumqttc::Request - Request\n\u27e836\u27e9 https://docs.rs/rumqttc/latest/rumqttc/enum.StateError.html: enum rumqttc::StateError - StateError\n\u27e837\u27e9 https://docs.rs/rumqttc/latest/rumqttc/enum.TlsConfiguration.html: enum rumqttc::TlsConfiguration - TlsConfiguration\n\u27e838\u27e9 https://docs.rs/rumqttc/latest/rumqttc/enum.TlsError.html: enum rumqttc::TlsError - TlsError\n\u27e839\u27e9 https://docs.rs/rumqttc/latest/rumqttc/enum.Transport.html: enum rumqttc::Transport - Transport\n\u27e840\u27e9 https://docs.rs/rumqttc/latest/rumqttc/enum.TryRecvError.html: enum rumqttc::TryRecvError - TryRecvError\n\u27e841\u27e9 https://docs.rs/rumqttc/latest/rumqttc/struct.Connection.html#method.try_recv: method rumqttc::Connection::try_recv - `Connection::try_recv`\n\u27e842\u27e9 https://docs.rs/rumqttc/latest/rumqttc/#types: \u00a7\n\u27e843\u27e9 https://docs.rs/rumqttc/latest/rumqttc/type.Incoming.html: type rumqttc::Incoming - Incoming\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `rumqttc` crate is a robust and efficient MQTT client implemented in pure Rust, designed to work seamlessly in both synchronous and asynchronous environments using a Tokio-based event loop. Key features include automatic reconnections, queue-based flow control, natural backpressure handling, and the ability to distribute incoming messages, access internal connection state, and perform graceful shutdowns. It supports customizable connection behavior and ensures reliable communication with MQTT brokers.",
    "feature_summary": null,
    "use_case": "Networking",
    "score": 6.0,
    "factual_counterfactual": "### Pair 1: Eventloop Behavior  \n\u2705 **Factual:** The `rumqttc` crate's event loop is externally polled using `connection.iter()` for synchronous clients or `eventloop.poll()` for asynchronous clients, allowing users to control connection progress and customize behavior.  \n\u274c **Counterfactual:** The `rumqttc` crate automatically handles the event loop internally without requiring users to explicitly poll it, ensuring connection progress without user intervention.  \n\n---\n\n### Pair 2: TLS Support  \n\u2705 **Factual:** The `rumqttc` crate supports TLS connections but cannot establish TLS connections to bare IP addresses with self-signed certificates due to limitations in the `rustls` library.  \n\u274c **Counterfactual:** The `rumqttc` crate can establish TLS connections to bare IP addresses with self-signed certificates by default without requiring additional DNS configuration.  \n\n---\n\n### Pair 3: Backpressure Handling  \n\u2705 **Factual:** The `rumqttc` crate provides natural backpressure to client APIs during poor network conditions, ensuring that outgoing packets are throttled based on queue size.  \n\u274c **Counterfactual:** The `rumqttc` crate does not implement any backpressure mechanisms, allowing outgoing packets to be sent regardless of network conditions or queue size.",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}