{
    "name": "anyhow",
    "version": "1.0.98",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/anyhow/latest/anyhow/all.html \"show sidebar\")\n# Crate anyhowCopy item path\n[Settings](https://docs.rs/anyhow/latest/settings.html)\n[Help](https://docs.rs/anyhow/latest/help.html)\nSummary[Source](https://docs.rs/anyhow/latest/src/anyhow/lib.rs.html#1-735)\nExpand description\n[![github](https://img.shields.io/badge/github-8da0cb?style=for-the-badge&labelColor=555555&logo=github)](https://github.com/dtolnay/anyhow) [![crates-io](https://img.shields.io/badge/crates.io-fc8d62?style=for-the-badge&labelColor=555555&logo=rust)](https://crates.io/crates/anyhow) [![docs-rs](https://img.shields.io/badge/docs.rs-66c2a5?style=for-the-badge&labelColor=555555&logo=docs.rs)](https://docs.rs/anyhow)\nThis library provides [`anyhow::Error`](https://docs.rs/anyhow/latest/anyhow/struct.Error.html \"struct anyhow::Error\"), a trait object based error type for easy idiomatic error handling in Rust applications.\n## [\u00a7](https://docs.rs/anyhow/latest/anyhow/#details)Details\n  * Use `Result<T, anyhow::Error>`, or equivalently `anyhow::Result<T>`, as the return type of any fallible function.\nWithin the function, use `?` to easily propagate any error that implements the [`std::error::Error`](https://doc.rust-lang.org/core/error/trait.Error.html \"trait core::error::Error\") trait.\n```\nuse anyhow::Result;\nfn get_cluster_info() -> Result<ClusterMap> {\n  let config = std::fs::read_to_string(\"cluster.json\")?;\n  let map: ClusterMap = serde_json::from_str(&config)?;\n  Ok(map)\n}\n```\n\n  * Attach context to help the person troubleshooting the error understand where things went wrong. A low-level error like \u201cNo such file or directory\u201d can be annoying to debug without more context about what higher level step the application was in the middle of.\n```\nuse anyhow::{Context, Result};\nfn main() -> Result<()> {\n  ...\n  it.detach().context(\"Failed to detach the important thing\")?;\n  let content = std::fs::read(path)\n    .with_context(|| format!(\"Failed to read instrs from {}\", path))?;\n  ...\n}\n```\n\n```\nError: Failed to read instrs from ./path/to/instrs.json\nCaused by:\n  No such file or directory (os error 2)\n```\n\n  * Downcasting is supported and can be by value, by shared reference, or by mutable reference as needed.\n```\n// If the error was caused by redaction, then return a\n// tombstone instead of the content.\nmatch root_cause.downcast_ref::<DataStoreError>() {\n  Some(DataStoreError::Censored(_)) => Ok(Poll::Ready(REDACTED_CONTENT)),\n  None => Err(error),\n}\n```\n\n  * If using Rust \u2265 1.65, a backtrace is captured and printed with the error if the underlying error type does not already provide its own. In order to see backtraces, they must be enabled through the environment variables described in [`std::backtrace`](https://doc.rust-lang.org/std/backtrace/index.html#environment-variables \"mod std::backtrace\"):\n    * If you want panics and errors to both have backtraces, set `RUST_BACKTRACE=1`;\n    * If you want only errors to have backtraces, set `RUST_LIB_BACKTRACE=1`;\n    * If you want only panics to have backtraces, set `RUST_BACKTRACE=1` and `RUST_LIB_BACKTRACE=0`.\n  * Anyhow works with any error type that has an impl of `std::error::Error`, including ones defined in your crate. We do not bundle a `derive(Error)` macro but you can write the impls yourself or use a standalone macro like [thiserror](https://github.com/dtolnay/thiserror).\n```\nuse thiserror::Error;\n#[derive(Error, Debug)]\npub enum FormatError {\n  #[error(\"Invalid header (expected {expected:?}, got {found:?})\")]\n  InvalidHeader {\n    expected: String,\n    found: String,\n  },\n  #[error(\"Missing attribute: {0}\")]\n  MissingAttribute(String),\n}\n```\n\n  * One-off error messages can be constructed using the `anyhow!` macro, which supports string interpolation and produces an `anyhow::Error`.\n```\nreturn Err(anyhow!(\"Missing attribute: {}\", missing));\n```\n\nA `bail!` macro is provided as a shorthand for the same early return.\n```\nbail!(\"Missing attribute: {}\", missing);\n```\n\n\n\n## [\u00a7](https://docs.rs/anyhow/latest/anyhow/#no-std-support)No-std support\nIn no_std mode, almost all of the same API is available and works the same way. To depend on Anyhow in no_std mode, disable our default enabled \u201cstd\u201d feature in Cargo.toml. A global allocator is required.\n```\n[dependencies]\nanyhow = { version = \"1.0\", default-features = false }\n```\n\nWith versions of Rust older than 1.81, no_std mode may require an additional `.map_err(Error::msg)` when working with a non-Anyhow error type inside a function that returns Anyhow\u2019s error type, as the trait that `?`-based error conversions are defined by is only available in std in those old versions.\n## Re-exports[\u00a7](https://docs.rs/anyhow/latest/anyhow/#reexports)\n\n`pub use anyhow[](https://docs.rs/anyhow/latest/anyhow/macro.anyhow.html \"macro anyhow::anyhow\") as format_err;`\n\n## Macros[\u00a7](https://docs.rs/anyhow/latest/anyhow/#macros)\n\n[anyhow](https://docs.rs/anyhow/latest/anyhow/macro.anyhow.html \"macro anyhow::anyhow\")\n    Construct an ad-hoc error from a string or existing non-`anyhow` error value.\n\n[bail](https://docs.rs/anyhow/latest/anyhow/macro.bail.html \"macro anyhow::bail\")\n    Return early with an error.\n\n[ensure](https://docs.rs/anyhow/latest/anyhow/macro.ensure.html \"macro anyhow::ensure\")\n    Return early with an error if a condition is not satisfied.\n## Structs[\u00a7](https://docs.rs/anyhow/latest/anyhow/#structs)\n\n[Chain](https://docs.rs/anyhow/latest/anyhow/struct.Chain.html \"struct anyhow::Chain\")\n    Iterator of a chain of source errors.\n\n[Error](https://docs.rs/anyhow/latest/anyhow/struct.Error.html \"struct anyhow::Error\")\n    The `Error` type, a wrapper around a dynamic error type.\n## Traits[\u00a7](https://docs.rs/anyhow/latest/anyhow/#traits)\n\n[Context](https://docs.rs/anyhow/latest/anyhow/trait.Context.html \"trait anyhow::Context\")\n    Provides the `context` method for `Result`.\n## Functions[\u00a7](https://docs.rs/anyhow/latest/anyhow/#functions)\n\n[Ok](https://docs.rs/anyhow/latest/anyhow/fn.Ok.html \"fn anyhow::Ok\")\n    Equivalent to `Ok::<_, anyhow::Error>(value)`.\n## Type Aliases[\u00a7](https://docs.rs/anyhow/latest/anyhow/#types)\n\n[Result](https://docs.rs/anyhow/latest/anyhow/type.Result.html \"type anyhow::Result\")\n    `Result<T, Error>`\n",
        "markdown_with_citations": "[](https://docs.rs/anyhow/latest/anyhow/all.html \"show sidebar\")\n# Crate anyhowCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\n![github\u27e84\u27e9](https://github.com/dtolnay/anyhow) ![crates-io\u27e85\u27e9](https://crates.io/crates/anyhow) ![docs-rs\u27e86\u27e9](https://docs.rs/anyhow)\nThis library provides `anyhow::Error`\u27e87\u27e9, a trait object based error type for easy idiomatic error handling in Rust applications.\n## \u00a7\u27e88\u27e9Details\n  * Use `Result<T, anyhow::Error>`, or equivalently `anyhow::Result<T>`, as the return type of any fallible function.\nWithin the function, use `?` to easily propagate any error that implements the `std::error::Error`\u27e89\u27e9 trait.\n```\nuse anyhow::Result;\nfn get_cluster_info() -> Result<ClusterMap> {\n  let config = std::fs::read_to_string(\"cluster.json\")?;\n  let map: ClusterMap = serde_json::from_str(&config)?;\n  Ok(map)\n}\n```\n\n  * Attach context to help the person troubleshooting the error understand where things went wrong. A low-level error like \u201cNo such file or directory\u201d can be annoying to debug without more context about what higher level step the application was in the middle of.\n```\nuse anyhow::{Context, Result};\nfn main() -> Result<()> {\n  ...\n  it.detach().context(\"Failed to detach the important thing\")?;\n  let content = std::fs::read(path)\n    .with_context(|| format!(\"Failed to read instrs from {}\", path))?;\n  ...\n}\n```\n\n```\nError: Failed to read instrs from ./path/to/instrs.json\nCaused by:\n  No such file or directory (os error 2)\n```\n\n  * Downcasting is supported and can be by value, by shared reference, or by mutable reference as needed.\n```\n// If the error was caused by redaction, then return a\n// tombstone instead of the content.\nmatch root_cause.downcast_ref::<DataStoreError>() {\n  Some(DataStoreError::Censored(_)) => Ok(Poll::Ready(REDACTED_CONTENT)),\n  None => Err(error),\n}\n```\n\n  * If using Rust \u2265 1.65, a backtrace is captured and printed with the error if the underlying error type does not already provide its own. In order to see backtraces, they must be enabled through the environment variables described in `std::backtrace`\u27e810\u27e9:\n    * If you want panics and errors to both have backtraces, set `RUST_BACKTRACE=1`;\n    * If you want only errors to have backtraces, set `RUST_LIB_BACKTRACE=1`;\n    * If you want only panics to have backtraces, set `RUST_BACKTRACE=1` and `RUST_LIB_BACKTRACE=0`.\n  * Anyhow works with any error type that has an impl of `std::error::Error`, including ones defined in your crate. We do not bundle a `derive(Error)` macro but you can write the impls yourself or use a standalone macro like thiserror\u27e811\u27e9.\n```\nuse thiserror::Error;\n#[derive(Error, Debug)]\npub enum FormatError {\n  #[error(\"Invalid header (expected {expected:?}, got {found:?})\")]\n  InvalidHeader {\n    expected: String,\n    found: String,\n  },\n  #[error(\"Missing attribute: {0}\")]\n  MissingAttribute(String),\n}\n```\n\n  * One-off error messages can be constructed using the `anyhow!` macro, which supports string interpolation and produces an `anyhow::Error`.\n```\nreturn Err(anyhow!(\"Missing attribute: {}\", missing));\n```\n\nA `bail!` macro is provided as a shorthand for the same early return.\n```\nbail!(\"Missing attribute: {}\", missing);\n```\n\n\n\n## \u00a7\u27e812\u27e9No-std support\nIn no_std mode, almost all of the same API is available and works the same way. To depend on Anyhow in no_std mode, disable our default enabled \u201cstd\u201d feature in Cargo.toml. A global allocator is required.\n```\n[dependencies]\nanyhow = { version = \"1.0\", default-features = false }\n```\n\nWith versions of Rust older than 1.81, no_std mode may require an additional `.map_err(Error::msg)` when working with a non-Anyhow error type inside a function that returns Anyhow\u2019s error type, as the trait that `?`-based error conversions are defined by is only available in std in those old versions.\n## Re-exports\u00a7\u27e813\u27e9\n\n`pub use anyhow[](https://docs.rs/anyhow/latest/anyhow/macro.anyhow.html \"macro anyhow::anyhow\") as format_err;`\n\n## Macros\u00a7\u27e814\u27e9\n\nanyhow\u27e815\u27e9\n    Construct an ad-hoc error from a string or existing non-`anyhow` error value.\n\nbail\u27e816\u27e9\n    Return early with an error.\n\nensure\u27e817\u27e9\n    Return early with an error if a condition is not satisfied.\n## Structs\u00a7\u27e818\u27e9\n\nChain\u27e819\u27e9\n    Iterator of a chain of source errors.\n\nError\u27e87\u27e9\n    The `Error` type, a wrapper around a dynamic error type.\n## Traits\u00a7\u27e820\u27e9\n\nContext\u27e821\u27e9\n    Provides the `context` method for `Result`.\n## Functions\u00a7\u27e822\u27e9\n\nOk\u27e823\u27e9\n    Equivalent to `Ok::<_, anyhow::Error>(value)`.\n## Type Aliases\u00a7\u27e824\u27e9\n\nResult\u27e825\u27e9\n    `Result<T, Error>`\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/anyhow/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/anyhow/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/anyhow/latest/src/anyhow/lib.rs.html#1-735: Source\n\u27e84\u27e9 https://img.shields.io/badge/github-8da0cb?style=for-the-badge&labelColor=555555&logo=github: ![github\n\u27e85\u27e9 https://img.shields.io/badge/crates.io-fc8d62?style=for-the-badge&labelColor=555555&logo=rust: ![crates-io\n\u27e86\u27e9 https://img.shields.io/badge/docs.rs-66c2a5?style=for-the-badge&labelColor=555555&logo=docs.rs: ![docs-rs\n\u27e87\u27e9 https://docs.rs/anyhow/latest/anyhow/struct.Error.html: struct anyhow::Error - `anyhow::Error`\n\u27e88\u27e9 https://docs.rs/anyhow/latest/anyhow/#details: \u00a7\n\u27e89\u27e9 https://doc.rust-lang.org/core/error/trait.Error.html: trait core::error::Error - `std::error::Error`\n\u27e810\u27e9 https://doc.rust-lang.org/std/backtrace/index.html#environment-variables: mod std::backtrace - `std::backtrace`\n\u27e811\u27e9 https://github.com/dtolnay/thiserror: thiserror\n\u27e812\u27e9 https://docs.rs/anyhow/latest/anyhow/#no-std-support: \u00a7\n\u27e813\u27e9 https://docs.rs/anyhow/latest/anyhow/#reexports: \u00a7\n\u27e814\u27e9 https://docs.rs/anyhow/latest/anyhow/#macros: \u00a7\n\u27e815\u27e9 https://docs.rs/anyhow/latest/anyhow/macro.anyhow.html: macro anyhow::anyhow - anyhow\n\u27e816\u27e9 https://docs.rs/anyhow/latest/anyhow/macro.bail.html: macro anyhow::bail - bail\n\u27e817\u27e9 https://docs.rs/anyhow/latest/anyhow/macro.ensure.html: macro anyhow::ensure - ensure\n\u27e818\u27e9 https://docs.rs/anyhow/latest/anyhow/#structs: \u00a7\n\u27e819\u27e9 https://docs.rs/anyhow/latest/anyhow/struct.Chain.html: struct anyhow::Chain - Chain\n\u27e820\u27e9 https://docs.rs/anyhow/latest/anyhow/#traits: \u00a7\n\u27e821\u27e9 https://docs.rs/anyhow/latest/anyhow/trait.Context.html: trait anyhow::Context - Context\n\u27e822\u27e9 https://docs.rs/anyhow/latest/anyhow/#functions: \u00a7\n\u27e823\u27e9 https://docs.rs/anyhow/latest/anyhow/fn.Ok.html: fn anyhow::Ok - Ok\n\u27e824\u27e9 https://docs.rs/anyhow/latest/anyhow/#types: \u00a7\n\u27e825\u27e9 https://docs.rs/anyhow/latest/anyhow/type.Result.html: type anyhow::Result - Result\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `anyhow` crate provides a flexible and idiomatic way to handle errors in Rust applications through the `anyhow::Error` type, which works seamlessly with `Result<T, anyhow::Error>` or `anyhow::Result<T>`. It supports error propagation with the `?` operator, attaching context to errors for better debugging, downcasting to specific error types, and generating ad-hoc error messages using macros like `anyhow!` and `bail!`. Additionally, it offers backtrace support, compatibility with custom error types, and can operate in `no_std` environments.",
    "feature_summary": null,
    "use_case": "Utilities",
    "score": 9.5,
    "factual_counterfactual": "### Pair 1: Error Handling and Propagation\n\u2705 **Factual:** The `anyhow::Error` type supports idiomatic error handling in Rust, allowing developers to use `Result<T, anyhow::Error>` or `anyhow::Result<T>` as the return type for fallible functions, with seamless error propagation using the `?` operator.  \n\u274c **Counterfactual:** The `anyhow::Error` type can only propagate errors that originate from the `std::io` module and does not support errors from other libraries or custom error types.  \n\n---\n\n### Pair 2: Contextual Error Messages\n\u2705 **Factual:** The `Context` trait in `anyhow` allows developers to attach additional context to errors, making debugging easier by providing higher-level information about the failure.  \n\u274c **Counterfactual:** The `Context` trait automatically generates context messages for errors based on the function name and arguments, without requiring explicit calls to `.context()` or `.with_context()`.  \n\n---\n\n### Pair 3: No-std Support\n\u2705 **Factual:** The `anyhow` crate supports `no_std` environments by disabling the default \"std\" feature in Cargo.toml, although a global allocator is required.  \n\u274c **Counterfactual:** The `anyhow` crate is incompatible with `no_std` environments and requires full access to the standard library to function.",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}