{
    "name": "pulsar",
    "version": "6.3.1",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/pulsar/latest/pulsar/all.html \"show sidebar\")\n# Crate pulsarCopy item path\n[Settings](https://docs.rs/pulsar/latest/settings.html)\n[Help](https://docs.rs/pulsar/latest/help.html)\nSummary[Source](https://docs.rs/pulsar/latest/src/pulsar/lib.rs.html#1-596)\nExpand description\n## [\u00a7](https://docs.rs/pulsar/latest/pulsar/#pure-rust-async-await-client-for-apache-pulsar)Pure Rust async await client for Apache Pulsar\nThis is a pure Rust client for Apache Pulsar that does not depend on the C++ Pulsar library. It provides an async/await based API, compatible with [Tokio](https://tokio.rs/) and [async-std](https://async.rs/).\nFeatures:\n  * URL based (`pulsar://` and `pulsar+ssl://`) connections with DNS lookup\n  * multi topic consumers (based on a regex)\n  * TLS connection\n  * configurable executor (Tokio or async-std)\n  * automatic reconnection with exponential back off\n  * message batching\n  * compression with LZ4, zlib, zstd or Snappy (can be deactivated with Cargo features)\n\n\n### [\u00a7](https://docs.rs/pulsar/latest/pulsar/#examples)Examples\nCopy this into your project\u2019s Cargo.toml:\n```\n[dependencies]\nenv_logger = \"0.9\"\npulsar = \"4.1.1\"\nserde = { version = \"1.0\", features = [\"derive\"] }\nserde_json = \"1.0\"\ntokio = { version = \"1.0\", features = [\"macros\", \"rt-multi-thread\"] }\nlog = \"0.4.6\"\nfutures = \"0.3\"\n```\n\n#### [\u00a7](https://docs.rs/pulsar/latest/pulsar/#producing)Producing\n```\nuse pulsar::{\n  message::proto, producer, Error as PulsarError, Pulsar, SerializeMessage, TokioExecutor,\n};\nuse serde::{Deserialize, Serialize};\n#[derive(Serialize, Deserialize)]\nstruct TestData {\n  data: String,\n}\nimpl SerializeMessage for TestData {\n  fn serialize_message(input: Self) -> Result<producer::Message, PulsarError> {\n    let payload =\n      serde_json::to_vec(&input).map_err(|e| PulsarError::Custom(e.to_string()))?;\n    Ok(producer::Message {\n      payload,\n      ..Default::default()\n    })\n  }\n}\n#[tokio::main]\nasync fn main() -> Result<(), pulsar::Error> {\n  env_logger::init();\n  let addr = \"pulsar://127.0.0.1:6650\";\n  let pulsar: Pulsar<_> = Pulsar::builder(addr, TokioExecutor).build().await?;\n  let mut producer = pulsar\n    .producer()\n    .with_topic(\"non-persistent://public/default/test\")\n    .with_name(\"my producer\")\n    .with_options(producer::ProducerOptions {\n      schema: Some(proto::Schema {\n        r#type: proto::schema::Type::String as i32,\n        ..Default::default()\n      }),\n      ..Default::default()\n    })\n    .build()\n    .await?;\n  let mut counter = 0usize;\n  loop {\n    producer\n      .send(TestData {\n        data: \"data\".to_string(),\n      })\n      .await?;\n    counter += 1;\n    println!(\"{} messages\", counter);\n    tokio::time::sleep(std::time::Duration::from_millis(2000)).await;\n  }\n}\n```\n\n#### [\u00a7](https://docs.rs/pulsar/latest/pulsar/#consuming)Consuming\n```\nuse futures::TryStreamExt;\nuse pulsar::{\n  message::{proto::command_subscribe::SubType, Payload},\n  Consumer, DeserializeMessage, Pulsar, TokioExecutor,\n};\nuse serde::{Deserialize, Serialize};\n#[derive(Serialize, Deserialize)]\nstruct TestData {\n  data: String,\n}\nimpl DeserializeMessage for TestData {\n  type Output = Result<TestData, serde_json::Error>;\n  fn deserialize_message(payload: &Payload) -> Self::Output {\n    serde_json::from_slice(&payload.data)\n  }\n}\n#[tokio::main]\nasync fn main() -> Result<(), pulsar::Error> {\n  env_logger::init();\n  let addr = \"pulsar://127.0.0.1:6650\";\n  let pulsar: Pulsar<_> = Pulsar::builder(addr, TokioExecutor).build().await?;\n  let mut consumer: Consumer<TestData, _> = pulsar\n    .consumer()\n    .with_topic(\"test\")\n    .with_consumer_name(\"test_consumer\")\n    .with_subscription_type(SubType::Exclusive)\n    .with_subscription(\"test_subscription\")\n    .build()\n    .await?;\n  let mut counter = 0usize;\n  while let Some(msg) = consumer.try_next().await? {\n    consumer.ack(&msg).await?;\n    let data = match msg.deserialize() {\n      Ok(data) => data,\n      Err(e) => {\n        log::error!(\"could not deserialize message: {:?}\", e);\n        break;\n      }\n    };\n    if data.data.as_str() != \"data\" {\n      log::error!(\"Unexpected payload: {}\", &data.data);\n      break;\n    }\n    counter += 1;\n    log::info!(\"got {} messages\", counter);\n  }\n  Ok(())\n}\n```\n\n## Re-exports[\u00a7](https://docs.rs/pulsar/latest/pulsar/#reexports)\n\n`pub use consumer::Consumer[](https://docs.rs/pulsar/latest/pulsar/consumer/struct.Consumer.html \"struct pulsar::consumer::Consumer\");`\n\n\n`pub use consumer::ConsumerBuilder[](https://docs.rs/pulsar/latest/pulsar/consumer/builder/struct.ConsumerBuilder.html \"struct pulsar::consumer::builder::ConsumerBuilder\");`\n\n\n`pub use consumer::ConsumerOptions[](https://docs.rs/pulsar/latest/pulsar/consumer/options/struct.ConsumerOptions.html \"struct pulsar::consumer::options::ConsumerOptions\");`\n\n\n`pub use error::Error[](https://docs.rs/pulsar/latest/pulsar/error/enum.Error.html \"enum pulsar::error::Error\");`\n\n\n`pub use executor::AsyncStdExecutor[](https://docs.rs/pulsar/latest/pulsar/executor/struct.AsyncStdExecutor.html \"struct pulsar::executor::AsyncStdExecutor\");`\n\n\n`pub use executor::Executor[](https://docs.rs/pulsar/latest/pulsar/executor/trait.Executor.html \"trait pulsar::executor::Executor\");`\n\n\n`pub use executor::TokioExecutor[](https://docs.rs/pulsar/latest/pulsar/executor/struct.TokioExecutor.html \"struct pulsar::executor::TokioExecutor\");`\n\n\n`pub use message::proto[](https://docs.rs/pulsar/latest/pulsar/message/proto/index.html \"mod pulsar::message::proto\");`\n\n\n`pub use message::proto::command_subscribe::SubType[](https://docs.rs/pulsar/latest/pulsar/message/proto/command_subscribe/enum.SubType.html \"enum pulsar::message::proto::command_subscribe::SubType\");`\n\n\n`pub use message::proto::CommandSendReceipt[](https://docs.rs/pulsar/latest/pulsar/message/proto/struct.CommandSendReceipt.html \"struct pulsar::message::proto::CommandSendReceipt\");`\n\n\n`pub use message::Payload[](https://docs.rs/pulsar/latest/pulsar/message/struct.Payload.html \"struct pulsar::message::Payload\");`\n\n\n`pub use producer::MultiTopicProducer[](https://docs.rs/pulsar/latest/pulsar/producer/struct.MultiTopicProducer.html \"struct pulsar::producer::MultiTopicProducer\");`\n\n\n`pub use producer::Producer[](https://docs.rs/pulsar/latest/pulsar/producer/struct.Producer.html \"struct pulsar::producer::Producer\");`\n\n\n`pub use producer::ProducerOptions[](https://docs.rs/pulsar/latest/pulsar/producer/struct.ProducerOptions.html \"struct pulsar::producer::ProducerOptions\");`\n\n## Modules[\u00a7](https://docs.rs/pulsar/latest/pulsar/#modules)\n\n[authentication](https://docs.rs/pulsar/latest/pulsar/authentication/index.html \"mod pulsar::authentication\")\n\n\n[compression](https://docs.rs/pulsar/latest/pulsar/compression/index.html \"mod pulsar::compression\")\n    Compression strategy configs\n\n[consumer](https://docs.rs/pulsar/latest/pulsar/consumer/index.html \"mod pulsar::consumer\")\n    Topic subscriptions\n\n[error](https://docs.rs/pulsar/latest/pulsar/error/index.html \"mod pulsar::error\")\n    Error types\n\n[executor](https://docs.rs/pulsar/latest/pulsar/executor/index.html \"mod pulsar::executor\")\n    executor abstraction\n\n[message](https://docs.rs/pulsar/latest/pulsar/message/index.html \"mod pulsar::message\")\n    low level structures used to send and process raw messages\n\n[producer](https://docs.rs/pulsar/latest/pulsar/producer/index.html \"mod pulsar::producer\")\n    Message publication\n\n[reader](https://docs.rs/pulsar/latest/pulsar/reader/index.html \"mod pulsar::reader\")\n\n## Structs[\u00a7](https://docs.rs/pulsar/latest/pulsar/#structs)\n\n[Authentication](https://docs.rs/pulsar/latest/pulsar/struct.Authentication.html \"struct pulsar::Authentication\")\n    Authentication parameters\n\n[BrokerAddress](https://docs.rs/pulsar/latest/pulsar/struct.BrokerAddress.html \"struct pulsar::BrokerAddress\")\n    holds connection information for a broker\n\n[ConnectionRetryOptions](https://docs.rs/pulsar/latest/pulsar/struct.ConnectionRetryOptions.html \"struct pulsar::ConnectionRetryOptions\")\n    configuration for reconnection exponential back off\n\n[OperationRetryOptions](https://docs.rs/pulsar/latest/pulsar/struct.OperationRetryOptions.html \"struct pulsar::OperationRetryOptions\")\n    configuration for Pulsar operation retries\n\n[Pulsar](https://docs.rs/pulsar/latest/pulsar/struct.Pulsar.html \"struct pulsar::Pulsar\")\n    Pulsar client\n\n[PulsarBuilder](https://docs.rs/pulsar/latest/pulsar/struct.PulsarBuilder.html \"struct pulsar::PulsarBuilder\")\n    Helper structure to generate a [Pulsar](https://docs.rs/pulsar/latest/pulsar/struct.Pulsar.html \"struct pulsar::Pulsar\") client\n\n[TlsOptions](https://docs.rs/pulsar/latest/pulsar/struct.TlsOptions.html \"struct pulsar::TlsOptions\")\n    configuration for TLS connections\n## Traits[\u00a7](https://docs.rs/pulsar/latest/pulsar/#traits)\n\n[DeserializeMessage](https://docs.rs/pulsar/latest/pulsar/trait.DeserializeMessage.html \"trait pulsar::DeserializeMessage\")\n    Helper trait for consumer deserialization\n\n[SerializeMessage](https://docs.rs/pulsar/latest/pulsar/trait.SerializeMessage.html \"trait pulsar::SerializeMessage\")\n    Helper trait for message serialization\n",
        "markdown_with_citations": "[](https://docs.rs/pulsar/latest/pulsar/all.html \"show sidebar\")\n# Crate pulsarCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\n## \u00a7\u27e84\u27e9Pure Rust async await client for Apache Pulsar\nThis is a pure Rust client for Apache Pulsar that does not depend on the C++ Pulsar library. It provides an async/await based API, compatible with Tokio\u27e85\u27e9 and async-std\u27e86\u27e9.\nFeatures:\n  * URL based (`pulsar://` and `pulsar+ssl://`) connections with DNS lookup\n  * multi topic consumers (based on a regex)\n  * TLS connection\n  * configurable executor (Tokio or async-std)\n  * automatic reconnection with exponential back off\n  * message batching\n  * compression with LZ4, zlib, zstd or Snappy (can be deactivated with Cargo features)\n\n\n### \u00a7\u27e87\u27e9Examples\nCopy this into your project\u2019s Cargo.toml:\n```\n[dependencies]\nenv_logger = \"0.9\"\npulsar = \"4.1.1\"\nserde = { version = \"1.0\", features = [\"derive\"] }\nserde_json = \"1.0\"\ntokio = { version = \"1.0\", features = [\"macros\", \"rt-multi-thread\"] }\nlog = \"0.4.6\"\nfutures = \"0.3\"\n```\n\n#### \u00a7\u27e88\u27e9Producing\n```\nuse pulsar::{\n  message::proto, producer, Error as PulsarError, Pulsar, SerializeMessage, TokioExecutor,\n};\nuse serde::{Deserialize, Serialize};\n#[derive(Serialize, Deserialize)]\nstruct TestData {\n  data: String,\n}\nimpl SerializeMessage for TestData {\n  fn serialize_message(input: Self) -> Result<producer::Message, PulsarError> {\n    let payload =\n      serde_json::to_vec(&input).map_err(|e| PulsarError::Custom(e.to_string()))?;\n    Ok(producer::Message {\n      payload,\n      ..Default::default()\n    })\n  }\n}\n#[tokio::main]\nasync fn main() -> Result<(), pulsar::Error> {\n  env_logger::init();\n  let addr = \"pulsar://127.0.0.1:6650\";\n  let pulsar: Pulsar<_> = Pulsar::builder(addr, TokioExecutor).build().await?;\n  let mut producer = pulsar\n    .producer()\n    .with_topic(\"non-persistent://public/default/test\")\n    .with_name(\"my producer\")\n    .with_options(producer::ProducerOptions {\n      schema: Some(proto::Schema {\n        r#type: proto::schema::Type::String as i32,\n        ..Default::default()\n      }),\n      ..Default::default()\n    })\n    .build()\n    .await?;\n  let mut counter = 0usize;\n  loop {\n    producer\n      .send(TestData {\n        data: \"data\".to_string(),\n      })\n      .await?;\n    counter += 1;\n    println!(\"{} messages\", counter);\n    tokio::time::sleep(std::time::Duration::from_millis(2000)).await;\n  }\n}\n```\n\n#### \u00a7\u27e89\u27e9Consuming\n```\nuse futures::TryStreamExt;\nuse pulsar::{\n  message::{proto::command_subscribe::SubType, Payload},\n  Consumer, DeserializeMessage, Pulsar, TokioExecutor,\n};\nuse serde::{Deserialize, Serialize};\n#[derive(Serialize, Deserialize)]\nstruct TestData {\n  data: String,\n}\nimpl DeserializeMessage for TestData {\n  type Output = Result<TestData, serde_json::Error>;\n  fn deserialize_message(payload: &Payload) -> Self::Output {\n    serde_json::from_slice(&payload.data)\n  }\n}\n#[tokio::main]\nasync fn main() -> Result<(), pulsar::Error> {\n  env_logger::init();\n  let addr = \"pulsar://127.0.0.1:6650\";\n  let pulsar: Pulsar<_> = Pulsar::builder(addr, TokioExecutor).build().await?;\n  let mut consumer: Consumer<TestData, _> = pulsar\n    .consumer()\n    .with_topic(\"test\")\n    .with_consumer_name(\"test_consumer\")\n    .with_subscription_type(SubType::Exclusive)\n    .with_subscription(\"test_subscription\")\n    .build()\n    .await?;\n  let mut counter = 0usize;\n  while let Some(msg) = consumer.try_next().await? {\n    consumer.ack(&msg).await?;\n    let data = match msg.deserialize() {\n      Ok(data) => data,\n      Err(e) => {\n        log::error!(\"could not deserialize message: {:?}\", e);\n        break;\n      }\n    };\n    if data.data.as_str() != \"data\" {\n      log::error!(\"Unexpected payload: {}\", &data.data);\n      break;\n    }\n    counter += 1;\n    log::info!(\"got {} messages\", counter);\n  }\n  Ok(())\n}\n```\n\n## Re-exports\u00a7\u27e810\u27e9\n\n`pub use consumer::Consumer[](https://docs.rs/pulsar/latest/pulsar/consumer/struct.Consumer.html \"struct pulsar::consumer::Consumer\");`\n\n\n`pub use consumer::ConsumerBuilder[](https://docs.rs/pulsar/latest/pulsar/consumer/builder/struct.ConsumerBuilder.html \"struct pulsar::consumer::builder::ConsumerBuilder\");`\n\n\n`pub use consumer::ConsumerOptions[](https://docs.rs/pulsar/latest/pulsar/consumer/options/struct.ConsumerOptions.html \"struct pulsar::consumer::options::ConsumerOptions\");`\n\n\n`pub use error::Error[](https://docs.rs/pulsar/latest/pulsar/error/enum.Error.html \"enum pulsar::error::Error\");`\n\n\n`pub use executor::AsyncStdExecutor[](https://docs.rs/pulsar/latest/pulsar/executor/struct.AsyncStdExecutor.html \"struct pulsar::executor::AsyncStdExecutor\");`\n\n\n`pub use executor::Executor[](https://docs.rs/pulsar/latest/pulsar/executor/trait.Executor.html \"trait pulsar::executor::Executor\");`\n\n\n`pub use executor::TokioExecutor[](https://docs.rs/pulsar/latest/pulsar/executor/struct.TokioExecutor.html \"struct pulsar::executor::TokioExecutor\");`\n\n\n`pub use message::proto[](https://docs.rs/pulsar/latest/pulsar/message/proto/index.html \"mod pulsar::message::proto\");`\n\n\n`pub use message::proto::command_subscribe::SubType[](https://docs.rs/pulsar/latest/pulsar/message/proto/command_subscribe/enum.SubType.html \"enum pulsar::message::proto::command_subscribe::SubType\");`\n\n\n`pub use message::proto::CommandSendReceipt[](https://docs.rs/pulsar/latest/pulsar/message/proto/struct.CommandSendReceipt.html \"struct pulsar::message::proto::CommandSendReceipt\");`\n\n\n`pub use message::Payload[](https://docs.rs/pulsar/latest/pulsar/message/struct.Payload.html \"struct pulsar::message::Payload\");`\n\n\n`pub use producer::MultiTopicProducer[](https://docs.rs/pulsar/latest/pulsar/producer/struct.MultiTopicProducer.html \"struct pulsar::producer::MultiTopicProducer\");`\n\n\n`pub use producer::Producer[](https://docs.rs/pulsar/latest/pulsar/producer/struct.Producer.html \"struct pulsar::producer::Producer\");`\n\n\n`pub use producer::ProducerOptions[](https://docs.rs/pulsar/latest/pulsar/producer/struct.ProducerOptions.html \"struct pulsar::producer::ProducerOptions\");`\n\n## Modules\u00a7\u27e811\u27e9\n\nauthentication\u27e812\u27e9\n\n\ncompression\u27e813\u27e9\n    Compression strategy configs\n\nconsumer\u27e814\u27e9\n    Topic subscriptions\n\nerror\u27e815\u27e9\n    Error types\n\nexecutor\u27e816\u27e9\n    executor abstraction\n\nmessage\u27e817\u27e9\n    low level structures used to send and process raw messages\n\nproducer\u27e818\u27e9\n    Message publication\n\nreader\u27e819\u27e9\n\n## Structs\u00a7\u27e820\u27e9\n\nAuthentication\u27e821\u27e9\n    Authentication parameters\n\nBrokerAddress\u27e822\u27e9\n    holds connection information for a broker\n\nConnectionRetryOptions\u27e823\u27e9\n    configuration for reconnection exponential back off\n\nOperationRetryOptions\u27e824\u27e9\n    configuration for Pulsar operation retries\n\nPulsar\u27e825\u27e9\n    Pulsar client\n\nPulsarBuilder\u27e826\u27e9\n    Helper structure to generate a Pulsar\u27e825\u27e9 client\n\nTlsOptions\u27e827\u27e9\n    configuration for TLS connections\n## Traits\u00a7\u27e828\u27e9\n\nDeserializeMessage\u27e829\u27e9\n    Helper trait for consumer deserialization\n\nSerializeMessage\u27e830\u27e9\n    Helper trait for message serialization\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/pulsar/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/pulsar/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/pulsar/latest/src/pulsar/lib.rs.html#1-596: Source\n\u27e84\u27e9 https://docs.rs/pulsar/latest/pulsar/#pure-rust-async-await-client-for-apache-pulsar: \u00a7\n\u27e85\u27e9 https://tokio.rs/: Tokio\n\u27e86\u27e9 https://async.rs/: async-std\n\u27e87\u27e9 https://docs.rs/pulsar/latest/pulsar/#examples: \u00a7\n\u27e88\u27e9 https://docs.rs/pulsar/latest/pulsar/#producing: \u00a7\n\u27e89\u27e9 https://docs.rs/pulsar/latest/pulsar/#consuming: \u00a7\n\u27e810\u27e9 https://docs.rs/pulsar/latest/pulsar/#reexports: \u00a7\n\u27e811\u27e9 https://docs.rs/pulsar/latest/pulsar/#modules: \u00a7\n\u27e812\u27e9 https://docs.rs/pulsar/latest/pulsar/authentication/index.html: mod pulsar::authentication - authentication\n\u27e813\u27e9 https://docs.rs/pulsar/latest/pulsar/compression/index.html: mod pulsar::compression - compression\n\u27e814\u27e9 https://docs.rs/pulsar/latest/pulsar/consumer/index.html: mod pulsar::consumer - consumer\n\u27e815\u27e9 https://docs.rs/pulsar/latest/pulsar/error/index.html: mod pulsar::error - error\n\u27e816\u27e9 https://docs.rs/pulsar/latest/pulsar/executor/index.html: mod pulsar::executor - executor\n\u27e817\u27e9 https://docs.rs/pulsar/latest/pulsar/message/index.html: mod pulsar::message - message\n\u27e818\u27e9 https://docs.rs/pulsar/latest/pulsar/producer/index.html: mod pulsar::producer - producer\n\u27e819\u27e9 https://docs.rs/pulsar/latest/pulsar/reader/index.html: mod pulsar::reader - reader\n\u27e820\u27e9 https://docs.rs/pulsar/latest/pulsar/#structs: \u00a7\n\u27e821\u27e9 https://docs.rs/pulsar/latest/pulsar/struct.Authentication.html: struct pulsar::Authentication - Authentication\n\u27e822\u27e9 https://docs.rs/pulsar/latest/pulsar/struct.BrokerAddress.html: struct pulsar::BrokerAddress - BrokerAddress\n\u27e823\u27e9 https://docs.rs/pulsar/latest/pulsar/struct.ConnectionRetryOptions.html: struct pulsar::ConnectionRetryOptions - ConnectionRetryOptions\n\u27e824\u27e9 https://docs.rs/pulsar/latest/pulsar/struct.OperationRetryOptions.html: struct pulsar::OperationRetryOptions - OperationRetryOptions\n\u27e825\u27e9 https://docs.rs/pulsar/latest/pulsar/struct.Pulsar.html: struct pulsar::Pulsar - Pulsar\n\u27e826\u27e9 https://docs.rs/pulsar/latest/pulsar/struct.PulsarBuilder.html: struct pulsar::PulsarBuilder - PulsarBuilder\n\u27e827\u27e9 https://docs.rs/pulsar/latest/pulsar/struct.TlsOptions.html: struct pulsar::TlsOptions - TlsOptions\n\u27e828\u27e9 https://docs.rs/pulsar/latest/pulsar/#traits: \u00a7\n\u27e829\u27e9 https://docs.rs/pulsar/latest/pulsar/trait.DeserializeMessage.html: trait pulsar::DeserializeMessage - DeserializeMessage\n\u27e830\u27e9 https://docs.rs/pulsar/latest/pulsar/trait.SerializeMessage.html: trait pulsar::SerializeMessage - SerializeMessage\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `pulsar` crate is a pure Rust async/await client for Apache Pulsar, compatible with Tokio and async-std, and does not rely on the C++ Pulsar library. It supports URL-based connections, multi-topic consumers (via regex), TLS, automatic reconnection with exponential backoff, message batching, and compression (LZ4, zlib, zstd, Snappy). Key features include configurable executors, producer/consumer APIs, and serialization/deserialization helpers for seamless message handling.",
    "feature_summary": null,
    "use_case": "Networking",
    "score": 6.0,
    "factual_counterfactual": "### Pair 1: Async/Await API and Compatibility  \n\u2705 **Factual:** The `pulsar` crate provides a pure Rust async/await API that is compatible with both `Tokio` and `async-std` executors.  \n\u274c **Counterfactual:** The `pulsar` crate requires the C++ Pulsar library to function and is incompatible with `Tokio` or `async-std`.\n\n---\n\n### Pair 2: Compression Support  \n\u2705 **Factual:** The `pulsar` crate supports message compression using LZ4, zlib, zstd, and Snappy, which can be disabled via Cargo features.  \n\u274c **Counterfactual:** The `pulsar` crate only supports uncompressed messages and does not provide any compression options.\n\n---\n\n### Pair 3: Multi-Topic Consumers  \n\u2705 **Factual:** The `pulsar` crate allows multi-topic consumers based on regular expressions, enabling dynamic subscription to multiple topics.  \n\u274c **Counterfactual:** The `pulsar` crate only supports single-topic consumers and does not allow subscriptions based on regular expressions.",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}