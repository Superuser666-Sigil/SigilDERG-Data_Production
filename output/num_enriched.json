{
    "name": "num",
    "version": "0.4.3",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/num/latest/num/all.html \"show sidebar\")\n# Crate numCopy item path\n[Settings](https://docs.rs/num/latest/settings.html)\n[Help](https://docs.rs/num/latest/help.html)\nSummary[Source](https://docs.rs/num/latest/src/num/lib.rs.html#11-108)\nExpand description\nA collection of numeric types and traits for Rust.\nThis includes new types for big integers, rationals, and complex numbers, new traits for generic programming on numeric properties like `Integer`, and generic range iterators.\n### [\u00a7](https://docs.rs/num/latest/num/#example)Example\nThis example uses the BigRational type and [Newton\u2019s method](https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method) to approximate a square root to arbitrary precision:\n```\n\nuse num::FromPrimitive;\nuse num::bigint::BigInt;\nuse num::rational::{Ratio, BigRational};\nfn approx_sqrt(number: u64, iterations: usize) -> BigRational {\n  let start: Ratio<BigInt> = Ratio::from_integer(FromPrimitive::from_u64(number).unwrap());\n  let mut approx = start.clone();\n  for _ in 0..iterations {\n    approx = (&approx + (&start / &approx)) /\n      Ratio::from_integer(FromPrimitive::from_u64(2).unwrap());\n  }\n  approx\n}\nfn main() {\n  println!(\"{}\", approx_sqrt(10, 4)); // prints 4057691201/1283082416\n}\n\n```\n\n### [\u00a7](https://docs.rs/num/latest/num/#compatibility)Compatibility\nThe `num` crate is tested for rustc 1.60 and greater.\n## Modules[\u00a7](https://docs.rs/num/latest/num/#modules)\n\n[bigint](https://docs.rs/num/latest/num/bigint/index.html \"mod num::bigint\")\n\n\n[cast](https://docs.rs/num/latest/num/cast/index.html \"mod num::cast\")\n\n\n[complex](https://docs.rs/num/latest/num/complex/index.html \"mod num::complex\")\n\n\n[integer](https://docs.rs/num/latest/num/integer/index.html \"mod num::integer\")\n\n\n[iter](https://docs.rs/num/latest/num/iter/index.html \"mod num::iter\")\n\n\n[pow](https://docs.rs/num/latest/num/pow/index.html \"mod num::pow\")\n\n\n[rational](https://docs.rs/num/latest/num/rational/index.html \"mod num::rational\")\n\n\n[traits](https://docs.rs/num/latest/num/traits/index.html \"mod num::traits\")\n\n## Structs[\u00a7](https://docs.rs/num/latest/num/#structs)\n\n[BigInt](https://docs.rs/num/latest/num/struct.BigInt.html \"struct num::BigInt\")\n    A big signed integer type.\n\n[BigUint](https://docs.rs/num/latest/num/struct.BigUint.html \"struct num::BigUint\")\n    A big unsigned integer type.\n\n[Complex](https://docs.rs/num/latest/num/struct.Complex.html \"struct num::Complex\")\n    A complex number in Cartesian form.\n## Traits[\u00a7](https://docs.rs/num/latest/num/#traits)\n\n[Bounded](https://docs.rs/num/latest/num/trait.Bounded.html \"trait num::Bounded\")\n    Numbers which have upper and lower bounds\n\n[CheckedAdd](https://docs.rs/num/latest/num/trait.CheckedAdd.html \"trait num::CheckedAdd\")\n    Performs addition that returns `None` instead of wrapping around on overflow.\n\n[CheckedDiv](https://docs.rs/num/latest/num/trait.CheckedDiv.html \"trait num::CheckedDiv\")\n    Performs division that returns `None` instead of panicking on division by zero and instead of wrapping around on underflow and overflow.\n\n[CheckedMul](https://docs.rs/num/latest/num/trait.CheckedMul.html \"trait num::CheckedMul\")\n    Performs multiplication that returns `None` instead of wrapping around on underflow or overflow.\n\n[CheckedSub](https://docs.rs/num/latest/num/trait.CheckedSub.html \"trait num::CheckedSub\")\n    Performs subtraction that returns `None` instead of wrapping around on underflow.\n\n[Float](https://docs.rs/num/latest/num/trait.Float.html \"trait num::Float\")\n    Generic trait for floating point numbers\n\n[FromPrimitive](https://docs.rs/num/latest/num/trait.FromPrimitive.html \"trait num::FromPrimitive\")\n    A generic trait for converting a number to a value.\n\n[Integer](https://docs.rs/num/latest/num/trait.Integer.html \"trait num::Integer\")\n\n\n[Num](https://docs.rs/num/latest/num/trait.Num.html \"trait num::Num\")\n    The base trait for numeric types, covering `0` and `1` values, comparisons, basic numeric operations, and string conversion.\n\n[NumCast](https://docs.rs/num/latest/num/trait.NumCast.html \"trait num::NumCast\")\n    An interface for casting between machine scalars.\n\n[One](https://docs.rs/num/latest/num/trait.One.html \"trait num::One\")\n    Defines a multiplicative identity element for `Self`.\n\n[PrimInt](https://docs.rs/num/latest/num/trait.PrimInt.html \"trait num::PrimInt\")\n    Generic trait for primitive integers.\n\n[Saturating](https://docs.rs/num/latest/num/trait.Saturating.html \"trait num::Saturating\")\n    Saturating math operations. Deprecated, use `SaturatingAdd`, `SaturatingSub` and `SaturatingMul` instead.\n\n[Signed](https://docs.rs/num/latest/num/trait.Signed.html \"trait num::Signed\")\n    Useful functions for signed numbers (i.e. numbers that can be negative).\n\n[ToPrimitive](https://docs.rs/num/latest/num/trait.ToPrimitive.html \"trait num::ToPrimitive\")\n    A generic trait for converting a value to a number.\n\n[Unsigned](https://docs.rs/num/latest/num/trait.Unsigned.html \"trait num::Unsigned\")\n    A trait for values which cannot be negative\n\n[Zero](https://docs.rs/num/latest/num/trait.Zero.html \"trait num::Zero\")\n    Defines an additive identity element for `Self`.\n## Functions[\u00a7](https://docs.rs/num/latest/num/#functions)\n\n[abs](https://docs.rs/num/latest/num/fn.abs.html \"fn num::abs\")\n    Computes the absolute value.\n\n[abs_sub](https://docs.rs/num/latest/num/fn.abs_sub.html \"fn num::abs_sub\")\n    The positive difference of two numbers.\n\n[cast](https://docs.rs/num/latest/num/fn.cast.html \"fn num::cast\")\n    Cast from one machine scalar to another.\n\n[checked_pow](https://docs.rs/num/latest/num/fn.checked_pow.html \"fn num::checked_pow\")\n    Raises a value to the power of exp, returning `None` if an overflow occurred.\n\n[clamp](https://docs.rs/num/latest/num/fn.clamp.html \"fn num::clamp\")\n    A value bounded by a minimum and a maximum\n\n[one](https://docs.rs/num/latest/num/fn.one.html \"fn num::one\")\n    Returns the multiplicative identity, `1`.\n\n[pow](https://docs.rs/num/latest/num/fn.pow.html \"fn num::pow\")\n    Raises a value to the power of exp, using exponentiation by squaring.\n\n[range](https://docs.rs/num/latest/num/fn.range.html \"fn num::range\")\n    Returns an iterator over the given range [start, stop) (that is, starting at start (inclusive), and ending at stop (exclusive)).\n\n[range_inclusive](https://docs.rs/num/latest/num/fn.range_inclusive.html \"fn num::range_inclusive\")\n    Return an iterator over the range [start, stop]\n\n[range_step](https://docs.rs/num/latest/num/fn.range_step.html \"fn num::range_step\")\n    Return an iterator over the range [start, stop) by `step`. It handles overflow by stopping.\n\n[range_step_inclusive](https://docs.rs/num/latest/num/fn.range_step_inclusive.html \"fn num::range_step_inclusive\")\n    Return an iterator over the range [start, stop] by `step`. It handles overflow by stopping.\n\n[signum](https://docs.rs/num/latest/num/fn.signum.html \"fn num::signum\")\n    Returns the sign of the number.\n\n[zero](https://docs.rs/num/latest/num/fn.zero.html \"fn num::zero\")\n    Returns the additive identity, `0`.\n## Type Aliases[\u00a7](https://docs.rs/num/latest/num/#types)\n\n[BigRational](https://docs.rs/num/latest/num/type.BigRational.html \"type num::BigRational\")\n    Alias for arbitrary precision rationals.\n\n[Rational](https://docs.rs/num/latest/num/type.Rational.html \"type num::Rational\")Deprecated\n    Alias for a `Ratio` of machine-sized integers.\n\n[Rational32](https://docs.rs/num/latest/num/type.Rational32.html \"type num::Rational32\")\n    Alias for a `Ratio` of 32-bit-sized integers.\n\n[Rational64](https://docs.rs/num/latest/num/type.Rational64.html \"type num::Rational64\")\n    Alias for a `Ratio` of 64-bit-sized integers.\n",
        "markdown_with_citations": "[](https://docs.rs/num/latest/num/all.html \"show sidebar\")\n# Crate numCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nA collection of numeric types and traits for Rust.\nThis includes new types for big integers, rationals, and complex numbers, new traits for generic programming on numeric properties like `Integer`, and generic range iterators.\n### \u00a7\u27e84\u27e9Example\nThis example uses the BigRational type and Newton\u2019s method\u27e85\u27e9 to approximate a square root to arbitrary precision:\n```\n\nuse num::FromPrimitive;\nuse num::bigint::BigInt;\nuse num::rational::{Ratio, BigRational};\nfn approx_sqrt(number: u64, iterations: usize) -> BigRational {\n  let start: Ratio<BigInt> = Ratio::from_integer(FromPrimitive::from_u64(number).unwrap());\n  let mut approx = start.clone();\n  for _ in 0..iterations {\n    approx = (&approx + (&start / &approx)) /\n      Ratio::from_integer(FromPrimitive::from_u64(2).unwrap());\n  }\n  approx\n}\nfn main() {\n  println!(\"{}\", approx_sqrt(10, 4)); // prints 4057691201/1283082416\n}\n\n```\n\n### \u00a7\u27e86\u27e9Compatibility\nThe `num` crate is tested for rustc 1.60 and greater.\n## Modules\u00a7\u27e87\u27e9\n\nbigint\u27e88\u27e9\n\n\ncast\u27e89\u27e9\n\n\ncomplex\u27e810\u27e9\n\n\ninteger\u27e811\u27e9\n\n\niter\u27e812\u27e9\n\n\npow\u27e813\u27e9\n\n\nrational\u27e814\u27e9\n\n\ntraits\u27e815\u27e9\n\n## Structs\u00a7\u27e816\u27e9\n\nBigInt\u27e817\u27e9\n    A big signed integer type.\n\nBigUint\u27e818\u27e9\n    A big unsigned integer type.\n\nComplex\u27e819\u27e9\n    A complex number in Cartesian form.\n## Traits\u00a7\u27e820\u27e9\n\nBounded\u27e821\u27e9\n    Numbers which have upper and lower bounds\n\nCheckedAdd\u27e822\u27e9\n    Performs addition that returns `None` instead of wrapping around on overflow.\n\nCheckedDiv\u27e823\u27e9\n    Performs division that returns `None` instead of panicking on division by zero and instead of wrapping around on underflow and overflow.\n\nCheckedMul\u27e824\u27e9\n    Performs multiplication that returns `None` instead of wrapping around on underflow or overflow.\n\nCheckedSub\u27e825\u27e9\n    Performs subtraction that returns `None` instead of wrapping around on underflow.\n\nFloat\u27e826\u27e9\n    Generic trait for floating point numbers\n\nFromPrimitive\u27e827\u27e9\n    A generic trait for converting a number to a value.\n\nInteger\u27e828\u27e9\n\n\nNum\u27e829\u27e9\n    The base trait for numeric types, covering `0` and `1` values, comparisons, basic numeric operations, and string conversion.\n\nNumCast\u27e830\u27e9\n    An interface for casting between machine scalars.\n\nOne\u27e831\u27e9\n    Defines a multiplicative identity element for `Self`.\n\nPrimInt\u27e832\u27e9\n    Generic trait for primitive integers.\n\nSaturating\u27e833\u27e9\n    Saturating math operations. Deprecated, use `SaturatingAdd`, `SaturatingSub` and `SaturatingMul` instead.\n\nSigned\u27e834\u27e9\n    Useful functions for signed numbers (i.e. numbers that can be negative).\n\nToPrimitive\u27e835\u27e9\n    A generic trait for converting a value to a number.\n\nUnsigned\u27e836\u27e9\n    A trait for values which cannot be negative\n\nZero\u27e837\u27e9\n    Defines an additive identity element for `Self`.\n## Functions\u00a7\u27e838\u27e9\n\nabs\u27e839\u27e9\n    Computes the absolute value.\n\nabs_sub\u27e840\u27e9\n    The positive difference of two numbers.\n\ncast\u27e841\u27e9\n    Cast from one machine scalar to another.\n\nchecked_pow\u27e842\u27e9\n    Raises a value to the power of exp, returning `None` if an overflow occurred.\n\nclamp\u27e843\u27e9\n    A value bounded by a minimum and a maximum\n\none\u27e844\u27e9\n    Returns the multiplicative identity, `1`.\n\npow\u27e845\u27e9\n    Raises a value to the power of exp, using exponentiation by squaring.\n\nrange\u27e846\u27e9\n    Returns an iterator over the given range start, stop) (that is, starting at start (inclusive), and ending at stop (exclusive)).\n\n[range_inclusive\u27e847\u27e9\n    Return an iterator over the range [start, stop]\n\nrange_step\u27e848\u27e9\n    Return an iterator over the range start, stop) by `step`. It handles overflow by stopping.\n\n[range_step_inclusive\u27e849\u27e9\n    Return an iterator over the range [start, stop] by `step`. It handles overflow by stopping.\n\nsignum\u27e850\u27e9\n    Returns the sign of the number.\n\nzero\u27e851\u27e9\n    Returns the additive identity, `0`.\n## Type Aliases\u00a7\u27e852\u27e9\n\nBigRational\u27e853\u27e9\n    Alias for arbitrary precision rationals.\n\nRational\u27e854\u27e9Deprecated\n    Alias for a `Ratio` of machine-sized integers.\n\nRational32\u27e855\u27e9\n    Alias for a `Ratio` of 32-bit-sized integers.\n\nRational64\u27e856\u27e9\n    Alias for a `Ratio` of 64-bit-sized integers.\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/num/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/num/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/num/latest/src/num/lib.rs.html#11-108: Source\n\u27e84\u27e9 https://docs.rs/num/latest/num/#example: \u00a7\n\u27e85\u27e9 https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method: Newton\u2019s method\n\u27e86\u27e9 https://docs.rs/num/latest/num/#compatibility: \u00a7\n\u27e87\u27e9 https://docs.rs/num/latest/num/#modules: \u00a7\n\u27e88\u27e9 https://docs.rs/num/latest/num/bigint/index.html: mod num::bigint - bigint\n\u27e89\u27e9 https://docs.rs/num/latest/num/cast/index.html: mod num::cast - cast\n\u27e810\u27e9 https://docs.rs/num/latest/num/complex/index.html: mod num::complex - complex\n\u27e811\u27e9 https://docs.rs/num/latest/num/integer/index.html: mod num::integer - integer\n\u27e812\u27e9 https://docs.rs/num/latest/num/iter/index.html: mod num::iter - iter\n\u27e813\u27e9 https://docs.rs/num/latest/num/pow/index.html: mod num::pow - pow\n\u27e814\u27e9 https://docs.rs/num/latest/num/rational/index.html: mod num::rational - rational\n\u27e815\u27e9 https://docs.rs/num/latest/num/traits/index.html: mod num::traits - traits\n\u27e816\u27e9 https://docs.rs/num/latest/num/#structs: \u00a7\n\u27e817\u27e9 https://docs.rs/num/latest/num/struct.BigInt.html: struct num::BigInt - BigInt\n\u27e818\u27e9 https://docs.rs/num/latest/num/struct.BigUint.html: struct num::BigUint - BigUint\n\u27e819\u27e9 https://docs.rs/num/latest/num/struct.Complex.html: struct num::Complex - Complex\n\u27e820\u27e9 https://docs.rs/num/latest/num/#traits: \u00a7\n\u27e821\u27e9 https://docs.rs/num/latest/num/trait.Bounded.html: trait num::Bounded - Bounded\n\u27e822\u27e9 https://docs.rs/num/latest/num/trait.CheckedAdd.html: trait num::CheckedAdd - CheckedAdd\n\u27e823\u27e9 https://docs.rs/num/latest/num/trait.CheckedDiv.html: trait num::CheckedDiv - CheckedDiv\n\u27e824\u27e9 https://docs.rs/num/latest/num/trait.CheckedMul.html: trait num::CheckedMul - CheckedMul\n\u27e825\u27e9 https://docs.rs/num/latest/num/trait.CheckedSub.html: trait num::CheckedSub - CheckedSub\n\u27e826\u27e9 https://docs.rs/num/latest/num/trait.Float.html: trait num::Float - Float\n\u27e827\u27e9 https://docs.rs/num/latest/num/trait.FromPrimitive.html: trait num::FromPrimitive - FromPrimitive\n\u27e828\u27e9 https://docs.rs/num/latest/num/trait.Integer.html: trait num::Integer - Integer\n\u27e829\u27e9 https://docs.rs/num/latest/num/trait.Num.html: trait num::Num - Num\n\u27e830\u27e9 https://docs.rs/num/latest/num/trait.NumCast.html: trait num::NumCast - NumCast\n\u27e831\u27e9 https://docs.rs/num/latest/num/trait.One.html: trait num::One - One\n\u27e832\u27e9 https://docs.rs/num/latest/num/trait.PrimInt.html: trait num::PrimInt - PrimInt\n\u27e833\u27e9 https://docs.rs/num/latest/num/trait.Saturating.html: trait num::Saturating - Saturating\n\u27e834\u27e9 https://docs.rs/num/latest/num/trait.Signed.html: trait num::Signed - Signed\n\u27e835\u27e9 https://docs.rs/num/latest/num/trait.ToPrimitive.html: trait num::ToPrimitive - ToPrimitive\n\u27e836\u27e9 https://docs.rs/num/latest/num/trait.Unsigned.html: trait num::Unsigned - Unsigned\n\u27e837\u27e9 https://docs.rs/num/latest/num/trait.Zero.html: trait num::Zero - Zero\n\u27e838\u27e9 https://docs.rs/num/latest/num/#functions: \u00a7\n\u27e839\u27e9 https://docs.rs/num/latest/num/fn.abs.html: fn num::abs - abs\n\u27e840\u27e9 https://docs.rs/num/latest/num/fn.abs_sub.html: fn num::abs_sub - abs_sub\n\u27e841\u27e9 https://docs.rs/num/latest/num/fn.cast.html: fn num::cast - cast\n\u27e842\u27e9 https://docs.rs/num/latest/num/fn.checked_pow.html: fn num::checked_pow - checked_pow\n\u27e843\u27e9 https://docs.rs/num/latest/num/fn.clamp.html: fn num::clamp - clamp\n\u27e844\u27e9 https://docs.rs/num/latest/num/fn.one.html: fn num::one - one\n\u27e845\u27e9 https://docs.rs/num/latest/num/fn.pow.html: fn num::pow - pow\n\u27e846\u27e9 https://docs.rs/num/latest/num/fn.range.html: fn num::range - range\n\u27e847\u27e9 https://docs.rs/num/latest/num/fn.range_inclusive.html: fn num::range_inclusive - start, stop) (that is, starting at start (inclusive), and ending at stop (exclusive)).\n\n[range_inclusive\n\u27e848\u27e9 https://docs.rs/num/latest/num/fn.range_step.html: fn num::range_step - range_step\n\u27e849\u27e9 https://docs.rs/num/latest/num/fn.range_step_inclusive.html: fn num::range_step_inclusive - start, stop) by `step`. It handles overflow by stopping.\n\n[range_step_inclusive\n\u27e850\u27e9 https://docs.rs/num/latest/num/fn.signum.html: fn num::signum - signum\n\u27e851\u27e9 https://docs.rs/num/latest/num/fn.zero.html: fn num::zero - zero\n\u27e852\u27e9 https://docs.rs/num/latest/num/#types: \u00a7\n\u27e853\u27e9 https://docs.rs/num/latest/num/type.BigRational.html: type num::BigRational - BigRational\n\u27e854\u27e9 https://docs.rs/num/latest/num/type.Rational.html: type num::Rational - Rational\n\u27e855\u27e9 https://docs.rs/num/latest/num/type.Rational32.html: type num::Rational32 - Rational32\n\u27e856\u27e9 https://docs.rs/num/latest/num/type.Rational64.html: type num::Rational64 - Rational64\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `num` crate provides a comprehensive collection of numeric types, traits, and utilities for Rust, including support for big integers (`BigInt`, `BigUint`), rationals (`BigRational`), complex numbers (`Complex`), and generic numeric traits like `Integer`, `Float`, and `Num`. It enables safe arithmetic operations (e.g., checked addition, subtraction, multiplication), type conversions, and range iterators, making it ideal for advanced mathematical computations and generic programming. The crate is compatible with Rust 1.60 and later.",
    "feature_summary": null,
    "use_case": "Utilities",
    "score": 8.0,
    "factual_counterfactual": "### Pair 1: Big Integer Support  \n\u2705 Factual: The `num` crate provides the `BigInt` type for working with arbitrarily large signed integers, enabling computations that exceed the size of standard integer types.  \n\u274c Counterfactual: The `num` crate only supports fixed-size integers, such as `i32` and `i64`, and does not include types for arbitrarily large integers.  \n\n---\n\n### Pair 2: Rational Numbers  \n\u2705 Factual: The `num` crate includes the `BigRational` type, which represents rational numbers with arbitrary precision using `BigInt` for the numerator and denominator.  \n\u274c Counterfactual: The `num` crate's rational number types, such as `BigRational`, only support machine-sized integers like `i32` and `i64` for the numerator and denominator.  \n\n---\n\n### Pair 3: Checked Arithmetic  \n\u2705 Factual: The `num` crate provides traits like `CheckedAdd` and `CheckedMul`, which perform arithmetic operations that return `None` on overflow instead of wrapping around.  \n\u274c Counterfactual: The `num` crate does not offer any traits or functions to handle overflow; all arithmetic operations wrap around by default.",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}