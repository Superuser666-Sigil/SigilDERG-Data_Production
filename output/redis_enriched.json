{
    "name": "redis",
    "version": "0.32.2",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/redis/latest/redis/all.html \"show sidebar\")\n# Crate redisCopy item path\n[Settings](https://docs.rs/redis/latest/settings.html)\n[Help](https://docs.rs/redis/latest/help.html)\nSummary[Source](https://docs.rs/redis/latest/src/redis/lib.rs.html#1-743)\nExpand description\nredis-rs is a Rust implementation of a client library for Redis. It exposes a general purpose interface to Redis and also provides specific helpers for commonly used functionality.\nThe crate is called `redis` and you can depend on it via cargo:\n```\n[dependencies.redis]\nversion = \"*\"\n```\n\nIf you want to use the git version:\n```\n[dependencies.redis]\ngit = \"https://github.com/redis-rs/redis-rs.git\"\n```\n\n## [\u00a7](https://docs.rs/redis/latest/redis/#basic-operation)Basic Operation\nredis-rs exposes two API levels: a low- and a high-level part. The high-level part does not expose all the functionality of redis and might take some liberties in how it speaks the protocol. The low-level part of the API allows you to express any request on the redis level. You can fluently switch between both API levels at any point.\n## [\u00a7](https://docs.rs/redis/latest/redis/#tls--ssl)TLS / SSL\nThe user can enable TLS support using either RusTLS or native support (usually OpenSSL), using the `tls-rustls` or `tls-native-tls` features respectively. In order to enable TLS for async usage, the user must enable matching features for their runtime - either `tokio-native-tls-comp`, `tokio-rustls-comp`, `async-std-native-tls-comp`, or `async-std-rustls-comp`. Additionally, the `tls-rustls-webpki-roots` allows usage of of webpki-roots for the root certificate store.\n## [\u00a7](https://docs.rs/redis/latest/redis/#tcp-settings)TCP settings\nThe user can set parameters of the underlying TCP connection by using the `tcp_nodelay` and `keep-alive` features. Alternatively, users of async connections can set [crate::io::tcp::TcpSettings](https://docs.rs/redis/latest/redis/io/tcp/struct.TcpSettings.html \"struct redis::io::tcp::TcpSettings\") on the connection configuration objects, and set the TCP parameters in a more specific manner there.\n### [\u00a7](https://docs.rs/redis/latest/redis/#connection-handling)Connection Handling\nFor connecting to redis you can use a client object which then can produce actual connections. Connections and clients as well as results of connections and clients are considered `ConnectionLike` objects and can be used anywhere a request is made.\nThe full canonical way to get a connection is to create a client and to ask for a connection from it:\n```\nextern crate redis;\nfn do_something() -> redis::RedisResult<()> {\n  let client = redis::Client::open(\"redis://127.0.0.1/\")?;\n  let mut con = client.get_connection()?;\n  /* do something here */\n  Ok(())\n}\n```\n\n### [\u00a7](https://docs.rs/redis/latest/redis/#connection-pooling)Connection Pooling\nWhen using a sync connection, it is recommended to use a connection pool in order to handle disconnects or multi-threaded usage. This can be done using the `r2d2` feature.\n```\nuse redis::Commands;\nlet client = redis::Client::open(\"redis://127.0.0.1/\").unwrap();\nlet pool = r2d2::Pool::builder().build(client).unwrap();\nlet mut conn = pool.get().unwrap();\nlet _: () = conn.set(\"KEY\", \"VALUE\").unwrap();\nlet val: String = conn.get(\"KEY\").unwrap();\n```\n\nFor async connections, connection pooling isn\u2019t necessary. The `MultiplexedConnection` is cheap to clone and can be used safely concurrently from multiple threads, so a single connection can be easily reused. For automatic reconnections consider using `ConnectionManager` with the `connection-manager` feature. Async cluster connections also don\u2019t require pooling and are thread-safe and reusable.\n### [\u00a7](https://docs.rs/redis/latest/redis/#optional-features)Optional Features\nThere are a few features defined that can enable additional functionality if so desired. Some of them are turned on by default.\n  * `acl`: enables acl support (enabled by default)\n  * `tokio-comp`: enables support for async usage with the Tokio runtime (optional)\n  * `async-std-comp`: enables support for async usage with any runtime which is async-std compliant. (optional)\n  * `smol-comp`: enables support for async usage with the Smol runtime (optional)\n  * `geospatial`: enables geospatial support (enabled by default)\n  * `script`: enables script support (enabled by default)\n  * `streams`: enables high-level interface for interaction with Redis streams (enabled by default)\n  * `r2d2`: enables r2d2 connection pool support (optional)\n  * `ahash`: enables ahash map/set support & uses ahash internally (+7-10% performance) (optional)\n  * `cluster`: enables redis cluster support (optional)\n  * `cluster-async`: enables async redis cluster support (optional)\n  * `connection-manager`: enables support for automatic reconnection (optional)\n  * `keep-alive`: enables keep-alive option on socket by means of `socket2` crate (enabled by default)\n  * `tcp_nodelay`: enables the no-delay flag on communication sockets (optional)\n  * `rust_decimal`, `bigdecimal`, `num-bigint`: enables type conversions to large number representation from different crates (optional)\n  * `uuid`: enables type conversion to UUID (optional)\n  * `sentinel`: enables high-level interfaces for communication with Redis sentinels (optional)\n  * `json`: enables high-level interfaces for communication with the JSON module (optional)\n  * `cache-aio`: enables **experimental** client side caching for MultiplexedConnection, ConnectionManager and async ClusterConnection (optional)\n  * `disable-client-setinfo`: disables the `CLIENT SETINFO` handshake during connection initialization\n\n\n### [\u00a7](https://docs.rs/redis/latest/redis/#connection-parameters)Connection Parameters\nredis-rs knows different ways to define where a connection should go. The parameter to `Client::open` needs to implement the `IntoConnectionInfo` trait of which there are three implementations:\n  * string slices in `redis://` URL format.\n  * URL objects from the redis-url crate.\n  * `ConnectionInfo` objects.\n\n\nThe URL format is `redis://[<username>][:<password>@]<hostname>[:port][/[<db>][?protocol=<protocol>]]`\nIf Unix socket support is available you can use a unix URL in this format:\n`redis+unix:///<path>[?db=<db>[&pass=<password>][&user=<username>][&protocol=<protocol>]]`\nFor compatibility with some other libraries for Redis, the \u201cunix\u201d scheme is also supported:\n`unix:///<path>[?db=<db>][&pass=<password>][&user=<username>][&protocol=<protocol>]]`\n### [\u00a7](https://docs.rs/redis/latest/redis/#executing-low-level-commands)Executing Low-Level Commands\nTo execute low-level commands you can use the `cmd` function which allows you to build redis requests. Once you have configured a command object to your liking you can send a query into any `ConnectionLike` object:\n```\nfn do_something(con: &mut redis::Connection) -> redis::RedisResult<()> {\n  redis::cmd(\"SET\").arg(\"my_key\").arg(42).exec(con)?;\n  Ok(())\n}\n```\n\nUpon querying the return value is a result object. If you do not care about the actual return value (other than that it is not a failure) you can always type annotate it to the unit type `()`.\nNote that commands with a sub-command (like \u201cMEMORY USAGE\u201d, \u201cACL WHOAMI\u201d, \u201cLATENCY HISTORY\u201d, etc) must specify the sub-command as a separate `arg`:\n```\nfn do_something(con: &mut redis::Connection) -> redis::RedisResult<usize> {\n  // This will result in a server error: \"unknown command `MEMORY USAGE`\"\n  // because \"USAGE\" is technically a sub-command of \"MEMORY\".\n  redis::cmd(\"MEMORY USAGE\").arg(\"my_key\").query::<usize>(con)?;\n  // However, this will work as you'd expect\n  redis::cmd(\"MEMORY\").arg(\"USAGE\").arg(\"my_key\").query(con)\n}\n```\n\n### [\u00a7](https://docs.rs/redis/latest/redis/#executing-high-level-commands)Executing High-Level Commands\nThe high-level interface is similar. For it to become available you need to use the `Commands` trait in which case all `ConnectionLike` objects the library provides will also have high-level methods which make working with the protocol easier:\n```\nextern crate redis;\nuse redis::Commands;\nfn do_something(con: &mut redis::Connection) -> redis::RedisResult<()> {\n  let _: () = con.set(\"my_key\", 42)?;\n  Ok(())\n}\n```\n\nNote that high-level commands are work in progress and many are still missing!\n### [\u00a7](https://docs.rs/redis/latest/redis/#type-conversions)Type Conversions\nBecause redis inherently is mostly type-less and the protocol is not exactly friendly to developers, this library provides flexible support for casting values to the intended results. This is driven through the `FromRedisValue` and `ToRedisArgs` traits.\nThe `arg` method of the command will accept a wide range of types through the `ToRedisArgs` trait and the `query` method of a command can convert the value to what you expect the function to return through the `FromRedisValue` trait. This is quite flexible and allows vectors, tuples, hashsets, hashmaps as well as optional values:\n```\nlet count : i32 = con.get(\"my_counter\")?;\nlet count = con.get(\"my_counter\").unwrap_or(0i32);\nlet k : Option<String> = con.get(\"missing_key\")?;\nlet name : String = con.get(\"my_name\")?;\nlet bin : Vec<u8> = con.get(\"my_binary\")?;\nlet map : HashMap<String, i32> = con.hgetall(\"my_hash\")?;\nlet keys : Vec<String> = con.hkeys(\"my_hash\")?;\nlet mems : HashSet<i32> = con.smembers(\"my_set\")?;\nlet (k1, k2) : (String, String) = con.get(&[\"k1\", \"k2\"])?;\n```\n\n### [\u00a7](https://docs.rs/redis/latest/redis/#pre-typed-commands)Pre-typed Commands\nIn some cases, you may not have a desired return type for a high-level command, and would instead like to use defaults provided by the library, to avoid the clutter and development overhead of specifying types for each command.\nThe library facilitates this by providing the `TypedCommands` and `AsyncTypedCommands` as alternatives to `Commands` and `AsyncCommands` respectively. These traits provide functions with pre-defined and opinionated return types. For example, `set` returns `()`, avoiding the need for developers to explicitly type each call as returning `()`.\n```\nuse redis::TypedCommands;\nfn fetch_an_integer() -> redis::RedisResult<isize> {\n  // connect to redis\n  let client = redis::Client::open(\"redis://127.0.0.1/\")?;\n  let mut con = client.get_connection()?;\n  // `set` returns a `()`, so we don't need to specify the return type manually unlike in the previous example.\n  con.set(\"my_key\", 42)?;\n  // `get_int` returns Result<Option<isize>>, as the key may not be found, or some error may occur.\n  Ok(con.get_int(\"my_key\").unwrap().unwrap())\n}\n```\n\n## [\u00a7](https://docs.rs/redis/latest/redis/#resp3-support)RESP3 support\nSince Redis / Valkey version 6, a newer communication protocol called RESP3 is supported. Using this protocol allows the user both to receive a more varied `Value` results, for users who use the low-level `Value` type, and to receive out of band messages on the same connection. This allows the user to receive PubSub messages on the same connection, instead of creating a new PubSub connection (see \u201cRESP3 async pubsub\u201d).\n## [\u00a7](https://docs.rs/redis/latest/redis/#iteration-protocol)Iteration Protocol\nIn addition to sending a single query, iterators are also supported. When used with regular bulk responses they don\u2019t give you much over querying and converting into a vector (both use a vector internally) but they can also be used with `SCAN` like commands in which case iteration will send more queries until the cursor is exhausted:\n[\u24d8](https://docs.rs/redis/latest/redis/ \"This example is not tested\")```\nlet mut iter : redis::Iter<isize> = redis::cmd(\"SSCAN\").arg(\"my_set\")\n  .cursor_arg(0).clone().iter(&mut con)?;\nfor x in iter {\n  // do something with the item\n}\n```\n\nAs you can see the cursor argument needs to be defined with `cursor_arg` instead of `arg` so that the library knows which argument needs updating as the query is run for more items.\n## [\u00a7](https://docs.rs/redis/latest/redis/#pipelining)Pipelining\nIn addition to simple queries you can also send command pipelines. This is provided through the `pipe` function. It works very similar to sending individual commands but you can send more than one in one go. This also allows you to ignore individual results so that matching on the end result is easier:\n```\nlet (k1, k2) : (i32, i32) = redis::pipe()\n  .cmd(\"SET\").arg(\"key_1\").arg(42).ignore()\n  .cmd(\"SET\").arg(\"key_2\").arg(43).ignore()\n  .cmd(\"GET\").arg(\"key_1\")\n  .cmd(\"GET\").arg(\"key_2\").query(&mut con)?;\n```\n\nIf you want the pipeline to be wrapped in a `MULTI`/`EXEC` block you can easily do that by switching the pipeline into `atomic` mode. From the caller\u2019s point of view nothing changes, the pipeline itself will take care of the rest for you:\n```\nlet (k1, k2) : (i32, i32) = redis::pipe()\n  .atomic()\n  .cmd(\"SET\").arg(\"key_1\").arg(42).ignore()\n  .cmd(\"SET\").arg(\"key_2\").arg(43).ignore()\n  .cmd(\"GET\").arg(\"key_1\")\n  .cmd(\"GET\").arg(\"key_2\").query(&mut con)?;\n```\n\nYou can also use high-level commands on pipelines:\n```\nlet (k1, k2) : (i32, i32) = redis::pipe()\n  .atomic()\n  .set(\"key_1\", 42).ignore()\n  .set(\"key_2\", 43).ignore()\n  .get(\"key_1\")\n  .get(\"key_2\").query(&mut con)?;\n```\n\n## [\u00a7](https://docs.rs/redis/latest/redis/#transactions)Transactions\nTransactions are available through atomic pipelines. In order to use them in a more simple way you can use the `transaction` function of a connection:\n```\nuse redis::Commands;\nlet key = \"the_key\";\nlet (new_val,) : (isize,) = redis::transaction(&mut con, &[key], |con, pipe| {\n  let old_val : isize = con.get(key)?;\n  pipe\n    .set(key, old_val + 1).ignore()\n    .get(key).query(con)\n})?;\nprintln!(\"The incremented number is: {}\", new_val);\n```\n\nFor more information see the `transaction` function.\n## [\u00a7](https://docs.rs/redis/latest/redis/#pubsub)PubSub\nPubsub is provided through the `PubSub` connection object for sync usage, or the `aio::PubSub` for async usage.\nExample usage:\n```\nlet client = redis::Client::open(\"redis://127.0.0.1/\")?;\nlet mut con = client.get_connection()?;\nlet mut pubsub = con.as_pubsub();\npubsub.subscribe(&[\"channel_1\", \"channel_2\"])?;\nloop {\n  let msg = pubsub.get_message()?;\n  let payload : String = msg.get_payload()?;\n  println!(\"channel '{}': {}\", msg.get_channel_name(), payload);\n}\n```\n\nIn order to update subscriptions while concurrently waiting for messages, the async PubSub can be split into separate sink & stream components. The sink can be receive subscription requests while the stream is awaited for messages.\n```\nuse futures_util::StreamExt;\nlet client = redis::Client::open(\"redis://127.0.0.1/\")?;\nlet (mut sink, mut stream) = client.get_async_pubsub().await?.split();\nsink.subscribe(\"channel_1\").await?;\nloop {\n  let msg = stream.next().await.unwrap();\n  let payload : String = msg.get_payload().unwrap();\n  println!(\"channel '{}': {}\", msg.get_channel_name(), payload);\n}\n```\n\n### [\u00a7](https://docs.rs/redis/latest/redis/#resp3-async-pubsub)RESP3 async pubsub\nIf you\u2019re targeting a Redis/Valkey server of version 6 or above, you can receive pubsub messages from it without creating another connection, by setting a push sender on the connection.\n```\n\nlet client = redis::Client::open(\"redis://127.0.0.1/?protocol=resp3\").unwrap();\nlet (tx, mut rx) = tokio::sync::mpsc::unbounded_channel();\nlet config = redis::AsyncConnectionConfig::new().set_push_sender(tx);\nlet mut con = client.get_multiplexed_async_connection_with_config(&config).await?;\ncon.subscribe(&[\"channel_1\", \"channel_2\"]).await?;\nloop {\n println!(\"Received {:?}\", rx.recv().await.unwrap());\n}\n```\n\n## [\u00a7](https://docs.rs/redis/latest/redis/#scripts)Scripts\nLua scripts are supported through the `Script` type in a convenient way. It will automatically load the script if it does not exist and invoke it.\nExample:\n```\nlet script = redis::Script::new(r\"\n  return tonumber(ARGV[1]) + tonumber(ARGV[2]);\n\");\nlet result: isize = script.arg(1).arg(2).invoke(&mut con)?;\nassert_eq!(result, 3);\n```\n\nScripts can also be pipelined:\n```\nlet script = redis::Script::new(r\"\n  return tonumber(ARGV[1]) + tonumber(ARGV[2]);\n\");\nlet (a, b): (isize, isize) = redis::pipe()\n  .invoke_script(script.arg(1).arg(2))\n  .invoke_script(script.arg(2).arg(3))\n  .query(&mut con)?;\nassert_eq!(a, 3);\nassert_eq!(b, 5);\n```\n\nNote: unlike a call to [`invoke`](https://docs.rs/redis/latest/redis/struct.ScriptInvocation.html#method.invoke \"method redis::ScriptInvocation::invoke\"), if the script isn\u2019t loaded during the pipeline operation, it will not automatically be loaded and retried. The script can be loaded using the [`load`](https://docs.rs/redis/latest/redis/struct.ScriptInvocation.html#method.load \"method redis::ScriptInvocation::load\") operation.\n## [\u00a7](https://docs.rs/redis/latest/redis/#async)Async\nIn addition to the synchronous interface that\u2019s been explained above there also exists an asynchronous interface based on [`futures`](https://crates.io/crates/futures) and [`tokio`](https://tokio.rs), [`smol`](https://docs.rs/smol/latest/smol/), or [`async-std`](https://async.rs/). All async connections are cheap to clone, and clones can be used concurrently from multiple threads.\nThis interface exists under the `aio` (async io) module (which requires that the `aio` feature is enabled) and largely mirrors the synchronous with a few concessions to make it fit the constraints of `futures`.\n```\nuse futures::prelude::*;\nuse redis::AsyncCommands;\nlet client = redis::Client::open(\"redis://127.0.0.1/\").unwrap();\nlet mut con = client.get_multiplexed_async_connection().await?;\nlet _: () = con.set(\"key1\", b\"foo\").await?;\nredis::cmd(\"SET\").arg(&[\"key2\", \"bar\"]).exec_async(&mut con).await?;\nlet result = redis::cmd(\"MGET\")\n .arg(&[\"key1\", \"key2\"])\n .query_async(&mut con)\n .await;\nassert_eq!(result, Ok((\"foo\".to_string(), b\"bar\".to_vec())));\n```\n\n### [\u00a7](https://docs.rs/redis/latest/redis/#runtime-support)Runtime support\nThe crate supports multiple runtimes, including `tokio`, `async-std`, and `smol`. For Tokio, the crate will spawn tasks on the current thread runtime. For async-std & smol, the crate will spawn tasks on the the global runtime. It is recommended that the crate be used with support only for a single runtime. If the crate is compiled with multiple runtimes, the user should call [`crate::aio::prefer_tokio`](https://docs.rs/redis/latest/redis/aio/fn.prefer_tokio.html \"fn redis::aio::prefer_tokio\"), [`crate::aio::prefer_async_std`](https://docs.rs/redis/latest/redis/aio/fn.prefer_async_std.html \"fn redis::aio::prefer_async_std\") or [`crate::aio::prefer_smol`](https://docs.rs/redis/latest/redis/aio/fn.prefer_smol.html \"fn redis::aio::prefer_smol\") to set the preferred runtime. These functions set global state which automatically chooses the correct runtime for the async connection.\n## [\u00a7](https://docs.rs/redis/latest/redis/#sentinel)Sentinel\nSentinel types allow users to connect to Redis sentinels and find primaries and replicas.\n```\nuse redis::{ Commands, RedisConnectionInfo };\nuse redis::sentinel::{ SentinelServerType, SentinelClient, SentinelNodeConnectionInfo };\nlet nodes = vec![\"redis://127.0.0.1:6379/\", \"redis://127.0.0.1:6378/\", \"redis://127.0.0.1:6377/\"];\nlet mut sentinel = SentinelClient::build(\n  nodes,\n  String::from(\"primary1\"),\n  Some(SentinelNodeConnectionInfo {\n    tls_mode: Some(redis::TlsMode::Insecure),\n    redis_connection_info: None,\n  }),\n  redis::sentinel::SentinelServerType::Master,\n)\n.unwrap();\nlet primary = sentinel.get_connection().unwrap();\n```\n\nAn async API also exists:\n```\nuse futures::prelude::*;\nuse redis::{ Commands, RedisConnectionInfo };\nuse redis::sentinel::{ SentinelServerType, SentinelClient, SentinelNodeConnectionInfo };\nlet nodes = vec![\"redis://127.0.0.1:6379/\", \"redis://127.0.0.1:6378/\", \"redis://127.0.0.1:6377/\"];\nlet mut sentinel = SentinelClient::build(\n  nodes,\n  String::from(\"primary1\"),\n  Some(SentinelNodeConnectionInfo {\n    tls_mode: Some(redis::TlsMode::Insecure),\n    redis_connection_info: None,\n  }),\n  redis::sentinel::SentinelServerType::Master,\n)\n.unwrap();\nlet primary = sentinel.get_async_connection().await.unwrap();\n```\n\n## Modules[\u00a7](https://docs.rs/redis/latest/redis/#modules)\n\n[acl](https://docs.rs/redis/latest/redis/acl/index.html \"mod redis::acl\")`acl`\n    Defines types to use with the ACL commands.\n\n[aio](https://docs.rs/redis/latest/redis/aio/index.html \"mod redis::aio\")`aio`\n    Adds async IO support to redis.\n\n[caching](https://docs.rs/redis/latest/redis/caching/index.html \"mod redis::caching\")`cache-aio`\n    This module provides **experimental** support for Server-assisted client-side caching in Redis.\n\n[cluster](https://docs.rs/redis/latest/redis/cluster/index.html \"mod redis::cluster\")`cluster`\n    This module extends the library to support Redis Cluster.\n\n[cluster_async](https://docs.rs/redis/latest/redis/cluster_async/index.html \"mod redis::cluster_async\")`cluster` and `aio`\n    This module provides async functionality for connecting to Redis / Valkey Clusters.\n\n[cluster_routing](https://docs.rs/redis/latest/redis/cluster_routing/index.html \"mod redis::cluster_routing\")`cluster`\n    Routing information for cluster commands.\n\n[geo](https://docs.rs/redis/latest/redis/geo/index.html \"mod redis::geo\")`geospatial`\n    Defines types to use with the geospatial commands.\n\n[io](https://docs.rs/redis/latest/redis/io/index.html \"mod redis::io\")\n    Module for defining I/O behavior.\n\n[sentinel](https://docs.rs/redis/latest/redis/sentinel/index.html \"mod redis::sentinel\")`sentinel`\n    Defines a Sentinel type that connects to Redis sentinels and creates clients to master or replica nodes.\n\n[streams](https://docs.rs/redis/latest/redis/streams/index.html \"mod redis::streams\")`streams`\n    Defines types to use with the streams commands.\n## Structs[\u00a7](https://docs.rs/redis/latest/redis/#structs)\n\n[AsyncConnectionConfig](https://docs.rs/redis/latest/redis/struct.AsyncConnectionConfig.html \"struct redis::AsyncConnectionConfig\")\n    Options for creation of async connection\n\n[AsyncIter](https://docs.rs/redis/latest/redis/struct.AsyncIter.html \"struct redis::AsyncIter\")`aio`\n    Represents a redis iterator that can be used with async connections.\n\n[Client](https://docs.rs/redis/latest/redis/struct.Client.html \"struct redis::Client\")\n    The client type.\n\n[ClientTlsConfig](https://docs.rs/redis/latest/redis/struct.ClientTlsConfig.html \"struct redis::ClientTlsConfig\")`tls-rustls`\n    Structure to hold mTLS client _certificate_ and _key_ binaries in PEM format\n\n[Cmd](https://docs.rs/redis/latest/redis/struct.Cmd.html \"struct redis::Cmd\")\n    Represents redis commands.\n\n[CommandCacheConfig](https://docs.rs/redis/latest/redis/struct.CommandCacheConfig.html \"struct redis::CommandCacheConfig\")\n    CommandCacheConfig is used to define caching behaviour of individual commands.\n\n[Connection](https://docs.rs/redis/latest/redis/struct.Connection.html \"struct redis::Connection\")\n    Represents a stateful redis TCP connection.\n\n[ConnectionInfo](https://docs.rs/redis/latest/redis/struct.ConnectionInfo.html \"struct redis::ConnectionInfo\")\n    Holds the connection information that redis should use for connecting.\n\n[CopyOptions](https://docs.rs/redis/latest/redis/struct.CopyOptions.html \"struct redis::CopyOptions\")\n    Options for the [COPY](https://redis.io/commands/copy) command\n\n[FlushAllOptions](https://docs.rs/redis/latest/redis/struct.FlushAllOptions.html \"struct redis::FlushAllOptions\")\n    Options for the [FLUSHALL](https://redis.io/commands/flushall) command\n\n[HashFieldExpirationOptions](https://docs.rs/redis/latest/redis/struct.HashFieldExpirationOptions.html \"struct redis::HashFieldExpirationOptions\")\n    Options for the HSETEX command\n\n[InfoDict](https://docs.rs/redis/latest/redis/struct.InfoDict.html \"struct redis::InfoDict\")\n    An info dictionary type.\n\n[Iter](https://docs.rs/redis/latest/redis/struct.Iter.html \"struct redis::Iter\")\n    Represents a redis iterator.\n\n[LposOptions](https://docs.rs/redis/latest/redis/struct.LposOptions.html \"struct redis::LposOptions\")\n    Options for the [LPOS](https://redis.io/commands/lpos) command\n\n[Msg](https://docs.rs/redis/latest/redis/struct.Msg.html \"struct redis::Msg\")\n    Represents a pubsub message.\n\n[Parser](https://docs.rs/redis/latest/redis/struct.Parser.html \"struct redis::Parser\")\n    The internal redis response parser.\n\n[Pipeline](https://docs.rs/redis/latest/redis/struct.Pipeline.html \"struct redis::Pipeline\")\n    Represents a redis command pipeline.\n\n[PubSub](https://docs.rs/redis/latest/redis/struct.PubSub.html \"struct redis::PubSub\")\n    Represents a pubsub connection.\n\n[PushInfo](https://docs.rs/redis/latest/redis/struct.PushInfo.html \"struct redis::PushInfo\")\n    A push message from the server.\n\n[RedisConnectionInfo](https://docs.rs/redis/latest/redis/struct.RedisConnectionInfo.html \"struct redis::RedisConnectionInfo\")\n    Redis specific/connection independent information used to establish a connection to redis.\n\n[RedisError](https://docs.rs/redis/latest/redis/struct.RedisError.html \"struct redis::RedisError\")\n    Represents a redis error.\n\n[ReplicaInfo](https://docs.rs/redis/latest/redis/struct.ReplicaInfo.html \"struct redis::ReplicaInfo\")\n    Replication information for a replica, as returned by the [`ROLE`](https://redis.io/docs/latest/commands/role/) command.\n\n[ScanOptions](https://docs.rs/redis/latest/redis/struct.ScanOptions.html \"struct redis::ScanOptions\")\n    Options for the [SCAN](https://redis.io/commands/scan) command\n\n[Script](https://docs.rs/redis/latest/redis/struct.Script.html \"struct redis::Script\")`script`\n    Represents a lua script.\n\n[ScriptInvocation](https://docs.rs/redis/latest/redis/struct.ScriptInvocation.html \"struct redis::ScriptInvocation\")`script`\n    Represents a prepared script call.\n\n[SetOptions](https://docs.rs/redis/latest/redis/struct.SetOptions.html \"struct redis::SetOptions\")\n    Options for the [SET](https://redis.io/commands/set) command\n\n[SortedSetAddOptions](https://docs.rs/redis/latest/redis/struct.SortedSetAddOptions.html \"struct redis::SortedSetAddOptions\")\n    Options for the [ZADD](https://redis.io/commands/zadd) command\n\n[TlsCertificates](https://docs.rs/redis/latest/redis/struct.TlsCertificates.html \"struct redis::TlsCertificates\")`tls-rustls`\n    Structure to hold TLS certificates\n## Enums[\u00a7](https://docs.rs/redis/latest/redis/#enums)\n\n[Arg](https://docs.rs/redis/latest/redis/enum.Arg.html \"enum redis::Arg\")\n    An argument to a redis command\n\n[ConnectionAddr](https://docs.rs/redis/latest/redis/enum.ConnectionAddr.html \"enum redis::ConnectionAddr\")\n    Defines the connection address.\n\n[ControlFlow](https://docs.rs/redis/latest/redis/enum.ControlFlow.html \"enum redis::ControlFlow\")\n    Allows pubsub callbacks to stop receiving messages.\n\n[Direction](https://docs.rs/redis/latest/redis/enum.Direction.html \"enum redis::Direction\")\n    Enum for the LEFT | RIGHT args used by some commands\n\n[ErrorKind](https://docs.rs/redis/latest/redis/enum.ErrorKind.html \"enum redis::ErrorKind\")\n    An enum of all error kinds.\n\n[ExistenceCheck](https://docs.rs/redis/latest/redis/enum.ExistenceCheck.html \"enum redis::ExistenceCheck\")\n    Helper enum that is used to define existence checks\n\n[ExpireOption](https://docs.rs/redis/latest/redis/enum.ExpireOption.html \"enum redis::ExpireOption\")\n    Helper enum that is used to define option for the hash expire commands\n\n[Expiry](https://docs.rs/redis/latest/redis/enum.Expiry.html \"enum redis::Expiry\")\n    Helper enum that is used to define expiry time\n\n[FieldExistenceCheck](https://docs.rs/redis/latest/redis/enum.FieldExistenceCheck.html \"enum redis::FieldExistenceCheck\")\n    Helper enum that is used to define field existence checks\n\n[IntegerReplyOrNoOp](https://docs.rs/redis/latest/redis/enum.IntegerReplyOrNoOp.html \"enum redis::IntegerReplyOrNoOp\")\n    Returned by typed commands which either return a positive integer or some negative integer indicating some kind of no-op.\n\n[NumericBehavior](https://docs.rs/redis/latest/redis/enum.NumericBehavior.html \"enum redis::NumericBehavior\")\n    Helper enum that is used in some situations to describe the behavior of arguments in a numeric context.\n\n[ProtocolVersion](https://docs.rs/redis/latest/redis/enum.ProtocolVersion.html \"enum redis::ProtocolVersion\")\n    Enum representing the communication protocol with the server.\n\n[PushKind](https://docs.rs/redis/latest/redis/enum.PushKind.html \"enum redis::PushKind\")\n    `Push` type\u2019s currently known kinds.\n\n[RetryMethod](https://docs.rs/redis/latest/redis/enum.RetryMethod.html \"enum redis::RetryMethod\")\n    What method should be used if retrying this request.\n\n[Role](https://docs.rs/redis/latest/redis/enum.Role.html \"enum redis::Role\")\n    High level representation of response to the [`ROLE`](https://redis.io/docs/latest/commands/role/) command.\n\n[SetExpiry](https://docs.rs/redis/latest/redis/enum.SetExpiry.html \"enum redis::SetExpiry\")\n    Helper enum that is used to define expiry time for SET command\n\n[TlsMode](https://docs.rs/redis/latest/redis/enum.TlsMode.html \"enum redis::TlsMode\")\n    TlsMode indicates use or do not use verification of certification.\n\n[UpdateCheck](https://docs.rs/redis/latest/redis/enum.UpdateCheck.html \"enum redis::UpdateCheck\")\n    Helper enum that is used to define update checks\n\n[Value](https://docs.rs/redis/latest/redis/enum.Value.html \"enum redis::Value\")\n    Internal low-level redis value enum.\n\n[ValueType](https://docs.rs/redis/latest/redis/enum.ValueType.html \"enum redis::ValueType\")\n    Possible types of value held in Redis: [Redis Docs](https://redis.io/docs/latest/commands/type/)\n\n[VerbatimFormat](https://docs.rs/redis/latest/redis/enum.VerbatimFormat.html \"enum redis::VerbatimFormat\")\n    `VerbatimString`\u2019s format types defined by spec\n## Traits[\u00a7](https://docs.rs/redis/latest/redis/#traits)\n\n[AsyncCommands](https://docs.rs/redis/latest/redis/trait.AsyncCommands.html \"trait redis::AsyncCommands\")`aio`\n    Implements common redis commands over asynchronous connections.\n\n[AsyncTypedCommands](https://docs.rs/redis/latest/redis/trait.AsyncTypedCommands.html \"trait redis::AsyncTypedCommands\")`aio`\n    Implements common redis commands over asynchronous connections. The return types are concrete and opinionated. If you want to choose the return type you should use the `AsyncCommands` trait.\n\n[Commands](https://docs.rs/redis/latest/redis/trait.Commands.html \"trait redis::Commands\")\n    Implements common redis commands for connection like objects.\n\n[ConnectionLike](https://docs.rs/redis/latest/redis/trait.ConnectionLike.html \"trait redis::ConnectionLike\")\n    Implements the \u201cstateless\u201d part of the connection interface that is used by the different objects in redis-rs.\n\n[FromRedisValue](https://docs.rs/redis/latest/redis/trait.FromRedisValue.html \"trait redis::FromRedisValue\")\n    This trait is used to convert a redis value into a more appropriate type.\n\n[IntoConnectionInfo](https://docs.rs/redis/latest/redis/trait.IntoConnectionInfo.html \"trait redis::IntoConnectionInfo\")\n    Converts an object into a connection info struct. This allows the constructor of the client to accept connection information in a range of different formats.\n\n[JsonAsyncCommands](https://docs.rs/redis/latest/redis/trait.JsonAsyncCommands.html \"trait redis::JsonAsyncCommands\")`json` and `aio`\n    Implements RedisJSON commands over asynchronous connections. This allows you to send commands straight to a connection or client.\n\n[JsonCommands](https://docs.rs/redis/latest/redis/trait.JsonCommands.html \"trait redis::JsonCommands\")`json`\n    Implements RedisJSON commands for connection like objects. This allows you to send commands straight to a connection or client. It is also implemented for redis results of clients which makes for very convenient access in some basic cases.\n\n[PubSubCommands](https://docs.rs/redis/latest/redis/trait.PubSubCommands.html \"trait redis::PubSubCommands\")\n    The PubSub trait allows subscribing to one or more channels and receiving a callback whenever a message arrives.\n\n[RedisWrite](https://docs.rs/redis/latest/redis/trait.RedisWrite.html \"trait redis::RedisWrite\")\n    Abstraction trait for redis command abstractions.\n\n[ToRedisArgs](https://docs.rs/redis/latest/redis/trait.ToRedisArgs.html \"trait redis::ToRedisArgs\")\n    Used to convert a value into one or multiple redis argument strings. Most values will produce exactly one item but in some cases it might make sense to produce more than one.\n\n[TypedCommands](https://docs.rs/redis/latest/redis/trait.TypedCommands.html \"trait redis::TypedCommands\")\n    Implements common redis commands. The return types are concrete and opinionated. If you want to choose the return type you should use the `Commands` trait.\n## Functions[\u00a7](https://docs.rs/redis/latest/redis/#functions)\n\n[cmd](https://docs.rs/redis/latest/redis/fn.cmd.html \"fn redis::cmd\")\n    Shortcut function to creating a command with a single argument.\n\n[from_owned_redis_value](https://docs.rs/redis/latest/redis/fn.from_owned_redis_value.html \"fn redis::from_owned_redis_value\")\n    A shortcut function to invoke `FromRedisValue::from_owned_redis_value` to make the API slightly nicer.\n\n[from_redis_value](https://docs.rs/redis/latest/redis/fn.from_redis_value.html \"fn redis::from_redis_value\")\n    A shortcut function to invoke `FromRedisValue::from_redis_value` to make the API slightly nicer.\n\n[make_extension_error](https://docs.rs/redis/latest/redis/fn.make_extension_error.html \"fn redis::make_extension_error\")\n    Creates a new Redis error with the `ExtensionError` kind.\n\n[pack_command](https://docs.rs/redis/latest/redis/fn.pack_command.html \"fn redis::pack_command\")\n    Packs a bunch of commands into a request.\n\n[parse_redis_url](https://docs.rs/redis/latest/redis/fn.parse_redis_url.html \"fn redis::parse_redis_url\")\n    This function takes a redis URL string and parses it into a URL as used by rust-url.\n\n[parse_redis_value](https://docs.rs/redis/latest/redis/fn.parse_redis_value.html \"fn redis::parse_redis_value\")\n    Parses bytes into a redis value.\n\n[parse_redis_value_async](https://docs.rs/redis/latest/redis/fn.parse_redis_value_async.html \"fn redis::parse_redis_value_async\")`aio`\n    Parses a redis value asynchronously.\n\n[pipe](https://docs.rs/redis/latest/redis/fn.pipe.html \"fn redis::pipe\")\n    Shortcut for creating a new pipeline.\n\n[transaction](https://docs.rs/redis/latest/redis/fn.transaction.html \"fn redis::transaction\")\n    This function simplifies transaction management slightly. What it does is automatically watching keys and then going into a transaction loop util it succeeds. Once it goes through the results are returned.\n## Type Aliases[\u00a7](https://docs.rs/redis/latest/redis/#types)\n\n[FlushDbOptions](https://docs.rs/redis/latest/redis/type.FlushDbOptions.html \"type redis::FlushDbOptions\")\n    Options for the [FLUSHDB](https://redis.io/commands/flushdb) command\n\n[RedisFuture](https://docs.rs/redis/latest/redis/type.RedisFuture.html \"type redis::RedisFuture\")`aio`\n    Library generic future type.\n\n[RedisResult](https://docs.rs/redis/latest/redis/type.RedisResult.html \"type redis::RedisResult\")\n    Library generic result type.\n",
        "markdown_with_citations": "[](https://docs.rs/redis/latest/redis/all.html \"show sidebar\")\n# Crate redisCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nredis-rs is a Rust implementation of a client library for Redis. It exposes a general purpose interface to Redis and also provides specific helpers for commonly used functionality.\nThe crate is called `redis` and you can depend on it via cargo:\n```\n[dependencies.redis]\nversion = \"*\"\n```\n\nIf you want to use the git version:\n```\n[dependencies.redis]\ngit = \"https://github.com/redis-rs/redis-rs.git\"\n```\n\n## \u00a7\u27e84\u27e9Basic Operation\nredis-rs exposes two API levels: a low- and a high-level part. The high-level part does not expose all the functionality of redis and might take some liberties in how it speaks the protocol. The low-level part of the API allows you to express any request on the redis level. You can fluently switch between both API levels at any point.\n## \u00a7\u27e85\u27e9TLS / SSL\nThe user can enable TLS support using either RusTLS or native support (usually OpenSSL), using the `tls-rustls` or `tls-native-tls` features respectively. In order to enable TLS for async usage, the user must enable matching features for their runtime - either `tokio-native-tls-comp`, `tokio-rustls-comp`, `async-std-native-tls-comp`, or `async-std-rustls-comp`. Additionally, the `tls-rustls-webpki-roots` allows usage of of webpki-roots for the root certificate store.\n## \u00a7\u27e86\u27e9TCP settings\nThe user can set parameters of the underlying TCP connection by using the `tcp_nodelay` and `keep-alive` features. Alternatively, users of async connections can set crate::io::tcp::TcpSettings\u27e87\u27e9 on the connection configuration objects, and set the TCP parameters in a more specific manner there.\n### \u00a7\u27e88\u27e9Connection Handling\nFor connecting to redis you can use a client object which then can produce actual connections. Connections and clients as well as results of connections and clients are considered `ConnectionLike` objects and can be used anywhere a request is made.\nThe full canonical way to get a connection is to create a client and to ask for a connection from it:\n```\nextern crate redis;\nfn do_something() -> redis::RedisResult<()> {\n  let client = redis::Client::open(\"redis://127.0.0.1/\")?;\n  let mut con = client.get_connection()?;\n  /* do something here */\n  Ok(())\n}\n```\n\n### \u00a7\u27e89\u27e9Connection Pooling\nWhen using a sync connection, it is recommended to use a connection pool in order to handle disconnects or multi-threaded usage. This can be done using the `r2d2` feature.\n```\nuse redis::Commands;\nlet client = redis::Client::open(\"redis://127.0.0.1/\").unwrap();\nlet pool = r2d2::Pool::builder().build(client).unwrap();\nlet mut conn = pool.get().unwrap();\nlet _: () = conn.set(\"KEY\", \"VALUE\").unwrap();\nlet val: String = conn.get(\"KEY\").unwrap();\n```\n\nFor async connections, connection pooling isn\u2019t necessary. The `MultiplexedConnection` is cheap to clone and can be used safely concurrently from multiple threads, so a single connection can be easily reused. For automatic reconnections consider using `ConnectionManager` with the `connection-manager` feature. Async cluster connections also don\u2019t require pooling and are thread-safe and reusable.\n### \u00a7\u27e810\u27e9Optional Features\nThere are a few features defined that can enable additional functionality if so desired. Some of them are turned on by default.\n  * `acl`: enables acl support (enabled by default)\n  * `tokio-comp`: enables support for async usage with the Tokio runtime (optional)\n  * `async-std-comp`: enables support for async usage with any runtime which is async-std compliant. (optional)\n  * `smol-comp`: enables support for async usage with the Smol runtime (optional)\n  * `geospatial`: enables geospatial support (enabled by default)\n  * `script`: enables script support (enabled by default)\n  * `streams`: enables high-level interface for interaction with Redis streams (enabled by default)\n  * `r2d2`: enables r2d2 connection pool support (optional)\n  * `ahash`: enables ahash map/set support & uses ahash internally (+7-10% performance) (optional)\n  * `cluster`: enables redis cluster support (optional)\n  * `cluster-async`: enables async redis cluster support (optional)\n  * `connection-manager`: enables support for automatic reconnection (optional)\n  * `keep-alive`: enables keep-alive option on socket by means of `socket2` crate (enabled by default)\n  * `tcp_nodelay`: enables the no-delay flag on communication sockets (optional)\n  * `rust_decimal`, `bigdecimal`, `num-bigint`: enables type conversions to large number representation from different crates (optional)\n  * `uuid`: enables type conversion to UUID (optional)\n  * `sentinel`: enables high-level interfaces for communication with Redis sentinels (optional)\n  * `json`: enables high-level interfaces for communication with the JSON module (optional)\n  * `cache-aio`: enables **experimental** client side caching for MultiplexedConnection, ConnectionManager and async ClusterConnection (optional)\n  * `disable-client-setinfo`: disables the `CLIENT SETINFO` handshake during connection initialization\n\n\n### \u00a7\u27e811\u27e9Connection Parameters\nredis-rs knows different ways to define where a connection should go. The parameter to `Client::open` needs to implement the `IntoConnectionInfo` trait of which there are three implementations:\n  * string slices in `redis://` URL format.\n  * URL objects from the redis-url crate.\n  * `ConnectionInfo` objects.\n\n\nThe URL format is `redis://[<username>][:<password>@]<hostname>[:port][/[<db>][?protocol=<protocol>]]`\nIf Unix socket support is available you can use a unix URL in this format:\n`redis+unix:///<path>[?db=<db>[&pass=<password>][&user=<username>][&protocol=<protocol>]]`\nFor compatibility with some other libraries for Redis, the \u201cunix\u201d scheme is also supported:\n`unix:///<path>[?db=<db>][&pass=<password>][&user=<username>][&protocol=<protocol>]]`\n### \u00a7\u27e812\u27e9Executing Low-Level Commands\nTo execute low-level commands you can use the `cmd` function which allows you to build redis requests. Once you have configured a command object to your liking you can send a query into any `ConnectionLike` object:\n```\nfn do_something(con: &mut redis::Connection) -> redis::RedisResult<()> {\n  redis::cmd(\"SET\").arg(\"my_key\").arg(42).exec(con)?;\n  Ok(())\n}\n```\n\nUpon querying the return value is a result object. If you do not care about the actual return value (other than that it is not a failure) you can always type annotate it to the unit type `()`.\nNote that commands with a sub-command (like \u201cMEMORY USAGE\u201d, \u201cACL WHOAMI\u201d, \u201cLATENCY HISTORY\u201d, etc) must specify the sub-command as a separate `arg`:\n```\nfn do_something(con: &mut redis::Connection) -> redis::RedisResult<usize> {\n  // This will result in a server error: \"unknown command `MEMORY USAGE`\"\n  // because \"USAGE\" is technically a sub-command of \"MEMORY\".\n  redis::cmd(\"MEMORY USAGE\").arg(\"my_key\").query::<usize>(con)?;\n  // However, this will work as you'd expect\n  redis::cmd(\"MEMORY\").arg(\"USAGE\").arg(\"my_key\").query(con)\n}\n```\n\n### \u00a7\u27e813\u27e9Executing High-Level Commands\nThe high-level interface is similar. For it to become available you need to use the `Commands` trait in which case all `ConnectionLike` objects the library provides will also have high-level methods which make working with the protocol easier:\n```\nextern crate redis;\nuse redis::Commands;\nfn do_something(con: &mut redis::Connection) -> redis::RedisResult<()> {\n  let _: () = con.set(\"my_key\", 42)?;\n  Ok(())\n}\n```\n\nNote that high-level commands are work in progress and many are still missing!\n### \u00a7\u27e814\u27e9Type Conversions\nBecause redis inherently is mostly type-less and the protocol is not exactly friendly to developers, this library provides flexible support for casting values to the intended results. This is driven through the `FromRedisValue` and `ToRedisArgs` traits.\nThe `arg` method of the command will accept a wide range of types through the `ToRedisArgs` trait and the `query` method of a command can convert the value to what you expect the function to return through the `FromRedisValue` trait. This is quite flexible and allows vectors, tuples, hashsets, hashmaps as well as optional values:\n```\nlet count : i32 = con.get(\"my_counter\")?;\nlet count = con.get(\"my_counter\").unwrap_or(0i32);\nlet k : Option<String> = con.get(\"missing_key\")?;\nlet name : String = con.get(\"my_name\")?;\nlet bin : Vec<u8> = con.get(\"my_binary\")?;\nlet map : HashMap<String, i32> = con.hgetall(\"my_hash\")?;\nlet keys : Vec<String> = con.hkeys(\"my_hash\")?;\nlet mems : HashSet<i32> = con.smembers(\"my_set\")?;\nlet (k1, k2) : (String, String) = con.get(&[\"k1\", \"k2\"])?;\n```\n\n### \u00a7\u27e815\u27e9Pre-typed Commands\nIn some cases, you may not have a desired return type for a high-level command, and would instead like to use defaults provided by the library, to avoid the clutter and development overhead of specifying types for each command.\nThe library facilitates this by providing the `TypedCommands` and `AsyncTypedCommands` as alternatives to `Commands` and `AsyncCommands` respectively. These traits provide functions with pre-defined and opinionated return types. For example, `set` returns `()`, avoiding the need for developers to explicitly type each call as returning `()`.\n```\nuse redis::TypedCommands;\nfn fetch_an_integer() -> redis::RedisResult<isize> {\n  // connect to redis\n  let client = redis::Client::open(\"redis://127.0.0.1/\")?;\n  let mut con = client.get_connection()?;\n  // `set` returns a `()`, so we don't need to specify the return type manually unlike in the previous example.\n  con.set(\"my_key\", 42)?;\n  // `get_int` returns Result<Option<isize>>, as the key may not be found, or some error may occur.\n  Ok(con.get_int(\"my_key\").unwrap().unwrap())\n}\n```\n\n## \u00a7\u27e816\u27e9RESP3 support\nSince Redis / Valkey version 6, a newer communication protocol called RESP3 is supported. Using this protocol allows the user both to receive a more varied `Value` results, for users who use the low-level `Value` type, and to receive out of band messages on the same connection. This allows the user to receive PubSub messages on the same connection, instead of creating a new PubSub connection (see \u201cRESP3 async pubsub\u201d).\n## \u00a7\u27e817\u27e9Iteration Protocol\nIn addition to sending a single query, iterators are also supported. When used with regular bulk responses they don\u2019t give you much over querying and converting into a vector (both use a vector internally) but they can also be used with `SCAN` like commands in which case iteration will send more queries until the cursor is exhausted:\n\u24d8\u27e818\u27e9```\nlet mut iter : redis::Iter<isize> = redis::cmd(\"SSCAN\").arg(\"my_set\")\n  .cursor_arg(0).clone().iter(&mut con)?;\nfor x in iter {\n  // do something with the item\n}\n```\n\nAs you can see the cursor argument needs to be defined with `cursor_arg` instead of `arg` so that the library knows which argument needs updating as the query is run for more items.\n## \u00a7\u27e819\u27e9Pipelining\nIn addition to simple queries you can also send command pipelines. This is provided through the `pipe` function. It works very similar to sending individual commands but you can send more than one in one go. This also allows you to ignore individual results so that matching on the end result is easier:\n```\nlet (k1, k2) : (i32, i32) = redis::pipe()\n  .cmd(\"SET\").arg(\"key_1\").arg(42).ignore()\n  .cmd(\"SET\").arg(\"key_2\").arg(43).ignore()\n  .cmd(\"GET\").arg(\"key_1\")\n  .cmd(\"GET\").arg(\"key_2\").query(&mut con)?;\n```\n\nIf you want the pipeline to be wrapped in a `MULTI`/`EXEC` block you can easily do that by switching the pipeline into `atomic` mode. From the caller\u2019s point of view nothing changes, the pipeline itself will take care of the rest for you:\n```\nlet (k1, k2) : (i32, i32) = redis::pipe()\n  .atomic()\n  .cmd(\"SET\").arg(\"key_1\").arg(42).ignore()\n  .cmd(\"SET\").arg(\"key_2\").arg(43).ignore()\n  .cmd(\"GET\").arg(\"key_1\")\n  .cmd(\"GET\").arg(\"key_2\").query(&mut con)?;\n```\n\nYou can also use high-level commands on pipelines:\n```\nlet (k1, k2) : (i32, i32) = redis::pipe()\n  .atomic()\n  .set(\"key_1\", 42).ignore()\n  .set(\"key_2\", 43).ignore()\n  .get(\"key_1\")\n  .get(\"key_2\").query(&mut con)?;\n```\n\n## \u00a7\u27e820\u27e9Transactions\nTransactions are available through atomic pipelines. In order to use them in a more simple way you can use the `transaction` function of a connection:\n```\nuse redis::Commands;\nlet key = \"the_key\";\nlet (new_val,) : (isize,) = redis::transaction(&mut con, &[key], |con, pipe| {\n  let old_val : isize = con.get(key)?;\n  pipe\n    .set(key, old_val + 1).ignore()\n    .get(key).query(con)\n})?;\nprintln!(\"The incremented number is: {}\", new_val);\n```\n\nFor more information see the `transaction` function.\n## \u00a7\u27e821\u27e9PubSub\nPubsub is provided through the `PubSub` connection object for sync usage, or the `aio::PubSub` for async usage.\nExample usage:\n```\nlet client = redis::Client::open(\"redis://127.0.0.1/\")?;\nlet mut con = client.get_connection()?;\nlet mut pubsub = con.as_pubsub();\npubsub.subscribe(&[\"channel_1\", \"channel_2\"])?;\nloop {\n  let msg = pubsub.get_message()?;\n  let payload : String = msg.get_payload()?;\n  println!(\"channel '{}': {}\", msg.get_channel_name(), payload);\n}\n```\n\nIn order to update subscriptions while concurrently waiting for messages, the async PubSub can be split into separate sink & stream components. The sink can be receive subscription requests while the stream is awaited for messages.\n```\nuse futures_util::StreamExt;\nlet client = redis::Client::open(\"redis://127.0.0.1/\")?;\nlet (mut sink, mut stream) = client.get_async_pubsub().await?.split();\nsink.subscribe(\"channel_1\").await?;\nloop {\n  let msg = stream.next().await.unwrap();\n  let payload : String = msg.get_payload().unwrap();\n  println!(\"channel '{}': {}\", msg.get_channel_name(), payload);\n}\n```\n\n### \u00a7\u27e822\u27e9RESP3 async pubsub\nIf you\u2019re targeting a Redis/Valkey server of version 6 or above, you can receive pubsub messages from it without creating another connection, by setting a push sender on the connection.\n```\n\nlet client = redis::Client::open(\"redis://127.0.0.1/?protocol=resp3\").unwrap();\nlet (tx, mut rx) = tokio::sync::mpsc::unbounded_channel();\nlet config = redis::AsyncConnectionConfig::new().set_push_sender(tx);\nlet mut con = client.get_multiplexed_async_connection_with_config(&config).await?;\ncon.subscribe(&[\"channel_1\", \"channel_2\"]).await?;\nloop {\n println!(\"Received {:?}\", rx.recv().await.unwrap());\n}\n```\n\n## \u00a7\u27e823\u27e9Scripts\nLua scripts are supported through the `Script` type in a convenient way. It will automatically load the script if it does not exist and invoke it.\nExample:\n```\nlet script = redis::Script::new(r\"\n  return tonumber(ARGV[1]) + tonumber(ARGV[2]);\n\");\nlet result: isize = script.arg(1).arg(2).invoke(&mut con)?;\nassert_eq!(result, 3);\n```\n\nScripts can also be pipelined:\n```\nlet script = redis::Script::new(r\"\n  return tonumber(ARGV[1]) + tonumber(ARGV[2]);\n\");\nlet (a, b): (isize, isize) = redis::pipe()\n  .invoke_script(script.arg(1).arg(2))\n  .invoke_script(script.arg(2).arg(3))\n  .query(&mut con)?;\nassert_eq!(a, 3);\nassert_eq!(b, 5);\n```\n\nNote: unlike a call to `invoke`\u27e824\u27e9, if the script isn\u2019t loaded during the pipeline operation, it will not automatically be loaded and retried. The script can be loaded using the `load`\u27e825\u27e9 operation.\n## \u00a7\u27e826\u27e9Async\nIn addition to the synchronous interface that\u2019s been explained above there also exists an asynchronous interface based on `futures`\u27e827\u27e9 and `tokio`\u27e828\u27e9, `smol`\u27e829\u27e9, or `async-std`\u27e830\u27e9. All async connections are cheap to clone, and clones can be used concurrently from multiple threads.\nThis interface exists under the `aio` (async io) module (which requires that the `aio` feature is enabled) and largely mirrors the synchronous with a few concessions to make it fit the constraints of `futures`.\n```\nuse futures::prelude::*;\nuse redis::AsyncCommands;\nlet client = redis::Client::open(\"redis://127.0.0.1/\").unwrap();\nlet mut con = client.get_multiplexed_async_connection().await?;\nlet _: () = con.set(\"key1\", b\"foo\").await?;\nredis::cmd(\"SET\").arg(&[\"key2\", \"bar\"]).exec_async(&mut con).await?;\nlet result = redis::cmd(\"MGET\")\n .arg(&[\"key1\", \"key2\"])\n .query_async(&mut con)\n .await;\nassert_eq!(result, Ok((\"foo\".to_string(), b\"bar\".to_vec())));\n```\n\n### \u00a7\u27e831\u27e9Runtime support\nThe crate supports multiple runtimes, including `tokio`, `async-std`, and `smol`. For Tokio, the crate will spawn tasks on the current thread runtime. For async-std & smol, the crate will spawn tasks on the the global runtime. It is recommended that the crate be used with support only for a single runtime. If the crate is compiled with multiple runtimes, the user should call `crate::aio::prefer_tokio`\u27e832\u27e9, `crate::aio::prefer_async_std`\u27e833\u27e9 or `crate::aio::prefer_smol`\u27e834\u27e9 to set the preferred runtime. These functions set global state which automatically chooses the correct runtime for the async connection.\n## \u00a7\u27e835\u27e9Sentinel\nSentinel types allow users to connect to Redis sentinels and find primaries and replicas.\n```\nuse redis::{ Commands, RedisConnectionInfo };\nuse redis::sentinel::{ SentinelServerType, SentinelClient, SentinelNodeConnectionInfo };\nlet nodes = vec![\"redis://127.0.0.1:6379/\", \"redis://127.0.0.1:6378/\", \"redis://127.0.0.1:6377/\"];\nlet mut sentinel = SentinelClient::build(\n  nodes,\n  String::from(\"primary1\"),\n  Some(SentinelNodeConnectionInfo {\n    tls_mode: Some(redis::TlsMode::Insecure),\n    redis_connection_info: None,\n  }),\n  redis::sentinel::SentinelServerType::Master,\n)\n.unwrap();\nlet primary = sentinel.get_connection().unwrap();\n```\n\nAn async API also exists:\n```\nuse futures::prelude::*;\nuse redis::{ Commands, RedisConnectionInfo };\nuse redis::sentinel::{ SentinelServerType, SentinelClient, SentinelNodeConnectionInfo };\nlet nodes = vec![\"redis://127.0.0.1:6379/\", \"redis://127.0.0.1:6378/\", \"redis://127.0.0.1:6377/\"];\nlet mut sentinel = SentinelClient::build(\n  nodes,\n  String::from(\"primary1\"),\n  Some(SentinelNodeConnectionInfo {\n    tls_mode: Some(redis::TlsMode::Insecure),\n    redis_connection_info: None,\n  }),\n  redis::sentinel::SentinelServerType::Master,\n)\n.unwrap();\nlet primary = sentinel.get_async_connection().await.unwrap();\n```\n\n## Modules\u00a7\u27e836\u27e9\n\nacl\u27e837\u27e9`acl`\n    Defines types to use with the ACL commands.\n\naio\u27e838\u27e9`aio`\n    Adds async IO support to redis.\n\ncaching\u27e839\u27e9`cache-aio`\n    This module provides **experimental** support for Server-assisted client-side caching in Redis.\n\ncluster\u27e840\u27e9`cluster`\n    This module extends the library to support Redis Cluster.\n\ncluster_async\u27e841\u27e9`cluster` and `aio`\n    This module provides async functionality for connecting to Redis / Valkey Clusters.\n\ncluster_routing\u27e842\u27e9`cluster`\n    Routing information for cluster commands.\n\ngeo\u27e843\u27e9`geospatial`\n    Defines types to use with the geospatial commands.\n\nio\u27e844\u27e9\n    Module for defining I/O behavior.\n\nsentinel\u27e845\u27e9`sentinel`\n    Defines a Sentinel type that connects to Redis sentinels and creates clients to master or replica nodes.\n\nstreams\u27e846\u27e9`streams`\n    Defines types to use with the streams commands.\n## Structs\u00a7\u27e847\u27e9\n\nAsyncConnectionConfig\u27e848\u27e9\n    Options for creation of async connection\n\nAsyncIter\u27e849\u27e9`aio`\n    Represents a redis iterator that can be used with async connections.\n\nClient\u27e850\u27e9\n    The client type.\n\nClientTlsConfig\u27e851\u27e9`tls-rustls`\n    Structure to hold mTLS client _certificate_ and _key_ binaries in PEM format\n\nCmd\u27e852\u27e9\n    Represents redis commands.\n\nCommandCacheConfig\u27e853\u27e9\n    CommandCacheConfig is used to define caching behaviour of individual commands.\n\nConnection\u27e854\u27e9\n    Represents a stateful redis TCP connection.\n\nConnectionInfo\u27e855\u27e9\n    Holds the connection information that redis should use for connecting.\n\nCopyOptions\u27e856\u27e9\n    Options for the COPY\u27e857\u27e9 command\n\nFlushAllOptions\u27e858\u27e9\n    Options for the FLUSHALL\u27e859\u27e9 command\n\nHashFieldExpirationOptions\u27e860\u27e9\n    Options for the HSETEX command\n\nInfoDict\u27e861\u27e9\n    An info dictionary type.\n\nIter\u27e862\u27e9\n    Represents a redis iterator.\n\nLposOptions\u27e863\u27e9\n    Options for the LPOS\u27e864\u27e9 command\n\nMsg\u27e865\u27e9\n    Represents a pubsub message.\n\nParser\u27e866\u27e9\n    The internal redis response parser.\n\nPipeline\u27e867\u27e9\n    Represents a redis command pipeline.\n\nPubSub\u27e868\u27e9\n    Represents a pubsub connection.\n\nPushInfo\u27e869\u27e9\n    A push message from the server.\n\nRedisConnectionInfo\u27e870\u27e9\n    Redis specific/connection independent information used to establish a connection to redis.\n\nRedisError\u27e871\u27e9\n    Represents a redis error.\n\nReplicaInfo\u27e872\u27e9\n    Replication information for a replica, as returned by the `ROLE`\u27e873\u27e9 command.\n\nScanOptions\u27e874\u27e9\n    Options for the SCAN\u27e875\u27e9 command\n\nScript\u27e876\u27e9`script`\n    Represents a lua script.\n\nScriptInvocation\u27e877\u27e9`script`\n    Represents a prepared script call.\n\nSetOptions\u27e878\u27e9\n    Options for the SET\u27e879\u27e9 command\n\nSortedSetAddOptions\u27e880\u27e9\n    Options for the ZADD\u27e881\u27e9 command\n\nTlsCertificates\u27e882\u27e9`tls-rustls`\n    Structure to hold TLS certificates\n## Enums\u00a7\u27e883\u27e9\n\nArg\u27e884\u27e9\n    An argument to a redis command\n\nConnectionAddr\u27e885\u27e9\n    Defines the connection address.\n\nControlFlow\u27e886\u27e9\n    Allows pubsub callbacks to stop receiving messages.\n\nDirection\u27e887\u27e9\n    Enum for the LEFT | RIGHT args used by some commands\n\nErrorKind\u27e888\u27e9\n    An enum of all error kinds.\n\nExistenceCheck\u27e889\u27e9\n    Helper enum that is used to define existence checks\n\nExpireOption\u27e890\u27e9\n    Helper enum that is used to define option for the hash expire commands\n\nExpiry\u27e891\u27e9\n    Helper enum that is used to define expiry time\n\nFieldExistenceCheck\u27e892\u27e9\n    Helper enum that is used to define field existence checks\n\nIntegerReplyOrNoOp\u27e893\u27e9\n    Returned by typed commands which either return a positive integer or some negative integer indicating some kind of no-op.\n\nNumericBehavior\u27e894\u27e9\n    Helper enum that is used in some situations to describe the behavior of arguments in a numeric context.\n\nProtocolVersion\u27e895\u27e9\n    Enum representing the communication protocol with the server.\n\nPushKind\u27e896\u27e9\n    `Push` type\u2019s currently known kinds.\n\nRetryMethod\u27e897\u27e9\n    What method should be used if retrying this request.\n\nRole\u27e898\u27e9\n    High level representation of response to the `ROLE`\u27e873\u27e9 command.\n\nSetExpiry\u27e899\u27e9\n    Helper enum that is used to define expiry time for SET command\n\nTlsMode\u27e8100\u27e9\n    TlsMode indicates use or do not use verification of certification.\n\nUpdateCheck\u27e8101\u27e9\n    Helper enum that is used to define update checks\n\nValue\u27e8102\u27e9\n    Internal low-level redis value enum.\n\nValueType\u27e8103\u27e9\n    Possible types of value held in Redis: Redis Docs\u27e8104\u27e9\n\nVerbatimFormat\u27e8105\u27e9\n    `VerbatimString`\u2019s format types defined by spec\n## Traits\u00a7\u27e8106\u27e9\n\nAsyncCommands\u27e8107\u27e9`aio`\n    Implements common redis commands over asynchronous connections.\n\nAsyncTypedCommands\u27e8108\u27e9`aio`\n    Implements common redis commands over asynchronous connections. The return types are concrete and opinionated. If you want to choose the return type you should use the `AsyncCommands` trait.\n\nCommands\u27e8109\u27e9\n    Implements common redis commands for connection like objects.\n\nConnectionLike\u27e8110\u27e9\n    Implements the \u201cstateless\u201d part of the connection interface that is used by the different objects in redis-rs.\n\nFromRedisValue\u27e8111\u27e9\n    This trait is used to convert a redis value into a more appropriate type.\n\nIntoConnectionInfo\u27e8112\u27e9\n    Converts an object into a connection info struct. This allows the constructor of the client to accept connection information in a range of different formats.\n\nJsonAsyncCommands\u27e8113\u27e9`json` and `aio`\n    Implements RedisJSON commands over asynchronous connections. This allows you to send commands straight to a connection or client.\n\nJsonCommands\u27e8114\u27e9`json`\n    Implements RedisJSON commands for connection like objects. This allows you to send commands straight to a connection or client. It is also implemented for redis results of clients which makes for very convenient access in some basic cases.\n\nPubSubCommands\u27e8115\u27e9\n    The PubSub trait allows subscribing to one or more channels and receiving a callback whenever a message arrives.\n\nRedisWrite\u27e8116\u27e9\n    Abstraction trait for redis command abstractions.\n\nToRedisArgs\u27e8117\u27e9\n    Used to convert a value into one or multiple redis argument strings. Most values will produce exactly one item but in some cases it might make sense to produce more than one.\n\nTypedCommands\u27e8118\u27e9\n    Implements common redis commands. The return types are concrete and opinionated. If you want to choose the return type you should use the `Commands` trait.\n## Functions\u00a7\u27e8119\u27e9\n\ncmd\u27e8120\u27e9\n    Shortcut function to creating a command with a single argument.\n\nfrom_owned_redis_value\u27e8121\u27e9\n    A shortcut function to invoke `FromRedisValue::from_owned_redis_value` to make the API slightly nicer.\n\nfrom_redis_value\u27e8122\u27e9\n    A shortcut function to invoke `FromRedisValue::from_redis_value` to make the API slightly nicer.\n\nmake_extension_error\u27e8123\u27e9\n    Creates a new Redis error with the `ExtensionError` kind.\n\npack_command\u27e8124\u27e9\n    Packs a bunch of commands into a request.\n\nparse_redis_url\u27e8125\u27e9\n    This function takes a redis URL string and parses it into a URL as used by rust-url.\n\nparse_redis_value\u27e8126\u27e9\n    Parses bytes into a redis value.\n\nparse_redis_value_async\u27e8127\u27e9`aio`\n    Parses a redis value asynchronously.\n\npipe\u27e8128\u27e9\n    Shortcut for creating a new pipeline.\n\ntransaction\u27e8129\u27e9\n    This function simplifies transaction management slightly. What it does is automatically watching keys and then going into a transaction loop util it succeeds. Once it goes through the results are returned.\n## Type Aliases\u00a7\u27e8130\u27e9\n\nFlushDbOptions\u27e8131\u27e9\n    Options for the FLUSHDB\u27e8132\u27e9 command\n\nRedisFuture\u27e8133\u27e9`aio`\n    Library generic future type.\n\nRedisResult\u27e8134\u27e9\n    Library generic result type.\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/redis/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/redis/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/redis/latest/src/redis/lib.rs.html#1-743: Source\n\u27e84\u27e9 https://docs.rs/redis/latest/redis/#basic-operation: \u00a7\n\u27e85\u27e9 https://docs.rs/redis/latest/redis/#tls--ssl: \u00a7\n\u27e86\u27e9 https://docs.rs/redis/latest/redis/#tcp-settings: \u00a7\n\u27e87\u27e9 https://docs.rs/redis/latest/redis/io/tcp/struct.TcpSettings.html: struct redis::io::tcp::TcpSettings - crate::io::tcp::TcpSettings\n\u27e88\u27e9 https://docs.rs/redis/latest/redis/#connection-handling: \u00a7\n\u27e89\u27e9 https://docs.rs/redis/latest/redis/#connection-pooling: \u00a7\n\u27e810\u27e9 https://docs.rs/redis/latest/redis/#optional-features: \u00a7\n\u27e811\u27e9 https://docs.rs/redis/latest/redis/#connection-parameters: \u00a7\n\u27e812\u27e9 https://docs.rs/redis/latest/redis/#executing-low-level-commands: \u00a7\n\u27e813\u27e9 https://docs.rs/redis/latest/redis/#executing-high-level-commands: \u00a7\n\u27e814\u27e9 https://docs.rs/redis/latest/redis/#type-conversions: \u00a7\n\u27e815\u27e9 https://docs.rs/redis/latest/redis/#pre-typed-commands: \u00a7\n\u27e816\u27e9 https://docs.rs/redis/latest/redis/#resp3-support: \u00a7\n\u27e817\u27e9 https://docs.rs/redis/latest/redis/#iteration-protocol: \u00a7\n\u27e818\u27e9 https://docs.rs/redis/latest/redis/: This example is not tested - \u24d8\n\u27e819\u27e9 https://docs.rs/redis/latest/redis/#pipelining: \u00a7\n\u27e820\u27e9 https://docs.rs/redis/latest/redis/#transactions: \u00a7\n\u27e821\u27e9 https://docs.rs/redis/latest/redis/#pubsub: \u00a7\n\u27e822\u27e9 https://docs.rs/redis/latest/redis/#resp3-async-pubsub: \u00a7\n\u27e823\u27e9 https://docs.rs/redis/latest/redis/#scripts: \u00a7\n\u27e824\u27e9 https://docs.rs/redis/latest/redis/struct.ScriptInvocation.html#method.invoke: method redis::ScriptInvocation::invoke - `invoke`\n\u27e825\u27e9 https://docs.rs/redis/latest/redis/struct.ScriptInvocation.html#method.load: method redis::ScriptInvocation::load - `load`\n\u27e826\u27e9 https://docs.rs/redis/latest/redis/#async: \u00a7\n\u27e827\u27e9 https://crates.io/crates/futures: `futures`\n\u27e828\u27e9 https://tokio.rs: `tokio`\n\u27e829\u27e9 https://docs.rs/smol/latest/smol/: `smol`\n\u27e830\u27e9 https://async.rs/: `async-std`\n\u27e831\u27e9 https://docs.rs/redis/latest/redis/#runtime-support: \u00a7\n\u27e832\u27e9 https://docs.rs/redis/latest/redis/aio/fn.prefer_tokio.html: fn redis::aio::prefer_tokio - `crate::aio::prefer_tokio`\n\u27e833\u27e9 https://docs.rs/redis/latest/redis/aio/fn.prefer_async_std.html: fn redis::aio::prefer_async_std - `crate::aio::prefer_async_std`\n\u27e834\u27e9 https://docs.rs/redis/latest/redis/aio/fn.prefer_smol.html: fn redis::aio::prefer_smol - `crate::aio::prefer_smol`\n\u27e835\u27e9 https://docs.rs/redis/latest/redis/#sentinel: \u00a7\n\u27e836\u27e9 https://docs.rs/redis/latest/redis/#modules: \u00a7\n\u27e837\u27e9 https://docs.rs/redis/latest/redis/acl/index.html: mod redis::acl - acl\n\u27e838\u27e9 https://docs.rs/redis/latest/redis/aio/index.html: mod redis::aio - aio\n\u27e839\u27e9 https://docs.rs/redis/latest/redis/caching/index.html: mod redis::caching - caching\n\u27e840\u27e9 https://docs.rs/redis/latest/redis/cluster/index.html: mod redis::cluster - cluster\n\u27e841\u27e9 https://docs.rs/redis/latest/redis/cluster_async/index.html: mod redis::cluster_async - cluster_async\n\u27e842\u27e9 https://docs.rs/redis/latest/redis/cluster_routing/index.html: mod redis::cluster_routing - cluster_routing\n\u27e843\u27e9 https://docs.rs/redis/latest/redis/geo/index.html: mod redis::geo - geo\n\u27e844\u27e9 https://docs.rs/redis/latest/redis/io/index.html: mod redis::io - io\n\u27e845\u27e9 https://docs.rs/redis/latest/redis/sentinel/index.html: mod redis::sentinel - sentinel\n\u27e846\u27e9 https://docs.rs/redis/latest/redis/streams/index.html: mod redis::streams - streams\n\u27e847\u27e9 https://docs.rs/redis/latest/redis/#structs: \u00a7\n\u27e848\u27e9 https://docs.rs/redis/latest/redis/struct.AsyncConnectionConfig.html: struct redis::AsyncConnectionConfig - AsyncConnectionConfig\n\u27e849\u27e9 https://docs.rs/redis/latest/redis/struct.AsyncIter.html: struct redis::AsyncIter - AsyncIter\n\u27e850\u27e9 https://docs.rs/redis/latest/redis/struct.Client.html: struct redis::Client - Client\n\u27e851\u27e9 https://docs.rs/redis/latest/redis/struct.ClientTlsConfig.html: struct redis::ClientTlsConfig - ClientTlsConfig\n\u27e852\u27e9 https://docs.rs/redis/latest/redis/struct.Cmd.html: struct redis::Cmd - Cmd\n\u27e853\u27e9 https://docs.rs/redis/latest/redis/struct.CommandCacheConfig.html: struct redis::CommandCacheConfig - CommandCacheConfig\n\u27e854\u27e9 https://docs.rs/redis/latest/redis/struct.Connection.html: struct redis::Connection - Connection\n\u27e855\u27e9 https://docs.rs/redis/latest/redis/struct.ConnectionInfo.html: struct redis::ConnectionInfo - ConnectionInfo\n\u27e856\u27e9 https://docs.rs/redis/latest/redis/struct.CopyOptions.html: struct redis::CopyOptions - CopyOptions\n\u27e857\u27e9 https://redis.io/commands/copy: COPY\n\u27e858\u27e9 https://docs.rs/redis/latest/redis/struct.FlushAllOptions.html: struct redis::FlushAllOptions - FlushAllOptions\n\u27e859\u27e9 https://redis.io/commands/flushall: FLUSHALL\n\u27e860\u27e9 https://docs.rs/redis/latest/redis/struct.HashFieldExpirationOptions.html: struct redis::HashFieldExpirationOptions - HashFieldExpirationOptions\n\u27e861\u27e9 https://docs.rs/redis/latest/redis/struct.InfoDict.html: struct redis::InfoDict - InfoDict\n\u27e862\u27e9 https://docs.rs/redis/latest/redis/struct.Iter.html: struct redis::Iter - Iter\n\u27e863\u27e9 https://docs.rs/redis/latest/redis/struct.LposOptions.html: struct redis::LposOptions - LposOptions\n\u27e864\u27e9 https://redis.io/commands/lpos: LPOS\n\u27e865\u27e9 https://docs.rs/redis/latest/redis/struct.Msg.html: struct redis::Msg - Msg\n\u27e866\u27e9 https://docs.rs/redis/latest/redis/struct.Parser.html: struct redis::Parser - Parser\n\u27e867\u27e9 https://docs.rs/redis/latest/redis/struct.Pipeline.html: struct redis::Pipeline - Pipeline\n\u27e868\u27e9 https://docs.rs/redis/latest/redis/struct.PubSub.html: struct redis::PubSub - PubSub\n\u27e869\u27e9 https://docs.rs/redis/latest/redis/struct.PushInfo.html: struct redis::PushInfo - PushInfo\n\u27e870\u27e9 https://docs.rs/redis/latest/redis/struct.RedisConnectionInfo.html: struct redis::RedisConnectionInfo - RedisConnectionInfo\n\u27e871\u27e9 https://docs.rs/redis/latest/redis/struct.RedisError.html: struct redis::RedisError - RedisError\n\u27e872\u27e9 https://docs.rs/redis/latest/redis/struct.ReplicaInfo.html: struct redis::ReplicaInfo - ReplicaInfo\n\u27e873\u27e9 https://redis.io/docs/latest/commands/role/: `ROLE`\n\u27e874\u27e9 https://docs.rs/redis/latest/redis/struct.ScanOptions.html: struct redis::ScanOptions - ScanOptions\n\u27e875\u27e9 https://redis.io/commands/scan: SCAN\n\u27e876\u27e9 https://docs.rs/redis/latest/redis/struct.Script.html: struct redis::Script - Script\n\u27e877\u27e9 https://docs.rs/redis/latest/redis/struct.ScriptInvocation.html: struct redis::ScriptInvocation - ScriptInvocation\n\u27e878\u27e9 https://docs.rs/redis/latest/redis/struct.SetOptions.html: struct redis::SetOptions - SetOptions\n\u27e879\u27e9 https://redis.io/commands/set: SET\n\u27e880\u27e9 https://docs.rs/redis/latest/redis/struct.SortedSetAddOptions.html: struct redis::SortedSetAddOptions - SortedSetAddOptions\n\u27e881\u27e9 https://redis.io/commands/zadd: ZADD\n\u27e882\u27e9 https://docs.rs/redis/latest/redis/struct.TlsCertificates.html: struct redis::TlsCertificates - TlsCertificates\n\u27e883\u27e9 https://docs.rs/redis/latest/redis/#enums: \u00a7\n\u27e884\u27e9 https://docs.rs/redis/latest/redis/enum.Arg.html: enum redis::Arg - Arg\n\u27e885\u27e9 https://docs.rs/redis/latest/redis/enum.ConnectionAddr.html: enum redis::ConnectionAddr - ConnectionAddr\n\u27e886\u27e9 https://docs.rs/redis/latest/redis/enum.ControlFlow.html: enum redis::ControlFlow - ControlFlow\n\u27e887\u27e9 https://docs.rs/redis/latest/redis/enum.Direction.html: enum redis::Direction - Direction\n\u27e888\u27e9 https://docs.rs/redis/latest/redis/enum.ErrorKind.html: enum redis::ErrorKind - ErrorKind\n\u27e889\u27e9 https://docs.rs/redis/latest/redis/enum.ExistenceCheck.html: enum redis::ExistenceCheck - ExistenceCheck\n\u27e890\u27e9 https://docs.rs/redis/latest/redis/enum.ExpireOption.html: enum redis::ExpireOption - ExpireOption\n\u27e891\u27e9 https://docs.rs/redis/latest/redis/enum.Expiry.html: enum redis::Expiry - Expiry\n\u27e892\u27e9 https://docs.rs/redis/latest/redis/enum.FieldExistenceCheck.html: enum redis::FieldExistenceCheck - FieldExistenceCheck\n\u27e893\u27e9 https://docs.rs/redis/latest/redis/enum.IntegerReplyOrNoOp.html: enum redis::IntegerReplyOrNoOp - IntegerReplyOrNoOp\n\u27e894\u27e9 https://docs.rs/redis/latest/redis/enum.NumericBehavior.html: enum redis::NumericBehavior - NumericBehavior\n\u27e895\u27e9 https://docs.rs/redis/latest/redis/enum.ProtocolVersion.html: enum redis::ProtocolVersion - ProtocolVersion\n\u27e896\u27e9 https://docs.rs/redis/latest/redis/enum.PushKind.html: enum redis::PushKind - PushKind\n\u27e897\u27e9 https://docs.rs/redis/latest/redis/enum.RetryMethod.html: enum redis::RetryMethod - RetryMethod\n\u27e898\u27e9 https://docs.rs/redis/latest/redis/enum.Role.html: enum redis::Role - Role\n\u27e899\u27e9 https://docs.rs/redis/latest/redis/enum.SetExpiry.html: enum redis::SetExpiry - SetExpiry\n\u27e8100\u27e9 https://docs.rs/redis/latest/redis/enum.TlsMode.html: enum redis::TlsMode - TlsMode\n\u27e8101\u27e9 https://docs.rs/redis/latest/redis/enum.UpdateCheck.html: enum redis::UpdateCheck - UpdateCheck\n\u27e8102\u27e9 https://docs.rs/redis/latest/redis/enum.Value.html: enum redis::Value - Value\n\u27e8103\u27e9 https://docs.rs/redis/latest/redis/enum.ValueType.html: enum redis::ValueType - ValueType\n\u27e8104\u27e9 https://redis.io/docs/latest/commands/type/: Redis Docs\n\u27e8105\u27e9 https://docs.rs/redis/latest/redis/enum.VerbatimFormat.html: enum redis::VerbatimFormat - VerbatimFormat\n\u27e8106\u27e9 https://docs.rs/redis/latest/redis/#traits: \u00a7\n\u27e8107\u27e9 https://docs.rs/redis/latest/redis/trait.AsyncCommands.html: trait redis::AsyncCommands - AsyncCommands\n\u27e8108\u27e9 https://docs.rs/redis/latest/redis/trait.AsyncTypedCommands.html: trait redis::AsyncTypedCommands - AsyncTypedCommands\n\u27e8109\u27e9 https://docs.rs/redis/latest/redis/trait.Commands.html: trait redis::Commands - Commands\n\u27e8110\u27e9 https://docs.rs/redis/latest/redis/trait.ConnectionLike.html: trait redis::ConnectionLike - ConnectionLike\n\u27e8111\u27e9 https://docs.rs/redis/latest/redis/trait.FromRedisValue.html: trait redis::FromRedisValue - FromRedisValue\n\u27e8112\u27e9 https://docs.rs/redis/latest/redis/trait.IntoConnectionInfo.html: trait redis::IntoConnectionInfo - IntoConnectionInfo\n\u27e8113\u27e9 https://docs.rs/redis/latest/redis/trait.JsonAsyncCommands.html: trait redis::JsonAsyncCommands - JsonAsyncCommands\n\u27e8114\u27e9 https://docs.rs/redis/latest/redis/trait.JsonCommands.html: trait redis::JsonCommands - JsonCommands\n\u27e8115\u27e9 https://docs.rs/redis/latest/redis/trait.PubSubCommands.html: trait redis::PubSubCommands - PubSubCommands\n\u27e8116\u27e9 https://docs.rs/redis/latest/redis/trait.RedisWrite.html: trait redis::RedisWrite - RedisWrite\n\u27e8117\u27e9 https://docs.rs/redis/latest/redis/trait.ToRedisArgs.html: trait redis::ToRedisArgs - ToRedisArgs\n\u27e8118\u27e9 https://docs.rs/redis/latest/redis/trait.TypedCommands.html: trait redis::TypedCommands - TypedCommands\n\u27e8119\u27e9 https://docs.rs/redis/latest/redis/#functions: \u00a7\n\u27e8120\u27e9 https://docs.rs/redis/latest/redis/fn.cmd.html: fn redis::cmd - cmd\n\u27e8121\u27e9 https://docs.rs/redis/latest/redis/fn.from_owned_redis_value.html: fn redis::from_owned_redis_value - from_owned_redis_value\n\u27e8122\u27e9 https://docs.rs/redis/latest/redis/fn.from_redis_value.html: fn redis::from_redis_value - from_redis_value\n\u27e8123\u27e9 https://docs.rs/redis/latest/redis/fn.make_extension_error.html: fn redis::make_extension_error - make_extension_error\n\u27e8124\u27e9 https://docs.rs/redis/latest/redis/fn.pack_command.html: fn redis::pack_command - pack_command\n\u27e8125\u27e9 https://docs.rs/redis/latest/redis/fn.parse_redis_url.html: fn redis::parse_redis_url - parse_redis_url\n\u27e8126\u27e9 https://docs.rs/redis/latest/redis/fn.parse_redis_value.html: fn redis::parse_redis_value - parse_redis_value\n\u27e8127\u27e9 https://docs.rs/redis/latest/redis/fn.parse_redis_value_async.html: fn redis::parse_redis_value_async - parse_redis_value_async\n\u27e8128\u27e9 https://docs.rs/redis/latest/redis/fn.pipe.html: fn redis::pipe - pipe\n\u27e8129\u27e9 https://docs.rs/redis/latest/redis/fn.transaction.html: fn redis::transaction - transaction\n\u27e8130\u27e9 https://docs.rs/redis/latest/redis/#types: \u00a7\n\u27e8131\u27e9 https://docs.rs/redis/latest/redis/type.FlushDbOptions.html: type redis::FlushDbOptions - FlushDbOptions\n\u27e8132\u27e9 https://redis.io/commands/flushdb: FLUSHDB\n\u27e8133\u27e9 https://docs.rs/redis/latest/redis/type.RedisFuture.html: type redis::RedisFuture - RedisFuture\n\u27e8134\u27e9 https://docs.rs/redis/latest/redis/type.RedisResult.html: type redis::RedisResult - RedisResult\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `redis` crate provides a comprehensive Redis client library for Rust, supporting both synchronous and asynchronous operations. It offers high- and low-level APIs, connection pooling, TLS/SSL, Redis cluster, Lua scripting, PubSub, and RESP3 protocol support. Optional features include geospatial commands, JSON module integration, and experimental client-side caching.",
    "feature_summary": null,
    "use_case": "Database",
    "score": 0.0,
    "factual_counterfactual": "### Pair 1: Connection Handling\n\u2705 Factual: The `redis` crate allows users to create a `Client` object and obtain connections using the `get_connection` method, which supports both synchronous and asynchronous operations.\n\u274c Counterfactual: The `redis` crate requires users to manually manage TCP connections and does not provide a `Client` abstraction for connection management.\n\n---\n\n### Pair 2: Optional Features\n\u2705 Factual: The crate supports optional features such as `r2d2` for connection pooling and `connection-manager` for automatic reconnection in asynchronous environments.\n\u274c Counterfactual: The crate does not support connection pooling or automatic reconnection, requiring users to implement these functionalities themselves.\n\n---\n\n### Pair 3: Lua Script Support\n\u2705 Factual: The `redis` crate provides convenient support for Lua scripts through the `Script` type, which automatically loads and invokes scripts on the Redis server.\n\u274c Counterfactual: The `redis` crate does not support Lua scripting, requiring users to send raw commands manually to execute scripts.\n\n---\n\n### Pair 4: RESP3 Protocol\n\u2705 Factual: The crate supports the RESP3 protocol introduced in Redis version 6, enabling features like receiving PubSub messages on the same connection without creating a separate PubSub connection.\n\u274c Counterfactual: The crate only supports the older RESP2 protocol and does not provide compatibility with RESP3 features like multiplexed PubSub.\n\n---\n\n### Pair 5: Async Runtime",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}