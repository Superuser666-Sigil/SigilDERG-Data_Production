{
    "name": "async-broadcast",
    "version": "0.7.2",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/async-broadcast/latest/async_broadcast/all.html \"show sidebar\")\n# Crate async_broadcastCopy item path\n[Settings](https://docs.rs/async-broadcast/latest/settings.html)\n[Help](https://docs.rs/async-broadcast/latest/help.html)\nSummary[Source](https://docs.rs/async-broadcast/latest/src/async_broadcast/lib.rs.html#1-2098)\nExpand description\nAsync broadcast channel\nAn async multi-producer multi-consumer broadcast channel, where each consumer gets a clone of every message sent on the channel. For obvious reasons, the channel can only be used to broadcast types that implement [`Clone`](https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html \"trait core::clone::Clone\").\nA channel has the [`Sender`](https://docs.rs/async-broadcast/latest/async_broadcast/struct.Sender.html \"struct async_broadcast::Sender\") and [`Receiver`](https://docs.rs/async-broadcast/latest/async_broadcast/struct.Receiver.html \"struct async_broadcast::Receiver\") side. Both sides are cloneable and can be shared among multiple threads.\nWhen all `Sender`s or all `Receiver`s are dropped, the channel becomes closed. When a channel is closed, no more messages can be sent, but remaining messages can still be received.\nThe channel can also be closed manually by calling [`Sender::close()`](https://docs.rs/async-broadcast/latest/async_broadcast/struct.Sender.html#method.close \"method async_broadcast::Sender::close\") or [`Receiver::close()`](https://docs.rs/async-broadcast/latest/async_broadcast/struct.Receiver.html#method.close \"method async_broadcast::Receiver::close\").\n### [\u00a7](https://docs.rs/async-broadcast/latest/async_broadcast/#examples)Examples\n```\nuse async_broadcast::{broadcast, TryRecvError};\nuse futures_lite::{future::block_on, stream::StreamExt};\nblock_on(async move {\n  let (s1, mut r1) = broadcast(2);\n  let s2 = s1.clone();\n  let mut r2 = r1.clone();\n  // Send 2 messages from two different senders.\n  s1.broadcast(7).await.unwrap();\n  s2.broadcast(8).await.unwrap();\n  // Channel is now at capacity so sending more messages will result in an error.\n  assert!(s2.try_broadcast(9).unwrap_err().is_full());\n  assert!(s1.try_broadcast(10).unwrap_err().is_full());\n  // We can use `recv` method of the `Stream` implementation to receive messages.\n  assert_eq!(r1.next().await.unwrap(), 7);\n  assert_eq!(r1.recv().await.unwrap(), 8);\n  assert_eq!(r2.next().await.unwrap(), 7);\n  assert_eq!(r2.recv().await.unwrap(), 8);\n  // All receiver got all messages so channel is now empty.\n  assert_eq!(r1.try_recv(), Err(TryRecvError::Empty));\n  assert_eq!(r2.try_recv(), Err(TryRecvError::Empty));\n  // Drop both senders, which closes the channel.\n  drop(s1);\n  drop(s2);\n  assert_eq!(r1.try_recv(), Err(TryRecvError::Closed));\n  assert_eq!(r2.try_recv(), Err(TryRecvError::Closed));\n})\n```\n\n### [\u00a7](https://docs.rs/async-broadcast/latest/async_broadcast/#difference-with-async-channel)Difference with `async-channel`\nThis crate is similar to [`async-channel`](https://crates.io/crates/async-channel) in that they both provide an MPMC channel but the main difference being that in `async-channel`, each message sent on the channel is only received by one of the receivers. `async-broadcast` on the other hand, delivers each message to every receiver (IOW broadcast) by cloning it for each receiver.\n### [\u00a7](https://docs.rs/async-broadcast/latest/async_broadcast/#difference-with-other-broadcast-crates)Difference with other broadcast crates\n  * [`broadcaster`](https://crates.io/crates/broadcaster): The main difference would be that `broadcaster` doesn\u2019t have a sender and receiver split and both sides use clones of the same BroadcastChannel instance. The messages are sent are sent to all channel clones. While this can work for many cases, the lack of sender and receiver split, means that often times, you\u2019ll find yourself having to drain the channel on the sending side yourself.\n  * [`postage`](https://crates.io/crates/postage): this crate provides a [broadcast API](https://docs.rs/postage/0.4.1/postage/broadcast/fn.channel.html) similar to `async_broadcast`. However, it:\n    * (at the time of this writing) duplicates [futures](https://crates.io/crates/futures) API, which isn\u2019t ideal.\n    * Does not support overflow mode nor has the concept of inactive receivers, so a slow or inactive receiver blocking the whole channel is not a solvable problem.\n    * Provides all kinds of channels, which is generally good but if you just need a broadcast channel, `async_broadcast` is probably a better choice.\n  * [`tokio::sync`](https://docs.rs/tokio/1.6.0/tokio/sync): Tokio\u2019s `sync` module provides a [broadcast channel](https://docs.rs/tokio/1.6.0/tokio/sync/broadcast/index.html) API. The differences here are:\n    * While this implementation does provide [overflow mode](https://docs.rs/tokio/1.6.0/tokio/sync/broadcast/index.html#lagging), it is the default behavior and not opt-in.\n    * There is no equivalent of inactive receivers.\n    * While it\u2019s possible to build tokio with only the `sync` module, it comes with other APIs that you may not need.\n\n\n## Structs[\u00a7](https://docs.rs/async-broadcast/latest/async_broadcast/#structs)\n\n[InactiveReceiver](https://docs.rs/async-broadcast/latest/async_broadcast/struct.InactiveReceiver.html \"struct async_broadcast::InactiveReceiver\")\n    An inactive receiver.\n\n[Receiver](https://docs.rs/async-broadcast/latest/async_broadcast/struct.Receiver.html \"struct async_broadcast::Receiver\")\n    The receiving side of a channel.\n\n[Recv](https://docs.rs/async-broadcast/latest/async_broadcast/struct.Recv.html \"struct async_broadcast::Recv\")\n    A future returned by [`Receiver::recv()`](https://docs.rs/async-broadcast/latest/async_broadcast/struct.Receiver.html#method.recv \"method async_broadcast::Receiver::recv\").\n\n[Send](https://docs.rs/async-broadcast/latest/async_broadcast/struct.Send.html \"struct async_broadcast::Send\")\n    A future returned by [`Sender::broadcast()`](https://docs.rs/async-broadcast/latest/async_broadcast/struct.Sender.html#method.broadcast \"method async_broadcast::Sender::broadcast\").\n\n[SendError](https://docs.rs/async-broadcast/latest/async_broadcast/struct.SendError.html \"struct async_broadcast::SendError\")\n    An error returned from [`Sender::broadcast()`](https://docs.rs/async-broadcast/latest/async_broadcast/struct.Sender.html#method.broadcast \"method async_broadcast::Sender::broadcast\").\n\n[Sender](https://docs.rs/async-broadcast/latest/async_broadcast/struct.Sender.html \"struct async_broadcast::Sender\")\n    The sending side of the broadcast channel.\n## Enums[\u00a7](https://docs.rs/async-broadcast/latest/async_broadcast/#enums)\n\n[RecvError](https://docs.rs/async-broadcast/latest/async_broadcast/enum.RecvError.html \"enum async_broadcast::RecvError\")\n    An error returned from [`Receiver::recv()`](https://docs.rs/async-broadcast/latest/async_broadcast/struct.Receiver.html#method.recv \"method async_broadcast::Receiver::recv\").\n\n[TryRecvError](https://docs.rs/async-broadcast/latest/async_broadcast/enum.TryRecvError.html \"enum async_broadcast::TryRecvError\")\n    An error returned from [`Receiver::try_recv()`](https://docs.rs/async-broadcast/latest/async_broadcast/struct.Receiver.html#method.try_recv \"method async_broadcast::Receiver::try_recv\").\n\n[TrySendError](https://docs.rs/async-broadcast/latest/async_broadcast/enum.TrySendError.html \"enum async_broadcast::TrySendError\")\n    An error returned from [`Sender::try_broadcast()`](https://docs.rs/async-broadcast/latest/async_broadcast/struct.Sender.html#method.try_broadcast \"method async_broadcast::Sender::try_broadcast\").\n## Functions[\u00a7](https://docs.rs/async-broadcast/latest/async_broadcast/#functions)\n\n[broadcast](https://docs.rs/async-broadcast/latest/async_broadcast/fn.broadcast.html \"fn async_broadcast::broadcast\")\n    Create a new broadcast channel.\n",
        "markdown_with_citations": "[](https://docs.rs/async-broadcast/latest/async_broadcast/all.html \"show sidebar\")\n# Crate async_broadcastCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nAsync broadcast channel\nAn async multi-producer multi-consumer broadcast channel, where each consumer gets a clone of every message sent on the channel. For obvious reasons, the channel can only be used to broadcast types that implement `Clone`\u27e84\u27e9.\nA channel has the `Sender`\u27e85\u27e9 and `Receiver`\u27e86\u27e9 side. Both sides are cloneable and can be shared among multiple threads.\nWhen all `Sender`s or all `Receiver`s are dropped, the channel becomes closed. When a channel is closed, no more messages can be sent, but remaining messages can still be received.\nThe channel can also be closed manually by calling `Sender::close()`\u27e87\u27e9 or `Receiver::close()`\u27e88\u27e9.\n### \u00a7\u27e89\u27e9Examples\n```\nuse async_broadcast::{broadcast, TryRecvError};\nuse futures_lite::{future::block_on, stream::StreamExt};\nblock_on(async move {\n  let (s1, mut r1) = broadcast(2);\n  let s2 = s1.clone();\n  let mut r2 = r1.clone();\n  // Send 2 messages from two different senders.\n  s1.broadcast(7).await.unwrap();\n  s2.broadcast(8).await.unwrap();\n  // Channel is now at capacity so sending more messages will result in an error.\n  assert!(s2.try_broadcast(9).unwrap_err().is_full());\n  assert!(s1.try_broadcast(10).unwrap_err().is_full());\n  // We can use `recv` method of the `Stream` implementation to receive messages.\n  assert_eq!(r1.next().await.unwrap(), 7);\n  assert_eq!(r1.recv().await.unwrap(), 8);\n  assert_eq!(r2.next().await.unwrap(), 7);\n  assert_eq!(r2.recv().await.unwrap(), 8);\n  // All receiver got all messages so channel is now empty.\n  assert_eq!(r1.try_recv(), Err(TryRecvError::Empty));\n  assert_eq!(r2.try_recv(), Err(TryRecvError::Empty));\n  // Drop both senders, which closes the channel.\n  drop(s1);\n  drop(s2);\n  assert_eq!(r1.try_recv(), Err(TryRecvError::Closed));\n  assert_eq!(r2.try_recv(), Err(TryRecvError::Closed));\n})\n```\n\n### \u00a7\u27e810\u27e9Difference with `async-channel`\nThis crate is similar to `async-channel`\u27e811\u27e9 in that they both provide an MPMC channel but the main difference being that in `async-channel`, each message sent on the channel is only received by one of the receivers. `async-broadcast` on the other hand, delivers each message to every receiver (IOW broadcast) by cloning it for each receiver.\n### \u00a7\u27e812\u27e9Difference with other broadcast crates\n  * `broadcaster`\u27e813\u27e9: The main difference would be that `broadcaster` doesn\u2019t have a sender and receiver split and both sides use clones of the same BroadcastChannel instance. The messages are sent are sent to all channel clones. While this can work for many cases, the lack of sender and receiver split, means that often times, you\u2019ll find yourself having to drain the channel on the sending side yourself.\n  * `postage`\u27e814\u27e9: this crate provides a broadcast API\u27e815\u27e9 similar to `async_broadcast`. However, it:\n    * (at the time of this writing) duplicates futures\u27e816\u27e9 API, which isn\u2019t ideal.\n    * Does not support overflow mode nor has the concept of inactive receivers, so a slow or inactive receiver blocking the whole channel is not a solvable problem.\n    * Provides all kinds of channels, which is generally good but if you just need a broadcast channel, `async_broadcast` is probably a better choice.\n  * `tokio::sync`\u27e817\u27e9: Tokio\u2019s `sync` module provides a broadcast channel\u27e818\u27e9 API. The differences here are:\n    * While this implementation does provide overflow mode\u27e819\u27e9, it is the default behavior and not opt-in.\n    * There is no equivalent of inactive receivers.\n    * While it\u2019s possible to build tokio with only the `sync` module, it comes with other APIs that you may not need.\n\n\n## Structs\u00a7\u27e820\u27e9\n\nInactiveReceiver\u27e821\u27e9\n    An inactive receiver.\n\nReceiver\u27e86\u27e9\n    The receiving side of a channel.\n\nRecv\u27e822\u27e9\n    A future returned by `Receiver::recv()`\u27e823\u27e9.\n\nSend\u27e824\u27e9\n    A future returned by `Sender::broadcast()`\u27e825\u27e9.\n\nSendError\u27e826\u27e9\n    An error returned from `Sender::broadcast()`\u27e825\u27e9.\n\nSender\u27e85\u27e9\n    The sending side of the broadcast channel.\n## Enums\u00a7\u27e827\u27e9\n\nRecvError\u27e828\u27e9\n    An error returned from `Receiver::recv()`\u27e823\u27e9.\n\nTryRecvError\u27e829\u27e9\n    An error returned from `Receiver::try_recv()`\u27e830\u27e9.\n\nTrySendError\u27e831\u27e9\n    An error returned from `Sender::try_broadcast()`\u27e832\u27e9.\n## Functions\u00a7\u27e833\u27e9\n\nbroadcast\u27e834\u27e9\n    Create a new broadcast channel.\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/async-broadcast/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/async-broadcast/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/async-broadcast/latest/src/async_broadcast/lib.rs.html#1-2098: Source\n\u27e84\u27e9 https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html: trait core::clone::Clone - `Clone`\n\u27e85\u27e9 https://docs.rs/async-broadcast/latest/async_broadcast/struct.Sender.html: struct async_broadcast::Sender - `Sender`\n\u27e86\u27e9 https://docs.rs/async-broadcast/latest/async_broadcast/struct.Receiver.html: struct async_broadcast::Receiver - `Receiver`\n\u27e87\u27e9 https://docs.rs/async-broadcast/latest/async_broadcast/struct.Sender.html#method.close: method async_broadcast::Sender::close - `Sender::close()`\n\u27e88\u27e9 https://docs.rs/async-broadcast/latest/async_broadcast/struct.Receiver.html#method.close: method async_broadcast::Receiver::close - `Receiver::close()`\n\u27e89\u27e9 https://docs.rs/async-broadcast/latest/async_broadcast/#examples: \u00a7\n\u27e810\u27e9 https://docs.rs/async-broadcast/latest/async_broadcast/#difference-with-async-channel: \u00a7\n\u27e811\u27e9 https://crates.io/crates/async-channel: `async-channel`\n\u27e812\u27e9 https://docs.rs/async-broadcast/latest/async_broadcast/#difference-with-other-broadcast-crates: \u00a7\n\u27e813\u27e9 https://crates.io/crates/broadcaster: `broadcaster`\n\u27e814\u27e9 https://crates.io/crates/postage: `postage`\n\u27e815\u27e9 https://docs.rs/postage/0.4.1/postage/broadcast/fn.channel.html: broadcast API\n\u27e816\u27e9 https://crates.io/crates/futures: futures\n\u27e817\u27e9 https://docs.rs/tokio/1.6.0/tokio/sync: `tokio::sync`\n\u27e818\u27e9 https://docs.rs/tokio/1.6.0/tokio/sync/broadcast/index.html: broadcast channel\n\u27e819\u27e9 https://docs.rs/tokio/1.6.0/tokio/sync/broadcast/index.html#lagging: overflow mode\n\u27e820\u27e9 https://docs.rs/async-broadcast/latest/async_broadcast/#structs: \u00a7\n\u27e821\u27e9 https://docs.rs/async-broadcast/latest/async_broadcast/struct.InactiveReceiver.html: struct async_broadcast::InactiveReceiver - InactiveReceiver\n\u27e822\u27e9 https://docs.rs/async-broadcast/latest/async_broadcast/struct.Recv.html: struct async_broadcast::Recv - Recv\n\u27e823\u27e9 https://docs.rs/async-broadcast/latest/async_broadcast/struct.Receiver.html#method.recv: method async_broadcast::Receiver::recv - `Receiver::recv()`\n\u27e824\u27e9 https://docs.rs/async-broadcast/latest/async_broadcast/struct.Send.html: struct async_broadcast::Send - Send\n\u27e825\u27e9 https://docs.rs/async-broadcast/latest/async_broadcast/struct.Sender.html#method.broadcast: method async_broadcast::Sender::broadcast - `Sender::broadcast()`\n\u27e826\u27e9 https://docs.rs/async-broadcast/latest/async_broadcast/struct.SendError.html: struct async_broadcast::SendError - SendError\n\u27e827\u27e9 https://docs.rs/async-broadcast/latest/async_broadcast/#enums: \u00a7\n\u27e828\u27e9 https://docs.rs/async-broadcast/latest/async_broadcast/enum.RecvError.html: enum async_broadcast::RecvError - RecvError\n\u27e829\u27e9 https://docs.rs/async-broadcast/latest/async_broadcast/enum.TryRecvError.html: enum async_broadcast::TryRecvError - TryRecvError\n\u27e830\u27e9 https://docs.rs/async-broadcast/latest/async_broadcast/struct.Receiver.html#method.try_recv: method async_broadcast::Receiver::try_recv - `Receiver::try_recv()`\n\u27e831\u27e9 https://docs.rs/async-broadcast/latest/async_broadcast/enum.TrySendError.html: enum async_broadcast::TrySendError - TrySendError\n\u27e832\u27e9 https://docs.rs/async-broadcast/latest/async_broadcast/struct.Sender.html#method.try_broadcast: method async_broadcast::Sender::try_broadcast - `Sender::try_broadcast()`\n\u27e833\u27e9 https://docs.rs/async-broadcast/latest/async_broadcast/#functions: \u00a7\n\u27e834\u27e9 https://docs.rs/async-broadcast/latest/async_broadcast/fn.broadcast.html: fn async_broadcast::broadcast - broadcast\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `async-broadcast` crate provides an asynchronous multi-producer, multi-consumer broadcast channel where each consumer receives a clone of every message sent. It supports manual or automatic channel closure, overflow handling, and inactive receivers to prevent slow consumers from blocking the channel. Unlike similar crates, it optimizes for broadcasting scenarios with a clear sender-receiver split and avoids unnecessary APIs or behaviors.",
    "feature_summary": null,
    "use_case": "Networking",
    "score": 6.0,
    "factual_counterfactual": "### Pair 1: Channel Behavior\n\u2705 Factual: The `async-broadcast` crate ensures that every message sent on the channel is cloned and delivered to all active receivers, making it suitable for multi-consumer broadcast scenarios.  \n\u274c Counterfactual: The `async-broadcast` crate delivers each message to only one receiver, ensuring exclusive consumption of messages.\n\n---\n\n### Pair 2: Overflow Mode\n\u2705 Factual: The `async-broadcast` crate supports an overflow mode, allowing senders to handle scenarios where the channel reaches capacity by returning an error instead of blocking indefinitely.  \n\u274c Counterfactual: The `async-broadcast` crate automatically drops older messages when the channel reaches capacity, ensuring new messages are always accepted.\n\n---\n\n### Pair 3: Sender and Receiver Design\n\u2705 Factual: In `async-broadcast`, the `Sender` and `Receiver` sides are distinct and independently cloneable, enabling flexible multi-threaded usage.  \n\u274c Counterfactual: The `async-broadcast` crate uses a single unified instance for both sending and receiving, similar to the `broadcaster` crate's design.",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}