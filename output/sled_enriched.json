{
    "name": "sled",
    "version": "1.0.0-alpha.124",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/sled/latest/sled/all.html \"show sidebar\")\n# Crate sledCopy item path\n[Settings](https://docs.rs/sled/latest/settings.html)\n[Help](https://docs.rs/sled/latest/help.html)\nSummary[Source](https://docs.rs/sled/latest/src/sled/lib.rs.html#1-527)\nExpand description\n`sled` is a high-performance embedded database with an API that is similar to a `BTreeMap<[u8], [u8]>`, but with several additional capabilities for assisting creators of stateful systems.\nIt is fully thread-safe, and all operations are atomic. Multiple `Tree`s with isolated keyspaces are supported with the [`Db::open_tree`](https://docs.rs/sled/latest/sled/struct.Db.html#method.open_tree) method.\nACID transactions involving reads and writes to multiple items are supported with the [`Tree::transaction`](https://docs.rs/sled/latest/sled/struct.Tree.html#method.transaction) method. Transactions may also operate over multiple `Tree`s (see [`Tree::transaction`](https://docs.rs/sled/latest/sled/struct.Tree.html#method.transaction) docs for more info).\nUsers may also subscribe to updates on individual `Tree`s by using the [`Tree::watch_prefix`](https://docs.rs/sled/latest/sled/struct.Tree.html#method.watch_prefix) method, which returns a blocking `Iterator` over updates to keys that begin with the provided prefix. You may supply an empty prefix to subscribe to everything.\n[Merge operators](https://github.com/spacejam/sled/wiki/merge-operators) (aka read-modify-write operators) are supported. A merge operator is a function that specifies how new data can be merged into an existing value without requiring both a read and a write. Using the [`Tree::merge`](https://docs.rs/sled/latest/sled/struct.Tree.html#method.merge) method, you may \u201cpush\u201d data to a `Tree` value and have the provided merge operator combine it with the existing value, if there was one. They are set on a per-`Tree` basis, and essentially allow any sort of data structure to be built using merges as an atomic high-level operation.\n`sled` is built by experienced database engineers who think users should spend less time tuning and working against high-friction APIs. Expect significant ergonomic and performance improvements over time. Most surprises are bugs, so please let us know if something is high friction.\n## [\u00a7](https://docs.rs/sled/latest/sled/#examples)Examples\n```\nlet db: sled::Db = sled::open(\"my_db\").unwrap();\n// insert and get\ndb.insert(b\"yo!\", b\"v1\");\nassert_eq!(&db.get(b\"yo!\").unwrap().unwrap(), b\"v1\");\n// Atomic compare-and-swap.\ndb.compare_and_swap(\n  b\"yo!\",   // key\n  Some(b\"v1\"), // old value, None for not present\n  Some(b\"v2\"), // new value, None for delete\n)\n.unwrap();\n// Iterates over key-value pairs, starting at the given key.\nlet scan_key: &[u8] = b\"a non-present key before yo!\";\nlet mut iter = db.range(scan_key..);\nassert_eq!(&iter.next().unwrap().unwrap().0, b\"yo!\");\nassert_eq!(iter.next(), None);\ndb.remove(b\"yo!\");\nassert_eq!(db.get(b\"yo!\"), Ok(None));\nlet other_tree: sled::Tree = db.open_tree(b\"cool db facts\").unwrap();\nother_tree.insert(\n  b\"k1\",\n  &b\"a Db acts like a Tree due to implementing Deref<Target = Tree>\"[..]\n).unwrap();\n```\n\n## Re-exports[\u00a7](https://docs.rs/sled/latest/sled/#reexports)\n\n`pub use self::transaction::Transactional[](https://docs.rs/sled/latest/sled/transaction/trait.Transactional.html \"trait sled::transaction::Transactional\");`\n\n## Modules[\u00a7](https://docs.rs/sled/latest/sled/#modules)\n\n[doc](https://docs.rs/sled/latest/sled/doc/index.html \"mod sled::doc\")\n    what is sled?\n\n[transaction](https://docs.rs/sled/latest/sled/transaction/index.html \"mod sled::transaction\")\n    Fully serializable (ACID) multi-`Tree` transactions\n## Structs[\u00a7](https://docs.rs/sled/latest/sled/#structs)\n\n[Batch](https://docs.rs/sled/latest/sled/struct.Batch.html \"struct sled::Batch\")\n    A batch of updates that will be applied atomically to the Tree.\n\n[CompareAndSwapError](https://docs.rs/sled/latest/sled/struct.CompareAndSwapError.html \"struct sled::CompareAndSwapError\")\n    Compare and swap error.\n\n[Config](https://docs.rs/sled/latest/sled/struct.Config.html \"struct sled::Config\")\n    Top-level configuration for the system.\n\n[Db](https://docs.rs/sled/latest/sled/struct.Db.html \"struct sled::Db\")\n    The `sled` embedded database! Implements `Deref<Target = sled::Tree>` to refer to a default keyspace / namespace / bucket.\n\n[IVec](https://docs.rs/sled/latest/sled/struct.IVec.html \"struct sled::IVec\")\n    A buffer that may either be inline or remote and protected by an Arc\n\n[Iter](https://docs.rs/sled/latest/sled/struct.Iter.html \"struct sled::Iter\")\n    An iterator over keys and values in a `Tree`.\n\n[Subscriber](https://docs.rs/sled/latest/sled/struct.Subscriber.html \"struct sled::Subscriber\")\n    A subscriber listening on a specified prefix\n\n[Tree](https://docs.rs/sled/latest/sled/struct.Tree.html \"struct sled::Tree\")\n    A flash-sympathetic persistent lock-free B+ tree.\n## Enums[\u00a7](https://docs.rs/sled/latest/sled/#enums)\n\n[Error](https://docs.rs/sled/latest/sled/enum.Error.html \"enum sled::Error\")\n    An Error type encapsulating various issues that may come up in the operation of a `Db`.\n\n[Event](https://docs.rs/sled/latest/sled/enum.Event.html \"enum sled::Event\")\n    An event that happened to a key that a subscriber is interested in.\n\n[Mode](https://docs.rs/sled/latest/sled/enum.Mode.html \"enum sled::Mode\")\n    The high-level database mode, according to the trade-offs of the RUM conjecture.\n## Traits[\u00a7](https://docs.rs/sled/latest/sled/#traits)\n\n[MergeOperator](https://docs.rs/sled/latest/sled/trait.MergeOperator.html \"trait sled::MergeOperator\")\n    A function that may be configured on a particular shared `Tree` that will be applied as a kind of read-modify-write operator to any values that are written using the `Tree::merge` method.\n## Functions[\u00a7](https://docs.rs/sled/latest/sled/#functions)\n\n[open](https://docs.rs/sled/latest/sled/fn.open.html \"fn sled::open\")\n    Opens a `Db` with a default configuration at the specified path. This will create a new storage directory at the specified path if it does not already exist. You can use the `Db::was_recovered` method to determine if your database was recovered from a previous instance. You can use `Config::create_new` if you want to increase the chances that the database will be freshly created.\n## Type Aliases[\u00a7](https://docs.rs/sled/latest/sled/#types)\n\n[Result](https://docs.rs/sled/latest/sled/type.Result.html \"type sled::Result\")\n    The top-level result type for dealing with fallible operations. The errors tend to be fail-stop, and nested results are used in cases where the outer fail-stop error can have try `?` used on it, exposing the inner operation that is expected to fail under normal operation. The philosophy behind this is detailed [on the sled blog](https://sled.rs/errors).\n",
        "markdown_with_citations": "[](https://docs.rs/sled/latest/sled/all.html \"show sidebar\")\n# Crate sledCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\n`sled` is a high-performance embedded database with an API that is similar to a `BTreeMap<[u8], [u8]>`, but with several additional capabilities for assisting creators of stateful systems.\nIt is fully thread-safe, and all operations are atomic. Multiple `Tree`s with isolated keyspaces are supported with the `Db::open_tree`\u27e84\u27e9 method.\nACID transactions involving reads and writes to multiple items are supported with the `Tree::transaction`\u27e85\u27e9 method. Transactions may also operate over multiple `Tree`s (see `Tree::transaction`\u27e85\u27e9 docs for more info).\nUsers may also subscribe to updates on individual `Tree`s by using the `Tree::watch_prefix`\u27e86\u27e9 method, which returns a blocking `Iterator` over updates to keys that begin with the provided prefix. You may supply an empty prefix to subscribe to everything.\nMerge operators\u27e87\u27e9 (aka read-modify-write operators) are supported. A merge operator is a function that specifies how new data can be merged into an existing value without requiring both a read and a write. Using the `Tree::merge`\u27e88\u27e9 method, you may \u201cpush\u201d data to a `Tree` value and have the provided merge operator combine it with the existing value, if there was one. They are set on a per-`Tree` basis, and essentially allow any sort of data structure to be built using merges as an atomic high-level operation.\n`sled` is built by experienced database engineers who think users should spend less time tuning and working against high-friction APIs. Expect significant ergonomic and performance improvements over time. Most surprises are bugs, so please let us know if something is high friction.\n## \u00a7\u27e89\u27e9Examples\n```\nlet db: sled::Db = sled::open(\"my_db\").unwrap();\n// insert and get\ndb.insert(b\"yo!\", b\"v1\");\nassert_eq!(&db.get(b\"yo!\").unwrap().unwrap(), b\"v1\");\n// Atomic compare-and-swap.\ndb.compare_and_swap(\n  b\"yo!\",   // key\n  Some(b\"v1\"), // old value, None for not present\n  Some(b\"v2\"), // new value, None for delete\n)\n.unwrap();\n// Iterates over key-value pairs, starting at the given key.\nlet scan_key: &[u8] = b\"a non-present key before yo!\";\nlet mut iter = db.range(scan_key..);\nassert_eq!(&iter.next().unwrap().unwrap().0, b\"yo!\");\nassert_eq!(iter.next(), None);\ndb.remove(b\"yo!\");\nassert_eq!(db.get(b\"yo!\"), Ok(None));\nlet other_tree: sled::Tree = db.open_tree(b\"cool db facts\").unwrap();\nother_tree.insert(\n  b\"k1\",\n  &b\"a Db acts like a Tree due to implementing Deref<Target = Tree>\"[..]\n).unwrap();\n```\n\n## Re-exports\u00a7\u27e810\u27e9\n\n`pub use self::transaction::Transactional[](https://docs.rs/sled/latest/sled/transaction/trait.Transactional.html \"trait sled::transaction::Transactional\");`\n\n## Modules\u00a7\u27e811\u27e9\n\ndoc\u27e812\u27e9\n    what is sled?\n\ntransaction\u27e813\u27e9\n    Fully serializable (ACID) multi-`Tree` transactions\n## Structs\u00a7\u27e814\u27e9\n\nBatch\u27e815\u27e9\n    A batch of updates that will be applied atomically to the Tree.\n\nCompareAndSwapError\u27e816\u27e9\n    Compare and swap error.\n\nConfig\u27e817\u27e9\n    Top-level configuration for the system.\n\nDb\u27e818\u27e9\n    The `sled` embedded database! Implements `Deref<Target = sled::Tree>` to refer to a default keyspace / namespace / bucket.\n\nIVec\u27e819\u27e9\n    A buffer that may either be inline or remote and protected by an Arc\n\nIter\u27e820\u27e9\n    An iterator over keys and values in a `Tree`.\n\nSubscriber\u27e821\u27e9\n    A subscriber listening on a specified prefix\n\nTree\u27e822\u27e9\n    A flash-sympathetic persistent lock-free B+ tree.\n## Enums\u00a7\u27e823\u27e9\n\nError\u27e824\u27e9\n    An Error type encapsulating various issues that may come up in the operation of a `Db`.\n\nEvent\u27e825\u27e9\n    An event that happened to a key that a subscriber is interested in.\n\nMode\u27e826\u27e9\n    The high-level database mode, according to the trade-offs of the RUM conjecture.\n## Traits\u00a7\u27e827\u27e9\n\nMergeOperator\u27e828\u27e9\n    A function that may be configured on a particular shared `Tree` that will be applied as a kind of read-modify-write operator to any values that are written using the `Tree::merge` method.\n## Functions\u00a7\u27e829\u27e9\n\nopen\u27e830\u27e9\n    Opens a `Db` with a default configuration at the specified path. This will create a new storage directory at the specified path if it does not already exist. You can use the `Db::was_recovered` method to determine if your database was recovered from a previous instance. You can use `Config::create_new` if you want to increase the chances that the database will be freshly created.\n## Type Aliases\u00a7\u27e831\u27e9\n\nResult\u27e832\u27e9\n    The top-level result type for dealing with fallible operations. The errors tend to be fail-stop, and nested results are used in cases where the outer fail-stop error can have try `?` used on it, exposing the inner operation that is expected to fail under normal operation. The philosophy behind this is detailed on the sled blog\u27e833\u27e9.\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/sled/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/sled/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/sled/latest/src/sled/lib.rs.html#1-527: Source\n\u27e84\u27e9 https://docs.rs/sled/latest/sled/struct.Db.html#method.open_tree: `Db::open_tree`\n\u27e85\u27e9 https://docs.rs/sled/latest/sled/struct.Tree.html#method.transaction: `Tree::transaction`\n\u27e86\u27e9 https://docs.rs/sled/latest/sled/struct.Tree.html#method.watch_prefix: `Tree::watch_prefix`\n\u27e87\u27e9 https://github.com/spacejam/sled/wiki/merge-operators: Merge operators\n\u27e88\u27e9 https://docs.rs/sled/latest/sled/struct.Tree.html#method.merge: `Tree::merge`\n\u27e89\u27e9 https://docs.rs/sled/latest/sled/#examples: \u00a7\n\u27e810\u27e9 https://docs.rs/sled/latest/sled/#reexports: \u00a7\n\u27e811\u27e9 https://docs.rs/sled/latest/sled/#modules: \u00a7\n\u27e812\u27e9 https://docs.rs/sled/latest/sled/doc/index.html: mod sled::doc - doc\n\u27e813\u27e9 https://docs.rs/sled/latest/sled/transaction/index.html: mod sled::transaction - transaction\n\u27e814\u27e9 https://docs.rs/sled/latest/sled/#structs: \u00a7\n\u27e815\u27e9 https://docs.rs/sled/latest/sled/struct.Batch.html: struct sled::Batch - Batch\n\u27e816\u27e9 https://docs.rs/sled/latest/sled/struct.CompareAndSwapError.html: struct sled::CompareAndSwapError - CompareAndSwapError\n\u27e817\u27e9 https://docs.rs/sled/latest/sled/struct.Config.html: struct sled::Config - Config\n\u27e818\u27e9 https://docs.rs/sled/latest/sled/struct.Db.html: struct sled::Db - Db\n\u27e819\u27e9 https://docs.rs/sled/latest/sled/struct.IVec.html: struct sled::IVec - IVec\n\u27e820\u27e9 https://docs.rs/sled/latest/sled/struct.Iter.html: struct sled::Iter - Iter\n\u27e821\u27e9 https://docs.rs/sled/latest/sled/struct.Subscriber.html: struct sled::Subscriber - Subscriber\n\u27e822\u27e9 https://docs.rs/sled/latest/sled/struct.Tree.html: struct sled::Tree - Tree\n\u27e823\u27e9 https://docs.rs/sled/latest/sled/#enums: \u00a7\n\u27e824\u27e9 https://docs.rs/sled/latest/sled/enum.Error.html: enum sled::Error - Error\n\u27e825\u27e9 https://docs.rs/sled/latest/sled/enum.Event.html: enum sled::Event - Event\n\u27e826\u27e9 https://docs.rs/sled/latest/sled/enum.Mode.html: enum sled::Mode - Mode\n\u27e827\u27e9 https://docs.rs/sled/latest/sled/#traits: \u00a7\n\u27e828\u27e9 https://docs.rs/sled/latest/sled/trait.MergeOperator.html: trait sled::MergeOperator - MergeOperator\n\u27e829\u27e9 https://docs.rs/sled/latest/sled/#functions: \u00a7\n\u27e830\u27e9 https://docs.rs/sled/latest/sled/fn.open.html: fn sled::open - open\n\u27e831\u27e9 https://docs.rs/sled/latest/sled/#types: \u00a7\n\u27e832\u27e9 https://docs.rs/sled/latest/sled/type.Result.html: type sled::Result - Result\n\u27e833\u27e9 https://sled.rs/errors: on the sled blog\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `sled` crate is a high-performance, embedded database designed with a `BTreeMap<[u8], [u8]>`-like API, offering thread-safe, atomic operations. It supports multiple isolated keyspaces (`Tree`s), ACID transactions across items or `Tree`s, and features such as prefix-based key watching and merge operators for atomic read-modify-write operations. Built for ease of use and performance, it enables efficient stateful system development with minimal friction.",
    "feature_summary": null,
    "use_case": "Database",
    "score": 7.0,
    "factual_counterfactual": "### Pair 1: Transactions  \n\u2705 Factual: `sled` supports ACID transactions that can involve reads and writes to multiple items, even across multiple `Tree`s, ensuring full serializability.  \n\u274c Counterfactual: `sled` only supports transactions within a single `Tree` and does not allow operations spanning multiple `Tree`s.  \n\n---\n\n### Pair 2: Merge Operators  \n\u2705 Factual: `sled` provides merge operators, allowing atomic read-modify-write operations on values without requiring separate read and write steps.  \n\u274c Counterfactual: `sled` does not support merge operators, requiring users to manually implement read-modify-write logic for atomic operations.  \n\n---\n\n### Pair 3: Thread Safety  \n\u2705 Factual: `sled` is fully thread-safe, allowing concurrent access and modification of the database without compromising data integrity.  \n\u274c Counterfactual: `sled` requires external synchronization mechanisms to ensure thread safety during concurrent operations.",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}