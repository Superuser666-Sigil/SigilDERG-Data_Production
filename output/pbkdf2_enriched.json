{
    "name": "pbkdf2",
    "version": "0.13.0-rc.0",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/pbkdf2/latest/pbkdf2/all.html \"show sidebar\")\n# Crate pbkdf2Copy item path\n[Settings](https://docs.rs/pbkdf2/latest/settings.html)\n[Help](https://docs.rs/pbkdf2/latest/help.html)\nSummary[Source](https://docs.rs/pbkdf2/latest/src/pbkdf2/lib.rs.html#1-282)\nExpand description\nThis crate implements the PBKDF2 key derivation function as specified in [RFC 2898](https://tools.ietf.org/html/rfc2898).\n## [\u00a7](https://docs.rs/pbkdf2/latest/pbkdf2/#examples)Examples\nPBKDF2 is defined in terms of a keyed pseudo-random function (PRF). Most commonly HMAC is used as this PRF. In such cases you can use [`pbkdf2_hmac`](https://docs.rs/pbkdf2/latest/pbkdf2/fn.pbkdf2_hmac.html \"fn pbkdf2::pbkdf2_hmac\") and [`pbkdf2_hmac_array`](https://docs.rs/pbkdf2/latest/pbkdf2/fn.pbkdf2_hmac_array.html \"fn pbkdf2::pbkdf2_hmac_array\") functions. The former accepts a byte slice which gets filled with generated key, while the former returns an array with generated key of requested length.\n```\nuse hex_literal::hex;\nuse pbkdf2::{pbkdf2_hmac, pbkdf2_hmac_array};\nuse sha2::Sha256;\nlet password = b\"password\";\nlet salt = b\"salt\";\n// number of iterations\nlet n = 600_000;\n// Expected value of generated key\nlet expected = hex!(\"669cfe52482116fda1aa2cbe409b2f56c8e45637\");\nlet mut key1 = [0u8; 20];\npbkdf2_hmac::<Sha256>(password, salt, n, &mut key1);\nassert_eq!(key1, expected);\nlet key2 = pbkdf2_hmac_array::<Sha256, 20>(password, salt, n);\nassert_eq!(key2, expected);\n```\n\nIf you want to use a different PRF, then you can use [`pbkdf2`](https://docs.rs/pbkdf2/latest/pbkdf2/fn.pbkdf2.html \"fn pbkdf2::pbkdf2\") and [`pbkdf2_array`](https://docs.rs/pbkdf2/latest/pbkdf2/fn.pbkdf2_array.html \"fn pbkdf2::pbkdf2_array\") functions.\nThis crates also provides the high-level password-hashing API through the [`Pbkdf2`](https://docs.rs/pbkdf2/latest/pbkdf2/struct.Pbkdf2.html \"struct pbkdf2::Pbkdf2\") struct and traits defined in the [`password-hash`](https://docs.rs/password-hash/0.5.0/x86_64-unknown-linux-gnu/password_hash/index.html \"mod password_hash\") crate.\nAdd the following to your crate\u2019s `Cargo.toml` to import it:\n```\n[dependencies]\npbkdf2 = { version = \"0.12\", features = [\"simple\"] }\nrand_core = { version = \"0.6\", features = [\"std\"] }\n```\n\nThe following example demonstrates the high-level password hashing API:\n```\nuse pbkdf2::{\n  password_hash::{\n    rand_core::OsRng,\n    PasswordHash, PasswordHasher, PasswordVerifier, SaltString\n  },\n  Pbkdf2\n};\nlet password = b\"hunter42\"; // Bad password; don't actually use!\nlet salt = SaltString::generate(&mut OsRng);\n// Hash password to PHC string ($pbkdf2-sha256$...)\nlet password_hash = Pbkdf2.hash_password(password, &salt)?.to_string();\n// Verify password against PHC string\nlet parsed_hash = PasswordHash::new(&password_hash)?;\nassert!(Pbkdf2.verify_password(password, &parsed_hash).is_ok());\n```\n\n## Re-exports[\u00a7](https://docs.rs/pbkdf2/latest/pbkdf2/#reexports)\n\n`pub use password_hash[](https://docs.rs/password-hash/0.5.0/x86_64-unknown-linux-gnu/password_hash/index.html \"mod password_hash\");``simple`\n\n\n`pub use hmac[](https://docs.rs/hmac/0.12.1/x86_64-unknown-linux-gnu/hmac/index.html \"mod hmac\");`\n\n## Structs[\u00a7](https://docs.rs/pbkdf2/latest/pbkdf2/#structs)\n\n[Params](https://docs.rs/pbkdf2/latest/pbkdf2/struct.Params.html \"struct pbkdf2::Params\")\n    PBKDF2 params\n\n[Pbkdf2](https://docs.rs/pbkdf2/latest/pbkdf2/struct.Pbkdf2.html \"struct pbkdf2::Pbkdf2\")\n    PBKDF2 type for use with [`PasswordHasher`](https://docs.rs/password-hash/0.5.0/x86_64-unknown-linux-gnu/password_hash/traits/trait.PasswordHasher.html \"trait password_hash::traits::PasswordHasher\").\n## Enums[\u00a7](https://docs.rs/pbkdf2/latest/pbkdf2/#enums)\n\n[Algorithm](https://docs.rs/pbkdf2/latest/pbkdf2/enum.Algorithm.html \"enum pbkdf2::Algorithm\")\n    PBKDF2 variants.\n## Functions[\u00a7](https://docs.rs/pbkdf2/latest/pbkdf2/#functions)\n\n[pbkdf2](https://docs.rs/pbkdf2/latest/pbkdf2/fn.pbkdf2.html \"fn pbkdf2::pbkdf2\")\n    Generic implementation of PBKDF2 algorithm which accepts an arbitrary keyed PRF.\n\n[pbkdf2_array](https://docs.rs/pbkdf2/latest/pbkdf2/fn.pbkdf2_array.html \"fn pbkdf2::pbkdf2_array\")\n    A variant of the [`pbkdf2`](https://docs.rs/pbkdf2/latest/pbkdf2/fn.pbkdf2.html \"fn pbkdf2::pbkdf2\") function which returns an array instead of filling an input slice.\n\n[pbkdf2_hmac](https://docs.rs/pbkdf2/latest/pbkdf2/fn.pbkdf2_hmac.html \"fn pbkdf2::pbkdf2_hmac\")`hmac`\n    A variant of the [`pbkdf2`](https://docs.rs/pbkdf2/latest/pbkdf2/fn.pbkdf2.html \"fn pbkdf2::pbkdf2\") function which uses HMAC for PRF. It\u2019s generic over (eager) hash functions.\n\n[pbkdf2_hmac_array](https://docs.rs/pbkdf2/latest/pbkdf2/fn.pbkdf2_hmac_array.html \"fn pbkdf2::pbkdf2_hmac_array\")`hmac`\n    A variant of the [`pbkdf2_hmac`](https://docs.rs/pbkdf2/latest/pbkdf2/fn.pbkdf2_hmac.html \"fn pbkdf2::pbkdf2_hmac\") function which returns an array instead of filling an input slice.\n",
        "markdown_with_citations": "[](https://docs.rs/pbkdf2/latest/pbkdf2/all.html \"show sidebar\")\n# Crate pbkdf2Copy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nThis crate implements the PBKDF2 key derivation function as specified in RFC 2898\u27e84\u27e9.\n## \u00a7\u27e85\u27e9Examples\nPBKDF2 is defined in terms of a keyed pseudo-random function (PRF). Most commonly HMAC is used as this PRF. In such cases you can use `pbkdf2_hmac`\u27e86\u27e9 and `pbkdf2_hmac_array`\u27e87\u27e9 functions. The former accepts a byte slice which gets filled with generated key, while the former returns an array with generated key of requested length.\n```\nuse hex_literal::hex;\nuse pbkdf2::{pbkdf2_hmac, pbkdf2_hmac_array};\nuse sha2::Sha256;\nlet password = b\"password\";\nlet salt = b\"salt\";\n// number of iterations\nlet n = 600_000;\n// Expected value of generated key\nlet expected = hex!(\"669cfe52482116fda1aa2cbe409b2f56c8e45637\");\nlet mut key1 = [0u8; 20];\npbkdf2_hmac::<Sha256>(password, salt, n, &mut key1);\nassert_eq!(key1, expected);\nlet key2 = pbkdf2_hmac_array::<Sha256, 20>(password, salt, n);\nassert_eq!(key2, expected);\n```\n\nIf you want to use a different PRF, then you can use `pbkdf2`\u27e88\u27e9 and `pbkdf2_array`\u27e89\u27e9 functions.\nThis crates also provides the high-level password-hashing API through the `Pbkdf2`\u27e810\u27e9 struct and traits defined in the `password-hash`\u27e811\u27e9 crate.\nAdd the following to your crate\u2019s `Cargo.toml` to import it:\n```\n[dependencies]\npbkdf2 = { version = \"0.12\", features = [\"simple\"] }\nrand_core = { version = \"0.6\", features = [\"std\"] }\n```\n\nThe following example demonstrates the high-level password hashing API:\n```\nuse pbkdf2::{\n  password_hash::{\n    rand_core::OsRng,\n    PasswordHash, PasswordHasher, PasswordVerifier, SaltString\n  },\n  Pbkdf2\n};\nlet password = b\"hunter42\"; // Bad password; don't actually use!\nlet salt = SaltString::generate(&mut OsRng);\n// Hash password to PHC string ($pbkdf2-sha256$...)\nlet password_hash = Pbkdf2.hash_password(password, &salt)?.to_string();\n// Verify password against PHC string\nlet parsed_hash = PasswordHash::new(&password_hash)?;\nassert!(Pbkdf2.verify_password(password, &parsed_hash).is_ok());\n```\n\n## Re-exports\u00a7\u27e812\u27e9\n\n`pub use password_hash[](https://docs.rs/password-hash/0.5.0/x86_64-unknown-linux-gnu/password_hash/index.html \"mod password_hash\");``simple`\n\n\n`pub use hmac[](https://docs.rs/hmac/0.12.1/x86_64-unknown-linux-gnu/hmac/index.html \"mod hmac\");`\n\n## Structs\u00a7\u27e813\u27e9\n\nParams\u27e814\u27e9\n    PBKDF2 params\n\nPbkdf2\u27e810\u27e9\n    PBKDF2 type for use with `PasswordHasher`\u27e815\u27e9.\n## Enums\u00a7\u27e816\u27e9\n\nAlgorithm\u27e817\u27e9\n    PBKDF2 variants.\n## Functions\u00a7\u27e818\u27e9\n\npbkdf2\u27e88\u27e9\n    Generic implementation of PBKDF2 algorithm which accepts an arbitrary keyed PRF.\n\npbkdf2_array\u27e89\u27e9\n    A variant of the `pbkdf2`\u27e88\u27e9 function which returns an array instead of filling an input slice.\n\npbkdf2_hmac\u27e86\u27e9`hmac`\n    A variant of the `pbkdf2`\u27e88\u27e9 function which uses HMAC for PRF. It\u2019s generic over (eager) hash functions.\n\npbkdf2_hmac_array\u27e87\u27e9`hmac`\n    A variant of the `pbkdf2_hmac`\u27e86\u27e9 function which returns an array instead of filling an input slice.\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/pbkdf2/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/pbkdf2/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/pbkdf2/latest/src/pbkdf2/lib.rs.html#1-282: Source\n\u27e84\u27e9 https://tools.ietf.org/html/rfc2898: RFC 2898\n\u27e85\u27e9 https://docs.rs/pbkdf2/latest/pbkdf2/#examples: \u00a7\n\u27e86\u27e9 https://docs.rs/pbkdf2/latest/pbkdf2/fn.pbkdf2_hmac.html: fn pbkdf2::pbkdf2_hmac - `pbkdf2_hmac`\n\u27e87\u27e9 https://docs.rs/pbkdf2/latest/pbkdf2/fn.pbkdf2_hmac_array.html: fn pbkdf2::pbkdf2_hmac_array - `pbkdf2_hmac_array`\n\u27e88\u27e9 https://docs.rs/pbkdf2/latest/pbkdf2/fn.pbkdf2.html: fn pbkdf2::pbkdf2 - `pbkdf2`\n\u27e89\u27e9 https://docs.rs/pbkdf2/latest/pbkdf2/fn.pbkdf2_array.html: fn pbkdf2::pbkdf2_array - `pbkdf2_array`\n\u27e810\u27e9 https://docs.rs/pbkdf2/latest/pbkdf2/struct.Pbkdf2.html: struct pbkdf2::Pbkdf2 - `Pbkdf2`\n\u27e811\u27e9 https://docs.rs/password-hash/0.5.0/x86_64-unknown-linux-gnu/password_hash/index.html: mod password_hash - `password-hash`\n\u27e812\u27e9 https://docs.rs/pbkdf2/latest/pbkdf2/#reexports: \u00a7\n\u27e813\u27e9 https://docs.rs/pbkdf2/latest/pbkdf2/#structs: \u00a7\n\u27e814\u27e9 https://docs.rs/pbkdf2/latest/pbkdf2/struct.Params.html: struct pbkdf2::Params - Params\n\u27e815\u27e9 https://docs.rs/password-hash/0.5.0/x86_64-unknown-linux-gnu/password_hash/traits/trait.PasswordHasher.html: trait password_hash::traits::PasswordHasher - `PasswordHasher`\n\u27e816\u27e9 https://docs.rs/pbkdf2/latest/pbkdf2/#enums: \u00a7\n\u27e817\u27e9 https://docs.rs/pbkdf2/latest/pbkdf2/enum.Algorithm.html: enum pbkdf2::Algorithm - Algorithm\n\u27e818\u27e9 https://docs.rs/pbkdf2/latest/pbkdf2/#functions: \u00a7\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `pbkdf2` crate implements the PBKDF2 key derivation function as specified in RFC 2898, commonly using HMAC as the pseudo-random function (PRF). It provides flexible APIs for generating derived keys (`pbkdf2_hmac`, `pbkdf2_hmac_array`) and supports custom PRFs (`pbkdf2`, `pbkdf2_array`). Additionally, it offers high-level password hashing and verification functionality via the `Pbkdf2` struct, integrating with the `password-hash` crate for PHC-compliant password management.",
    "feature_summary": null,
    "use_case": "Cryptography",
    "score": 6.5,
    "factual_counterfactual": "### Pair 1: Key Derivation Functions\n\u2705 Factual: The `pbkdf2` crate provides the `pbkdf2_hmac` function, which uses HMAC as the pseudo-random function (PRF) for key derivation, and is generic over hash functions like `Sha256`.  \n\u274c Counterfactual: The `pbkdf2` crate only supports the `Sha256` hash function and does not allow other hash functions to be used with `pbkdf2_hmac`.\n\n---\n\n### Pair 2: Password Hashing API\n\u2705 Factual: The `pbkdf2` crate offers a high-level password hashing API via the `Pbkdf2` struct, which integrates with the `password-hash` crate for password verification and PHC string generation.  \n\u274c Counterfactual: The `pbkdf2` crate does not provide any high-level password hashing API and only supports low-level key derivation functions.\n\n---\n\n### Pair 3: Iterations and Security\n\u2705 Factual: The `pbkdf2_hmac` function allows specifying the number of iterations, enabling users to increase computational cost for enhanced security.  \n\u274c Counterfactual: The `pbkdf2_hmac` function has a fixed number of iterations and does not allow customization to adjust security levels.",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}