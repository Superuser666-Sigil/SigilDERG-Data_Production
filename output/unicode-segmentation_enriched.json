{
    "name": "unicode-segmentation",
    "version": "1.12.0",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/unicode-segmentation/latest/unicode_segmentation/all.html \"show sidebar\")\n# Crate unicode_segmentationCopy item path\n[Settings](https://docs.rs/unicode-segmentation/latest/settings.html)\n[Help](https://docs.rs/unicode-segmentation/latest/help.html)\nSummary[Source](https://docs.rs/unicode-segmentation/latest/src/unicode_segmentation/lib.rs.html#11-294)\nExpand description\nIterators which split strings on Grapheme Cluster, Word or Sentence boundaries, according to the [Unicode Standard Annex #29](http://www.unicode.org/reports/tr29/) rules.\n```\nextern crate unicode_segmentation;\nuse unicode_segmentation::UnicodeSegmentation;\nfn main() {\n  let s = \"a\u0310e\u0301o\u0308\u0332\\r\\n\";\n  let g = UnicodeSegmentation::graphemes(s, true).collect::<Vec<&str>>();\n  let b: &[_] = &[\"a\u0310\", \"e\u0301\", \"o\u0308\u0332\", \"\\r\\n\"];\n  assert_eq!(g, b);\n  let s = \"The quick (\\\"brown\\\") fox can't jump 32.3 feet, right?\";\n  let w = s.unicode_words().collect::<Vec<&str>>();\n  let b: &[_] = &[\"The\", \"quick\", \"brown\", \"fox\", \"can't\", \"jump\", \"32.3\", \"feet\", \"right\"];\n  assert_eq!(w, b);\n  let s = \"The quick (\\\"brown\\\") fox\";\n  let w = s.split_word_bounds().collect::<Vec<&str>>();\n  let b: &[_] = &[\"The\", \" \", \"quick\", \" \", \"(\", \"\\\"\", \"brown\", \"\\\"\", \")\", \" \", \"fox\"];\n  assert_eq!(w, b);\n}\n```\n\n## [\u00a7](https://docs.rs/unicode-segmentation/latest/unicode_segmentation/#no_std)no_std\nunicode-segmentation does not depend on libstd, so it can be used in crates with the `#![no_std]` attribute.\n## [\u00a7](https://docs.rs/unicode-segmentation/latest/unicode_segmentation/#cratesio)crates.io\nYou can use this package in your project by adding the following to your `Cargo.toml`:\n```\n[dependencies]\nunicode-segmentation = \"1.9.0\"\n```\n\n## Structs[\u00a7](https://docs.rs/unicode-segmentation/latest/unicode_segmentation/#structs)\n\n[GraphemeCursor](https://docs.rs/unicode-segmentation/latest/unicode_segmentation/struct.GraphemeCursor.html \"struct unicode_segmentation::GraphemeCursor\")\n    Cursor-based segmenter for grapheme clusters.\n\n[GraphemeIndices](https://docs.rs/unicode-segmentation/latest/unicode_segmentation/struct.GraphemeIndices.html \"struct unicode_segmentation::GraphemeIndices\")\n    External iterator for grapheme clusters and byte offsets.\n\n[Graphemes](https://docs.rs/unicode-segmentation/latest/unicode_segmentation/struct.Graphemes.html \"struct unicode_segmentation::Graphemes\")\n    External iterator for a string\u2019s [grapheme clusters](http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries).\n\n[USentenceBoundIndices](https://docs.rs/unicode-segmentation/latest/unicode_segmentation/struct.USentenceBoundIndices.html \"struct unicode_segmentation::USentenceBoundIndices\")\n    External iterator for sentence boundaries and byte offsets.\n\n[USentenceBounds](https://docs.rs/unicode-segmentation/latest/unicode_segmentation/struct.USentenceBounds.html \"struct unicode_segmentation::USentenceBounds\")\n    External iterator for a string\u2019s [sentence boundaries](http://www.unicode.org/reports/tr29/#Sentence_Boundaries).\n\n[UWordBoundIndices](https://docs.rs/unicode-segmentation/latest/unicode_segmentation/struct.UWordBoundIndices.html \"struct unicode_segmentation::UWordBoundIndices\")\n    External iterator for word boundaries and byte offsets.\n\n[UWordBounds](https://docs.rs/unicode-segmentation/latest/unicode_segmentation/struct.UWordBounds.html \"struct unicode_segmentation::UWordBounds\")\n    External iterator for a string\u2019s [word boundaries](http://www.unicode.org/reports/tr29/#Word_Boundaries).\n\n[UnicodeSentences](https://docs.rs/unicode-segmentation/latest/unicode_segmentation/struct.UnicodeSentences.html \"struct unicode_segmentation::UnicodeSentences\")\n    An iterator over the substrings of a string which, after splitting the string on [sentence boundaries](http://www.unicode.org/reports/tr29/#Sentence_Boundaries), contain any characters with the [Alphabetic](http://unicode.org/reports/tr44/#Alphabetic) property, or with [General_Category=Number](http://unicode.org/reports/tr44/#General_Category_Values).\n\n[UnicodeWordIndices](https://docs.rs/unicode-segmentation/latest/unicode_segmentation/struct.UnicodeWordIndices.html \"struct unicode_segmentation::UnicodeWordIndices\")\n    An iterator over the substrings of a string which, after splitting the string on [word boundaries](http://www.unicode.org/reports/tr29/#Word_Boundaries), contain any characters with the [Alphabetic](http://unicode.org/reports/tr44/#Alphabetic) property, or with [General_Category=Number](http://unicode.org/reports/tr44/#General_Category_Values). This iterator also provides the byte offsets for each substring.\n\n[UnicodeWords](https://docs.rs/unicode-segmentation/latest/unicode_segmentation/struct.UnicodeWords.html \"struct unicode_segmentation::UnicodeWords\")\n    An iterator over the substrings of a string which, after splitting the string on [word boundaries](http://www.unicode.org/reports/tr29/#Word_Boundaries), contain any characters with the [Alphabetic](http://unicode.org/reports/tr44/#Alphabetic) property, or with [General_Category=Number](http://unicode.org/reports/tr44/#General_Category_Values).\n## Enums[\u00a7](https://docs.rs/unicode-segmentation/latest/unicode_segmentation/#enums)\n\n[GraphemeIncomplete](https://docs.rs/unicode-segmentation/latest/unicode_segmentation/enum.GraphemeIncomplete.html \"enum unicode_segmentation::GraphemeIncomplete\")\n    An error return indicating that not enough content was available in the provided chunk to satisfy the query, and that more content must be provided.\n## Constants[\u00a7](https://docs.rs/unicode-segmentation/latest/unicode_segmentation/#constants)\n\n[UNICODE_VERSION](https://docs.rs/unicode-segmentation/latest/unicode_segmentation/constant.UNICODE_VERSION.html \"constant unicode_segmentation::UNICODE_VERSION\")\n    The version of [Unicode](http://www.unicode.org/) that this version of unicode-segmentation is based on.\n## Traits[\u00a7](https://docs.rs/unicode-segmentation/latest/unicode_segmentation/#traits)\n\n[UnicodeSegmentation](https://docs.rs/unicode-segmentation/latest/unicode_segmentation/trait.UnicodeSegmentation.html \"trait unicode_segmentation::UnicodeSegmentation\")\n    Methods for segmenting strings according to [Unicode Standard Annex #29](http://www.unicode.org/reports/tr29/).\n",
        "markdown_with_citations": "[](https://docs.rs/unicode-segmentation/latest/unicode_segmentation/all.html \"show sidebar\")\n# Crate unicode_segmentationCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nIterators which split strings on Grapheme Cluster, Word or Sentence boundaries, according to the Unicode Standard Annex #29\u27e84\u27e9 rules.\n```\nextern crate unicode_segmentation;\nuse unicode_segmentation::UnicodeSegmentation;\nfn main() {\n  let s = \"a\u0310e\u0301o\u0308\u0332\\r\\n\";\n  let g = UnicodeSegmentation::graphemes(s, true).collect::<Vec<&str>>();\n  let b: &[_] = &[\"a\u0310\", \"e\u0301\", \"o\u0308\u0332\", \"\\r\\n\"];\n  assert_eq!(g, b);\n  let s = \"The quick (\\\"brown\\\") fox can't jump 32.3 feet, right?\";\n  let w = s.unicode_words().collect::<Vec<&str>>();\n  let b: &[_] = &[\"The\", \"quick\", \"brown\", \"fox\", \"can't\", \"jump\", \"32.3\", \"feet\", \"right\"];\n  assert_eq!(w, b);\n  let s = \"The quick (\\\"brown\\\") fox\";\n  let w = s.split_word_bounds().collect::<Vec<&str>>();\n  let b: &[_] = &[\"The\", \" \", \"quick\", \" \", \"(\", \"\\\"\", \"brown\", \"\\\"\", \")\", \" \", \"fox\"];\n  assert_eq!(w, b);\n}\n```\n\n## \u00a7\u27e85\u27e9no_std\nunicode-segmentation does not depend on libstd, so it can be used in crates with the `#![no_std]` attribute.\n## \u00a7\u27e86\u27e9crates.io\nYou can use this package in your project by adding the following to your `Cargo.toml`:\n```\n[dependencies]\nunicode-segmentation = \"1.9.0\"\n```\n\n## Structs\u00a7\u27e87\u27e9\n\nGraphemeCursor\u27e88\u27e9\n    Cursor-based segmenter for grapheme clusters.\n\nGraphemeIndices\u27e89\u27e9\n    External iterator for grapheme clusters and byte offsets.\n\nGraphemes\u27e810\u27e9\n    External iterator for a string\u2019s grapheme clusters\u27e811\u27e9.\n\nUSentenceBoundIndices\u27e812\u27e9\n    External iterator for sentence boundaries and byte offsets.\n\nUSentenceBounds\u27e813\u27e9\n    External iterator for a string\u2019s sentence boundaries\u27e814\u27e9.\n\nUWordBoundIndices\u27e815\u27e9\n    External iterator for word boundaries and byte offsets.\n\nUWordBounds\u27e816\u27e9\n    External iterator for a string\u2019s word boundaries\u27e817\u27e9.\n\nUnicodeSentences\u27e818\u27e9\n    An iterator over the substrings of a string which, after splitting the string on sentence boundaries\u27e814\u27e9, contain any characters with the Alphabetic\u27e819\u27e9 property, or with General_Category=Number\u27e820\u27e9.\n\nUnicodeWordIndices\u27e821\u27e9\n    An iterator over the substrings of a string which, after splitting the string on word boundaries\u27e817\u27e9, contain any characters with the Alphabetic\u27e819\u27e9 property, or with General_Category=Number\u27e820\u27e9. This iterator also provides the byte offsets for each substring.\n\nUnicodeWords\u27e822\u27e9\n    An iterator over the substrings of a string which, after splitting the string on word boundaries\u27e817\u27e9, contain any characters with the Alphabetic\u27e819\u27e9 property, or with General_Category=Number\u27e820\u27e9.\n## Enums\u00a7\u27e823\u27e9\n\nGraphemeIncomplete\u27e824\u27e9\n    An error return indicating that not enough content was available in the provided chunk to satisfy the query, and that more content must be provided.\n## Constants\u00a7\u27e825\u27e9\n\nUNICODE_VERSION\u27e826\u27e9\n    The version of Unicode\u27e827\u27e9 that this version of unicode-segmentation is based on.\n## Traits\u00a7\u27e828\u27e9\n\nUnicodeSegmentation\u27e829\u27e9\n    Methods for segmenting strings according to Unicode Standard Annex #29\u27e84\u27e9.\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/unicode-segmentation/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/unicode-segmentation/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/unicode-segmentation/latest/src/unicode_segmentation/lib.rs.html#11-294: Source\n\u27e84\u27e9 http://www.unicode.org/reports/tr29/: Unicode Standard Annex #29\n\u27e85\u27e9 https://docs.rs/unicode-segmentation/latest/unicode_segmentation/#no_std: \u00a7\n\u27e86\u27e9 https://docs.rs/unicode-segmentation/latest/unicode_segmentation/#cratesio: \u00a7\n\u27e87\u27e9 https://docs.rs/unicode-segmentation/latest/unicode_segmentation/#structs: \u00a7\n\u27e88\u27e9 https://docs.rs/unicode-segmentation/latest/unicode_segmentation/struct.GraphemeCursor.html: struct unicode_segmentation::GraphemeCursor - GraphemeCursor\n\u27e89\u27e9 https://docs.rs/unicode-segmentation/latest/unicode_segmentation/struct.GraphemeIndices.html: struct unicode_segmentation::GraphemeIndices - GraphemeIndices\n\u27e810\u27e9 https://docs.rs/unicode-segmentation/latest/unicode_segmentation/struct.Graphemes.html: struct unicode_segmentation::Graphemes - Graphemes\n\u27e811\u27e9 http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries: grapheme clusters\n\u27e812\u27e9 https://docs.rs/unicode-segmentation/latest/unicode_segmentation/struct.USentenceBoundIndices.html: struct unicode_segmentation::USentenceBoundIndices - USentenceBoundIndices\n\u27e813\u27e9 https://docs.rs/unicode-segmentation/latest/unicode_segmentation/struct.USentenceBounds.html: struct unicode_segmentation::USentenceBounds - USentenceBounds\n\u27e814\u27e9 http://www.unicode.org/reports/tr29/#Sentence_Boundaries: sentence boundaries\n\u27e815\u27e9 https://docs.rs/unicode-segmentation/latest/unicode_segmentation/struct.UWordBoundIndices.html: struct unicode_segmentation::UWordBoundIndices - UWordBoundIndices\n\u27e816\u27e9 https://docs.rs/unicode-segmentation/latest/unicode_segmentation/struct.UWordBounds.html: struct unicode_segmentation::UWordBounds - UWordBounds\n\u27e817\u27e9 http://www.unicode.org/reports/tr29/#Word_Boundaries: word boundaries\n\u27e818\u27e9 https://docs.rs/unicode-segmentation/latest/unicode_segmentation/struct.UnicodeSentences.html: struct unicode_segmentation::UnicodeSentences - UnicodeSentences\n\u27e819\u27e9 http://unicode.org/reports/tr44/#Alphabetic: Alphabetic\n\u27e820\u27e9 http://unicode.org/reports/tr44/#General_Category_Values: General_Category=Number\n\u27e821\u27e9 https://docs.rs/unicode-segmentation/latest/unicode_segmentation/struct.UnicodeWordIndices.html: struct unicode_segmentation::UnicodeWordIndices - UnicodeWordIndices\n\u27e822\u27e9 https://docs.rs/unicode-segmentation/latest/unicode_segmentation/struct.UnicodeWords.html: struct unicode_segmentation::UnicodeWords - UnicodeWords\n\u27e823\u27e9 https://docs.rs/unicode-segmentation/latest/unicode_segmentation/#enums: \u00a7\n\u27e824\u27e9 https://docs.rs/unicode-segmentation/latest/unicode_segmentation/enum.GraphemeIncomplete.html: enum unicode_segmentation::GraphemeIncomplete - GraphemeIncomplete\n\u27e825\u27e9 https://docs.rs/unicode-segmentation/latest/unicode_segmentation/#constants: \u00a7\n\u27e826\u27e9 https://docs.rs/unicode-segmentation/latest/unicode_segmentation/constant.UNICODE_VERSION.html: constant unicode_segmentation::UNICODE_VERSION - UNICODE_VERSION\n\u27e827\u27e9 http://www.unicode.org/: Unicode\n\u27e828\u27e9 https://docs.rs/unicode-segmentation/latest/unicode_segmentation/#traits: \u00a7\n\u27e829\u27e9 https://docs.rs/unicode-segmentation/latest/unicode_segmentation/trait.UnicodeSegmentation.html: trait unicode_segmentation::UnicodeSegmentation - UnicodeSegmentation\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `unicode-segmentation` crate provides iterators for splitting strings into grapheme clusters, words, or sentences based on Unicode Standard Annex #29 rules. It supports `no_std` environments and includes various utilities like `UnicodeSegmentation` traits and structs for precise boundary detection, such as `Graphemes`, `UnicodeWords`, and `USentenceBounds`. This crate is ideal for handling complex Unicode text segmentation in Rust.",
    "feature_summary": null,
    "use_case": "Utilities",
    "score": 8.0,
    "factual_counterfactual": "### Pair 1: Grapheme Cluster Segmentation\n\u2705 **Factual:** The `unicode-segmentation` crate provides an iterator called `Graphemes` that splits strings into grapheme clusters according to Unicode Standard Annex #29 rules.  \n\u274c **Counterfactual:** The `unicode-segmentation` crate uses ASCII-based rules to split strings into grapheme clusters, ignoring Unicode standards.\n\n---\n\n### Pair 2: `no_std` Compatibility\n\u2705 **Factual:** The `unicode-segmentation` crate is compatible with `#![no_std]`, making it suitable for embedded systems and environments without the Rust standard library.  \n\u274c **Counterfactual:** The `unicode-segmentation` crate requires the Rust standard library and cannot be used in `#![no_std]` environments.\n\n---\n\n### Pair 3: Sentence Boundary Detection\n\u2705 **Factual:** The crate provides iterators like `USentenceBounds` to split strings into sentence boundaries based on Unicode rules.  \n\u274c **Counterfactual:** The crate does not support sentence boundary detection and only provides word and grapheme cluster segmentation.",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}