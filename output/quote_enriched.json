{
    "name": "quote",
    "version": "1.0.40",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/quote/latest/quote/all.html \"show sidebar\")\n# Crate quoteCopy item path\n[Settings](https://docs.rs/quote/latest/settings.html)\n[Help](https://docs.rs/quote/latest/help.html)\nSummary[Source](https://docs.rs/quote/latest/src/quote/lib.rs.html#1-1454)\nExpand description\n[![github](https://img.shields.io/badge/github-8da0cb?style=for-the-badge&labelColor=555555&logo=github)](https://github.com/dtolnay/quote) [![crates-io](https://img.shields.io/badge/crates.io-fc8d62?style=for-the-badge&labelColor=555555&logo=rust)](https://crates.io/crates/quote) [![docs-rs](https://img.shields.io/badge/docs.rs-66c2a5?style=for-the-badge&labelColor=555555&logo=docs.rs)](https://docs.rs/quote)\nThis crate provides the [`quote!`](https://docs.rs/quote/latest/quote/macro.quote.html \"macro quote::quote\") macro for turning Rust syntax tree data structures into tokens of source code.\nProcedural macros in Rust receive a stream of tokens as input, execute arbitrary Rust code to determine how to manipulate those tokens, and produce a stream of tokens to hand back to the compiler to compile into the caller\u2019s crate. Quasi-quoting is a solution to one piece of that \u2014 producing tokens to return to the compiler.\nThe idea of quasi-quoting is that we write _code_ that we treat as _data_. Within the `quote!` macro, we can write what looks like code to our text editor or IDE. We get all the benefits of the editor\u2019s brace matching, syntax highlighting, indentation, and maybe autocompletion. But rather than compiling that as code into the current crate, we can treat it as data, pass it around, mutate it, and eventually hand it back to the compiler as tokens to compile into the macro caller\u2019s crate.\nThis crate is motivated by the procedural macro use case, but is a general-purpose Rust quasi-quoting library and is not specific to procedural macros.\n```\n[dependencies]\nquote = \"1.0\"\n```\n\n## [\u00a7](https://docs.rs/quote/latest/quote/#example)Example\nThe following quasi-quoted block of code is something you might find in [a](https://serde.rs/) procedural macro having to do with data structure serialization. The `#var` syntax performs interpolation of runtime variables into the quoted tokens. Check out the documentation of the [`quote!`](https://docs.rs/quote/latest/quote/macro.quote.html \"macro quote::quote\") macro for more detail about the syntax. See also the [`quote_spanned!`](https://docs.rs/quote/latest/quote/macro.quote_spanned.html \"macro quote::quote_spanned\") macro which is important for implementing hygienic procedural macros.\n```\nlet tokens = quote! {\n  struct SerializeWith #generics #where_clause {\n    value: &'a #field_ty,\n    phantom: core::marker::PhantomData<#item_ty>,\n  }\n  impl #generics serde::Serialize for SerializeWith #generics #where_clause {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n      S: serde::Serializer,\n    {\n      #path(self.value, serializer)\n    }\n  }\n  SerializeWith {\n    value: #value,\n    phantom: core::marker::PhantomData::<#item_ty>,\n  }\n};\n```\n\n## [\u00a7](https://docs.rs/quote/latest/quote/#non-macro-code-generators)Non-macro code generators\nWhen using `quote` in a build.rs or main.rs and writing the output out to a file, consider having the code generator pass the tokens through [prettyplease](https://github.com/dtolnay/prettyplease) before writing. This way if an error occurs in the generated code it is convenient for a human to read and debug.\n## Macros[\u00a7](https://docs.rs/quote/latest/quote/#macros)\n\n[format_ident](https://docs.rs/quote/latest/quote/macro.format_ident.html \"macro quote::format_ident\")\n    Formatting macro for constructing `Ident`s.\n\n[quote](https://docs.rs/quote/latest/quote/macro.quote.html \"macro quote::quote\")\n    The whole point.\n\n[quote_spanned](https://docs.rs/quote/latest/quote/macro.quote_spanned.html \"macro quote::quote_spanned\")\n    Same as `quote!`, but applies a given span to all tokens originating within the macro invocation.\n## Traits[\u00a7](https://docs.rs/quote/latest/quote/#traits)\n\n[IdentFragment](https://docs.rs/quote/latest/quote/trait.IdentFragment.html \"trait quote::IdentFragment\")\n    Specialized formatting trait used by `format_ident!`.\n\n[ToTokens](https://docs.rs/quote/latest/quote/trait.ToTokens.html \"trait quote::ToTokens\")\n    Types that can be interpolated inside a `quote!` invocation.\n\n[TokenStreamExt](https://docs.rs/quote/latest/quote/trait.TokenStreamExt.html \"trait quote::TokenStreamExt\")\n    TokenStream extension trait with methods for appending tokens.\n",
        "markdown_with_citations": "[](https://docs.rs/quote/latest/quote/all.html \"show sidebar\")\n# Crate quoteCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\n![github\u27e84\u27e9](https://github.com/dtolnay/quote) ![crates-io\u27e85\u27e9](https://crates.io/crates/quote) ![docs-rs\u27e86\u27e9](https://docs.rs/quote)\nThis crate provides the `quote!`\u27e87\u27e9 macro for turning Rust syntax tree data structures into tokens of source code.\nProcedural macros in Rust receive a stream of tokens as input, execute arbitrary Rust code to determine how to manipulate those tokens, and produce a stream of tokens to hand back to the compiler to compile into the caller\u2019s crate. Quasi-quoting is a solution to one piece of that \u2014 producing tokens to return to the compiler.\nThe idea of quasi-quoting is that we write _code_ that we treat as _data_. Within the `quote!` macro, we can write what looks like code to our text editor or IDE. We get all the benefits of the editor\u2019s brace matching, syntax highlighting, indentation, and maybe autocompletion. But rather than compiling that as code into the current crate, we can treat it as data, pass it around, mutate it, and eventually hand it back to the compiler as tokens to compile into the macro caller\u2019s crate.\nThis crate is motivated by the procedural macro use case, but is a general-purpose Rust quasi-quoting library and is not specific to procedural macros.\n```\n[dependencies]\nquote = \"1.0\"\n```\n\n## \u00a7\u27e88\u27e9Example\nThe following quasi-quoted block of code is something you might find in a\u27e89\u27e9 procedural macro having to do with data structure serialization. The `#var` syntax performs interpolation of runtime variables into the quoted tokens. Check out the documentation of the `quote!`\u27e87\u27e9 macro for more detail about the syntax. See also the `quote_spanned!`\u27e810\u27e9 macro which is important for implementing hygienic procedural macros.\n```\nlet tokens = quote! {\n  struct SerializeWith #generics #where_clause {\n    value: &'a #field_ty,\n    phantom: core::marker::PhantomData<#item_ty>,\n  }\n  impl #generics serde::Serialize for SerializeWith #generics #where_clause {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n      S: serde::Serializer,\n    {\n      #path(self.value, serializer)\n    }\n  }\n  SerializeWith {\n    value: #value,\n    phantom: core::marker::PhantomData::<#item_ty>,\n  }\n};\n```\n\n## \u00a7\u27e811\u27e9Non-macro code generators\nWhen using `quote` in a build.rs or main.rs and writing the output out to a file, consider having the code generator pass the tokens through prettyplease\u27e812\u27e9 before writing. This way if an error occurs in the generated code it is convenient for a human to read and debug.\n## Macros\u00a7\u27e813\u27e9\n\nformat_ident\u27e814\u27e9\n    Formatting macro for constructing `Ident`s.\n\nquote\u27e87\u27e9\n    The whole point.\n\nquote_spanned\u27e810\u27e9\n    Same as `quote!`, but applies a given span to all tokens originating within the macro invocation.\n## Traits\u00a7\u27e815\u27e9\n\nIdentFragment\u27e816\u27e9\n    Specialized formatting trait used by `format_ident!`.\n\nToTokens\u27e817\u27e9\n    Types that can be interpolated inside a `quote!` invocation.\n\nTokenStreamExt\u27e818\u27e9\n    TokenStream extension trait with methods for appending tokens.\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/quote/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/quote/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/quote/latest/src/quote/lib.rs.html#1-1454: Source\n\u27e84\u27e9 https://img.shields.io/badge/github-8da0cb?style=for-the-badge&labelColor=555555&logo=github: ![github\n\u27e85\u27e9 https://img.shields.io/badge/crates.io-fc8d62?style=for-the-badge&labelColor=555555&logo=rust: ![crates-io\n\u27e86\u27e9 https://img.shields.io/badge/docs.rs-66c2a5?style=for-the-badge&labelColor=555555&logo=docs.rs: ![docs-rs\n\u27e87\u27e9 https://docs.rs/quote/latest/quote/macro.quote.html: macro quote::quote - `quote!`\n\u27e88\u27e9 https://docs.rs/quote/latest/quote/#example: \u00a7\n\u27e89\u27e9 https://serde.rs/: a\n\u27e810\u27e9 https://docs.rs/quote/latest/quote/macro.quote_spanned.html: macro quote::quote_spanned - `quote_spanned!`\n\u27e811\u27e9 https://docs.rs/quote/latest/quote/#non-macro-code-generators: \u00a7\n\u27e812\u27e9 https://github.com/dtolnay/prettyplease: prettyplease\n\u27e813\u27e9 https://docs.rs/quote/latest/quote/#macros: \u00a7\n\u27e814\u27e9 https://docs.rs/quote/latest/quote/macro.format_ident.html: macro quote::format_ident - format_ident\n\u27e815\u27e9 https://docs.rs/quote/latest/quote/#traits: \u00a7\n\u27e816\u27e9 https://docs.rs/quote/latest/quote/trait.IdentFragment.html: trait quote::IdentFragment - IdentFragment\n\u27e817\u27e9 https://docs.rs/quote/latest/quote/trait.ToTokens.html: trait quote::ToTokens - ToTokens\n\u27e818\u27e9 https://docs.rs/quote/latest/quote/trait.TokenStreamExt.html: trait quote::TokenStreamExt - TokenStreamExt\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `quote` crate provides the `quote!` macro for generating Rust code as token streams, enabling quasi-quoting for procedural macros and general-purpose code generation. It supports syntax interpolation (`#var`), span customization (`quote_spanned!`), and includes utilities like `format_ident!` for constructing identifiers. Key traits like `ToTokens` and `TokenStreamExt` facilitate token manipulation and extension.",
    "feature_summary": null,
    "use_case": "DevTools",
    "score": 9.5,
    "factual_counterfactual": "### Pair 1: Quasi-quoting and Token Generation  \n\u2705 **Factual:** The `quote` crate provides the `quote!` macro, which allows developers to generate Rust code as tokens by writing code that is treated as data.  \n\u274c **Counterfactual:** The `quote!` macro directly compiles the generated tokens into the current crate without passing them back to the compiler.  \n\n---\n\n### Pair 2: Procedural Macro Use Case  \n\u2705 **Factual:** The `quote` crate is commonly used in procedural macros to manipulate and generate token streams for compilation.  \n\u274c **Counterfactual:** The `quote` crate is exclusively designed for procedural macros and cannot be used for other code generation tasks.  \n\n---\n\n### Pair 3: Span Application in Macros  \n\u2705 **Factual:** The `quote_spanned!` macro in the `quote` crate allows developers to apply a specific span to all tokens generated within the macro invocation, aiding in procedural macro hygiene.  \n\u274c **Counterfactual:** The `quote_spanned!` macro automatically applies spans based on the caller's environment without requiring explicit input from the developer.",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}