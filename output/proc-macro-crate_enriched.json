{
    "name": "proc-macro-crate",
    "version": "3.3.0",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/proc-macro-crate/latest/proc_macro_crate/all.html \"show sidebar\")\n# Crate proc_macro_crateCopy item path\n[Settings](https://docs.rs/proc-macro-crate/latest/settings.html)\n[Help](https://docs.rs/proc-macro-crate/latest/help.html)\nSummary[Source](https://docs.rs/proc-macro-crate/latest/src/proc_macro_crate/lib.rs.html#1-577)\nExpand description\n[![](https://docs.rs/proc-macro-crate/badge.svg)](https://docs.rs/proc-macro-crate/) [![](https://img.shields.io/crates/v/proc-macro-crate.svg)](https://crates.io/crates/proc-macro-crate) [![](https://img.shields.io/crates/d/proc-macro-crate.png)](https://crates.io/crates/proc-macro-crate) [![Build Status](https://travis-ci.org/bkchr/proc-macro-crate.png?branch=master)](https://travis-ci.org/bkchr/proc-macro-crate)\nProviding support for `$crate` in procedural macros.\n  * [Introduction](https://docs.rs/proc-macro-crate/latest/proc_macro_crate/#introduction)\n  * [Example](https://docs.rs/proc-macro-crate/latest/proc_macro_crate/#example)\n  * [License](https://docs.rs/proc-macro-crate/latest/proc_macro_crate/#license)\n\n\n### [\u00a7](https://docs.rs/proc-macro-crate/latest/proc_macro_crate/#introduction)Introduction\nIn `macro_rules!` `$crate` is used to get the path of the crate where a macro is declared in. In procedural macros there is currently no easy way to get this path. A common hack is to import the desired crate with a know name and use this. However, with rust edition 2018 and dropping `extern crate` declarations from `lib.rs`, people start to rename crates in `Cargo.toml` directly. However, this breaks importing the crate, as the proc-macro developer does not know the renamed name of the crate that should be imported.\nThis crate provides a way to get the name of a crate, even if it renamed in `Cargo.toml`. For this purpose a single function `crate_name` is provided. This function needs to be called in the context of a proc-macro with the name of the desired crate. `CARGO_MANIFEST_DIR` will be used to find the current active `Cargo.toml` and this `Cargo.toml` is searched for the desired crate.\n### [\u00a7](https://docs.rs/proc-macro-crate/latest/proc_macro_crate/#example)Example\n```\nuse quote::quote;\nuse syn::Ident;\nuse proc_macro2::Span;\nuse proc_macro_crate::{crate_name, FoundCrate};\nfn import_my_crate() {\n  let found_crate = crate_name(\"my-crate\").expect(\"my-crate is present in `Cargo.toml`\");\n  match found_crate {\n    FoundCrate::Itself => quote!( crate::Something ),\n    FoundCrate::Name(name) => {\n      let ident = Ident::new(&name, Span::call_site());\n      quote!( #ident::Something )\n    }\n  };\n}\n\n```\n\n### [\u00a7](https://docs.rs/proc-macro-crate/latest/proc_macro_crate/#edge-cases)Edge cases\nThere are multiple edge cases when it comes to determining the correct crate. If you for example import a crate as its own dependency, like this:\n```\n[package]\nname = \"my_crate\"\n[dev-dependencies]\nmy_crate = { version = \"0.1\", features = [ \"test-feature\" ] }\n```\n\nThe crate will return `FoundCrate::Itself` and you will not be able to find the other instance of your crate in `dev-dependencies`. Other similar cases are when one crate is imported multiple times:\n```\n[package]\nname = \"my_crate\"\n[dependencies]\nsome-crate = { version = \"0.5\" }\nsome-crate-old = { package = \"some-crate\", version = \"0.1\" }\n```\n\nWhen searching for `some-crate` in this `Cargo.toml` it will return `FoundCrate::Name(\"some_old_crate\")`, aka the last definition of the crate in the `Cargo.toml`.\n### [\u00a7](https://docs.rs/proc-macro-crate/latest/proc_macro_crate/#license)License\nLicensed under either of\n  * [Apache License, Version 2.0](https://www.apache.org/licenses/LICENSE-2.0)\n  * [MIT license](https://opensource.org/licenses/MIT)\n\n\nat your option.\n## Enums[\u00a7](https://docs.rs/proc-macro-crate/latest/proc_macro_crate/#enums)\n\n[Error](https://docs.rs/proc-macro-crate/latest/proc_macro_crate/enum.Error.html \"enum proc_macro_crate::Error\")\n    Error type used by this crate.\n\n[FoundCrate](https://docs.rs/proc-macro-crate/latest/proc_macro_crate/enum.FoundCrate.html \"enum proc_macro_crate::FoundCrate\")\n    The crate as found by [`crate_name`](https://docs.rs/proc-macro-crate/latest/proc_macro_crate/fn.crate_name.html \"fn proc_macro_crate::crate_name\").\n## Functions[\u00a7](https://docs.rs/proc-macro-crate/latest/proc_macro_crate/#functions)\n\n[crate_name](https://docs.rs/proc-macro-crate/latest/proc_macro_crate/fn.crate_name.html \"fn proc_macro_crate::crate_name\")\n    Find the crate name for the given `orig_name` in the current `Cargo.toml`.\n",
        "markdown_with_citations": "[](https://docs.rs/proc-macro-crate/latest/proc_macro_crate/all.html \"show sidebar\")\n# Crate proc_macro_crateCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\n![\u27e84\u27e9](https://docs.rs/proc-macro-crate/) ![\u27e85\u27e9](https://crates.io/crates/proc-macro-crate) ![\u27e86\u27e9](https://crates.io/crates/proc-macro-crate) ![Build Status\u27e87\u27e9](https://travis-ci.org/bkchr/proc-macro-crate)\nProviding support for `$crate` in procedural macros.\n  * Introduction\u27e88\u27e9\n  * Example\u27e89\u27e9\n  * License\u27e810\u27e9\n\n\n### \u00a7\u27e88\u27e9Introduction\nIn `macro_rules!` `$crate` is used to get the path of the crate where a macro is declared in. In procedural macros there is currently no easy way to get this path. A common hack is to import the desired crate with a know name and use this. However, with rust edition 2018 and dropping `extern crate` declarations from `lib.rs`, people start to rename crates in `Cargo.toml` directly. However, this breaks importing the crate, as the proc-macro developer does not know the renamed name of the crate that should be imported.\nThis crate provides a way to get the name of a crate, even if it renamed in `Cargo.toml`. For this purpose a single function `crate_name` is provided. This function needs to be called in the context of a proc-macro with the name of the desired crate. `CARGO_MANIFEST_DIR` will be used to find the current active `Cargo.toml` and this `Cargo.toml` is searched for the desired crate.\n### \u00a7\u27e89\u27e9Example\n```\nuse quote::quote;\nuse syn::Ident;\nuse proc_macro2::Span;\nuse proc_macro_crate::{crate_name, FoundCrate};\nfn import_my_crate() {\n  let found_crate = crate_name(\"my-crate\").expect(\"my-crate is present in `Cargo.toml`\");\n  match found_crate {\n    FoundCrate::Itself => quote!( crate::Something ),\n    FoundCrate::Name(name) => {\n      let ident = Ident::new(&name, Span::call_site());\n      quote!( #ident::Something )\n    }\n  };\n}\n\n```\n\n### \u00a7\u27e811\u27e9Edge cases\nThere are multiple edge cases when it comes to determining the correct crate. If you for example import a crate as its own dependency, like this:\n```\n[package]\nname = \"my_crate\"\n[dev-dependencies]\nmy_crate = { version = \"0.1\", features = [ \"test-feature\" ] }\n```\n\nThe crate will return `FoundCrate::Itself` and you will not be able to find the other instance of your crate in `dev-dependencies`. Other similar cases are when one crate is imported multiple times:\n```\n[package]\nname = \"my_crate\"\n[dependencies]\nsome-crate = { version = \"0.5\" }\nsome-crate-old = { package = \"some-crate\", version = \"0.1\" }\n```\n\nWhen searching for `some-crate` in this `Cargo.toml` it will return `FoundCrate::Name(\"some_old_crate\")`, aka the last definition of the crate in the `Cargo.toml`.\n### \u00a7\u27e810\u27e9License\nLicensed under either of\n  * Apache License, Version 2.0\u27e812\u27e9\n  * MIT license\u27e813\u27e9\n\n\nat your option.\n## Enums\u00a7\u27e814\u27e9\n\nError\u27e815\u27e9\n    Error type used by this crate.\n\nFoundCrate\u27e816\u27e9\n    The crate as found by `crate_name`\u27e817\u27e9.\n## Functions\u00a7\u27e818\u27e9\n\ncrate_name\u27e817\u27e9\n    Find the crate name for the given `orig_name` in the current `Cargo.toml`.\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/proc-macro-crate/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/proc-macro-crate/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/proc-macro-crate/latest/src/proc_macro_crate/lib.rs.html#1-577: Source\n\u27e84\u27e9 https://docs.rs/proc-macro-crate/badge.svg: ![\n\u27e85\u27e9 https://img.shields.io/crates/v/proc-macro-crate.svg: ![\n\u27e86\u27e9 https://img.shields.io/crates/d/proc-macro-crate.png: ![\n\u27e87\u27e9 https://travis-ci.org/bkchr/proc-macro-crate.png?branch=master: ![Build Status\n\u27e88\u27e9 https://docs.rs/proc-macro-crate/latest/proc_macro_crate/#introduction: Introduction\n\u27e89\u27e9 https://docs.rs/proc-macro-crate/latest/proc_macro_crate/#example: Example\n\u27e810\u27e9 https://docs.rs/proc-macro-crate/latest/proc_macro_crate/#license: License\n\u27e811\u27e9 https://docs.rs/proc-macro-crate/latest/proc_macro_crate/#edge-cases: \u00a7\n\u27e812\u27e9 https://www.apache.org/licenses/LICENSE-2.0: Apache License, Version 2.0\n\u27e813\u27e9 https://opensource.org/licenses/MIT: MIT license\n\u27e814\u27e9 https://docs.rs/proc-macro-crate/latest/proc_macro_crate/#enums: \u00a7\n\u27e815\u27e9 https://docs.rs/proc-macro-crate/latest/proc_macro_crate/enum.Error.html: enum proc_macro_crate::Error - Error\n\u27e816\u27e9 https://docs.rs/proc-macro-crate/latest/proc_macro_crate/enum.FoundCrate.html: enum proc_macro_crate::FoundCrate - FoundCrate\n\u27e817\u27e9 https://docs.rs/proc-macro-crate/latest/proc_macro_crate/fn.crate_name.html: fn proc_macro_crate::crate_name - `crate_name`\n\u27e818\u27e9 https://docs.rs/proc-macro-crate/latest/proc_macro_crate/#functions: \u00a7\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `proc-macro-crate` crate provides support for resolving crate names in procedural macros, even when crates are renamed in `Cargo.toml`. It offers the `crate_name` function to locate a crate's name using the `CARGO_MANIFEST_DIR`, handling edge cases like self-dependencies and multiple imports. This simplifies working with `$crate` paths in procedural macros and supports Rust 2018 edition conventions.",
    "feature_summary": null,
    "use_case": "DevTools",
    "score": 7.0,
    "factual_counterfactual": "### Pair 1: Crate Functionality  \n\u2705 Factual: The `proc-macro-crate` crate provides the `crate_name` function, which allows procedural macros to retrieve the name of a crate as declared in the `Cargo.toml`, even if the crate has been renamed.  \n\u274c Counterfactual: The `proc-macro-crate` crate automatically resolves and imports the crate into the procedural macro without requiring any additional code or configuration.  \n\n---\n\n### Pair 2: Edge Case Handling  \n\u2705 Factual: When a crate is imported multiple times in `Cargo.toml` under different names, `proc-macro-crate` resolves the crate to the last definition in the file.  \n\u274c Counterfactual: The `proc-macro-crate` crate always resolves the first definition of a crate in `Cargo.toml`, ignoring subsequent entries.  \n\n---\n\n### Pair 3: Licensing  \n\u2705 Factual: The `proc-macro-crate` crate is dual-licensed under the Apache License 2.0 and the MIT license, allowing users to choose the license that best fits their needs.  \n\u274c Counterfactual: The `proc-macro-crate` crate is licensed exclusively under the GNU General Public License (GPL), requiring strict copyleft compliance.",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}