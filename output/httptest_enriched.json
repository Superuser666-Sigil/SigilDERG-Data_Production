{
    "name": "httptest",
    "version": "0.16.3",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/httptest/latest/httptest/all.html \"show sidebar\")\n# Crate httptestCopy item path\n[Settings](https://docs.rs/httptest/latest/settings.html)\n[Help](https://docs.rs/httptest/latest/help.html)\nSummary[Source](https://docs.rs/httptest/latest/src/httptest/lib.rs.html#1-363)\nExpand description\n## [\u00a7](https://docs.rs/httptest/latest/httptest/#httptest)httptest\nProvide convenient mechanism for testing http clients against a locally running http server. The typical usage is as follows:\n  * Start a server\n  * Configure the server by adding expectations\n  * Test your http client by making requests to the server\n  * On Drop the server verifies all expectations were met.\n\n\n### [\u00a7](https://docs.rs/httptest/latest/httptest/#example-test)Example Test\n```\nuse http_body_util::Full;\nuse hyper_util::client::legacy::Client;\nuse httptest::{Server, Expectation, matchers::*, responders::*};\n// Starting a logger within the test can make debugging a failed test\n// easier. The mock http server will log::debug every request and response\n// received along with what, if any, matcher was found for the request. When\n// env_logger is initialized running the test with `RUST_LOG=httptest=debug\n// cargo test` can provide that information on stderr.\nlet _ = pretty_env_logger::try_init();\n// Start a server running on a local ephemeral port.\nlet server = Server::run();\n// Configure the server to expect a single GET /foo request and respond\n// with a 200 status code.\nserver.expect(\n  Expectation::matching(request::method_path(\"GET\", \"/foo\"))\n  .respond_with(status_code(200)),\n);\n// The server provides server.addr() that returns the address of the\n// locally running server, or more conveniently provides a server.url() method\n// that gives a fully formed http url to the provided path.\nlet url = server.url(\"/foo\");\nlet client = Client::builder(hyper_util::rt::TokioExecutor::new()).build_http::<Full<bytes::Bytes>>();\n// Issue the GET /foo to the server.\nlet resp = client.get(url).await.unwrap();\n// assert the response has a 200 status code.\nassert!(resp.status().is_success());\n// on Drop the server will assert all expectations have been met and will\n// panic if not.\n```\n\n## [\u00a7](https://docs.rs/httptest/latest/httptest/#server-behavior)Server behavior\nTypically the server is started by calling [Server::run](https://docs.rs/httptest/latest/httptest/struct.Server.html#method.run). It starts without any expectations configured.\nExpectations are added by calling [Server::expect](https://docs.rs/httptest/latest/httptest/struct.Server.html#method.expect). Every invocation of expect appends a new expectation onto the list. Expectations are only removed from the server on Drop or when [Server::verify_and_clear](https://docs.rs/httptest/latest/httptest/struct.Server.html#method.verify_and_clear) is invoked. This guarantees that all expectations are always verified.\nExpectations consist of:\n  * A matcher that determines which requests match this expectation\n  * The number of times a request matching this expectation is expected to be received\n  * A responder that indicates how the server should respond to the request.\n\n\nWhen the server receives a request it iterates over all expectations in the _reverse_ order they have been added. When it reaches an expectation that matches the request, it increments the hit count on that expectation and verifies it has not exceeded it\u2019s expected number of requests. If the limit has been exceeded a 500 error is returned, if the limit has not been exceeded it uses the expectation\u2019s responder to respond to the request. If the request does not match any expectation a 500 error is returned.\nWhen the server is Dropped it:\n  * Stops running\n  * Panics if \n    * any expectation did not receive the expected number of requests\n    * a request was received that did not match any expectation\n\n\nClients can determine the address and port the server is reachable at using [Server::addr](https://docs.rs/httptest/latest/httptest/struct.Server.html#method.addr), or the helper methods [Server::url](https://docs.rs/httptest/latest/httptest/struct.Server.html#method.url) and [Server::url_str](https://docs.rs/httptest/latest/httptest/struct.Server.html#method.url_str).\n### [\u00a7](https://docs.rs/httptest/latest/httptest/#server-pooling)Server Pooling\nTypical usage would use [Server::run](https://docs.rs/httptest/latest/httptest/struct.Server.html#method.run) early in each test case and have the Drop implementation at the end of the test assert all expectations were met. This runs a separate server for each test. Rust\u2019s test harness starts a separate thread for each test within a test-suite so the machine running the test would likely end up running a server for each #[test] function concurrently. For large test suites this could cause machine wide resources (like tcp ports) to become scarce. To address this you could use the \u2013test-threads flag on the test-harness to limit the number of threads running, or alternatively you could use a global [ServerPool](https://docs.rs/httptest/latest/httptest/struct.ServerPool.html) instance.\nThe [ServerPool](https://docs.rs/httptest/latest/httptest/struct.ServerPool.html) allows limiting the number of servers that can be running concurrently while still allowing test cases to function independently.\n#### [\u00a7](https://docs.rs/httptest/latest/httptest/#serverpool-example)ServerPool example\n```\n// Create a server pool that will create at most 2 servers.\nstatic SERVER_POOL: ServerPool = ServerPool::new(2);\n#[test]\nfn test1() {\n  let server = SERVER_POOL.get_server();\n  server.expect(Expectation::matching(any()).respond_with(status_code(200)));\n  // Send requests to server\n  // Server will assert expectations on drop.\n}\n#[test]\nfn test2() {\n  let server = SERVER_POOL.get_server();\n  server.expect(Expectation::matching(any()).respond_with(status_code(200)));\n  // Send requests to server\n  // Server will assert expectations on drop.\n}\n#[test]\nfn test3() {\n  let server = SERVER_POOL.get_server();\n  server.expect(Expectation::matching(any()).respond_with(status_code(200)));\n  // Send requests to server\n  // Server will assert expectations on drop.\n}\n```\n\nThis is almost identical to tests without pooling, the only addition is creating a static ServerPool instance, and using `SERVER_POOL.get_server()` instead of `Server::run()`. This will effectively limit the amount of concurrency of the test suite to two tests at a time. The first two tests to execute `get_server()` will be handed servers without blocking, the 3rd test will block in `get_server()` until one of the first 2 tests complete.\n## [\u00a7](https://docs.rs/httptest/latest/httptest/#defining-expectations)Defining Expectations\nEvery expecation defines a request matcher, a defintion of the number of times it\u2019s expected to be called, and what it should respond with.\n#### [\u00a7](https://docs.rs/httptest/latest/httptest/#expectation-example)Expectation example\n```\nuse httptest::{Expectation, matchers::*, responders::*};\n// Define an Expectation that matches any request to path /foo, expects to\n// receive at least 1 such request, and responds with a 200 response.\nExpectation::matching(request::path(\"/foo\"))\n  .times(1..)\n  .respond_with(status_code(200));\n```\n\n### [\u00a7](https://docs.rs/httptest/latest/httptest/#request-matchers)Request Matchers\nDefining which request an expecation matches is done in a composable manner using a [Matcher](https://docs.rs/httptest/latest/httptest/matchers/trait.Matcher.html) trait. The `Matcher` trait is generic over an input type and defines a single method `matches` that returns a boolean if the input matches.\nA request matcher is any `Matcher` that accepts a `http::Request<hyper::body::Bytes>` as input. A true result indicates the request matches.\nWith that understanding we can discuss how to easily define a request matcher. There are a variety of pre-defined matchers within the [matchers](https://docs.rs/httptest/latest/httptest/matchers/index.html) module. These matchers can be composed together to define the values you want to match. The matchers fall into two categories. Some of the matchers extract a value from the input type and pass it to another matcher, other matchers accept an input type and return a bool. These primitives provide an easy and flexible way to define custom logic.\n#### [\u00a7](https://docs.rs/httptest/latest/httptest/#matcher-examples)Matcher examples\n```\n// pull all the predefined matchers into our namespace.\nuse httptest::matchers::*;\n// &str, String, and &[u8] all implement matchers that test for equality.\n// All of these matchers return true when the input equals \"/foo\"\nlet mut m = eq(\"/foo\");\nlet mut m = \"/foo\";\nlet mut m = \"/foo\".to_string();\nlet mut m = &b\"/foo\"[..];\n// A mapper that returns true when the input matches the regex \"(foo|bar).*\"\nlet mut m = matches(\"(foo|bar).*\");\n// A request matcher that matches a request to path \"/foo\"\nlet mut m = request::path(\"/foo\");\n// A request matcher that matches a POST request\nlet mut m = request::method(\"POST\");\n// A request matcher that matches a POST with a path that matches the regex 'foo.*'\nlet mut m = all_of![\n  request::method(\"POST\"),\n  request::path(matches(\"foo.*\")),\n];\n\n```\n\n### [\u00a7](https://docs.rs/httptest/latest/httptest/#times)Times\nEach expectation defines how many times a matching request is expected to be received. The default is exactly once. The ExpectationBuilder provides a [times](https://docs.rs/httptest/latest/httptest/struct.ExpectationBuilder.html#method.times) method to specify the number of requests expected.\n```\n// Expect exactly one request\nExpectation::matching(any())\n  .respond_with(status_code(200));\n// Expect exactly two requests\nExpectation::matching(any())\n  .times(2)\n  .respond_with(status_code(200));\n// Expect at least 2 requests\nExpectation::matching(any())\n  .times(2..)\n  .respond_with(status_code(200));\n// Expect at most 2 requests\nExpectation::matching(any())\n  .times(..2)\n  .respond_with(status_code(200));\n// Expect between 2 and 5 requests\nExpectation::matching(any())\n  .times(2..6)\n  .respond_with(status_code(200));\n// Expect between 2 and 5 requests\nExpectation::matching(any())\n  .times(2..=5)\n  .respond_with(status_code(200));\n// Expect any number of requests.\nExpectation::matching(any())\n  .times(..)\n  .respond_with(status_code(200));\n```\n\nThe server will respond to any requests that violate the times restriction with a 500 status code and the server will subsequently panic on Drop.\n### [\u00a7](https://docs.rs/httptest/latest/httptest/#responder)Responder\nResponders define how the server will respond to a matched request. There are a number of implemented responders within the responders module. In addition to the predefined responders you can provide any `http::Response` with a body that can be cloned or implement your own Responder.\n#### [\u00a7](https://docs.rs/httptest/latest/httptest/#responder-example)Responder example\n```\nuse httptest::responders::*;\n// respond with a successful 200 status code.\nstatus_code(200);\n// respond with a 404 page not found and a custom header.\nstatus_code(404).append_header(\"X-My-Hdr\", \"my hdr val\");\n// respond with a successful 200 status code and body.\nstatus_code(200).body(\"my body\");\n// respond with a json encoded body and custom header.\njson_encoded(serde_json::json!({\n  \"my_key\": 100,\n  \"my_key2\": [1, 2, \"foo\", 99],\n})).append_header(\"X-My-Hdr\", \"my hdr val\");\n// respond with a url encoded body (foo=bar&baz=bat)\nurl_encoded(&[\n  (\"foo\", \"bar\"),\n  (\"baz\", \"bat\")\n]);\n// alternate between responding with a 200 and a 404.\ncycle![\n  status_code(200),\n  status_code(404),\n];\n```\n\n!\n## Re-exports[\u00a7](https://docs.rs/httptest/latest/httptest/#reexports)\n\n`pub use bytes[](https://docs.rs/bytes/1.10.1/x86_64-unknown-linux-gnu/bytes/index.html \"mod bytes\");`\n\n\n`pub use http[](https://docs.rs/http/1.3.1/x86_64-unknown-linux-gnu/http/index.html \"mod http\");`\n\n## Modules[\u00a7](https://docs.rs/httptest/latest/httptest/#modules)\n\n[matchers](https://docs.rs/httptest/latest/httptest/matchers/index.html \"mod httptest::matchers\")\n    Matcher implementations.\n\n[responders](https://docs.rs/httptest/latest/httptest/responders/index.html \"mod httptest::responders\")\n    Responder implementations.\n## Macros[\u00a7](https://docs.rs/httptest/latest/httptest/#macros)\n\n[all_of](https://docs.rs/httptest/latest/httptest/macro.all_of.html \"macro httptest::all_of\")\n    true if all the provided matchers return true.\n\n[any_of](https://docs.rs/httptest/latest/httptest/macro.any_of.html \"macro httptest::any_of\")\n    true if any of the provided matchers return true.\n\n[cycle](https://docs.rs/httptest/latest/httptest/macro.cycle.html \"macro httptest::cycle\")\n    a Responder that cycles through a list of responses.\n## Structs[\u00a7](https://docs.rs/httptest/latest/httptest/#structs)\n\n[Expectation](https://docs.rs/httptest/latest/httptest/struct.Expectation.html \"struct httptest::Expectation\")\n    An expectation to be asserted by the server.\n\n[ExpectationBuilder](https://docs.rs/httptest/latest/httptest/struct.ExpectationBuilder.html \"struct httptest::ExpectationBuilder\")\n    Define expectations using a builder pattern.\n\n[Server](https://docs.rs/httptest/latest/httptest/struct.Server.html \"struct httptest::Server\")\n    The Server\n\n[ServerBuilder](https://docs.rs/httptest/latest/httptest/struct.ServerBuilder.html \"struct httptest::ServerBuilder\")\n    Custom Server Builder.\n\n[ServerHandle](https://docs.rs/httptest/latest/httptest/struct.ServerHandle.html \"struct httptest::ServerHandle\")\n    A handle to a server. Expectations are inserted when the handle is dropped.\n\n[ServerPool](https://docs.rs/httptest/latest/httptest/struct.ServerPool.html \"struct httptest::ServerPool\")\n    A pool of shared servers.\n## Traits[\u00a7](https://docs.rs/httptest/latest/httptest/#traits)\n\n[IntoTimes](https://docs.rs/httptest/latest/httptest/trait.IntoTimes.html \"trait httptest::IntoTimes\")\n    How many times is an expectation expected to occur. Implemented for usize and any range of usize values.\n",
        "markdown_with_citations": "[](https://docs.rs/httptest/latest/httptest/all.html \"show sidebar\")\n# Crate httptestCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\n## \u00a7\u27e84\u27e9httptest\nProvide convenient mechanism for testing http clients against a locally running http server. The typical usage is as follows:\n  * Start a server\n  * Configure the server by adding expectations\n  * Test your http client by making requests to the server\n  * On Drop the server verifies all expectations were met.\n\n\n### \u00a7\u27e85\u27e9Example Test\n```\nuse http_body_util::Full;\nuse hyper_util::client::legacy::Client;\nuse httptest::{Server, Expectation, matchers::*, responders::*};\n// Starting a logger within the test can make debugging a failed test\n// easier. The mock http server will log::debug every request and response\n// received along with what, if any, matcher was found for the request. When\n// env_logger is initialized running the test with `RUST_LOG=httptest=debug\n// cargo test` can provide that information on stderr.\nlet _ = pretty_env_logger::try_init();\n// Start a server running on a local ephemeral port.\nlet server = Server::run();\n// Configure the server to expect a single GET /foo request and respond\n// with a 200 status code.\nserver.expect(\n  Expectation::matching(request::method_path(\"GET\", \"/foo\"))\n  .respond_with(status_code(200)),\n);\n// The server provides server.addr() that returns the address of the\n// locally running server, or more conveniently provides a server.url() method\n// that gives a fully formed http url to the provided path.\nlet url = server.url(\"/foo\");\nlet client = Client::builder(hyper_util::rt::TokioExecutor::new()).build_http::<Full<bytes::Bytes>>();\n// Issue the GET /foo to the server.\nlet resp = client.get(url).await.unwrap();\n// assert the response has a 200 status code.\nassert!(resp.status().is_success());\n// on Drop the server will assert all expectations have been met and will\n// panic if not.\n```\n\n## \u00a7\u27e86\u27e9Server behavior\nTypically the server is started by calling Server::run\u27e87\u27e9. It starts without any expectations configured.\nExpectations are added by calling Server::expect\u27e88\u27e9. Every invocation of expect appends a new expectation onto the list. Expectations are only removed from the server on Drop or when Server::verify_and_clear\u27e89\u27e9 is invoked. This guarantees that all expectations are always verified.\nExpectations consist of:\n  * A matcher that determines which requests match this expectation\n  * The number of times a request matching this expectation is expected to be received\n  * A responder that indicates how the server should respond to the request.\n\n\nWhen the server receives a request it iterates over all expectations in the _reverse_ order they have been added. When it reaches an expectation that matches the request, it increments the hit count on that expectation and verifies it has not exceeded it\u2019s expected number of requests. If the limit has been exceeded a 500 error is returned, if the limit has not been exceeded it uses the expectation\u2019s responder to respond to the request. If the request does not match any expectation a 500 error is returned.\nWhen the server is Dropped it:\n  * Stops running\n  * Panics if \n    * any expectation did not receive the expected number of requests\n    * a request was received that did not match any expectation\n\n\nClients can determine the address and port the server is reachable at using Server::addr\u27e810\u27e9, or the helper methods Server::url\u27e811\u27e9 and Server::url_str\u27e812\u27e9.\n### \u00a7\u27e813\u27e9Server Pooling\nTypical usage would use Server::run\u27e87\u27e9 early in each test case and have the Drop implementation at the end of the test assert all expectations were met. This runs a separate server for each test. Rust\u2019s test harness starts a separate thread for each test within a test-suite so the machine running the test would likely end up running a server for each #[test] function concurrently. For large test suites this could cause machine wide resources (like tcp ports) to become scarce. To address this you could use the \u2013test-threads flag on the test-harness to limit the number of threads running, or alternatively you could use a global ServerPool\u27e814\u27e9 instance.\nThe ServerPool\u27e814\u27e9 allows limiting the number of servers that can be running concurrently while still allowing test cases to function independently.\n#### \u00a7\u27e815\u27e9ServerPool example\n```\n// Create a server pool that will create at most 2 servers.\nstatic SERVER_POOL: ServerPool = ServerPool::new(2);\n#[test]\nfn test1() {\n  let server = SERVER_POOL.get_server();\n  server.expect(Expectation::matching(any()).respond_with(status_code(200)));\n  // Send requests to server\n  // Server will assert expectations on drop.\n}\n#[test]\nfn test2() {\n  let server = SERVER_POOL.get_server();\n  server.expect(Expectation::matching(any()).respond_with(status_code(200)));\n  // Send requests to server\n  // Server will assert expectations on drop.\n}\n#[test]\nfn test3() {\n  let server = SERVER_POOL.get_server();\n  server.expect(Expectation::matching(any()).respond_with(status_code(200)));\n  // Send requests to server\n  // Server will assert expectations on drop.\n}\n```\n\nThis is almost identical to tests without pooling, the only addition is creating a static ServerPool instance, and using `SERVER_POOL.get_server()` instead of `Server::run()`. This will effectively limit the amount of concurrency of the test suite to two tests at a time. The first two tests to execute `get_server()` will be handed servers without blocking, the 3rd test will block in `get_server()` until one of the first 2 tests complete.\n## \u00a7\u27e816\u27e9Defining Expectations\nEvery expecation defines a request matcher, a defintion of the number of times it\u2019s expected to be called, and what it should respond with.\n#### \u00a7\u27e817\u27e9Expectation example\n```\nuse httptest::{Expectation, matchers::*, responders::*};\n// Define an Expectation that matches any request to path /foo, expects to\n// receive at least 1 such request, and responds with a 200 response.\nExpectation::matching(request::path(\"/foo\"))\n  .times(1..)\n  .respond_with(status_code(200));\n```\n\n### \u00a7\u27e818\u27e9Request Matchers\nDefining which request an expecation matches is done in a composable manner using a Matcher\u27e819\u27e9 trait. The `Matcher` trait is generic over an input type and defines a single method `matches` that returns a boolean if the input matches.\nA request matcher is any `Matcher` that accepts a `http::Request<hyper::body::Bytes>` as input. A true result indicates the request matches.\nWith that understanding we can discuss how to easily define a request matcher. There are a variety of pre-defined matchers within the matchers\u27e820\u27e9 module. These matchers can be composed together to define the values you want to match. The matchers fall into two categories. Some of the matchers extract a value from the input type and pass it to another matcher, other matchers accept an input type and return a bool. These primitives provide an easy and flexible way to define custom logic.\n#### \u00a7\u27e821\u27e9Matcher examples\n```\n// pull all the predefined matchers into our namespace.\nuse httptest::matchers::*;\n// &str, String, and &[u8] all implement matchers that test for equality.\n// All of these matchers return true when the input equals \"/foo\"\nlet mut m = eq(\"/foo\");\nlet mut m = \"/foo\";\nlet mut m = \"/foo\".to_string();\nlet mut m = &b\"/foo\"[..];\n// A mapper that returns true when the input matches the regex \"(foo|bar).*\"\nlet mut m = matches(\"(foo|bar).*\");\n// A request matcher that matches a request to path \"/foo\"\nlet mut m = request::path(\"/foo\");\n// A request matcher that matches a POST request\nlet mut m = request::method(\"POST\");\n// A request matcher that matches a POST with a path that matches the regex 'foo.*'\nlet mut m = all_of![\n  request::method(\"POST\"),\n  request::path(matches(\"foo.*\")),\n];\n\n```\n\n### \u00a7\u27e822\u27e9Times\nEach expectation defines how many times a matching request is expected to be received. The default is exactly once. The ExpectationBuilder provides a times\u27e823\u27e9 method to specify the number of requests expected.\n```\n// Expect exactly one request\nExpectation::matching(any())\n  .respond_with(status_code(200));\n// Expect exactly two requests\nExpectation::matching(any())\n  .times(2)\n  .respond_with(status_code(200));\n// Expect at least 2 requests\nExpectation::matching(any())\n  .times(2..)\n  .respond_with(status_code(200));\n// Expect at most 2 requests\nExpectation::matching(any())\n  .times(..2)\n  .respond_with(status_code(200));\n// Expect between 2 and 5 requests\nExpectation::matching(any())\n  .times(2..6)\n  .respond_with(status_code(200));\n// Expect between 2 and 5 requests\nExpectation::matching(any())\n  .times(2..=5)\n  .respond_with(status_code(200));\n// Expect any number of requests.\nExpectation::matching(any())\n  .times(..)\n  .respond_with(status_code(200));\n```\n\nThe server will respond to any requests that violate the times restriction with a 500 status code and the server will subsequently panic on Drop.\n### \u00a7\u27e824\u27e9Responder\nResponders define how the server will respond to a matched request. There are a number of implemented responders within the responders module. In addition to the predefined responders you can provide any `http::Response` with a body that can be cloned or implement your own Responder.\n#### \u00a7\u27e825\u27e9Responder example\n```\nuse httptest::responders::*;\n// respond with a successful 200 status code.\nstatus_code(200);\n// respond with a 404 page not found and a custom header.\nstatus_code(404).append_header(\"X-My-Hdr\", \"my hdr val\");\n// respond with a successful 200 status code and body.\nstatus_code(200).body(\"my body\");\n// respond with a json encoded body and custom header.\njson_encoded(serde_json::json!({\n  \"my_key\": 100,\n  \"my_key2\": [1, 2, \"foo\", 99],\n})).append_header(\"X-My-Hdr\", \"my hdr val\");\n// respond with a url encoded body (foo=bar&baz=bat)\nurl_encoded(&[\n  (\"foo\", \"bar\"),\n  (\"baz\", \"bat\")\n]);\n// alternate between responding with a 200 and a 404.\ncycle![\n  status_code(200),\n  status_code(404),\n];\n```\n\n!\n## Re-exports\u00a7\u27e826\u27e9\n\n`pub use bytes[](https://docs.rs/bytes/1.10.1/x86_64-unknown-linux-gnu/bytes/index.html \"mod bytes\");`\n\n\n`pub use http[](https://docs.rs/http/1.3.1/x86_64-unknown-linux-gnu/http/index.html \"mod http\");`\n\n## Modules\u00a7\u27e827\u27e9\n\nmatchers\u27e820\u27e9\n    Matcher implementations.\n\nresponders\u27e828\u27e9\n    Responder implementations.\n## Macros\u00a7\u27e829\u27e9\n\nall_of\u27e830\u27e9\n    true if all the provided matchers return true.\n\nany_of\u27e831\u27e9\n    true if any of the provided matchers return true.\n\ncycle\u27e832\u27e9\n    a Responder that cycles through a list of responses.\n## Structs\u00a7\u27e833\u27e9\n\nExpectation\u27e834\u27e9\n    An expectation to be asserted by the server.\n\nExpectationBuilder\u27e835\u27e9\n    Define expectations using a builder pattern.\n\nServer\u27e836\u27e9\n    The Server\n\nServerBuilder\u27e837\u27e9\n    Custom Server Builder.\n\nServerHandle\u27e838\u27e9\n    A handle to a server. Expectations are inserted when the handle is dropped.\n\nServerPool\u27e814\u27e9\n    A pool of shared servers.\n## Traits\u00a7\u27e839\u27e9\n\nIntoTimes\u27e840\u27e9\n    How many times is an expectation expected to occur. Implemented for usize and any range of usize values.\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/httptest/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/httptest/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/httptest/latest/src/httptest/lib.rs.html#1-363: Source\n\u27e84\u27e9 https://docs.rs/httptest/latest/httptest/#httptest: \u00a7\n\u27e85\u27e9 https://docs.rs/httptest/latest/httptest/#example-test: \u00a7\n\u27e86\u27e9 https://docs.rs/httptest/latest/httptest/#server-behavior: \u00a7\n\u27e87\u27e9 https://docs.rs/httptest/latest/httptest/struct.Server.html#method.run: Server::run\n\u27e88\u27e9 https://docs.rs/httptest/latest/httptest/struct.Server.html#method.expect: Server::expect\n\u27e89\u27e9 https://docs.rs/httptest/latest/httptest/struct.Server.html#method.verify_and_clear: Server::verify_and_clear\n\u27e810\u27e9 https://docs.rs/httptest/latest/httptest/struct.Server.html#method.addr: Server::addr\n\u27e811\u27e9 https://docs.rs/httptest/latest/httptest/struct.Server.html#method.url: Server::url\n\u27e812\u27e9 https://docs.rs/httptest/latest/httptest/struct.Server.html#method.url_str: Server::url_str\n\u27e813\u27e9 https://docs.rs/httptest/latest/httptest/#server-pooling: \u00a7\n\u27e814\u27e9 https://docs.rs/httptest/latest/httptest/struct.ServerPool.html: ServerPool\n\u27e815\u27e9 https://docs.rs/httptest/latest/httptest/#serverpool-example: \u00a7\n\u27e816\u27e9 https://docs.rs/httptest/latest/httptest/#defining-expectations: \u00a7\n\u27e817\u27e9 https://docs.rs/httptest/latest/httptest/#expectation-example: \u00a7\n\u27e818\u27e9 https://docs.rs/httptest/latest/httptest/#request-matchers: \u00a7\n\u27e819\u27e9 https://docs.rs/httptest/latest/httptest/matchers/trait.Matcher.html: Matcher\n\u27e820\u27e9 https://docs.rs/httptest/latest/httptest/matchers/index.html: matchers\n\u27e821\u27e9 https://docs.rs/httptest/latest/httptest/#matcher-examples: \u00a7\n\u27e822\u27e9 https://docs.rs/httptest/latest/httptest/#times: \u00a7\n\u27e823\u27e9 https://docs.rs/httptest/latest/httptest/struct.ExpectationBuilder.html#method.times: times\n\u27e824\u27e9 https://docs.rs/httptest/latest/httptest/#responder: \u00a7\n\u27e825\u27e9 https://docs.rs/httptest/latest/httptest/#responder-example: \u00a7\n\u27e826\u27e9 https://docs.rs/httptest/latest/httptest/#reexports: \u00a7\n\u27e827\u27e9 https://docs.rs/httptest/latest/httptest/#modules: \u00a7\n\u27e828\u27e9 https://docs.rs/httptest/latest/httptest/responders/index.html: mod httptest::responders - responders\n\u27e829\u27e9 https://docs.rs/httptest/latest/httptest/#macros: \u00a7\n\u27e830\u27e9 https://docs.rs/httptest/latest/httptest/macro.all_of.html: macro httptest::all_of - all_of\n\u27e831\u27e9 https://docs.rs/httptest/latest/httptest/macro.any_of.html: macro httptest::any_of - any_of\n\u27e832\u27e9 https://docs.rs/httptest/latest/httptest/macro.cycle.html: macro httptest::cycle - cycle\n\u27e833\u27e9 https://docs.rs/httptest/latest/httptest/#structs: \u00a7\n\u27e834\u27e9 https://docs.rs/httptest/latest/httptest/struct.Expectation.html: struct httptest::Expectation - Expectation\n\u27e835\u27e9 https://docs.rs/httptest/latest/httptest/struct.ExpectationBuilder.html: struct httptest::ExpectationBuilder - ExpectationBuilder\n\u27e836\u27e9 https://docs.rs/httptest/latest/httptest/struct.Server.html: struct httptest::Server - Server\n\u27e837\u27e9 https://docs.rs/httptest/latest/httptest/struct.ServerBuilder.html: struct httptest::ServerBuilder - ServerBuilder\n\u27e838\u27e9 https://docs.rs/httptest/latest/httptest/struct.ServerHandle.html: struct httptest::ServerHandle - ServerHandle\n\u27e839\u27e9 https://docs.rs/httptest/latest/httptest/#traits: \u00a7\n\u27e840\u27e9 https://docs.rs/httptest/latest/httptest/trait.IntoTimes.html: trait httptest::IntoTimes - IntoTimes\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `httptest` crate provides a convenient way to test HTTP clients by simulating a locally running HTTP server with configurable expectations and responses. Key features include defining request matchers, response behaviors, and expected call counts, with automatic verification of expectations on server drop. It supports server pooling for resource efficiency in large test suites and offers flexible matchers and responders for custom test scenarios.",
    "feature_summary": null,
    "use_case": "DevTools",
    "score": 6.0,
    "factual_counterfactual": "### Pair 1: Server Behavior\n\u2705 **Factual**: The `httptest` crate verifies all expectations on server `Drop`, ensuring that all expected requests were received and matched, and it panics if any expectation is unmet or if unmatched requests were received.  \n\u274c **Counterfactual**: The `httptest` crate automatically clears all expectations when the server receives a request, allowing unmatched requests to pass without verification.\n\n---\n\n### Pair 2: Request Matchers\n\u2705 **Factual**: The `httptest` crate provides composable request matchers, such as `request::method` and `request::path`, which can be combined using macros like `all_of!` to define complex matching logic.  \n\u274c **Counterfactual**: The `httptest` crate requires users to manually implement their own request matchers, as it does not provide predefined matchers or composition macros.\n\n---\n\n### Pair 3: Server Pooling\n\u2705 **Factual**: The `ServerPool` feature in `httptest` allows limiting the number of concurrent servers, preventing resource exhaustion during large test suites by blocking additional server creation until resources are freed.  \n\u274c **Counterfactual**: The `ServerPool` feature in `httptest` dynamically allocates servers without any concurrency limits, potentially leading to resource exhaustion in large test suites.",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}