{
    "name": "lapin",
    "version": "3.0.0",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/lapin/latest/lapin/all.html \"show sidebar\")\n# Crate lapinCopy item path\n[Settings](https://docs.rs/lapin/latest/settings.html)\n[Help](https://docs.rs/lapin/latest/help.html)\nSummary[Source](https://docs.rs/lapin/latest/src/lapin/lib.rs.html#1-166)\nExpand description\nlapin\nThis project follows the AMQP 0.9.1 specifications, targeting especially RabbitMQ.\nThe main access point is the [`Channel`](https://docs.rs/lapin/latest/lapin/struct.Channel.html), which contains the individual AMQP methods. As to the AMQP specification, one TCP [`Connection`](https://docs.rs/lapin/latest/lapin/struct.Connection.html) can contain multiple channels.\n### [\u00a7](https://docs.rs/lapin/latest/lapin/#feature-switches)Feature switches\n  * `codegen`: generate code instead of using pregenerated one\n  * `native-tls`: enable amqps support through native-tls (preferred over rustls when set)\n  * `openssl`: enable amqps support through openssl (preferred over rustls when set)\n  * `rustls` (_default_): enable amqps support through rustls (uses rustls-native-certs by default)\n  * `rustls-native-certs`: same as rustls, be ensure we\u2019ll still use rustls-native-certs even if the default for rustls changes\n  * `rustls-webpki-roots-certs`: same as rustls but using webkit-roots instead of rustls-native-certs\n\n\n### [\u00a7](https://docs.rs/lapin/latest/lapin/#example)Example\n```\nuse futures_lite::stream::StreamExt;\nuse lapin::{\n  options::*, publisher_confirm::Confirmation, types::FieldTable, BasicProperties, Connection,\n  ConnectionProperties, Result,\n};\nuse tracing::info;\nfn main() -> Result<()> {\n  if std::env::var(\"RUST_LOG\").is_err() {\n    unsafe { std::env::set_var(\"RUST_LOG\", \"info\") };\n  }\n  tracing_subscriber::fmt::init();\n  let addr = std::env::var(\"AMQP_ADDR\").unwrap_or_else(|_| \"amqp://127.0.0.1:5672/%2f\".into());\n  async_global_executor::block_on(async {\n    let conn = Connection::connect(\n      &addr,\n      ConnectionProperties::default(),\n    )\n    .await?;\n    info!(\"CONNECTED\");\n    let channel_a = conn.create_channel().await?;\n    let channel_b = conn.create_channel().await?;\n    let queue = channel_a\n      .queue_declare(\n        \"hello\",\n        QueueDeclareOptions::default(),\n        FieldTable::default(),\n      )\n      .await?;\n    info!(?queue, \"Declared queue\");\n    let mut consumer = channel_b\n      .basic_consume(\n        \"hello\",\n        \"my_consumer\",\n        BasicConsumeOptions::default(),\n        FieldTable::default(),\n      )\n      .await?;\n    async_global_executor::spawn(async move {\n      info!(\"will consume\");\n      while let Some(delivery) = consumer.next().await {\n        let delivery = delivery.expect(\"error in consumer\");\n        delivery\n          .ack(BasicAckOptions::default())\n          .await\n          .expect(\"ack\");\n      }\n    }).detach();\n    let payload = b\"Hello world!\";\n    loop {\n      let confirm = channel_a\n        .basic_publish(\n          \"\",\n          \"hello\",\n          BasicPublishOptions::default(),\n          payload,\n          BasicProperties::default(),\n        )\n        .await?\n        .await?;\n      assert_eq!(confirm, Confirmation::NotRequested);\n    }\n  })\n}\n```\n\n## Re-exports[\u00a7](https://docs.rs/lapin/latest/lapin/#reexports)\n\n`pub use amq_protocol::tcp[](https://docs.rs/amq-protocol-tcp/8.1.2/x86_64-unknown-linux-gnu/amq_protocol_tcp/index.html \"mod amq_protocol_tcp\");`\n\n\n`pub use amq_protocol::types[](https://docs.rs/amq-protocol-types/8.1.2/x86_64-unknown-linux-gnu/amq_protocol_types/index.html \"mod amq_protocol_types\");`\n\n\n`pub use amq_protocol::uri[](https://docs.rs/amq-protocol-uri/8.1.2/x86_64-unknown-linux-gnu/amq_protocol_uri/index.html \"mod amq_protocol_uri\");`\n\n## Modules[\u00a7](https://docs.rs/lapin/latest/lapin/#modules)\n\n[acker](https://docs.rs/lapin/latest/lapin/acker/index.html \"mod lapin::acker\")\n\n\n[auth](https://docs.rs/lapin/latest/lapin/auth/index.html \"mod lapin::auth\")\n    Utility to handle SASL authentication with AMQP server\n\n[heartbeat](https://docs.rs/lapin/latest/lapin/heartbeat/index.html \"mod lapin::heartbeat\")\n\n\n[message](https://docs.rs/lapin/latest/lapin/message/index.html \"mod lapin::message\")\n\n\n[options](https://docs.rs/lapin/latest/lapin/options/index.html \"mod lapin::options\")\n\n\n[protocol](https://docs.rs/lapin/latest/lapin/protocol/index.html \"mod lapin::protocol\")\n    The AMQ Protocol implementation (Generated)\n\n[publisher_confirm](https://docs.rs/lapin/latest/lapin/publisher_confirm/index.html \"mod lapin::publisher_confirm\")\n\n\n[socket_state](https://docs.rs/lapin/latest/lapin/socket_state/index.html \"mod lapin::socket_state\")\n\n## Structs[\u00a7](https://docs.rs/lapin/latest/lapin/#structs)\n\n[Channel](https://docs.rs/lapin/latest/lapin/struct.Channel.html \"struct lapin::Channel\")\n    Main entry point for most AMQP operations.\n\n[ChannelStatus](https://docs.rs/lapin/latest/lapin/struct.ChannelStatus.html \"struct lapin::ChannelStatus\")\n\n\n[Configuration](https://docs.rs/lapin/latest/lapin/struct.Configuration.html \"struct lapin::Configuration\")\n\n\n[Connection](https://docs.rs/lapin/latest/lapin/struct.Connection.html \"struct lapin::Connection\")\n    A TCP connection to the AMQP server.\n\n[ConnectionProperties](https://docs.rs/lapin/latest/lapin/struct.ConnectionProperties.html \"struct lapin::ConnectionProperties\")\n\n\n[ConnectionStatus](https://docs.rs/lapin/latest/lapin/struct.ConnectionStatus.html \"struct lapin::ConnectionStatus\")\n\n\n[Consumer](https://docs.rs/lapin/latest/lapin/struct.Consumer.html \"struct lapin::Consumer\")\n    Continuously consumes message from a Queue.\n\n[Error](https://docs.rs/lapin/latest/lapin/struct.Error.html \"struct lapin::Error\")\n    The error that can be returned in this crate.\n\n[Queue](https://docs.rs/lapin/latest/lapin/struct.Queue.html \"struct lapin::Queue\")\n\n\n[RecoveryConfig](https://docs.rs/lapin/latest/lapin/struct.RecoveryConfig.html \"struct lapin::RecoveryConfig\")\n\n## Enums[\u00a7](https://docs.rs/lapin/latest/lapin/#enums)\n\n[ChannelState](https://docs.rs/lapin/latest/lapin/enum.ChannelState.html \"enum lapin::ChannelState\")\n\n\n[ConnectionState](https://docs.rs/lapin/latest/lapin/enum.ConnectionState.html \"enum lapin::ConnectionState\")\n\n\n[ConsumerState](https://docs.rs/lapin/latest/lapin/enum.ConsumerState.html \"enum lapin::ConsumerState\")\n\n\n[ErrorKind](https://docs.rs/lapin/latest/lapin/enum.ErrorKind.html \"enum lapin::ErrorKind\")\n    The type of error that can be returned in this crate.\n\n[ExchangeKind](https://docs.rs/lapin/latest/lapin/enum.ExchangeKind.html \"enum lapin::ExchangeKind\")\n\n\n[TcpStream](https://docs.rs/lapin/latest/lapin/enum.TcpStream.html \"enum lapin::TcpStream\")\n    Wrapper around plain or TLS TCP streams\n## Traits[\u00a7](https://docs.rs/lapin/latest/lapin/#traits)\n\n[Connect](https://docs.rs/lapin/latest/lapin/trait.Connect.html \"trait lapin::Connect\")\n    Trait providing a method to connect to an AMQP server\n\n[ConsumerDelegate](https://docs.rs/lapin/latest/lapin/trait.ConsumerDelegate.html \"trait lapin::ConsumerDelegate\")\n\n## Type Aliases[\u00a7](https://docs.rs/lapin/latest/lapin/#types)\n\n[BasicProperties](https://docs.rs/lapin/latest/lapin/type.BasicProperties.html \"type lapin::BasicProperties\")\n    Type alias for AMQP BasicProperties\n\n[Result](https://docs.rs/lapin/latest/lapin/type.Result.html \"type lapin::Result\")\n    A std Result with a lapin::Error error type\n",
        "markdown_with_citations": "[](https://docs.rs/lapin/latest/lapin/all.html \"show sidebar\")\n# Crate lapinCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nlapin\nThis project follows the AMQP 0.9.1 specifications, targeting especially RabbitMQ.\nThe main access point is the `Channel`\u27e84\u27e9, which contains the individual AMQP methods. As to the AMQP specification, one TCP `Connection`\u27e85\u27e9 can contain multiple channels.\n### \u00a7\u27e86\u27e9Feature switches\n  * `codegen`: generate code instead of using pregenerated one\n  * `native-tls`: enable amqps support through native-tls (preferred over rustls when set)\n  * `openssl`: enable amqps support through openssl (preferred over rustls when set)\n  * `rustls` (_default_): enable amqps support through rustls (uses rustls-native-certs by default)\n  * `rustls-native-certs`: same as rustls, be ensure we\u2019ll still use rustls-native-certs even if the default for rustls changes\n  * `rustls-webpki-roots-certs`: same as rustls but using webkit-roots instead of rustls-native-certs\n\n\n### \u00a7\u27e87\u27e9Example\n```\nuse futures_lite::stream::StreamExt;\nuse lapin::{\n  options::*, publisher_confirm::Confirmation, types::FieldTable, BasicProperties, Connection,\n  ConnectionProperties, Result,\n};\nuse tracing::info;\nfn main() -> Result<()> {\n  if std::env::var(\"RUST_LOG\").is_err() {\n    unsafe { std::env::set_var(\"RUST_LOG\", \"info\") };\n  }\n  tracing_subscriber::fmt::init();\n  let addr = std::env::var(\"AMQP_ADDR\").unwrap_or_else(|_| \"amqp://127.0.0.1:5672/%2f\".into());\n  async_global_executor::block_on(async {\n    let conn = Connection::connect(\n      &addr,\n      ConnectionProperties::default(),\n    )\n    .await?;\n    info!(\"CONNECTED\");\n    let channel_a = conn.create_channel().await?;\n    let channel_b = conn.create_channel().await?;\n    let queue = channel_a\n      .queue_declare(\n        \"hello\",\n        QueueDeclareOptions::default(),\n        FieldTable::default(),\n      )\n      .await?;\n    info!(?queue, \"Declared queue\");\n    let mut consumer = channel_b\n      .basic_consume(\n        \"hello\",\n        \"my_consumer\",\n        BasicConsumeOptions::default(),\n        FieldTable::default(),\n      )\n      .await?;\n    async_global_executor::spawn(async move {\n      info!(\"will consume\");\n      while let Some(delivery) = consumer.next().await {\n        let delivery = delivery.expect(\"error in consumer\");\n        delivery\n          .ack(BasicAckOptions::default())\n          .await\n          .expect(\"ack\");\n      }\n    }).detach();\n    let payload = b\"Hello world!\";\n    loop {\n      let confirm = channel_a\n        .basic_publish(\n          \"\",\n          \"hello\",\n          BasicPublishOptions::default(),\n          payload,\n          BasicProperties::default(),\n        )\n        .await?\n        .await?;\n      assert_eq!(confirm, Confirmation::NotRequested);\n    }\n  })\n}\n```\n\n## Re-exports\u00a7\u27e88\u27e9\n\n`pub use amq_protocol::tcp[](https://docs.rs/amq-protocol-tcp/8.1.2/x86_64-unknown-linux-gnu/amq_protocol_tcp/index.html \"mod amq_protocol_tcp\");`\n\n\n`pub use amq_protocol::types[](https://docs.rs/amq-protocol-types/8.1.2/x86_64-unknown-linux-gnu/amq_protocol_types/index.html \"mod amq_protocol_types\");`\n\n\n`pub use amq_protocol::uri[](https://docs.rs/amq-protocol-uri/8.1.2/x86_64-unknown-linux-gnu/amq_protocol_uri/index.html \"mod amq_protocol_uri\");`\n\n## Modules\u00a7\u27e89\u27e9\n\nacker\u27e810\u27e9\n\n\nauth\u27e811\u27e9\n    Utility to handle SASL authentication with AMQP server\n\nheartbeat\u27e812\u27e9\n\n\nmessage\u27e813\u27e9\n\n\noptions\u27e814\u27e9\n\n\nprotocol\u27e815\u27e9\n    The AMQ Protocol implementation (Generated)\n\npublisher_confirm\u27e816\u27e9\n\n\nsocket_state\u27e817\u27e9\n\n## Structs\u00a7\u27e818\u27e9\n\nChannel\u27e84\u27e9\n    Main entry point for most AMQP operations.\n\nChannelStatus\u27e819\u27e9\n\n\nConfiguration\u27e820\u27e9\n\n\nConnection\u27e85\u27e9\n    A TCP connection to the AMQP server.\n\nConnectionProperties\u27e821\u27e9\n\n\nConnectionStatus\u27e822\u27e9\n\n\nConsumer\u27e823\u27e9\n    Continuously consumes message from a Queue.\n\nError\u27e824\u27e9\n    The error that can be returned in this crate.\n\nQueue\u27e825\u27e9\n\n\nRecoveryConfig\u27e826\u27e9\n\n## Enums\u00a7\u27e827\u27e9\n\nChannelState\u27e828\u27e9\n\n\nConnectionState\u27e829\u27e9\n\n\nConsumerState\u27e830\u27e9\n\n\nErrorKind\u27e831\u27e9\n    The type of error that can be returned in this crate.\n\nExchangeKind\u27e832\u27e9\n\n\nTcpStream\u27e833\u27e9\n    Wrapper around plain or TLS TCP streams\n## Traits\u00a7\u27e834\u27e9\n\nConnect\u27e835\u27e9\n    Trait providing a method to connect to an AMQP server\n\nConsumerDelegate\u27e836\u27e9\n\n## Type Aliases\u00a7\u27e837\u27e9\n\nBasicProperties\u27e838\u27e9\n    Type alias for AMQP BasicProperties\n\nResult\u27e839\u27e9\n    A std Result with a lapin::Error error type\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/lapin/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/lapin/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/lapin/latest/src/lapin/lib.rs.html#1-166: Source\n\u27e84\u27e9 https://docs.rs/lapin/latest/lapin/struct.Channel.html: `Channel`\n\u27e85\u27e9 https://docs.rs/lapin/latest/lapin/struct.Connection.html: `Connection`\n\u27e86\u27e9 https://docs.rs/lapin/latest/lapin/#feature-switches: \u00a7\n\u27e87\u27e9 https://docs.rs/lapin/latest/lapin/#example: \u00a7\n\u27e88\u27e9 https://docs.rs/lapin/latest/lapin/#reexports: \u00a7\n\u27e89\u27e9 https://docs.rs/lapin/latest/lapin/#modules: \u00a7\n\u27e810\u27e9 https://docs.rs/lapin/latest/lapin/acker/index.html: mod lapin::acker - acker\n\u27e811\u27e9 https://docs.rs/lapin/latest/lapin/auth/index.html: mod lapin::auth - auth\n\u27e812\u27e9 https://docs.rs/lapin/latest/lapin/heartbeat/index.html: mod lapin::heartbeat - heartbeat\n\u27e813\u27e9 https://docs.rs/lapin/latest/lapin/message/index.html: mod lapin::message - message\n\u27e814\u27e9 https://docs.rs/lapin/latest/lapin/options/index.html: mod lapin::options - options\n\u27e815\u27e9 https://docs.rs/lapin/latest/lapin/protocol/index.html: mod lapin::protocol - protocol\n\u27e816\u27e9 https://docs.rs/lapin/latest/lapin/publisher_confirm/index.html: mod lapin::publisher_confirm - publisher_confirm\n\u27e817\u27e9 https://docs.rs/lapin/latest/lapin/socket_state/index.html: mod lapin::socket_state - socket_state\n\u27e818\u27e9 https://docs.rs/lapin/latest/lapin/#structs: \u00a7\n\u27e819\u27e9 https://docs.rs/lapin/latest/lapin/struct.ChannelStatus.html: struct lapin::ChannelStatus - ChannelStatus\n\u27e820\u27e9 https://docs.rs/lapin/latest/lapin/struct.Configuration.html: struct lapin::Configuration - Configuration\n\u27e821\u27e9 https://docs.rs/lapin/latest/lapin/struct.ConnectionProperties.html: struct lapin::ConnectionProperties - ConnectionProperties\n\u27e822\u27e9 https://docs.rs/lapin/latest/lapin/struct.ConnectionStatus.html: struct lapin::ConnectionStatus - ConnectionStatus\n\u27e823\u27e9 https://docs.rs/lapin/latest/lapin/struct.Consumer.html: struct lapin::Consumer - Consumer\n\u27e824\u27e9 https://docs.rs/lapin/latest/lapin/struct.Error.html: struct lapin::Error - Error\n\u27e825\u27e9 https://docs.rs/lapin/latest/lapin/struct.Queue.html: struct lapin::Queue - Queue\n\u27e826\u27e9 https://docs.rs/lapin/latest/lapin/struct.RecoveryConfig.html: struct lapin::RecoveryConfig - RecoveryConfig\n\u27e827\u27e9 https://docs.rs/lapin/latest/lapin/#enums: \u00a7\n\u27e828\u27e9 https://docs.rs/lapin/latest/lapin/enum.ChannelState.html: enum lapin::ChannelState - ChannelState\n\u27e829\u27e9 https://docs.rs/lapin/latest/lapin/enum.ConnectionState.html: enum lapin::ConnectionState - ConnectionState\n\u27e830\u27e9 https://docs.rs/lapin/latest/lapin/enum.ConsumerState.html: enum lapin::ConsumerState - ConsumerState\n\u27e831\u27e9 https://docs.rs/lapin/latest/lapin/enum.ErrorKind.html: enum lapin::ErrorKind - ErrorKind\n\u27e832\u27e9 https://docs.rs/lapin/latest/lapin/enum.ExchangeKind.html: enum lapin::ExchangeKind - ExchangeKind\n\u27e833\u27e9 https://docs.rs/lapin/latest/lapin/enum.TcpStream.html: enum lapin::TcpStream - TcpStream\n\u27e834\u27e9 https://docs.rs/lapin/latest/lapin/#traits: \u00a7\n\u27e835\u27e9 https://docs.rs/lapin/latest/lapin/trait.Connect.html: trait lapin::Connect - Connect\n\u27e836\u27e9 https://docs.rs/lapin/latest/lapin/trait.ConsumerDelegate.html: trait lapin::ConsumerDelegate - ConsumerDelegate\n\u27e837\u27e9 https://docs.rs/lapin/latest/lapin/#types: \u00a7\n\u27e838\u27e9 https://docs.rs/lapin/latest/lapin/type.BasicProperties.html: type lapin::BasicProperties - BasicProperties\n\u27e839\u27e9 https://docs.rs/lapin/latest/lapin/type.Result.html: type lapin::Result - Result\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `lapin` crate is an AMQP 0.9.1 client library designed for interacting with RabbitMQ. It provides abstractions for managing TCP connections, channels, queues, message publishing, and consumption. Key features include support for TLS (via `rustls`, `native-tls`, or `openssl`), publisher confirmations, SASL authentication, and configurable connection properties.",
    "feature_summary": null,
    "use_case": "Networking",
    "score": 8.0,
    "factual_counterfactual": "### Pair 1: Connection and Channels\n\u2705 Factual: The `lapin` crate allows a single TCP `Connection` to manage multiple AMQP `Channel`s, as per the AMQP 0.9.1 specification.  \n\u274c Counterfactual: The `lapin` crate restricts each TCP `Connection` to a single AMQP `Channel`, requiring a new connection for each channel.  \n\n---\n\n### Pair 2: TLS Support\n\u2705 Factual: The `lapin` crate supports AMQPS (AMQP over TLS) using multiple options, including `rustls`, `native-tls`, and `openssl`. By default, it uses `rustls`.  \n\u274c Counterfactual: The `lapin` crate only supports AMQP without TLS and does not provide any options for secure communication.  \n\n---\n\n### Pair 3: Consumer Behavior\n\u2705 Factual: The `lapin` crate provides a `Consumer` struct that can continuously consume messages from a queue, with support for acknowledging deliveries.  \n\u274c Counterfactual: The `lapin` crate does not support message consumption from queues and only provides publishing capabilities.  \n\n---",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}