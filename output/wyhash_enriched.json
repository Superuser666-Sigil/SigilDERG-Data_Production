{
    "name": "wyhash",
    "version": "0.6.0",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/wyhash/latest/wyhash/all.html \"show sidebar\")\n# Crate wyhashCopy item path\n[Settings](https://docs.rs/wyhash/latest/settings.html)\n[Help](https://docs.rs/wyhash/latest/help.html)\nSummary[Source](https://docs.rs/wyhash/latest/src/wyhash/lib.rs.html#1-114)\nExpand description\nRust implementation of the [wyhash algorithm by Wang Yi](https://github.com/wangyi-fudan/wyhash).\nThe hashing algorithm passes SMHasher and the random number generator passes BigCrush and practrand. As of now it is the fastest algorithm in the SMHasher benchmark (faster than t1ha and XXH3). See [here](https://github.com/wangyi-fudan/wyhash).\nFurthermore, this algorithm is solid, simple, portable (does not need hardware support, can be used in `no_std` environments) and has no dependencies.\nThe generated hashes are equal (see tests) as of the version stated [here](https://github.com/eldruin/wyhash-rs/blob/master/comparison/original/CMakeLists.txt) although the speed varies ([PRs are welcome](https://github.com/eldruin/wyhash-rs/issues)).\n### [\u00a7](https://docs.rs/wyhash/latest/wyhash/#crate-features)Crate features\nBy default this crate uses 128-bit integer multiplications. To restrict that to 64 bits you can enable the feature `mum32bit`. This offers better performance on 32-bit architectures. Beware that this feature produces different the results.\n### [\u00a7](https://docs.rs/wyhash/latest/wyhash/#usage-see-also-examples-folder)Usage (see also examples folder)\nFor the hashing function you can use either the free function or the `Hasher` trait.\n#### [\u00a7](https://docs.rs/wyhash/latest/wyhash/#wyhash-function-usage)`wyhash` function usage\n```\nuse wyhash::wyhash;\nlet data = [0, 1, 2];\nlet seed = 3;\nlet hash = wyhash(&data, seed);\nprintln!(\"{:x}\", hash); // prints b0f941520b1ad95d\n```\n\n#### [\u00a7](https://docs.rs/wyhash/latest/wyhash/#hasher-trait-usage)`Hasher` trait usage\nYou can also use `std::hash::Hasher`, it is the same.\n```\nuse core::hash::Hasher;\nuse wyhash::WyHash;\nlet mut hasher = WyHash::with_seed(3);\nhasher.write(&[0, 1, 2]);\nprintln!(\"{:x}\", hasher.finish()); // prints b0f941520b1ad95d\n```\n\n#### [\u00a7](https://docs.rs/wyhash/latest/wyhash/#wyrng-function-usage)`wyrng` function usage\nNote that the seed parameter is updated so that it is possible to generate a sequence of random numbers.\n```\nuse wyhash::wyrng;\nlet mut seed = 3;\nlet random_number = wyrng(&mut seed);\nprintln!(\"{:x}\", random_number); // prints 3e99a772750dcbe\nprintln!(\"{:x}\", seed); //prints a0761d6478bd6432\n```\n\n#### [\u00a7](https://docs.rs/wyhash/latest/wyhash/#rngcore-trait-usage)`RngCore` trait usage\nYou can also use `rand::Rng`, it is the same.\n```\nuse rand_core::RngCore;\nuse wyhash::WyRng;\nlet mut rng = WyRng::default();\nprintln!(\"{:x}\", rng.next_u64()); // prints 111cb3a78f59a58e\n```\n\n#### [\u00a7](https://docs.rs/wyhash/latest/wyhash/#seedablerng-trait-usage)`SeedableRng` trait usage\nYou can also use `rand::SeedableRng`, it is the same.\n```\nuse rand_core::{RngCore, SeedableRng};\nuse wyhash::WyRng;\n// Seeds are 8-byte long.\nlet seed = [0, 1, 2, 3, 4, 5, 6, 7];\nlet mut rng1 = WyRng::from_seed(seed);\nprintln!(\"{:x}\", rng1.next_u64()); // prints d730135774c6ae31\n// Alternatively you can also use this convenience method:\nlet mut rng2 = WyRng::seed_from_u64(3);\nprintln!(\"{:x}\", rng2.next_u64()); // prints 3e99a772750dcbe\n```\n\n## Re-exports[\u00a7](https://docs.rs/wyhash/latest/wyhash/#reexports)\n\n`pub use crate::v1::wyhash[](https://docs.rs/wyhash/latest/wyhash/v1/fn.wyhash.html \"fn wyhash::v1::wyhash\");`\n\n\n`pub use crate::v1::wyrng[](https://docs.rs/wyhash/latest/wyhash/v1/fn.wyrng.html \"fn wyhash::v1::wyrng\");`\n\n\n`pub use crate::v1::WyHash[](https://docs.rs/wyhash/latest/wyhash/v1/struct.WyHash.html \"struct wyhash::v1::WyHash\");`\n\n\n`pub use crate::v1::WyHasherBuilder[](https://docs.rs/wyhash/latest/wyhash/v1/struct.WyHasherBuilder.html \"struct wyhash::v1::WyHasherBuilder\");`\n\n\n`pub use crate::v1::WyRng[](https://docs.rs/wyhash/latest/wyhash/v1/struct.WyRng.html \"struct wyhash::v1::WyRng\");`\n\n## Modules[\u00a7](https://docs.rs/wyhash/latest/wyhash/#modules)\n\n[final3](https://docs.rs/wyhash/latest/wyhash/final3/index.html \"mod wyhash::final3\")\n    WyHash version final 3\n\n[v1](https://docs.rs/wyhash/latest/wyhash/v1/index.html \"mod wyhash::v1\")\n    WyHash version 1\n",
        "markdown_with_citations": "[](https://docs.rs/wyhash/latest/wyhash/all.html \"show sidebar\")\n# Crate wyhashCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nRust implementation of the wyhash algorithm by Wang Yi\u27e84\u27e9.\nThe hashing algorithm passes SMHasher and the random number generator passes BigCrush and practrand. As of now it is the fastest algorithm in the SMHasher benchmark (faster than t1ha and XXH3). See here\u27e84\u27e9.\nFurthermore, this algorithm is solid, simple, portable (does not need hardware support, can be used in `no_std` environments) and has no dependencies.\nThe generated hashes are equal (see tests) as of the version stated here\u27e85\u27e9 although the speed varies (PRs are welcome\u27e86\u27e9).\n### \u00a7\u27e87\u27e9Crate features\nBy default this crate uses 128-bit integer multiplications. To restrict that to 64 bits you can enable the feature `mum32bit`. This offers better performance on 32-bit architectures. Beware that this feature produces different the results.\n### \u00a7\u27e88\u27e9Usage (see also examples folder)\nFor the hashing function you can use either the free function or the `Hasher` trait.\n#### \u00a7\u27e89\u27e9`wyhash` function usage\n```\nuse wyhash::wyhash;\nlet data = [0, 1, 2];\nlet seed = 3;\nlet hash = wyhash(&data, seed);\nprintln!(\"{:x}\", hash); // prints b0f941520b1ad95d\n```\n\n#### \u00a7\u27e810\u27e9`Hasher` trait usage\nYou can also use `std::hash::Hasher`, it is the same.\n```\nuse core::hash::Hasher;\nuse wyhash::WyHash;\nlet mut hasher = WyHash::with_seed(3);\nhasher.write(&[0, 1, 2]);\nprintln!(\"{:x}\", hasher.finish()); // prints b0f941520b1ad95d\n```\n\n#### \u00a7\u27e811\u27e9`wyrng` function usage\nNote that the seed parameter is updated so that it is possible to generate a sequence of random numbers.\n```\nuse wyhash::wyrng;\nlet mut seed = 3;\nlet random_number = wyrng(&mut seed);\nprintln!(\"{:x}\", random_number); // prints 3e99a772750dcbe\nprintln!(\"{:x}\", seed); //prints a0761d6478bd6432\n```\n\n#### \u00a7\u27e812\u27e9`RngCore` trait usage\nYou can also use `rand::Rng`, it is the same.\n```\nuse rand_core::RngCore;\nuse wyhash::WyRng;\nlet mut rng = WyRng::default();\nprintln!(\"{:x}\", rng.next_u64()); // prints 111cb3a78f59a58e\n```\n\n#### \u00a7\u27e813\u27e9`SeedableRng` trait usage\nYou can also use `rand::SeedableRng`, it is the same.\n```\nuse rand_core::{RngCore, SeedableRng};\nuse wyhash::WyRng;\n// Seeds are 8-byte long.\nlet seed = [0, 1, 2, 3, 4, 5, 6, 7];\nlet mut rng1 = WyRng::from_seed(seed);\nprintln!(\"{:x}\", rng1.next_u64()); // prints d730135774c6ae31\n// Alternatively you can also use this convenience method:\nlet mut rng2 = WyRng::seed_from_u64(3);\nprintln!(\"{:x}\", rng2.next_u64()); // prints 3e99a772750dcbe\n```\n\n## Re-exports\u00a7\u27e814\u27e9\n\n`pub use crate::v1::wyhash[](https://docs.rs/wyhash/latest/wyhash/v1/fn.wyhash.html \"fn wyhash::v1::wyhash\");`\n\n\n`pub use crate::v1::wyrng[](https://docs.rs/wyhash/latest/wyhash/v1/fn.wyrng.html \"fn wyhash::v1::wyrng\");`\n\n\n`pub use crate::v1::WyHash[](https://docs.rs/wyhash/latest/wyhash/v1/struct.WyHash.html \"struct wyhash::v1::WyHash\");`\n\n\n`pub use crate::v1::WyHasherBuilder[](https://docs.rs/wyhash/latest/wyhash/v1/struct.WyHasherBuilder.html \"struct wyhash::v1::WyHasherBuilder\");`\n\n\n`pub use crate::v1::WyRng[](https://docs.rs/wyhash/latest/wyhash/v1/struct.WyRng.html \"struct wyhash::v1::WyRng\");`\n\n## Modules\u00a7\u27e815\u27e9\n\nfinal3\u27e816\u27e9\n    WyHash version final 3\n\nv1\u27e817\u27e9\n    WyHash version 1\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/wyhash/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/wyhash/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/wyhash/latest/src/wyhash/lib.rs.html#1-114: Source\n\u27e84\u27e9 https://github.com/wangyi-fudan/wyhash: wyhash algorithm by Wang Yi\n\u27e85\u27e9 https://github.com/eldruin/wyhash-rs/blob/master/comparison/original/CMakeLists.txt: here\n\u27e86\u27e9 https://github.com/eldruin/wyhash-rs/issues: PRs are welcome\n\u27e87\u27e9 https://docs.rs/wyhash/latest/wyhash/#crate-features: \u00a7\n\u27e88\u27e9 https://docs.rs/wyhash/latest/wyhash/#usage-see-also-examples-folder: \u00a7\n\u27e89\u27e9 https://docs.rs/wyhash/latest/wyhash/#wyhash-function-usage: \u00a7\n\u27e810\u27e9 https://docs.rs/wyhash/latest/wyhash/#hasher-trait-usage: \u00a7\n\u27e811\u27e9 https://docs.rs/wyhash/latest/wyhash/#wyrng-function-usage: \u00a7\n\u27e812\u27e9 https://docs.rs/wyhash/latest/wyhash/#rngcore-trait-usage: \u00a7\n\u27e813\u27e9 https://docs.rs/wyhash/latest/wyhash/#seedablerng-trait-usage: \u00a7\n\u27e814\u27e9 https://docs.rs/wyhash/latest/wyhash/#reexports: \u00a7\n\u27e815\u27e9 https://docs.rs/wyhash/latest/wyhash/#modules: \u00a7\n\u27e816\u27e9 https://docs.rs/wyhash/latest/wyhash/final3/index.html: mod wyhash::final3 - final3\n\u27e817\u27e9 https://docs.rs/wyhash/latest/wyhash/v1/index.html: mod wyhash::v1 - v1\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `wyhash` crate is a Rust implementation of the Wyhash algorithm, known for its speed, simplicity, and portability, passing SMHasher, BigCrush, and PractRand benchmarks. It supports hashing via free functions or the `Hasher` trait, random number generation with `wyrng`, and integration with `rand` traits like `RngCore` and `SeedableRng`. The crate is `no_std` compatible, has no dependencies, and includes an optional `mum32bit` feature for optimized performance on 32-bit architectures.",
    "feature_summary": null,
    "use_case": "Utilities",
    "score": 6.0,
    "factual_counterfactual": "### Pair 1: Hashing Algorithm Performance  \n\u2705 **Factual:** The `wyhash` crate implements the WyHash algorithm, which is currently the fastest hashing algorithm in the SMHasher benchmark, outperforming alternatives like `t1ha` and `XXH3`.  \n\u274c **Counterfactual:** The `wyhash` crate's hashing algorithm is slower than `t1ha` and `XXH3` in the SMHasher benchmark but provides better collision resistance.  \n\n---\n\n### Pair 2: Portability and `no_std` Support  \n\u2705 **Factual:** The `wyhash` crate is portable and can be used in `no_std` environments, as it does not rely on hardware-specific features.  \n\u274c **Counterfactual:** The `wyhash` crate requires hardware-specific instructions, such as SIMD, and is incompatible with `no_std` environments.  \n\n---\n\n### Pair 3: RNG Seed Behavior  \n\u2705 **Factual:** The `wyrng` function updates the seed parameter after generating a random number, allowing for the creation of a sequence of random numbers.  \n\u274c **Counterfactual:** The `wyrng` function does not modify the seed parameter, requiring manual updates to generate a sequence of random numbers.",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}