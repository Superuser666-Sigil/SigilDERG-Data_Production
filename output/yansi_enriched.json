{
    "name": "yansi",
    "version": "1.0.1",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/yansi/latest/yansi/all.html \"show sidebar\")\n# Crate yansiCopy item path\n[Settings](https://docs.rs/yansi/latest/settings.html)\n[Help](https://docs.rs/yansi/latest/help.html)\nSummary[Source](https://docs.rs/yansi/latest/src/yansi/lib.rs.html#1-373)\nExpand description\nA dead simple ANSI terminal color painting library.\n## [\u00a7](https://docs.rs/yansi/latest/yansi/#features)Features\nWhy _y_ et another _ANSI_ terminal coloring library? Here are some reasons:\n  * This library makes simple things _simple_ : `use` [`Paint`](https://docs.rs/yansi/latest/yansi/trait.Paint.html \"trait yansi::Paint\") and go!\n  * Zero dependencies by default. It really is simple.\n  * Zero allocations except as needed by opt-in [wrapping](https://docs.rs/yansi/latest/yansi/#wrapping).\n  * [Automatic Windows support](https://docs.rs/yansi/latest/yansi/#windows) for the vast majority (95%+) of Windows users.\n  * [Featureful `no_std`](https://docs.rs/yansi/latest/yansi/#crate-features), no-`alloc`, support with `default-features = false`.\n  * [`Style` constructors are `const`](https://docs.rs/yansi/latest/yansi/#uniform-const-builders): store styles statically, even with dynamic conditions!\n  * _Any_ type implementing a formatting trait can be styled, not just strings.\n  * Styling can be [enabled](https://docs.rs/yansi/latest/yansi/fn.enable.html \"fn yansi::enable\") and [disabled](https://docs.rs/yansi/latest/yansi/fn.disable.html \"fn yansi::disable\") globally and [dynamically](https://docs.rs/yansi/latest/yansi/fn.whenever.html \"fn yansi::whenever\"), on the fly.\n  * A `Style` can be predicated on arbitrary [conditions](https://docs.rs/yansi/latest/yansi/#per-style).\n  * Formatting specifiers like `{:x}` and `{:08b}` are supported and preserved!\n  * [Built-in (optional) conditions](https://docs.rs/yansi/latest/yansi/struct.Condition.html#built-in-conditions \"struct yansi::Condition\") for [TTY detection](https://docs.rs/yansi/latest/yansi/struct.Condition.html#impl-Condition-1 \"struct yansi::Condition\") and [common environment variables](https://docs.rs/yansi/latest/yansi/struct.Condition.html#impl-Condition-2 \"struct yansi::Condition\").\n  * Arbitrary items can be [_masked_](https://docs.rs/yansi/latest/yansi/#masking) for selective disabling.\n  * Styling can [_wrap_](https://docs.rs/yansi/latest/yansi/#wrapping) to preserve styling across resets.\n  * Styling can [_linger_](https://docs.rs/yansi/latest/yansi/#lingering) beyond a single value.\n  * Experimental support for [hyperlinking](https://docs.rs/yansi/latest/yansi/hyperlink/index.html \"mod yansi::hyperlink\") is included.\n  * The name `yansi` is pretty cool \ud83d\ude0e.\n\n\nAll that said, `yansi` borrows API ideas from older libraries as well as implementation details from [`ansi_term`](https://crates.io/crates/ansi_term).\n## [\u00a7](https://docs.rs/yansi/latest/yansi/#usage)Usage\nThe [`Paint`](https://docs.rs/yansi/latest/yansi/trait.Paint.html \"trait yansi::Paint\") trait is implemented for every type. Import it and call chainable builder methods:\n```\nuse yansi::Paint;\nprintln!(\"Testing, {}, {}, {}!\",\n  \"Ready\".bold(),\n  \"Set\".yellow().italic(),\n  \"STOP\".white().on_red().bright().underline().bold());\n```\n\n`>` Testing, **Ready** , _**Set**_ , _**STOP**_!\nThe methods return a [`Painted`](https://docs.rs/yansi/latest/yansi/struct.Painted.html \"struct yansi::Painted\") type which consists of a [`Style`](https://docs.rs/yansi/latest/yansi/struct.Style.html \"struct yansi::Style\") and a reference to the receiver. Displaying a [`Painted`](https://docs.rs/yansi/latest/yansi/struct.Painted.html \"struct yansi::Painted\") (via `print!()`, `format!()`, etc) results in emitting ANSI escape codes that effectuate the style.\n### [\u00a7](https://docs.rs/yansi/latest/yansi/#uniform-const-builders)Uniform `const` Builders\nAll builder methods are uniformly available for [`Style`](https://docs.rs/yansi/latest/yansi/struct.Style.html \"struct yansi::Style\"), [`Color`](https://docs.rs/yansi/latest/yansi/enum.Color.html \"enum yansi::Color\"), and [`Painted`](https://docs.rs/yansi/latest/yansi/struct.Painted.html \"struct yansi::Painted\"), which means you can chain calls across library types. All methods are `const`, allowing creations of `const` or `static` [`Style`](https://docs.rs/yansi/latest/yansi/struct.Style.html \"struct yansi::Style\")s. A `Style` can be directly applied to values with [`.paint()`](https://docs.rs/yansi/latest/yansi/trait.Paint.html#method.paint \"method yansi::Paint::paint\"), from [`Paint::paint()`](https://docs.rs/yansi/latest/yansi/trait.Paint.html#method.paint \"method yansi::Paint::paint\"), available for every type:\n```\nuse yansi::{Paint, Style, Color::*};\n// `const` constructors allow static `Style`s for easy reuse\nstatic ALERT: Style = White.bright().underline().italic().on_red();\nprintln!(\"Testing, {}, {}, {}!\",\n  \"Ready\".bold(),\n  \"Set\".yellow().bold(),\n  \"STOP\".paint(ALERT));\n```\n\n`>` Testing, **Ready** , **Set** , __STOP__!\n### [\u00a7](https://docs.rs/yansi/latest/yansi/#conditional-styling)Conditional Styling\n#### [\u00a7](https://docs.rs/yansi/latest/yansi/#globally)Globally\nStyling is enabled by default but can be enabled and disabled globally via [`enable()`](https://docs.rs/yansi/latest/yansi/fn.enable.html \"fn yansi::enable\") and [`disable()`](https://docs.rs/yansi/latest/yansi/fn.disable.html \"fn yansi::disable\"). When styling is disabled, no ANSI escape codes are emitted, and [_masked_](https://docs.rs/yansi/latest/yansi/#masking) values are omitted entirely.\nGlobal styling can also be dynamically enabled and disabled using [`whenever()`](https://docs.rs/yansi/latest/yansi/fn.whenever.html \"fn yansi::whenever\") with an arbitrary [`Condition`](https://docs.rs/yansi/latest/yansi/struct.Condition.html \"struct yansi::Condition\"): a function that returns `true` or `false`. This condition is evaluated each time a [`Painted`](https://docs.rs/yansi/latest/yansi/struct.Painted.html \"struct yansi::Painted\") item is displayed. The associated styling is enabled, and mask values emitted, exactly when and only when the condition returns `true`.\n#### [\u00a7](https://docs.rs/yansi/latest/yansi/#per-style)Per-`Style`\nA specific `Style` can itself be conditionally applied by using [`.whenever()`](https://docs.rs/yansi/latest/yansi/struct.Style.html#method.whenever \"method yansi::Style::whenever\"):\n```\nuse yansi::{Paint, Style, Color::*, Condition};\nstatic WARNING: Style = Black.bold().on_yellow().whenever(Condition::STDERR_IS_TTY);\neprintln!(\"{}\", \"Bees can sting!\".paint(WARNING));\n```\n\nWith the above, if `stderr` is a TTY, then: `>` **Bees can sting!**\nIf it is not a TTY, styling is not emitted: `>` Bees can sting!\nSee [`Condition`](https://docs.rs/yansi/latest/yansi/struct.Condition.html \"struct yansi::Condition\") for a list of built-in conditions which require enabling crate features.\n## [\u00a7](https://docs.rs/yansi/latest/yansi/#quirks)Quirks\nAs a convenience, `yansi` implements several \u201cquirks\u201d, applicable via [`Quirk`](https://docs.rs/yansi/latest/yansi/enum.Quirk.html \"enum yansi::Quirk\") and the respective methods, that modify if and how styling is presented to the terminal. These quirks do not correspond to any ANSI styling sequences.\n### [\u00a7](https://docs.rs/yansi/latest/yansi/#masking)Masking\nItems can be arbitrarily _masked_ with the [`mask()`](https://docs.rs/yansi/latest/yansi/trait.Paint.html#tymethod.mask \"method yansi::Paint::mask\") builder method. Masked values are not emitted when styling is disabled, globally or for a given style. This allows selective output based on whether styling is enabled.\nOne use for this feature is to print certain characters only when styling is enabled. For instance, you might wish to emit the \ud83c\udfa8 emoji when coloring is enabled but not otherwise. This can be accomplished by masking the emoji:\n```\nuse yansi::Paint;\nprintln!(\"I like colors!{}\", \" \ud83c\udfa8\".mask());\n```\n\nWhen styling is enabled, this prints: `>` I like colors! \ud83c\udfa8\nWith styling disabled, this prints: `>` I like colors!\n### [\u00a7](https://docs.rs/yansi/latest/yansi/#wrapping)Wrapping\n**Note:** _Either the`std` or `alloc` feature is required for wrapping. `std` is enabled by default. See [crate features](https://docs.rs/yansi/latest/yansi/#crate-features)._\nStyling can _wrap_ via [`Quirk::Wrap`](https://docs.rs/yansi/latest/yansi/enum.Quirk.html#variant.Wrap \"variant yansi::Quirk::Wrap\") or the equivalent [`wrap()`](https://docs.rs/yansi/latest/yansi/struct.Painted.html#method.wrap \"method yansi::Painted::wrap\") constructor. A wrapping style modifies any styling resets emitted by the internal value so that they correspond to the wrapping style. In other words, the \u201creset\u201d style of the wrapped item is modified to be the style being `.wrap()`d.\nWrapping is useful in situations where opaque and arbitrary values must be styled consistently irrespective of any existing styling. For example, a generic logger might want to style messages based on log levels consistently, even when those messages may already include styling. Wrapping exists to enable such consistent styling:\n```\nuse yansi::Paint;\n// Imagine that `inner` is opaque and we don't know it's styling.\nlet inner = format!(\"{} and {}\", \"Stop\".red(), \"Go\".green());\n// We can use `wrap` to ensure anything in `inner` not styled is blue.\nprintln!(\"Hey! {}\", inner.blue().wrap());\n```\n\nThanks to wrapping, this prints: `>` Hey!  Stop and Go\nWithout wrapping, the reset after `\"Stop\".red()` would not be overwritten: `>` Hey! Stop and Go\nWrapping incurs a performance cost due to an extra allocation and replacement if the wrapped item has styling applied to it. Otherwise, it does not allocate nor incur a meaningful performance cost.\n### [\u00a7](https://docs.rs/yansi/latest/yansi/#lingering)Lingering\nStyling can _linger_ beyond a single value via [`Quirk::Linger`](https://docs.rs/yansi/latest/yansi/enum.Quirk.html#variant.Linger \"variant yansi::Quirk::Linger\") or the equivalent [`linger()`](https://docs.rs/yansi/latest/yansi/struct.Painted.html#method.linger \"method yansi::Painted::linger\") constructor. A lingering style does not reset itself after being applied. In other words, the style lingers on beyond the value it\u2019s applied to, until something else resets the respective styling.\nThe complement to lingering is force resetting via [`Quirk::Resetting`](https://docs.rs/yansi/latest/yansi/enum.Quirk.html#variant.Resetting \"variant yansi::Quirk::Resetting\") or the equivalent [`resetting()`](https://docs.rs/yansi/latest/yansi/struct.Painted.html#method.resetting \"method yansi::Painted::resetting\") constructor. Force resetting, as the name implies, forces a reset suffix to be emitted after the value, irrespective of any lingering applied. It can be used as a way to finalize a lingering style.\nLingering itself is useful in situations where a given style is to be repeated across multiple values, or when style is intended to persist even across values that are not styled with `yansi`. It also allows avoiding unnecessarily repeated ANSI code sequences. The examples below illustrate some scenarios in which lingering is useful:\n```\nuse yansi::Paint;\nprintln!(\"Hello! {} {} things with {} {}?\",\n  \"How\".magenta().underline().linger(),\n  \"are\".italic().linger(),\n  \"you\".on_yellow(), // doesn't linger, so all styling is reset here\n  \"today\".blue());\n```\n\n`>` Hello!  _How _are things with you__ today?\n```\nuse yansi::Paint;\nprintln!(\"Hello! {} {} things with {} {}?\",\n  \"How\".magenta().underline().linger(),\n  \"are\".italic(), // doesn't linger, so all styling is reset here\n  \"you\".on_yellow().linger(),\n  \"today\".blue()); // doesn't linger; styling is reset\n```\n\n`>` Hello!  _How _are__ things with  you today?\n```\nuse yansi::Paint;\nprintln!(\"{} B {} {} {} F\",\n  \"A\".red().linger(),\n  \"C\".underline().linger(),\n  \"D\", // doesn't linger, but no styling applied, thus no reset\n  \"E\".resetting()); // explicitly reset\n```\n\n`>` A B _C D E_ F\n### [\u00a7](https://docs.rs/yansi/latest/yansi/#brightening)Brightening\nMost pimrary colors are available in regular and _bright_ variants, e.g., [`Color::Red`](https://docs.rs/yansi/latest/yansi/enum.Color.html#variant.Red \"variant yansi::Color::Red\") and [`Color::BrightRed`](https://docs.rs/yansi/latest/yansi/enum.Color.html#variant.BrightRed \"variant yansi::Color::BrightRed\"). The [`Quirk::Bright`](https://docs.rs/yansi/latest/yansi/enum.Quirk.html#variant.Bright \"variant yansi::Quirk::Bright\") and [`Quirk::OnBright`](https://docs.rs/yansi/latest/yansi/enum.Quirk.html#variant.OnBright \"variant yansi::Quirk::OnBright\") quirks, typically applied via [`.bright()`](https://docs.rs/yansi/latest/yansi/struct.Painted.html#method.bright \"method yansi::Painted::bright\") and [`.on_bright()`](https://docs.rs/yansi/latest/yansi/struct.Painted.html#method.on_bright \"method yansi::Painted::on_bright\"), provide an alternative, convenient mechanism to select the bright variant of the selected foreground or background color, respectively. The quirk provides no additional colors and is equivalent to selecting the bright variants directly.\n```\nuse yansi::Paint;\n// These are all equivalent.\nprint!(\"{}\", \"Regular\".red());\nprint!(\"{}\", \"Bright\".bright_red());\nprint!(\"{}\", \"Bright\".bright().red());\nprint!(\"{}\", \"Bright\".red().bright());\n// The `bright` quirk lets use choose the bright variants of _any_ color,\n// even when the color or style is unknown at the call site.\nprint!(\"{}\", \"Normal\".paint(STYLE));\nprint!(\"{}\", \"Bright\".paint(STYLE).bright());\n```\n\n`>` Regular Bright Bright Bright **Normal** **Bright**\nThe `bright()` quirk can be applied before or after a color is selected while having the same effect.\n## [\u00a7](https://docs.rs/yansi/latest/yansi/#windows)Windows\nStyling is supported and enabled automatically on Windows beginning with the Windows 10 Anniversary Update, or about [96% of all Windows machines worldwide](https://gs.statcounter.com/os-version-market-share/windows/desktop/worldwide), and likely closer to 100% of developer machines (e.g., 99% of visitors to [rocket.rs](https://rocket.rs) on Windows are on Windows 10+).\nYansi enables styling support on Windows by querying the Windows API on the first attempt to color. If support is available, it is enabled. If support is not available, styling is disabled and no styling sequences are emitted.\n## [\u00a7](https://docs.rs/yansi/latest/yansi/#crate-features)Crate Features\nFeature| Default?| Also Enables| Notes  \n---|---|---|---  \n`std`| **Y**| `alloc`|  Use `std` library.  \n`alloc`| **Y**| |  Use `alloc`. Enables [wrapping](https://docs.rs/yansi/latest/yansi/#wrapping).  \n`detect-tty`| N| `std`| See [optional conditions](https://docs.rs/yansi/latest/yansi/struct.Condition.html#built-in-conditions \"struct yansi::Condition\").  \n`detect-env`| N| `std`| See [optional conditions](https://docs.rs/yansi/latest/yansi/struct.Condition.html#built-in-conditions \"struct yansi::Condition\").  \n`hyperlink`| N| `std`| Enables [hyperlinking](https://docs.rs/yansi/latest/yansi/hyperlink/index.html \"mod yansi::hyperlink\") support.  \nWith `default-features = false`, this crate is `#[no_std]`.\nWithout any features enabled, all functionality except [wrapping](https://docs.rs/yansi/latest/yansi/#wrapping) is available. To recover wrapping _with_ `#[no_std]`, set `default-features = false` and enable the `alloc` feature, which requires `alloc` support.\n## Modules[\u00a7](https://docs.rs/yansi/latest/yansi/#modules)\n\n[hyperlink](https://docs.rs/yansi/latest/yansi/hyperlink/index.html \"mod yansi::hyperlink\")`hyperlink`\n    Experimental support for hyperlinking.\n## Structs[\u00a7](https://docs.rs/yansi/latest/yansi/#structs)\n\n[Condition](https://docs.rs/yansi/latest/yansi/struct.Condition.html \"struct yansi::Condition\")\n    A function that decides whether styling should be applied.\n\n[Painted](https://docs.rs/yansi/latest/yansi/struct.Painted.html \"struct yansi::Painted\")\n    An arbitrary value with a [`Style`](https://docs.rs/yansi/latest/yansi/struct.Style.html \"struct yansi::Style\") applied to it.\n\n[Style](https://docs.rs/yansi/latest/yansi/struct.Style.html \"struct yansi::Style\")\n    A set of styling options.\n## Enums[\u00a7](https://docs.rs/yansi/latest/yansi/#enums)\n\n[Attribute](https://docs.rs/yansi/latest/yansi/enum.Attribute.html \"enum yansi::Attribute\")\n    Enum representing text attributes, largely for text formatting.\n\n[Color](https://docs.rs/yansi/latest/yansi/enum.Color.html \"enum yansi::Color\")\n    Enum representing a terminal color.\n\n[Quirk](https://docs.rs/yansi/latest/yansi/enum.Quirk.html \"enum yansi::Quirk\")\n    Enum representing a `yansi` quirk.\n## Traits[\u00a7](https://docs.rs/yansi/latest/yansi/#traits)\n\n[Paint](https://docs.rs/yansi/latest/yansi/trait.Paint.html \"trait yansi::Paint\")\n    A trait to apply styling to any value. Implemented for all types.\n## Functions[\u00a7](https://docs.rs/yansi/latest/yansi/#functions)\n\n[disable](https://docs.rs/yansi/latest/yansi/fn.disable.html \"fn yansi::disable\")\n    Unconditionally disables styling globally.\n\n[enable](https://docs.rs/yansi/latest/yansi/fn.enable.html \"fn yansi::enable\")\n    Unconditionally enables styling globally.\n\n[is_enabled](https://docs.rs/yansi/latest/yansi/fn.is_enabled.html \"fn yansi::is_enabled\")\n    Returns `true` if styling is globally enabled and `false` otherwise.\n\n[whenever](https://docs.rs/yansi/latest/yansi/fn.whenever.html \"fn yansi::whenever\")\n    Dynamically enables and disables styling globally based on `condition`.\n",
        "markdown_with_citations": "[](https://docs.rs/yansi/latest/yansi/all.html \"show sidebar\")\n# Crate yansiCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nA dead simple ANSI terminal color painting library.\n## \u00a7\u27e84\u27e9Features\nWhy _y_ et another _ANSI_ terminal coloring library? Here are some reasons:\n  * This library makes simple things _simple_ : `use` `Paint`\u27e85\u27e9 and go!\n  * Zero dependencies by default. It really is simple.\n  * Zero allocations except as needed by opt-in wrapping\u27e86\u27e9.\n  * Automatic Windows support\u27e87\u27e9 for the vast majority (95%+) of Windows users.\n  * Featureful `no_std`\u27e88\u27e9, no-`alloc`, support with `default-features = false`.\n  * `Style` constructors are `const`\u27e89\u27e9: store styles statically, even with dynamic conditions!\n  * _Any_ type implementing a formatting trait can be styled, not just strings.\n  * Styling can be enabled\u27e810\u27e9 and disabled\u27e811\u27e9 globally and dynamically\u27e812\u27e9, on the fly.\n  * A `Style` can be predicated on arbitrary conditions\u27e813\u27e9.\n  * Formatting specifiers like `{:x}` and `{:08b}` are supported and preserved!\n  * Built-in (optional) conditions\u27e814\u27e9 for TTY detection\u27e815\u27e9 and common environment variables\u27e816\u27e9.\n  * Arbitrary items can be _masked_\u27e817\u27e9 for selective disabling.\n  * Styling can _wrap_\u27e86\u27e9 to preserve styling across resets.\n  * Styling can _linger_\u27e818\u27e9 beyond a single value.\n  * Experimental support for hyperlinking\u27e819\u27e9 is included.\n  * The name `yansi` is pretty cool \ud83d\ude0e.\n\n\nAll that said, `yansi` borrows API ideas from older libraries as well as implementation details from `ansi_term`\u27e820\u27e9.\n## \u00a7\u27e821\u27e9Usage\nThe `Paint`\u27e85\u27e9 trait is implemented for every type. Import it and call chainable builder methods:\n```\nuse yansi::Paint;\nprintln!(\"Testing, {}, {}, {}!\",\n  \"Ready\".bold(),\n  \"Set\".yellow().italic(),\n  \"STOP\".white().on_red().bright().underline().bold());\n```\n\n`>` Testing, **Ready** , _**Set**_ , _**STOP**_!\nThe methods return a `Painted`\u27e822\u27e9 type which consists of a `Style`\u27e823\u27e9 and a reference to the receiver. Displaying a `Painted`\u27e822\u27e9 (via `print!()`, `format!()`, etc) results in emitting ANSI escape codes that effectuate the style.\n### \u00a7\u27e89\u27e9Uniform `const` Builders\nAll builder methods are uniformly available for `Style`\u27e823\u27e9, `Color`\u27e824\u27e9, and `Painted`\u27e822\u27e9, which means you can chain calls across library types. All methods are `const`, allowing creations of `const` or `static` `Style`\u27e823\u27e9s. A `Style` can be directly applied to values with `.paint()`\u27e825\u27e9, from `Paint::paint()`\u27e825\u27e9, available for every type:\n```\nuse yansi::{Paint, Style, Color::*};\n// `const` constructors allow static `Style`s for easy reuse\nstatic ALERT: Style = White.bright().underline().italic().on_red();\nprintln!(\"Testing, {}, {}, {}!\",\n  \"Ready\".bold(),\n  \"Set\".yellow().bold(),\n  \"STOP\".paint(ALERT));\n```\n\n`>` Testing, **Ready** , **Set** , __STOP__!\n### \u00a7\u27e826\u27e9Conditional Styling\n#### \u00a7\u27e827\u27e9Globally\nStyling is enabled by default but can be enabled and disabled globally via `enable()`\u27e810\u27e9 and `disable()`\u27e811\u27e9. When styling is disabled, no ANSI escape codes are emitted, and _masked_\u27e817\u27e9 values are omitted entirely.\nGlobal styling can also be dynamically enabled and disabled using `whenever()`\u27e812\u27e9 with an arbitrary `Condition`\u27e828\u27e9: a function that returns `true` or `false`. This condition is evaluated each time a `Painted`\u27e822\u27e9 item is displayed. The associated styling is enabled, and mask values emitted, exactly when and only when the condition returns `true`.\n#### \u00a7\u27e813\u27e9Per-`Style`\nA specific `Style` can itself be conditionally applied by using `.whenever()`\u27e829\u27e9:\n```\nuse yansi::{Paint, Style, Color::*, Condition};\nstatic WARNING: Style = Black.bold().on_yellow().whenever(Condition::STDERR_IS_TTY);\neprintln!(\"{}\", \"Bees can sting!\".paint(WARNING));\n```\n\nWith the above, if `stderr` is a TTY, then: `>` **Bees can sting!**\nIf it is not a TTY, styling is not emitted: `>` Bees can sting!\nSee `Condition`\u27e828\u27e9 for a list of built-in conditions which require enabling crate features.\n## \u00a7\u27e830\u27e9Quirks\nAs a convenience, `yansi` implements several \u201cquirks\u201d, applicable via `Quirk`\u27e831\u27e9 and the respective methods, that modify if and how styling is presented to the terminal. These quirks do not correspond to any ANSI styling sequences.\n### \u00a7\u27e817\u27e9Masking\nItems can be arbitrarily _masked_ with the `mask()`\u27e832\u27e9 builder method. Masked values are not emitted when styling is disabled, globally or for a given style. This allows selective output based on whether styling is enabled.\nOne use for this feature is to print certain characters only when styling is enabled. For instance, you might wish to emit the \ud83c\udfa8 emoji when coloring is enabled but not otherwise. This can be accomplished by masking the emoji:\n```\nuse yansi::Paint;\nprintln!(\"I like colors!{}\", \" \ud83c\udfa8\".mask());\n```\n\nWhen styling is enabled, this prints: `>` I like colors! \ud83c\udfa8\nWith styling disabled, this prints: `>` I like colors!\n### \u00a7\u27e86\u27e9Wrapping\n**Note:** _Either the`std` or `alloc` feature is required for wrapping. `std` is enabled by default. See crate features\u27e88\u27e9._\nStyling can _wrap_ via `Quirk::Wrap`\u27e833\u27e9 or the equivalent `wrap()`\u27e834\u27e9 constructor. A wrapping style modifies any styling resets emitted by the internal value so that they correspond to the wrapping style. In other words, the \u201creset\u201d style of the wrapped item is modified to be the style being `.wrap()`d.\nWrapping is useful in situations where opaque and arbitrary values must be styled consistently irrespective of any existing styling. For example, a generic logger might want to style messages based on log levels consistently, even when those messages may already include styling. Wrapping exists to enable such consistent styling:\n```\nuse yansi::Paint;\n// Imagine that `inner` is opaque and we don't know it's styling.\nlet inner = format!(\"{} and {}\", \"Stop\".red(), \"Go\".green());\n// We can use `wrap` to ensure anything in `inner` not styled is blue.\nprintln!(\"Hey! {}\", inner.blue().wrap());\n```\n\nThanks to wrapping, this prints: `>` Hey!  Stop and Go\nWithout wrapping, the reset after `\"Stop\".red()` would not be overwritten: `>` Hey! Stop and Go\nWrapping incurs a performance cost due to an extra allocation and replacement if the wrapped item has styling applied to it. Otherwise, it does not allocate nor incur a meaningful performance cost.\n### \u00a7\u27e818\u27e9Lingering\nStyling can _linger_ beyond a single value via `Quirk::Linger`\u27e835\u27e9 or the equivalent `linger()`\u27e836\u27e9 constructor. A lingering style does not reset itself after being applied. In other words, the style lingers on beyond the value it\u2019s applied to, until something else resets the respective styling.\nThe complement to lingering is force resetting via `Quirk::Resetting`\u27e837\u27e9 or the equivalent `resetting()`\u27e838\u27e9 constructor. Force resetting, as the name implies, forces a reset suffix to be emitted after the value, irrespective of any lingering applied. It can be used as a way to finalize a lingering style.\nLingering itself is useful in situations where a given style is to be repeated across multiple values, or when style is intended to persist even across values that are not styled with `yansi`. It also allows avoiding unnecessarily repeated ANSI code sequences. The examples below illustrate some scenarios in which lingering is useful:\n```\nuse yansi::Paint;\nprintln!(\"Hello! {} {} things with {} {}?\",\n  \"How\".magenta().underline().linger(),\n  \"are\".italic().linger(),\n  \"you\".on_yellow(), // doesn't linger, so all styling is reset here\n  \"today\".blue());\n```\n\n`>` Hello!  _How _are things with you__ today?\n```\nuse yansi::Paint;\nprintln!(\"Hello! {} {} things with {} {}?\",\n  \"How\".magenta().underline().linger(),\n  \"are\".italic(), // doesn't linger, so all styling is reset here\n  \"you\".on_yellow().linger(),\n  \"today\".blue()); // doesn't linger; styling is reset\n```\n\n`>` Hello!  _How _are__ things with  you today?\n```\nuse yansi::Paint;\nprintln!(\"{} B {} {} {} F\",\n  \"A\".red().linger(),\n  \"C\".underline().linger(),\n  \"D\", // doesn't linger, but no styling applied, thus no reset\n  \"E\".resetting()); // explicitly reset\n```\n\n`>` A B _C D E_ F\n### \u00a7\u27e839\u27e9Brightening\nMost pimrary colors are available in regular and _bright_ variants, e.g., `Color::Red`\u27e840\u27e9 and `Color::BrightRed`\u27e841\u27e9. The `Quirk::Bright`\u27e842\u27e9 and `Quirk::OnBright`\u27e843\u27e9 quirks, typically applied via `.bright()`\u27e844\u27e9 and `.on_bright()`\u27e845\u27e9, provide an alternative, convenient mechanism to select the bright variant of the selected foreground or background color, respectively. The quirk provides no additional colors and is equivalent to selecting the bright variants directly.\n```\nuse yansi::Paint;\n// These are all equivalent.\nprint!(\"{}\", \"Regular\".red());\nprint!(\"{}\", \"Bright\".bright_red());\nprint!(\"{}\", \"Bright\".bright().red());\nprint!(\"{}\", \"Bright\".red().bright());\n// The `bright` quirk lets use choose the bright variants of _any_ color,\n// even when the color or style is unknown at the call site.\nprint!(\"{}\", \"Normal\".paint(STYLE));\nprint!(\"{}\", \"Bright\".paint(STYLE).bright());\n```\n\n`>` Regular Bright Bright Bright **Normal** **Bright**\nThe `bright()` quirk can be applied before or after a color is selected while having the same effect.\n## \u00a7\u27e87\u27e9Windows\nStyling is supported and enabled automatically on Windows beginning with the Windows 10 Anniversary Update, or about 96% of all Windows machines worldwide\u27e846\u27e9, and likely closer to 100% of developer machines (e.g., 99% of visitors to rocket.rs\u27e847\u27e9 on Windows are on Windows 10+).\nYansi enables styling support on Windows by querying the Windows API on the first attempt to color. If support is available, it is enabled. If support is not available, styling is disabled and no styling sequences are emitted.\n## \u00a7\u27e88\u27e9Crate Features\nFeature| Default?| Also Enables| Notes  \n---|---|---|---  \n`std`| **Y**| `alloc`|  Use `std` library.  \n`alloc`| **Y**| |  Use `alloc`. Enables wrapping\u27e86\u27e9.  \n`detect-tty`| N| `std`| See optional conditions\u27e814\u27e9.  \n`detect-env`| N| `std`| See optional conditions\u27e814\u27e9.  \n`hyperlink`| N| `std`| Enables hyperlinking\u27e819\u27e9 support.  \nWith `default-features = false`, this crate is `#[no_std]`.\nWithout any features enabled, all functionality except wrapping\u27e86\u27e9 is available. To recover wrapping _with_ `#[no_std]`, set `default-features = false` and enable the `alloc` feature, which requires `alloc` support.\n## Modules\u00a7\u27e848\u27e9\n\nhyperlink\u27e819\u27e9`hyperlink`\n    Experimental support for hyperlinking.\n## Structs\u00a7\u27e849\u27e9\n\nCondition\u27e828\u27e9\n    A function that decides whether styling should be applied.\n\nPainted\u27e822\u27e9\n    An arbitrary value with a `Style`\u27e823\u27e9 applied to it.\n\nStyle\u27e823\u27e9\n    A set of styling options.\n## Enums\u00a7\u27e850\u27e9\n\nAttribute\u27e851\u27e9\n    Enum representing text attributes, largely for text formatting.\n\nColor\u27e824\u27e9\n    Enum representing a terminal color.\n\nQuirk\u27e831\u27e9\n    Enum representing a `yansi` quirk.\n## Traits\u00a7\u27e852\u27e9\n\nPaint\u27e85\u27e9\n    A trait to apply styling to any value. Implemented for all types.\n## Functions\u00a7\u27e853\u27e9\n\ndisable\u27e811\u27e9\n    Unconditionally disables styling globally.\n\nenable\u27e810\u27e9\n    Unconditionally enables styling globally.\n\nis_enabled\u27e854\u27e9\n    Returns `true` if styling is globally enabled and `false` otherwise.\n\nwhenever\u27e812\u27e9\n    Dynamically enables and disables styling globally based on `condition`.\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/yansi/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/yansi/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/yansi/latest/src/yansi/lib.rs.html#1-373: Source\n\u27e84\u27e9 https://docs.rs/yansi/latest/yansi/#features: \u00a7\n\u27e85\u27e9 https://docs.rs/yansi/latest/yansi/trait.Paint.html: trait yansi::Paint - `Paint`\n\u27e86\u27e9 https://docs.rs/yansi/latest/yansi/#wrapping: wrapping\n\u27e87\u27e9 https://docs.rs/yansi/latest/yansi/#windows: Automatic Windows support\n\u27e88\u27e9 https://docs.rs/yansi/latest/yansi/#crate-features: Featureful `no_std`\n\u27e89\u27e9 https://docs.rs/yansi/latest/yansi/#uniform-const-builders: `Style` constructors are `const`\n\u27e810\u27e9 https://docs.rs/yansi/latest/yansi/fn.enable.html: fn yansi::enable - enabled\n\u27e811\u27e9 https://docs.rs/yansi/latest/yansi/fn.disable.html: fn yansi::disable - disabled\n\u27e812\u27e9 https://docs.rs/yansi/latest/yansi/fn.whenever.html: fn yansi::whenever - dynamically\n\u27e813\u27e9 https://docs.rs/yansi/latest/yansi/#per-style: conditions\n\u27e814\u27e9 https://docs.rs/yansi/latest/yansi/struct.Condition.html#built-in-conditions: struct yansi::Condition - Built-in (optional) conditions\n\u27e815\u27e9 https://docs.rs/yansi/latest/yansi/struct.Condition.html#impl-Condition-1: struct yansi::Condition - TTY detection\n\u27e816\u27e9 https://docs.rs/yansi/latest/yansi/struct.Condition.html#impl-Condition-2: struct yansi::Condition - common environment variables\n\u27e817\u27e9 https://docs.rs/yansi/latest/yansi/#masking: _masked_\n\u27e818\u27e9 https://docs.rs/yansi/latest/yansi/#lingering: _linger_\n\u27e819\u27e9 https://docs.rs/yansi/latest/yansi/hyperlink/index.html: mod yansi::hyperlink - hyperlinking\n\u27e820\u27e9 https://crates.io/crates/ansi_term: `ansi_term`\n\u27e821\u27e9 https://docs.rs/yansi/latest/yansi/#usage: \u00a7\n\u27e822\u27e9 https://docs.rs/yansi/latest/yansi/struct.Painted.html: struct yansi::Painted - `Painted`\n\u27e823\u27e9 https://docs.rs/yansi/latest/yansi/struct.Style.html: struct yansi::Style - `Style`\n\u27e824\u27e9 https://docs.rs/yansi/latest/yansi/enum.Color.html: enum yansi::Color - `Color`\n\u27e825\u27e9 https://docs.rs/yansi/latest/yansi/trait.Paint.html#method.paint: method yansi::Paint::paint - `.paint()`\n\u27e826\u27e9 https://docs.rs/yansi/latest/yansi/#conditional-styling: \u00a7\n\u27e827\u27e9 https://docs.rs/yansi/latest/yansi/#globally: \u00a7\n\u27e828\u27e9 https://docs.rs/yansi/latest/yansi/struct.Condition.html: struct yansi::Condition - `Condition`\n\u27e829\u27e9 https://docs.rs/yansi/latest/yansi/struct.Style.html#method.whenever: method yansi::Style::whenever - `.whenever()`\n\u27e830\u27e9 https://docs.rs/yansi/latest/yansi/#quirks: \u00a7\n\u27e831\u27e9 https://docs.rs/yansi/latest/yansi/enum.Quirk.html: enum yansi::Quirk - `Quirk`\n\u27e832\u27e9 https://docs.rs/yansi/latest/yansi/trait.Paint.html#tymethod.mask: method yansi::Paint::mask - `mask()`\n\u27e833\u27e9 https://docs.rs/yansi/latest/yansi/enum.Quirk.html#variant.Wrap: variant yansi::Quirk::Wrap - `Quirk::Wrap`\n\u27e834\u27e9 https://docs.rs/yansi/latest/yansi/struct.Painted.html#method.wrap: method yansi::Painted::wrap - `wrap()`\n\u27e835\u27e9 https://docs.rs/yansi/latest/yansi/enum.Quirk.html#variant.Linger: variant yansi::Quirk::Linger - `Quirk::Linger`\n\u27e836\u27e9 https://docs.rs/yansi/latest/yansi/struct.Painted.html#method.linger: method yansi::Painted::linger - `linger()`\n\u27e837\u27e9 https://docs.rs/yansi/latest/yansi/enum.Quirk.html#variant.Resetting: variant yansi::Quirk::Resetting - `Quirk::Resetting`\n\u27e838\u27e9 https://docs.rs/yansi/latest/yansi/struct.Painted.html#method.resetting: method yansi::Painted::resetting - `resetting()`\n\u27e839\u27e9 https://docs.rs/yansi/latest/yansi/#brightening: \u00a7\n\u27e840\u27e9 https://docs.rs/yansi/latest/yansi/enum.Color.html#variant.Red: variant yansi::Color::Red - `Color::Red`\n\u27e841\u27e9 https://docs.rs/yansi/latest/yansi/enum.Color.html#variant.BrightRed: variant yansi::Color::BrightRed - `Color::BrightRed`\n\u27e842\u27e9 https://docs.rs/yansi/latest/yansi/enum.Quirk.html#variant.Bright: variant yansi::Quirk::Bright - `Quirk::Bright`\n\u27e843\u27e9 https://docs.rs/yansi/latest/yansi/enum.Quirk.html#variant.OnBright: variant yansi::Quirk::OnBright - `Quirk::OnBright`\n\u27e844\u27e9 https://docs.rs/yansi/latest/yansi/struct.Painted.html#method.bright: method yansi::Painted::bright - `.bright()`\n\u27e845\u27e9 https://docs.rs/yansi/latest/yansi/struct.Painted.html#method.on_bright: method yansi::Painted::on_bright - `.on_bright()`\n\u27e846\u27e9 https://gs.statcounter.com/os-version-market-share/windows/desktop/worldwide: 96% of all Windows machines worldwide\n\u27e847\u27e9 https://rocket.rs: rocket.rs\n\u27e848\u27e9 https://docs.rs/yansi/latest/yansi/#modules: \u00a7\n\u27e849\u27e9 https://docs.rs/yansi/latest/yansi/#structs: \u00a7\n\u27e850\u27e9 https://docs.rs/yansi/latest/yansi/#enums: \u00a7\n\u27e851\u27e9 https://docs.rs/yansi/latest/yansi/enum.Attribute.html: enum yansi::Attribute - Attribute\n\u27e852\u27e9 https://docs.rs/yansi/latest/yansi/#traits: \u00a7\n\u27e853\u27e9 https://docs.rs/yansi/latest/yansi/#functions: \u00a7\n\u27e854\u27e9 https://docs.rs/yansi/latest/yansi/fn.is_enabled.html: fn yansi::is_enabled - is_enabled\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `yansi` crate is a lightweight library for applying ANSI terminal colors and text styles to any type, not just strings, with zero dependencies by default and minimal allocations. It supports global and conditional styling, masking, wrapping, lingering, and brightening, along with automatic Windows compatibility and `no_std` support. Features include `const` style constructors, built-in TTY/environment variable detection, and experimental hyperlinking.",
    "feature_summary": null,
    "use_case": "Utilities",
    "score": 6.0,
    "factual_counterfactual": "### Pair 1: Conditional Styling  \n\u2705 **Factual:** The `yansi` crate allows conditional styling globally using the `whenever()` function, which evaluates a `Condition` to decide whether styling should be applied.  \n\u274c **Counterfactual:** The `yansi` crate requires compile-time evaluation of conditions for enabling or disabling styling globally, making it incompatible with runtime conditions.  \n\n---\n\n### Pair 2: Windows Support  \n\u2705 **Factual:** The `yansi` crate automatically enables ANSI styling on Windows machines running Windows 10 Anniversary Update or later, covering over 95% of Windows users.  \n\u274c **Counterfactual:** The `yansi` crate requires manual configuration to enable ANSI styling on Windows, as it does not automatically detect Windows API support.  \n\n---\n\n### Pair 3: `no_std` Compatibility  \n\u2705 **Factual:** The `yansi` crate supports `no_std` environments by disabling default features, allowing usage without the standard library.  \n\u274c **Counterfactual:** The `yansi` crate cannot be used in `no_std` environments because it relies on the `std` library for all functionality.",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}