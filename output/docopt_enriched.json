{
    "name": "docopt",
    "version": "1.1.1",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/docopt/latest/docopt/all.html \"show sidebar\")\n# Crate docoptCopy item path\n[Settings](https://docs.rs/docopt/latest/settings.html)\n[Help](https://docs.rs/docopt/latest/help.html)\nSummary[Source](https://docs.rs/docopt/latest/src/docopt/lib.rs.html#1-209)\nExpand description\nDocopt for Rust. This implementation conforms to the [official description of Docopt](http://docopt.org/) and [passes its test suite](https://github.com/docopt/docopt/pull/201).\nThis library is [on GitHub](https://github.com/docopt/docopt.rs).\nFundamentally, Docopt is a command line argument parser. The detail that distinguishes it from most parsers is that the parser is derived from the usage string. Here\u2019s a simple example:\n```\nuse docopt::Docopt;\n// Write the Docopt usage string.\nconst USAGE: &'static str = \"\nUsage: cp [-a] <source> <dest>\n    cp [-a] <source>... <dir>\nOptions:\n  -a, --archive Copy everything.\n\";\n// The argv. Normally you'd just use `parse` which will automatically\n// use `std::env::args()`.\nlet argv = || vec![\"cp\", \"-a\", \"file1\", \"file2\", \"dest/\"];\n// Parse argv and exit the program with an error message if it fails.\nlet args = Docopt::new(USAGE)\n         .and_then(|d| d.argv(argv().into_iter()).parse())\n         .unwrap_or_else(|e| e.exit());\n// Now access your argv values. Synonyms work just fine!\nassert!(args.get_bool(\"-a\") && args.get_bool(\"--archive\"));\nassert_eq!(args.get_vec(\"<source>\"), vec![\"file1\", \"file2\"]);\nassert_eq!(args.get_str(\"<dir>\"), \"dest/\");\nassert_eq!(args.get_str(\"<dest>\"), \"\");\n```\n\n## [\u00a7](https://docs.rs/docopt/latest/docopt/#type-based-decoding)Type based decoding\nOften, command line values aren\u2019t just strings or booleans\u2014sometimes they are integers, or enums, or something more elaborate. Using the standard Docopt interface can be inconvenient for this purpose, because you\u2019ll need to convert all of the values explicitly. Instead, this crate provides a `Decoder` that converts an `ArgvMap` to your custom struct. Here is the same example as above using type based decoding:\n```\nuse docopt::Docopt;\nuse serde::Deserialize;\n// Write the Docopt usage string.\nconst USAGE: &'static str = \"\nUsage: cp [-a] <source> <dest>\n    cp [-a] <source>... <dir>\nOptions:\n  -a, --archive Copy everything.\n\";\n#[derive(Deserialize)]\nstruct Args {\n  arg_source: Vec<String>,\n  arg_dest: String,\n  arg_dir: String,\n  flag_archive: bool,\n}\nlet argv = || vec![\"cp\", \"-a\", \"file1\", \"file2\", \"dest/\"];\nlet args: Args = Docopt::new(USAGE)\n  .and_then(|d| d.argv(argv().into_iter()).deserialize())\n  .unwrap_or_else(|e| e.exit());\n// Now access your argv values.\nfn s(x: &str) -> String { x.to_string() }\nassert!(args.flag_archive);\nassert_eq!(args.arg_source, vec![s(\"file1\"), s(\"file2\")]);\nassert_eq!(args.arg_dir, s(\"dest/\"));\nassert_eq!(args.arg_dest, s(\"\"));\n```\n\n## [\u00a7](https://docs.rs/docopt/latest/docopt/#command-line-arguments-for-rustc)Command line arguments for `rustc`\nHere\u2019s an example with a subset of `rustc`\u2019s command line arguments that shows more of Docopt and some of the benefits of type based decoding.\n```\nuse std::fmt;\nuse serde::Deserialize;\nuse docopt::Docopt;\n// Write the Docopt usage string.\nconst USAGE: &'static str = \"\nUsage: rustc [options] [--cfg SPEC... -L PATH...] INPUT\n    rustc (--help | --version)\nOptions:\n  -h, --help     Show this message.\n  --version     Show the version of rustc.\n  --cfg SPEC     Configure the compilation environment.\n  -L PATH      Add a directory to the library search path.\n  --emit TYPE    Configure the output that rustc will produce.\n            Valid values: asm, ir, bc, obj, link.\n  --opt-level LEVEL Optimize with possible levels 0-3.\n\";\n#[derive(Deserialize)]\nstruct Args {\n  arg_INPUT: String,\n  flag_emit: Option<Emit>,\n  flag_opt_level: Option<OptLevel>,\n  flag_cfg: Vec<String>,\n  flag_L: Vec<String>,\n  flag_help: bool,\n  flag_version: bool,\n}\n// This is easy. The decoder will automatically restrict values to\n// strings that match one of the enum variants.\n#[derive(Deserialize)]\nenum Emit { Asm, Ir, Bc, Obj, Link }\n// This one is harder because we want the user to specify an integer,\n// but restrict it to a specific range. So we implement `Deserialize`\n// ourselves.\nenum OptLevel { Zero, One, Two, Three }\nstruct OptLevelVisitor;\nimpl<'de> serde::de::Visitor<'de> for OptLevelVisitor {\n  type Value = OptLevel;\n  fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n    formatter.write_str(\"a number from range 0..3\")\n  }\n  fn visit_u8<E>(self, n: u8) -> Result<Self::Value, E>\n    where E: serde::de::Error\n  {\n    Ok(match n {\n      0 => OptLevel::Zero, 1 => OptLevel::One,\n      2 => OptLevel::Two, 3 => OptLevel::Three,\n      n => {\n        let err = format!(\n          \"Could not deserialize '{}' as opt-level.\", n);\n        return Err(E::custom(err));\n      }\n    })\n  }\n}\nimpl<'de> serde::de::Deserialize<'de> for OptLevel {\n  fn deserialize<D>(d: D) -> Result<OptLevel, D::Error>\n    where D: serde::de::Deserializer<'de>\n  {\n    d.deserialize_u8(OptLevelVisitor)\n  }\n}\nlet argv = || vec![\"rustc\", \"-L\", \".\", \"-L\", \"..\", \"--cfg\", \"a\",\n              \"--opt-level\", \"2\", \"--emit=ir\", \"docopt.rs\"];\nlet args: Args = Docopt::new(USAGE)\n            .and_then(|d| d.argv(argv().into_iter()).deserialize())\n            .unwrap_or_else(|e| e.exit());\n// Now access your argv values.\nfn s(x: &str) -> String { x.to_string() }\nassert_eq!(args.arg_INPUT, \"docopt.rs\".to_string());\nassert_eq!(args.flag_L, vec![s(\".\"), s(\"..\")]);\nassert_eq!(args.flag_cfg, vec![s(\"a\")]);\nassert_eq!(args.flag_opt_level, Some(OptLevel::Two));\nassert_eq!(args.flag_emit, Some(Emit::Ir));\n```\n\n## Structs[\u00a7](https://docs.rs/docopt/latest/docopt/#structs)\n\n[ArgvMap](https://docs.rs/docopt/latest/docopt/struct.ArgvMap.html \"struct docopt::ArgvMap\")\n    A map containing matched values from command line arguments.\n\n[Deserializer](https://docs.rs/docopt/latest/docopt/struct.Deserializer.html \"struct docopt::Deserializer\")\n    Deserializer for `ArgvMap` into your own `Deserialize`able types.\n\n[Docopt](https://docs.rs/docopt/latest/docopt/struct.Docopt.html \"struct docopt::Docopt\")\n    The main Docopt type, which is constructed with a Docopt usage string.\n## Enums[\u00a7](https://docs.rs/docopt/latest/docopt/#enums)\n\n[Error](https://docs.rs/docopt/latest/docopt/enum.Error.html \"enum docopt::Error\")\n    Represents the different types of Docopt errors.\n\n[Value](https://docs.rs/docopt/latest/docopt/enum.Value.html \"enum docopt::Value\")\n    A matched command line value.\n",
        "markdown_with_citations": "[](https://docs.rs/docopt/latest/docopt/all.html \"show sidebar\")\n# Crate docoptCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nDocopt for Rust. This implementation conforms to the official description of Docopt\u27e84\u27e9 and passes its test suite\u27e85\u27e9.\nThis library is on GitHub\u27e86\u27e9.\nFundamentally, Docopt is a command line argument parser. The detail that distinguishes it from most parsers is that the parser is derived from the usage string. Here\u2019s a simple example:\n```\nuse docopt::Docopt;\n// Write the Docopt usage string.\nconst USAGE: &'static str = \"\nUsage: cp [-a] <source> <dest>\n    cp [-a] <source>... <dir>\nOptions:\n  -a, --archive Copy everything.\n\";\n// The argv. Normally you'd just use `parse` which will automatically\n// use `std::env::args()`.\nlet argv = || vec![\"cp\", \"-a\", \"file1\", \"file2\", \"dest/\"];\n// Parse argv and exit the program with an error message if it fails.\nlet args = Docopt::new(USAGE)\n         .and_then(|d| d.argv(argv().into_iter()).parse())\n         .unwrap_or_else(|e| e.exit());\n// Now access your argv values. Synonyms work just fine!\nassert!(args.get_bool(\"-a\") && args.get_bool(\"--archive\"));\nassert_eq!(args.get_vec(\"<source>\"), vec![\"file1\", \"file2\"]);\nassert_eq!(args.get_str(\"<dir>\"), \"dest/\");\nassert_eq!(args.get_str(\"<dest>\"), \"\");\n```\n\n## \u00a7\u27e87\u27e9Type based decoding\nOften, command line values aren\u2019t just strings or booleans\u2014sometimes they are integers, or enums, or something more elaborate. Using the standard Docopt interface can be inconvenient for this purpose, because you\u2019ll need to convert all of the values explicitly. Instead, this crate provides a `Decoder` that converts an `ArgvMap` to your custom struct. Here is the same example as above using type based decoding:\n```\nuse docopt::Docopt;\nuse serde::Deserialize;\n// Write the Docopt usage string.\nconst USAGE: &'static str = \"\nUsage: cp [-a] <source> <dest>\n    cp [-a] <source>... <dir>\nOptions:\n  -a, --archive Copy everything.\n\";\n#[derive(Deserialize)]\nstruct Args {\n  arg_source: Vec<String>,\n  arg_dest: String,\n  arg_dir: String,\n  flag_archive: bool,\n}\nlet argv = || vec![\"cp\", \"-a\", \"file1\", \"file2\", \"dest/\"];\nlet args: Args = Docopt::new(USAGE)\n  .and_then(|d| d.argv(argv().into_iter()).deserialize())\n  .unwrap_or_else(|e| e.exit());\n// Now access your argv values.\nfn s(x: &str) -> String { x.to_string() }\nassert!(args.flag_archive);\nassert_eq!(args.arg_source, vec![s(\"file1\"), s(\"file2\")]);\nassert_eq!(args.arg_dir, s(\"dest/\"));\nassert_eq!(args.arg_dest, s(\"\"));\n```\n\n## \u00a7\u27e88\u27e9Command line arguments for `rustc`\nHere\u2019s an example with a subset of `rustc`\u2019s command line arguments that shows more of Docopt and some of the benefits of type based decoding.\n```\nuse std::fmt;\nuse serde::Deserialize;\nuse docopt::Docopt;\n// Write the Docopt usage string.\nconst USAGE: &'static str = \"\nUsage: rustc [options] [--cfg SPEC... -L PATH...] INPUT\n    rustc (--help | --version)\nOptions:\n  -h, --help     Show this message.\n  --version     Show the version of rustc.\n  --cfg SPEC     Configure the compilation environment.\n  -L PATH      Add a directory to the library search path.\n  --emit TYPE    Configure the output that rustc will produce.\n            Valid values: asm, ir, bc, obj, link.\n  --opt-level LEVEL Optimize with possible levels 0-3.\n\";\n#[derive(Deserialize)]\nstruct Args {\n  arg_INPUT: String,\n  flag_emit: Option<Emit>,\n  flag_opt_level: Option<OptLevel>,\n  flag_cfg: Vec<String>,\n  flag_L: Vec<String>,\n  flag_help: bool,\n  flag_version: bool,\n}\n// This is easy. The decoder will automatically restrict values to\n// strings that match one of the enum variants.\n#[derive(Deserialize)]\nenum Emit { Asm, Ir, Bc, Obj, Link }\n// This one is harder because we want the user to specify an integer,\n// but restrict it to a specific range. So we implement `Deserialize`\n// ourselves.\nenum OptLevel { Zero, One, Two, Three }\nstruct OptLevelVisitor;\nimpl<'de> serde::de::Visitor<'de> for OptLevelVisitor {\n  type Value = OptLevel;\n  fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n    formatter.write_str(\"a number from range 0..3\")\n  }\n  fn visit_u8<E>(self, n: u8) -> Result<Self::Value, E>\n    where E: serde::de::Error\n  {\n    Ok(match n {\n      0 => OptLevel::Zero, 1 => OptLevel::One,\n      2 => OptLevel::Two, 3 => OptLevel::Three,\n      n => {\n        let err = format!(\n          \"Could not deserialize '{}' as opt-level.\", n);\n        return Err(E::custom(err));\n      }\n    })\n  }\n}\nimpl<'de> serde::de::Deserialize<'de> for OptLevel {\n  fn deserialize<D>(d: D) -> Result<OptLevel, D::Error>\n    where D: serde::de::Deserializer<'de>\n  {\n    d.deserialize_u8(OptLevelVisitor)\n  }\n}\nlet argv = || vec![\"rustc\", \"-L\", \".\", \"-L\", \"..\", \"--cfg\", \"a\",\n              \"--opt-level\", \"2\", \"--emit=ir\", \"docopt.rs\"];\nlet args: Args = Docopt::new(USAGE)\n            .and_then(|d| d.argv(argv().into_iter()).deserialize())\n            .unwrap_or_else(|e| e.exit());\n// Now access your argv values.\nfn s(x: &str) -> String { x.to_string() }\nassert_eq!(args.arg_INPUT, \"docopt.rs\".to_string());\nassert_eq!(args.flag_L, vec![s(\".\"), s(\"..\")]);\nassert_eq!(args.flag_cfg, vec![s(\"a\")]);\nassert_eq!(args.flag_opt_level, Some(OptLevel::Two));\nassert_eq!(args.flag_emit, Some(Emit::Ir));\n```\n\n## Structs\u00a7\u27e89\u27e9\n\nArgvMap\u27e810\u27e9\n    A map containing matched values from command line arguments.\n\nDeserializer\u27e811\u27e9\n    Deserializer for `ArgvMap` into your own `Deserialize`able types.\n\nDocopt\u27e812\u27e9\n    The main Docopt type, which is constructed with a Docopt usage string.\n## Enums\u00a7\u27e813\u27e9\n\nError\u27e814\u27e9\n    Represents the different types of Docopt errors.\n\nValue\u27e815\u27e9\n    A matched command line value.\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/docopt/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/docopt/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/docopt/latest/src/docopt/lib.rs.html#1-209: Source\n\u27e84\u27e9 http://docopt.org/: official description of Docopt\n\u27e85\u27e9 https://github.com/docopt/docopt/pull/201: passes its test suite\n\u27e86\u27e9 https://github.com/docopt/docopt.rs: on GitHub\n\u27e87\u27e9 https://docs.rs/docopt/latest/docopt/#type-based-decoding: \u00a7\n\u27e88\u27e9 https://docs.rs/docopt/latest/docopt/#command-line-arguments-for-rustc: \u00a7\n\u27e89\u27e9 https://docs.rs/docopt/latest/docopt/#structs: \u00a7\n\u27e810\u27e9 https://docs.rs/docopt/latest/docopt/struct.ArgvMap.html: struct docopt::ArgvMap - ArgvMap\n\u27e811\u27e9 https://docs.rs/docopt/latest/docopt/struct.Deserializer.html: struct docopt::Deserializer - Deserializer\n\u27e812\u27e9 https://docs.rs/docopt/latest/docopt/struct.Docopt.html: struct docopt::Docopt - Docopt\n\u27e813\u27e9 https://docs.rs/docopt/latest/docopt/#enums: \u00a7\n\u27e814\u27e9 https://docs.rs/docopt/latest/docopt/enum.Error.html: enum docopt::Error - Error\n\u27e815\u27e9 https://docs.rs/docopt/latest/docopt/enum.Value.html: enum docopt::Value - Value\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `docopt` crate is a command-line argument parser for Rust that derives its functionality from a usage string, simplifying argument parsing by matching command-line inputs to the specified usage format. It supports type-based decoding using Serde, allowing seamless conversion of arguments into custom structs, including enums and constrained types. Key features include error handling, flexible argument mapping via `ArgvMap`, and integration with Rust's type system for robust parsing.",
    "feature_summary": null,
    "use_case": "Utilities",
    "score": 5.0,
    "factual_counterfactual": "### Pair 1: Command Line Parsing\n\u2705 Factual: The `docopt` crate derives its command-line argument parser directly from the usage string, allowing developers to define argument behavior in a human-readable format without writing explicit parsing logic.  \n\u274c Counterfactual: The `docopt` crate requires developers to manually define argument parsing logic in Rust code, as it does not support deriving parsers from usage strings.\n\n---\n\n### Pair 2: Type-Based Decoding\n\u2705 Factual: The `docopt` crate supports type-based decoding, enabling automatic deserialization of command-line arguments into custom Rust structs using Serde.  \n\u274c Counterfactual: The `docopt` crate does not support deserialization of command-line arguments into custom types, requiring developers to manually cast values to the desired types.\n\n---\n\n### Pair 3: Error Handling\n\u2705 Factual: The `docopt` crate provides comprehensive error handling, including the ability to exit the program with a detailed error message if argument parsing fails.  \n\u274c Counterfactual: The `docopt` crate does not offer error handling mechanisms for failed argument parsing, leaving developers responsible for implementing their own error handling logic.",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}