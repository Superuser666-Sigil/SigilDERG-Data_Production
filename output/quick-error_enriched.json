{
    "name": "quick-error",
    "version": "2.0.1",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/quick-error/latest/quick_error/all.html \"show sidebar\")\n# Crate quick_errorCopy item path\n[Settings](https://docs.rs/quick-error/latest/settings.html)\n[Help](https://docs.rs/quick-error/latest/help.html)\nSummary[Source](https://docs.rs/quick-error/latest/src/quick_error/lib.rs.html#1-1336)\nExpand description\nA macro which makes errors easy to write\nMinimum type is like this:\n```\n#[macro_use] extern crate quick_error;\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    Variant1 {}\n  }\n}\n```\n\nBoth `pub` and non-public types may be declared, and all meta attributes (such as `#[derive(Debug)]`) are forwarded as is. The `Debug` must be implemented (but you may do that yourself if you like). The documentation comments `/// something` (as well as other meta attrbiutes) on variants are allowed.\n## [\u00a7](https://docs.rs/quick-error/latest/quick_error/#allowed-syntax)Allowed Syntax\nYou may add arbitrary parameters to any struct variant:\n```\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    /// IO Error\n    Io(err: std::io::Error) {}\n    /// Utf8 Error\n    Utf8(err: std::str::Utf8Error) {}\n  }\n}\n```\n\nNote unlike in normal Enum declarations you declare names of fields (which are omitted from type). How they can be used is outlined below.\nNow you might have noticed trailing braces `{}`. They are used to define implementations. By default:\n  * `Error::source()` returns None (even if type wraps some value)\n  * `Display` outputs debug representation\n  * No `From` implementations are defined\n\n\n```\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    Io(err: std::io::Error) {\n      display(\"{}\", err)\n    }\n    Utf8(err: std::str::Utf8Error) {\n      display(\"utf8 error\")\n    }\n  }\n}\n```\n\nTo change `source` method to return some error, add `source(value)`, for example:\n```\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    Io(err: std::io::Error) {\n      source(err)\n    }\n    Utf8(err: std::str::Utf8Error) {\n      display(\"utf8 error\")\n    }\n    Other(err: Box<std::error::Error>) {\n      source(&**err)\n    }\n  }\n}\n```\n\nNote you don\u2019t need to wrap value in `Some`, its implicit. In case you want `None` returned just omit the `source`. You can\u2019t return `None` conditionally.\nTo change how each clause is `Display`ed add `display(pattern,..args)`, for example:\n```\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    Io(err: std::io::Error) {\n      display(\"I/O error: {}\", err)\n    }\n    Utf8(err: std::str::Utf8Error) {\n      display(\"Utf8 error, valid up to {}\", err.valid_up_to())\n    }\n  }\n}\n```\n\nIf you need a reference to the error when `Display`ing, you can instead use `display(x) -> (pattern, ..args)`, where `x` sets the name of the reference.\n```\nuse std::error::Error; // put methods like `source()` of this trait into scope\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    Io(err: std::io::Error) {\n      display(x) -> (\"I/O: {}\", err)\n    }\n    Utf8(err: std::str::Utf8Error) {\n      display(self_) -> (\"UTF-8 error. Valid up to {}\", err.valid_up_to())\n    }\n  }\n}\n```\n\nTo convert to the type from any other, use one of the three forms of `from` clause.\nFor example, to convert simple wrapper use bare `from()`:\n```\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    Io(err: std::io::Error) {\n      from()\n    }\n  }\n}\n```\n\nThis implements `From<io::Error>`.\nTo convert to singleton enumeration type (discarding the value), use the `from(type)` form:\n```\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    FormatError {\n      from(std::fmt::Error)\n    }\n  }\n}\n```\n\nAnd the most powerful form is `from(var: type) -> (arguments...)`. It might be used to convert to type with multiple arguments or for arbitrary value conversions:\n```\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    FailedOperation(s: &'static str, errno: i32) {\n      from(errno: i32) -> (\"os error\", errno)\n      from(e: std::io::Error) -> (\"io error\", e.raw_os_error().unwrap())\n    }\n    /// Converts from both kinds of utf8 errors\n    Utf8(err: std::str::Utf8Error) {\n      from()\n      from(err: std::string::FromUtf8Error) -> (err.utf8_error())\n    }\n  }\n}\n```\n\n## [\u00a7](https://docs.rs/quick-error/latest/quick_error/#context)Context\nSince quick-error 1.1 we also have a `context` declaration, which is similar to (the longest form of) `from`, but allows adding some context to the error. We need a longer example to demonstrate this:\n```\nuse quick_error::ResultExt;\nquick_error! {\n  #[derive(Debug)]\n  pub enum Error {\n    File(filename: PathBuf, err: io::Error) {\n      context(path: &'a Path, err: io::Error)\n        -> (path.to_path_buf(), err)\n    }\n  }\n}\nfn openfile(path: &Path) -> Result<(), Error> {\n  File::open(path).context(path)?;\n  // If we didn't have context, the line above would be written as;\n  //\n  // File::open(path)\n  //   .map_err(|err| Error::File(path.to_path_buf(), err))?;\n  Ok(())\n}\n\n```\n\nEach `context(a: A, b: B)` clause implements `From<Context<A, B>> for Error`. Which means multiple `context` clauses are a subject to the normal coherence rules. Unfortunately, we can\u2019t provide full support of generics for the context, but you may either use a lifetime `'a` for references or `AsRef<Type>` (the latter means `A: AsRef<Type>`, and `Type` must be concrete). It\u2019s also occasionally useful to use a tuple as a type of the first argument.\nYou also need to `use quick_error::ResultExt` extension trait to get working `.context()` method.\nMore info on context in [this article](http://bit.ly/1PsuxDt).\nAll forms of `from`, `display`, `source`, and `context` clauses can be combined and put in arbitrary order. Only `from` and `context` can be used multiple times in single variant of enumeration. Docstrings are also okay. Empty braces can be omitted as of quick_error 0.1.3.\n## [\u00a7](https://docs.rs/quick-error/latest/quick_error/#private-enums)Private Enums\nSince quick-error 1.2.0 we have a way to make a private enum that is wrapped by public structure:\n```\n#[macro_use] extern crate quick_error;\nquick_error! {\n  #[derive(Debug)]\n  pub enum PubError wraps ErrorEnum {\n    Variant1 {}\n  }\n}\n```\n\nThis generates data structures like this\n```\n\npub struct PubError(ErrorEnum);\nenum ErrorEnum {\n  Variant1,\n}\n\n```\n\nWhich in turn allows you to export just `PubError` in your crate and keep actual enumeration private to the crate. This is useful to keep backwards compatibility for error types. Currently there is no shorcuts to define error constructors for the inner type, but we consider adding some in future versions.\nIt\u2019s possible to declare internal enum as public too.\n## Macros[\u00a7](https://docs.rs/quick-error/latest/quick_error/#macros)\n\n[quick_error](https://docs.rs/quick-error/latest/quick_error/macro.quick_error.html \"macro quick_error::quick_error\")\n    Main macro that does all the work\n## Structs[\u00a7](https://docs.rs/quick-error/latest/quick_error/#structs)\n\n[Context](https://docs.rs/quick-error/latest/quick_error/struct.Context.html \"struct quick_error::Context\")\n    Generic context type\n## Traits[\u00a7](https://docs.rs/quick-error/latest/quick_error/#traits)\n\n[ResultExt](https://docs.rs/quick-error/latest/quick_error/trait.ResultExt.html \"trait quick_error::ResultExt\")\n    Result extension trait adding a `context` method\n",
        "markdown_with_citations": "[](https://docs.rs/quick-error/latest/quick_error/all.html \"show sidebar\")\n# Crate quick_errorCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nA macro which makes errors easy to write\nMinimum type is like this:\n```\n#[macro_use] extern crate quick_error;\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    Variant1 {}\n  }\n}\n```\n\nBoth `pub` and non-public types may be declared, and all meta attributes (such as `#[derive(Debug)]`) are forwarded as is. The `Debug` must be implemented (but you may do that yourself if you like). The documentation comments `/// something` (as well as other meta attrbiutes) on variants are allowed.\n## \u00a7\u27e84\u27e9Allowed Syntax\nYou may add arbitrary parameters to any struct variant:\n```\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    /// IO Error\n    Io(err: std::io::Error) {}\n    /// Utf8 Error\n    Utf8(err: std::str::Utf8Error) {}\n  }\n}\n```\n\nNote unlike in normal Enum declarations you declare names of fields (which are omitted from type). How they can be used is outlined below.\nNow you might have noticed trailing braces `{}`. They are used to define implementations. By default:\n  * `Error::source()` returns None (even if type wraps some value)\n  * `Display` outputs debug representation\n  * No `From` implementations are defined\n\n\n```\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    Io(err: std::io::Error) {\n      display(\"{}\", err)\n    }\n    Utf8(err: std::str::Utf8Error) {\n      display(\"utf8 error\")\n    }\n  }\n}\n```\n\nTo change `source` method to return some error, add `source(value)`, for example:\n```\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    Io(err: std::io::Error) {\n      source(err)\n    }\n    Utf8(err: std::str::Utf8Error) {\n      display(\"utf8 error\")\n    }\n    Other(err: Box<std::error::Error>) {\n      source(&**err)\n    }\n  }\n}\n```\n\nNote you don\u2019t need to wrap value in `Some`, its implicit. In case you want `None` returned just omit the `source`. You can\u2019t return `None` conditionally.\nTo change how each clause is `Display`ed add `display(pattern,..args)`, for example:\n```\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    Io(err: std::io::Error) {\n      display(\"I/O error: {}\", err)\n    }\n    Utf8(err: std::str::Utf8Error) {\n      display(\"Utf8 error, valid up to {}\", err.valid_up_to())\n    }\n  }\n}\n```\n\nIf you need a reference to the error when `Display`ing, you can instead use `display(x) -> (pattern, ..args)`, where `x` sets the name of the reference.\n```\nuse std::error::Error; // put methods like `source()` of this trait into scope\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    Io(err: std::io::Error) {\n      display(x) -> (\"I/O: {}\", err)\n    }\n    Utf8(err: std::str::Utf8Error) {\n      display(self_) -> (\"UTF-8 error. Valid up to {}\", err.valid_up_to())\n    }\n  }\n}\n```\n\nTo convert to the type from any other, use one of the three forms of `from` clause.\nFor example, to convert simple wrapper use bare `from()`:\n```\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    Io(err: std::io::Error) {\n      from()\n    }\n  }\n}\n```\n\nThis implements `From<io::Error>`.\nTo convert to singleton enumeration type (discarding the value), use the `from(type)` form:\n```\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    FormatError {\n      from(std::fmt::Error)\n    }\n  }\n}\n```\n\nAnd the most powerful form is `from(var: type) -> (arguments...)`. It might be used to convert to type with multiple arguments or for arbitrary value conversions:\n```\nquick_error! {\n  #[derive(Debug)]\n  pub enum SomeError {\n    FailedOperation(s: &'static str, errno: i32) {\n      from(errno: i32) -> (\"os error\", errno)\n      from(e: std::io::Error) -> (\"io error\", e.raw_os_error().unwrap())\n    }\n    /// Converts from both kinds of utf8 errors\n    Utf8(err: std::str::Utf8Error) {\n      from()\n      from(err: std::string::FromUtf8Error) -> (err.utf8_error())\n    }\n  }\n}\n```\n\n## \u00a7\u27e85\u27e9Context\nSince quick-error 1.1 we also have a `context` declaration, which is similar to (the longest form of) `from`, but allows adding some context to the error. We need a longer example to demonstrate this:\n```\nuse quick_error::ResultExt;\nquick_error! {\n  #[derive(Debug)]\n  pub enum Error {\n    File(filename: PathBuf, err: io::Error) {\n      context(path: &'a Path, err: io::Error)\n        -> (path.to_path_buf(), err)\n    }\n  }\n}\nfn openfile(path: &Path) -> Result<(), Error> {\n  File::open(path).context(path)?;\n  // If we didn't have context, the line above would be written as;\n  //\n  // File::open(path)\n  //   .map_err(|err| Error::File(path.to_path_buf(), err))?;\n  Ok(())\n}\n\n```\n\nEach `context(a: A, b: B)` clause implements `From<Context<A, B>> for Error`. Which means multiple `context` clauses are a subject to the normal coherence rules. Unfortunately, we can\u2019t provide full support of generics for the context, but you may either use a lifetime `'a` for references or `AsRef<Type>` (the latter means `A: AsRef<Type>`, and `Type` must be concrete). It\u2019s also occasionally useful to use a tuple as a type of the first argument.\nYou also need to `use quick_error::ResultExt` extension trait to get working `.context()` method.\nMore info on context in this article\u27e86\u27e9.\nAll forms of `from`, `display`, `source`, and `context` clauses can be combined and put in arbitrary order. Only `from` and `context` can be used multiple times in single variant of enumeration. Docstrings are also okay. Empty braces can be omitted as of quick_error 0.1.3.\n## \u00a7\u27e87\u27e9Private Enums\nSince quick-error 1.2.0 we have a way to make a private enum that is wrapped by public structure:\n```\n#[macro_use] extern crate quick_error;\nquick_error! {\n  #[derive(Debug)]\n  pub enum PubError wraps ErrorEnum {\n    Variant1 {}\n  }\n}\n```\n\nThis generates data structures like this\n```\n\npub struct PubError(ErrorEnum);\nenum ErrorEnum {\n  Variant1,\n}\n\n```\n\nWhich in turn allows you to export just `PubError` in your crate and keep actual enumeration private to the crate. This is useful to keep backwards compatibility for error types. Currently there is no shorcuts to define error constructors for the inner type, but we consider adding some in future versions.\nIt\u2019s possible to declare internal enum as public too.\n## Macros\u00a7\u27e88\u27e9\n\nquick_error\u27e89\u27e9\n    Main macro that does all the work\n## Structs\u00a7\u27e810\u27e9\n\nContext\u27e811\u27e9\n    Generic context type\n## Traits\u00a7\u27e812\u27e9\n\nResultExt\u27e813\u27e9\n    Result extension trait adding a `context` method\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/quick-error/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/quick-error/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/quick-error/latest/src/quick_error/lib.rs.html#1-1336: Source\n\u27e84\u27e9 https://docs.rs/quick-error/latest/quick_error/#allowed-syntax: \u00a7\n\u27e85\u27e9 https://docs.rs/quick-error/latest/quick_error/#context: \u00a7\n\u27e86\u27e9 http://bit.ly/1PsuxDt: this article\n\u27e87\u27e9 https://docs.rs/quick-error/latest/quick_error/#private-enums: \u00a7\n\u27e88\u27e9 https://docs.rs/quick-error/latest/quick_error/#macros: \u00a7\n\u27e89\u27e9 https://docs.rs/quick-error/latest/quick_error/macro.quick_error.html: macro quick_error::quick_error - quick_error\n\u27e810\u27e9 https://docs.rs/quick-error/latest/quick_error/#structs: \u00a7\n\u27e811\u27e9 https://docs.rs/quick-error/latest/quick_error/struct.Context.html: struct quick_error::Context - Context\n\u27e812\u27e9 https://docs.rs/quick-error/latest/quick_error/#traits: \u00a7\n\u27e813\u27e9 https://docs.rs/quick-error/latest/quick_error/trait.ResultExt.html: trait quick_error::ResultExt - ResultExt\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `quick-error` crate provides a macro for simplifying error type definitions in Rust. It supports custom implementations for `Display`, `Error::source`, and `From` conversions, along with adding contextual information to errors using the `context` method. It also allows defining private enums wrapped by public structures for better API design and backward compatibility.",
    "feature_summary": null,
    "use_case": "Utilities",
    "score": 6.0,
    "factual_counterfactual": "### Pair 1: Error Handling Features  \n\u2705 Factual: The `quick-error` crate allows defining custom error types with the `quick_error!` macro, supporting `Display`, `source`, and `From` implementations for enhanced error handling.  \n\u274c Counterfactual: The `quick-error` crate automatically generates `From` implementations for all enum variants without requiring explicit `from` clauses in the macro.  \n\n---\n\n### Pair 2: Context Support  \n\u2705 Factual: Since version 1.1, `quick-error` provides a `context` declaration, enabling errors to carry additional contextual information, such as file paths or other metadata.  \n\u274c Counterfactual: The `context` feature in `quick-error` supports full generics, allowing arbitrary types to be used without restrictions like lifetimes or concrete types.  \n\n---\n\n### Pair 3: Private Enums  \n\u2705 Factual: Starting with version 1.2.0, `quick-error` supports defining private enums wrapped by public structs, enabling better encapsulation and backward compatibility for error types.  \n\u274c Counterfactual: Private enums in `quick-error` automatically generate error constructors for the inner enum type, simplifying instantiation without additional boilerplate.",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}