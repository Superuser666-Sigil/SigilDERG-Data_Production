{
    "name": "rayon",
    "version": "1.10.0",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/rayon/latest/rayon/all.html \"show sidebar\")\n# Crate rayonCopy item path\n[Settings](https://docs.rs/rayon/latest/settings.html)\n[Help](https://docs.rs/rayon/latest/help.html)\nSummary[Source](https://docs.rs/rayon/latest/src/rayon/lib.rs.html#1-160)\nExpand description\nRayon is a data-parallelism library that makes it easy to convert sequential computations into parallel.\nIt is lightweight and convenient for introducing parallelism into existing code. It guarantees data-race free executions and takes advantage of parallelism when sensible, based on work-load at runtime.\n## [\u00a7](https://docs.rs/rayon/latest/rayon/#how-to-use-rayon)How to use Rayon\nThere are two ways to use Rayon:\n  * **High-level parallel constructs** are the simplest way to use Rayon and also typically the most efficient. \n    * [Parallel iterators](https://docs.rs/rayon/latest/rayon/iter/index.html) make it easy to convert a sequential iterator to execute in parallel. \n      * The [`ParallelIterator`](https://docs.rs/rayon/latest/rayon/iter/trait.ParallelIterator.html) trait defines general methods for all parallel iterators.\n      * The [`IndexedParallelIterator`](https://docs.rs/rayon/latest/rayon/iter/trait.IndexedParallelIterator.html) trait adds methods for iterators that support random access.\n    * The [`par_sort`](https://docs.rs/rayon/latest/rayon/slice/trait.ParallelSliceMut.html#method.par_sort) method sorts `&mut [T]` slices (or vectors) in parallel.\n    * [`par_extend`](https://docs.rs/rayon/latest/rayon/iter/trait.ParallelExtend.html#tymethod.par_extend) can be used to efficiently grow collections with items produced by a parallel iterator.\n  * **Custom tasks** let you divide your work into parallel tasks yourself. \n    * [`join`](https://docs.rs/rayon/latest/rayon/fn.join.html) is used to subdivide a task into two pieces.\n    * [`scope`](https://docs.rs/rayon/latest/rayon/fn.scope.html) creates a scope within which you can create any number of parallel tasks.\n    * [`ThreadPoolBuilder`](https://docs.rs/rayon/latest/rayon/struct.ThreadPoolBuilder.html) can be used to create your own thread pools or customize the global one.\n\n\n## [\u00a7](https://docs.rs/rayon/latest/rayon/#basic-usage-and-the-rayon-prelude)Basic usage and the Rayon prelude\nFirst, you will need to add `rayon` to your `Cargo.toml`.\nNext, to use parallel iterators or the other high-level methods, you need to import several traits. Those traits are bundled into the module [`rayon::prelude`](https://docs.rs/rayon/latest/rayon/prelude/index.html). It is recommended that you import all of these traits at once by adding `use rayon::prelude::*` at the top of each module that uses Rayon methods.\nThese traits give you access to the `par_iter` method which provides parallel implementations of many iterative functions such as [`map`](https://docs.rs/rayon/latest/rayon/iter/trait.ParallelIterator.html#method.map), [`for_each`](https://docs.rs/rayon/latest/rayon/iter/trait.ParallelIterator.html#method.for_each), [`filter`](https://docs.rs/rayon/latest/rayon/iter/trait.ParallelIterator.html#method.filter), [`fold`](https://docs.rs/rayon/latest/rayon/iter/trait.ParallelIterator.html#method.fold), and [more](https://docs.rs/rayon/latest/rayon/iter/trait.ParallelIterator.html#provided-methods).\n## [\u00a7](https://docs.rs/rayon/latest/rayon/#crate-layout)Crate Layout\nRayon extends many of the types found in the standard library with parallel iterator implementations. The modules in the `rayon` crate mirror [`std`](https://doc.rust-lang.org/std/) itself: so, e.g., the `option` module in Rayon contains parallel iterators for the `Option` type, which is found in [the `option` module of `std`](https://doc.rust-lang.org/std/option/index.html). Similarly, the `collections` module in Rayon offers parallel iterator types for [the `collections` from `std`](https://doc.rust-lang.org/std/collections/index.html). You will rarely need to access these submodules unless you need to name iterator types explicitly.\n## [\u00a7](https://docs.rs/rayon/latest/rayon/#targets-without-threading)Targets without threading\nRayon has limited support for targets without `std` threading implementations. See the [`rayon_core`](https://docs.rs/rayon-core/1.12.1/x86_64-unknown-linux-gnu/rayon_core/index.html \"mod rayon_core\") documentation for more information about its global fallback.\n## [\u00a7](https://docs.rs/rayon/latest/rayon/#other-questions)Other questions?\nSee [the Rayon FAQ](https://github.com/rayon-rs/rayon/blob/main/FAQ.md).\n## Modules[\u00a7](https://docs.rs/rayon/latest/rayon/#modules)\n\n[array](https://docs.rs/rayon/latest/rayon/array/index.html \"mod rayon::array\")\n    Parallel iterator types for [arrays](https://doc.rust-lang.org/std/primitive.array.html) (`[T; N]`)\n\n[collections](https://docs.rs/rayon/latest/rayon/collections/index.html \"mod rayon::collections\")\n    Parallel iterator types for [standard collections](https://doc.rust-lang.org/stable/std/collections/)\n\n[iter](https://docs.rs/rayon/latest/rayon/iter/index.html \"mod rayon::iter\")\n    Traits for writing parallel programs using an iterator-style interface\n\n[option](https://docs.rs/rayon/latest/rayon/option/index.html \"mod rayon::option\")\n    Parallel iterator types for [options](https://doc.rust-lang.org/stable/std/option/)\n\n[prelude](https://docs.rs/rayon/latest/rayon/prelude/index.html \"mod rayon::prelude\")\n    The rayon prelude imports the various `ParallelIterator` traits. The intention is that one can include `use rayon::prelude::*` and have easy access to the various traits and methods you will need.\n\n[range](https://docs.rs/rayon/latest/rayon/range/index.html \"mod rayon::range\")\n    Parallel iterator types for [ranges](https://doc.rust-lang.org/core/ops/struct.Range.html), the type for values created by `a..b` expressions\n\n[range_inclusive](https://docs.rs/rayon/latest/rayon/range_inclusive/index.html \"mod rayon::range_inclusive\")\n    Parallel iterator types for [inclusive ranges](https://doc.rust-lang.org/core/ops/struct.RangeInclusive.html), the type for values created by `a..=b` expressions\n\n[result](https://docs.rs/rayon/latest/rayon/result/index.html \"mod rayon::result\")\n    Parallel iterator types for [results](https://doc.rust-lang.org/stable/std/result/)\n\n[slice](https://docs.rs/rayon/latest/rayon/slice/index.html \"mod rayon::slice\")\n    Parallel iterator types for [slices](https://doc.rust-lang.org/stable/std/slice/)\n\n[str](https://docs.rs/rayon/latest/rayon/str/index.html \"mod rayon::str\")\n    Parallel iterator types for [strings](https://doc.rust-lang.org/stable/std/str/)\n\n[string](https://docs.rs/rayon/latest/rayon/string/index.html \"mod rayon::string\")\n    This module contains the parallel iterator types for owned strings (`String`). You will rarely need to interact with it directly unless you have need to name one of the iterator types.\n\n[vec](https://docs.rs/rayon/latest/rayon/vec/index.html \"mod rayon::vec\")\n    Parallel iterator types for [vectors](https://doc.rust-lang.org/stable/std/vec/) (`Vec<T>`)\n## Structs[\u00a7](https://docs.rs/rayon/latest/rayon/#structs)\n\n[BroadcastContext](https://docs.rs/rayon/latest/rayon/struct.BroadcastContext.html \"struct rayon::BroadcastContext\")\n    Provides context to a closure called by `broadcast`.\n\n[FnContext](https://docs.rs/rayon/latest/rayon/struct.FnContext.html \"struct rayon::FnContext\")\n    Provides the calling context to a closure called by `join_context`.\n\n[Scope](https://docs.rs/rayon/latest/rayon/struct.Scope.html \"struct rayon::Scope\")\n    Represents a fork-join scope which can be used to spawn any number of tasks. See [`scope()`](https://docs.rs/rayon/latest/rayon/fn.scope.html) for more information.\n\n[ScopeFifo](https://docs.rs/rayon/latest/rayon/struct.ScopeFifo.html \"struct rayon::ScopeFifo\")\n    Represents a fork-join scope which can be used to spawn any number of tasks. Those spawned from the same thread are prioritized in relative FIFO order. See [`scope_fifo()`](https://docs.rs/rayon/latest/rayon/fn.scope_fifo.html) for more information.\n\n[ThreadBuilder](https://docs.rs/rayon/latest/rayon/struct.ThreadBuilder.html \"struct rayon::ThreadBuilder\")\n    Thread builder used for customization via [`ThreadPoolBuilder::spawn_handler`](https://docs.rs/rayon/latest/rayon/struct.ThreadPoolBuilder.html#method.spawn_handler).\n\n[ThreadPool](https://docs.rs/rayon/latest/rayon/struct.ThreadPool.html \"struct rayon::ThreadPool\")\n    Represents a user created [thread-pool](https://en.wikipedia.org/wiki/Thread_pool).\n\n[ThreadPoolBuildError](https://docs.rs/rayon/latest/rayon/struct.ThreadPoolBuildError.html \"struct rayon::ThreadPoolBuildError\")\n    Error when initializing a thread pool.\n\n[ThreadPoolBuilder](https://docs.rs/rayon/latest/rayon/struct.ThreadPoolBuilder.html \"struct rayon::ThreadPoolBuilder\")\n    Used to create a new [`ThreadPool`](https://docs.rs/rayon/latest/rayon/struct.ThreadPool.html) or to configure the global rayon thread pool.\n## Enums[\u00a7](https://docs.rs/rayon/latest/rayon/#enums)\n\n[Yield](https://docs.rs/rayon/latest/rayon/enum.Yield.html \"enum rayon::Yield\")\n    Result of [`yield_now()`](https://docs.rs/rayon/latest/rayon/fn.yield_now.html \"fn rayon::yield_now\") or [`yield_local()`](https://docs.rs/rayon/latest/rayon/fn.yield_local.html \"fn rayon::yield_local\").\n## Functions[\u00a7](https://docs.rs/rayon/latest/rayon/#functions)\n\n[broadcast](https://docs.rs/rayon/latest/rayon/fn.broadcast.html \"fn rayon::broadcast\")\n    Executes `op` within every thread in the current threadpool. If this is called from a non-Rayon thread, it will execute in the global threadpool. Any attempts to use `join`, `scope`, or parallel iterators will then operate within that threadpool. When the call has completed on each thread, returns a vector containing all of their return values.\n\n[current_num_threads](https://docs.rs/rayon/latest/rayon/fn.current_num_threads.html \"fn rayon::current_num_threads\")\n    Returns the number of threads in the current registry. If this code is executing within a Rayon thread-pool, then this will be the number of threads for the thread-pool of the current thread. Otherwise, it will be the number of threads for the global thread-pool.\n\n[current_thread_index](https://docs.rs/rayon/latest/rayon/fn.current_thread_index.html \"fn rayon::current_thread_index\")\n    If called from a Rayon worker thread, returns the index of that thread within its current pool; if not called from a Rayon thread, returns `None`.\n\n[in_place_scope](https://docs.rs/rayon/latest/rayon/fn.in_place_scope.html \"fn rayon::in_place_scope\")\n    Creates a \u201cfork-join\u201d scope `s` and invokes the closure with a reference to `s`. This closure can then spawn asynchronous tasks into `s`. Those tasks may run asynchronously with respect to the closure; they may themselves spawn additional tasks into `s`. When the closure returns, it will block until all tasks that have been spawned into `s` complete.\n\n[in_place_scope_fifo](https://docs.rs/rayon/latest/rayon/fn.in_place_scope_fifo.html \"fn rayon::in_place_scope_fifo\")\n    Creates a \u201cfork-join\u201d scope `s` with FIFO order, and invokes the closure with a reference to `s`. This closure can then spawn asynchronous tasks into `s`. Those tasks may run asynchronously with respect to the closure; they may themselves spawn additional tasks into `s`. When the closure returns, it will block until all tasks that have been spawned into `s` complete.\n\n[join](https://docs.rs/rayon/latest/rayon/fn.join.html \"fn rayon::join\")\n    Takes two closures and _potentially_ runs them in parallel. It returns a pair of the results from those closures.\n\n[join_context](https://docs.rs/rayon/latest/rayon/fn.join_context.html \"fn rayon::join_context\")\n    Identical to `join`, except that the closures have a parameter that provides context for the way the closure has been called, especially indicating whether they\u2019re executing on a different thread than where `join_context` was called. This will occur if the second job is stolen by a different thread, or if `join_context` was called from outside the thread pool to begin with.\n\n[max_num_threads](https://docs.rs/rayon/latest/rayon/fn.max_num_threads.html \"fn rayon::max_num_threads\")\n    Returns the maximum number of threads that Rayon supports in a single thread-pool.\n\n[scope](https://docs.rs/rayon/latest/rayon/fn.scope.html \"fn rayon::scope\")\n    Creates a \u201cfork-join\u201d scope `s` and invokes the closure with a reference to `s`. This closure can then spawn asynchronous tasks into `s`. Those tasks may run asynchronously with respect to the closure; they may themselves spawn additional tasks into `s`. When the closure returns, it will block until all tasks that have been spawned into `s` complete.\n\n[scope_fifo](https://docs.rs/rayon/latest/rayon/fn.scope_fifo.html \"fn rayon::scope_fifo\")\n    Creates a \u201cfork-join\u201d scope `s` with FIFO order, and invokes the closure with a reference to `s`. This closure can then spawn asynchronous tasks into `s`. Those tasks may run asynchronously with respect to the closure; they may themselves spawn additional tasks into `s`. When the closure returns, it will block until all tasks that have been spawned into `s` complete.\n\n[spawn](https://docs.rs/rayon/latest/rayon/fn.spawn.html \"fn rayon::spawn\")\n    Puts the task into the Rayon threadpool\u2019s job queue in the \u201cstatic\u201d or \u201cglobal\u201d scope. Just like a standard thread, this task is not tied to the current stack frame, and hence it cannot hold any references other than those with `'static` lifetime. If you want to spawn a task that references stack data, use [the `scope()` function](https://docs.rs/rayon/latest/rayon/fn.scope.html) to create a scope.\n\n[spawn_broadcast](https://docs.rs/rayon/latest/rayon/fn.spawn_broadcast.html \"fn rayon::spawn_broadcast\")\n    Spawns an asynchronous task on every thread in this thread-pool. This task will run in the implicit, global scope, which means that it may outlast the current stack frame \u2013 therefore, it cannot capture any references onto the stack (you will likely need a `move` closure).\n\n[spawn_fifo](https://docs.rs/rayon/latest/rayon/fn.spawn_fifo.html \"fn rayon::spawn_fifo\")\n    Fires off a task into the Rayon threadpool in the \u201cstatic\u201d or \u201cglobal\u201d scope. Just like a standard thread, this task is not tied to the current stack frame, and hence it cannot hold any references other than those with `'static` lifetime. If you want to spawn a task that references stack data, use [the `scope_fifo()` function](https://docs.rs/rayon/latest/rayon/fn.scope_fifo.html) to create a scope.\n\n[yield_local](https://docs.rs/rayon/latest/rayon/fn.yield_local.html \"fn rayon::yield_local\")\n    Cooperatively yields execution to local Rayon work.\n\n[yield_now](https://docs.rs/rayon/latest/rayon/fn.yield_now.html \"fn rayon::yield_now\")\n    Cooperatively yields execution to Rayon.\n",
        "markdown_with_citations": "[](https://docs.rs/rayon/latest/rayon/all.html \"show sidebar\")\n# Crate rayonCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nRayon is a data-parallelism library that makes it easy to convert sequential computations into parallel.\nIt is lightweight and convenient for introducing parallelism into existing code. It guarantees data-race free executions and takes advantage of parallelism when sensible, based on work-load at runtime.\n## \u00a7\u27e84\u27e9How to use Rayon\nThere are two ways to use Rayon:\n  * **High-level parallel constructs** are the simplest way to use Rayon and also typically the most efficient. \n    * Parallel iterators\u27e85\u27e9 make it easy to convert a sequential iterator to execute in parallel. \n      * The `ParallelIterator`\u27e86\u27e9 trait defines general methods for all parallel iterators.\n      * The `IndexedParallelIterator`\u27e87\u27e9 trait adds methods for iterators that support random access.\n    * The `par_sort`\u27e88\u27e9 method sorts `&mut [T]` slices (or vectors) in parallel.\n    * `par_extend`\u27e89\u27e9 can be used to efficiently grow collections with items produced by a parallel iterator.\n  * **Custom tasks** let you divide your work into parallel tasks yourself. \n    * `join`\u27e810\u27e9 is used to subdivide a task into two pieces.\n    * `scope`\u27e811\u27e9 creates a scope within which you can create any number of parallel tasks.\n    * `ThreadPoolBuilder`\u27e812\u27e9 can be used to create your own thread pools or customize the global one.\n\n\n## \u00a7\u27e813\u27e9Basic usage and the Rayon prelude\nFirst, you will need to add `rayon` to your `Cargo.toml`.\nNext, to use parallel iterators or the other high-level methods, you need to import several traits. Those traits are bundled into the module `rayon::prelude`\u27e814\u27e9. It is recommended that you import all of these traits at once by adding `use rayon::prelude::*` at the top of each module that uses Rayon methods.\nThese traits give you access to the `par_iter` method which provides parallel implementations of many iterative functions such as `map`\u27e815\u27e9, `for_each`\u27e816\u27e9, `filter`\u27e817\u27e9, `fold`\u27e818\u27e9, and more\u27e819\u27e9.\n## \u00a7\u27e820\u27e9Crate Layout\nRayon extends many of the types found in the standard library with parallel iterator implementations. The modules in the `rayon` crate mirror `std`\u27e821\u27e9 itself: so, e.g., the `option` module in Rayon contains parallel iterators for the `Option` type, which is found in the `option` module of `std`\u27e822\u27e9. Similarly, the `collections` module in Rayon offers parallel iterator types for the `collections` from `std`\u27e823\u27e9. You will rarely need to access these submodules unless you need to name iterator types explicitly.\n## \u00a7\u27e824\u27e9Targets without threading\nRayon has limited support for targets without `std` threading implementations. See the `rayon_core`\u27e825\u27e9 documentation for more information about its global fallback.\n## \u00a7\u27e826\u27e9Other questions?\nSee the Rayon FAQ\u27e827\u27e9.\n## Modules\u00a7\u27e828\u27e9\n\narray\u27e829\u27e9\n    Parallel iterator types for arrays\u27e830\u27e9 (`[T; N]`)\n\ncollections\u27e831\u27e9\n    Parallel iterator types for standard collections\u27e832\u27e9\n\niter\u27e85\u27e9\n    Traits for writing parallel programs using an iterator-style interface\n\noption\u27e833\u27e9\n    Parallel iterator types for options\u27e834\u27e9\n\nprelude\u27e814\u27e9\n    The rayon prelude imports the various `ParallelIterator` traits. The intention is that one can include `use rayon::prelude::*` and have easy access to the various traits and methods you will need.\n\nrange\u27e835\u27e9\n    Parallel iterator types for ranges\u27e836\u27e9, the type for values created by `a..b` expressions\n\nrange_inclusive\u27e837\u27e9\n    Parallel iterator types for inclusive ranges\u27e838\u27e9, the type for values created by `a..=b` expressions\n\nresult\u27e839\u27e9\n    Parallel iterator types for results\u27e840\u27e9\n\nslice\u27e841\u27e9\n    Parallel iterator types for slices\u27e842\u27e9\n\nstr\u27e843\u27e9\n    Parallel iterator types for strings\u27e844\u27e9\n\nstring\u27e845\u27e9\n    This module contains the parallel iterator types for owned strings (`String`). You will rarely need to interact with it directly unless you have need to name one of the iterator types.\n\nvec\u27e846\u27e9\n    Parallel iterator types for vectors\u27e847\u27e9 (`Vec<T>`)\n## Structs\u00a7\u27e848\u27e9\n\nBroadcastContext\u27e849\u27e9\n    Provides context to a closure called by `broadcast`.\n\nFnContext\u27e850\u27e9\n    Provides the calling context to a closure called by `join_context`.\n\nScope\u27e851\u27e9\n    Represents a fork-join scope which can be used to spawn any number of tasks. See `scope()`\u27e811\u27e9 for more information.\n\nScopeFifo\u27e852\u27e9\n    Represents a fork-join scope which can be used to spawn any number of tasks. Those spawned from the same thread are prioritized in relative FIFO order. See `scope_fifo()`\u27e853\u27e9 for more information.\n\nThreadBuilder\u27e854\u27e9\n    Thread builder used for customization via `ThreadPoolBuilder::spawn_handler`\u27e855\u27e9.\n\nThreadPool\u27e856\u27e9\n    Represents a user created thread-pool\u27e857\u27e9.\n\nThreadPoolBuildError\u27e858\u27e9\n    Error when initializing a thread pool.\n\nThreadPoolBuilder\u27e812\u27e9\n    Used to create a new `ThreadPool`\u27e856\u27e9 or to configure the global rayon thread pool.\n## Enums\u00a7\u27e859\u27e9\n\nYield\u27e860\u27e9\n    Result of `yield_now()`\u27e861\u27e9 or `yield_local()`\u27e862\u27e9.\n## Functions\u00a7\u27e863\u27e9\n\nbroadcast\u27e864\u27e9\n    Executes `op` within every thread in the current threadpool. If this is called from a non-Rayon thread, it will execute in the global threadpool. Any attempts to use `join`, `scope`, or parallel iterators will then operate within that threadpool. When the call has completed on each thread, returns a vector containing all of their return values.\n\ncurrent_num_threads\u27e865\u27e9\n    Returns the number of threads in the current registry. If this code is executing within a Rayon thread-pool, then this will be the number of threads for the thread-pool of the current thread. Otherwise, it will be the number of threads for the global thread-pool.\n\ncurrent_thread_index\u27e866\u27e9\n    If called from a Rayon worker thread, returns the index of that thread within its current pool; if not called from a Rayon thread, returns `None`.\n\nin_place_scope\u27e867\u27e9\n    Creates a \u201cfork-join\u201d scope `s` and invokes the closure with a reference to `s`. This closure can then spawn asynchronous tasks into `s`. Those tasks may run asynchronously with respect to the closure; they may themselves spawn additional tasks into `s`. When the closure returns, it will block until all tasks that have been spawned into `s` complete.\n\nin_place_scope_fifo\u27e868\u27e9\n    Creates a \u201cfork-join\u201d scope `s` with FIFO order, and invokes the closure with a reference to `s`. This closure can then spawn asynchronous tasks into `s`. Those tasks may run asynchronously with respect to the closure; they may themselves spawn additional tasks into `s`. When the closure returns, it will block until all tasks that have been spawned into `s` complete.\n\njoin\u27e810\u27e9\n    Takes two closures and _potentially_ runs them in parallel. It returns a pair of the results from those closures.\n\njoin_context\u27e869\u27e9\n    Identical to `join`, except that the closures have a parameter that provides context for the way the closure has been called, especially indicating whether they\u2019re executing on a different thread than where `join_context` was called. This will occur if the second job is stolen by a different thread, or if `join_context` was called from outside the thread pool to begin with.\n\nmax_num_threads\u27e870\u27e9\n    Returns the maximum number of threads that Rayon supports in a single thread-pool.\n\nscope\u27e811\u27e9\n    Creates a \u201cfork-join\u201d scope `s` and invokes the closure with a reference to `s`. This closure can then spawn asynchronous tasks into `s`. Those tasks may run asynchronously with respect to the closure; they may themselves spawn additional tasks into `s`. When the closure returns, it will block until all tasks that have been spawned into `s` complete.\n\nscope_fifo\u27e853\u27e9\n    Creates a \u201cfork-join\u201d scope `s` with FIFO order, and invokes the closure with a reference to `s`. This closure can then spawn asynchronous tasks into `s`. Those tasks may run asynchronously with respect to the closure; they may themselves spawn additional tasks into `s`. When the closure returns, it will block until all tasks that have been spawned into `s` complete.\n\nspawn\u27e871\u27e9\n    Puts the task into the Rayon threadpool\u2019s job queue in the \u201cstatic\u201d or \u201cglobal\u201d scope. Just like a standard thread, this task is not tied to the current stack frame, and hence it cannot hold any references other than those with `'static` lifetime. If you want to spawn a task that references stack data, use the `scope()` function\u27e811\u27e9 to create a scope.\n\nspawn_broadcast\u27e872\u27e9\n    Spawns an asynchronous task on every thread in this thread-pool. This task will run in the implicit, global scope, which means that it may outlast the current stack frame \u2013 therefore, it cannot capture any references onto the stack (you will likely need a `move` closure).\n\nspawn_fifo\u27e873\u27e9\n    Fires off a task into the Rayon threadpool in the \u201cstatic\u201d or \u201cglobal\u201d scope. Just like a standard thread, this task is not tied to the current stack frame, and hence it cannot hold any references other than those with `'static` lifetime. If you want to spawn a task that references stack data, use the `scope_fifo()` function\u27e853\u27e9 to create a scope.\n\nyield_local\u27e862\u27e9\n    Cooperatively yields execution to local Rayon work.\n\nyield_now\u27e861\u27e9\n    Cooperatively yields execution to Rayon.\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/rayon/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/rayon/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/rayon/latest/src/rayon/lib.rs.html#1-160: Source\n\u27e84\u27e9 https://docs.rs/rayon/latest/rayon/#how-to-use-rayon: \u00a7\n\u27e85\u27e9 https://docs.rs/rayon/latest/rayon/iter/index.html: Parallel iterators\n\u27e86\u27e9 https://docs.rs/rayon/latest/rayon/iter/trait.ParallelIterator.html: `ParallelIterator`\n\u27e87\u27e9 https://docs.rs/rayon/latest/rayon/iter/trait.IndexedParallelIterator.html: `IndexedParallelIterator`\n\u27e88\u27e9 https://docs.rs/rayon/latest/rayon/slice/trait.ParallelSliceMut.html#method.par_sort: `par_sort`\n\u27e89\u27e9 https://docs.rs/rayon/latest/rayon/iter/trait.ParallelExtend.html#tymethod.par_extend: `par_extend`\n\u27e810\u27e9 https://docs.rs/rayon/latest/rayon/fn.join.html: `join`\n\u27e811\u27e9 https://docs.rs/rayon/latest/rayon/fn.scope.html: `scope`\n\u27e812\u27e9 https://docs.rs/rayon/latest/rayon/struct.ThreadPoolBuilder.html: `ThreadPoolBuilder`\n\u27e813\u27e9 https://docs.rs/rayon/latest/rayon/#basic-usage-and-the-rayon-prelude: \u00a7\n\u27e814\u27e9 https://docs.rs/rayon/latest/rayon/prelude/index.html: `rayon::prelude`\n\u27e815\u27e9 https://docs.rs/rayon/latest/rayon/iter/trait.ParallelIterator.html#method.map: `map`\n\u27e816\u27e9 https://docs.rs/rayon/latest/rayon/iter/trait.ParallelIterator.html#method.for_each: `for_each`\n\u27e817\u27e9 https://docs.rs/rayon/latest/rayon/iter/trait.ParallelIterator.html#method.filter: `filter`\n\u27e818\u27e9 https://docs.rs/rayon/latest/rayon/iter/trait.ParallelIterator.html#method.fold: `fold`\n\u27e819\u27e9 https://docs.rs/rayon/latest/rayon/iter/trait.ParallelIterator.html#provided-methods: more\n\u27e820\u27e9 https://docs.rs/rayon/latest/rayon/#crate-layout: \u00a7\n\u27e821\u27e9 https://doc.rust-lang.org/std/: `std`\n\u27e822\u27e9 https://doc.rust-lang.org/std/option/index.html: the `option` module of `std`\n\u27e823\u27e9 https://doc.rust-lang.org/std/collections/index.html: the `collections` from `std`\n\u27e824\u27e9 https://docs.rs/rayon/latest/rayon/#targets-without-threading: \u00a7\n\u27e825\u27e9 https://docs.rs/rayon-core/1.12.1/x86_64-unknown-linux-gnu/rayon_core/index.html: mod rayon_core - `rayon_core`\n\u27e826\u27e9 https://docs.rs/rayon/latest/rayon/#other-questions: \u00a7\n\u27e827\u27e9 https://github.com/rayon-rs/rayon/blob/main/FAQ.md: the Rayon FAQ\n\u27e828\u27e9 https://docs.rs/rayon/latest/rayon/#modules: \u00a7\n\u27e829\u27e9 https://docs.rs/rayon/latest/rayon/array/index.html: mod rayon::array - array\n\u27e830\u27e9 https://doc.rust-lang.org/std/primitive.array.html: arrays\n\u27e831\u27e9 https://docs.rs/rayon/latest/rayon/collections/index.html: mod rayon::collections - collections\n\u27e832\u27e9 https://doc.rust-lang.org/stable/std/collections/: standard collections\n\u27e833\u27e9 https://docs.rs/rayon/latest/rayon/option/index.html: mod rayon::option - option\n\u27e834\u27e9 https://doc.rust-lang.org/stable/std/option/: options\n\u27e835\u27e9 https://docs.rs/rayon/latest/rayon/range/index.html: mod rayon::range - range\n\u27e836\u27e9 https://doc.rust-lang.org/core/ops/struct.Range.html: ranges\n\u27e837\u27e9 https://docs.rs/rayon/latest/rayon/range_inclusive/index.html: mod rayon::range_inclusive - range_inclusive\n\u27e838\u27e9 https://doc.rust-lang.org/core/ops/struct.RangeInclusive.html: inclusive ranges\n\u27e839\u27e9 https://docs.rs/rayon/latest/rayon/result/index.html: mod rayon::result - result\n\u27e840\u27e9 https://doc.rust-lang.org/stable/std/result/: results\n\u27e841\u27e9 https://docs.rs/rayon/latest/rayon/slice/index.html: mod rayon::slice - slice\n\u27e842\u27e9 https://doc.rust-lang.org/stable/std/slice/: slices\n\u27e843\u27e9 https://docs.rs/rayon/latest/rayon/str/index.html: mod rayon::str - str\n\u27e844\u27e9 https://doc.rust-lang.org/stable/std/str/: strings\n\u27e845\u27e9 https://docs.rs/rayon/latest/rayon/string/index.html: mod rayon::string - string\n\u27e846\u27e9 https://docs.rs/rayon/latest/rayon/vec/index.html: mod rayon::vec - vec\n\u27e847\u27e9 https://doc.rust-lang.org/stable/std/vec/: vectors\n\u27e848\u27e9 https://docs.rs/rayon/latest/rayon/#structs: \u00a7\n\u27e849\u27e9 https://docs.rs/rayon/latest/rayon/struct.BroadcastContext.html: struct rayon::BroadcastContext - BroadcastContext\n\u27e850\u27e9 https://docs.rs/rayon/latest/rayon/struct.FnContext.html: struct rayon::FnContext - FnContext\n\u27e851\u27e9 https://docs.rs/rayon/latest/rayon/struct.Scope.html: struct rayon::Scope - Scope\n\u27e852\u27e9 https://docs.rs/rayon/latest/rayon/struct.ScopeFifo.html: struct rayon::ScopeFifo - ScopeFifo\n\u27e853\u27e9 https://docs.rs/rayon/latest/rayon/fn.scope_fifo.html: `scope_fifo()`\n\u27e854\u27e9 https://docs.rs/rayon/latest/rayon/struct.ThreadBuilder.html: struct rayon::ThreadBuilder - ThreadBuilder\n\u27e855\u27e9 https://docs.rs/rayon/latest/rayon/struct.ThreadPoolBuilder.html#method.spawn_handler: `ThreadPoolBuilder::spawn_handler`\n\u27e856\u27e9 https://docs.rs/rayon/latest/rayon/struct.ThreadPool.html: struct rayon::ThreadPool - ThreadPool\n\u27e857\u27e9 https://en.wikipedia.org/wiki/Thread_pool: thread-pool\n\u27e858\u27e9 https://docs.rs/rayon/latest/rayon/struct.ThreadPoolBuildError.html: struct rayon::ThreadPoolBuildError - ThreadPoolBuildError\n\u27e859\u27e9 https://docs.rs/rayon/latest/rayon/#enums: \u00a7\n\u27e860\u27e9 https://docs.rs/rayon/latest/rayon/enum.Yield.html: enum rayon::Yield - Yield\n\u27e861\u27e9 https://docs.rs/rayon/latest/rayon/fn.yield_now.html: fn rayon::yield_now - `yield_now()`\n\u27e862\u27e9 https://docs.rs/rayon/latest/rayon/fn.yield_local.html: fn rayon::yield_local - `yield_local()`\n\u27e863\u27e9 https://docs.rs/rayon/latest/rayon/#functions: \u00a7\n\u27e864\u27e9 https://docs.rs/rayon/latest/rayon/fn.broadcast.html: fn rayon::broadcast - broadcast\n\u27e865\u27e9 https://docs.rs/rayon/latest/rayon/fn.current_num_threads.html: fn rayon::current_num_threads - current_num_threads\n\u27e866\u27e9 https://docs.rs/rayon/latest/rayon/fn.current_thread_index.html: fn rayon::current_thread_index - current_thread_index\n\u27e867\u27e9 https://docs.rs/rayon/latest/rayon/fn.in_place_scope.html: fn rayon::in_place_scope - in_place_scope\n\u27e868\u27e9 https://docs.rs/rayon/latest/rayon/fn.in_place_scope_fifo.html: fn rayon::in_place_scope_fifo - in_place_scope_fifo\n\u27e869\u27e9 https://docs.rs/rayon/latest/rayon/fn.join_context.html: fn rayon::join_context - join_context\n\u27e870\u27e9 https://docs.rs/rayon/latest/rayon/fn.max_num_threads.html: fn rayon::max_num_threads - max_num_threads\n\u27e871\u27e9 https://docs.rs/rayon/latest/rayon/fn.spawn.html: fn rayon::spawn - spawn\n\u27e872\u27e9 https://docs.rs/rayon/latest/rayon/fn.spawn_broadcast.html: fn rayon::spawn_broadcast - spawn_broadcast\n\u27e873\u27e9 https://docs.rs/rayon/latest/rayon/fn.spawn_fifo.html: fn rayon::spawn_fifo - spawn_fifo\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `rayon` crate is a data-parallelism library for Rust that simplifies converting sequential computations into parallel ones while ensuring data-race-free execution. It offers high-level parallel constructs like parallel iterators (`ParallelIterator`, `IndexedParallelIterator`) for efficient operations on collections, and custom task management with utilities like `join`, `scope`, and `ThreadPoolBuilder`. Rayon integrates seamlessly with standard library types and supports dynamic workload balancing for optimal runtime performance.",
    "feature_summary": null,
    "use_case": "Utilities",
    "score": 9.0,
    "factual_counterfactual": "### Pair 1: Parallel Iterators  \n\u2705 **Factual:** Rayon allows you to convert sequential iterators into parallel iterators using the `par_iter` method, enabling parallel execution of operations like `map`, `filter`, and `fold`.  \n\u274c **Counterfactual:** Rayon requires explicit thread management for parallel iterators, meaning developers must manually assign threads to handle the parallel tasks.  \n\n---\n\n### Pair 2: ThreadPool Customization  \n\u2705 **Factual:** Rayon provides `ThreadPoolBuilder` for creating custom thread pools or configuring the global thread pool, including options like setting the number of threads.  \n\u274c **Counterfactual:** Rayon mandates the use of its default global thread pool and does not allow developers to create or customize their own thread pools.  \n\n---\n\n### Pair 3: Data Race Safety  \n\u2705 **Factual:** Rayon guarantees data-race-free parallelism by ensuring that tasks spawned in parallel do not access shared memory unsafely.  \n\u274c **Counterfactual:** Rayon requires developers to manually implement synchronization primitives like `Mutex` or `RwLock` to prevent data races in parallel computations.",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}