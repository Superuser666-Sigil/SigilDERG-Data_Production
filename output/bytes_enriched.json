{
    "name": "bytes",
    "version": "1.10.1",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/bytes/latest/bytes/all.html \"show sidebar\")\n# Crate bytesCopy item path\n[Settings](https://docs.rs/bytes/latest/settings.html)\n[Help](https://docs.rs/bytes/latest/help.html)\nSummary[Source](https://docs.rs/bytes/latest/src/bytes/lib.rs.html#1-199)\nExpand description\nProvides abstractions for working with bytes.\nThe `bytes` crate provides an efficient byte buffer structure ([`Bytes`](https://docs.rs/bytes/latest/bytes/struct.Bytes.html \"struct bytes::Bytes\")) and traits for working with buffer implementations ([`Buf`](https://docs.rs/bytes/latest/bytes/buf/trait.Buf.html \"trait bytes::buf::Buf\"), [`BufMut`](https://docs.rs/bytes/latest/bytes/buf/trait.BufMut.html \"trait bytes::buf::BufMut\")).\n## [\u00a7](https://docs.rs/bytes/latest/bytes/#bytes)`Bytes`\n`Bytes` is an efficient container for storing and operating on contiguous slices of memory. It is intended for use primarily in networking code, but could have applications elsewhere as well.\n`Bytes` values facilitate zero-copy network programming by allowing multiple `Bytes` objects to point to the same underlying memory. This is managed by using a reference count to track when the memory is no longer needed and can be freed.\nA `Bytes` handle can be created directly from an existing byte store (such as `&[u8]` or `Vec<u8>`), but usually a `BytesMut` is used first and written to. For example:\n```\nuse bytes::{BytesMut, BufMut};\nlet mut buf = BytesMut::with_capacity(1024);\nbuf.put(&b\"hello world\"[..]);\nbuf.put_u16(1234);\nlet a = buf.split();\nassert_eq!(a, b\"hello world\\x04\\xD2\"[..]);\nbuf.put(&b\"goodbye world\"[..]);\nlet b = buf.split();\nassert_eq!(b, b\"goodbye world\"[..]);\nassert_eq!(buf.capacity(), 998);\n```\n\nIn the above example, only a single buffer of 1024 is allocated. The handles `a` and `b` will share the underlying buffer and maintain indices tracking the view into the buffer represented by the handle.\nSee the [struct docs](https://docs.rs/bytes/latest/bytes/struct.Bytes.html \"struct bytes::Bytes\") for more details.\n## [\u00a7](https://docs.rs/bytes/latest/bytes/#buf-bufmut)`Buf`, `BufMut`\nThese two traits provide read and write access to buffers. The underlying storage may or may not be in contiguous memory. For example, `Bytes` is a buffer that guarantees contiguous memory, but a [rope](https://en.wikipedia.org/wiki/Rope_\\(data_structure\\)) stores the bytes in disjoint chunks. `Buf` and `BufMut` maintain cursors tracking the current position in the underlying byte storage. When bytes are read or written, the cursor is advanced.\n### [\u00a7](https://docs.rs/bytes/latest/bytes/#relation-with-read-and-write)Relation with `Read` and `Write`\nAt first glance, it may seem that `Buf` and `BufMut` overlap in functionality with [`std::io::Read`](https://doc.rust-lang.org/nightly/std/io/trait.Read.html \"trait std::io::Read\") and [`std::io::Write`](https://doc.rust-lang.org/nightly/std/io/trait.Write.html \"trait std::io::Write\"). However, they serve different purposes. A buffer is the value that is provided as an argument to `Read::read` and `Write::write`. `Read` and `Write` may then perform a syscall, which has the potential of failing. Operations on `Buf` and `BufMut` are infallible.\n## Re-exports[\u00a7](https://docs.rs/bytes/latest/bytes/#reexports)\n\n`pub use crate::buf::Buf[](https://docs.rs/bytes/latest/bytes/buf/trait.Buf.html \"trait bytes::buf::Buf\");`\n\n\n`pub use crate::buf::BufMut[](https://docs.rs/bytes/latest/bytes/buf/trait.BufMut.html \"trait bytes::buf::BufMut\");`\n\n## Modules[\u00a7](https://docs.rs/bytes/latest/bytes/#modules)\n\n[buf](https://docs.rs/bytes/latest/bytes/buf/index.html \"mod bytes::buf\")\n    Utilities for working with buffers.\n## Structs[\u00a7](https://docs.rs/bytes/latest/bytes/#structs)\n\n[Bytes](https://docs.rs/bytes/latest/bytes/struct.Bytes.html \"struct bytes::Bytes\")\n    A cheaply cloneable and sliceable chunk of contiguous memory.\n\n[BytesMut](https://docs.rs/bytes/latest/bytes/struct.BytesMut.html \"struct bytes::BytesMut\")\n    A unique reference to a contiguous slice of memory.\n\n[TryGetError](https://docs.rs/bytes/latest/bytes/struct.TryGetError.html \"struct bytes::TryGetError\")\n    Error type for the `try_get_` methods of [`Buf`](https://docs.rs/bytes/latest/bytes/buf/trait.Buf.html \"trait bytes::buf::Buf\"). Indicates that there were not enough remaining bytes in the buffer while attempting to get a value from a [`Buf`](https://docs.rs/bytes/latest/bytes/buf/trait.Buf.html \"trait bytes::buf::Buf\") with one of the `try_get_` methods.\n",
        "markdown_with_citations": "[](https://docs.rs/bytes/latest/bytes/all.html \"show sidebar\")\n# Crate bytesCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nProvides abstractions for working with bytes.\nThe `bytes` crate provides an efficient byte buffer structure (`Bytes`\u27e84\u27e9) and traits for working with buffer implementations (`Buf`\u27e85\u27e9, `BufMut`\u27e86\u27e9).\n## \u00a7\u27e87\u27e9`Bytes`\n`Bytes` is an efficient container for storing and operating on contiguous slices of memory. It is intended for use primarily in networking code, but could have applications elsewhere as well.\n`Bytes` values facilitate zero-copy network programming by allowing multiple `Bytes` objects to point to the same underlying memory. This is managed by using a reference count to track when the memory is no longer needed and can be freed.\nA `Bytes` handle can be created directly from an existing byte store (such as `&[u8]` or `Vec<u8>`), but usually a `BytesMut` is used first and written to. For example:\n```\nuse bytes::{BytesMut, BufMut};\nlet mut buf = BytesMut::with_capacity(1024);\nbuf.put(&b\"hello world\"[..]);\nbuf.put_u16(1234);\nlet a = buf.split();\nassert_eq!(a, b\"hello world\\x04\\xD2\"[..]);\nbuf.put(&b\"goodbye world\"[..]);\nlet b = buf.split();\nassert_eq!(b, b\"goodbye world\"[..]);\nassert_eq!(buf.capacity(), 998);\n```\n\nIn the above example, only a single buffer of 1024 is allocated. The handles `a` and `b` will share the underlying buffer and maintain indices tracking the view into the buffer represented by the handle.\nSee the struct docs\u27e84\u27e9 for more details.\n## \u00a7\u27e88\u27e9`Buf`, `BufMut`\nThese two traits provide read and write access to buffers. The underlying storage may or may not be in contiguous memory. For example, `Bytes` is a buffer that guarantees contiguous memory, but a rope\u27e89\u27e9) stores the bytes in disjoint chunks. `Buf` and `BufMut` maintain cursors tracking the current position in the underlying byte storage. When bytes are read or written, the cursor is advanced.\n### \u00a7\u27e810\u27e9Relation with `Read` and `Write`\nAt first glance, it may seem that `Buf` and `BufMut` overlap in functionality with `std::io::Read`\u27e811\u27e9 and `std::io::Write`\u27e812\u27e9. However, they serve different purposes. A buffer is the value that is provided as an argument to `Read::read` and `Write::write`. `Read` and `Write` may then perform a syscall, which has the potential of failing. Operations on `Buf` and `BufMut` are infallible.\n## Re-exports\u00a7\u27e813\u27e9\n\n`pub use crate::buf::Buf[](https://docs.rs/bytes/latest/bytes/buf/trait.Buf.html \"trait bytes::buf::Buf\");`\n\n\n`pub use crate::buf::BufMut[](https://docs.rs/bytes/latest/bytes/buf/trait.BufMut.html \"trait bytes::buf::BufMut\");`\n\n## Modules\u00a7\u27e814\u27e9\n\nbuf\u27e815\u27e9\n    Utilities for working with buffers.\n## Structs\u00a7\u27e816\u27e9\n\nBytes\u27e84\u27e9\n    A cheaply cloneable and sliceable chunk of contiguous memory.\n\nBytesMut\u27e817\u27e9\n    A unique reference to a contiguous slice of memory.\n\nTryGetError\u27e818\u27e9\n    Error type for the `try_get_` methods of `Buf`\u27e85\u27e9. Indicates that there were not enough remaining bytes in the buffer while attempting to get a value from a `Buf`\u27e85\u27e9 with one of the `try_get_` methods.\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/bytes/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/bytes/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/bytes/latest/src/bytes/lib.rs.html#1-199: Source\n\u27e84\u27e9 https://docs.rs/bytes/latest/bytes/struct.Bytes.html: struct bytes::Bytes - `Bytes`\n\u27e85\u27e9 https://docs.rs/bytes/latest/bytes/buf/trait.Buf.html: trait bytes::buf::Buf - `Buf`\n\u27e86\u27e9 https://docs.rs/bytes/latest/bytes/buf/trait.BufMut.html: trait bytes::buf::BufMut - `BufMut`\n\u27e87\u27e9 https://docs.rs/bytes/latest/bytes/#bytes: \u00a7\n\u27e88\u27e9 https://docs.rs/bytes/latest/bytes/#buf-bufmut: \u00a7\n\u27e89\u27e9 https://en.wikipedia.org/wiki/Rope_\\(data_structure\\: rope\n\u27e810\u27e9 https://docs.rs/bytes/latest/bytes/#relation-with-read-and-write: \u00a7\n\u27e811\u27e9 https://doc.rust-lang.org/nightly/std/io/trait.Read.html: trait std::io::Read - `std::io::Read`\n\u27e812\u27e9 https://doc.rust-lang.org/nightly/std/io/trait.Write.html: trait std::io::Write - `std::io::Write`\n\u27e813\u27e9 https://docs.rs/bytes/latest/bytes/#reexports: \u00a7\n\u27e814\u27e9 https://docs.rs/bytes/latest/bytes/#modules: \u00a7\n\u27e815\u27e9 https://docs.rs/bytes/latest/bytes/buf/index.html: mod bytes::buf - buf\n\u27e816\u27e9 https://docs.rs/bytes/latest/bytes/#structs: \u00a7\n\u27e817\u27e9 https://docs.rs/bytes/latest/bytes/struct.BytesMut.html: struct bytes::BytesMut - BytesMut\n\u27e818\u27e9 https://docs.rs/bytes/latest/bytes/struct.TryGetError.html: struct bytes::TryGetError - TryGetError\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `bytes` crate provides efficient abstractions for working with byte buffers, including the `Bytes` and `BytesMut` structures for managing contiguous slices of memory. It supports zero-copy operations, making it ideal for networking applications, and includes traits like `Buf` and `BufMut` for infallible read/write access to buffers. These tools enable advanced memory management and efficient handling of byte data.",
    "feature_summary": null,
    "use_case": "Networking",
    "score": 8.5,
    "factual_counterfactual": "### Pair 1: Zero-Copy Networking\n\u2705 **Factual:** The `Bytes` struct in the `bytes` crate facilitates zero-copy network programming by allowing multiple `Bytes` objects to share the same underlying memory, managed via reference counting.  \n\u274c **Counterfactual:** The `Bytes` struct requires copying the underlying memory whenever a new `Bytes` object is created, making it unsuitable for zero-copy networking.\n\n---\n\n### Pair 2: Contiguous Memory Guarantee\n\u2705 **Factual:** The `Bytes` struct guarantees contiguous memory storage, making it ideal for use cases like networking where such memory layouts are crucial.  \n\u274c **Counterfactual:** The `Bytes` struct can store data in disjoint chunks, similar to a rope data structure, rather than guaranteeing contiguous memory.\n\n---\n\n### Pair 3: Traits for Buffer Manipulation\n\u2705 **Factual:** The `Buf` and `BufMut` traits provide infallible methods for reading from and writing to buffers, advancing cursors as operations are performed.  \n\u274c **Counterfactual:** The `Buf` and `BufMut` traits are designed to replace the functionality of `std::io::Read` and `std::io::Write` for performing syscalls directly.",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}