{
    "name": "axum",
    "version": "0.8.4",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/axum/latest/axum/all.html \"show sidebar\")\n# Crate axumCopy item path\n[Settings](https://docs.rs/axum/latest/settings.html)\n[Help](https://docs.rs/axum/latest/help.html)\nSummary[Source](https://docs.rs/axum/latest/src/axum/lib.rs.html#1-488)\nExpand description\naxum is a web application framework that focuses on ergonomics and modularity.\n## [\u00a7](https://docs.rs/axum/latest/axum/#high-level-features)High-level features\n  * Route requests to handlers with a macro-free API.\n  * Declaratively parse requests using extractors.\n  * Simple and predictable error handling model.\n  * Generate responses with minimal boilerplate.\n  * Take full advantage of the [`tower`](https://crates.io/crates/tower) and [`tower-http`](https://crates.io/crates/tower-http) ecosystem of middleware, services, and utilities.\n\n\nIn particular, the last point is what sets `axum` apart from other frameworks. `axum` doesn\u2019t have its own middleware system but instead uses [`tower::Service`](https://docs.rs/tower-service/0.3.3/x86_64-unknown-linux-gnu/tower_service/trait.Service.html \"trait tower_service::Service\"). This means `axum` gets timeouts, tracing, compression, authorization, and more, for free. It also enables you to share middleware with applications written using [`hyper`](http://crates.io/crates/hyper) or [`tonic`](http://crates.io/crates/tonic).\n## [\u00a7](https://docs.rs/axum/latest/axum/#compatibility)Compatibility\naxum is designed to work with [tokio](https://docs.rs/tokio/1.45.1/x86_64-unknown-linux-gnu/tokio/index.html \"mod tokio\") and [hyper](https://docs.rs/hyper/1.6.0/x86_64-unknown-linux-gnu/hyper/index.html \"mod hyper\"). Runtime and transport layer independence is not a goal, at least for the time being.\n## [\u00a7](https://docs.rs/axum/latest/axum/#example)Example\nThe \u201cHello, World!\u201d of axum is:\n```\nuse axum::{\n  routing::get,\n  Router,\n};\n#[tokio::main]\nasync fn main() {\n  // build our application with a single route\n  let app = Router::new().route(\"/\", get(|| async { \"Hello, World!\" }));\n  // run our app with hyper, listening globally on port 3000\n  let listener = tokio::net::TcpListener::bind(\"0.0.0.0:3000\").await.unwrap();\n  axum::serve(listener, app).await.unwrap();\n}\n```\n\nNote using `#[tokio::main]` requires you enable tokio\u2019s `macros` and `rt-multi-thread` features or just `full` to enable all features (`cargo add tokio --features macros,rt-multi-thread`).\n## [\u00a7](https://docs.rs/axum/latest/axum/#routing)Routing\n[`Router`](https://docs.rs/axum/latest/axum/struct.Router.html \"struct axum::Router\") is used to set up which paths go to which services:\n```\nuse axum::{Router, routing::get};\n// our router\nlet app = Router::new()\n  .route(\"/\", get(root))\n  .route(\"/foo\", get(get_foo).post(post_foo))\n  .route(\"/foo/bar\", get(foo_bar));\n// which calls one of these handlers\nasync fn root() {}\nasync fn get_foo() {}\nasync fn post_foo() {}\nasync fn foo_bar() {}\n```\n\nSee [`Router`](https://docs.rs/axum/latest/axum/struct.Router.html \"struct axum::Router\") for more details on routing.\n## [\u00a7](https://docs.rs/axum/latest/axum/#handlers)Handlers\nIn axum a \u201chandler\u201d is an async function that accepts zero or more [\u201cextractors\u201d](https://docs.rs/axum/latest/axum/extract/index.html \"mod axum::extract\") as arguments and returns something that can be converted [into a response](https://docs.rs/axum/latest/axum/response/index.html \"mod axum::response\").\nHandlers are where your application logic lives and axum applications are built by routing between handlers.\nSee [`handler`](https://docs.rs/axum/latest/axum/handler/index.html \"mod axum::handler\") for more details on handlers.\n## [\u00a7](https://docs.rs/axum/latest/axum/#extractors)Extractors\nAn extractor is a type that implements [`FromRequest`](https://docs.rs/axum/latest/axum/extract/trait.FromRequest.html \"trait axum::extract::FromRequest\") or [`FromRequestParts`](https://docs.rs/axum/latest/axum/extract/trait.FromRequestParts.html \"trait axum::extract::FromRequestParts\"). Extractors are how you pick apart the incoming request to get the parts your handler needs.\n```\nuse axum::extract::{Path, Query, Json};\nuse std::collections::HashMap;\n// `Path` gives you the path parameters and deserializes them.\nasync fn path(Path(user_id): Path<u32>) {}\n// `Query` gives you the query parameters and deserializes them.\nasync fn query(Query(params): Query<HashMap<String, String>>) {}\n// Buffer the request body and deserialize it as JSON into a\n// `serde_json::Value`. `Json` supports any type that implements\n// `serde::Deserialize`.\nasync fn json(Json(payload): Json<serde_json::Value>) {}\n```\n\nSee [`extract`](https://docs.rs/axum/latest/axum/extract/index.html \"mod axum::extract\") for more details on extractors.\n## [\u00a7](https://docs.rs/axum/latest/axum/#responses)Responses\nAnything that implements [`IntoResponse`](https://docs.rs/axum/latest/axum/response/trait.IntoResponse.html \"trait axum::response::IntoResponse\") can be returned from handlers.\n```\nuse axum::{\n  body::Body,\n  routing::get,\n  response::Json,\n  Router,\n};\nuse serde_json::{Value, json};\n// `&'static str` becomes a `200 OK` with `content-type: text/plain; charset=utf-8`\nasync fn plain_text() -> &'static str {\n  \"foo\"\n}\n// `Json` gives a content-type of `application/json` and works with any type\n// that implements `serde::Serialize`\nasync fn json() -> Json<Value> {\n  Json(json!({ \"data\": 42 }))\n}\nlet app = Router::new()\n  .route(\"/plain_text\", get(plain_text))\n  .route(\"/json\", get(json));\n```\n\nSee [`response`](https://docs.rs/axum/latest/axum/response/index.html \"mod axum::response\") for more details on building responses.\n## [\u00a7](https://docs.rs/axum/latest/axum/#error-handling)Error handling\naxum aims to have a simple and predictable error handling model. That means it is simple to convert errors into responses and you are guaranteed that all errors are handled.\nSee [`error_handling`](https://docs.rs/axum/latest/axum/error_handling/index.html \"mod axum::error_handling\") for more details on axum\u2019s error handling model and how to handle errors gracefully.\n## [\u00a7](https://docs.rs/axum/latest/axum/#middleware)Middleware\nThere are several different ways to write middleware for axum. See [`middleware`](https://docs.rs/axum/latest/axum/middleware/index.html \"mod axum::middleware\") for more details.\n## [\u00a7](https://docs.rs/axum/latest/axum/#sharing-state-with-handlers)Sharing state with handlers\nIt is common to share some state between handlers. For example, a pool of database connections or clients to other services may need to be shared.\nThe four most common ways of doing that are:\n  * Using the [`State`](https://docs.rs/axum/latest/axum/extract/struct.State.html \"struct axum::extract::State\") extractor\n  * Using request extensions\n  * Using closure captures\n  * Using task-local variables\n\n\n### [\u00a7](https://docs.rs/axum/latest/axum/#using-the-state-extractor)Using the [`State`](https://docs.rs/axum/latest/axum/extract/struct.State.html \"struct axum::extract::State\") extractor\n```\nuse axum::{\n  extract::State,\n  routing::get,\n  Router,\n};\nuse std::sync::Arc;\nstruct AppState {\n  // ...\n}\nlet shared_state = Arc::new(AppState { /* ... */ });\nlet app = Router::new()\n  .route(\"/\", get(handler))\n  .with_state(shared_state);\nasync fn handler(\n  State(state): State<Arc<AppState>>,\n) {\n  // ...\n}\n```\n\nYou should prefer using [`State`](https://docs.rs/axum/latest/axum/extract/struct.State.html \"struct axum::extract::State\") if possible since it\u2019s more type safe. The downside is that it\u2019s less dynamic than task-local variables and request extensions.\nSee [`State`](https://docs.rs/axum/latest/axum/extract/struct.State.html \"struct axum::extract::State\") for more details about accessing state.\n### [\u00a7](https://docs.rs/axum/latest/axum/#using-request-extensions)Using request extensions\nAnother way to share state with handlers is using [`Extension`](https://docs.rs/axum/latest/axum/struct.Extension.html \"struct axum::Extension\") as layer and extractor:\n```\nuse axum::{\n  extract::Extension,\n  routing::get,\n  Router,\n};\nuse std::sync::Arc;\nstruct AppState {\n  // ...\n}\nlet shared_state = Arc::new(AppState { /* ... */ });\nlet app = Router::new()\n  .route(\"/\", get(handler))\n  .layer(Extension(shared_state));\nasync fn handler(\n  Extension(state): Extension<Arc<AppState>>,\n) {\n  // ...\n}\n```\n\nThe downside to this approach is that you\u2019ll get runtime errors (specifically a `500 Internal Server Error` response) if you try and extract an extension that doesn\u2019t exist, perhaps because you forgot to add the middleware or because you\u2019re extracting the wrong type.\n### [\u00a7](https://docs.rs/axum/latest/axum/#using-closure-captures)Using closure captures\nState can also be passed directly to handlers using closure captures:\n```\nuse axum::{\n  Json,\n  extract::{Extension, Path},\n  routing::{get, post},\n  Router,\n};\nuse std::sync::Arc;\nuse serde::Deserialize;\nstruct AppState {\n  // ...\n}\nlet shared_state = Arc::new(AppState { /* ... */ });\nlet app = Router::new()\n  .route(\n    \"/users\",\n    post({\n      let shared_state = Arc::clone(&shared_state);\n      move |body| create_user(body, shared_state)\n    }),\n  )\n  .route(\n    \"/users/{id}\",\n    get({\n      let shared_state = Arc::clone(&shared_state);\n      move |path| get_user(path, shared_state)\n    }),\n  );\nasync fn get_user(Path(user_id): Path<String>, state: Arc<AppState>) {\n  // ...\n}\nasync fn create_user(Json(payload): Json<CreateUserPayload>, state: Arc<AppState>) {\n  // ...\n}\n#[derive(Deserialize)]\nstruct CreateUserPayload {\n  // ...\n}\n```\n\nThe downside to this approach is that it\u2019s a the most verbose approach.\n### [\u00a7](https://docs.rs/axum/latest/axum/#using-task-local-variables)Using task-local variables\nThis also allows to share state with `IntoResponse` implementations:\n```\nuse axum::{\n  extract::Request,\n  http::{header, StatusCode},\n  middleware::{self, Next},\n  response::{IntoResponse, Response},\n  routing::get,\n  Router,\n};\nuse tokio::task_local;\n#[derive(Clone)]\nstruct CurrentUser {\n  name: String,\n}\ntask_local! {\n  pub static USER: CurrentUser;\n}\nasync fn auth(req: Request, next: Next) -> Result<Response, StatusCode> {\n  let auth_header = req\n    .headers()\n    .get(header::AUTHORIZATION)\n    .and_then(|header| header.to_str().ok())\n    .ok_or(StatusCode::UNAUTHORIZED)?;\n  if let Some(current_user) = authorize_current_user(auth_header).await {\n    // State is setup here in the middleware\n    Ok(USER.scope(current_user, next.run(req)).await)\n  } else {\n    Err(StatusCode::UNAUTHORIZED)\n  }\n}\nasync fn authorize_current_user(auth_token: &str) -> Option<CurrentUser> {\n  Some(CurrentUser {\n    name: auth_token.to_string(),\n  })\n}\nstruct UserResponse;\nimpl IntoResponse for UserResponse {\n  fn into_response(self) -> Response {\n    // State is accessed here in the IntoResponse implementation\n    let current_user = USER.with(|u| u.clone());\n    (StatusCode::OK, current_user.name).into_response()\n  }\n}\nasync fn handler() -> UserResponse {\n  UserResponse\n}\nlet app: Router = Router::new()\n  .route(\"/\", get(handler))\n  .route_layer(middleware::from_fn(auth));\n```\n\nThe main downside to this approach is that it only works when the async executor being used has the concept of task-local variables. The example above uses [tokio\u2019s `task_local` macro](https://docs.rs/tokio/1/tokio/macro.task_local.html). smol does not yet offer equivalent functionality at the time of writing (see [this GitHub issue](https://github.com/smol-rs/async-executor/issues/139)).\n## [\u00a7](https://docs.rs/axum/latest/axum/#building-integrations-for-axum)Building integrations for axum\nLibraries authors that want to provide [`FromRequest`](https://docs.rs/axum/latest/axum/extract/trait.FromRequest.html \"trait axum::extract::FromRequest\"), [`FromRequestParts`](https://docs.rs/axum/latest/axum/extract/trait.FromRequestParts.html \"trait axum::extract::FromRequestParts\"), or [`IntoResponse`](https://docs.rs/axum/latest/axum/response/trait.IntoResponse.html \"trait axum::response::IntoResponse\") implementations should depend on the [`axum-core`](http://crates.io/crates/axum-core) crate, instead of `axum` if possible. [`axum-core`](http://crates.io/crates/axum-core) contains core types and traits and is less likely to receive breaking changes.\n## [\u00a7](https://docs.rs/axum/latest/axum/#required-dependencies)Required dependencies\nTo use axum there are a few dependencies you have to pull in as well:\n```\n[dependencies]\naxum = \"<latest-version>\"\ntokio = { version = \"<latest-version>\", features = [\"full\"] }\ntower = \"<latest-version>\"\n```\n\nThe `\"full\"` feature for tokio isn\u2019t necessary but it\u2019s the easiest way to get started.\nTower isn\u2019t strictly necessary either but helpful for testing. See the testing example in the repo to learn more about testing axum apps.\n## [\u00a7](https://docs.rs/axum/latest/axum/#examples)Examples\nThe axum repo contains [a number of examples](https://github.com/tokio-rs/axum/tree/main/examples) that show how to put all the pieces together.\n## [\u00a7](https://docs.rs/axum/latest/axum/#feature-flags)Feature flags\naxum uses a set of [feature flags](https://doc.rust-lang.org/cargo/reference/features.html#the-features-section) to reduce the amount of compiled and optional dependencies.\nThe following optional features are available:\nName| Description| Default?  \n---|---|---  \n`http1`| Enables hyper\u2019s `http1` feature| Yes  \n`http2`| Enables hyper\u2019s `http2` feature| No  \n`json`| Enables the [`Json`](https://docs.rs/axum/latest/axum/struct.Json.html \"struct axum::Json\") type and some similar convenience functionality| Yes  \n`macros`| Enables optional utility macros| No  \n`matched-path`| Enables capturing of every request\u2019s router path and the [`MatchedPath`](https://docs.rs/axum/latest/axum/extract/struct.MatchedPath.html \"struct axum::extract::MatchedPath\") extractor| Yes  \n`multipart`| Enables parsing `multipart/form-data` requests with [`Multipart`](https://docs.rs/axum/latest/axum/extract/struct.Multipart.html \"struct axum::extract::Multipart\")| No  \n`original-uri`| Enables capturing of every request\u2019s original URI and the [`OriginalUri`](https://docs.rs/axum/latest/axum/extract/struct.OriginalUri.html \"struct axum::extract::OriginalUri\") extractor| Yes  \n`tokio`| Enables `tokio` as a dependency and `axum::serve`, `SSE` and `extract::connect_info` types.| Yes  \n`tower-log`| Enables `tower`\u2019s `log` feature| Yes  \n`tracing`| Log rejections from built-in extractors| Yes  \n`ws`| Enables WebSockets support via [`extract::ws`](https://docs.rs/axum/latest/axum/extract/ws/index.html \"mod axum::extract::ws\")| No  \n`form`| Enables the `Form` extractor| Yes  \n`query`| Enables the `Query` extractor| Yes  \n## Re-exports[\u00a7](https://docs.rs/axum/latest/axum/#reexports)\n\n`pub use http[](https://docs.rs/http/1.3.1/x86_64-unknown-linux-gnu/http/index.html \"mod http\");`\n\n## Modules[\u00a7](https://docs.rs/axum/latest/axum/#modules)\n\n[body](https://docs.rs/axum/latest/axum/body/index.html \"mod axum::body\")\n    HTTP body utilities.\n\n[error_handling](https://docs.rs/axum/latest/axum/error_handling/index.html \"mod axum::error_handling\")\n    Error handling model and utilities\n\n[extract](https://docs.rs/axum/latest/axum/extract/index.html \"mod axum::extract\")\n    Types and traits for extracting data from requests.\n\n[handler](https://docs.rs/axum/latest/axum/handler/index.html \"mod axum::handler\")\n    Async functions that can be used to handle requests.\n\n[middleware](https://docs.rs/axum/latest/axum/middleware/index.html \"mod axum::middleware\")\n    Utilities for writing middleware\n\n[response](https://docs.rs/axum/latest/axum/response/index.html \"mod axum::response\")\n    Types and traits for generating responses.\n\n[routing](https://docs.rs/axum/latest/axum/routing/index.html \"mod axum::routing\")\n    Routing between [`Service`](https://docs.rs/tower-service/0.3.3/x86_64-unknown-linux-gnu/tower_service/trait.Service.html \"trait tower_service::Service\")s and handlers.\n\n[serve](https://docs.rs/axum/latest/axum/serve/index.html \"mod axum::serve\")`tokio` and (`http1` or `http2`)\n    Serve services.\n\n[test_helpers](https://docs.rs/axum/latest/axum/test_helpers/index.html \"mod axum::test_helpers\")`__private`\n\n## Structs[\u00a7](https://docs.rs/axum/latest/axum/#structs)\n\n[Error](https://docs.rs/axum/latest/axum/struct.Error.html \"struct axum::Error\")\n    Errors that can happen when using axum.\n\n[Extension](https://docs.rs/axum/latest/axum/struct.Extension.html \"struct axum::Extension\")\n    Extractor and response for extensions.\n\n[Form](https://docs.rs/axum/latest/axum/struct.Form.html \"struct axum::Form\")`form`\n    URL encoded extractor and response.\n\n[Json](https://docs.rs/axum/latest/axum/struct.Json.html \"struct axum::Json\")`json`\n    JSON Extractor / Response.\n\n[Router](https://docs.rs/axum/latest/axum/struct.Router.html \"struct axum::Router\")\n    The router type for composing handlers and services.\n## Traits[\u00a7](https://docs.rs/axum/latest/axum/#traits)\n\n[RequestExt](https://docs.rs/axum/latest/axum/trait.RequestExt.html \"trait axum::RequestExt\")\n    Extension trait that adds additional methods to [`Request`](https://docs.rs/axum/latest/axum/extract/type.Request.html \"type axum::extract::Request\").\n\n[RequestPartsExt](https://docs.rs/axum/latest/axum/trait.RequestPartsExt.html \"trait axum::RequestPartsExt\")\n    Extension trait that adds additional methods to [`Parts`](https://docs.rs/http/1.3.1/x86_64-unknown-linux-gnu/http/request/struct.Parts.html \"struct http::request::Parts\").\n\n[ServiceExt](https://docs.rs/axum/latest/axum/trait.ServiceExt.html \"trait axum::ServiceExt\")\n    Extension trait that adds additional methods to any [`Service`](https://docs.rs/tower-service/0.3.3/x86_64-unknown-linux-gnu/tower_service/trait.Service.html \"trait tower_service::Service\").\n## Functions[\u00a7](https://docs.rs/axum/latest/axum/#functions)\n\n[serve](https://docs.rs/axum/latest/axum/fn.serve.html \"fn axum::serve\")`tokio` and (`http1` or `http2`)\n    Serve the service with the supplied listener.\n## Type Aliases[\u00a7](https://docs.rs/axum/latest/axum/#types)\n\n[BoxError](https://docs.rs/axum/latest/axum/type.BoxError.html \"type axum::BoxError\")\n    Alias for a type-erased error type.\n## Attribute Macros[\u00a7](https://docs.rs/axum/latest/axum/#attributes)\n\n[debug_handler](https://docs.rs/axum/latest/axum/attr.debug_handler.html \"attr axum::debug_handler\")`macros`\n    Generates better error messages when applied to handler functions.\n\n[debug_middleware](https://docs.rs/axum/latest/axum/attr.debug_middleware.html \"attr axum::debug_middleware\")`macros`\n    Generates better error messages when applied to middleware functions.\n",
        "markdown_with_citations": "[](https://docs.rs/axum/latest/axum/all.html \"show sidebar\")\n# Crate axumCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\naxum is a web application framework that focuses on ergonomics and modularity.\n## \u00a7\u27e84\u27e9High-level features\n  * Route requests to handlers with a macro-free API.\n  * Declaratively parse requests using extractors.\n  * Simple and predictable error handling model.\n  * Generate responses with minimal boilerplate.\n  * Take full advantage of the `tower`\u27e85\u27e9 and `tower-http`\u27e86\u27e9 ecosystem of middleware, services, and utilities.\n\n\nIn particular, the last point is what sets `axum` apart from other frameworks. `axum` doesn\u2019t have its own middleware system but instead uses `tower::Service`\u27e87\u27e9. This means `axum` gets timeouts, tracing, compression, authorization, and more, for free. It also enables you to share middleware with applications written using `hyper`\u27e88\u27e9 or `tonic`\u27e89\u27e9.\n## \u00a7\u27e810\u27e9Compatibility\naxum is designed to work with tokio\u27e811\u27e9 and hyper\u27e812\u27e9. Runtime and transport layer independence is not a goal, at least for the time being.\n## \u00a7\u27e813\u27e9Example\nThe \u201cHello, World!\u201d of axum is:\n```\nuse axum::{\n  routing::get,\n  Router,\n};\n#[tokio::main]\nasync fn main() {\n  // build our application with a single route\n  let app = Router::new().route(\"/\", get(|| async { \"Hello, World!\" }));\n  // run our app with hyper, listening globally on port 3000\n  let listener = tokio::net::TcpListener::bind(\"0.0.0.0:3000\").await.unwrap();\n  axum::serve(listener, app).await.unwrap();\n}\n```\n\nNote using `#[tokio::main]` requires you enable tokio\u2019s `macros` and `rt-multi-thread` features or just `full` to enable all features (`cargo add tokio --features macros,rt-multi-thread`).\n## \u00a7\u27e814\u27e9Routing\n`Router`\u27e815\u27e9 is used to set up which paths go to which services:\n```\nuse axum::{Router, routing::get};\n// our router\nlet app = Router::new()\n  .route(\"/\", get(root))\n  .route(\"/foo\", get(get_foo).post(post_foo))\n  .route(\"/foo/bar\", get(foo_bar));\n// which calls one of these handlers\nasync fn root() {}\nasync fn get_foo() {}\nasync fn post_foo() {}\nasync fn foo_bar() {}\n```\n\nSee `Router`\u27e815\u27e9 for more details on routing.\n## \u00a7\u27e816\u27e9Handlers\nIn axum a \u201chandler\u201d is an async function that accepts zero or more \u201cextractors\u201d\u27e817\u27e9 as arguments and returns something that can be converted into a response\u27e818\u27e9.\nHandlers are where your application logic lives and axum applications are built by routing between handlers.\nSee `handler`\u27e819\u27e9 for more details on handlers.\n## \u00a7\u27e820\u27e9Extractors\nAn extractor is a type that implements `FromRequest`\u27e821\u27e9 or `FromRequestParts`\u27e822\u27e9. Extractors are how you pick apart the incoming request to get the parts your handler needs.\n```\nuse axum::extract::{Path, Query, Json};\nuse std::collections::HashMap;\n// `Path` gives you the path parameters and deserializes them.\nasync fn path(Path(user_id): Path<u32>) {}\n// `Query` gives you the query parameters and deserializes them.\nasync fn query(Query(params): Query<HashMap<String, String>>) {}\n// Buffer the request body and deserialize it as JSON into a\n// `serde_json::Value`. `Json` supports any type that implements\n// `serde::Deserialize`.\nasync fn json(Json(payload): Json<serde_json::Value>) {}\n```\n\nSee `extract`\u27e817\u27e9 for more details on extractors.\n## \u00a7\u27e823\u27e9Responses\nAnything that implements `IntoResponse`\u27e824\u27e9 can be returned from handlers.\n```\nuse axum::{\n  body::Body,\n  routing::get,\n  response::Json,\n  Router,\n};\nuse serde_json::{Value, json};\n// `&'static str` becomes a `200 OK` with `content-type: text/plain; charset=utf-8`\nasync fn plain_text() -> &'static str {\n  \"foo\"\n}\n// `Json` gives a content-type of `application/json` and works with any type\n// that implements `serde::Serialize`\nasync fn json() -> Json<Value> {\n  Json(json!({ \"data\": 42 }))\n}\nlet app = Router::new()\n  .route(\"/plain_text\", get(plain_text))\n  .route(\"/json\", get(json));\n```\n\nSee `response`\u27e818\u27e9 for more details on building responses.\n## \u00a7\u27e825\u27e9Error handling\naxum aims to have a simple and predictable error handling model. That means it is simple to convert errors into responses and you are guaranteed that all errors are handled.\nSee `error_handling`\u27e826\u27e9 for more details on axum\u2019s error handling model and how to handle errors gracefully.\n## \u00a7\u27e827\u27e9Middleware\nThere are several different ways to write middleware for axum. See `middleware`\u27e828\u27e9 for more details.\n## \u00a7\u27e829\u27e9Sharing state with handlers\nIt is common to share some state between handlers. For example, a pool of database connections or clients to other services may need to be shared.\nThe four most common ways of doing that are:\n  * Using the `State`\u27e830\u27e9 extractor\n  * Using request extensions\n  * Using closure captures\n  * Using task-local variables\n\n\n### \u00a7\u27e831\u27e9Using the `State`\u27e830\u27e9 extractor\n```\nuse axum::{\n  extract::State,\n  routing::get,\n  Router,\n};\nuse std::sync::Arc;\nstruct AppState {\n  // ...\n}\nlet shared_state = Arc::new(AppState { /* ... */ });\nlet app = Router::new()\n  .route(\"/\", get(handler))\n  .with_state(shared_state);\nasync fn handler(\n  State(state): State<Arc<AppState>>,\n) {\n  // ...\n}\n```\n\nYou should prefer using `State`\u27e830\u27e9 if possible since it\u2019s more type safe. The downside is that it\u2019s less dynamic than task-local variables and request extensions.\nSee `State`\u27e830\u27e9 for more details about accessing state.\n### \u00a7\u27e832\u27e9Using request extensions\nAnother way to share state with handlers is using `Extension`\u27e833\u27e9 as layer and extractor:\n```\nuse axum::{\n  extract::Extension,\n  routing::get,\n  Router,\n};\nuse std::sync::Arc;\nstruct AppState {\n  // ...\n}\nlet shared_state = Arc::new(AppState { /* ... */ });\nlet app = Router::new()\n  .route(\"/\", get(handler))\n  .layer(Extension(shared_state));\nasync fn handler(\n  Extension(state): Extension<Arc<AppState>>,\n) {\n  // ...\n}\n```\n\nThe downside to this approach is that you\u2019ll get runtime errors (specifically a `500 Internal Server Error` response) if you try and extract an extension that doesn\u2019t exist, perhaps because you forgot to add the middleware or because you\u2019re extracting the wrong type.\n### \u00a7\u27e834\u27e9Using closure captures\nState can also be passed directly to handlers using closure captures:\n```\nuse axum::{\n  Json,\n  extract::{Extension, Path},\n  routing::{get, post},\n  Router,\n};\nuse std::sync::Arc;\nuse serde::Deserialize;\nstruct AppState {\n  // ...\n}\nlet shared_state = Arc::new(AppState { /* ... */ });\nlet app = Router::new()\n  .route(\n    \"/users\",\n    post({\n      let shared_state = Arc::clone(&shared_state);\n      move |body| create_user(body, shared_state)\n    }),\n  )\n  .route(\n    \"/users/{id}\",\n    get({\n      let shared_state = Arc::clone(&shared_state);\n      move |path| get_user(path, shared_state)\n    }),\n  );\nasync fn get_user(Path(user_id): Path<String>, state: Arc<AppState>) {\n  // ...\n}\nasync fn create_user(Json(payload): Json<CreateUserPayload>, state: Arc<AppState>) {\n  // ...\n}\n#[derive(Deserialize)]\nstruct CreateUserPayload {\n  // ...\n}\n```\n\nThe downside to this approach is that it\u2019s a the most verbose approach.\n### \u00a7\u27e835\u27e9Using task-local variables\nThis also allows to share state with `IntoResponse` implementations:\n```\nuse axum::{\n  extract::Request,\n  http::{header, StatusCode},\n  middleware::{self, Next},\n  response::{IntoResponse, Response},\n  routing::get,\n  Router,\n};\nuse tokio::task_local;\n#[derive(Clone)]\nstruct CurrentUser {\n  name: String,\n}\ntask_local! {\n  pub static USER: CurrentUser;\n}\nasync fn auth(req: Request, next: Next) -> Result<Response, StatusCode> {\n  let auth_header = req\n    .headers()\n    .get(header::AUTHORIZATION)\n    .and_then(|header| header.to_str().ok())\n    .ok_or(StatusCode::UNAUTHORIZED)?;\n  if let Some(current_user) = authorize_current_user(auth_header).await {\n    // State is setup here in the middleware\n    Ok(USER.scope(current_user, next.run(req)).await)\n  } else {\n    Err(StatusCode::UNAUTHORIZED)\n  }\n}\nasync fn authorize_current_user(auth_token: &str) -> Option<CurrentUser> {\n  Some(CurrentUser {\n    name: auth_token.to_string(),\n  })\n}\nstruct UserResponse;\nimpl IntoResponse for UserResponse {\n  fn into_response(self) -> Response {\n    // State is accessed here in the IntoResponse implementation\n    let current_user = USER.with(|u| u.clone());\n    (StatusCode::OK, current_user.name).into_response()\n  }\n}\nasync fn handler() -> UserResponse {\n  UserResponse\n}\nlet app: Router = Router::new()\n  .route(\"/\", get(handler))\n  .route_layer(middleware::from_fn(auth));\n```\n\nThe main downside to this approach is that it only works when the async executor being used has the concept of task-local variables. The example above uses tokio\u2019s `task_local` macro\u27e836\u27e9. smol does not yet offer equivalent functionality at the time of writing (see this GitHub issue\u27e837\u27e9).\n## \u00a7\u27e838\u27e9Building integrations for axum\nLibraries authors that want to provide `FromRequest`\u27e821\u27e9, `FromRequestParts`\u27e822\u27e9, or `IntoResponse`\u27e824\u27e9 implementations should depend on the `axum-core`\u27e839\u27e9 crate, instead of `axum` if possible. `axum-core`\u27e839\u27e9 contains core types and traits and is less likely to receive breaking changes.\n## \u00a7\u27e840\u27e9Required dependencies\nTo use axum there are a few dependencies you have to pull in as well:\n```\n[dependencies]\naxum = \"<latest-version>\"\ntokio = { version = \"<latest-version>\", features = [\"full\"] }\ntower = \"<latest-version>\"\n```\n\nThe `\"full\"` feature for tokio isn\u2019t necessary but it\u2019s the easiest way to get started.\nTower isn\u2019t strictly necessary either but helpful for testing. See the testing example in the repo to learn more about testing axum apps.\n## \u00a7\u27e841\u27e9Examples\nThe axum repo contains a number of examples\u27e842\u27e9 that show how to put all the pieces together.\n## \u00a7\u27e843\u27e9Feature flags\naxum uses a set of feature flags\u27e844\u27e9 to reduce the amount of compiled and optional dependencies.\nThe following optional features are available:\nName| Description| Default?  \n---|---|---  \n`http1`| Enables hyper\u2019s `http1` feature| Yes  \n`http2`| Enables hyper\u2019s `http2` feature| No  \n`json`| Enables the `Json`\u27e845\u27e9 type and some similar convenience functionality| Yes  \n`macros`| Enables optional utility macros| No  \n`matched-path`| Enables capturing of every request\u2019s router path and the `MatchedPath`\u27e846\u27e9 extractor| Yes  \n`multipart`| Enables parsing `multipart/form-data` requests with `Multipart`\u27e847\u27e9| No  \n`original-uri`| Enables capturing of every request\u2019s original URI and the `OriginalUri`\u27e848\u27e9 extractor| Yes  \n`tokio`| Enables `tokio` as a dependency and `axum::serve`, `SSE` and `extract::connect_info` types.| Yes  \n`tower-log`| Enables `tower`\u2019s `log` feature| Yes  \n`tracing`| Log rejections from built-in extractors| Yes  \n`ws`| Enables WebSockets support via `extract::ws`\u27e849\u27e9| No  \n`form`| Enables the `Form` extractor| Yes  \n`query`| Enables the `Query` extractor| Yes  \n## Re-exports\u00a7\u27e850\u27e9\n\n`pub use http[](https://docs.rs/http/1.3.1/x86_64-unknown-linux-gnu/http/index.html \"mod http\");`\n\n## Modules\u00a7\u27e851\u27e9\n\nbody\u27e852\u27e9\n    HTTP body utilities.\n\nerror_handling\u27e826\u27e9\n    Error handling model and utilities\n\nextract\u27e817\u27e9\n    Types and traits for extracting data from requests.\n\nhandler\u27e819\u27e9\n    Async functions that can be used to handle requests.\n\nmiddleware\u27e828\u27e9\n    Utilities for writing middleware\n\nresponse\u27e818\u27e9\n    Types and traits for generating responses.\n\nrouting\u27e853\u27e9\n    Routing between `Service`\u27e87\u27e9s and handlers.\n\nserve\u27e854\u27e9`tokio` and (`http1` or `http2`)\n    Serve services.\n\ntest_helpers\u27e855\u27e9`__private`\n\n## Structs\u00a7\u27e856\u27e9\n\nError\u27e857\u27e9\n    Errors that can happen when using axum.\n\nExtension\u27e833\u27e9\n    Extractor and response for extensions.\n\nForm\u27e858\u27e9`form`\n    URL encoded extractor and response.\n\nJson\u27e845\u27e9`json`\n    JSON Extractor / Response.\n\nRouter\u27e815\u27e9\n    The router type for composing handlers and services.\n## Traits\u00a7\u27e859\u27e9\n\nRequestExt\u27e860\u27e9\n    Extension trait that adds additional methods to `Request`\u27e861\u27e9.\n\nRequestPartsExt\u27e862\u27e9\n    Extension trait that adds additional methods to `Parts`\u27e863\u27e9.\n\nServiceExt\u27e864\u27e9\n    Extension trait that adds additional methods to any `Service`\u27e87\u27e9.\n## Functions\u00a7\u27e865\u27e9\n\nserve\u27e866\u27e9`tokio` and (`http1` or `http2`)\n    Serve the service with the supplied listener.\n## Type Aliases\u00a7\u27e867\u27e9\n\nBoxError\u27e868\u27e9\n    Alias for a type-erased error type.\n## Attribute Macros\u00a7\u27e869\u27e9\n\ndebug_handler\u27e870\u27e9`macros`\n    Generates better error messages when applied to handler functions.\n\ndebug_middleware\u27e871\u27e9`macros`\n    Generates better error messages when applied to middleware functions.\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/axum/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/axum/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/axum/latest/src/axum/lib.rs.html#1-488: Source\n\u27e84\u27e9 https://docs.rs/axum/latest/axum/#high-level-features: \u00a7\n\u27e85\u27e9 https://crates.io/crates/tower: `tower`\n\u27e86\u27e9 https://crates.io/crates/tower-http: `tower-http`\n\u27e87\u27e9 https://docs.rs/tower-service/0.3.3/x86_64-unknown-linux-gnu/tower_service/trait.Service.html: trait tower_service::Service - `tower::Service`\n\u27e88\u27e9 http://crates.io/crates/hyper: `hyper`\n\u27e89\u27e9 http://crates.io/crates/tonic: `tonic`\n\u27e810\u27e9 https://docs.rs/axum/latest/axum/#compatibility: \u00a7\n\u27e811\u27e9 https://docs.rs/tokio/1.45.1/x86_64-unknown-linux-gnu/tokio/index.html: mod tokio - tokio\n\u27e812\u27e9 https://docs.rs/hyper/1.6.0/x86_64-unknown-linux-gnu/hyper/index.html: mod hyper - hyper\n\u27e813\u27e9 https://docs.rs/axum/latest/axum/#example: \u00a7\n\u27e814\u27e9 https://docs.rs/axum/latest/axum/#routing: \u00a7\n\u27e815\u27e9 https://docs.rs/axum/latest/axum/struct.Router.html: struct axum::Router - `Router`\n\u27e816\u27e9 https://docs.rs/axum/latest/axum/#handlers: \u00a7\n\u27e817\u27e9 https://docs.rs/axum/latest/axum/extract/index.html: mod axum::extract - \u201cextractors\u201d\n\u27e818\u27e9 https://docs.rs/axum/latest/axum/response/index.html: mod axum::response - into a response\n\u27e819\u27e9 https://docs.rs/axum/latest/axum/handler/index.html: mod axum::handler - `handler`\n\u27e820\u27e9 https://docs.rs/axum/latest/axum/#extractors: \u00a7\n\u27e821\u27e9 https://docs.rs/axum/latest/axum/extract/trait.FromRequest.html: trait axum::extract::FromRequest - `FromRequest`\n\u27e822\u27e9 https://docs.rs/axum/latest/axum/extract/trait.FromRequestParts.html: trait axum::extract::FromRequestParts - `FromRequestParts`\n\u27e823\u27e9 https://docs.rs/axum/latest/axum/#responses: \u00a7\n\u27e824\u27e9 https://docs.rs/axum/latest/axum/response/trait.IntoResponse.html: trait axum::response::IntoResponse - `IntoResponse`\n\u27e825\u27e9 https://docs.rs/axum/latest/axum/#error-handling: \u00a7\n\u27e826\u27e9 https://docs.rs/axum/latest/axum/error_handling/index.html: mod axum::error_handling - `error_handling`\n\u27e827\u27e9 https://docs.rs/axum/latest/axum/#middleware: \u00a7\n\u27e828\u27e9 https://docs.rs/axum/latest/axum/middleware/index.html: mod axum::middleware - `middleware`\n\u27e829\u27e9 https://docs.rs/axum/latest/axum/#sharing-state-with-handlers: \u00a7\n\u27e830\u27e9 https://docs.rs/axum/latest/axum/extract/struct.State.html: struct axum::extract::State - `State`\n\u27e831\u27e9 https://docs.rs/axum/latest/axum/#using-the-state-extractor: \u00a7\n\u27e832\u27e9 https://docs.rs/axum/latest/axum/#using-request-extensions: \u00a7\n\u27e833\u27e9 https://docs.rs/axum/latest/axum/struct.Extension.html: struct axum::Extension - `Extension`\n\u27e834\u27e9 https://docs.rs/axum/latest/axum/#using-closure-captures: \u00a7\n\u27e835\u27e9 https://docs.rs/axum/latest/axum/#using-task-local-variables: \u00a7\n\u27e836\u27e9 https://docs.rs/tokio/1/tokio/macro.task_local.html: tokio\u2019s `task_local` macro\n\u27e837\u27e9 https://github.com/smol-rs/async-executor/issues/139: this GitHub issue\n\u27e838\u27e9 https://docs.rs/axum/latest/axum/#building-integrations-for-axum: \u00a7\n\u27e839\u27e9 http://crates.io/crates/axum-core: `axum-core`\n\u27e840\u27e9 https://docs.rs/axum/latest/axum/#required-dependencies: \u00a7\n\u27e841\u27e9 https://docs.rs/axum/latest/axum/#examples: \u00a7\n\u27e842\u27e9 https://github.com/tokio-rs/axum/tree/main/examples: a number of examples\n\u27e843\u27e9 https://docs.rs/axum/latest/axum/#feature-flags: \u00a7\n\u27e844\u27e9 https://doc.rust-lang.org/cargo/reference/features.html#the-features-section: feature flags\n\u27e845\u27e9 https://docs.rs/axum/latest/axum/struct.Json.html: struct axum::Json - `Json`\n\u27e846\u27e9 https://docs.rs/axum/latest/axum/extract/struct.MatchedPath.html: struct axum::extract::MatchedPath - `MatchedPath`\n\u27e847\u27e9 https://docs.rs/axum/latest/axum/extract/struct.Multipart.html: struct axum::extract::Multipart - `Multipart`\n\u27e848\u27e9 https://docs.rs/axum/latest/axum/extract/struct.OriginalUri.html: struct axum::extract::OriginalUri - `OriginalUri`\n\u27e849\u27e9 https://docs.rs/axum/latest/axum/extract/ws/index.html: mod axum::extract::ws - `extract::ws`\n\u27e850\u27e9 https://docs.rs/axum/latest/axum/#reexports: \u00a7\n\u27e851\u27e9 https://docs.rs/axum/latest/axum/#modules: \u00a7\n\u27e852\u27e9 https://docs.rs/axum/latest/axum/body/index.html: mod axum::body - body\n\u27e853\u27e9 https://docs.rs/axum/latest/axum/routing/index.html: mod axum::routing - routing\n\u27e854\u27e9 https://docs.rs/axum/latest/axum/serve/index.html: mod axum::serve - serve\n\u27e855\u27e9 https://docs.rs/axum/latest/axum/test_helpers/index.html: mod axum::test_helpers - test_helpers\n\u27e856\u27e9 https://docs.rs/axum/latest/axum/#structs: \u00a7\n\u27e857\u27e9 https://docs.rs/axum/latest/axum/struct.Error.html: struct axum::Error - Error\n\u27e858\u27e9 https://docs.rs/axum/latest/axum/struct.Form.html: struct axum::Form - Form\n\u27e859\u27e9 https://docs.rs/axum/latest/axum/#traits: \u00a7\n\u27e860\u27e9 https://docs.rs/axum/latest/axum/trait.RequestExt.html: trait axum::RequestExt - RequestExt\n\u27e861\u27e9 https://docs.rs/axum/latest/axum/extract/type.Request.html: type axum::extract::Request - `Request`\n\u27e862\u27e9 https://docs.rs/axum/latest/axum/trait.RequestPartsExt.html: trait axum::RequestPartsExt - RequestPartsExt\n\u27e863\u27e9 https://docs.rs/http/1.3.1/x86_64-unknown-linux-gnu/http/request/struct.Parts.html: struct http::request::Parts - `Parts`\n\u27e864\u27e9 https://docs.rs/axum/latest/axum/trait.ServiceExt.html: trait axum::ServiceExt - ServiceExt\n\u27e865\u27e9 https://docs.rs/axum/latest/axum/#functions: \u00a7\n\u27e866\u27e9 https://docs.rs/axum/latest/axum/fn.serve.html: fn axum::serve - serve\n\u27e867\u27e9 https://docs.rs/axum/latest/axum/#types: \u00a7\n\u27e868\u27e9 https://docs.rs/axum/latest/axum/type.BoxError.html: type axum::BoxError - BoxError\n\u27e869\u27e9 https://docs.rs/axum/latest/axum/#attributes: \u00a7\n\u27e870\u27e9 https://docs.rs/axum/latest/axum/attr.debug_handler.html: attr axum::debug_handler - debug_handler\n\u27e871\u27e9 https://docs.rs/axum/latest/axum/attr.debug_middleware.html: attr axum::debug_middleware - debug_middleware\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `axum` crate is a modular and ergonomic web application framework for building HTTP services in Rust. It features a macro-free API for routing, declarative request parsing via extractors, predictable error handling, and minimal boilerplate for generating responses. Leveraging the `tower` ecosystem, it supports middleware like timeouts, tracing, and compression, and integrates seamlessly with `tokio` and `hyper`.",
    "feature_summary": null,
    "use_case": "Web Framework",
    "score": 8.5,
    "factual_counterfactual": "### Pair 1: Routing and Handlers  \n\u2705 Factual: Axum allows routing requests to handlers using a macro-free API, making it simple to define routes declaratively with the `Router` type.  \n\u274c Counterfactual: Axum requires macros to define routes and handlers, making it harder to set up routing without additional dependencies.  \n\n---\n\n### Pair 2: Middleware Integration  \n\u2705 Factual: Axum leverages the `tower::Service` trait for middleware, enabling features like timeouts, tracing, and compression without requiring a custom middleware system.  \n\u274c Counterfactual: Axum provides its own middleware system independent of `tower`, which limits compatibility with other frameworks like `hyper` or `tonic`.  \n\n---\n\n### Pair 3: Dependency Requirements  \n\u2705 Factual: Axum requires `tokio` with the `\"full\"` feature enabled for its runtime, but `tower` is optional and primarily useful for testing.  \n\u274c Counterfactual: Axum can function independently of `tokio` and does not require any runtime-specific dependencies for basic usage.",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}