{
    "name": "ureq",
    "version": "3.0.12",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/ureq/latest/ureq/all.html \"show sidebar\")\n# Crate ureqCopy item path\n[Settings](https://docs.rs/ureq/latest/settings.html)\n[Help](https://docs.rs/ureq/latest/help.html)\nSummary[Source](https://docs.rs/ureq/latest/src/ureq/lib.rs.html#1-1260)\nExpand description\n[ ![Crates.io version](https://img.shields.io/crates/v/ureq.svg?style=flat-square) ](https://crates.io/crates/ureq) [ ![docs.rs docs](https://img.shields.io/badge/docs-latest-blue.svg?style=flat-square) ](https://docs.rs/ureq) [ ![Crates.io downloads](https://img.shields.io/crates/d/ureq.svg?style=flat-square) ](https://crates.io/crates/ureq)\nA simple, safe HTTP client.\nUreq\u2019s first priority is being easy for you to use. It\u2019s great for anyone who wants a low-overhead HTTP client that just gets the job done. Works very well with HTTP APIs. Its features include cookies, JSON, HTTP proxies, HTTPS, charset decoding, and is based on the API of the `http` crate.\nUreq is in pure Rust for safety and ease of understanding. It avoids using `unsafe` directly. It uses blocking I/O instead of async I/O, because that keeps the API simple and keeps dependencies to a minimum. For TLS, ureq uses rustls or native-tls.\nSee the [changelog](https://github.com/algesten/ureq/blob/main/CHANGELOG.md) for details of recent releases.\n## [\u00a7](https://docs.rs/ureq/latest/ureq/#usage)Usage\nIn its simplest form, ureq looks like this:\n```\nlet body: String = ureq::get(\"http://example.com\")\n  .header(\"Example-Header\", \"header value\")\n  .call()?\n  .body_mut()\n  .read_to_string()?;\n```\n\nFor more involved tasks, you\u2019ll want to create an [`Agent`](https://docs.rs/ureq/3.0.0-rc4/ureq/struct.Agent.html). An Agent holds a connection pool for reuse, and a cookie store if you use the **cookies** feature. An Agent can be cheaply cloned due to internal [`Arc`](https://doc.rust-lang.org/std/sync/struct.Arc.html) and all clones of an Agent share state among each other. Creating an Agent also allows setting options like the TLS configuration.\n```\nuse ureq::Agent;\nuse std::time::Duration;\nlet mut config = Agent::config_builder()\n  .timeout_global(Some(Duration::from_secs(5)))\n  .build();\nlet agent: Agent = config.into();\nlet body: String = agent.get(\"http://example.com/page\")\n  .call()?\n  .body_mut()\n  .read_to_string()?;\n// Reuses the connection from previous request.\nlet response: String = agent.put(\"http://example.com/upload\")\n  .header(\"Authorization\", \"example-token\")\n  .send(\"some body data\")?\n  .body_mut()\n  .read_to_string()?;\n```\n\n### [\u00a7](https://docs.rs/ureq/latest/ureq/#json)JSON\nUreq supports sending and receiving json, if you enable the **json** feature:\n```\nuse serde::{Serialize, Deserialize};\n#[derive(Serialize)]\nstruct MySendBody {\n  thing: String,\n}\n#[derive(Deserialize)]\nstruct MyRecvBody {\n  other: String,\n}\nlet send_body = MySendBody { thing: \"yo\".to_string() };\n// Requires the `json` feature enabled.\nlet recv_body = ureq::post(\"http://example.com/post/ingest\")\n  .header(\"X-My-Header\", \"Secret\")\n  .send_json(&send_body)?\n  .body_mut()\n  .read_json::<MyRecvBody>()?;\n```\n\n### [\u00a7](https://docs.rs/ureq/latest/ureq/#error-handling)Error handling\nureq returns errors via `Result<T, ureq::Error>`. That includes I/O errors, protocol errors. By default, also HTTP status code errors (when the server responded 4xx or 5xx) results in [`Error`](https://docs.rs/ureq/3.0.0-rc4/ureq/enum.Error.html).\nThis behavior can be turned off via [`http_status_as_error()`](https://docs.rs/ureq/3.0.0-rc4/ureq/config/struct.ConfigBuilder.html#method.http_status_as_error)\n```\nuse ureq::Error;\nmatch ureq::get(\"http://mypage.example.com/\").call() {\n  Ok(response) => { /* it worked */},\n  Err(Error::StatusCode(code)) => {\n    /* the server returned an unexpected status\n      code (such as 400, 500 etc) */\n  }\n  Err(_) => { /* some kind of io/transport/etc error */ }\n}\n```\n\n## [\u00a7](https://docs.rs/ureq/latest/ureq/#features)Features\nTo enable a minimal dependency tree, some features are off by default. You can control them when including ureq as a dependency.\n`ureq = { version = \"3\", features = [\"socks-proxy\", \"charset\"] }`\nThe default enabled features are: **rustls** and **gzip**.\n  * **rustls** enables the rustls TLS implementation. This is the default for the the crate level convenience calls (`ureq::get` etc). It currently uses `ring` as the TLS provider.\n  * **native-tls** enables the native tls backend for TLS. Due to the risk of diamond dependencies accidentally switching on an unwanted TLS implementation, `native-tls` is never picked up as a default or used by the crate level convenience calls (`ureq::get` etc) \u2013 it must be configured on the agent\n  * **platform-verifier** enables verifying the server certificates using a method native to the platform ureq is executing on. See [rustls-platform-verifier](https://crates.io/crates/rustls-platform-verifier) crate\n  * **socks-proxy** enables proxy config using the `socks4://`, `socks4a://`, `socks5://` and `socks://` (equal to `socks5://`) prefix\n  * **cookies** enables cookies\n  * **gzip** enables requests of gzip-compressed responses and decompresses them\n  * **brotli** enables requests brotli-compressed responses and decompresses them\n  * **charset** enables interpreting the charset part of the Content-Type header (e.g. `Content-Type: text/plain; charset=iso-8859-1`). Without this, the library defaults to Rust\u2019s built in `utf-8`\n  * **json** enables JSON sending and receiving via serde_json\n\n\n#### [\u00a7](https://docs.rs/ureq/latest/ureq/#unstable)Unstable\nThese features are unstable and might change in a minor version.\n  * **rustls-no-provider** Enables rustls, but does not enable any [`CryptoProvider`](https://docs.rs/rustls/latest/rustls/crypto/struct.CryptoProvider.html) such as `ring`. Providers other than the default (currently `ring`) are never picked up from feature flags alone. It must be configured on the agent.\n  * **vendored** compiles and statically links to a copy of non-Rust vendors (e.g. OpenSSL from `native-tls`)\n\n\n## [\u00a7](https://docs.rs/ureq/latest/ureq/#tls-https)TLS (https)\n### [\u00a7](https://docs.rs/ureq/latest/ureq/#rustls)rustls\nBy default, ureq uses [`rustls` crate](https://crates.io/crates/rustls) with the `ring` cryptographic provider. As of Sep 2024, the `ring` provider has a higher chance of compiling successfully. If the user installs another process [default provider](https://docs.rs/rustls/latest/rustls/crypto/struct.CryptoProvider.html#method.install_default), that choice is respected.\nureq does not guarantee to default to ring indefinitely. `rustls` as a feature flag will always work, but the specific crypto backend might change in a minor version.\n```\n// This uses rustls\nureq::get(\"https://www.google.com/\").call().unwrap();\n```\n\n#### [\u00a7](https://docs.rs/ureq/latest/ureq/#rustls-without-ring)rustls without ring\nureq never changes TLS backend from feature flags alone. It is possible to compile ureq without ring, but it requires specific feature flags and configuring the [`Agent`](https://docs.rs/ureq/3.0.0-rc4/ureq/struct.Agent.html).\nSince rustls is not semver 1.x, this requires non-semver-guaranteed API. I.e. ureq might change this behavior without a major version bump.\nRead more at [`TlsConfigBuilder::unversioned_rustls_crypto_provider`](https://docs.rs/ureq/latest/ureq/tls/struct.TlsConfigBuilder.html#method.unversioned_rustls_crypto_provider \"method ureq::tls::TlsConfigBuilder::unversioned_rustls_crypto_provider\").\n### [\u00a7](https://docs.rs/ureq/latest/ureq/#native-tls)native-tls\nAs an alternative, ureq ships with [`native-tls`](https://crates.io/crates/native-tls) as a TLS provider. This must be enabled using the **native-tls** feature. Due to the risk of diamond dependencies accidentally switching on an unwanted TLS implementation, `native-tls` is never picked up as a default or used by the crate level convenience calls (`ureq::get` etc) \u2013 it must be configured on the agent.\n```\nuse ureq::config::Config;\nuse ureq::tls::{TlsConfig, TlsProvider};\nlet mut config = Config::builder()\n  .tls_config(\n    TlsConfig::builder()\n      // requires the native-tls feature\n      .provider(TlsProvider::NativeTls)\n      .build()\n  )\n  .build();\nlet agent = config.new_agent();\nagent.get(\"https://www.google.com/\").call().unwrap();\n```\n\n### [\u00a7](https://docs.rs/ureq/latest/ureq/#root-certificates)Root certificates\n#### [\u00a7](https://docs.rs/ureq/latest/ureq/#webpki-roots)webpki-roots\nBy default, ureq uses Mozilla\u2019s root certificates via the [webpki-roots](https://crates.io/crates/webpki-roots) crate. This is a static bundle of root certificates that do not update automatically. It also circumvents whatever root certificates are installed on the host running ureq, which might be a good or a bad thing depending on your perspective. There is also no mechanism for [SCT](https://en.wikipedia.org/wiki/Certificate_Transparency), [CRL](https://en.wikipedia.org/wiki/Certificate_revocation_list)s or other revocations. To maintain a \u201cfresh\u201d list of root certs, you need to bump the ureq dependency from time to time.\nThe main reason for chosing this as the default is to minimize the number of dependencies. More details about this decision can be found at [PR 818].\nIf your use case for ureq is talking to a limited number of servers with high trust, the default setting is likely sufficient. If you use ureq with a high number of servers, or servers you don\u2019t trust, we recommend using the platform verifier (see below).\n#### [\u00a7](https://docs.rs/ureq/latest/ureq/#platform-verifier)platform-verifier\nThe [rustls-platform-verifier](https://crates.io/crates/rustls-platform-verifier) crate provides access to natively checking the certificate via your OS. To use this verifier, you need to enable it using feature flag **platform-verifier** as well as configure an agent to use it.\n```\nuse ureq::Agent;\nuse ureq::tls::{TlsConfig, RootCerts};\nlet agent = Agent::config_builder()\n  .tls_config(\n    TlsConfig::builder()\n      .root_certs(RootCerts::PlatformVerifier)\n      .build()\n  )\n  .build()\n  .new_agent();\nlet response = agent.get(\"https://httpbin.org/get\").call()?;\n```\n\nSetting `RootCerts::PlatformVerifier` together with `TlsProvider::NativeTls` means also native-tls will use the OS roots instead of [webpki-roots](https://crates.io/crates/webpki-roots) crate. Whether that results in a config that has CRLs and revocations is up to whatever native-tls links to.\n## [\u00a7](https://docs.rs/ureq/latest/ureq/#json-1)JSON\nBy enabling the **json** feature, the library supports serde json.\nThis is enabled by default.\n  * [`request.send_json()`](https://docs.rs/ureq/3.0.0-rc4/ureq/struct.RequestBuilder.html#method.send_json) send body as json.\n  * [`body.read_json()`](https://docs.rs/ureq/3.0.0-rc4/ureq/struct.Body.html#method.read_json) transform response to json.\n\n\n## [\u00a7](https://docs.rs/ureq/latest/ureq/#sending-body-data)Sending body data\nHTTP/1.1 has two ways of transfering body data. Either of a known size with the `Content-Length` HTTP header, or unknown size with the `Transfer-Encoding: chunked` header. ureq supports both and will use the appropriate method depending on which body is being sent.\nureq has a [`AsSendBody`](https://docs.rs/ureq/3.0.0-rc4/ureq/trait.AsSendBody.html) trait that is implemented for many well known types of data that we might want to send. The request body can thus be anything from a `String` to a `File`, see below.\n### [\u00a7](https://docs.rs/ureq/latest/ureq/#content-length)Content-Length\nThe library will send a `Content-Length` header on requests with bodies of known size, in other words, if the body to send is one of:\n  * `&[u8]`\n  * `&[u8; N]`\n  * `&str`\n  * `String`\n  * `&String`\n  * `Vec<u8>`\n  * `&Vec<u8>)`\n  * [`SendBody::from_json()`](https://docs.rs/ureq/3.0.0-rc4/ureq/struct.SendBody.html#method.from_json) (implicitly via [`request.send_json()`](https://docs.rs/ureq/3.0.0-rc4/ureq/struct.RequestBuilder.html#method.send_json))\n\n\n### [\u00a7](https://docs.rs/ureq/latest/ureq/#transfer-encoding-chunked)Transfer-Encoding: chunked\nureq will send a `Transfer-Encoding: chunked` header on requests where the body is of unknown size. The body is automatically converted to an [`std::io::Read`](https://doc.rust-lang.org/std/io/trait.Read.html) when the type is one of:\n  * `File`\n  * `&File`\n  * `TcpStream`\n  * `&TcpStream`\n  * `Stdin`\n  * `UnixStream` (not on windows)\n\n\n#### [\u00a7](https://docs.rs/ureq/latest/ureq/#from-readers)From readers\nThe chunked method also applies for bodies constructed via:\n  * [`SendBody::from_reader()`](https://docs.rs/ureq/3.0.0-rc4/ureq/struct.SendBody.html#method.from_reader)\n  * [`SendBody::from_owned_reader()`](https://docs.rs/ureq/3.0.0-rc4/ureq/struct.SendBody.html#method.from_owned_reader)\n\n\n### [\u00a7](https://docs.rs/ureq/latest/ureq/#proxying-a-response-body)Proxying a response body\nAs a special case, when ureq sends a [`Body`](https://docs.rs/ureq/3.0.0-rc4/ureq/struct.Body.html) from a previous http call, the use of `Content-Length` or `chunked` depends on situation. For input such as gzip decoding (**gzip** feature) or charset transformation (**charset** feature), the output body might not match the input, which means ureq is forced to use the `chunked` method.\n  * `Response<Body>`\n\n\n### [\u00a7](https://docs.rs/ureq/latest/ureq/#sending-form-data)Sending form data\n[`request.send_form()`](https://docs.rs/ureq/3.0.0-rc4/ureq/struct.RequestBuilder.html#method.send_form) provides a way to send `application/x-www-form-urlencoded` encoded data. The key/values provided will be URL encoded.\n### [\u00a7](https://docs.rs/ureq/latest/ureq/#overriding)Overriding\nIf you set your own Content-Length or Transfer-Encoding header before sending the body, ureq will respect that header by not overriding it, and by encoding the body or not, as indicated by the headers you set.\n```\nlet resp = ureq::put(\"https://httpbin.org/put\")\n  .header(\"Transfer-Encoding\", \"chunked\")\n  .send(\"Hello world\")?;\n```\n\n## [\u00a7](https://docs.rs/ureq/latest/ureq/#character-encoding)Character encoding\nBy enabling the **charset** feature, the library supports receiving other character sets than `utf-8`.\nFor [`Body::read_to_string()`](https://docs.rs/ureq/3.0.0-rc4/ureq/struct.Body.html#method.read_to_string) we read the header like:\n`Content-Type: text/plain; charset=iso-8859-1`\nand if it contains a charset specification, we try to decode the body using that encoding. In the absence of, or failing to interpret the charset, we fall back on `utf-8`.\nCurrently ureq does not provide a way to encode when sending request bodies.\n### [\u00a7](https://docs.rs/ureq/latest/ureq/#lossy-utf-8)Lossy utf-8\nWhen reading text bodies (with a `Content-Type` starting `text/` as in `text/plain`, `text/html`, etc), ureq can ensure the body is possible to read as a `String` also if it contains characters that are not valid for utf-8. Invalid characters are replaced with a question mark `?` (NOT the utf-8 replacement character).\nFor [`Body::read_to_string()`](https://docs.rs/ureq/3.0.0-rc4/ureq/struct.Body.html#method.read_to_string) this is turned on by default, but it can be disabled and conversely for [`Body::as_reader()`](https://docs.rs/ureq/3.0.0-rc4/ureq/struct.Body.html#method.as_reader) it is not enabled, but can be.\nTo precisely configure the behavior use [`Body::with_config()`](https://docs.rs/ureq/3.0.0-rc4/ureq/struct.Body.html#method.with_config).\n## [\u00a7](https://docs.rs/ureq/latest/ureq/#proxying)Proxying\nureq supports two kinds of proxies, [`HTTP`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Proxy_servers_and_tunneling#http_tunneling) ([`CONNECT`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/CONNECT)), [`SOCKS4`](https://en.wikipedia.org/wiki/SOCKS#SOCKS4)/[`SOCKS5`](https://en.wikipedia.org/wiki/SOCKS#SOCKS5), the former is always available while the latter must be enabled using the feature **socks-proxy**.\nProxies settings are configured on an [`Agent`](https://docs.rs/ureq/3.0.0-rc4/ureq/struct.Agent.html). All request sent through the agent will be proxied.\n### [\u00a7](https://docs.rs/ureq/latest/ureq/#example-using-http)Example using HTTP\n```\nuse ureq::{Agent, Proxy};\n// Configure an http connect proxy.\nlet proxy = Proxy::new(\"http://user:password@cool.proxy:9090\")?;\nlet agent: Agent = Agent::config_builder()\n  .proxy(Some(proxy))\n  .build()\n  .into();\n// This is proxied.\nlet resp = agent.get(\"http://cool.server\").call()?;\n```\n\n### [\u00a7](https://docs.rs/ureq/latest/ureq/#example-using-socks5)Example using SOCKS5\n```\nuse ureq::{Agent, Proxy};\n// Configure a SOCKS proxy.\nlet proxy = Proxy::new(\"socks5://user:password@cool.proxy:9090\")?;\nlet agent: Agent = Agent::config_builder()\n  .proxy(Some(proxy))\n  .build()\n  .into();\n// This is proxied.\nlet resp = agent.get(\"http://cool.server\").call()?;\n```\n\n## [\u00a7](https://docs.rs/ureq/latest/ureq/#log-levels)Log levels\nureq uses the log crate. These are the definitions of the log levels, however we do not guarantee anything for dependencies such as `http` and `rustls`.\n  * `ERROR` - nothing\n  * `WARN` - if we detect a user configuration problem.\n  * `INFO` - nothing\n  * `DEBUG` - uri, state changes, transport, resolver and selected request/response headers\n  * `TRACE` - wire level debug. NOT REDACTED!\n\n\nThe request/response headers on DEBUG levels are allow-listed to only include headers that are considered safe. The code has the [allow list](https://github.com/algesten/ureq/blob/81127cfc38516903330dc1b9c618122372f8dc29/src/util.rs#L184-L198).\n## [\u00a7](https://docs.rs/ureq/latest/ureq/#versioning)Versioning\n### [\u00a7](https://docs.rs/ureq/latest/ureq/#semver-and-unversioned)Semver and `unversioned`\nureq follows semver. From ureq 3.x we strive to have a much closer adherence to semver than 2.x. The main mistake in 2.x was to re-export crates that were not yet semver 1.0. In ureq 3.x TLS and cookie configuration is shimmed using our own types.\nureq 3.x is trying out two new traits that had no equivalent in 2.x, [`Transport`](https://docs.rs/ureq/3.0.0-rc4/ureq/unversioned/transport/trait.Transport.html) and [`Resolver`](https://docs.rs/ureq/3.0.0-rc4/ureq/unversioned/resolver/trait.Resolver.html). These allow the user write their own bespoke transports and (DNS name) resolver. The API:s for these parts are not yet solidified. They live under the [`unversioned`](https://docs.rs/ureq/3.0.0-rc4/ureq/unversioned/index.html) module, and do not follow semver. See module doc for more info.\n### [\u00a7](https://docs.rs/ureq/latest/ureq/#breaking-changes-in-dependencies)Breaking changes in dependencies\nureq relies on non-semver 1.x crates such as `rustls` and `native-tls`. Some scenarios, such as configuring `rustls` to not use `ring`, a user of ureq might need to interact with these crates directly instead of going via ureq\u2019s provided API.\nSuch changes can break when ureq updates dependencies. This is not considered a breaking change for ureq and will not be reflected by a major version bump.\nWe strive to mark ureq\u2019s API with the word \u201cunversioned\u201d to identify places where this risk arises.\n### [\u00a7](https://docs.rs/ureq/latest/ureq/#minimum-supported-rust-version-msrv)Minimum Supported Rust Version (MSRV)\nFrom time to time we will need to update our minimum supported Rust version (MSRV). This is not something we do lightly; our ambition is to be as conservative with MSRV as possible.\n  * For some dependencies, we will opt for pinning the version of the dep instead of bumping our MSRV.\n  * For important dependencies, like the TLS libraries, we cannot hold back our MSRV if they change.\n  * We do not consider MSRV changes to be breaking for the purposes of semver.\n  * We will not make MSRV changes in patch releases.\n  * MSRV changes will get their own minor release, and not be co-mingled with other changes.\n\n\n## Re-exports[\u00a7](https://docs.rs/ureq/latest/ureq/#reexports)\n\n`pub use ureq_proto::http[](https://docs.rs/http/1.3.1/x86_64-unknown-linux-gnu/http/index.html \"mod http\");`\n\n## Modules[\u00a7](https://docs.rs/ureq/latest/ureq/#modules)\n\n[config](https://docs.rs/ureq/latest/ureq/config/index.html \"mod ureq::config\")\n    Agent configuration\n\n[middleware](https://docs.rs/ureq/latest/ureq/middleware/index.html \"mod ureq::middleware\")\n    Chained interception to modify the request or response.\n\n[tls](https://docs.rs/ureq/latest/ureq/tls/index.html \"mod ureq::tls\")\n    TLS for handling `https`.\n\n[typestate](https://docs.rs/ureq/latest/ureq/typestate/index.html \"mod ureq::typestate\")\n    Typestate variables.\n\n[unversioned](https://docs.rs/ureq/latest/ureq/unversioned/index.html \"mod ureq::unversioned\")\n    API that does not (yet) follow semver.\n## Structs[\u00a7](https://docs.rs/ureq/latest/ureq/#structs)\n\n[Agent](https://docs.rs/ureq/latest/ureq/struct.Agent.html \"struct ureq::Agent\")\n    Agents keep state between requests.\n\n[Body](https://docs.rs/ureq/latest/ureq/struct.Body.html \"struct ureq::Body\")\n    A response body returned as [`http::Response<Body>`](https://docs.rs/http/1.3.1/x86_64-unknown-linux-gnu/http/response/struct.Response.html \"struct http::response::Response\").\n\n[BodyBuilder](https://docs.rs/ureq/latest/ureq/struct.BodyBuilder.html \"struct ureq::BodyBuilder\")\n    Builder for creating a response body.\n\n[BodyReader](https://docs.rs/ureq/latest/ureq/struct.BodyReader.html \"struct ureq::BodyReader\")\n    A reader of the response data.\n\n[BodyWithConfig](https://docs.rs/ureq/latest/ureq/struct.BodyWithConfig.html \"struct ureq::BodyWithConfig\")\n    Configuration of how to read the body.\n\n[Cookie](https://docs.rs/ureq/latest/ureq/struct.Cookie.html \"struct ureq::Cookie\")\n    Representation of an HTTP cookie.\n\n[CookieJar](https://docs.rs/ureq/latest/ureq/struct.CookieJar.html \"struct ureq::CookieJar\")\n    Collection of cookies.\n\n[Proxy](https://docs.rs/ureq/latest/ureq/struct.Proxy.html \"struct ureq::Proxy\")\n    Proxy server settings\n\n[ProxyBuilder](https://docs.rs/ureq/latest/ureq/struct.ProxyBuilder.html \"struct ureq::ProxyBuilder\")\n    Builder for configuring a proxy.\n\n[RequestBuilder](https://docs.rs/ureq/latest/ureq/struct.RequestBuilder.html \"struct ureq::RequestBuilder\")\n    Transparent wrapper around [`http::request::Builder`](https://docs.rs/http/1.3.1/x86_64-unknown-linux-gnu/http/request/struct.Builder.html \"struct http::request::Builder\").\n\n[SendBody](https://docs.rs/ureq/latest/ureq/struct.SendBody.html \"struct ureq::SendBody\")\n    Request body for sending data via POST, PUT and PATCH.\n## Enums[\u00a7](https://docs.rs/ureq/latest/ureq/#enums)\n\n[Error](https://docs.rs/ureq/latest/ureq/enum.Error.html \"enum ureq::Error\")\n    Errors from ureq.\n\n[ProxyProtocol](https://docs.rs/ureq/latest/ureq/enum.ProxyProtocol.html \"enum ureq::ProxyProtocol\")\n    Proxy protocol\n\n[Timeout](https://docs.rs/ureq/latest/ureq/enum.Timeout.html \"enum ureq::Timeout\")\n    The various timeouts.\n## Traits[\u00a7](https://docs.rs/ureq/latest/ureq/#traits)\n\n[AsSendBody](https://docs.rs/ureq/latest/ureq/trait.AsSendBody.html \"trait ureq::AsSendBody\")\n    Trait for common types to send in POST, PUT or PATCH.\n\n[RequestExt](https://docs.rs/ureq/latest/ureq/trait.RequestExt.html \"trait ureq::RequestExt\")\n    Extension trait for [`http::Request<impl AsSendBody>`](https://docs.rs/http/1.3.1/x86_64-unknown-linux-gnu/http/request/struct.Request.html \"struct http::request::Request\").\n\n[ResponseExt](https://docs.rs/ureq/latest/ureq/trait.ResponseExt.html \"trait ureq::ResponseExt\")\n    Extension trait for [`http::Response<Body>`](https://docs.rs/http/1.3.1/x86_64-unknown-linux-gnu/http/response/struct.Response.html \"struct http::response::Response\").\n## Functions[\u00a7](https://docs.rs/ureq/latest/ureq/#functions)\n\n[agent](https://docs.rs/ureq/latest/ureq/fn.agent.html \"fn ureq::agent\")\n    A new [Agent](https://docs.rs/ureq/latest/ureq/struct.Agent.html \"struct ureq::Agent\") with default configuration\n\n[connect](https://docs.rs/ureq/latest/ureq/fn.connect.html \"fn ureq::connect\")\n    Make a CONNECT request.\n\n[delete](https://docs.rs/ureq/latest/ureq/fn.delete.html \"fn ureq::delete\")\n    Make a DELETE request.\n\n[get](https://docs.rs/ureq/latest/ureq/fn.get.html \"fn ureq::get\")\n    Make a GET request.\n\n[head](https://docs.rs/ureq/latest/ureq/fn.head.html \"fn ureq::head\")\n    Make a HEAD request.\n\n[options](https://docs.rs/ureq/latest/ureq/fn.options.html \"fn ureq::options\")\n    Make an OPTIONS request.\n\n[patch](https://docs.rs/ureq/latest/ureq/fn.patch.html \"fn ureq::patch\")\n    Make a PATCH request.\n\n[post](https://docs.rs/ureq/latest/ureq/fn.post.html \"fn ureq::post\")\n    Make a POST request.\n\n[put](https://docs.rs/ureq/latest/ureq/fn.put.html \"fn ureq::put\")\n    Make a PUT request.\n\n[run](https://docs.rs/ureq/latest/ureq/fn.run.html \"fn ureq::run\")\n    Run a [`http::Request<impl AsSendBody>`](https://docs.rs/http/1.3.1/x86_64-unknown-linux-gnu/http/request/struct.Request.html \"struct http::request::Request\").\n\n[trace](https://docs.rs/ureq/latest/ureq/fn.trace.html \"fn ureq::trace\")\n    Make a TRACE request.\n",
        "markdown_with_citations": "[](https://docs.rs/ureq/latest/ureq/all.html \"show sidebar\")\n# Crate ureqCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\n ![Crates.io version\u27e84\u27e9 ](https://crates.io/crates/ureq)  ![docs.rs docs\u27e85\u27e9 ](https://docs.rs/ureq)  ![Crates.io downloads\u27e86\u27e9 ](https://crates.io/crates/ureq)\nA simple, safe HTTP client.\nUreq\u2019s first priority is being easy for you to use. It\u2019s great for anyone who wants a low-overhead HTTP client that just gets the job done. Works very well with HTTP APIs. Its features include cookies, JSON, HTTP proxies, HTTPS, charset decoding, and is based on the API of the `http` crate.\nUreq is in pure Rust for safety and ease of understanding. It avoids using `unsafe` directly. It uses blocking I/O instead of async I/O, because that keeps the API simple and keeps dependencies to a minimum. For TLS, ureq uses rustls or native-tls.\nSee the changelog\u27e87\u27e9 for details of recent releases.\n## \u00a7\u27e88\u27e9Usage\nIn its simplest form, ureq looks like this:\n```\nlet body: String = ureq::get(\"http://example.com\")\n  .header(\"Example-Header\", \"header value\")\n  .call()?\n  .body_mut()\n  .read_to_string()?;\n```\n\nFor more involved tasks, you\u2019ll want to create an `Agent`\u27e89\u27e9. An Agent holds a connection pool for reuse, and a cookie store if you use the **cookies** feature. An Agent can be cheaply cloned due to internal `Arc`\u27e810\u27e9 and all clones of an Agent share state among each other. Creating an Agent also allows setting options like the TLS configuration.\n```\nuse ureq::Agent;\nuse std::time::Duration;\nlet mut config = Agent::config_builder()\n  .timeout_global(Some(Duration::from_secs(5)))\n  .build();\nlet agent: Agent = config.into();\nlet body: String = agent.get(\"http://example.com/page\")\n  .call()?\n  .body_mut()\n  .read_to_string()?;\n// Reuses the connection from previous request.\nlet response: String = agent.put(\"http://example.com/upload\")\n  .header(\"Authorization\", \"example-token\")\n  .send(\"some body data\")?\n  .body_mut()\n  .read_to_string()?;\n```\n\n### \u00a7\u27e811\u27e9JSON\nUreq supports sending and receiving json, if you enable the **json** feature:\n```\nuse serde::{Serialize, Deserialize};\n#[derive(Serialize)]\nstruct MySendBody {\n  thing: String,\n}\n#[derive(Deserialize)]\nstruct MyRecvBody {\n  other: String,\n}\nlet send_body = MySendBody { thing: \"yo\".to_string() };\n// Requires the `json` feature enabled.\nlet recv_body = ureq::post(\"http://example.com/post/ingest\")\n  .header(\"X-My-Header\", \"Secret\")\n  .send_json(&send_body)?\n  .body_mut()\n  .read_json::<MyRecvBody>()?;\n```\n\n### \u00a7\u27e812\u27e9Error handling\nureq returns errors via `Result<T, ureq::Error>`. That includes I/O errors, protocol errors. By default, also HTTP status code errors (when the server responded 4xx or 5xx) results in `Error`\u27e813\u27e9.\nThis behavior can be turned off via `http_status_as_error()`\u27e814\u27e9\n```\nuse ureq::Error;\nmatch ureq::get(\"http://mypage.example.com/\").call() {\n  Ok(response) => { /* it worked */},\n  Err(Error::StatusCode(code)) => {\n    /* the server returned an unexpected status\n      code (such as 400, 500 etc) */\n  }\n  Err(_) => { /* some kind of io/transport/etc error */ }\n}\n```\n\n## \u00a7\u27e815\u27e9Features\nTo enable a minimal dependency tree, some features are off by default. You can control them when including ureq as a dependency.\n`ureq = { version = \"3\", features = [\"socks-proxy\", \"charset\"] }`\nThe default enabled features are: **rustls** and **gzip**.\n  * **rustls** enables the rustls TLS implementation. This is the default for the the crate level convenience calls (`ureq::get` etc). It currently uses `ring` as the TLS provider.\n  * **native-tls** enables the native tls backend for TLS. Due to the risk of diamond dependencies accidentally switching on an unwanted TLS implementation, `native-tls` is never picked up as a default or used by the crate level convenience calls (`ureq::get` etc) \u2013 it must be configured on the agent\n  * **platform-verifier** enables verifying the server certificates using a method native to the platform ureq is executing on. See rustls-platform-verifier\u27e816\u27e9 crate\n  * **socks-proxy** enables proxy config using the `socks4://`, `socks4a://`, `socks5://` and `socks://` (equal to `socks5://`) prefix\n  * **cookies** enables cookies\n  * **gzip** enables requests of gzip-compressed responses and decompresses them\n  * **brotli** enables requests brotli-compressed responses and decompresses them\n  * **charset** enables interpreting the charset part of the Content-Type header (e.g. `Content-Type: text/plain; charset=iso-8859-1`). Without this, the library defaults to Rust\u2019s built in `utf-8`\n  * **json** enables JSON sending and receiving via serde_json\n\n\n#### \u00a7\u27e817\u27e9Unstable\nThese features are unstable and might change in a minor version.\n  * **rustls-no-provider** Enables rustls, but does not enable any `CryptoProvider`\u27e818\u27e9 such as `ring`. Providers other than the default (currently `ring`) are never picked up from feature flags alone. It must be configured on the agent.\n  * **vendored** compiles and statically links to a copy of non-Rust vendors (e.g. OpenSSL from `native-tls`)\n\n\n## \u00a7\u27e819\u27e9TLS (https)\n### \u00a7\u27e820\u27e9rustls\nBy default, ureq uses `rustls` crate\u27e821\u27e9 with the `ring` cryptographic provider. As of Sep 2024, the `ring` provider has a higher chance of compiling successfully. If the user installs another process default provider\u27e822\u27e9, that choice is respected.\nureq does not guarantee to default to ring indefinitely. `rustls` as a feature flag will always work, but the specific crypto backend might change in a minor version.\n```\n// This uses rustls\nureq::get(\"https://www.google.com/\").call().unwrap();\n```\n\n#### \u00a7\u27e823\u27e9rustls without ring\nureq never changes TLS backend from feature flags alone. It is possible to compile ureq without ring, but it requires specific feature flags and configuring the `Agent`\u27e89\u27e9.\nSince rustls is not semver 1.x, this requires non-semver-guaranteed API. I.e. ureq might change this behavior without a major version bump.\nRead more at `TlsConfigBuilder::unversioned_rustls_crypto_provider`\u27e824\u27e9.\n### \u00a7\u27e825\u27e9native-tls\nAs an alternative, ureq ships with `native-tls`\u27e826\u27e9 as a TLS provider. This must be enabled using the **native-tls** feature. Due to the risk of diamond dependencies accidentally switching on an unwanted TLS implementation, `native-tls` is never picked up as a default or used by the crate level convenience calls (`ureq::get` etc) \u2013 it must be configured on the agent.\n```\nuse ureq::config::Config;\nuse ureq::tls::{TlsConfig, TlsProvider};\nlet mut config = Config::builder()\n  .tls_config(\n    TlsConfig::builder()\n      // requires the native-tls feature\n      .provider(TlsProvider::NativeTls)\n      .build()\n  )\n  .build();\nlet agent = config.new_agent();\nagent.get(\"https://www.google.com/\").call().unwrap();\n```\n\n### \u00a7\u27e827\u27e9Root certificates\n#### \u00a7\u27e828\u27e9webpki-roots\nBy default, ureq uses Mozilla\u2019s root certificates via the webpki-roots\u27e829\u27e9 crate. This is a static bundle of root certificates that do not update automatically. It also circumvents whatever root certificates are installed on the host running ureq, which might be a good or a bad thing depending on your perspective. There is also no mechanism for SCT\u27e830\u27e9, CRL\u27e831\u27e9s or other revocations. To maintain a \u201cfresh\u201d list of root certs, you need to bump the ureq dependency from time to time.\nThe main reason for chosing this as the default is to minimize the number of dependencies. More details about this decision can be found at [PR 818].\nIf your use case for ureq is talking to a limited number of servers with high trust, the default setting is likely sufficient. If you use ureq with a high number of servers, or servers you don\u2019t trust, we recommend using the platform verifier (see below).\n#### \u00a7\u27e832\u27e9platform-verifier\nThe rustls-platform-verifier\u27e816\u27e9 crate provides access to natively checking the certificate via your OS. To use this verifier, you need to enable it using feature flag **platform-verifier** as well as configure an agent to use it.\n```\nuse ureq::Agent;\nuse ureq::tls::{TlsConfig, RootCerts};\nlet agent = Agent::config_builder()\n  .tls_config(\n    TlsConfig::builder()\n      .root_certs(RootCerts::PlatformVerifier)\n      .build()\n  )\n  .build()\n  .new_agent();\nlet response = agent.get(\"https://httpbin.org/get\").call()?;\n```\n\nSetting `RootCerts::PlatformVerifier` together with `TlsProvider::NativeTls` means also native-tls will use the OS roots instead of webpki-roots\u27e829\u27e9 crate. Whether that results in a config that has CRLs and revocations is up to whatever native-tls links to.\n## \u00a7\u27e833\u27e9JSON\nBy enabling the **json** feature, the library supports serde json.\nThis is enabled by default.\n  * `request.send_json()`\u27e834\u27e9 send body as json.\n  * `body.read_json()`\u27e835\u27e9 transform response to json.\n\n\n## \u00a7\u27e836\u27e9Sending body data\nHTTP/1.1 has two ways of transfering body data. Either of a known size with the `Content-Length` HTTP header, or unknown size with the `Transfer-Encoding: chunked` header. ureq supports both and will use the appropriate method depending on which body is being sent.\nureq has a `AsSendBody`\u27e837\u27e9 trait that is implemented for many well known types of data that we might want to send. The request body can thus be anything from a `String` to a `File`, see below.\n### \u00a7\u27e838\u27e9Content-Length\nThe library will send a `Content-Length` header on requests with bodies of known size, in other words, if the body to send is one of:\n  * `&[u8]`\n  * `&[u8; N]`\n  * `&str`\n  * `String`\n  * `&String`\n  * `Vec<u8>`\n  * `&Vec<u8>)`\n  * `SendBody::from_json()`\u27e839\u27e9 (implicitly via `request.send_json()`\u27e834\u27e9)\n\n\n### \u00a7\u27e840\u27e9Transfer-Encoding: chunked\nureq will send a `Transfer-Encoding: chunked` header on requests where the body is of unknown size. The body is automatically converted to an `std::io::Read`\u27e841\u27e9 when the type is one of:\n  * `File`\n  * `&File`\n  * `TcpStream`\n  * `&TcpStream`\n  * `Stdin`\n  * `UnixStream` (not on windows)\n\n\n#### \u00a7\u27e842\u27e9From readers\nThe chunked method also applies for bodies constructed via:\n  * `SendBody::from_reader()`\u27e843\u27e9\n  * `SendBody::from_owned_reader()`\u27e844\u27e9\n\n\n### \u00a7\u27e845\u27e9Proxying a response body\nAs a special case, when ureq sends a `Body`\u27e846\u27e9 from a previous http call, the use of `Content-Length` or `chunked` depends on situation. For input such as gzip decoding (**gzip** feature) or charset transformation (**charset** feature), the output body might not match the input, which means ureq is forced to use the `chunked` method.\n  * `Response<Body>`\n\n\n### \u00a7\u27e847\u27e9Sending form data\n`request.send_form()`\u27e848\u27e9 provides a way to send `application/x-www-form-urlencoded` encoded data. The key/values provided will be URL encoded.\n### \u00a7\u27e849\u27e9Overriding\nIf you set your own Content-Length or Transfer-Encoding header before sending the body, ureq will respect that header by not overriding it, and by encoding the body or not, as indicated by the headers you set.\n```\nlet resp = ureq::put(\"https://httpbin.org/put\")\n  .header(\"Transfer-Encoding\", \"chunked\")\n  .send(\"Hello world\")?;\n```\n\n## \u00a7\u27e850\u27e9Character encoding\nBy enabling the **charset** feature, the library supports receiving other character sets than `utf-8`.\nFor `Body::read_to_string()`\u27e851\u27e9 we read the header like:\n`Content-Type: text/plain; charset=iso-8859-1`\nand if it contains a charset specification, we try to decode the body using that encoding. In the absence of, or failing to interpret the charset, we fall back on `utf-8`.\nCurrently ureq does not provide a way to encode when sending request bodies.\n### \u00a7\u27e852\u27e9Lossy utf-8\nWhen reading text bodies (with a `Content-Type` starting `text/` as in `text/plain`, `text/html`, etc), ureq can ensure the body is possible to read as a `String` also if it contains characters that are not valid for utf-8. Invalid characters are replaced with a question mark `?` (NOT the utf-8 replacement character).\nFor `Body::read_to_string()`\u27e851\u27e9 this is turned on by default, but it can be disabled and conversely for `Body::as_reader()`\u27e853\u27e9 it is not enabled, but can be.\nTo precisely configure the behavior use `Body::with_config()`\u27e854\u27e9.\n## \u00a7\u27e855\u27e9Proxying\nureq supports two kinds of proxies, `HTTP`\u27e856\u27e9 (`CONNECT`\u27e857\u27e9), `SOCKS4`\u27e858\u27e9/`SOCKS5`\u27e859\u27e9, the former is always available while the latter must be enabled using the feature **socks-proxy**.\nProxies settings are configured on an `Agent`\u27e89\u27e9. All request sent through the agent will be proxied.\n### \u00a7\u27e860\u27e9Example using HTTP\n```\nuse ureq::{Agent, Proxy};\n// Configure an http connect proxy.\nlet proxy = Proxy::new(\"http://user:password@cool.proxy:9090\")?;\nlet agent: Agent = Agent::config_builder()\n  .proxy(Some(proxy))\n  .build()\n  .into();\n// This is proxied.\nlet resp = agent.get(\"http://cool.server\").call()?;\n```\n\n### \u00a7\u27e861\u27e9Example using SOCKS5\n```\nuse ureq::{Agent, Proxy};\n// Configure a SOCKS proxy.\nlet proxy = Proxy::new(\"socks5://user:password@cool.proxy:9090\")?;\nlet agent: Agent = Agent::config_builder()\n  .proxy(Some(proxy))\n  .build()\n  .into();\n// This is proxied.\nlet resp = agent.get(\"http://cool.server\").call()?;\n```\n\n## \u00a7\u27e862\u27e9Log levels\nureq uses the log crate. These are the definitions of the log levels, however we do not guarantee anything for dependencies such as `http` and `rustls`.\n  * `ERROR` - nothing\n  * `WARN` - if we detect a user configuration problem.\n  * `INFO` - nothing\n  * `DEBUG` - uri, state changes, transport, resolver and selected request/response headers\n  * `TRACE` - wire level debug. NOT REDACTED!\n\n\nThe request/response headers on DEBUG levels are allow-listed to only include headers that are considered safe. The code has the allow list\u27e863\u27e9.\n## \u00a7\u27e864\u27e9Versioning\n### \u00a7\u27e865\u27e9Semver and `unversioned`\nureq follows semver. From ureq 3.x we strive to have a much closer adherence to semver than 2.x. The main mistake in 2.x was to re-export crates that were not yet semver 1.0. In ureq 3.x TLS and cookie configuration is shimmed using our own types.\nureq 3.x is trying out two new traits that had no equivalent in 2.x, `Transport`\u27e866\u27e9 and `Resolver`\u27e867\u27e9. These allow the user write their own bespoke transports and (DNS name) resolver. The API:s for these parts are not yet solidified. They live under the `unversioned`\u27e868\u27e9 module, and do not follow semver. See module doc for more info.\n### \u00a7\u27e869\u27e9Breaking changes in dependencies\nureq relies on non-semver 1.x crates such as `rustls` and `native-tls`. Some scenarios, such as configuring `rustls` to not use `ring`, a user of ureq might need to interact with these crates directly instead of going via ureq\u2019s provided API.\nSuch changes can break when ureq updates dependencies. This is not considered a breaking change for ureq and will not be reflected by a major version bump.\nWe strive to mark ureq\u2019s API with the word \u201cunversioned\u201d to identify places where this risk arises.\n### \u00a7\u27e870\u27e9Minimum Supported Rust Version (MSRV)\nFrom time to time we will need to update our minimum supported Rust version (MSRV). This is not something we do lightly; our ambition is to be as conservative with MSRV as possible.\n  * For some dependencies, we will opt for pinning the version of the dep instead of bumping our MSRV.\n  * For important dependencies, like the TLS libraries, we cannot hold back our MSRV if they change.\n  * We do not consider MSRV changes to be breaking for the purposes of semver.\n  * We will not make MSRV changes in patch releases.\n  * MSRV changes will get their own minor release, and not be co-mingled with other changes.\n\n\n## Re-exports\u00a7\u27e871\u27e9\n\n`pub use ureq_proto::http[](https://docs.rs/http/1.3.1/x86_64-unknown-linux-gnu/http/index.html \"mod http\");`\n\n## Modules\u00a7\u27e872\u27e9\n\nconfig\u27e873\u27e9\n    Agent configuration\n\nmiddleware\u27e874\u27e9\n    Chained interception to modify the request or response.\n\ntls\u27e875\u27e9\n    TLS for handling `https`.\n\ntypestate\u27e876\u27e9\n    Typestate variables.\n\nunversioned\u27e877\u27e9\n    API that does not (yet) follow semver.\n## Structs\u00a7\u27e878\u27e9\n\nAgent\u27e879\u27e9\n    Agents keep state between requests.\n\nBody\u27e880\u27e9\n    A response body returned as `http::Response<Body>`\u27e881\u27e9.\n\nBodyBuilder\u27e882\u27e9\n    Builder for creating a response body.\n\nBodyReader\u27e883\u27e9\n    A reader of the response data.\n\nBodyWithConfig\u27e884\u27e9\n    Configuration of how to read the body.\n\nCookie\u27e885\u27e9\n    Representation of an HTTP cookie.\n\nCookieJar\u27e886\u27e9\n    Collection of cookies.\n\nProxy\u27e887\u27e9\n    Proxy server settings\n\nProxyBuilder\u27e888\u27e9\n    Builder for configuring a proxy.\n\nRequestBuilder\u27e889\u27e9\n    Transparent wrapper around `http::request::Builder`\u27e890\u27e9.\n\nSendBody\u27e891\u27e9\n    Request body for sending data via POST, PUT and PATCH.\n## Enums\u00a7\u27e892\u27e9\n\nError\u27e893\u27e9\n    Errors from ureq.\n\nProxyProtocol\u27e894\u27e9\n    Proxy protocol\n\nTimeout\u27e895\u27e9\n    The various timeouts.\n## Traits\u00a7\u27e896\u27e9\n\nAsSendBody\u27e897\u27e9\n    Trait for common types to send in POST, PUT or PATCH.\n\nRequestExt\u27e898\u27e9\n    Extension trait for `http::Request<impl AsSendBody>`\u27e899\u27e9.\n\nResponseExt\u27e8100\u27e9\n    Extension trait for `http::Response<Body>`\u27e881\u27e9.\n## Functions\u00a7\u27e8101\u27e9\n\nagent\u27e8102\u27e9\n    A new Agent\u27e879\u27e9 with default configuration\n\nconnect\u27e8103\u27e9\n    Make a CONNECT request.\n\ndelete\u27e8104\u27e9\n    Make a DELETE request.\n\nget\u27e8105\u27e9\n    Make a GET request.\n\nhead\u27e8106\u27e9\n    Make a HEAD request.\n\noptions\u27e8107\u27e9\n    Make an OPTIONS request.\n\npatch\u27e8108\u27e9\n    Make a PATCH request.\n\npost\u27e8109\u27e9\n    Make a POST request.\n\nput\u27e8110\u27e9\n    Make a PUT request.\n\nrun\u27e8111\u27e9\n    Run a `http::Request<impl AsSendBody>`\u27e899\u27e9.\n\ntrace\u27e8112\u27e9\n    Make a TRACE request.\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/ureq/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/ureq/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/ureq/latest/src/ureq/lib.rs.html#1-1260: Source\n\u27e84\u27e9 https://img.shields.io/crates/v/ureq.svg?style=flat-square:  ![Crates.io version\n\u27e85\u27e9 https://img.shields.io/badge/docs-latest-blue.svg?style=flat-square:  ![docs.rs docs\n\u27e86\u27e9 https://img.shields.io/crates/d/ureq.svg?style=flat-square:  ![Crates.io downloads\n\u27e87\u27e9 https://github.com/algesten/ureq/blob/main/CHANGELOG.md: changelog\n\u27e88\u27e9 https://docs.rs/ureq/latest/ureq/#usage: \u00a7\n\u27e89\u27e9 https://docs.rs/ureq/3.0.0-rc4/ureq/struct.Agent.html: `Agent`\n\u27e810\u27e9 https://doc.rust-lang.org/std/sync/struct.Arc.html: `Arc`\n\u27e811\u27e9 https://docs.rs/ureq/latest/ureq/#json: \u00a7\n\u27e812\u27e9 https://docs.rs/ureq/latest/ureq/#error-handling: \u00a7\n\u27e813\u27e9 https://docs.rs/ureq/3.0.0-rc4/ureq/enum.Error.html: `Error`\n\u27e814\u27e9 https://docs.rs/ureq/3.0.0-rc4/ureq/config/struct.ConfigBuilder.html#method.http_status_as_error: `http_status_as_error()`\n\u27e815\u27e9 https://docs.rs/ureq/latest/ureq/#features: \u00a7\n\u27e816\u27e9 https://crates.io/crates/rustls-platform-verifier: rustls-platform-verifier\n\u27e817\u27e9 https://docs.rs/ureq/latest/ureq/#unstable: \u00a7\n\u27e818\u27e9 https://docs.rs/rustls/latest/rustls/crypto/struct.CryptoProvider.html: `CryptoProvider`\n\u27e819\u27e9 https://docs.rs/ureq/latest/ureq/#tls-https: \u00a7\n\u27e820\u27e9 https://docs.rs/ureq/latest/ureq/#rustls: \u00a7\n\u27e821\u27e9 https://crates.io/crates/rustls: `rustls` crate\n\u27e822\u27e9 https://docs.rs/rustls/latest/rustls/crypto/struct.CryptoProvider.html#method.install_default: default provider\n\u27e823\u27e9 https://docs.rs/ureq/latest/ureq/#rustls-without-ring: \u00a7\n\u27e824\u27e9 https://docs.rs/ureq/latest/ureq/tls/struct.TlsConfigBuilder.html#method.unversioned_rustls_crypto_provider: method ureq::tls::TlsConfigBuilder::unversioned_rustls_crypto_provider - `TlsConfigBuilder::unversioned_rustls_crypto_provider`\n\u27e825\u27e9 https://docs.rs/ureq/latest/ureq/#native-tls: \u00a7\n\u27e826\u27e9 https://crates.io/crates/native-tls: `native-tls`\n\u27e827\u27e9 https://docs.rs/ureq/latest/ureq/#root-certificates: \u00a7\n\u27e828\u27e9 https://docs.rs/ureq/latest/ureq/#webpki-roots: \u00a7\n\u27e829\u27e9 https://crates.io/crates/webpki-roots: webpki-roots\n\u27e830\u27e9 https://en.wikipedia.org/wiki/Certificate_Transparency: SCT\n\u27e831\u27e9 https://en.wikipedia.org/wiki/Certificate_revocation_list: CRL\n\u27e832\u27e9 https://docs.rs/ureq/latest/ureq/#platform-verifier: \u00a7\n\u27e833\u27e9 https://docs.rs/ureq/latest/ureq/#json-1: \u00a7\n\u27e834\u27e9 https://docs.rs/ureq/3.0.0-rc4/ureq/struct.RequestBuilder.html#method.send_json: `request.send_json()`\n\u27e835\u27e9 https://docs.rs/ureq/3.0.0-rc4/ureq/struct.Body.html#method.read_json: `body.read_json()`\n\u27e836\u27e9 https://docs.rs/ureq/latest/ureq/#sending-body-data: \u00a7\n\u27e837\u27e9 https://docs.rs/ureq/3.0.0-rc4/ureq/trait.AsSendBody.html: `AsSendBody`\n\u27e838\u27e9 https://docs.rs/ureq/latest/ureq/#content-length: \u00a7\n\u27e839\u27e9 https://docs.rs/ureq/3.0.0-rc4/ureq/struct.SendBody.html#method.from_json: `SendBody::from_json()`\n\u27e840\u27e9 https://docs.rs/ureq/latest/ureq/#transfer-encoding-chunked: \u00a7\n\u27e841\u27e9 https://doc.rust-lang.org/std/io/trait.Read.html: `std::io::Read`\n\u27e842\u27e9 https://docs.rs/ureq/latest/ureq/#from-readers: \u00a7\n\u27e843\u27e9 https://docs.rs/ureq/3.0.0-rc4/ureq/struct.SendBody.html#method.from_reader: `SendBody::from_reader()`\n\u27e844\u27e9 https://docs.rs/ureq/3.0.0-rc4/ureq/struct.SendBody.html#method.from_owned_reader: `SendBody::from_owned_reader()`\n\u27e845\u27e9 https://docs.rs/ureq/latest/ureq/#proxying-a-response-body: \u00a7\n\u27e846\u27e9 https://docs.rs/ureq/3.0.0-rc4/ureq/struct.Body.html: `Body`\n\u27e847\u27e9 https://docs.rs/ureq/latest/ureq/#sending-form-data: \u00a7\n\u27e848\u27e9 https://docs.rs/ureq/3.0.0-rc4/ureq/struct.RequestBuilder.html#method.send_form: `request.send_form()`\n\u27e849\u27e9 https://docs.rs/ureq/latest/ureq/#overriding: \u00a7\n\u27e850\u27e9 https://docs.rs/ureq/latest/ureq/#character-encoding: \u00a7\n\u27e851\u27e9 https://docs.rs/ureq/3.0.0-rc4/ureq/struct.Body.html#method.read_to_string: `Body::read_to_string()`\n\u27e852\u27e9 https://docs.rs/ureq/latest/ureq/#lossy-utf-8: \u00a7\n\u27e853\u27e9 https://docs.rs/ureq/3.0.0-rc4/ureq/struct.Body.html#method.as_reader: `Body::as_reader()`\n\u27e854\u27e9 https://docs.rs/ureq/3.0.0-rc4/ureq/struct.Body.html#method.with_config: `Body::with_config()`\n\u27e855\u27e9 https://docs.rs/ureq/latest/ureq/#proxying: \u00a7\n\u27e856\u27e9 https://developer.mozilla.org/en-US/docs/Web/HTTP/Proxy_servers_and_tunneling#http_tunneling: `HTTP`\n\u27e857\u27e9 https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/CONNECT: `CONNECT`\n\u27e858\u27e9 https://en.wikipedia.org/wiki/SOCKS#SOCKS4: `SOCKS4`\n\u27e859\u27e9 https://en.wikipedia.org/wiki/SOCKS#SOCKS5: `SOCKS5`\n\u27e860\u27e9 https://docs.rs/ureq/latest/ureq/#example-using-http: \u00a7\n\u27e861\u27e9 https://docs.rs/ureq/latest/ureq/#example-using-socks5: \u00a7\n\u27e862\u27e9 https://docs.rs/ureq/latest/ureq/#log-levels: \u00a7\n\u27e863\u27e9 https://github.com/algesten/ureq/blob/81127cfc38516903330dc1b9c618122372f8dc29/src/util.rs#L184-L198: allow list\n\u27e864\u27e9 https://docs.rs/ureq/latest/ureq/#versioning: \u00a7\n\u27e865\u27e9 https://docs.rs/ureq/latest/ureq/#semver-and-unversioned: \u00a7\n\u27e866\u27e9 https://docs.rs/ureq/3.0.0-rc4/ureq/unversioned/transport/trait.Transport.html: `Transport`\n\u27e867\u27e9 https://docs.rs/ureq/3.0.0-rc4/ureq/unversioned/resolver/trait.Resolver.html: `Resolver`\n\u27e868\u27e9 https://docs.rs/ureq/3.0.0-rc4/ureq/unversioned/index.html: `unversioned`\n\u27e869\u27e9 https://docs.rs/ureq/latest/ureq/#breaking-changes-in-dependencies: \u00a7\n\u27e870\u27e9 https://docs.rs/ureq/latest/ureq/#minimum-supported-rust-version-msrv: \u00a7\n\u27e871\u27e9 https://docs.rs/ureq/latest/ureq/#reexports: \u00a7\n\u27e872\u27e9 https://docs.rs/ureq/latest/ureq/#modules: \u00a7\n\u27e873\u27e9 https://docs.rs/ureq/latest/ureq/config/index.html: mod ureq::config - config\n\u27e874\u27e9 https://docs.rs/ureq/latest/ureq/middleware/index.html: mod ureq::middleware - middleware\n\u27e875\u27e9 https://docs.rs/ureq/latest/ureq/tls/index.html: mod ureq::tls - tls\n\u27e876\u27e9 https://docs.rs/ureq/latest/ureq/typestate/index.html: mod ureq::typestate - typestate\n\u27e877\u27e9 https://docs.rs/ureq/latest/ureq/unversioned/index.html: mod ureq::unversioned - unversioned\n\u27e878\u27e9 https://docs.rs/ureq/latest/ureq/#structs: \u00a7\n\u27e879\u27e9 https://docs.rs/ureq/latest/ureq/struct.Agent.html: struct ureq::Agent - Agent\n\u27e880\u27e9 https://docs.rs/ureq/latest/ureq/struct.Body.html: struct ureq::Body - Body\n\u27e881\u27e9 https://docs.rs/http/1.3.1/x86_64-unknown-linux-gnu/http/response/struct.Response.html: struct http::response::Response - `http::Response<Body>`\n\u27e882\u27e9 https://docs.rs/ureq/latest/ureq/struct.BodyBuilder.html: struct ureq::BodyBuilder - BodyBuilder\n\u27e883\u27e9 https://docs.rs/ureq/latest/ureq/struct.BodyReader.html: struct ureq::BodyReader - BodyReader\n\u27e884\u27e9 https://docs.rs/ureq/latest/ureq/struct.BodyWithConfig.html: struct ureq::BodyWithConfig - BodyWithConfig\n\u27e885\u27e9 https://docs.rs/ureq/latest/ureq/struct.Cookie.html: struct ureq::Cookie - Cookie\n\u27e886\u27e9 https://docs.rs/ureq/latest/ureq/struct.CookieJar.html: struct ureq::CookieJar - CookieJar\n\u27e887\u27e9 https://docs.rs/ureq/latest/ureq/struct.Proxy.html: struct ureq::Proxy - Proxy\n\u27e888\u27e9 https://docs.rs/ureq/latest/ureq/struct.ProxyBuilder.html: struct ureq::ProxyBuilder - ProxyBuilder\n\u27e889\u27e9 https://docs.rs/ureq/latest/ureq/struct.RequestBuilder.html: struct ureq::RequestBuilder - RequestBuilder\n\u27e890\u27e9 https://docs.rs/http/1.3.1/x86_64-unknown-linux-gnu/http/request/struct.Builder.html: struct http::request::Builder - `http::request::Builder`\n\u27e891\u27e9 https://docs.rs/ureq/latest/ureq/struct.SendBody.html: struct ureq::SendBody - SendBody\n\u27e892\u27e9 https://docs.rs/ureq/latest/ureq/#enums: \u00a7\n\u27e893\u27e9 https://docs.rs/ureq/latest/ureq/enum.Error.html: enum ureq::Error - Error\n\u27e894\u27e9 https://docs.rs/ureq/latest/ureq/enum.ProxyProtocol.html: enum ureq::ProxyProtocol - ProxyProtocol\n\u27e895\u27e9 https://docs.rs/ureq/latest/ureq/enum.Timeout.html: enum ureq::Timeout - Timeout\n\u27e896\u27e9 https://docs.rs/ureq/latest/ureq/#traits: \u00a7\n\u27e897\u27e9 https://docs.rs/ureq/latest/ureq/trait.AsSendBody.html: trait ureq::AsSendBody - AsSendBody\n\u27e898\u27e9 https://docs.rs/ureq/latest/ureq/trait.RequestExt.html: trait ureq::RequestExt - RequestExt\n\u27e899\u27e9 https://docs.rs/http/1.3.1/x86_64-unknown-linux-gnu/http/request/struct.Request.html: struct http::request::Request - `http::Request<impl AsSendBody>`\n\u27e8100\u27e9 https://docs.rs/ureq/latest/ureq/trait.ResponseExt.html: trait ureq::ResponseExt - ResponseExt\n\u27e8101\u27e9 https://docs.rs/ureq/latest/ureq/#functions: \u00a7\n\u27e8102\u27e9 https://docs.rs/ureq/latest/ureq/fn.agent.html: fn ureq::agent - agent\n\u27e8103\u27e9 https://docs.rs/ureq/latest/ureq/fn.connect.html: fn ureq::connect - connect\n\u27e8104\u27e9 https://docs.rs/ureq/latest/ureq/fn.delete.html: fn ureq::delete - delete\n\u27e8105\u27e9 https://docs.rs/ureq/latest/ureq/fn.get.html: fn ureq::get - get\n\u27e8106\u27e9 https://docs.rs/ureq/latest/ureq/fn.head.html: fn ureq::head - head\n\u27e8107\u27e9 https://docs.rs/ureq/latest/ureq/fn.options.html: fn ureq::options - options\n\u27e8108\u27e9 https://docs.rs/ureq/latest/ureq/fn.patch.html: fn ureq::patch - patch\n\u27e8109\u27e9 https://docs.rs/ureq/latest/ureq/fn.post.html: fn ureq::post - post\n\u27e8110\u27e9 https://docs.rs/ureq/latest/ureq/fn.put.html: fn ureq::put - put\n\u27e8111\u27e9 https://docs.rs/ureq/latest/ureq/fn.run.html: fn ureq::run - run\n\u27e8112\u27e9 https://docs.rs/ureq/latest/ureq/fn.trace.html: fn ureq::trace - trace\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `ureq` crate is a simple, safe, and blocking HTTP client designed for ease of use and minimal dependencies. It supports features like cookies, JSON handling, proxies (HTTP and SOCKS), gzip/brotli compression, and charset decoding, with TLS provided via `rustls` or `native-tls`. It offers a straightforward API for making HTTP requests and managing connection pooling through `Agent`.",
    "feature_summary": null,
    "use_case": "Web Framework",
    "score": 0.0,
    "factual_counterfactual": "### Pair 1: Blocking vs Async I/O  \n\u2705 **Factual:** The `ureq` crate uses blocking I/O instead of async I/O to keep its API simple and minimize dependencies.  \n\u274c **Counterfactual:** The `ureq` crate provides full support for async I/O, allowing seamless integration with async runtimes like Tokio and async-std.  \n\n---\n\n### Pair 2: Default TLS Implementation  \n\u2705 **Factual:** By default, `ureq` uses the `rustls` crate with the `ring` cryptographic provider for TLS, ensuring safety and simplicity.  \n\u274c **Counterfactual:** The `ureq` crate defaults to using `native-tls` for TLS operations, automatically leveraging the platform's native libraries.  \n\n---\n\n### Pair 3: Feature Flags for JSON  \n\u2705 **Factual:** The `ureq` crate supports JSON serialization and deserialization via the `serde` crate when the `json` feature is enabled.  \n\u274c **Counterfactual:** JSON handling in `ureq` is always enabled by default and does not require activating any feature flags.",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}