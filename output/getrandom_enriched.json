{
    "name": "getrandom",
    "version": "0.3.3",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/getrandom/latest/getrandom/all.html \"show sidebar\")\n# Crate getrandomCopy item path\n[Settings](https://docs.rs/getrandom/latest/settings.html)\n[Help](https://docs.rs/getrandom/latest/help.html)\nSummary[Source](https://docs.rs/getrandom/latest/src/getrandom/lib.rs.html#2-143)\nExpand description\n## [\u00a7](https://docs.rs/getrandom/latest/getrandom/#getrandom-systems-random-number-generator)getrandom: system\u2019s random number generator\n[![Build Status](https://github.com/rust-random/getrandom/actions/workflows/tests.yml/badge.svg?branch=master)](https://github.com/rust-random/getrandom/actions?query=branch:master) [![Crate](https://img.shields.io/crates/v/getrandom)](https://crates.io/crates/getrandom) [![Documentation](https://docs.rs/getrandom/badge.svg)](https://docs.rs/getrandom) [![Dependency Status](https://deps.rs/repo/github/rust-random/getrandom/status.svg)](https://deps.rs/repo/github/rust-random/getrandom) [![Downloads](https://img.shields.io/crates/d/getrandom)](https://crates.io/crates/getrandom) [![License](https://img.shields.io/crates/l/getrandom)](https://github.com/rust-random/getrandom/blob/master/LICENSE-MIT)\n`getrandom` is a Rust library for retrieving random data from (operating) system sources.\nIt is assumed that the system always provides high-quality, cryptographically secure random data, ideally backed by hardware entropy sources. This crate derives its name from the Linux `getrandom` syscall but is cross-platform, roughly supporting the same set of platforms as Rust\u2019s `std` library.\nThis is a low-level API. Most users should prefer using a higher-level random-number library like [`rand`](https://crates.io/crates/rand).\n### [\u00a7](https://docs.rs/getrandom/latest/getrandom/#usage)Usage\nAdd the `getrandom` dependency to your `Cargo.toml` file:\n```\n[dependencies]\ngetrandom = \"0.3\"\n```\n\nThen invoke the `fill` function on a byte buffer to fill it with random data:\n```\nfn get_random_u128() -> Result<u128, getrandom::Error> {\n  let mut buf = [0u8; 16];\n  getrandom::fill(&mut buf)?;\n  Ok(u128::from_ne_bytes(buf))\n}\n```\n\n### [\u00a7](https://docs.rs/getrandom/latest/getrandom/#supported-targets)Supported targets\nTarget| Target Triple| Implementation  \n---|---|---  \nLinux, Android| `*\u2011linux\u2011*`| [`getrandom`](https://manned.org/getrandom.2) system call if available, otherwise [`/dev/urandom`](https://manned.org/urandom.4) after successfully polling `/dev/random`  \nWindows 10+| `*\u2011windows\u2011*`| [`ProcessPrng`](https://learn.microsoft.com/en-us/windows/win32/seccng/processprng) on Rust 1.78+, [`RtlGenRandom`](https://learn.microsoft.com/en-us/windows/win32/api/ntsecapi/nf-ntsecapi-rtlgenrandom) otherwise  \nWindows 7, 8| `*-win7\u2011windows\u2011*`| [`RtlGenRandom`](https://learn.microsoft.com/en-us/windows/win32/api/ntsecapi/nf-ntsecapi-rtlgenrandom)  \nmacOS| `*\u2011apple\u2011darwin`| [`getentropy`](https://www.unix.com/man-page/mojave/2/getentropy/)  \niOS, tvOS, watchOS| `*\u2011apple\u2011{ios,tvos,watchos}`| [`CCRandomGenerateBytes`](https://opensource.apple.com/source/CommonCrypto/CommonCrypto-60074/include/CommonRandom.h.auto.html)  \nFreeBSD| `*\u2011freebsd`| [`getrandom`](https://www.freebsd.org/cgi/man.cgi?query=getrandom&manpath=FreeBSD+12.0-stable)  \nOpenBSD| `*\u2011openbsd`| [`getentropy`](https://man.openbsd.org/getentropy.2)  \nNetBSD| `*\u2011netbsd`| [`getrandom`](https://man.netbsd.org/getrandom.2) if available, otherwise [`kern.arandom`](https://man.netbsd.org/sysctl.7)  \nDragonfly BSD| `*\u2011dragonfly`| [`getrandom`](https://leaf.dragonflybsd.org/cgi/web-man?command=getrandom)  \nSolaris| `*\u2011solaris`| [`getrandom`](https://docs.oracle.com/cd/E88353_01/html/E37841/getrandom-2.html) with `GRND_RANDOM`  \nillumos| `*\u2011illumos`| [`getrandom`](https://illumos.org/man/2/getrandom)  \nFuchsia OS| `*\u2011fuchsia`| [`cprng_draw`](https://fuchsia.dev/fuchsia-src/zircon/syscalls/cprng_draw)  \nRedox| `*\u2011redox`| `/dev/urandom`  \nHaiku| `*\u2011haiku`| `/dev/urandom` (identical to `/dev/random`)  \nHermit| `*-hermit`| [`sys_read_entropy`](https://github.com/hermit-os/kernel/blob/315f58ff5efc81d9bf0618af85a59963ff55f8b1/src/syscalls/entropy.rs#L47-L55)  \nHurd| `*-hurd-*`| [`getrandom`](https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-getrandom)  \nSGX| `x86_64\u2011*\u2011sgx`| [`RDRAND`](https://software.intel.com/en-us/articles/intel-digital-random-number-generator-drng-software-implementation-guide)  \nVxWorks| `*\u2011wrs\u2011vxworks\u2011*`| `randABytes` after checking entropy pool initialization with `randSecure`  \nEmscripten| `*\u2011emscripten`| [`getentropy`](https://github.com/emscripten-core/emscripten/pull/12240)  \nWASI 0.1| `wasm32\u2011wasip1`| [`random_get`](https://github.com/WebAssembly/WASI/blob/snapshot-01/phases/snapshot/docs.md#-random_getbuf-pointeru8-buf_len-size---errno)  \nWASI 0.2| `wasm32\u2011wasip2`| [`get-random-u64`](https://github.com/WebAssembly/WASI/blob/v0.2.1/wasip2/random/random.wit#L23-L28)  \nSOLID| `*-kmc-solid_*`| `SOLID_RNG_SampleRandomBytes`  \nNintendo 3DS| `*-nintendo-3ds`| [`getrandom`](https://github.com/rust3ds/shim-3ds/commit/b01d2568836dea2a65d05d662f8e5f805c64389d)  \nESP-IDF| `*\u2011espidf`| [`esp_fill_random`](https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-reference/system/random.html#functions) WARNING: see \u201cEarly Boot\u201d section below  \nPS Vita| `*-vita-*`| [`getentropy`](https://github.com/vitasdk/newlib/blob/2d869fe47aaf02b8e52d04e9a2b79d5b210fd016/newlib/libc/sys/vita/getentropy.c)  \nQNX Neutrino| `*\u2011nto-qnx*`| [`/dev/urandom`](https://www.qnx.com/developers/docs/7.1/index.html#com.qnx.doc.neutrino.utilities/topic/r/random.html) (identical to `/dev/random`)  \nAIX| `*-ibm-aix`| [`/dev/urandom`](https://www.ibm.com/docs/en/aix/7.3?topic=files-random-urandom-devices)  \nCygwin| `*-cygwin`| [`getrandom`](https://github.com/cygwin/cygwin/blob/main/winsup/cygwin/libc/getentropy.cc) (based on [`RtlGenRandom`](https://learn.microsoft.com/en-us/windows/win32/api/ntsecapi/nf-ntsecapi-rtlgenrandom))  \nPull Requests that add support for new targets to `getrandom` are always welcome.\n#### [\u00a7](https://docs.rs/getrandom/latest/getrandom/#opt-in-backends)Opt-in backends\n`getrandom` also provides optional (opt-in) backends, which allow users to customize the source of randomness based on their specific needs:\nBackend name| Target| Target Triple| Implementation  \n---|---|---|---  \n`linux_getrandom`| Linux, Android| `*\u2011linux\u2011*`| [`getrandom`](https://manned.org/getrandom.2) system call (without `/dev/urandom` fallback). Bumps minimum supported Linux kernel version to 3.17 and Android API level to 23 (Marshmallow).  \n`linux_raw`| Linux, Android| `*\u2011linux\u2011*`| Same as `linux_getrandom`, but uses raw `asm!`-based syscalls instead of `libc`.  \n`rdrand`| x86, x86-64| `x86_64-*`, `i686-*`| [`RDRAND`](https://software.intel.com/en-us/articles/intel-digital-random-number-generator-drng-software-implementation-guide) instruction  \n`rndr`| AArch64| `aarch64-*`| [`RNDR`](https://developer.arm.com/documentation/ddi0601/2024-06/AArch64-Registers/RNDR--Random-Number) register  \n`wasm_js`| Web Browser, Node.js| `wasm32\u2011unknown\u2011unknown`, `wasm32v1-none`| [`Crypto.getRandomValues`](https://www.w3.org/TR/WebCryptoAPI/#Crypto-method-getRandomValues). Requires feature `wasm_js` ([see below](https://docs.rs/getrandom/latest/getrandom/#webassembly-support)).  \n`efi_rng`| UEFI| `*-unknown\u2011uefi`| [`EFI_RNG_PROTOCOL`](https://uefi.org/specs/UEFI/2.10/37_Secure_Technologies.html#efi-rng-protocol) with `EFI_RNG_ALGORITHM_RAW` (requires `std` and Nigthly compiler)  \n`custom`| All targets| `*`| User-provided custom implementation (see [custom backend](https://docs.rs/getrandom/latest/getrandom/#custom-backend))  \nOpt-in backends can be enabled using the `getrandom_backend` configuration flag. The flag can be set either by specifying the `rustflags` field in [`.cargo/config.toml`](https://doc.rust-lang.org/cargo/reference/config.html):\n```\n# It's recommended to set the flag on a per-target basis:\n[target.wasm32-unknown-unknown]\nrustflags = ['--cfg', 'getrandom_backend=\"wasm_js\"']\n```\n\nOr by using the `RUSTFLAGS` environment variable:\n```\nRUSTFLAGS='--cfg getrandom_backend=\"linux_getrandom\"' cargo build\n```\n\nEnabling an opt-in backend will replace the backend used by default. Doing this for an incorrect target (e.g. using `linux_getrandom` while compiling for a Windows target) will result in a compilation error. Be extremely careful while using opt-in backends, as incorrect configuration may result in vulnerable applications or applications that always panic.\nNote that using an opt-in backend in a library (e.g. for tests or benchmarks) WILL NOT have any effect on its downstream users.\n#### [\u00a7](https://docs.rs/getrandom/latest/getrandom/#raw-linux-syscall-support)Raw Linux syscall support\nCurrently the `linux_raw` backend supports only targets with stabilized `asm!` macro, i.e. `arm`, `aarch64`, `loongarch64`, `riscv32`, `riscv64`, `s390x`, `x86`, and `x86_64`.\nNote that the raw syscall backend may be slower than backends based on `libc::getrandom`, e.g. it does not implement vDSO optimizations and on `x86` it uses the infamously slow `int 0x80` instruction to perform syscall.\n#### [\u00a7](https://docs.rs/getrandom/latest/getrandom/#webassembly-support)WebAssembly support\nThis crate fully supports the [WASI](https://github.com/WebAssembly/WASI) and [Emscripten](https://emscripten.org) targets. However, the `wasm32-unknown-unknown` target (i.e. the target used by `wasm-pack`) is not automatically supported since, from the target name alone, we cannot deduce which JavaScript interface should be used (or if JavaScript is available at all).\nTo enable `getrandom`\u2019s functionality on `wasm32-unknown-unknown` using the Web Crypto methods [described above](https://docs.rs/getrandom/latest/getrandom/#opt-in-backends) via [`wasm-bindgen`](https://github.com/rustwasm/wasm-bindgen), do _both_ of the following:\n  * Use the `wasm_js` feature flag, i.e. `getrandom = { version = \"0.3\", features = [\"wasm_js\"] }`. On its own, this only makes the backend available. (As a side effect this will make your `Cargo.lock` significantly larger if you are not already using [`wasm-bindgen`](https://github.com/rustwasm/wasm-bindgen), but otherwise enabling this feature is harmless.)\n  * Set `RUSTFLAGS='--cfg getrandom_backend=\"wasm_js\"'` ([see above](https://docs.rs/getrandom/latest/getrandom/#opt-in-backends)).\n\n\nThis backend supports both web browsers (main window and Web Workers) and Node.js (v19 or later) environments.\nWARNING: It is highly recommended to enable the `wasm_js` feature only for binary crates and tests, i.e. avoid unconditionally enabling it in library crates.\n#### [\u00a7](https://docs.rs/getrandom/latest/getrandom/#custom-backend)Custom backend\nIf this crate does not support your target out of the box or you have to use a non-default entropy source, then you can provide a custom implementation. You need to enable the custom backend as described in the [opt-in backends](https://docs.rs/getrandom/latest/getrandom/#opt-in-backends) section.\nNext, you need to define an `extern` function with the following signature:\n```\nuse getrandom::Error;\n#[no_mangle]\nunsafe extern \"Rust\" fn __getrandom_v03_custom(\n  dest: *mut u8,\n  len: usize,\n) -> Result<(), Error> {\n  todo!()\n}\n```\n\nThis function should, ideally, be defined in the root crate of your project, e.g. in your `main.rs`. This function MUST be defined only once for your project, i.e. upstream library crates SHOULD NOT define it outside of tests and benchmarks. Improper configuration of this backend may result in linking errors.\nThe function accepts a pointer to a buffer that should be filled with random data and its length in bytes. Note that the buffer MAY be uninitialized. On success, the function should return `Ok(())` and fully fill the input buffer; otherwise, it should return an error value.\nWhile wrapping functions which work with byte slices you should fully initialize the buffer before passing it to the function:\n```\nuse getrandom::Error;\nfn my_entropy_source(buf: &mut [u8]) -> Result<(), getrandom::Error> {\n  // ...\n  Ok(())\n}\n#[no_mangle]\nunsafe extern \"Rust\" fn __getrandom_v03_custom(\n  dest: *mut u8,\n  len: usize,\n) -> Result<(), Error> {\n  let buf = unsafe {\n    // fill the buffer with zeros\n    core::ptr::write_bytes(dest, 0, len);\n    // create mutable byte slice\n    core::slice::from_raw_parts_mut(dest, len)\n  };\n  my_entropy_source(buf)\n}\n```\n\nIf you are confident that `getrandom` is not used in your project, but it gets pulled nevertheless by one of your dependencies, then you can use the following custom backend, which always returns the \u201cunsupported\u201d error:\n```\nuse getrandom::Error;\n#[no_mangle]\nunsafe extern \"Rust\" fn __getrandom_v03_custom(\n  dest: *mut u8,\n  len: usize,\n) -> Result<(), Error> {\n  Err(Error::UNSUPPORTED)\n}\n```\n\n#### [\u00a7](https://docs.rs/getrandom/latest/getrandom/#platform-support)Platform Support\nThis crate generally supports the same operating system and platform versions that the Rust standard library does. Additional targets may be supported using the opt-in custom backend.\nThis means that as Rust drops support for old versions of operating systems (such as old Linux kernel versions, Android API levels, etc.) in stable releases, `getrandom` may create new patch releases that remove support for outdated platform versions.\n#### [\u00a7](https://docs.rs/getrandom/latest/getrandom/#devurandom-fallback-on-linux-and-android)`/dev/urandom` fallback on Linux and Android\nOn Linux targets, the `/dev/urandom` fallback is present only if either `target_env` is `musl`, or `target_arch` is one of the following: `aarch64`, `arm`, `powerpc`, `powerpc64`, `s390x`, `x86`, `x86_64`. Other supported targets [require](https://doc.rust-lang.org/stable/rustc/platform-support.html) kernel versions that support the `getrandom` system call, so the fallback is not needed.\nOn Android targets the fallback is present only for the following `target_arch`es: `aarch64`, `arm`, `x86`, `x86_64`. Other `target_arch`es (e.g. RISC-V) require sufficiently high API levels.\nThe fallback can be disabled by enabling the `linux_getrandom` opt-in backend. Note that doing so will bump minimum supported Linux kernel version to 3.17 and Android API level to 23 (Marshmallow).\n#### [\u00a7](https://docs.rs/getrandom/latest/getrandom/#early-boot)Early boot\nSometimes, early in the boot process, the OS has not collected enough entropy to securely seed its RNG. This is especially common on virtual machines, where standard \u201crandom\u201d events are hard to come by.\nSome operating system interfaces always block until the RNG is securely seeded. This can take anywhere from a few seconds to more than a minute. A few (Linux, NetBSD and Solaris) offer a choice between blocking and getting an error; in these cases, we always choose to block.\nOn Linux (when the `getrandom` system call is not available), reading from `/dev/urandom` never blocks, even when the OS hasn\u2019t collected enough entropy yet. To avoid returning low-entropy bytes, we first poll `/dev/random` and only switch to `/dev/urandom` once this has succeeded.\nOn OpenBSD, this kind of entropy accounting isn\u2019t available, and on NetBSD, blocking on it is discouraged. On these platforms, nonblocking interfaces are used, even when reliable entropy may not be available. On the platforms where it is used, the reliability of entropy accounting itself isn\u2019t free from controversy. This library provides randomness sourced according to the platform\u2019s best practices, but each platform has its own limits on the grade of randomness it can promise in environments with few sources of entropy.\nOn ESP-IDF, if `esp_fill_random` is used before enabling WiFi, BT, or the voltage noise entropy source (SAR ADC), the Hardware RNG will only be seeded via RC_FAST_CLK. This can occur during early boot unless `bootloader_random_enable()` is called. For more information see the [ESP-IDF RNG Docs](https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-reference/system/random.html) or the [RNG section of the ESP32 Technical Reference Manual](https://www.espressif.com/sites/default/files/documentation/esp32_technical_reference_manual_en.pdf#rng).\n### [\u00a7](https://docs.rs/getrandom/latest/getrandom/#error-handling)Error handling\nWe always prioritize failure over returning known insecure \u201crandom\u201d bytes. Generally, on supported platforms, failure is highly unlikely, though not impossible. If an error does occur, it is likely that it will occur on every call to `getrandom`. Therefore, after the first successful call, one can be reasonably confident that no errors will occur.\n### [\u00a7](https://docs.rs/getrandom/latest/getrandom/#panic-handling)Panic handling\nWe strive to eliminate all potential panics from our backend implementations. In other words, when compiled with optimizations enabled, the generated binary code for `getrandom` functions should not contain any panic branches. Even if the platform misbehaves and returns an unexpected result, our code should correctly handle it and return an error, e.g. [`Error::UNEXPECTED`](https://docs.rs/getrandom/latest/getrandom/struct.Error.html#associatedconstant.UNEXPECTED \"associated constant getrandom::Error::UNEXPECTED\").\n### [\u00a7](https://docs.rs/getrandom/latest/getrandom/#sanitizer-support)Sanitizer support\nIf your code uses [`fill_uninit`](https://docs.rs/getrandom/latest/getrandom/fn.fill_uninit.html \"fn getrandom::fill_uninit\") and you enable [MemorySanitizer](https://doc.rust-lang.org/beta/unstable-book/compiler-flags/sanitizer.html#memorysanitizer) (i.e. `-Zsanitizer=memory`), we will automatically handle unpoisoning of the destination buffer filled by `fill_uninit`.\nYou can run sanitizer tests for your crate dependent on `getrandom` like this:\n```\nRUSTFLAGS=\"-Zsanitizer=memory\" cargo test -Zbuild-std --target=x86_64-unknown-linux-gnu\n```\n\n### [\u00a7](https://docs.rs/getrandom/latest/getrandom/#minimum-supported-rust-version)Minimum Supported Rust Version\nThis crate requires Rust 1.63 or later.\n### [\u00a7](https://docs.rs/getrandom/latest/getrandom/#license)License\nThe `getrandom` library is distributed under either of\n  * [Apache License, Version 2.0](https://github.com/rust-random/getrandom/blob/master/LICENSE-APACHE)\n  * [MIT license](https://github.com/rust-random/getrandom/blob/master/LICENSE-MIT)\n\n\nat your option.\n#### [\u00a7](https://docs.rs/getrandom/latest/getrandom/#contribution)Contribution\nUnless you explicitly state otherwise, any contribution intentionally submitted for inclusion in the work by you, as defined in the Apache-2.0 license, shall be dual licensed as above, without any additional terms or conditions.\n## Structs[\u00a7](https://docs.rs/getrandom/latest/getrandom/#structs)\n\n[Error](https://docs.rs/getrandom/latest/getrandom/struct.Error.html \"struct getrandom::Error\")\n    A small and `no_std` compatible error type\n## Functions[\u00a7](https://docs.rs/getrandom/latest/getrandom/#functions)\n\n[fill](https://docs.rs/getrandom/latest/getrandom/fn.fill.html \"fn getrandom::fill\")\n    Fill `dest` with random bytes from the system\u2019s preferred random number source.\n\n[fill_uninit](https://docs.rs/getrandom/latest/getrandom/fn.fill_uninit.html \"fn getrandom::fill_uninit\")\n    Fill potentially uninitialized buffer `dest` with random bytes from the system\u2019s preferred random number source and return a mutable reference to those bytes.\n\n[u32](https://docs.rs/getrandom/latest/getrandom/fn.u32.html \"fn getrandom::u32\")\n    Get random `u32` from the system\u2019s preferred random number source.\n\n[u64](https://docs.rs/getrandom/latest/getrandom/fn.u64.html \"fn getrandom::u64\")\n    Get random `u64` from the system\u2019s preferred random number source.\n",
        "markdown_with_citations": "[](https://docs.rs/getrandom/latest/getrandom/all.html \"show sidebar\")\n# Crate getrandomCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\n## \u00a7\u27e84\u27e9getrandom: system\u2019s random number generator\n![Build Status\u27e85\u27e9](https://github.com/rust-random/getrandom/actions?query=branch:master) ![Crate\u27e86\u27e9](https://crates.io/crates/getrandom) ![Documentation\u27e87\u27e9](https://docs.rs/getrandom) ![Dependency Status\u27e88\u27e9](https://deps.rs/repo/github/rust-random/getrandom) ![Downloads\u27e89\u27e9](https://crates.io/crates/getrandom) ![License\u27e810\u27e9](https://github.com/rust-random/getrandom/blob/master/LICENSE-MIT)\n`getrandom` is a Rust library for retrieving random data from (operating) system sources.\nIt is assumed that the system always provides high-quality, cryptographically secure random data, ideally backed by hardware entropy sources. This crate derives its name from the Linux `getrandom` syscall but is cross-platform, roughly supporting the same set of platforms as Rust\u2019s `std` library.\nThis is a low-level API. Most users should prefer using a higher-level random-number library like `rand`\u27e811\u27e9.\n### \u00a7\u27e812\u27e9Usage\nAdd the `getrandom` dependency to your `Cargo.toml` file:\n```\n[dependencies]\ngetrandom = \"0.3\"\n```\n\nThen invoke the `fill` function on a byte buffer to fill it with random data:\n```\nfn get_random_u128() -> Result<u128, getrandom::Error> {\n  let mut buf = [0u8; 16];\n  getrandom::fill(&mut buf)?;\n  Ok(u128::from_ne_bytes(buf))\n}\n```\n\n### \u00a7\u27e813\u27e9Supported targets\nTarget| Target Triple| Implementation  \n---|---|---  \nLinux, Android| `*\u2011linux\u2011*`| `getrandom`\u27e814\u27e9 system call if available, otherwise `/dev/urandom`\u27e815\u27e9 after successfully polling `/dev/random`  \nWindows 10+| `*\u2011windows\u2011*`| `ProcessPrng`\u27e816\u27e9 on Rust 1.78+, `RtlGenRandom`\u27e817\u27e9 otherwise  \nWindows 7, 8| `*-win7\u2011windows\u2011*`| `RtlGenRandom`\u27e817\u27e9  \nmacOS| `*\u2011apple\u2011darwin`| `getentropy`\u27e818\u27e9  \niOS, tvOS, watchOS| `*\u2011apple\u2011{ios,tvos,watchos}`| `CCRandomGenerateBytes`\u27e819\u27e9  \nFreeBSD| `*\u2011freebsd`| `getrandom`\u27e820\u27e9  \nOpenBSD| `*\u2011openbsd`| `getentropy`\u27e821\u27e9  \nNetBSD| `*\u2011netbsd`| `getrandom`\u27e822\u27e9 if available, otherwise `kern.arandom`\u27e823\u27e9  \nDragonfly BSD| `*\u2011dragonfly`| `getrandom`\u27e824\u27e9  \nSolaris| `*\u2011solaris`| `getrandom`\u27e825\u27e9 with `GRND_RANDOM`  \nillumos| `*\u2011illumos`| `getrandom`\u27e826\u27e9  \nFuchsia OS| `*\u2011fuchsia`| `cprng_draw`\u27e827\u27e9  \nRedox| `*\u2011redox`| `/dev/urandom`  \nHaiku| `*\u2011haiku`| `/dev/urandom` (identical to `/dev/random`)  \nHermit| `*-hermit`| `sys_read_entropy`\u27e828\u27e9  \nHurd| `*-hurd-*`| `getrandom`\u27e829\u27e9  \nSGX| `x86_64\u2011*\u2011sgx`| `RDRAND`\u27e830\u27e9  \nVxWorks| `*\u2011wrs\u2011vxworks\u2011*`| `randABytes` after checking entropy pool initialization with `randSecure`  \nEmscripten| `*\u2011emscripten`| `getentropy`\u27e831\u27e9  \nWASI 0.1| `wasm32\u2011wasip1`| `random_get`\u27e832\u27e9  \nWASI 0.2| `wasm32\u2011wasip2`| `get-random-u64`\u27e833\u27e9  \nSOLID| `*-kmc-solid_*`| `SOLID_RNG_SampleRandomBytes`  \nNintendo 3DS| `*-nintendo-3ds`| `getrandom`\u27e834\u27e9  \nESP-IDF| `*\u2011espidf`| `esp_fill_random`\u27e835\u27e9 WARNING: see \u201cEarly Boot\u201d section below  \nPS Vita| `*-vita-*`| `getentropy`\u27e836\u27e9  \nQNX Neutrino| `*\u2011nto-qnx*`| `/dev/urandom`\u27e837\u27e9 (identical to `/dev/random`)  \nAIX| `*-ibm-aix`| `/dev/urandom`\u27e838\u27e9  \nCygwin| `*-cygwin`| `getrandom`\u27e839\u27e9 (based on `RtlGenRandom`\u27e817\u27e9)  \nPull Requests that add support for new targets to `getrandom` are always welcome.\n#### \u00a7\u27e840\u27e9Opt-in backends\n`getrandom` also provides optional (opt-in) backends, which allow users to customize the source of randomness based on their specific needs:\nBackend name| Target| Target Triple| Implementation  \n---|---|---|---  \n`linux_getrandom`| Linux, Android| `*\u2011linux\u2011*`| `getrandom`\u27e814\u27e9 system call (without `/dev/urandom` fallback). Bumps minimum supported Linux kernel version to 3.17 and Android API level to 23 (Marshmallow).  \n`linux_raw`| Linux, Android| `*\u2011linux\u2011*`| Same as `linux_getrandom`, but uses raw `asm!`-based syscalls instead of `libc`.  \n`rdrand`| x86, x86-64| `x86_64-*`, `i686-*`| `RDRAND`\u27e830\u27e9 instruction  \n`rndr`| AArch64| `aarch64-*`| `RNDR`\u27e841\u27e9 register  \n`wasm_js`| Web Browser, Node.js| `wasm32\u2011unknown\u2011unknown`, `wasm32v1-none`| `Crypto.getRandomValues`\u27e842\u27e9. Requires feature `wasm_js` (see below\u27e843\u27e9).  \n`efi_rng`| UEFI| `*-unknown\u2011uefi`| `EFI_RNG_PROTOCOL`\u27e844\u27e9 with `EFI_RNG_ALGORITHM_RAW` (requires `std` and Nigthly compiler)  \n`custom`| All targets| `*`| User-provided custom implementation (see custom backend\u27e845\u27e9)  \nOpt-in backends can be enabled using the `getrandom_backend` configuration flag. The flag can be set either by specifying the `rustflags` field in `.cargo/config.toml`\u27e846\u27e9:\n```\n# It's recommended to set the flag on a per-target basis:\n[target.wasm32-unknown-unknown]\nrustflags = ['--cfg', 'getrandom_backend=\"wasm_js\"']\n```\n\nOr by using the `RUSTFLAGS` environment variable:\n```\nRUSTFLAGS='--cfg getrandom_backend=\"linux_getrandom\"' cargo build\n```\n\nEnabling an opt-in backend will replace the backend used by default. Doing this for an incorrect target (e.g. using `linux_getrandom` while compiling for a Windows target) will result in a compilation error. Be extremely careful while using opt-in backends, as incorrect configuration may result in vulnerable applications or applications that always panic.\nNote that using an opt-in backend in a library (e.g. for tests or benchmarks) WILL NOT have any effect on its downstream users.\n#### \u00a7\u27e847\u27e9Raw Linux syscall support\nCurrently the `linux_raw` backend supports only targets with stabilized `asm!` macro, i.e. `arm`, `aarch64`, `loongarch64`, `riscv32`, `riscv64`, `s390x`, `x86`, and `x86_64`.\nNote that the raw syscall backend may be slower than backends based on `libc::getrandom`, e.g. it does not implement vDSO optimizations and on `x86` it uses the infamously slow `int 0x80` instruction to perform syscall.\n#### \u00a7\u27e843\u27e9WebAssembly support\nThis crate fully supports the WASI\u27e848\u27e9 and Emscripten\u27e849\u27e9 targets. However, the `wasm32-unknown-unknown` target (i.e. the target used by `wasm-pack`) is not automatically supported since, from the target name alone, we cannot deduce which JavaScript interface should be used (or if JavaScript is available at all).\nTo enable `getrandom`\u2019s functionality on `wasm32-unknown-unknown` using the Web Crypto methods described above\u27e840\u27e9 via `wasm-bindgen`\u27e850\u27e9, do _both_ of the following:\n  * Use the `wasm_js` feature flag, i.e. `getrandom = { version = \"0.3\", features = [\"wasm_js\"] }`. On its own, this only makes the backend available. (As a side effect this will make your `Cargo.lock` significantly larger if you are not already using `wasm-bindgen`\u27e850\u27e9, but otherwise enabling this feature is harmless.)\n  * Set `RUSTFLAGS='--cfg getrandom_backend=\"wasm_js\"'` (see above\u27e840\u27e9).\n\n\nThis backend supports both web browsers (main window and Web Workers) and Node.js (v19 or later) environments.\nWARNING: It is highly recommended to enable the `wasm_js` feature only for binary crates and tests, i.e. avoid unconditionally enabling it in library crates.\n#### \u00a7\u27e845\u27e9Custom backend\nIf this crate does not support your target out of the box or you have to use a non-default entropy source, then you can provide a custom implementation. You need to enable the custom backend as described in the opt-in backends\u27e840\u27e9 section.\nNext, you need to define an `extern` function with the following signature:\n```\nuse getrandom::Error;\n#[no_mangle]\nunsafe extern \"Rust\" fn __getrandom_v03_custom(\n  dest: *mut u8,\n  len: usize,\n) -> Result<(), Error> {\n  todo!()\n}\n```\n\nThis function should, ideally, be defined in the root crate of your project, e.g. in your `main.rs`. This function MUST be defined only once for your project, i.e. upstream library crates SHOULD NOT define it outside of tests and benchmarks. Improper configuration of this backend may result in linking errors.\nThe function accepts a pointer to a buffer that should be filled with random data and its length in bytes. Note that the buffer MAY be uninitialized. On success, the function should return `Ok(())` and fully fill the input buffer; otherwise, it should return an error value.\nWhile wrapping functions which work with byte slices you should fully initialize the buffer before passing it to the function:\n```\nuse getrandom::Error;\nfn my_entropy_source(buf: &mut [u8]) -> Result<(), getrandom::Error> {\n  // ...\n  Ok(())\n}\n#[no_mangle]\nunsafe extern \"Rust\" fn __getrandom_v03_custom(\n  dest: *mut u8,\n  len: usize,\n) -> Result<(), Error> {\n  let buf = unsafe {\n    // fill the buffer with zeros\n    core::ptr::write_bytes(dest, 0, len);\n    // create mutable byte slice\n    core::slice::from_raw_parts_mut(dest, len)\n  };\n  my_entropy_source(buf)\n}\n```\n\nIf you are confident that `getrandom` is not used in your project, but it gets pulled nevertheless by one of your dependencies, then you can use the following custom backend, which always returns the \u201cunsupported\u201d error:\n```\nuse getrandom::Error;\n#[no_mangle]\nunsafe extern \"Rust\" fn __getrandom_v03_custom(\n  dest: *mut u8,\n  len: usize,\n) -> Result<(), Error> {\n  Err(Error::UNSUPPORTED)\n}\n```\n\n#### \u00a7\u27e851\u27e9Platform Support\nThis crate generally supports the same operating system and platform versions that the Rust standard library does. Additional targets may be supported using the opt-in custom backend.\nThis means that as Rust drops support for old versions of operating systems (such as old Linux kernel versions, Android API levels, etc.) in stable releases, `getrandom` may create new patch releases that remove support for outdated platform versions.\n#### \u00a7\u27e852\u27e9`/dev/urandom` fallback on Linux and Android\nOn Linux targets, the `/dev/urandom` fallback is present only if either `target_env` is `musl`, or `target_arch` is one of the following: `aarch64`, `arm`, `powerpc`, `powerpc64`, `s390x`, `x86`, `x86_64`. Other supported targets require\u27e853\u27e9 kernel versions that support the `getrandom` system call, so the fallback is not needed.\nOn Android targets the fallback is present only for the following `target_arch`es: `aarch64`, `arm`, `x86`, `x86_64`. Other `target_arch`es (e.g. RISC-V) require sufficiently high API levels.\nThe fallback can be disabled by enabling the `linux_getrandom` opt-in backend. Note that doing so will bump minimum supported Linux kernel version to 3.17 and Android API level to 23 (Marshmallow).\n#### \u00a7\u27e854\u27e9Early boot\nSometimes, early in the boot process, the OS has not collected enough entropy to securely seed its RNG. This is especially common on virtual machines, where standard \u201crandom\u201d events are hard to come by.\nSome operating system interfaces always block until the RNG is securely seeded. This can take anywhere from a few seconds to more than a minute. A few (Linux, NetBSD and Solaris) offer a choice between blocking and getting an error; in these cases, we always choose to block.\nOn Linux (when the `getrandom` system call is not available), reading from `/dev/urandom` never blocks, even when the OS hasn\u2019t collected enough entropy yet. To avoid returning low-entropy bytes, we first poll `/dev/random` and only switch to `/dev/urandom` once this has succeeded.\nOn OpenBSD, this kind of entropy accounting isn\u2019t available, and on NetBSD, blocking on it is discouraged. On these platforms, nonblocking interfaces are used, even when reliable entropy may not be available. On the platforms where it is used, the reliability of entropy accounting itself isn\u2019t free from controversy. This library provides randomness sourced according to the platform\u2019s best practices, but each platform has its own limits on the grade of randomness it can promise in environments with few sources of entropy.\nOn ESP-IDF, if `esp_fill_random` is used before enabling WiFi, BT, or the voltage noise entropy source (SAR ADC), the Hardware RNG will only be seeded via RC_FAST_CLK. This can occur during early boot unless `bootloader_random_enable()` is called. For more information see the ESP-IDF RNG Docs\u27e855\u27e9 or the RNG section of the ESP32 Technical Reference Manual\u27e856\u27e9.\n### \u00a7\u27e857\u27e9Error handling\nWe always prioritize failure over returning known insecure \u201crandom\u201d bytes. Generally, on supported platforms, failure is highly unlikely, though not impossible. If an error does occur, it is likely that it will occur on every call to `getrandom`. Therefore, after the first successful call, one can be reasonably confident that no errors will occur.\n### \u00a7\u27e858\u27e9Panic handling\nWe strive to eliminate all potential panics from our backend implementations. In other words, when compiled with optimizations enabled, the generated binary code for `getrandom` functions should not contain any panic branches. Even if the platform misbehaves and returns an unexpected result, our code should correctly handle it and return an error, e.g. `Error::UNEXPECTED`\u27e859\u27e9.\n### \u00a7\u27e860\u27e9Sanitizer support\nIf your code uses `fill_uninit`\u27e861\u27e9 and you enable MemorySanitizer\u27e862\u27e9 (i.e. `-Zsanitizer=memory`), we will automatically handle unpoisoning of the destination buffer filled by `fill_uninit`.\nYou can run sanitizer tests for your crate dependent on `getrandom` like this:\n```\nRUSTFLAGS=\"-Zsanitizer=memory\" cargo test -Zbuild-std --target=x86_64-unknown-linux-gnu\n```\n\n### \u00a7\u27e863\u27e9Minimum Supported Rust Version\nThis crate requires Rust 1.63 or later.\n### \u00a7\u27e864\u27e9License\nThe `getrandom` library is distributed under either of\n  * Apache License, Version 2.0\u27e865\u27e9\n  * MIT license\u27e866\u27e9\n\n\nat your option.\n#### \u00a7\u27e867\u27e9Contribution\nUnless you explicitly state otherwise, any contribution intentionally submitted for inclusion in the work by you, as defined in the Apache-2.0 license, shall be dual licensed as above, without any additional terms or conditions.\n## Structs\u00a7\u27e868\u27e9\n\nError\u27e869\u27e9\n    A small and `no_std` compatible error type\n## Functions\u00a7\u27e870\u27e9\n\nfill\u27e871\u27e9\n    Fill `dest` with random bytes from the system\u2019s preferred random number source.\n\nfill_uninit\u27e861\u27e9\n    Fill potentially uninitialized buffer `dest` with random bytes from the system\u2019s preferred random number source and return a mutable reference to those bytes.\n\nu32\u27e872\u27e9\n    Get random `u32` from the system\u2019s preferred random number source.\n\nu64\u27e873\u27e9\n    Get random `u64` from the system\u2019s preferred random number source.\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/getrandom/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/getrandom/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/getrandom/latest/src/getrandom/lib.rs.html#2-143: Source\n\u27e84\u27e9 https://docs.rs/getrandom/latest/getrandom/#getrandom-systems-random-number-generator: \u00a7\n\u27e85\u27e9 https://github.com/rust-random/getrandom/actions/workflows/tests.yml/badge.svg?branch=master: ![Build Status\n\u27e86\u27e9 https://img.shields.io/crates/v/getrandom: ![Crate\n\u27e87\u27e9 https://docs.rs/getrandom/badge.svg: ![Documentation\n\u27e88\u27e9 https://deps.rs/repo/github/rust-random/getrandom/status.svg: ![Dependency Status\n\u27e89\u27e9 https://img.shields.io/crates/d/getrandom: ![Downloads\n\u27e810\u27e9 https://img.shields.io/crates/l/getrandom: ![License\n\u27e811\u27e9 https://crates.io/crates/rand: `rand`\n\u27e812\u27e9 https://docs.rs/getrandom/latest/getrandom/#usage: \u00a7\n\u27e813\u27e9 https://docs.rs/getrandom/latest/getrandom/#supported-targets: \u00a7\n\u27e814\u27e9 https://manned.org/getrandom.2: `getrandom`\n\u27e815\u27e9 https://manned.org/urandom.4: `/dev/urandom`\n\u27e816\u27e9 https://learn.microsoft.com/en-us/windows/win32/seccng/processprng: `ProcessPrng`\n\u27e817\u27e9 https://learn.microsoft.com/en-us/windows/win32/api/ntsecapi/nf-ntsecapi-rtlgenrandom: `RtlGenRandom`\n\u27e818\u27e9 https://www.unix.com/man-page/mojave/2/getentropy/: `getentropy`\n\u27e819\u27e9 https://opensource.apple.com/source/CommonCrypto/CommonCrypto-60074/include/CommonRandom.h.auto.html: `CCRandomGenerateBytes`\n\u27e820\u27e9 https://www.freebsd.org/cgi/man.cgi?query=getrandom&manpath=FreeBSD+12.0-stable: `getrandom`\n\u27e821\u27e9 https://man.openbsd.org/getentropy.2: `getentropy`\n\u27e822\u27e9 https://man.netbsd.org/getrandom.2: `getrandom`\n\u27e823\u27e9 https://man.netbsd.org/sysctl.7: `kern.arandom`\n\u27e824\u27e9 https://leaf.dragonflybsd.org/cgi/web-man?command=getrandom: `getrandom`\n\u27e825\u27e9 https://docs.oracle.com/cd/E88353_01/html/E37841/getrandom-2.html: `getrandom`\n\u27e826\u27e9 https://illumos.org/man/2/getrandom: `getrandom`\n\u27e827\u27e9 https://fuchsia.dev/fuchsia-src/zircon/syscalls/cprng_draw: `cprng_draw`\n\u27e828\u27e9 https://github.com/hermit-os/kernel/blob/315f58ff5efc81d9bf0618af85a59963ff55f8b1/src/syscalls/entropy.rs#L47-L55: `sys_read_entropy`\n\u27e829\u27e9 https://www.gnu.org/software/libc/manual/html_mono/libc.html#index-getrandom: `getrandom`\n\u27e830\u27e9 https://software.intel.com/en-us/articles/intel-digital-random-number-generator-drng-software-implementation-guide: `RDRAND`\n\u27e831\u27e9 https://github.com/emscripten-core/emscripten/pull/12240: `getentropy`\n\u27e832\u27e9 https://github.com/WebAssembly/WASI/blob/snapshot-01/phases/snapshot/docs.md#-random_getbuf-pointeru8-buf_len-size---errno: `random_get`\n\u27e833\u27e9 https://github.com/WebAssembly/WASI/blob/v0.2.1/wasip2/random/random.wit#L23-L28: `get-random-u64`\n\u27e834\u27e9 https://github.com/rust3ds/shim-3ds/commit/b01d2568836dea2a65d05d662f8e5f805c64389d: `getrandom`\n\u27e835\u27e9 https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-reference/system/random.html#functions: `esp_fill_random`\n\u27e836\u27e9 https://github.com/vitasdk/newlib/blob/2d869fe47aaf02b8e52d04e9a2b79d5b210fd016/newlib/libc/sys/vita/getentropy.c: `getentropy`\n\u27e837\u27e9 https://www.qnx.com/developers/docs/7.1/index.html#com.qnx.doc.neutrino.utilities/topic/r/random.html: `/dev/urandom`\n\u27e838\u27e9 https://www.ibm.com/docs/en/aix/7.3?topic=files-random-urandom-devices: `/dev/urandom`\n\u27e839\u27e9 https://github.com/cygwin/cygwin/blob/main/winsup/cygwin/libc/getentropy.cc: `getrandom`\n\u27e840\u27e9 https://docs.rs/getrandom/latest/getrandom/#opt-in-backends: \u00a7\n\u27e841\u27e9 https://developer.arm.com/documentation/ddi0601/2024-06/AArch64-Registers/RNDR--Random-Number: `RNDR`\n\u27e842\u27e9 https://www.w3.org/TR/WebCryptoAPI/#Crypto-method-getRandomValues: `Crypto.getRandomValues`\n\u27e843\u27e9 https://docs.rs/getrandom/latest/getrandom/#webassembly-support: see below\n\u27e844\u27e9 https://uefi.org/specs/UEFI/2.10/37_Secure_Technologies.html#efi-rng-protocol: `EFI_RNG_PROTOCOL`\n\u27e845\u27e9 https://docs.rs/getrandom/latest/getrandom/#custom-backend: custom backend\n\u27e846\u27e9 https://doc.rust-lang.org/cargo/reference/config.html: `.cargo/config.toml`\n\u27e847\u27e9 https://docs.rs/getrandom/latest/getrandom/#raw-linux-syscall-support: \u00a7\n\u27e848\u27e9 https://github.com/WebAssembly/WASI: WASI\n\u27e849\u27e9 https://emscripten.org: Emscripten\n\u27e850\u27e9 https://github.com/rustwasm/wasm-bindgen: `wasm-bindgen`\n\u27e851\u27e9 https://docs.rs/getrandom/latest/getrandom/#platform-support: \u00a7\n\u27e852\u27e9 https://docs.rs/getrandom/latest/getrandom/#devurandom-fallback-on-linux-and-android: \u00a7\n\u27e853\u27e9 https://doc.rust-lang.org/stable/rustc/platform-support.html: require\n\u27e854\u27e9 https://docs.rs/getrandom/latest/getrandom/#early-boot: \u00a7\n\u27e855\u27e9 https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-reference/system/random.html: ESP-IDF RNG Docs\n\u27e856\u27e9 https://www.espressif.com/sites/default/files/documentation/esp32_technical_reference_manual_en.pdf#rng: RNG section of the ESP32 Technical Reference Manual\n\u27e857\u27e9 https://docs.rs/getrandom/latest/getrandom/#error-handling: \u00a7\n\u27e858\u27e9 https://docs.rs/getrandom/latest/getrandom/#panic-handling: \u00a7\n\u27e859\u27e9 https://docs.rs/getrandom/latest/getrandom/struct.Error.html#associatedconstant.UNEXPECTED: associated constant getrandom::Error::UNEXPECTED - `Error::UNEXPECTED`\n\u27e860\u27e9 https://docs.rs/getrandom/latest/getrandom/#sanitizer-support: \u00a7\n\u27e861\u27e9 https://docs.rs/getrandom/latest/getrandom/fn.fill_uninit.html: fn getrandom::fill_uninit - `fill_uninit`\n\u27e862\u27e9 https://doc.rust-lang.org/beta/unstable-book/compiler-flags/sanitizer.html#memorysanitizer: MemorySanitizer\n\u27e863\u27e9 https://docs.rs/getrandom/latest/getrandom/#minimum-supported-rust-version: \u00a7\n\u27e864\u27e9 https://docs.rs/getrandom/latest/getrandom/#license: \u00a7\n\u27e865\u27e9 https://github.com/rust-random/getrandom/blob/master/LICENSE-APACHE: Apache License, Version 2.0\n\u27e866\u27e9 https://github.com/rust-random/getrandom/blob/master/LICENSE-MIT: MIT license\n\u27e867\u27e9 https://docs.rs/getrandom/latest/getrandom/#contribution: \u00a7\n\u27e868\u27e9 https://docs.rs/getrandom/latest/getrandom/#structs: \u00a7\n\u27e869\u27e9 https://docs.rs/getrandom/latest/getrandom/struct.Error.html: struct getrandom::Error - Error\n\u27e870\u27e9 https://docs.rs/getrandom/latest/getrandom/#functions: \u00a7\n\u27e871\u27e9 https://docs.rs/getrandom/latest/getrandom/fn.fill.html: fn getrandom::fill - fill\n\u27e872\u27e9 https://docs.rs/getrandom/latest/getrandom/fn.u32.html: fn getrandom::u32 - u32\n\u27e873\u27e9 https://docs.rs/getrandom/latest/getrandom/fn.u64.html: fn getrandom::u64 - u64\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `getrandom` crate provides a low-level API for securely retrieving random data from the operating system's preferred entropy sources, ensuring cryptographically secure randomness. It supports a wide range of platforms, including Linux, Windows, macOS, WebAssembly, and embedded systems, with optional backends for customization. Key features include functions to fill buffers with random bytes, support for custom entropy sources, and compatibility with `no_std` environments.",
    "feature_summary": null,
    "use_case": "Cryptography",
    "score": 8.5,
    "factual_counterfactual": "### Pair 1: Supported Platforms\n\u2705 Factual: The `getrandom` crate supports a wide range of platforms, including Linux, Windows, macOS, FreeBSD, and WebAssembly through WASI and Emscripten targets.  \n\u274c Counterfactual: The `getrandom` crate only supports Linux-based platforms and does not provide support for Windows or macOS.  \n\n---\n\n### Pair 2: API Usage\n\u2705 Factual: The `getrandom::fill` function can be used to fill a mutable byte buffer with cryptographically secure random data from the operating system's preferred entropy source.  \n\u274c Counterfactual: The `getrandom::fill` function generates random data using a software-based pseudo-random number generator instead of relying on the operating system's entropy sources.  \n\n---\n\n### Pair 3: WebAssembly Support\n\u2705 Factual: The `getrandom` crate supports the `wasm32-unknown-unknown` WebAssembly target when the `wasm_js` feature is enabled, allowing it to use the `Crypto.getRandomValues` API in web browsers and Node.js.  \n\u274c Counterfactual: The `getrandom` crate automatically supports the `wasm32-unknown-unknown` WebAssembly target without requiring any additional configuration or feature flags.",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}