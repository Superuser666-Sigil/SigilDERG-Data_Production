{
    "name": "ed25519-dalek",
    "version": "2.1.1",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/ed25519-dalek/latest/ed25519_dalek/all.html \"show sidebar\")\n# Crate ed25519_dalekCopy item path\n[Settings](https://docs.rs/ed25519-dalek/latest/settings.html)\n[Help](https://docs.rs/ed25519-dalek/latest/help.html)\nSummary[Source](https://docs.rs/ed25519-dalek/latest/src/ed25519_dalek/lib.rs.html#10-293)\nExpand description\nA Rust implementation of ed25519 key generation, signing, and verification.\n## [\u00a7](https://docs.rs/ed25519-dalek/latest/ed25519_dalek/#example)Example\nCreating an ed25519 signature on a message is simple.\nFirst, we need to generate a `SigningKey`, which includes both public and secret halves of an asymmetric key. To do so, we need a cryptographically secure pseudorandom number generator (CSPRNG). For this example, we\u2019ll use the operating system\u2019s builtin PRNG:\n```\nuse rand::rngs::OsRng;\nuse ed25519_dalek::SigningKey;\nuse ed25519_dalek::Signature;\nlet mut csprng = OsRng;\nlet signing_key: SigningKey = SigningKey::generate(&mut csprng);\n```\n\nWe can now use this `signing_key` to sign a message:\n```\nuse ed25519_dalek::{Signature, Signer};\nlet message: &[u8] = b\"This is a test of the tsunami alert system.\";\nlet signature: Signature = signing_key.sign(message);\n```\n\nAs well as to verify that this is, indeed, a valid signature on that `message`:\n```\nuse ed25519_dalek::Verifier;\nassert!(signing_key.verify(message, &signature).is_ok());\n```\n\nAnyone else, given the `public` half of the `signing_key` can also easily verify this signature:\n```\nuse ed25519_dalek::{VerifyingKey, Verifier};\nlet verifying_key: VerifyingKey = signing_key.verifying_key();\nassert!(verifying_key.verify(message, &signature).is_ok());\n```\n\n### [\u00a7](https://docs.rs/ed25519-dalek/latest/ed25519_dalek/#serialisation)Serialisation\n`VerifyingKey`s, `SecretKey`s, `SigningKey`s, and `Signature`s can be serialised into byte-arrays by calling `.to_bytes()`. It\u2019s perfectly acceptable and safe to transfer and/or store those bytes. (Of course, never transfer your secret key to anyone else, since they will only need the public key to verify your signatures!)\n```\nuse ed25519_dalek::{PUBLIC_KEY_LENGTH, SECRET_KEY_LENGTH, KEYPAIR_LENGTH, SIGNATURE_LENGTH};\nlet verifying_key_bytes: [u8; PUBLIC_KEY_LENGTH] = signing_key.verifying_key().to_bytes();\nlet secret_key_bytes: [u8; SECRET_KEY_LENGTH] = signing_key.to_bytes();\nlet signing_key_bytes:  [u8; KEYPAIR_LENGTH]  = signing_key.to_keypair_bytes();\nlet signature_bytes: [u8; SIGNATURE_LENGTH] = signature.to_bytes();\n```\n\nAnd similarly, decoded from bytes with `::from_bytes()`:\n```\nlet verifying_key: VerifyingKey = VerifyingKey::from_bytes(&verifying_key_bytes)?;\nlet signing_key: SigningKey = SigningKey::from_bytes(&signing_key_bytes);\nlet signature: Signature = Signature::try_from(&signature_bytes[..])?;\n```\n\n#### [\u00a7](https://docs.rs/ed25519-dalek/latest/ed25519_dalek/#pkcs8-key-encoding)PKCS#8 Key Encoding\nPKCS#8 is a private key format with support for multiple algorithms. It can be encoded as binary (DER) or text (PEM).\nYou can recognize PEM-encoded PKCS#8 keys by the following:\n```\n-----BEGIN PRIVATE KEY-----\n```\n\nTo use PKCS#8, you need to enable the `pkcs8` crate feature.\nThe following traits can be used to decode/encode [`SigningKey`](https://docs.rs/ed25519-dalek/latest/ed25519_dalek/struct.SigningKey.html \"struct ed25519_dalek::SigningKey\") and [`VerifyingKey`](https://docs.rs/ed25519-dalek/latest/ed25519_dalek/struct.VerifyingKey.html \"struct ed25519_dalek::VerifyingKey\") as PKCS#8. Note that [`pkcs8`](https://docs.rs/ed25519-dalek/latest/ed25519_dalek/pkcs8/index.html \"mod ed25519_dalek::pkcs8\") is re-exported from the toplevel of the crate:\n  * [`pkcs8::DecodePrivateKey`](https://docs.rs/ed25519-dalek/latest/ed25519_dalek/pkcs8/trait.DecodePrivateKey.html \"trait ed25519_dalek::pkcs8::DecodePrivateKey\"): decode private keys from PKCS#8\n  * [`pkcs8::EncodePrivateKey`](https://docs.rs/ed25519-dalek/latest/ed25519_dalek/pkcs8/trait.EncodePrivateKey.html \"trait ed25519_dalek::pkcs8::EncodePrivateKey\"): encode private keys to PKCS#8\n  * [`pkcs8::DecodePublicKey`](https://docs.rs/ed25519-dalek/latest/ed25519_dalek/pkcs8/trait.DecodePublicKey.html \"trait ed25519_dalek::pkcs8::DecodePublicKey\"): decode public keys from PKCS#8\n  * [`pkcs8::EncodePublicKey`](https://docs.rs/ed25519-dalek/latest/ed25519_dalek/pkcs8/trait.EncodePublicKey.html \"trait ed25519_dalek::pkcs8::EncodePublicKey\"): encode public keys to PKCS#8\n\n\n##### [\u00a7](https://docs.rs/ed25519-dalek/latest/ed25519_dalek/#example-1)Example\nNOTE: this requires the `pem` crate feature.\n```\nuse ed25519_dalek::{VerifyingKey, pkcs8::DecodePublicKey};\nlet pem = \"-----BEGIN PUBLIC KEY-----\nMCowBQYDK2VwAyEAGb9ECWmEzf6FQbrBZ9w7lshQhqowtrbLDFw4rXAxZuE=\n-----END PUBLIC KEY-----\";\nlet verifying_key = VerifyingKey::from_public_key_pem(pem)\n  .expect(\"invalid public key PEM\");\n```\n\n#### [\u00a7](https://docs.rs/ed25519-dalek/latest/ed25519_dalek/#using-serde)Using Serde\nIf you prefer the bytes to be wrapped in another serialisation format, all types additionally come with built-in [serde](https://serde.rs) support by building `ed25519-dalek` via:\n```\n$ cargo build --features=\"serde\"\n```\n\nThey can be then serialised into any of the wire formats which serde supports. For example, using [bincode](https://github.com/TyOverby/bincode):\n```\nuse bincode::serialize;\nlet encoded_verifying_key: Vec<u8> = serialize(&verifying_key).unwrap();\nlet encoded_signature: Vec<u8> = serialize(&signature).unwrap();\n```\n\nAfter sending the `encoded_verifying_key` and `encoded_signature`, the recipient may deserialise them and verify:\n```\nuse bincode::deserialize;\nlet message: &[u8] = b\"This is a test of the tsunami alert system.\";\nlet decoded_verifying_key: VerifyingKey = deserialize(&encoded_verifying_key).unwrap();\nlet decoded_signature: Signature = deserialize(&encoded_signature).unwrap();\nlet verified: bool = decoded_verifying_key.verify(&message, &decoded_signature).is_ok();\nassert!(verified);\n```\n\n## Re-exports[\u00a7](https://docs.rs/ed25519-dalek/latest/ed25519_dalek/#reexports)\n\n`pub use ed25519[](https://docs.rs/ed25519/2.2.3/x86_64-unknown-linux-gnu/ed25519/index.html \"mod ed25519\");`\n\n## Modules[\u00a7](https://docs.rs/ed25519-dalek/latest/ed25519_dalek/#modules)\n\n[hazmat](https://docs.rs/ed25519-dalek/latest/ed25519_dalek/hazmat/index.html \"mod ed25519_dalek::hazmat\")`hazmat`\n    Low-level interfaces to ed25519 functions\n\n[pkcs8](https://docs.rs/ed25519-dalek/latest/ed25519_dalek/pkcs8/index.html \"mod ed25519_dalek::pkcs8\")`pkcs8`\n    PKCS#8 private key support.\n## Structs[\u00a7](https://docs.rs/ed25519-dalek/latest/ed25519_dalek/#structs)\n\n[Context](https://docs.rs/ed25519-dalek/latest/ed25519_dalek/struct.Context.html \"struct ed25519_dalek::Context\")`digest`\n    Ed25519 contexts as used by Ed25519ph.\n\n[Signature](https://docs.rs/ed25519-dalek/latest/ed25519_dalek/struct.Signature.html \"struct ed25519_dalek::Signature\")\n    Ed25519 signature.\n\n[SigningKey](https://docs.rs/ed25519-dalek/latest/ed25519_dalek/struct.SigningKey.html \"struct ed25519_dalek::SigningKey\")\n    ed25519 signing key which can be used to produce signatures.\n\n[VerifyingKey](https://docs.rs/ed25519-dalek/latest/ed25519_dalek/struct.VerifyingKey.html \"struct ed25519_dalek::VerifyingKey\")\n    An ed25519 public key.\n## Constants[\u00a7](https://docs.rs/ed25519-dalek/latest/ed25519_dalek/#constants)\n\n[EXPANDED_SECRET_KEY_LENGTH](https://docs.rs/ed25519-dalek/latest/ed25519_dalek/constant.EXPANDED_SECRET_KEY_LENGTH.html \"constant ed25519_dalek::EXPANDED_SECRET_KEY_LENGTH\")\n    The length of an \u201cexpanded\u201d ed25519 key, `ExpandedSecretKey`, in bytes.\n\n[KEYPAIR_LENGTH](https://docs.rs/ed25519-dalek/latest/ed25519_dalek/constant.KEYPAIR_LENGTH.html \"constant ed25519_dalek::KEYPAIR_LENGTH\")\n    The length of an ed25519 `Keypair`, in bytes.\n\n[PUBLIC_KEY_LENGTH](https://docs.rs/ed25519-dalek/latest/ed25519_dalek/constant.PUBLIC_KEY_LENGTH.html \"constant ed25519_dalek::PUBLIC_KEY_LENGTH\")\n    The length of an ed25519 `PublicKey`, in bytes.\n\n[SECRET_KEY_LENGTH](https://docs.rs/ed25519-dalek/latest/ed25519_dalek/constant.SECRET_KEY_LENGTH.html \"constant ed25519_dalek::SECRET_KEY_LENGTH\")\n    The length of a ed25519 `SecretKey`, in bytes.\n\n[SIGNATURE_LENGTH](https://docs.rs/ed25519-dalek/latest/ed25519_dalek/constant.SIGNATURE_LENGTH.html \"constant ed25519_dalek::SIGNATURE_LENGTH\")\n    The length of a ed25519 `Signature`, in bytes.\n## Traits[\u00a7](https://docs.rs/ed25519-dalek/latest/ed25519_dalek/#traits)\n\n[Digest](https://docs.rs/ed25519-dalek/latest/ed25519_dalek/trait.Digest.html \"trait ed25519_dalek::Digest\")\n    Convenience wrapper trait covering functionality of cryptographic hash functions with fixed output size.\n\n[DigestSigner](https://docs.rs/ed25519-dalek/latest/ed25519_dalek/trait.DigestSigner.html \"trait ed25519_dalek::DigestSigner\")`digest`\n    Sign the given prehashed message [`Digest`](https://docs.rs/ed25519-dalek/latest/ed25519_dalek/trait.Digest.html \"trait ed25519_dalek::Digest\") using `Self`.\n\n[DigestVerifier](https://docs.rs/ed25519-dalek/latest/ed25519_dalek/trait.DigestVerifier.html \"trait ed25519_dalek::DigestVerifier\")`digest`\n    Verify the provided signature for the given prehashed message [`Digest`](https://docs.rs/ed25519-dalek/latest/ed25519_dalek/trait.Digest.html \"trait ed25519_dalek::Digest\") is authentic.\n\n[Signer](https://docs.rs/ed25519-dalek/latest/ed25519_dalek/trait.Signer.html \"trait ed25519_dalek::Signer\")\n    Sign the provided message bytestring using `Self` (e.g. a cryptographic key or connection to an HSM), returning a digital signature.\n\n[Verifier](https://docs.rs/ed25519-dalek/latest/ed25519_dalek/trait.Verifier.html \"trait ed25519_dalek::Verifier\")\n    Verify the provided message bytestring using `Self` (e.g. a public key)\n## Functions[\u00a7](https://docs.rs/ed25519-dalek/latest/ed25519_dalek/#functions)\n\n[verify_batch](https://docs.rs/ed25519-dalek/latest/ed25519_dalek/fn.verify_batch.html \"fn ed25519_dalek::verify_batch\")`batch`\n    Verify a batch of `signatures` on `messages` with their respective `verifying_keys`.\n## Type Aliases[\u00a7](https://docs.rs/ed25519-dalek/latest/ed25519_dalek/#types)\n\n[SecretKey](https://docs.rs/ed25519-dalek/latest/ed25519_dalek/type.SecretKey.html \"type ed25519_dalek::SecretKey\")\n    ed25519 secret key as defined in [RFC8032 \u00a7 5.1.5](https://www.rfc-editor.org/rfc/rfc8032#section-5.1.5):\n\n[Sha512](https://docs.rs/ed25519-dalek/latest/ed25519_dalek/type.Sha512.html \"type ed25519_dalek::Sha512\")`digest`\n    SHA-512 hasher.\n\n[SignatureError](https://docs.rs/ed25519-dalek/latest/ed25519_dalek/type.SignatureError.html \"type ed25519_dalek::SignatureError\")\n    Errors which may occur while processing signatures and keypairs.\n",
        "markdown_with_citations": "[](https://docs.rs/ed25519-dalek/latest/ed25519_dalek/all.html \"show sidebar\")\n# Crate ed25519_dalekCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nA Rust implementation of ed25519 key generation, signing, and verification.\n## \u00a7\u27e84\u27e9Example\nCreating an ed25519 signature on a message is simple.\nFirst, we need to generate a `SigningKey`, which includes both public and secret halves of an asymmetric key. To do so, we need a cryptographically secure pseudorandom number generator (CSPRNG). For this example, we\u2019ll use the operating system\u2019s builtin PRNG:\n```\nuse rand::rngs::OsRng;\nuse ed25519_dalek::SigningKey;\nuse ed25519_dalek::Signature;\nlet mut csprng = OsRng;\nlet signing_key: SigningKey = SigningKey::generate(&mut csprng);\n```\n\nWe can now use this `signing_key` to sign a message:\n```\nuse ed25519_dalek::{Signature, Signer};\nlet message: &[u8] = b\"This is a test of the tsunami alert system.\";\nlet signature: Signature = signing_key.sign(message);\n```\n\nAs well as to verify that this is, indeed, a valid signature on that `message`:\n```\nuse ed25519_dalek::Verifier;\nassert!(signing_key.verify(message, &signature).is_ok());\n```\n\nAnyone else, given the `public` half of the `signing_key` can also easily verify this signature:\n```\nuse ed25519_dalek::{VerifyingKey, Verifier};\nlet verifying_key: VerifyingKey = signing_key.verifying_key();\nassert!(verifying_key.verify(message, &signature).is_ok());\n```\n\n### \u00a7\u27e85\u27e9Serialisation\n`VerifyingKey`s, `SecretKey`s, `SigningKey`s, and `Signature`s can be serialised into byte-arrays by calling `.to_bytes()`. It\u2019s perfectly acceptable and safe to transfer and/or store those bytes. (Of course, never transfer your secret key to anyone else, since they will only need the public key to verify your signatures!)\n```\nuse ed25519_dalek::{PUBLIC_KEY_LENGTH, SECRET_KEY_LENGTH, KEYPAIR_LENGTH, SIGNATURE_LENGTH};\nlet verifying_key_bytes: [u8; PUBLIC_KEY_LENGTH] = signing_key.verifying_key().to_bytes();\nlet secret_key_bytes: [u8; SECRET_KEY_LENGTH] = signing_key.to_bytes();\nlet signing_key_bytes:  [u8; KEYPAIR_LENGTH]  = signing_key.to_keypair_bytes();\nlet signature_bytes: [u8; SIGNATURE_LENGTH] = signature.to_bytes();\n```\n\nAnd similarly, decoded from bytes with `::from_bytes()`:\n```\nlet verifying_key: VerifyingKey = VerifyingKey::from_bytes(&verifying_key_bytes)?;\nlet signing_key: SigningKey = SigningKey::from_bytes(&signing_key_bytes);\nlet signature: Signature = Signature::try_from(&signature_bytes[..])?;\n```\n\n#### \u00a7\u27e86\u27e9PKCS#8 Key Encoding\nPKCS#8 is a private key format with support for multiple algorithms. It can be encoded as binary (DER) or text (PEM).\nYou can recognize PEM-encoded PKCS#8 keys by the following:\n```\n-----BEGIN PRIVATE KEY-----\n```\n\nTo use PKCS#8, you need to enable the `pkcs8` crate feature.\nThe following traits can be used to decode/encode `SigningKey`\u27e87\u27e9 and `VerifyingKey`\u27e88\u27e9 as PKCS#8. Note that `pkcs8`\u27e89\u27e9 is re-exported from the toplevel of the crate:\n  * `pkcs8::DecodePrivateKey`\u27e810\u27e9: decode private keys from PKCS#8\n  * `pkcs8::EncodePrivateKey`\u27e811\u27e9: encode private keys to PKCS#8\n  * `pkcs8::DecodePublicKey`\u27e812\u27e9: decode public keys from PKCS#8\n  * `pkcs8::EncodePublicKey`\u27e813\u27e9: encode public keys to PKCS#8\n\n\n##### \u00a7\u27e814\u27e9Example\nNOTE: this requires the `pem` crate feature.\n```\nuse ed25519_dalek::{VerifyingKey, pkcs8::DecodePublicKey};\nlet pem = \"-----BEGIN PUBLIC KEY-----\nMCowBQYDK2VwAyEAGb9ECWmEzf6FQbrBZ9w7lshQhqowtrbLDFw4rXAxZuE=\n-----END PUBLIC KEY-----\";\nlet verifying_key = VerifyingKey::from_public_key_pem(pem)\n  .expect(\"invalid public key PEM\");\n```\n\n#### \u00a7\u27e815\u27e9Using Serde\nIf you prefer the bytes to be wrapped in another serialisation format, all types additionally come with built-in serde\u27e816\u27e9 support by building `ed25519-dalek` via:\n```\n$ cargo build --features=\"serde\"\n```\n\nThey can be then serialised into any of the wire formats which serde supports. For example, using bincode\u27e817\u27e9:\n```\nuse bincode::serialize;\nlet encoded_verifying_key: Vec<u8> = serialize(&verifying_key).unwrap();\nlet encoded_signature: Vec<u8> = serialize(&signature).unwrap();\n```\n\nAfter sending the `encoded_verifying_key` and `encoded_signature`, the recipient may deserialise them and verify:\n```\nuse bincode::deserialize;\nlet message: &[u8] = b\"This is a test of the tsunami alert system.\";\nlet decoded_verifying_key: VerifyingKey = deserialize(&encoded_verifying_key).unwrap();\nlet decoded_signature: Signature = deserialize(&encoded_signature).unwrap();\nlet verified: bool = decoded_verifying_key.verify(&message, &decoded_signature).is_ok();\nassert!(verified);\n```\n\n## Re-exports\u00a7\u27e818\u27e9\n\n`pub use ed25519[](https://docs.rs/ed25519/2.2.3/x86_64-unknown-linux-gnu/ed25519/index.html \"mod ed25519\");`\n\n## Modules\u00a7\u27e819\u27e9\n\nhazmat\u27e820\u27e9`hazmat`\n    Low-level interfaces to ed25519 functions\n\npkcs8\u27e89\u27e9`pkcs8`\n    PKCS#8 private key support.\n## Structs\u00a7\u27e821\u27e9\n\nContext\u27e822\u27e9`digest`\n    Ed25519 contexts as used by Ed25519ph.\n\nSignature\u27e823\u27e9\n    Ed25519 signature.\n\nSigningKey\u27e87\u27e9\n    ed25519 signing key which can be used to produce signatures.\n\nVerifyingKey\u27e88\u27e9\n    An ed25519 public key.\n## Constants\u00a7\u27e824\u27e9\n\nEXPANDED_SECRET_KEY_LENGTH\u27e825\u27e9\n    The length of an \u201cexpanded\u201d ed25519 key, `ExpandedSecretKey`, in bytes.\n\nKEYPAIR_LENGTH\u27e826\u27e9\n    The length of an ed25519 `Keypair`, in bytes.\n\nPUBLIC_KEY_LENGTH\u27e827\u27e9\n    The length of an ed25519 `PublicKey`, in bytes.\n\nSECRET_KEY_LENGTH\u27e828\u27e9\n    The length of a ed25519 `SecretKey`, in bytes.\n\nSIGNATURE_LENGTH\u27e829\u27e9\n    The length of a ed25519 `Signature`, in bytes.\n## Traits\u00a7\u27e830\u27e9\n\nDigest\u27e831\u27e9\n    Convenience wrapper trait covering functionality of cryptographic hash functions with fixed output size.\n\nDigestSigner\u27e832\u27e9`digest`\n    Sign the given prehashed message `Digest`\u27e831\u27e9 using `Self`.\n\nDigestVerifier\u27e833\u27e9`digest`\n    Verify the provided signature for the given prehashed message `Digest`\u27e831\u27e9 is authentic.\n\nSigner\u27e834\u27e9\n    Sign the provided message bytestring using `Self` (e.g. a cryptographic key or connection to an HSM), returning a digital signature.\n\nVerifier\u27e835\u27e9\n    Verify the provided message bytestring using `Self` (e.g. a public key)\n## Functions\u00a7\u27e836\u27e9\n\nverify_batch\u27e837\u27e9`batch`\n    Verify a batch of `signatures` on `messages` with their respective `verifying_keys`.\n## Type Aliases\u00a7\u27e838\u27e9\n\nSecretKey\u27e839\u27e9\n    ed25519 secret key as defined in RFC8032 \u00a7 5.1.5\u27e840\u27e9:\n\nSha512\u27e841\u27e9`digest`\n    SHA-512 hasher.\n\nSignatureError\u27e842\u27e9\n    Errors which may occur while processing signatures and keypairs.\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/ed25519-dalek/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/ed25519-dalek/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/ed25519-dalek/latest/src/ed25519_dalek/lib.rs.html#10-293: Source\n\u27e84\u27e9 https://docs.rs/ed25519-dalek/latest/ed25519_dalek/#example: \u00a7\n\u27e85\u27e9 https://docs.rs/ed25519-dalek/latest/ed25519_dalek/#serialisation: \u00a7\n\u27e86\u27e9 https://docs.rs/ed25519-dalek/latest/ed25519_dalek/#pkcs8-key-encoding: \u00a7\n\u27e87\u27e9 https://docs.rs/ed25519-dalek/latest/ed25519_dalek/struct.SigningKey.html: struct ed25519_dalek::SigningKey - `SigningKey`\n\u27e88\u27e9 https://docs.rs/ed25519-dalek/latest/ed25519_dalek/struct.VerifyingKey.html: struct ed25519_dalek::VerifyingKey - `VerifyingKey`\n\u27e89\u27e9 https://docs.rs/ed25519-dalek/latest/ed25519_dalek/pkcs8/index.html: mod ed25519_dalek::pkcs8 - `pkcs8`\n\u27e810\u27e9 https://docs.rs/ed25519-dalek/latest/ed25519_dalek/pkcs8/trait.DecodePrivateKey.html: trait ed25519_dalek::pkcs8::DecodePrivateKey - `pkcs8::DecodePrivateKey`\n\u27e811\u27e9 https://docs.rs/ed25519-dalek/latest/ed25519_dalek/pkcs8/trait.EncodePrivateKey.html: trait ed25519_dalek::pkcs8::EncodePrivateKey - `pkcs8::EncodePrivateKey`\n\u27e812\u27e9 https://docs.rs/ed25519-dalek/latest/ed25519_dalek/pkcs8/trait.DecodePublicKey.html: trait ed25519_dalek::pkcs8::DecodePublicKey - `pkcs8::DecodePublicKey`\n\u27e813\u27e9 https://docs.rs/ed25519-dalek/latest/ed25519_dalek/pkcs8/trait.EncodePublicKey.html: trait ed25519_dalek::pkcs8::EncodePublicKey - `pkcs8::EncodePublicKey`\n\u27e814\u27e9 https://docs.rs/ed25519-dalek/latest/ed25519_dalek/#example-1: \u00a7\n\u27e815\u27e9 https://docs.rs/ed25519-dalek/latest/ed25519_dalek/#using-serde: \u00a7\n\u27e816\u27e9 https://serde.rs: serde\n\u27e817\u27e9 https://github.com/TyOverby/bincode: bincode\n\u27e818\u27e9 https://docs.rs/ed25519-dalek/latest/ed25519_dalek/#reexports: \u00a7\n\u27e819\u27e9 https://docs.rs/ed25519-dalek/latest/ed25519_dalek/#modules: \u00a7\n\u27e820\u27e9 https://docs.rs/ed25519-dalek/latest/ed25519_dalek/hazmat/index.html: mod ed25519_dalek::hazmat - hazmat\n\u27e821\u27e9 https://docs.rs/ed25519-dalek/latest/ed25519_dalek/#structs: \u00a7\n\u27e822\u27e9 https://docs.rs/ed25519-dalek/latest/ed25519_dalek/struct.Context.html: struct ed25519_dalek::Context - Context\n\u27e823\u27e9 https://docs.rs/ed25519-dalek/latest/ed25519_dalek/struct.Signature.html: struct ed25519_dalek::Signature - Signature\n\u27e824\u27e9 https://docs.rs/ed25519-dalek/latest/ed25519_dalek/#constants: \u00a7\n\u27e825\u27e9 https://docs.rs/ed25519-dalek/latest/ed25519_dalek/constant.EXPANDED_SECRET_KEY_LENGTH.html: constant ed25519_dalek::EXPANDED_SECRET_KEY_LENGTH - EXPANDED_SECRET_KEY_LENGTH\n\u27e826\u27e9 https://docs.rs/ed25519-dalek/latest/ed25519_dalek/constant.KEYPAIR_LENGTH.html: constant ed25519_dalek::KEYPAIR_LENGTH - KEYPAIR_LENGTH\n\u27e827\u27e9 https://docs.rs/ed25519-dalek/latest/ed25519_dalek/constant.PUBLIC_KEY_LENGTH.html: constant ed25519_dalek::PUBLIC_KEY_LENGTH - PUBLIC_KEY_LENGTH\n\u27e828\u27e9 https://docs.rs/ed25519-dalek/latest/ed25519_dalek/constant.SECRET_KEY_LENGTH.html: constant ed25519_dalek::SECRET_KEY_LENGTH - SECRET_KEY_LENGTH\n\u27e829\u27e9 https://docs.rs/ed25519-dalek/latest/ed25519_dalek/constant.SIGNATURE_LENGTH.html: constant ed25519_dalek::SIGNATURE_LENGTH - SIGNATURE_LENGTH\n\u27e830\u27e9 https://docs.rs/ed25519-dalek/latest/ed25519_dalek/#traits: \u00a7\n\u27e831\u27e9 https://docs.rs/ed25519-dalek/latest/ed25519_dalek/trait.Digest.html: trait ed25519_dalek::Digest - Digest\n\u27e832\u27e9 https://docs.rs/ed25519-dalek/latest/ed25519_dalek/trait.DigestSigner.html: trait ed25519_dalek::DigestSigner - DigestSigner\n\u27e833\u27e9 https://docs.rs/ed25519-dalek/latest/ed25519_dalek/trait.DigestVerifier.html: trait ed25519_dalek::DigestVerifier - DigestVerifier\n\u27e834\u27e9 https://docs.rs/ed25519-dalek/latest/ed25519_dalek/trait.Signer.html: trait ed25519_dalek::Signer - Signer\n\u27e835\u27e9 https://docs.rs/ed25519-dalek/latest/ed25519_dalek/trait.Verifier.html: trait ed25519_dalek::Verifier - Verifier\n\u27e836\u27e9 https://docs.rs/ed25519-dalek/latest/ed25519_dalek/#functions: \u00a7\n\u27e837\u27e9 https://docs.rs/ed25519-dalek/latest/ed25519_dalek/fn.verify_batch.html: fn ed25519_dalek::verify_batch - verify_batch\n\u27e838\u27e9 https://docs.rs/ed25519-dalek/latest/ed25519_dalek/#types: \u00a7\n\u27e839\u27e9 https://docs.rs/ed25519-dalek/latest/ed25519_dalek/type.SecretKey.html: type ed25519_dalek::SecretKey - SecretKey\n\u27e840\u27e9 https://www.rfc-editor.org/rfc/rfc8032#section-5.1.5: RFC8032 \u00a7 5.1.5\n\u27e841\u27e9 https://docs.rs/ed25519-dalek/latest/ed25519_dalek/type.Sha512.html: type ed25519_dalek::Sha512 - Sha512\n\u27e842\u27e9 https://docs.rs/ed25519-dalek/latest/ed25519_dalek/type.SignatureError.html: type ed25519_dalek::SignatureError - SignatureError\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `ed25519-dalek` crate provides a Rust implementation of Ed25519 for key generation, signing, and signature verification. It supports serialization/deserialization of keys and signatures, PKCS#8 key encoding, and optional integration with Serde for flexible data formats. Additional features include batch signature verification and low-level cryptographic interfaces via its `hazmat` module.",
    "feature_summary": null,
    "use_case": "Cryptography",
    "score": 8.0,
    "factual_counterfactual": "### Pair 1: Key Generation and Signing\n\u2705 **Factual**: The `ed25519-dalek` crate allows users to generate an Ed25519 signing key using a cryptographically secure pseudorandom number generator (CSPRNG), such as the operating system's `OsRng`.  \n\u274c **Counterfactual**: The `ed25519-dalek` crate automatically generates signing keys without requiring a pseudorandom number generator, making it suitable for deterministic environments.\n\n---\n\n### Pair 2: Serialization Support\n\u2705 **Factual**: The `ed25519-dalek` crate provides serialization methods for `SigningKey`, `VerifyingKey`, and `Signature` objects, allowing them to be safely converted to and from byte arrays for storage or transfer.  \n\u274c **Counterfactual**: The `ed25519-dalek` crate does not support serialization of cryptographic keys or signatures, requiring users to implement custom serialization logic.\n\n---\n\n### Pair 3: Batch Verification\n\u2705 **Factual**: The `verify_batch` function in `ed25519-dalek` enables efficient verification of multiple signatures on different messages using their respective public keys.  \n\u274c **Counterfactual**: The `ed25519-dalek` crate only supports single-message signature verification and does not include functionality for batch verification.",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}