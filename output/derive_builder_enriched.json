{
    "name": "derive_builder",
    "version": "0.20.2",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/derive_builder/latest/derive_builder/all.html \"show sidebar\")\n# Crate derive_builderCopy item path\n[Settings](https://docs.rs/derive_builder/latest/settings.html)\n[Help](https://docs.rs/derive_builder/latest/help.html)\nSummary[Source](https://docs.rs/derive_builder/latest/src/derive_builder/lib.rs.html#1-717)\nExpand description\nDerive a builder for a struct\nThis crate implements the [builder pattern](https://web.archive.org/web/20170701044756/https://aturon.github.io/ownership/builders.html) for you. Just apply `#[derive(Builder)]` to a struct `Foo`, and it will derive an additional struct `FooBuilder` with **setter** -methods for all fields and a **build** -method \u2014 the way you want it.\n## [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#quick-start)Quick Start\nAdd `derive_builder` as a dependency to you `Cargo.toml`.\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#what-you-write)What you write\n```\nuse derive_builder::Builder;\n#[derive(Builder)]\nstruct Lorem {\n  ipsum: u32,\n  // ..\n}\n```\n\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#what-you-get)What you get\n```\n#[derive(Clone, Default)]\nstruct LoremBuilder {\n  ipsum: Option<u32>,\n}\n#[allow(dead_code)]\nimpl LoremBuilder {\n  pub fn ipsum(&mut self, value: u32) -> &mut Self {\n    let mut new = self;\n    new.ipsum = Some(value);\n    new\n  }\n  fn build(&self) -> Result<Lorem, LoremBuilderError> {\n    Ok(Lorem {\n      ipsum: Clone::clone(self.ipsum\n        .as_ref()\n        .ok_or(LoremBuilderError::from(UninitializedFieldError::new(\"ipsum\")))?),\n    })\n  }\n}\n```\n\nBy default all generated setter-methods take and return `&mut self` (aka _non-consuming_ builder pattern). Accordingly, the build method also takes a reference by default.\nYou can easily opt into different patterns and control many other aspects.\nThe build method returns `Result<T, E>`, where `T` is the struct you started with and E is a generated builder error type. It returns `Err` if you didn\u2019t initialize all fields and no default values were provided.\n## [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#builder-patterns)Builder Patterns\nLet\u2019s look again at the example above. You can now build structs like this:\n```\nlet x: Lorem = LoremBuilder::default().ipsum(42).build()?;\n```\n\nOk, _chaining_ method calls is nice, but what if `ipsum(42)` should only happen if `geek = true`?\nSo let\u2019s make this call conditional\n```\nlet mut builder = LoremBuilder::default();\nif geek {\n  builder.ipsum(42);\n}\nlet x: Lorem = builder.build()?;\n```\n\nNow it comes in handy that our setter methods take and return mutable references. Otherwise we would need to write something more clumsy like `builder = builder.ipsum(42)` to reassign the return value each time we have to call a setter conditionally.\nSetters with mutable references are therefore a convenient default for the builder pattern in Rust.\nBut this is a free world and the choice is still yours!\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#owned-aka-consuming)Owned, aka Consuming\nPrecede your struct (or field) with `#[builder(pattern = \"owned\")]` to opt into this pattern. Builders generated with this pattern do not automatically derive `Clone`, which allows builders to be generated for structs with fields that do not derive `Clone`.\n  * Setters take and return `self`.\n  * PRO: Setter calls and final build method can be chained.\n  * CON: If you don\u2019t chain your calls, you have to create a reference to each return value, e.g. `builder = builder.ipsum(42)`.\n\n\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#mutable-aka-non-consuming-recommended)Mutable, aka Non-Consuming (recommended)\nThis pattern is recommended and active by default if you don\u2019t specify anything else. You can precede your struct (or field) with `#[builder(pattern = \"mutable\")]` to make this choice explicit.\n  * Setters take and return `&mut self`.\n  * PRO: Setter calls and final build method can be chained.\n  * CON: The build method must clone or copy data to create something owned out of a mutable reference. Otherwise it could not be used in a chain. **(*)**\n\n\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#immutable)Immutable\nPrecede your struct (or field) with `#[builder(pattern = \"immutable\")]` to opt into this pattern.\n  * Setters take and return `&self`.\n  * PRO: Setter calls and final build method can be chained.\n  * CON: If you don\u2019t chain your calls, you have to create a reference to each return value, e.g. `builder = builder.ipsum(42)`.\n  * CON: The build method _and each setter_ must clone or copy data to create something owned out of a reference. **(*)**\n\n\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#-performance-considerations)(*) Performance Considerations\nLuckily Rust is clever enough to optimize these clone-calls away in release builds for your every-day use cases. Thats quite a safe bet - we checked this for you. ;-) Switching to consuming signatures (=`self`) is unlikely to give you any performance gain, but very likely to restrict your API for non-chained use cases.\n## [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#more-features)More Features\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#hidden-fields)Hidden Fields\nYou can hide fields by skipping their setters on (and presence in) the builder struct.\n  * Opt-out \u2014 skip setters via `#[builder(setter(skip))]` on individual fields.\n  * Opt-in \u2014 set `#[builder(setter(skip))]` on the whole struct and enable individual setters via `#[builder(setter)]`.\n\n\nThe types of skipped fields must implement `Default`.\n```\n#[derive(Builder)]\nstruct HiddenField {\n  setter_present: u32,\n  #[builder(setter(skip))]\n  setter_skipped: u32,\n}\n```\n\nAlternatively, you can use the more verbose form:\n  * `#[builder(setter(skip = true))]`\n  * `#[builder(setter(skip = false))]`\n\n\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#custom-setters-skip-autogenerated-setters)Custom setters (skip autogenerated setters)\nSimilarly to `setter(skip)`, you can say that you will provide your own setter methods. This simply suppresses the generation of the setter, leaving the field in the builder, as `Option<T>`.\n```\n#[derive(Builder)]\nstruct SetterOptOut {\n  #[builder(setter(custom))]\n  custom_setter: u32,\n}\nimpl SetterOptOutBuilder {\n  fn custom_setter(&mut self, value: u32) {\n    self.custom_setter = Some(value);\n  }\n}\n```\n\nAgain, the more verbose form is accepted:\n  * `#[builder(setter(custom = true))]`\n  * `#[builder(setter(custom = false))]`\n\n\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#setter-visibility)Setter Visibility\nSetters are public by default. You can precede your struct (or field) with `#[builder(public)]` to make this explicit.\nOtherwise precede your struct (or field) with `#[builder(private)]` to opt into private setters.\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#generated-builder-struct-name)Generated builder struct name\nBy default, the builder struct for `struct Foo` is `FooBuilder`. You can override this:\n```\n#[derive(Builder)]\n#[builder(name = \"FooConstructor\")]\nstruct Foo { }\nlet foo: Foo = FooConstructor::default().build()?;\n```\n\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#setter-nameprefix)Setter Name/Prefix\nSetter methods are named after their corresponding field by default.\n  * You can customize the setter name via `#[builder(setter(name = \"foo\"))`.\n  * Alternatively you can set a prefix via `#[builder(setter(prefix = \"xyz\"))`, which will change the method name to `xyz_foo` if the field is named `foo`. Note that an underscore is inserted, since Rust favors snake case here.\n\n\nPrefixes can also be defined on the struct level, but renames only work on fields. Renames take precedence over prefix definitions.\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#generic-setters)Generic Setters\nYou can make each setter generic over the `Into`-trait. It\u2019s as simple as adding `#[builder(setter(into))]` to either a field or the whole struct.\n```\n#[derive(Builder, Debug, PartialEq)]\nstruct Lorem {\n  #[builder(setter(into))]\n  pub ipsum: String,\n}\nfn main() {\n  // `\"foo\"` will be converted into a `String` automatically.\n  let x = LoremBuilder::default().ipsum(\"foo\").build().unwrap();\n  assert_eq!(x, Lorem {\n    ipsum: \"foo\".to_string(),\n  });\n}\n```\n\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#setters-for-option)Setters for Option\nYou can avoid wrapping values in `Some(...)` for fields of type `Option<T>`. It\u2019s as simple as adding `#[builder(setter(strip_option))]` to either a single field or the whole struct.\n```\n#[derive(Builder, Debug, PartialEq)]\nstruct Lorem {\n  #[builder(setter(into, strip_option))]\n  pub ipsum: Option<String>,\n  #[builder(setter(into, strip_option), default)]\n  pub foo: Option<String>,\n}\nfn main() {\n  // `\"foo\"` will be converted into a `String` automatically.\n  let x = LoremBuilder::default().ipsum(\"foo\").build().unwrap();\n  assert_eq!(x, Lorem {\n    ipsum: Some(\"foo\".to_string()),\n    foo: None\n  });\n}\n```\n\nIf you want to set the value to None when unset, then enable `default` on this field (or do not use `strip_option`).\nLimitation: only the `Option` type name is supported, not type alias nor `std::option::Option`.\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#fallible-setters)Fallible Setters\nAlongside the normal setter methods, you can expose fallible setters which are generic over the `TryInto` trait. TryInto is similar to `Into` with the key distinction that the conversion can fail, and therefore produces a `Result`.\nYou can only declare the `try_setter` attribute today if you\u2019re targeting nightly, and you have to add `#![feature(try_from)]` to your crate to use it.\n```\n#[derive(Builder, Debug, PartialEq)]\n#[builder(try_setter, setter(into))]\nstruct Lorem {\n  pub name: String,\n  pub ipsum: u8,\n}\n#[derive(Builder, Debug, PartialEq)]\nstruct Ipsum {\n  #[builder(try_setter, setter(into, name = \"foo\"))]\n  pub dolor: u8,\n}\nfn main() {\n  LoremBuilder::default()\n    .try_ipsum(1u16).unwrap()\n    .name(\"hello\")\n    .build()\n    .expect(\"1 fits into a u8\");\n  IpsumBuilder::default()\n    .try_foo(1u16).unwrap()\n    .build()\n    .expect(\"1 fits into a u8\");\n}\n```\n\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#default-values)Default Values\nYou can define default values for each field via annotation by `#[builder(default = \"...\")]`, where `...` stands for any Rust expression and must be string-escaped, e.g.\n  * `#[builder(default = \"42\")]`\n  * `#[builder(default)]` delegates to the [`Default`](https://doc.rust-lang.org/std/default/trait.Default.html) trait of the base type.\n\n\nThe expression will be evaluated with each call to `build`.\n```\n#[derive(Builder, Debug, PartialEq)]\nstruct Lorem {\n  #[builder(default = \"42\")]\n  pub ipsum: u32,\n}\nfn main() {\n  // If we don't set the field `ipsum`,\n  let x = LoremBuilder::default().build().unwrap();\n  // .. the custom default will be used for `ipsum`:\n  assert_eq!(x, Lorem {\n    ipsum: 42,\n  });\n}\n```\n\n#### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#tips-on-defaults)Tips on Defaults\n  * The `#[builder(default)]` annotation can be used on the struct level, too. Overrides are still possible.\n  * Delegate to a private helper method on `FooBuilder` for anything fancy. This way you will get _much better error diagnostics_ from the rust compiler and it will be _much more readable_ for other human beings. :-)\n  * Defaults will not work while using `#[builder(build_fn(skip))]`. In this case, you\u2019ll need to handle default values yourself when converting from the builder, such as by using `.unwrap_or()` and `.unwrap_or_else()`.\n\n\n```\nstruct Lorem {\n  ipsum: String,\n  // Custom defaults can delegate to helper methods\n  // and pass errors to the enclosing `build()` method via `?`.\n  #[builder(default = \"self.default_dolor()?\")]\n  dolor: String,\n}\nimpl LoremBuilder {\n  // Private helper method with access to the builder struct.\n  fn default_dolor(&self) -> Result<String, String> {\n    match self.ipsum {\n      Some(ref x) if x.chars().count() > 3 => Ok(format!(\"dolor {}\", x)),\n      _ => Err(\"ipsum must at least 3 chars to build dolor\".to_string()),\n    }\n  }\n}\n\n```\n\nYou can even reference other fields, but you have to remember that the builder struct will wrap every type in an Option ([as illustrated earlier](https://docs.rs/derive_builder/latest/derive_builder/#what-you-get)).\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#generic-structs)Generic Structs\n```\n#[derive(Builder, Debug, PartialEq, Default, Clone)]\nstruct GenLorem<T: Clone> {\n  ipsum: &'static str,\n  dolor: T,\n}\nfn main() {\n  let x = GenLoremBuilder::default().ipsum(\"sit\").dolor(42).build().unwrap();\n  assert_eq!(x, GenLorem { ipsum: \"sit\".into(), dolor: 42 });\n}\n```\n\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#build-method-customization)Build Method Customization\nYou can rename or suppress the auto-generated build method, leaving you free to implement your own version. Suppression is done using `#[builder(build_fn(skip))]` at the struct level, and renaming is done with `#[builder(build_fn(name = \"YOUR_NAME\"))]`.\nAdditionally if you want to make the build method private you can apply `#[builder(build_fn(private))]`.\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#pre-build-validation)Pre-Build Validation\nIf you\u2019re using the provided `build` method, you can declare `#[builder(build_fn(validate = \"path::to::fn\"))]` to specify a validator function which gets access to the builder before construction. The path does not need to be fully-qualified, and will consider `use` statements made at module level. It must be accessible from the scope where the target struct is declared.\nThe provided function must have the signature `(&FooBuilder) -> Result<_, String>`; the `Ok` variant is not used by the `build` method.\n```\n#[derive(Builder, Debug, PartialEq)]\n#[builder(build_fn(validate = \"Self::validate\"))]\nstruct Lorem {\n  pub ipsum: u8,\n}\nimpl LoremBuilder {\n  /// Check that `Lorem` is putting in the right amount of effort.\n  fn validate(&self) -> Result<(), String> {\n    if let Some(ref ipsum) = self.ipsum {\n      match *ipsum {\n        i if i < 20 => Err(\"Try harder\".to_string()),\n        i if i > 100 => Err(\"You'll tire yourself out\".to_string()),\n        _ => Ok(())\n      }\n    } else {\n      Ok(())\n    }\n  }\n}\nfn main() {\n  // If we're trying too hard...\n  let x = LoremBuilder::default().ipsum(120).build().unwrap_err();\n  // .. the build will fail:\n  assert_eq!(&x.to_string(), \"You'll tire yourself out\");\n}\n```\n\nNote:\n  * Default values are applied _after_ validation, and will therefore not be validated!\n\n\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#additional-trait-derivations)Additional Trait Derivations\nYou can derive additional traits on the builder, including traits defined by other crates:\n```\n#[derive(Builder, Clone)]\n#[builder(derive(Debug, PartialEq, Eq))]\npub struct Lorem {\n  foo: u8,\n  bar: String,\n}\nfn main() {\n  assert_eq!(LoremBuilder::default(), LoremBuilder::default());\n}\n```\n\nAttributes declared for those traits are _not_ forwarded to the fields on the builder.\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#documentation-comments-and-attributes)Documentation Comments and Attributes\n`#[derive(Builder)]` copies doc comments and attributes (`#[...]`) from your fields to the according builder fields and setter-methods, if it is one of the following:\n  * `/// ...`\n  * `#[doc = ...]`\n  * `#[cfg(...)]`\n  * `#[allow(...)]`\n\n\nThe whitelisting minimizes interference with other custom attributes like those used by Serde, Diesel, or others.\n```\n#[derive(Builder)]\nstruct Lorem {\n  /// `ipsum` may be any `String` (be creative).\n  ipsum: String,\n  #[doc = r\"`dolor` is the estimated amount of work.\"]\n  dolor: i32,\n  // `#[derive(Builder)]` understands conditional compilation via cfg-attributes,\n  // i.e. => \"no field = no setter\".\n  #[cfg(target_os = \"macos\")]\n  #[allow(non_snake_case)]\n  Im_a_Mac: bool,\n}\n```\n\n#### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#pass-through-attributes)Pass-through Attributes\nYou can set attributes on elements of the builder using the `builder_*_attr` attributes:\n  * `builder_struct_attr` adds attributes after `#[derive(...)]` on the builder struct.\n  * `builder_impl_attr` adds attributes on the `impl` block\n  * `builder_field_attr` adds attributes to field declarations in the builder struct.\n  * `builder_setter_attr` adds attributes to the setter in the `impl` block.\n\n\n```\n#[derive(Builder)]\n#[builder(derive(serde::Serialize))]\n#[builder_struct_attr(serde(rename_all = \"camelCase\"))]\nstruct Lorem {\n  #[builder_field_attr(serde(rename=\"dolor\"))]\n  ipsum: String,\n}\nlet mut show = LoremBuilder::default();\nshow.ipsum(\"sit\".into());\nassert_eq!(serde_json::to_string(&show).unwrap(), r#\"{\"dolor\":\"sit\"}\"#);\n```\n\n## [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#error-return-type-from-autogenerated-build-function)Error return type from autogenerated `build` function\nBy default, `build` returns an autogenerated error type:\n```\n#[doc=\"Error type for LoremBuilder\"]\n#[derive(Debug)]\n#[non_exhaustive]\npub enum LoremBuilderError { // where `LoremBuilder` is the name of the builder struct\n  /// Uninitialized field\n  UninitializedField(&'static str),\n  /// Custom validation error\n  ValidationError(String),\n}\nimpl From<String> for LoremBuilderError {\n  fn from(s: String) -> Self { Self::ValidationError(s) }\n}\nimpl From<UninitializedFieldError> for LoremBuilderError { // ...\nimpl Display for LoremBuilderError { // ...\nimpl std::error::Error for LoremBuilderError {}\n```\n\nAlternatively, you can specify your own error type:\n```\n#[derive(Builder, Debug, PartialEq)]\n#[builder(build_fn(error = \"OurLoremError\"))]\nstruct Lorem {\n  pub ipsum: u32,\n}\nstruct OurLoremError(String);\nimpl From<UninitializedFieldError> for OurLoremError {\n  fn from(ufe: UninitializedFieldError) -> OurLoremError { OurLoremError(ufe.to_string()) }\n}\nlet err: OurLoremError = LoremBuilder::default().build().unwrap_err();\nassert_eq!(&err.0, \"Field not initialized: ipsum\");\n```\n\n## [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#completely-custom-fields-in-the-builder)Completely custom fields in the builder\nInstead of having an `Option`, you can have whatever type you like:\n```\n#[derive(Debug, PartialEq, Default, Builder, Clone)]\n#[builder(derive(Debug, PartialEq))]\nstruct Lorem {\n  #[builder(setter(into), field(ty = \"u32\"))]\n  ipsum: u32,\n  #[builder(field(ty = \"String\", build = \"()\"))]\n  dolor: (),\n  #[builder(field(ty = \"&'static str\", build = \"self.amet.parse()?\"))]\n  amet: u32,\n}\nimpl From<std::num::ParseIntError> for LoremBuilderError { // ...\nlet mut builder = LoremBuilder::default();\nbuilder.ipsum(42u16).dolor(\"sit\".into()).amet(\"12\");\nassert_eq!(builder, LoremBuilder { ipsum: 42, dolor: \"sit\".into(), amet: \"12\" });\nlet lorem = builder.build().unwrap();\nassert_eq!(lorem, Lorem { ipsum: 42, dolor: (), amet: 12 });\n```\n\nThe builder field type (`ty =`) must implement `Default`.\nThe argument to `build` must be a literal string containing Rust code for the contents of a block, which must evaluate to the type of the target field. It may refer to the builder struct as `self`, use `?`, etc.\n## [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#no_std-support-on-nightly)**`#![no_std]`**Support (on Nightly)\nYou can activate support for `#![no_std]` by adding `#[builder(no_std)]` to your struct and `#![feature(alloc)] extern crate alloc` to your crate.\nThe latter requires the _nightly_ toolchain.\n## [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#troubleshooting)Troubleshooting\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#gotchas)Gotchas\n  * Tuple structs and unit structs are not supported as they have no field names.\n  * Generic setters introduce a type parameter `VALUE: Into<_>`. Therefore you can\u2019t use `VALUE` as a type parameter on a generic struct in combination with generic setters.\n  * The `try_setter` attribute and `owned` builder pattern are not compatible in practice; an error during building will consume the builder, making it impossible to continue construction.\n  * When re-exporting the underlying struct under a different name, the auto-generated documentation will not match.\n  * If derive_builder depends on your crate, and vice versa, then a cyclic dependency would occur. To break it you could try to depend on the [`derive_builder_core`](https://crates.io/crates/derive_builder_core) crate instead.\n\n\n### [\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#report-issues-and-ideas)Report Issues and Ideas\n[Open an issue on GitHub](https://github.com/colin-kiegel/rust-derive-builder/issues)\nIf possible please try to provide the debugging info if you experience unexpected compilation errors (see above).\n## Structs[\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#structs)\n\n[UninitializedFieldError](https://docs.rs/derive_builder/latest/derive_builder/struct.UninitializedFieldError.html \"struct derive_builder::UninitializedFieldError\")\n    Runtime error when a `build()` method is called and one or more required fields do not have a value.\n## Derive Macros[\u00a7](https://docs.rs/derive_builder/latest/derive_builder/#derives)\n\n[Builder](https://docs.rs/derive_builder/latest/derive_builder/derive.Builder.html \"derive derive_builder::Builder\")\n    Create a builder struct for the deriving struct.\n",
        "markdown_with_citations": "[](https://docs.rs/derive_builder/latest/derive_builder/all.html \"show sidebar\")\n# Crate derive_builderCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nDerive a builder for a struct\nThis crate implements the builder pattern\u27e84\u27e9 for you. Just apply `#[derive(Builder)]` to a struct `Foo`, and it will derive an additional struct `FooBuilder` with **setter** -methods for all fields and a **build** -method \u2014 the way you want it.\n## \u00a7\u27e85\u27e9Quick Start\nAdd `derive_builder` as a dependency to you `Cargo.toml`.\n### \u00a7\u27e86\u27e9What you write\n```\nuse derive_builder::Builder;\n#[derive(Builder)]\nstruct Lorem {\n  ipsum: u32,\n  // ..\n}\n```\n\n### \u00a7\u27e87\u27e9What you get\n```\n#[derive(Clone, Default)]\nstruct LoremBuilder {\n  ipsum: Option<u32>,\n}\n#[allow(dead_code)]\nimpl LoremBuilder {\n  pub fn ipsum(&mut self, value: u32) -> &mut Self {\n    let mut new = self;\n    new.ipsum = Some(value);\n    new\n  }\n  fn build(&self) -> Result<Lorem, LoremBuilderError> {\n    Ok(Lorem {\n      ipsum: Clone::clone(self.ipsum\n        .as_ref()\n        .ok_or(LoremBuilderError::from(UninitializedFieldError::new(\"ipsum\")))?),\n    })\n  }\n}\n```\n\nBy default all generated setter-methods take and return `&mut self` (aka _non-consuming_ builder pattern). Accordingly, the build method also takes a reference by default.\nYou can easily opt into different patterns and control many other aspects.\nThe build method returns `Result<T, E>`, where `T` is the struct you started with and E is a generated builder error type. It returns `Err` if you didn\u2019t initialize all fields and no default values were provided.\n## \u00a7\u27e88\u27e9Builder Patterns\nLet\u2019s look again at the example above. You can now build structs like this:\n```\nlet x: Lorem = LoremBuilder::default().ipsum(42).build()?;\n```\n\nOk, _chaining_ method calls is nice, but what if `ipsum(42)` should only happen if `geek = true`?\nSo let\u2019s make this call conditional\n```\nlet mut builder = LoremBuilder::default();\nif geek {\n  builder.ipsum(42);\n}\nlet x: Lorem = builder.build()?;\n```\n\nNow it comes in handy that our setter methods take and return mutable references. Otherwise we would need to write something more clumsy like `builder = builder.ipsum(42)` to reassign the return value each time we have to call a setter conditionally.\nSetters with mutable references are therefore a convenient default for the builder pattern in Rust.\nBut this is a free world and the choice is still yours!\n### \u00a7\u27e89\u27e9Owned, aka Consuming\nPrecede your struct (or field) with `#[builder(pattern = \"owned\")]` to opt into this pattern. Builders generated with this pattern do not automatically derive `Clone`, which allows builders to be generated for structs with fields that do not derive `Clone`.\n  * Setters take and return `self`.\n  * PRO: Setter calls and final build method can be chained.\n  * CON: If you don\u2019t chain your calls, you have to create a reference to each return value, e.g. `builder = builder.ipsum(42)`.\n\n\n### \u00a7\u27e810\u27e9Mutable, aka Non-Consuming (recommended)\nThis pattern is recommended and active by default if you don\u2019t specify anything else. You can precede your struct (or field) with `#[builder(pattern = \"mutable\")]` to make this choice explicit.\n  * Setters take and return `&mut self`.\n  * PRO: Setter calls and final build method can be chained.\n  * CON: The build method must clone or copy data to create something owned out of a mutable reference. Otherwise it could not be used in a chain. **(*)**\n\n\n### \u00a7\u27e811\u27e9Immutable\nPrecede your struct (or field) with `#[builder(pattern = \"immutable\")]` to opt into this pattern.\n  * Setters take and return `&self`.\n  * PRO: Setter calls and final build method can be chained.\n  * CON: If you don\u2019t chain your calls, you have to create a reference to each return value, e.g. `builder = builder.ipsum(42)`.\n  * CON: The build method _and each setter_ must clone or copy data to create something owned out of a reference. **(*)**\n\n\n### \u00a7\u27e812\u27e9(*) Performance Considerations\nLuckily Rust is clever enough to optimize these clone-calls away in release builds for your every-day use cases. Thats quite a safe bet - we checked this for you. ;-) Switching to consuming signatures (=`self`) is unlikely to give you any performance gain, but very likely to restrict your API for non-chained use cases.\n## \u00a7\u27e813\u27e9More Features\n### \u00a7\u27e814\u27e9Hidden Fields\nYou can hide fields by skipping their setters on (and presence in) the builder struct.\n  * Opt-out \u2014 skip setters via `#[builder(setter(skip))]` on individual fields.\n  * Opt-in \u2014 set `#[builder(setter(skip))]` on the whole struct and enable individual setters via `#[builder(setter)]`.\n\n\nThe types of skipped fields must implement `Default`.\n```\n#[derive(Builder)]\nstruct HiddenField {\n  setter_present: u32,\n  #[builder(setter(skip))]\n  setter_skipped: u32,\n}\n```\n\nAlternatively, you can use the more verbose form:\n  * `#[builder(setter(skip = true))]`\n  * `#[builder(setter(skip = false))]`\n\n\n### \u00a7\u27e815\u27e9Custom setters (skip autogenerated setters)\nSimilarly to `setter(skip)`, you can say that you will provide your own setter methods. This simply suppresses the generation of the setter, leaving the field in the builder, as `Option<T>`.\n```\n#[derive(Builder)]\nstruct SetterOptOut {\n  #[builder(setter(custom))]\n  custom_setter: u32,\n}\nimpl SetterOptOutBuilder {\n  fn custom_setter(&mut self, value: u32) {\n    self.custom_setter = Some(value);\n  }\n}\n```\n\nAgain, the more verbose form is accepted:\n  * `#[builder(setter(custom = true))]`\n  * `#[builder(setter(custom = false))]`\n\n\n### \u00a7\u27e816\u27e9Setter Visibility\nSetters are public by default. You can precede your struct (or field) with `#[builder(public)]` to make this explicit.\nOtherwise precede your struct (or field) with `#[builder(private)]` to opt into private setters.\n### \u00a7\u27e817\u27e9Generated builder struct name\nBy default, the builder struct for `struct Foo` is `FooBuilder`. You can override this:\n```\n#[derive(Builder)]\n#[builder(name = \"FooConstructor\")]\nstruct Foo { }\nlet foo: Foo = FooConstructor::default().build()?;\n```\n\n### \u00a7\u27e818\u27e9Setter Name/Prefix\nSetter methods are named after their corresponding field by default.\n  * You can customize the setter name via `#builder(setter(name = \"foo\"))`.\n  * Alternatively you can set a prefix via `#[builder(setter(prefix = \"xyz\"))`, which will change the method name to `xyz_foo` if the field is named `foo`. Note that an underscore is inserted, since Rust favors snake case here.\n\n\nPrefixes can also be defined on the struct level, but renames only work on fields. Renames take precedence over prefix definitions.\n### [\u00a7\u27e819\u27e9Generic Setters\nYou can make each setter generic over the `Into`-trait. It\u2019s as simple as adding `#[builder(setter(into))]` to either a field or the whole struct.\n```\n#[derive(Builder, Debug, PartialEq)]\nstruct Lorem {\n  #[builder(setter(into))]\n  pub ipsum: String,\n}\nfn main() {\n  // `\"foo\"` will be converted into a `String` automatically.\n  let x = LoremBuilder::default().ipsum(\"foo\").build().unwrap();\n  assert_eq!(x, Lorem {\n    ipsum: \"foo\".to_string(),\n  });\n}\n```\n\n### \u00a7\u27e820\u27e9Setters for Option\nYou can avoid wrapping values in `Some(...)` for fields of type `Option<T>`. It\u2019s as simple as adding `#[builder(setter(strip_option))]` to either a single field or the whole struct.\n```\n#[derive(Builder, Debug, PartialEq)]\nstruct Lorem {\n  #[builder(setter(into, strip_option))]\n  pub ipsum: Option<String>,\n  #[builder(setter(into, strip_option), default)]\n  pub foo: Option<String>,\n}\nfn main() {\n  // `\"foo\"` will be converted into a `String` automatically.\n  let x = LoremBuilder::default().ipsum(\"foo\").build().unwrap();\n  assert_eq!(x, Lorem {\n    ipsum: Some(\"foo\".to_string()),\n    foo: None\n  });\n}\n```\n\nIf you want to set the value to None when unset, then enable `default` on this field (or do not use `strip_option`).\nLimitation: only the `Option` type name is supported, not type alias nor `std::option::Option`.\n### \u00a7\u27e821\u27e9Fallible Setters\nAlongside the normal setter methods, you can expose fallible setters which are generic over the `TryInto` trait. TryInto is similar to `Into` with the key distinction that the conversion can fail, and therefore produces a `Result`.\nYou can only declare the `try_setter` attribute today if you\u2019re targeting nightly, and you have to add `#![feature(try_from)]` to your crate to use it.\n```\n#[derive(Builder, Debug, PartialEq)]\n#[builder(try_setter, setter(into))]\nstruct Lorem {\n  pub name: String,\n  pub ipsum: u8,\n}\n#[derive(Builder, Debug, PartialEq)]\nstruct Ipsum {\n  #[builder(try_setter, setter(into, name = \"foo\"))]\n  pub dolor: u8,\n}\nfn main() {\n  LoremBuilder::default()\n    .try_ipsum(1u16).unwrap()\n    .name(\"hello\")\n    .build()\n    .expect(\"1 fits into a u8\");\n  IpsumBuilder::default()\n    .try_foo(1u16).unwrap()\n    .build()\n    .expect(\"1 fits into a u8\");\n}\n```\n\n### \u00a7\u27e822\u27e9Default Values\nYou can define default values for each field via annotation by `#[builder(default = \"...\")]`, where `...` stands for any Rust expression and must be string-escaped, e.g.\n  * `#[builder(default = \"42\")]`\n  * `#[builder(default)]` delegates to the `Default`\u27e823\u27e9 trait of the base type.\n\n\nThe expression will be evaluated with each call to `build`.\n```\n#[derive(Builder, Debug, PartialEq)]\nstruct Lorem {\n  #[builder(default = \"42\")]\n  pub ipsum: u32,\n}\nfn main() {\n  // If we don't set the field `ipsum`,\n  let x = LoremBuilder::default().build().unwrap();\n  // .. the custom default will be used for `ipsum`:\n  assert_eq!(x, Lorem {\n    ipsum: 42,\n  });\n}\n```\n\n#### \u00a7\u27e824\u27e9Tips on Defaults\n  * The `#[builder(default)]` annotation can be used on the struct level, too. Overrides are still possible.\n  * Delegate to a private helper method on `FooBuilder` for anything fancy. This way you will get _much better error diagnostics_ from the rust compiler and it will be _much more readable_ for other human beings. :-)\n  * Defaults will not work while using `#[builder(build_fn(skip))]`. In this case, you\u2019ll need to handle default values yourself when converting from the builder, such as by using `.unwrap_or()` and `.unwrap_or_else()`.\n\n\n```\nstruct Lorem {\n  ipsum: String,\n  // Custom defaults can delegate to helper methods\n  // and pass errors to the enclosing `build()` method via `?`.\n  #[builder(default = \"self.default_dolor()?\")]\n  dolor: String,\n}\nimpl LoremBuilder {\n  // Private helper method with access to the builder struct.\n  fn default_dolor(&self) -> Result<String, String> {\n    match self.ipsum {\n      Some(ref x) if x.chars().count() > 3 => Ok(format!(\"dolor {}\", x)),\n      _ => Err(\"ipsum must at least 3 chars to build dolor\".to_string()),\n    }\n  }\n}\n\n```\n\nYou can even reference other fields, but you have to remember that the builder struct will wrap every type in an Option (as illustrated earlier\u27e87\u27e9).\n### \u00a7\u27e825\u27e9Generic Structs\n```\n#[derive(Builder, Debug, PartialEq, Default, Clone)]\nstruct GenLorem<T: Clone> {\n  ipsum: &'static str,\n  dolor: T,\n}\nfn main() {\n  let x = GenLoremBuilder::default().ipsum(\"sit\").dolor(42).build().unwrap();\n  assert_eq!(x, GenLorem { ipsum: \"sit\".into(), dolor: 42 });\n}\n```\n\n### \u00a7\u27e826\u27e9Build Method Customization\nYou can rename or suppress the auto-generated build method, leaving you free to implement your own version. Suppression is done using `#[builder(build_fn(skip))]` at the struct level, and renaming is done with `#[builder(build_fn(name = \"YOUR_NAME\"))]`.\nAdditionally if you want to make the build method private you can apply `#[builder(build_fn(private))]`.\n### \u00a7\u27e827\u27e9Pre-Build Validation\nIf you\u2019re using the provided `build` method, you can declare `#[builder(build_fn(validate = \"path::to::fn\"))]` to specify a validator function which gets access to the builder before construction. The path does not need to be fully-qualified, and will consider `use` statements made at module level. It must be accessible from the scope where the target struct is declared.\nThe provided function must have the signature `(&FooBuilder) -> Result<_, String>`; the `Ok` variant is not used by the `build` method.\n```\n#[derive(Builder, Debug, PartialEq)]\n#[builder(build_fn(validate = \"Self::validate\"))]\nstruct Lorem {\n  pub ipsum: u8,\n}\nimpl LoremBuilder {\n  /// Check that `Lorem` is putting in the right amount of effort.\n  fn validate(&self) -> Result<(), String> {\n    if let Some(ref ipsum) = self.ipsum {\n      match *ipsum {\n        i if i < 20 => Err(\"Try harder\".to_string()),\n        i if i > 100 => Err(\"You'll tire yourself out\".to_string()),\n        _ => Ok(())\n      }\n    } else {\n      Ok(())\n    }\n  }\n}\nfn main() {\n  // If we're trying too hard...\n  let x = LoremBuilder::default().ipsum(120).build().unwrap_err();\n  // .. the build will fail:\n  assert_eq!(&x.to_string(), \"You'll tire yourself out\");\n}\n```\n\nNote:\n  * Default values are applied _after_ validation, and will therefore not be validated!\n\n\n### \u00a7\u27e828\u27e9Additional Trait Derivations\nYou can derive additional traits on the builder, including traits defined by other crates:\n```\n#[derive(Builder, Clone)]\n#[builder(derive(Debug, PartialEq, Eq))]\npub struct Lorem {\n  foo: u8,\n  bar: String,\n}\nfn main() {\n  assert_eq!(LoremBuilder::default(), LoremBuilder::default());\n}\n```\n\nAttributes declared for those traits are _not_ forwarded to the fields on the builder.\n### \u00a7\u27e829\u27e9Documentation Comments and Attributes\n`#[derive(Builder)]` copies doc comments and attributes (`#[...]`) from your fields to the according builder fields and setter-methods, if it is one of the following:\n  * `/// ...`\n  * `#[doc = ...]`\n  * `#[cfg(...)]`\n  * `#[allow(...)]`\n\n\nThe whitelisting minimizes interference with other custom attributes like those used by Serde, Diesel, or others.\n```\n#[derive(Builder)]\nstruct Lorem {\n  /// `ipsum` may be any `String` (be creative).\n  ipsum: String,\n  #[doc = r\"`dolor` is the estimated amount of work.\"]\n  dolor: i32,\n  // `#[derive(Builder)]` understands conditional compilation via cfg-attributes,\n  // i.e. => \"no field = no setter\".\n  #[cfg(target_os = \"macos\")]\n  #[allow(non_snake_case)]\n  Im_a_Mac: bool,\n}\n```\n\n#### \u00a7\u27e830\u27e9Pass-through Attributes\nYou can set attributes on elements of the builder using the `builder_*_attr` attributes:\n  * `builder_struct_attr` adds attributes after `#[derive(...)]` on the builder struct.\n  * `builder_impl_attr` adds attributes on the `impl` block\n  * `builder_field_attr` adds attributes to field declarations in the builder struct.\n  * `builder_setter_attr` adds attributes to the setter in the `impl` block.\n\n\n```\n#[derive(Builder)]\n#[builder(derive(serde::Serialize))]\n#[builder_struct_attr(serde(rename_all = \"camelCase\"))]\nstruct Lorem {\n  #[builder_field_attr(serde(rename=\"dolor\"))]\n  ipsum: String,\n}\nlet mut show = LoremBuilder::default();\nshow.ipsum(\"sit\".into());\nassert_eq!(serde_json::to_string(&show).unwrap(), r#\"{\"dolor\":\"sit\"}\"#);\n```\n\n## \u00a7\u27e831\u27e9Error return type from autogenerated `build` function\nBy default, `build` returns an autogenerated error type:\n```\n#[doc=\"Error type for LoremBuilder\"]\n#[derive(Debug)]\n#[non_exhaustive]\npub enum LoremBuilderError { // where `LoremBuilder` is the name of the builder struct\n  /// Uninitialized field\n  UninitializedField(&'static str),\n  /// Custom validation error\n  ValidationError(String),\n}\nimpl From<String> for LoremBuilderError {\n  fn from(s: String) -> Self { Self::ValidationError(s) }\n}\nimpl From<UninitializedFieldError> for LoremBuilderError { // ...\nimpl Display for LoremBuilderError { // ...\nimpl std::error::Error for LoremBuilderError {}\n```\n\nAlternatively, you can specify your own error type:\n```\n#[derive(Builder, Debug, PartialEq)]\n#[builder(build_fn(error = \"OurLoremError\"))]\nstruct Lorem {\n  pub ipsum: u32,\n}\nstruct OurLoremError(String);\nimpl From<UninitializedFieldError> for OurLoremError {\n  fn from(ufe: UninitializedFieldError) -> OurLoremError { OurLoremError(ufe.to_string()) }\n}\nlet err: OurLoremError = LoremBuilder::default().build().unwrap_err();\nassert_eq!(&err.0, \"Field not initialized: ipsum\");\n```\n\n## \u00a7\u27e832\u27e9Completely custom fields in the builder\nInstead of having an `Option`, you can have whatever type you like:\n```\n#[derive(Debug, PartialEq, Default, Builder, Clone)]\n#[builder(derive(Debug, PartialEq))]\nstruct Lorem {\n  #[builder(setter(into), field(ty = \"u32\"))]\n  ipsum: u32,\n  #[builder(field(ty = \"String\", build = \"()\"))]\n  dolor: (),\n  #[builder(field(ty = \"&'static str\", build = \"self.amet.parse()?\"))]\n  amet: u32,\n}\nimpl From<std::num::ParseIntError> for LoremBuilderError { // ...\nlet mut builder = LoremBuilder::default();\nbuilder.ipsum(42u16).dolor(\"sit\".into()).amet(\"12\");\nassert_eq!(builder, LoremBuilder { ipsum: 42, dolor: \"sit\".into(), amet: \"12\" });\nlet lorem = builder.build().unwrap();\nassert_eq!(lorem, Lorem { ipsum: 42, dolor: (), amet: 12 });\n```\n\nThe builder field type (`ty =`) must implement `Default`.\nThe argument to `build` must be a literal string containing Rust code for the contents of a block, which must evaluate to the type of the target field. It may refer to the builder struct as `self`, use `?`, etc.\n## \u00a7\u27e833\u27e9**`#![no_std]`**Support (on Nightly)\nYou can activate support for `#![no_std]` by adding `#[builder(no_std)]` to your struct and `#![feature(alloc)] extern crate alloc` to your crate.\nThe latter requires the _nightly_ toolchain.\n## \u00a7\u27e834\u27e9Troubleshooting\n### \u00a7\u27e835\u27e9Gotchas\n  * Tuple structs and unit structs are not supported as they have no field names.\n  * Generic setters introduce a type parameter `VALUE: Into<_>`. Therefore you can\u2019t use `VALUE` as a type parameter on a generic struct in combination with generic setters.\n  * The `try_setter` attribute and `owned` builder pattern are not compatible in practice; an error during building will consume the builder, making it impossible to continue construction.\n  * When re-exporting the underlying struct under a different name, the auto-generated documentation will not match.\n  * If derive_builder depends on your crate, and vice versa, then a cyclic dependency would occur. To break it you could try to depend on the `derive_builder_core`\u27e836\u27e9 crate instead.\n\n\n### \u00a7\u27e837\u27e9Report Issues and Ideas\nOpen an issue on GitHub\u27e838\u27e9\nIf possible please try to provide the debugging info if you experience unexpected compilation errors (see above).\n## Structs\u00a7\u27e839\u27e9\n\nUninitializedFieldError\u27e840\u27e9\n    Runtime error when a `build()` method is called and one or more required fields do not have a value.\n## Derive Macros\u00a7\u27e841\u27e9\n\nBuilder\u27e842\u27e9\n    Create a builder struct for the deriving struct.\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/derive_builder/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/derive_builder/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/derive_builder/latest/src/derive_builder/lib.rs.html#1-717: Source\n\u27e84\u27e9 https://web.archive.org/web/20170701044756/https://aturon.github.io/ownership/builders.html: builder pattern\n\u27e85\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#quick-start: \u00a7\n\u27e86\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#what-you-write: \u00a7\n\u27e87\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#what-you-get: \u00a7\n\u27e88\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#builder-patterns: \u00a7\n\u27e89\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#owned-aka-consuming: \u00a7\n\u27e810\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#mutable-aka-non-consuming-recommended: \u00a7\n\u27e811\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#immutable: \u00a7\n\u27e812\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#-performance-considerations: \u00a7\n\u27e813\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#more-features: \u00a7\n\u27e814\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#hidden-fields: \u00a7\n\u27e815\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#custom-setters-skip-autogenerated-setters: \u00a7\n\u27e816\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#setter-visibility: \u00a7\n\u27e817\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#generated-builder-struct-name: \u00a7\n\u27e818\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#setter-nameprefix: \u00a7\n\u27e819\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#generic-setters: builder(setter(name = \"foo\"))`.\n  * Alternatively you can set a prefix via `#[builder(setter(prefix = \"xyz\"))`, which will change the method name to `xyz_foo` if the field is named `foo`. Note that an underscore is inserted, since Rust favors snake case here.\n\n\nPrefixes can also be defined on the struct level, but renames only work on fields. Renames take precedence over prefix definitions.\n### [\u00a7\n\u27e820\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#setters-for-option: \u00a7\n\u27e821\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#fallible-setters: \u00a7\n\u27e822\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#default-values: \u00a7\n\u27e823\u27e9 https://doc.rust-lang.org/std/default/trait.Default.html: `Default`\n\u27e824\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#tips-on-defaults: \u00a7\n\u27e825\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#generic-structs: \u00a7\n\u27e826\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#build-method-customization: \u00a7\n\u27e827\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#pre-build-validation: \u00a7\n\u27e828\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#additional-trait-derivations: \u00a7\n\u27e829\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#documentation-comments-and-attributes: \u00a7\n\u27e830\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#pass-through-attributes: \u00a7\n\u27e831\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#error-return-type-from-autogenerated-build-function: \u00a7\n\u27e832\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#completely-custom-fields-in-the-builder: \u00a7\n\u27e833\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#no_std-support-on-nightly: \u00a7\n\u27e834\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#troubleshooting: \u00a7\n\u27e835\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#gotchas: \u00a7\n\u27e836\u27e9 https://crates.io/crates/derive_builder_core: `derive_builder_core`\n\u27e837\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#report-issues-and-ideas: \u00a7\n\u27e838\u27e9 https://github.com/colin-kiegel/rust-derive-builder/issues: Open an issue on GitHub\n\u27e839\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#structs: \u00a7\n\u27e840\u27e9 https://docs.rs/derive_builder/latest/derive_builder/struct.UninitializedFieldError.html: struct derive_builder::UninitializedFieldError - UninitializedFieldError\n\u27e841\u27e9 https://docs.rs/derive_builder/latest/derive_builder/#derives: \u00a7\n\u27e842\u27e9 https://docs.rs/derive_builder/latest/derive_builder/derive.Builder.html: derive derive_builder::Builder - Builder\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `derive_builder` crate automates the implementation of the builder pattern for structs in Rust, generating a corresponding builder struct with customizable setter methods and a `build` method. It supports various builder patterns (mutable, owned, immutable), default values, field visibility, custom setters, validation, and trait derivations. Additional features include support for generic setters, `Option` handling, custom error types, and `#![no_std]` compatibility on nightly.",
    "feature_summary": null,
    "use_case": "Utilities",
    "score": 8.5,
    "factual_counterfactual": "### Pair 1: Builder Patterns\n\u2705 Factual: The `derive_builder` crate supports three builder patterns: mutable (non-consuming), owned (consuming), and immutable. By default, the mutable pattern is used, allowing setter methods to take and return `&mut self`.  \n\u274c Counterfactual: The `derive_builder` crate only supports the immutable builder pattern, where setter methods take and return `&self`.\n\n---\n\n### Pair 2: Default Values\n\u2705 Factual: Fields in a struct can have default values specified using the `#[builder(default = \"...\")]` attribute, which allows for custom expressions or delegation to the `Default` trait.  \n\u274c Counterfactual: Default values for fields are automatically inferred by the `derive_builder` crate based on the field's type without requiring explicit annotations.\n\n---\n\n### Pair 3: Error Handling\n\u2705 Factual: The `derive_builder` crate generates a custom error type for the `build` method, which includes variants for uninitialized fields and validation errors. Users can override this error type using the `#[builder(build_fn(error = \"...\"))]` attribute.  \n\u274c Counterfactual: The `derive_builder` crate does not provide any error handling for the `build` method; users must implement error handling manually for uninitialized fields and validation failures.",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}