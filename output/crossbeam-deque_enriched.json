{
    "name": "crossbeam-deque",
    "version": "0.8.6",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/crossbeam-deque/latest/crossbeam_deque/all.html \"show sidebar\")\n# Crate crossbeam_dequeCopy item path\n[Settings](https://docs.rs/crossbeam-deque/latest/settings.html)\n[Help](https://docs.rs/crossbeam-deque/latest/help.html)\nSummary[Source](https://docs.rs/crossbeam-deque/latest/src/crossbeam_deque/lib.rs.html#1-106)\nExpand description\nConcurrent work-stealing deques.\nThese data structures are most commonly used in work-stealing schedulers. The typical setup involves a number of threads, each having its own FIFO or LIFO queue (_worker_). There is also one global FIFO queue (_injector_) and a list of references to _worker_ queues that are able to steal tasks (_stealers_).\nWe spawn a new task onto the scheduler by pushing it into the _injector_ queue. Each worker thread waits in a loop until it finds the next task to run and then runs it. To find a task, it first looks into its local _worker_ queue, and then into the _injector_ and _stealers_.\n## [\u00a7](https://docs.rs/crossbeam-deque/latest/crossbeam_deque/#queues)Queues\n[`Injector`](https://docs.rs/crossbeam-deque/latest/crossbeam_deque/struct.Injector.html \"struct crossbeam_deque::Injector\") is a FIFO queue, where tasks are pushed and stolen from opposite ends. It is shared among threads and is usually the entry point for new tasks.\n[`Worker`](https://docs.rs/crossbeam-deque/latest/crossbeam_deque/struct.Worker.html \"struct crossbeam_deque::Worker\") has two constructors:\n  * [`new_fifo()`](https://docs.rs/crossbeam-deque/latest/crossbeam_deque/struct.Worker.html#method.new_fifo \"associated function crossbeam_deque::Worker::new_fifo\") - Creates a FIFO queue, in which tasks are pushed and popped from opposite ends.\n  * [`new_lifo()`](https://docs.rs/crossbeam-deque/latest/crossbeam_deque/struct.Worker.html#method.new_lifo \"associated function crossbeam_deque::Worker::new_lifo\") - Creates a LIFO queue, in which tasks are pushed and popped from the same end.\n\n\nEach [`Worker`](https://docs.rs/crossbeam-deque/latest/crossbeam_deque/struct.Worker.html \"struct crossbeam_deque::Worker\") is owned by a single thread and supports only push and pop operations.\nMethod [`stealer()`](https://docs.rs/crossbeam-deque/latest/crossbeam_deque/struct.Worker.html#method.stealer \"method crossbeam_deque::Worker::stealer\") creates a [`Stealer`](https://docs.rs/crossbeam-deque/latest/crossbeam_deque/struct.Stealer.html \"struct crossbeam_deque::Stealer\") that may be shared among threads and can only steal tasks from its [`Worker`](https://docs.rs/crossbeam-deque/latest/crossbeam_deque/struct.Worker.html \"struct crossbeam_deque::Worker\"). Tasks are stolen from the end opposite to where they get pushed.\n## [\u00a7](https://docs.rs/crossbeam-deque/latest/crossbeam_deque/#stealing)Stealing\nSteal operations come in three flavors:\n  1. [`steal()`](https://docs.rs/crossbeam-deque/latest/crossbeam_deque/struct.Stealer.html#method.steal \"method crossbeam_deque::Stealer::steal\") - Steals one task.\n  2. [`steal_batch()`](https://docs.rs/crossbeam-deque/latest/crossbeam_deque/struct.Stealer.html#method.steal_batch \"method crossbeam_deque::Stealer::steal_batch\") - Steals a batch of tasks and moves them into another worker.\n  3. [`steal_batch_and_pop()`](https://docs.rs/crossbeam-deque/latest/crossbeam_deque/struct.Stealer.html#method.steal_batch_and_pop \"method crossbeam_deque::Stealer::steal_batch_and_pop\") - Steals a batch of tasks, moves them into another queue, and pops one task from that worker.\n\n\nIn contrast to push and pop operations, stealing can spuriously fail with [`Steal::Retry`](https://docs.rs/crossbeam-deque/latest/crossbeam_deque/enum.Steal.html#variant.Retry \"variant crossbeam_deque::Steal::Retry\"), in which case the steal operation needs to be retried.\n## [\u00a7](https://docs.rs/crossbeam-deque/latest/crossbeam_deque/#examples)Examples\nSuppose a thread in a work-stealing scheduler is idle and looking for the next task to run. To find an available task, it might do the following:\n  1. Try popping one task from the local worker queue.\n  2. Try stealing a batch of tasks from the global injector queue.\n  3. Try stealing one task from another thread using the stealer list.\n\n\nAn implementation of this work-stealing strategy:\n```\nuse crossbeam_deque::{Injector, Stealer, Worker};\nuse std::iter;\nfn find_task<T>(\n  local: &Worker<T>,\n  global: &Injector<T>,\n  stealers: &[Stealer<T>],\n) -> Option<T> {\n  // Pop a task from the local queue, if not empty.\n  local.pop().or_else(|| {\n    // Otherwise, we need to look for a task elsewhere.\n    iter::repeat_with(|| {\n      // Try stealing a batch of tasks from the global queue.\n      global.steal_batch_and_pop(local)\n        // Or try stealing a task from one of the other threads.\n        .or_else(|| stealers.iter().map(|s| s.steal()).collect())\n    })\n    // Loop while no task was stolen and any steal operation needs to be retried.\n    .find(|s| !s.is_retry())\n    // Extract the stolen task, if there is one.\n    .and_then(|s| s.success())\n  })\n}\n```\n\n## Structs[\u00a7](https://docs.rs/crossbeam-deque/latest/crossbeam_deque/#structs)\n\n[Injector](https://docs.rs/crossbeam-deque/latest/crossbeam_deque/struct.Injector.html \"struct crossbeam_deque::Injector\")\n    An injector queue.\n\n[Stealer](https://docs.rs/crossbeam-deque/latest/crossbeam_deque/struct.Stealer.html \"struct crossbeam_deque::Stealer\")\n    A stealer handle of a worker queue.\n\n[Worker](https://docs.rs/crossbeam-deque/latest/crossbeam_deque/struct.Worker.html \"struct crossbeam_deque::Worker\")\n    A worker queue.\n## Enums[\u00a7](https://docs.rs/crossbeam-deque/latest/crossbeam_deque/#enums)\n\n[Steal](https://docs.rs/crossbeam-deque/latest/crossbeam_deque/enum.Steal.html \"enum crossbeam_deque::Steal\")\n    Possible outcomes of a steal operation.\n",
        "markdown_with_citations": "[](https://docs.rs/crossbeam-deque/latest/crossbeam_deque/all.html \"show sidebar\")\n# Crate crossbeam_dequeCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nConcurrent work-stealing deques.\nThese data structures are most commonly used in work-stealing schedulers. The typical setup involves a number of threads, each having its own FIFO or LIFO queue (_worker_). There is also one global FIFO queue (_injector_) and a list of references to _worker_ queues that are able to steal tasks (_stealers_).\nWe spawn a new task onto the scheduler by pushing it into the _injector_ queue. Each worker thread waits in a loop until it finds the next task to run and then runs it. To find a task, it first looks into its local _worker_ queue, and then into the _injector_ and _stealers_.\n## \u00a7\u27e84\u27e9Queues\n`Injector`\u27e85\u27e9 is a FIFO queue, where tasks are pushed and stolen from opposite ends. It is shared among threads and is usually the entry point for new tasks.\n`Worker`\u27e86\u27e9 has two constructors:\n  * `new_fifo()`\u27e87\u27e9 - Creates a FIFO queue, in which tasks are pushed and popped from opposite ends.\n  * `new_lifo()`\u27e88\u27e9 - Creates a LIFO queue, in which tasks are pushed and popped from the same end.\n\n\nEach `Worker`\u27e86\u27e9 is owned by a single thread and supports only push and pop operations.\nMethod `stealer()`\u27e89\u27e9 creates a `Stealer`\u27e810\u27e9 that may be shared among threads and can only steal tasks from its `Worker`\u27e86\u27e9. Tasks are stolen from the end opposite to where they get pushed.\n## \u00a7\u27e811\u27e9Stealing\nSteal operations come in three flavors:\n  1. `steal()`\u27e812\u27e9 - Steals one task.\n  2. `steal_batch()`\u27e813\u27e9 - Steals a batch of tasks and moves them into another worker.\n  3. `steal_batch_and_pop()`\u27e814\u27e9 - Steals a batch of tasks, moves them into another queue, and pops one task from that worker.\n\n\nIn contrast to push and pop operations, stealing can spuriously fail with `Steal::Retry`\u27e815\u27e9, in which case the steal operation needs to be retried.\n## \u00a7\u27e816\u27e9Examples\nSuppose a thread in a work-stealing scheduler is idle and looking for the next task to run. To find an available task, it might do the following:\n  1. Try popping one task from the local worker queue.\n  2. Try stealing a batch of tasks from the global injector queue.\n  3. Try stealing one task from another thread using the stealer list.\n\n\nAn implementation of this work-stealing strategy:\n```\nuse crossbeam_deque::{Injector, Stealer, Worker};\nuse std::iter;\nfn find_task<T>(\n  local: &Worker<T>,\n  global: &Injector<T>,\n  stealers: &[Stealer<T>],\n) -> Option<T> {\n  // Pop a task from the local queue, if not empty.\n  local.pop().or_else(|| {\n    // Otherwise, we need to look for a task elsewhere.\n    iter::repeat_with(|| {\n      // Try stealing a batch of tasks from the global queue.\n      global.steal_batch_and_pop(local)\n        // Or try stealing a task from one of the other threads.\n        .or_else(|| stealers.iter().map(|s| s.steal()).collect())\n    })\n    // Loop while no task was stolen and any steal operation needs to be retried.\n    .find(|s| !s.is_retry())\n    // Extract the stolen task, if there is one.\n    .and_then(|s| s.success())\n  })\n}\n```\n\n## Structs\u00a7\u27e817\u27e9\n\nInjector\u27e85\u27e9\n    An injector queue.\n\nStealer\u27e810\u27e9\n    A stealer handle of a worker queue.\n\nWorker\u27e86\u27e9\n    A worker queue.\n## Enums\u00a7\u27e818\u27e9\n\nSteal\u27e819\u27e9\n    Possible outcomes of a steal operation.\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/crossbeam-deque/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/crossbeam-deque/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/crossbeam-deque/latest/src/crossbeam_deque/lib.rs.html#1-106: Source\n\u27e84\u27e9 https://docs.rs/crossbeam-deque/latest/crossbeam_deque/#queues: \u00a7\n\u27e85\u27e9 https://docs.rs/crossbeam-deque/latest/crossbeam_deque/struct.Injector.html: struct crossbeam_deque::Injector - `Injector`\n\u27e86\u27e9 https://docs.rs/crossbeam-deque/latest/crossbeam_deque/struct.Worker.html: struct crossbeam_deque::Worker - `Worker`\n\u27e87\u27e9 https://docs.rs/crossbeam-deque/latest/crossbeam_deque/struct.Worker.html#method.new_fifo: associated function crossbeam_deque::Worker::new_fifo - `new_fifo()`\n\u27e88\u27e9 https://docs.rs/crossbeam-deque/latest/crossbeam_deque/struct.Worker.html#method.new_lifo: associated function crossbeam_deque::Worker::new_lifo - `new_lifo()`\n\u27e89\u27e9 https://docs.rs/crossbeam-deque/latest/crossbeam_deque/struct.Worker.html#method.stealer: method crossbeam_deque::Worker::stealer - `stealer()`\n\u27e810\u27e9 https://docs.rs/crossbeam-deque/latest/crossbeam_deque/struct.Stealer.html: struct crossbeam_deque::Stealer - `Stealer`\n\u27e811\u27e9 https://docs.rs/crossbeam-deque/latest/crossbeam_deque/#stealing: \u00a7\n\u27e812\u27e9 https://docs.rs/crossbeam-deque/latest/crossbeam_deque/struct.Stealer.html#method.steal: method crossbeam_deque::Stealer::steal - `steal()`\n\u27e813\u27e9 https://docs.rs/crossbeam-deque/latest/crossbeam_deque/struct.Stealer.html#method.steal_batch: method crossbeam_deque::Stealer::steal_batch - `steal_batch()`\n\u27e814\u27e9 https://docs.rs/crossbeam-deque/latest/crossbeam_deque/struct.Stealer.html#method.steal_batch_and_pop: method crossbeam_deque::Stealer::steal_batch_and_pop - `steal_batch_and_pop()`\n\u27e815\u27e9 https://docs.rs/crossbeam-deque/latest/crossbeam_deque/enum.Steal.html#variant.Retry: variant crossbeam_deque::Steal::Retry - `Steal::Retry`\n\u27e816\u27e9 https://docs.rs/crossbeam-deque/latest/crossbeam_deque/#examples: \u00a7\n\u27e817\u27e9 https://docs.rs/crossbeam-deque/latest/crossbeam_deque/#structs: \u00a7\n\u27e818\u27e9 https://docs.rs/crossbeam-deque/latest/crossbeam_deque/#enums: \u00a7\n\u27e819\u27e9 https://docs.rs/crossbeam-deque/latest/crossbeam_deque/enum.Steal.html: enum crossbeam_deque::Steal - Steal\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `crossbeam-deque` crate provides concurrent work-stealing deques designed for work-stealing schedulers. It features three key components: `Injector` (a global FIFO queue for task injection), `Worker` (thread-local FIFO or LIFO queues for task management), and `Stealer` (handles for stealing tasks from other workers). It supports efficient task stealing operations, including single task, batch, and batch-with-pop stealing, with retry mechanisms for handling spurious failures.",
    "feature_summary": null,
    "use_case": "Utilities",
    "score": 8.0,
    "factual_counterfactual": "### Pair 1: Queue Types  \n\u2705 **Factual:** The `crossbeam-deque` crate provides two types of worker queues: FIFO (`new_fifo()`) and LIFO (`new_lifo()`), allowing tasks to be pushed and popped in different orders depending on the scheduler's needs.  \n\u274c **Counterfactual:** The `crossbeam-deque` crate only supports FIFO queues and does not provide a LIFO queue option for worker threads.  \n\n---\n\n### Pair 2: Stealing Tasks  \n\u2705 **Factual:** The `Stealer` struct in `crossbeam-deque` allows threads to steal tasks from the opposite end of a `Worker` queue, facilitating work-stealing in concurrent applications.  \n\u274c **Counterfactual:** The `Stealer` struct in `crossbeam-deque` allows threads to steal tasks from the same end of a `Worker` queue where tasks are pushed.  \n\n---\n\n### Pair 3: Global Injector Queue  \n\u2705 **Factual:** The `Injector` queue in `crossbeam-deque` acts as a global FIFO queue shared among threads, serving as the entry point for new tasks in a work-stealing scheduler.  \n\u274c **Counterfactual:** The `Injector` queue in `crossbeam-deque` is a LIFO queue shared among threads, where tasks are pushed and popped from the same end.",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}