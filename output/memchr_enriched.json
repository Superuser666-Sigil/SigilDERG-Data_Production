{
    "name": "memchr",
    "version": "2.7.5",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/memchr/latest/memchr/all.html \"show sidebar\")\n# Crate memchrCopy item path\n[Settings](https://docs.rs/memchr/latest/settings.html)\n[Help](https://docs.rs/memchr/latest/help.html)\nSummary[Source](https://docs.rs/memchr/latest/src/memchr/lib.rs.html#1-221)\nExpand description\nThis library provides heavily optimized routines for string search primitives.\n## [\u00a7](https://docs.rs/memchr/latest/memchr/#overview)Overview\nThis section gives a brief high level overview of what this crate offers.\n  * The top-level module provides routines for searching for 1, 2 or 3 bytes in the forward or reverse direction. When searching for more than one byte, positions are considered a match if the byte at that position matches any of the bytes.\n  * The [`memmem`](https://docs.rs/memchr/latest/memchr/memmem/index.html \"mod memchr::memmem\") sub-module provides forward and reverse substring search routines.\n\n\nIn all such cases, routines operate on `&[u8]` without regard to encoding. This is exactly what you want when searching either UTF-8 or arbitrary bytes.\n## [\u00a7](https://docs.rs/memchr/latest/memchr/#example-using-memchr)Example: using `memchr`\nThis example shows how to use `memchr` to find the first occurrence of `z` in a haystack:\n```\nuse memchr::memchr;\nlet haystack = b\"foo bar baz quuz\";\nassert_eq!(Some(10), memchr(b'z', haystack));\n```\n\n## [\u00a7](https://docs.rs/memchr/latest/memchr/#example-matching-one-of-three-possible-bytes)Example: matching one of three possible bytes\nThis examples shows how to use `memrchr3` to find occurrences of `a`, `b` or `c`, starting at the end of the haystack.\n```\nuse memchr::memchr3_iter;\nlet haystack = b\"xyzaxyzbxyzc\";\nlet mut it = memchr3_iter(b'a', b'b', b'c', haystack).rev();\nassert_eq!(Some(11), it.next());\nassert_eq!(Some(7), it.next());\nassert_eq!(Some(3), it.next());\nassert_eq!(None, it.next());\n```\n\n## [\u00a7](https://docs.rs/memchr/latest/memchr/#example-iterating-over-substring-matches)Example: iterating over substring matches\nThis example shows how to use the [`memmem`](https://docs.rs/memchr/latest/memchr/memmem/index.html \"mod memchr::memmem\") sub-module to find occurrences of a substring in a haystack.\n```\nuse memchr::memmem;\nlet haystack = b\"foo bar foo baz foo\";\nlet mut it = memmem::find_iter(haystack, \"foo\");\nassert_eq!(Some(0), it.next());\nassert_eq!(Some(8), it.next());\nassert_eq!(Some(16), it.next());\nassert_eq!(None, it.next());\n```\n\n## [\u00a7](https://docs.rs/memchr/latest/memchr/#example-repeating-a-search-for-the-same-needle)Example: repeating a search for the same needle\nIt may be possible for the overhead of constructing a substring searcher to be measurable in some workloads. In cases where the same needle is used to search many haystacks, it is possible to do construction once and thus to avoid it for subsequent searches. This can be done with a [`memmem::Finder`](https://docs.rs/memchr/latest/memchr/memmem/struct.Finder.html \"struct memchr::memmem::Finder\"):\n```\nuse memchr::memmem;\nlet finder = memmem::Finder::new(\"foo\");\nassert_eq!(Some(4), finder.find(b\"baz foo quux\"));\nassert_eq!(None, finder.find(b\"quux baz bar\"));\n```\n\n## [\u00a7](https://docs.rs/memchr/latest/memchr/#why-use-this-crate)Why use this crate?\nAt first glance, the APIs provided by this crate might seem weird. Why provide a dedicated routine like `memchr` for something that could be implemented clearly and trivially in one line:\n```\nfn memchr(needle: u8, haystack: &[u8]) -> Option<usize> {\n  haystack.iter().position(|&b| b == needle)\n}\n```\n\nOr similarly, why does this crate provide substring search routines when Rust\u2019s core library already provides them?\n```\nfn search(haystack: &str, needle: &str) -> Option<usize> {\n  haystack.find(needle)\n}\n```\n\nThe primary reason for both of them to exist is performance. When it comes to performance, at a high level at least, there are two primary ways to look at it:\n  * **Throughput** : For this, think about it as, \u201cgiven some very large haystack and a byte that never occurs in that haystack, how long does it take to search through it and determine that it, in fact, does not occur?\u201d\n  * **Latency** : For this, think about it as, \u201cgiven a tiny haystack\u2014just a few bytes\u2014how long does it take to determine if a byte is in it?\u201d\n\n\nThe `memchr` routine in this crate has _slightly_ worse latency than the solution presented above, however, its throughput can easily be over an order of magnitude faster. This is a good general purpose trade off to make. You rarely lose, but often gain big.\n**NOTE:** The name `memchr` comes from the corresponding routine in `libc`. A key advantage of using this library is that its performance is not tied to its quality of implementation in the `libc` you happen to be using, which can vary greatly from platform to platform.\nBut what about substring search? This one is a bit more complicated. The primary reason for its existence is still indeed performance, but it\u2019s also useful because Rust\u2019s core library doesn\u2019t actually expose any substring search routine on arbitrary bytes. The only substring search routine that exists works exclusively on valid UTF-8.\nSo if you have valid UTF-8, is there a reason to use this over the standard library substring search routine? Yes. This routine is faster on almost every metric, including latency. The natural question then, is why isn\u2019t this implementation in the standard library, even if only for searching on UTF-8? The reason is that the implementation details for using SIMD in the standard library haven\u2019t quite been worked out yet.\n**NOTE:** Currently, only `x86_64`, `wasm32` and `aarch64` targets have vector accelerated implementations of `memchr` (and friends) and `memmem`.\n## [\u00a7](https://docs.rs/memchr/latest/memchr/#crate-features)Crate features\n  * **std** - When enabled (the default), this will permit features specific to the standard library. Currently, the only thing used from the standard library is runtime SIMD CPU feature detection. This means that this feature must be enabled to get AVX2 accelerated routines on `x86_64` targets without enabling the `avx2` feature at compile time, for example. When `std` is not enabled, this crate will still attempt to use SSE2 accelerated routines on `x86_64`. It will also use AVX2 accelerated routines when the `avx2` feature is enabled at compile time. In general, enable this feature if you can.\n  * **alloc** - When enabled (the default), APIs in this crate requiring some kind of allocation will become available. For example, the [`memmem::Finder::into_owned`](https://docs.rs/memchr/latest/memchr/memmem/struct.Finder.html#method.into_owned \"method memchr::memmem::Finder::into_owned\") API and the [`arch::all::shiftor`](https://docs.rs/memchr/latest/memchr/arch/all/shiftor/index.html \"mod memchr::arch::all::shiftor\") substring search implementation. Otherwise, this crate is designed from the ground up to be usable in core-only contexts, so the `alloc` feature doesn\u2019t add much currently. Notably, disabling `std` but enabling `alloc` will **not** result in the use of AVX2 on `x86_64` targets unless the `avx2` feature is enabled at compile time. (With `std` enabled, AVX2 can be used even without the `avx2` feature enabled at compile time by way of runtime CPU feature detection.)\n  * **logging** - When enabled (disabled by default), the `log` crate is used to emit log messages about what kinds of `memchr` and `memmem` algorithms are used. Namely, both `memchr` and `memmem` have a number of different implementation choices depending on the target and CPU, and the log messages can help show what specific implementations are being used. Generally, this is useful for debugging performance issues.\n  * **libc** - **DEPRECATED**. Previously, this enabled the use of the target\u2019s `memchr` function from whatever `libc` was linked into the program. This feature is now a no-op because this crate\u2019s implementation of `memchr` should now be sufficiently fast on a number of platforms that `libc` should no longer be needed. (This feature is somewhat of a holdover from this crate\u2019s origins. Originally, this crate was literally just a safe wrapper function around the `memchr` function from `libc`.)\n\n\n## Modules[\u00a7](https://docs.rs/memchr/latest/memchr/#modules)\n\n[arch](https://docs.rs/memchr/latest/memchr/arch/index.html \"mod memchr::arch\")\n    A module with low-level architecture dependent routines.\n\n[memmem](https://docs.rs/memchr/latest/memchr/memmem/index.html \"mod memchr::memmem\")\n    This module provides forward and reverse substring search routines.\n## Structs[\u00a7](https://docs.rs/memchr/latest/memchr/#structs)\n\n[Memchr](https://docs.rs/memchr/latest/memchr/struct.Memchr.html \"struct memchr::Memchr\")\n    An iterator over all occurrences of a single byte in a haystack.\n\n[Memchr2](https://docs.rs/memchr/latest/memchr/struct.Memchr2.html \"struct memchr::Memchr2\")\n    An iterator over all occurrences of two possible bytes in a haystack.\n\n[Memchr3](https://docs.rs/memchr/latest/memchr/struct.Memchr3.html \"struct memchr::Memchr3\")\n    An iterator over all occurrences of three possible bytes in a haystack.\n## Functions[\u00a7](https://docs.rs/memchr/latest/memchr/#functions)\n\n[memchr](https://docs.rs/memchr/latest/memchr/fn.memchr.html \"fn memchr::memchr\")\n    Search for the first occurrence of a byte in a slice.\n\n[memchr2](https://docs.rs/memchr/latest/memchr/fn.memchr2.html \"fn memchr::memchr2\")\n    Search for the first occurrence of two possible bytes in a haystack.\n\n[memchr3](https://docs.rs/memchr/latest/memchr/fn.memchr3.html \"fn memchr::memchr3\")\n    Search for the first occurrence of three possible bytes in a haystack.\n\n[memchr2_iter](https://docs.rs/memchr/latest/memchr/fn.memchr2_iter.html \"fn memchr::memchr2_iter\")\n    Returns an iterator over all occurrences of the needles in a haystack.\n\n[memchr3_iter](https://docs.rs/memchr/latest/memchr/fn.memchr3_iter.html \"fn memchr::memchr3_iter\")\n    Returns an iterator over all occurrences of the needles in a haystack.\n\n[memchr_iter](https://docs.rs/memchr/latest/memchr/fn.memchr_iter.html \"fn memchr::memchr_iter\")\n    Returns an iterator over all occurrences of the needle in a haystack.\n\n[memrchr](https://docs.rs/memchr/latest/memchr/fn.memrchr.html \"fn memchr::memrchr\")\n    Search for the last occurrence of a byte in a slice.\n\n[memrchr2](https://docs.rs/memchr/latest/memchr/fn.memrchr2.html \"fn memchr::memrchr2\")\n    Search for the last occurrence of two possible bytes in a haystack.\n\n[memrchr3](https://docs.rs/memchr/latest/memchr/fn.memrchr3.html \"fn memchr::memrchr3\")\n    Search for the last occurrence of three possible bytes in a haystack.\n\n[memrchr2_iter](https://docs.rs/memchr/latest/memchr/fn.memrchr2_iter.html \"fn memchr::memrchr2_iter\")\n    Returns an iterator over all occurrences of the needles in a haystack, in reverse.\n\n[memrchr3_iter](https://docs.rs/memchr/latest/memchr/fn.memrchr3_iter.html \"fn memchr::memrchr3_iter\")\n    Returns an iterator over all occurrences of the needles in a haystack, in reverse.\n\n[memrchr_iter](https://docs.rs/memchr/latest/memchr/fn.memrchr_iter.html \"fn memchr::memrchr_iter\")\n    Returns an iterator over all occurrences of the needle in a haystack, in reverse.\n",
        "markdown_with_citations": "[](https://docs.rs/memchr/latest/memchr/all.html \"show sidebar\")\n# Crate memchrCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nThis library provides heavily optimized routines for string search primitives.\n## \u00a7\u27e84\u27e9Overview\nThis section gives a brief high level overview of what this crate offers.\n  * The top-level module provides routines for searching for 1, 2 or 3 bytes in the forward or reverse direction. When searching for more than one byte, positions are considered a match if the byte at that position matches any of the bytes.\n  * The `memmem`\u27e85\u27e9 sub-module provides forward and reverse substring search routines.\n\n\nIn all such cases, routines operate on `&[u8]` without regard to encoding. This is exactly what you want when searching either UTF-8 or arbitrary bytes.\n## \u00a7\u27e86\u27e9Example: using `memchr`\nThis example shows how to use `memchr` to find the first occurrence of `z` in a haystack:\n```\nuse memchr::memchr;\nlet haystack = b\"foo bar baz quuz\";\nassert_eq!(Some(10), memchr(b'z', haystack));\n```\n\n## \u00a7\u27e87\u27e9Example: matching one of three possible bytes\nThis examples shows how to use `memrchr3` to find occurrences of `a`, `b` or `c`, starting at the end of the haystack.\n```\nuse memchr::memchr3_iter;\nlet haystack = b\"xyzaxyzbxyzc\";\nlet mut it = memchr3_iter(b'a', b'b', b'c', haystack).rev();\nassert_eq!(Some(11), it.next());\nassert_eq!(Some(7), it.next());\nassert_eq!(Some(3), it.next());\nassert_eq!(None, it.next());\n```\n\n## \u00a7\u27e88\u27e9Example: iterating over substring matches\nThis example shows how to use the `memmem`\u27e85\u27e9 sub-module to find occurrences of a substring in a haystack.\n```\nuse memchr::memmem;\nlet haystack = b\"foo bar foo baz foo\";\nlet mut it = memmem::find_iter(haystack, \"foo\");\nassert_eq!(Some(0), it.next());\nassert_eq!(Some(8), it.next());\nassert_eq!(Some(16), it.next());\nassert_eq!(None, it.next());\n```\n\n## \u00a7\u27e89\u27e9Example: repeating a search for the same needle\nIt may be possible for the overhead of constructing a substring searcher to be measurable in some workloads. In cases where the same needle is used to search many haystacks, it is possible to do construction once and thus to avoid it for subsequent searches. This can be done with a `memmem::Finder`\u27e810\u27e9:\n```\nuse memchr::memmem;\nlet finder = memmem::Finder::new(\"foo\");\nassert_eq!(Some(4), finder.find(b\"baz foo quux\"));\nassert_eq!(None, finder.find(b\"quux baz bar\"));\n```\n\n## \u00a7\u27e811\u27e9Why use this crate?\nAt first glance, the APIs provided by this crate might seem weird. Why provide a dedicated routine like `memchr` for something that could be implemented clearly and trivially in one line:\n```\nfn memchr(needle: u8, haystack: &[u8]) -> Option<usize> {\n  haystack.iter().position(|&b| b == needle)\n}\n```\n\nOr similarly, why does this crate provide substring search routines when Rust\u2019s core library already provides them?\n```\nfn search(haystack: &str, needle: &str) -> Option<usize> {\n  haystack.find(needle)\n}\n```\n\nThe primary reason for both of them to exist is performance. When it comes to performance, at a high level at least, there are two primary ways to look at it:\n  * **Throughput** : For this, think about it as, \u201cgiven some very large haystack and a byte that never occurs in that haystack, how long does it take to search through it and determine that it, in fact, does not occur?\u201d\n  * **Latency** : For this, think about it as, \u201cgiven a tiny haystack\u2014just a few bytes\u2014how long does it take to determine if a byte is in it?\u201d\n\n\nThe `memchr` routine in this crate has _slightly_ worse latency than the solution presented above, however, its throughput can easily be over an order of magnitude faster. This is a good general purpose trade off to make. You rarely lose, but often gain big.\n**NOTE:** The name `memchr` comes from the corresponding routine in `libc`. A key advantage of using this library is that its performance is not tied to its quality of implementation in the `libc` you happen to be using, which can vary greatly from platform to platform.\nBut what about substring search? This one is a bit more complicated. The primary reason for its existence is still indeed performance, but it\u2019s also useful because Rust\u2019s core library doesn\u2019t actually expose any substring search routine on arbitrary bytes. The only substring search routine that exists works exclusively on valid UTF-8.\nSo if you have valid UTF-8, is there a reason to use this over the standard library substring search routine? Yes. This routine is faster on almost every metric, including latency. The natural question then, is why isn\u2019t this implementation in the standard library, even if only for searching on UTF-8? The reason is that the implementation details for using SIMD in the standard library haven\u2019t quite been worked out yet.\n**NOTE:** Currently, only `x86_64`, `wasm32` and `aarch64` targets have vector accelerated implementations of `memchr` (and friends) and `memmem`.\n## \u00a7\u27e812\u27e9Crate features\n  * **std** - When enabled (the default), this will permit features specific to the standard library. Currently, the only thing used from the standard library is runtime SIMD CPU feature detection. This means that this feature must be enabled to get AVX2 accelerated routines on `x86_64` targets without enabling the `avx2` feature at compile time, for example. When `std` is not enabled, this crate will still attempt to use SSE2 accelerated routines on `x86_64`. It will also use AVX2 accelerated routines when the `avx2` feature is enabled at compile time. In general, enable this feature if you can.\n  * **alloc** - When enabled (the default), APIs in this crate requiring some kind of allocation will become available. For example, the `memmem::Finder::into_owned`\u27e813\u27e9 API and the `arch::all::shiftor`\u27e814\u27e9 substring search implementation. Otherwise, this crate is designed from the ground up to be usable in core-only contexts, so the `alloc` feature doesn\u2019t add much currently. Notably, disabling `std` but enabling `alloc` will **not** result in the use of AVX2 on `x86_64` targets unless the `avx2` feature is enabled at compile time. (With `std` enabled, AVX2 can be used even without the `avx2` feature enabled at compile time by way of runtime CPU feature detection.)\n  * **logging** - When enabled (disabled by default), the `log` crate is used to emit log messages about what kinds of `memchr` and `memmem` algorithms are used. Namely, both `memchr` and `memmem` have a number of different implementation choices depending on the target and CPU, and the log messages can help show what specific implementations are being used. Generally, this is useful for debugging performance issues.\n  * **libc** - **DEPRECATED**. Previously, this enabled the use of the target\u2019s `memchr` function from whatever `libc` was linked into the program. This feature is now a no-op because this crate\u2019s implementation of `memchr` should now be sufficiently fast on a number of platforms that `libc` should no longer be needed. (This feature is somewhat of a holdover from this crate\u2019s origins. Originally, this crate was literally just a safe wrapper function around the `memchr` function from `libc`.)\n\n\n## Modules\u00a7\u27e815\u27e9\n\narch\u27e816\u27e9\n    A module with low-level architecture dependent routines.\n\nmemmem\u27e85\u27e9\n    This module provides forward and reverse substring search routines.\n## Structs\u00a7\u27e817\u27e9\n\nMemchr\u27e818\u27e9\n    An iterator over all occurrences of a single byte in a haystack.\n\nMemchr2\u27e819\u27e9\n    An iterator over all occurrences of two possible bytes in a haystack.\n\nMemchr3\u27e820\u27e9\n    An iterator over all occurrences of three possible bytes in a haystack.\n## Functions\u00a7\u27e821\u27e9\n\nmemchr\u27e822\u27e9\n    Search for the first occurrence of a byte in a slice.\n\nmemchr2\u27e823\u27e9\n    Search for the first occurrence of two possible bytes in a haystack.\n\nmemchr3\u27e824\u27e9\n    Search for the first occurrence of three possible bytes in a haystack.\n\nmemchr2_iter\u27e825\u27e9\n    Returns an iterator over all occurrences of the needles in a haystack.\n\nmemchr3_iter\u27e826\u27e9\n    Returns an iterator over all occurrences of the needles in a haystack.\n\nmemchr_iter\u27e827\u27e9\n    Returns an iterator over all occurrences of the needle in a haystack.\n\nmemrchr\u27e828\u27e9\n    Search for the last occurrence of a byte in a slice.\n\nmemrchr2\u27e829\u27e9\n    Search for the last occurrence of two possible bytes in a haystack.\n\nmemrchr3\u27e830\u27e9\n    Search for the last occurrence of three possible bytes in a haystack.\n\nmemrchr2_iter\u27e831\u27e9\n    Returns an iterator over all occurrences of the needles in a haystack, in reverse.\n\nmemrchr3_iter\u27e832\u27e9\n    Returns an iterator over all occurrences of the needles in a haystack, in reverse.\n\nmemrchr_iter\u27e833\u27e9\n    Returns an iterator over all occurrences of the needle in a haystack, in reverse.\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/memchr/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/memchr/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/memchr/latest/src/memchr/lib.rs.html#1-221: Source\n\u27e84\u27e9 https://docs.rs/memchr/latest/memchr/#overview: \u00a7\n\u27e85\u27e9 https://docs.rs/memchr/latest/memchr/memmem/index.html: mod memchr::memmem - `memmem`\n\u27e86\u27e9 https://docs.rs/memchr/latest/memchr/#example-using-memchr: \u00a7\n\u27e87\u27e9 https://docs.rs/memchr/latest/memchr/#example-matching-one-of-three-possible-bytes: \u00a7\n\u27e88\u27e9 https://docs.rs/memchr/latest/memchr/#example-iterating-over-substring-matches: \u00a7\n\u27e89\u27e9 https://docs.rs/memchr/latest/memchr/#example-repeating-a-search-for-the-same-needle: \u00a7\n\u27e810\u27e9 https://docs.rs/memchr/latest/memchr/memmem/struct.Finder.html: struct memchr::memmem::Finder - `memmem::Finder`\n\u27e811\u27e9 https://docs.rs/memchr/latest/memchr/#why-use-this-crate: \u00a7\n\u27e812\u27e9 https://docs.rs/memchr/latest/memchr/#crate-features: \u00a7\n\u27e813\u27e9 https://docs.rs/memchr/latest/memchr/memmem/struct.Finder.html#method.into_owned: method memchr::memmem::Finder::into_owned - `memmem::Finder::into_owned`\n\u27e814\u27e9 https://docs.rs/memchr/latest/memchr/arch/all/shiftor/index.html: mod memchr::arch::all::shiftor - `arch::all::shiftor`\n\u27e815\u27e9 https://docs.rs/memchr/latest/memchr/#modules: \u00a7\n\u27e816\u27e9 https://docs.rs/memchr/latest/memchr/arch/index.html: mod memchr::arch - arch\n\u27e817\u27e9 https://docs.rs/memchr/latest/memchr/#structs: \u00a7\n\u27e818\u27e9 https://docs.rs/memchr/latest/memchr/struct.Memchr.html: struct memchr::Memchr - Memchr\n\u27e819\u27e9 https://docs.rs/memchr/latest/memchr/struct.Memchr2.html: struct memchr::Memchr2 - Memchr2\n\u27e820\u27e9 https://docs.rs/memchr/latest/memchr/struct.Memchr3.html: struct memchr::Memchr3 - Memchr3\n\u27e821\u27e9 https://docs.rs/memchr/latest/memchr/#functions: \u00a7\n\u27e822\u27e9 https://docs.rs/memchr/latest/memchr/fn.memchr.html: fn memchr::memchr - memchr\n\u27e823\u27e9 https://docs.rs/memchr/latest/memchr/fn.memchr2.html: fn memchr::memchr2 - memchr2\n\u27e824\u27e9 https://docs.rs/memchr/latest/memchr/fn.memchr3.html: fn memchr::memchr3 - memchr3\n\u27e825\u27e9 https://docs.rs/memchr/latest/memchr/fn.memchr2_iter.html: fn memchr::memchr2_iter - memchr2_iter\n\u27e826\u27e9 https://docs.rs/memchr/latest/memchr/fn.memchr3_iter.html: fn memchr::memchr3_iter - memchr3_iter\n\u27e827\u27e9 https://docs.rs/memchr/latest/memchr/fn.memchr_iter.html: fn memchr::memchr_iter - memchr_iter\n\u27e828\u27e9 https://docs.rs/memchr/latest/memchr/fn.memrchr.html: fn memchr::memrchr - memrchr\n\u27e829\u27e9 https://docs.rs/memchr/latest/memchr/fn.memrchr2.html: fn memchr::memrchr2 - memrchr2\n\u27e830\u27e9 https://docs.rs/memchr/latest/memchr/fn.memrchr3.html: fn memchr::memrchr3 - memrchr3\n\u27e831\u27e9 https://docs.rs/memchr/latest/memchr/fn.memrchr2_iter.html: fn memchr::memrchr2_iter - memrchr2_iter\n\u27e832\u27e9 https://docs.rs/memchr/latest/memchr/fn.memrchr3_iter.html: fn memchr::memrchr3_iter - memrchr3_iter\n\u27e833\u27e9 https://docs.rs/memchr/latest/memchr/fn.memrchr_iter.html: fn memchr::memrchr_iter - memrchr_iter\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `memchr` crate provides highly optimized routines for searching bytes or substrings in a `&[u8]` slice, supporting forward and reverse searches for single, multiple, or substring matches. It offers fast performance using SIMD acceleration on supported platforms (`x86_64`, `wasm32`, `aarch64`) and includes iterator-based APIs for repeated or bulk searches. Key features include `memchr`, `memmem` substring search, and configurable crate features like `std`, `alloc`, and optional logging.",
    "feature_summary": null,
    "use_case": "Utilities",
    "score": 8.5,
    "factual_counterfactual": "### Pair 1: Searching for a Single Byte\n\u2705 **Factual**: The `memchr` function in the `memchr` crate is optimized to find the first occurrence of a single byte in a slice of `&[u8]`, offering better throughput than a naive implementation using `haystack.iter().position(|&b| b == needle)`.\n\u274c **Counterfactual**: The `memchr` function can only search for single bytes in UTF-8 encoded strings and does not work on arbitrary byte slices.\n\n---\n\n### Pair 2: Substring Search with SIMD\n\u2705 **Factual**: The `memmem` sub-module in the `memchr` crate provides substring search routines that leverage SIMD acceleration on supported architectures like `x86_64`, `wasm32`, and `aarch64`.\n\u274c **Counterfactual**: The `memmem` sub-module is limited to non-SIMD implementations and does not utilize vector acceleration on any architecture.\n\n---\n\n### Pair 3: Reverse Search for Multiple Bytes\n\u2705 **Factual**: The `memrchr3_iter` function in the `memchr` crate allows reverse iteration over all occurrences of three specified bytes in a haystack, providing efficient backward search capabilities.\n\u274c **Counterfactual**: The `memrchr3_iter` function only supports forward iteration and cannot perform reverse searches for multiple bytes.",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}