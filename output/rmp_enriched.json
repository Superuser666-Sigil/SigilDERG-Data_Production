{
    "name": "rmp",
    "version": "0.8.14",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/rmp/latest/rmp/all.html \"show sidebar\")\n# Crate rmpCopy item path\n[Settings](https://docs.rs/rmp/latest/settings.html)\n[Help](https://docs.rs/rmp/latest/help.html)\nSummary[Source](https://docs.rs/rmp/latest/src/rmp/lib.rs.html#1-14)\nExpand description\n### [\u00a7](https://docs.rs/rmp/latest/rmp/#the-rust-messagepack-library)The Rust MessagePack Library\nRMP is a pure Rust [MessagePack](http://msgpack.org) implementation of an efficient binary serialization format. This crate provides low-level core functionality, writers and readers for primitive values with direct mapping between binary MessagePack format.\n[Looking for Serde support](https://lib.rs/crates/rmp-serde)?\nThis crate represents the very basic functionality needed to work with MessagePack format. Ideologically it is developed as a basis for building high-level abstractions.\n#### [\u00a7](https://docs.rs/rmp/latest/rmp/#usage)Usage\nTo use `rmp`, first add this to your `Cargo.toml`:\n```\n[dependencies.rmp]\nrmp = \"0.8\"\n```\n\n#### [\u00a7](https://docs.rs/rmp/latest/rmp/#features)Features\n  * **Low-level API**\nRMP is designed to be lightweight and straightforward. There are low-level APIs, which give you full control over the encoding/decoding process. `no-std` environments are supported.\n  * **Zero-copy value decoding**\nRMP allows to decode bytes from a buffer in a zero-copy manner, without any heap allocations. easily and blazingly fast. Rust static checks guarantee that the data will be valid until buffer lives.\n  * **Clear error handling**\nRMP\u2019s error system guarantees that you never receive an error enum with unreachable variant.\n  * **Robust and tested**\nThis project is developed using TDD and CI, so any found bugs will be fixed without breaking existing functionality.\n\n\n#### [\u00a7](https://docs.rs/rmp/latest/rmp/#detailed)Detailed\nCurrently there are two large modules: encode and decode. More detail you can find in the corresponding sections.\nFormally every MessagePack message consists of some marker encapsulating a data type and the data itself. Sometimes there are no separate data chunk, for example for booleans. In these cases a marker contains the value. For example, the `true` value is encoded as `0xc3`.\n```\nlet mut buf = Vec::new();\nrmp::encode::write_bool(&mut buf, true).unwrap();\nassert_eq!([0xc3], buf[..]);\n```\n\nSometimes a single value can be encoded in multiple ways. For example a value of `42` can be represented as: `[0x2a], [0xcc, 0x2a], [0xcd, 0x00, 0x2a]` and so on, and all of them are considered as valid representations. To allow fine-grained control over encoding such values the library provides direct mapping functions.\n```\nlet mut bufs = vec![vec![]; 5];\nrmp::encode::write_pfix(&mut bufs[0], 42).unwrap();\nrmp::encode::write_u8(&mut bufs[1], 42).unwrap();\nrmp::encode::write_u16(&mut bufs[2], 42).unwrap();\nrmp::encode::write_u32(&mut bufs[3], 42).unwrap();\nrmp::encode::write_u64(&mut bufs[4], 42).unwrap();\nassert_eq!([0x2a], bufs[0][..]);\nassert_eq!([0xcc, 0x2a], bufs[1][..]);\nassert_eq!([0xcd, 0x00, 0x2a], bufs[2][..]);\nassert_eq!([0xce, 0x00, 0x00, 0x00, 0x2a], bufs[3][..]);\nassert_eq!([0xcf, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2a], bufs[4][..]);\n```\n\nBut they aren\u2019t planned to be widely used. Instead we often need to encode bytes compactly to save space. In these cases RMP provides functions that guarantee that for encoding the most compact representation will be chosen.\n```\nlet mut buf = Vec::new();\nrmp::encode::write_sint(&mut buf, 300).unwrap();\nassert_eq!([0xcd, 0x1, 0x2c], buf[..]);\n```\n\nOn the other hand for deserialization it is not matter in which representation the value is encoded - RMP deals with all of them.\nSometimes you know the exact type representation and want to enforce the deserialization process to make it strongly type safe.\n```\nlet buf = [0xcd, 0x1, 0x2c];\nassert_eq!(300, rmp::decode::read_u16(&mut &buf[..]).unwrap());\n```\n\nHowever if you try to decode such bytearray as other integer type, for example `u32`, there will be type mismatch error.\n```\nlet buf = [0xcd, 0x1, 0x2c];\nrmp::decode::read_u32(&mut &buf[..]).err().unwrap();\n```\n\nBut sometimes all you want is just to encode an integer that _must_ fit in the specified type no matter how it was encoded. RMP provides [`such`](https://docs.rs/rmp/latest/rmp/decode/fn.read_int.html) function to ease integration with other MessagePack libraries.\n```\nlet buf = [0xcd, 0x1, 0x2c];\nassert_eq!(300i16, rmp::decode::read_int(&mut &buf[..]).unwrap());\nassert_eq!(300i32, rmp::decode::read_int(&mut &buf[..]).unwrap());\nassert_eq!(300i64, rmp::decode::read_int(&mut &buf[..]).unwrap());\nassert_eq!(300u16, rmp::decode::read_int(&mut &buf[..]).unwrap());\nassert_eq!(300u32, rmp::decode::read_int(&mut &buf[..]).unwrap());\nassert_eq!(300u64, rmp::decode::read_int(&mut &buf[..]).unwrap());\n```\n\n#### [\u00a7](https://docs.rs/rmp/latest/rmp/#api)API\nAlmost all API are represented as pure functions, which accepts a generic `Write` or `Read` and the value to be encoded/decoded. For example let\u2019s do a round trip for \u03c0 number.\n```\nlet pi = std::f64::consts::PI;\nlet mut buf = Vec::new();\nrmp::encode::write_f64(&mut buf, pi).unwrap();\nassert_eq!([0xcb, 0x40, 0x9, 0x21, 0xfb, 0x54, 0x44, 0x2d, 0x18], buf[..]);\nassert_eq!(pi, rmp::decode::read_f64(&mut &buf[..]).unwrap());\n```\n\nLicense: MIT\n## Modules[\u00a7](https://docs.rs/rmp/latest/rmp/#modules)\n\n[decode](https://docs.rs/rmp/latest/rmp/decode/index.html \"mod rmp::decode\")\n    Provides various functions and structs for MessagePack decoding.\n\n[encode](https://docs.rs/rmp/latest/rmp/encode/index.html \"mod rmp::encode\")\n    Provides various functions and structs for MessagePack encoding.\n## Enums[\u00a7](https://docs.rs/rmp/latest/rmp/#enums)\n\n[Marker](https://docs.rs/rmp/latest/rmp/enum.Marker.html \"enum rmp::Marker\")\n    Format markers.\n## Constants[\u00a7](https://docs.rs/rmp/latest/rmp/#constants)\n\n[MSGPACK_VERSION](https://docs.rs/rmp/latest/rmp/constant.MSGPACK_VERSION.html \"constant rmp::MSGPACK_VERSION\")\n    Version of the MessagePack [spec](http://github.com/msgpack/msgpack/blob/master/spec.md).\n",
        "markdown_with_citations": "[](https://docs.rs/rmp/latest/rmp/all.html \"show sidebar\")\n# Crate rmpCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\n### \u00a7\u27e84\u27e9The Rust MessagePack Library\nRMP is a pure Rust MessagePack\u27e85\u27e9 implementation of an efficient binary serialization format. This crate provides low-level core functionality, writers and readers for primitive values with direct mapping between binary MessagePack format.\nLooking for Serde support\u27e86\u27e9?\nThis crate represents the very basic functionality needed to work with MessagePack format. Ideologically it is developed as a basis for building high-level abstractions.\n#### \u00a7\u27e87\u27e9Usage\nTo use `rmp`, first add this to your `Cargo.toml`:\n```\n[dependencies.rmp]\nrmp = \"0.8\"\n```\n\n#### \u00a7\u27e88\u27e9Features\n  * **Low-level API**\nRMP is designed to be lightweight and straightforward. There are low-level APIs, which give you full control over the encoding/decoding process. `no-std` environments are supported.\n  * **Zero-copy value decoding**\nRMP allows to decode bytes from a buffer in a zero-copy manner, without any heap allocations. easily and blazingly fast. Rust static checks guarantee that the data will be valid until buffer lives.\n  * **Clear error handling**\nRMP\u2019s error system guarantees that you never receive an error enum with unreachable variant.\n  * **Robust and tested**\nThis project is developed using TDD and CI, so any found bugs will be fixed without breaking existing functionality.\n\n\n#### \u00a7\u27e89\u27e9Detailed\nCurrently there are two large modules: encode and decode. More detail you can find in the corresponding sections.\nFormally every MessagePack message consists of some marker encapsulating a data type and the data itself. Sometimes there are no separate data chunk, for example for booleans. In these cases a marker contains the value. For example, the `true` value is encoded as `0xc3`.\n```\nlet mut buf = Vec::new();\nrmp::encode::write_bool(&mut buf, true).unwrap();\nassert_eq!([0xc3], buf[..]);\n```\n\nSometimes a single value can be encoded in multiple ways. For example a value of `42` can be represented as: `[0x2a], [0xcc, 0x2a], [0xcd, 0x00, 0x2a]` and so on, and all of them are considered as valid representations. To allow fine-grained control over encoding such values the library provides direct mapping functions.\n```\nlet mut bufs = vec![vec![]; 5];\nrmp::encode::write_pfix(&mut bufs[0], 42).unwrap();\nrmp::encode::write_u8(&mut bufs[1], 42).unwrap();\nrmp::encode::write_u16(&mut bufs[2], 42).unwrap();\nrmp::encode::write_u32(&mut bufs[3], 42).unwrap();\nrmp::encode::write_u64(&mut bufs[4], 42).unwrap();\nassert_eq!([0x2a], bufs[0][..]);\nassert_eq!([0xcc, 0x2a], bufs[1][..]);\nassert_eq!([0xcd, 0x00, 0x2a], bufs[2][..]);\nassert_eq!([0xce, 0x00, 0x00, 0x00, 0x2a], bufs[3][..]);\nassert_eq!([0xcf, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2a], bufs[4][..]);\n```\n\nBut they aren\u2019t planned to be widely used. Instead we often need to encode bytes compactly to save space. In these cases RMP provides functions that guarantee that for encoding the most compact representation will be chosen.\n```\nlet mut buf = Vec::new();\nrmp::encode::write_sint(&mut buf, 300).unwrap();\nassert_eq!([0xcd, 0x1, 0x2c], buf[..]);\n```\n\nOn the other hand for deserialization it is not matter in which representation the value is encoded - RMP deals with all of them.\nSometimes you know the exact type representation and want to enforce the deserialization process to make it strongly type safe.\n```\nlet buf = [0xcd, 0x1, 0x2c];\nassert_eq!(300, rmp::decode::read_u16(&mut &buf[..]).unwrap());\n```\n\nHowever if you try to decode such bytearray as other integer type, for example `u32`, there will be type mismatch error.\n```\nlet buf = [0xcd, 0x1, 0x2c];\nrmp::decode::read_u32(&mut &buf[..]).err().unwrap();\n```\n\nBut sometimes all you want is just to encode an integer that _must_ fit in the specified type no matter how it was encoded. RMP provides `such`\u27e810\u27e9 function to ease integration with other MessagePack libraries.\n```\nlet buf = [0xcd, 0x1, 0x2c];\nassert_eq!(300i16, rmp::decode::read_int(&mut &buf[..]).unwrap());\nassert_eq!(300i32, rmp::decode::read_int(&mut &buf[..]).unwrap());\nassert_eq!(300i64, rmp::decode::read_int(&mut &buf[..]).unwrap());\nassert_eq!(300u16, rmp::decode::read_int(&mut &buf[..]).unwrap());\nassert_eq!(300u32, rmp::decode::read_int(&mut &buf[..]).unwrap());\nassert_eq!(300u64, rmp::decode::read_int(&mut &buf[..]).unwrap());\n```\n\n#### \u00a7\u27e811\u27e9API\nAlmost all API are represented as pure functions, which accepts a generic `Write` or `Read` and the value to be encoded/decoded. For example let\u2019s do a round trip for \u03c0 number.\n```\nlet pi = std::f64::consts::PI;\nlet mut buf = Vec::new();\nrmp::encode::write_f64(&mut buf, pi).unwrap();\nassert_eq!([0xcb, 0x40, 0x9, 0x21, 0xfb, 0x54, 0x44, 0x2d, 0x18], buf[..]);\nassert_eq!(pi, rmp::decode::read_f64(&mut &buf[..]).unwrap());\n```\n\nLicense: MIT\n## Modules\u00a7\u27e812\u27e9\n\ndecode\u27e813\u27e9\n    Provides various functions and structs for MessagePack decoding.\n\nencode\u27e814\u27e9\n    Provides various functions and structs for MessagePack encoding.\n## Enums\u00a7\u27e815\u27e9\n\nMarker\u27e816\u27e9\n    Format markers.\n## Constants\u00a7\u27e817\u27e9\n\nMSGPACK_VERSION\u27e818\u27e9\n    Version of the MessagePack spec\u27e819\u27e9.\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/rmp/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/rmp/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/rmp/latest/src/rmp/lib.rs.html#1-14: Source\n\u27e84\u27e9 https://docs.rs/rmp/latest/rmp/#the-rust-messagepack-library: \u00a7\n\u27e85\u27e9 http://msgpack.org: MessagePack\n\u27e86\u27e9 https://lib.rs/crates/rmp-serde: Looking for Serde support\n\u27e87\u27e9 https://docs.rs/rmp/latest/rmp/#usage: \u00a7\n\u27e88\u27e9 https://docs.rs/rmp/latest/rmp/#features: \u00a7\n\u27e89\u27e9 https://docs.rs/rmp/latest/rmp/#detailed: \u00a7\n\u27e810\u27e9 https://docs.rs/rmp/latest/rmp/decode/fn.read_int.html: `such`\n\u27e811\u27e9 https://docs.rs/rmp/latest/rmp/#api: \u00a7\n\u27e812\u27e9 https://docs.rs/rmp/latest/rmp/#modules: \u00a7\n\u27e813\u27e9 https://docs.rs/rmp/latest/rmp/decode/index.html: mod rmp::decode - decode\n\u27e814\u27e9 https://docs.rs/rmp/latest/rmp/encode/index.html: mod rmp::encode - encode\n\u27e815\u27e9 https://docs.rs/rmp/latest/rmp/#enums: \u00a7\n\u27e816\u27e9 https://docs.rs/rmp/latest/rmp/enum.Marker.html: enum rmp::Marker - Marker\n\u27e817\u27e9 https://docs.rs/rmp/latest/rmp/#constants: \u00a7\n\u27e818\u27e9 https://docs.rs/rmp/latest/rmp/constant.MSGPACK_VERSION.html: constant rmp::MSGPACK_VERSION - MSGPACK_VERSION\n\u27e819\u27e9 http://github.com/msgpack/msgpack/blob/master/spec.md: spec\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `rmp` crate is a pure Rust implementation of the MessagePack binary serialization format, offering low-level APIs for efficient encoding and decoding of primitive values. Key features include zero-copy value decoding for performance, robust error handling, support for `no-std` environments, and compact encoding options. It serves as a foundational library for building higher-level abstractions and integrates seamlessly with other MessagePack tools.",
    "feature_summary": null,
    "use_case": "Serialization",
    "score": 6.0,
    "factual_counterfactual": "### Pair 1: Encoding and Decoding Features  \n\u2705 **Factual:** The `rmp` crate supports zero-copy value decoding, allowing data to be read directly from a buffer without heap allocations, ensuring high performance and memory efficiency.  \n\u274c **Counterfactual:** The `rmp` crate requires heap allocations for all decoding operations, making it unsuitable for memory-constrained environments.  \n\n---\n\n### Pair 2: Compact Encoding  \n\u2705 **Factual:** The `rmp` crate provides functions like `write_sint` that guarantee the most compact representation of integers during encoding, optimizing for space efficiency.  \n\u274c **Counterfactual:** The `rmp` crate always encodes integers using a fixed-width format, regardless of their value, leading to inefficient space usage.  \n\n---\n\n### Pair 3: Error Handling  \n\u2705 **Factual:** The `rmp` crate's error handling system ensures that all errors are represented by reachable variants of its error enums, avoiding undefined or unreachable states.  \n\u274c **Counterfactual:** The `rmp` crate's error handling system includes unreachable variants in its error enums, which can lead to runtime panics during decoding.",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}