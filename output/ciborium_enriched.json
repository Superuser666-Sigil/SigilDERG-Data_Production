{
    "name": "ciborium",
    "version": "0.2.2",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/ciborium/latest/ciborium/all.html \"show sidebar\")\n# Crate ciboriumCopy item path\n[Settings](https://docs.rs/ciborium/latest/settings.html)\n[Help](https://docs.rs/ciborium/latest/help.html)\nSummary[Source](https://docs.rs/ciborium/latest/src/ciborium/lib.rs.html#3-224)\nExpand description\nWelcome to Ciborium!\nCiborium contains CBOR serialization and deserialization implementations for serde.\n## [\u00a7](https://docs.rs/ciborium/latest/ciborium/#quick-start)Quick Start\nYou\u2019re probably looking for [`from_reader()`](https://docs.rs/ciborium/latest/ciborium/fn.from_reader.html \"fn ciborium::from_reader\") and [`into_writer()`](https://docs.rs/ciborium/latest/ciborium/fn.into_writer.html \"fn ciborium::into_writer\"), which are the main functions. Note that byte slices are also readers and writers and can be passed to these functions just as streams can.\nFor dynamic CBOR value creation/inspection, see [`Value`](https://docs.rs/ciborium/latest/ciborium/enum.Value.html \"enum ciborium::Value\").\n## [\u00a7](https://docs.rs/ciborium/latest/ciborium/#design-decisions)Design Decisions\n### [\u00a7](https://docs.rs/ciborium/latest/ciborium/#always-serialize-numeric-values-to-the-smallest-size)Always Serialize Numeric Values to the Smallest Size\nAlthough the CBOR specification has differing numeric widths, this is only a form of compression on the wire and is not intended to directly represent an \u201cinteger width\u201d or \u201cfloat width.\u201d Therefore, ciborium always serializes numbers to the smallest possible lossless encoding. For example, we serialize `1u128` as a single byte (`01`). Likewise, we will also freely decode that single byte into a `u128`.\nWhile there is some minor performance cost for this, there are several reasons for this choice. First, the specification seems to imply it by using a separate bit for the sign. Second, the specification requires that implementations handle leading zeroes; a liberal reading of which implies a requirement for lossless coercion. Third, dynamic languages like Python have no notion of \u201cinteger width,\u201d making this is a practical choice for maximizing wire compatibility with those languages.\nThis coercion is **always** lossless. For floats, this implies that we only coerce to a smaller size if coercion back to the original size has the same raw bits as the original.\n### [\u00a7](https://docs.rs/ciborium/latest/ciborium/#compatibility-with-other-implementations)Compatibility with Other Implementations\nThe ciborium project follows the [Robustness Principle](https://en.wikipedia.org/wiki/Robustness_principle). Therefore, we aim to be liberal in what we accept. This implies that we aim to be wire-compatible with other implementations in decoding, but not necessarily encoding.\nOne notable example of this is that `serde_cbor` uses fixed-width encoding of numbers and doesn\u2019t losslessly coerce. This implies that `ciborium` will successfully decode `serde_cbor` encodings, but the opposite may not be the case.\n### [\u00a7](https://docs.rs/ciborium/latest/ciborium/#representing-map-as-a-sequence-of-values)Representing Map as a Sequence of Values\nOther serde parsers have generally taken the route of using `BTreeMap` or `HashMap` to implement their encoding\u2019s underlying `Map` type. This crate chooses to represent the `Map` type using `Vec<(Value, Value)>` instead.\nThis decision was made because this type preserves the order of the pairs on the wire. Further, for those that need the properties of `BTreeMap` or `HashMap`, you can simply `collect()` the values into the respective type. This provides maximum flexibility.\n### [\u00a7](https://docs.rs/ciborium/latest/ciborium/#low-level-library)Low-level Library\nThe ciborium crate has the beginnings of a low-level library in the (private) `basic` module. We may extend this to be more robust and expose it for application consumption once we have it in a good state. If you\u2019d like to collaborate with us on that, please contact us. Alternatively, we might fork this code into a separate crate with no serde dependency.\n### [\u00a7](https://docs.rs/ciborium/latest/ciborium/#internal-types)Internal Types\nThe ciborium crate contains a number of internal types that implement useful serde traits. While these are not currently exposed, we might choose to expose them in the future if there is demand. Generally, this crate takes a conservative approach to exposing APIs to avoid breakage.\n### [\u00a7](https://docs.rs/ciborium/latest/ciborium/#packed-encoding)Packed Encoding?\nPacked encoding uses numerical offsets to represent structure field names and enum variant names. This can save significant space on the wire.\nWhile the authors of this crate like packed encoding, it should generally be avoided because it can be fragile as it exposes invariants of your Rust code to remote actors. We might consider adding this in the future. If you are interested in this, please contact us.\n## Modules[\u00a7](https://docs.rs/ciborium/latest/ciborium/#modules)\n\n[de](https://docs.rs/ciborium/latest/ciborium/de/index.html \"mod ciborium::de\")\n    Serde deserialization support for CBOR\n\n[ser](https://docs.rs/ciborium/latest/ciborium/ser/index.html \"mod ciborium::ser\")\n    Serde serialization support for CBOR\n\n[tag](https://docs.rs/ciborium/latest/ciborium/tag/index.html \"mod ciborium::tag\")\n    Contains helper types for dealing with CBOR tags\n\n[value](https://docs.rs/ciborium/latest/ciborium/value/index.html \"mod ciborium::value\")\n    A dynamic CBOR value\n## Macros[\u00a7](https://docs.rs/ciborium/latest/ciborium/#macros)\n\n[cbor](https://docs.rs/ciborium/latest/ciborium/macro.cbor.html \"macro ciborium::cbor\")\n    Build a `Value` conveniently.\n## Enums[\u00a7](https://docs.rs/ciborium/latest/ciborium/#enums)\n\n[Value](https://docs.rs/ciborium/latest/ciborium/enum.Value.html \"enum ciborium::Value\")\n    A representation of a dynamic CBOR value that can handled dynamically\n## Functions[\u00a7](https://docs.rs/ciborium/latest/ciborium/#functions)\n\n[from_reader](https://docs.rs/ciborium/latest/ciborium/fn.from_reader.html \"fn ciborium::from_reader\")\n    Deserializes as CBOR from a type with [`impl ciborium_io::Read`](https://docs.rs/ciborium-io/0.2.2/x86_64-unknown-linux-gnu/ciborium_io/trait.Read.html \"trait ciborium_io::Read\") using a 4KB buffer on the stack.\n\n[from_reader_with_buffer](https://docs.rs/ciborium/latest/ciborium/fn.from_reader_with_buffer.html \"fn ciborium::from_reader_with_buffer\")\n    Deserializes as CBOR from a type with [`impl ciborium_io::Read`](https://docs.rs/ciborium-io/0.2.2/x86_64-unknown-linux-gnu/ciborium_io/trait.Read.html \"trait ciborium_io::Read\"), using a caller-specific buffer as a temporary scratch space.\n\n[into_writer](https://docs.rs/ciborium/latest/ciborium/fn.into_writer.html \"fn ciborium::into_writer\")\n    Serializes as CBOR into a type with [`impl ciborium_io::Write`](https://docs.rs/ciborium-io/0.2.2/x86_64-unknown-linux-gnu/ciborium_io/trait.Write.html \"trait ciborium_io::Write\")\n",
        "markdown_with_citations": "[](https://docs.rs/ciborium/latest/ciborium/all.html \"show sidebar\")\n# Crate ciboriumCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nWelcome to Ciborium!\nCiborium contains CBOR serialization and deserialization implementations for serde.\n## \u00a7\u27e84\u27e9Quick Start\nYou\u2019re probably looking for `from_reader()`\u27e85\u27e9 and `into_writer()`\u27e86\u27e9, which are the main functions. Note that byte slices are also readers and writers and can be passed to these functions just as streams can.\nFor dynamic CBOR value creation/inspection, see `Value`\u27e87\u27e9.\n## \u00a7\u27e88\u27e9Design Decisions\n### \u00a7\u27e89\u27e9Always Serialize Numeric Values to the Smallest Size\nAlthough the CBOR specification has differing numeric widths, this is only a form of compression on the wire and is not intended to directly represent an \u201cinteger width\u201d or \u201cfloat width.\u201d Therefore, ciborium always serializes numbers to the smallest possible lossless encoding. For example, we serialize `1u128` as a single byte (`01`). Likewise, we will also freely decode that single byte into a `u128`.\nWhile there is some minor performance cost for this, there are several reasons for this choice. First, the specification seems to imply it by using a separate bit for the sign. Second, the specification requires that implementations handle leading zeroes; a liberal reading of which implies a requirement for lossless coercion. Third, dynamic languages like Python have no notion of \u201cinteger width,\u201d making this is a practical choice for maximizing wire compatibility with those languages.\nThis coercion is **always** lossless. For floats, this implies that we only coerce to a smaller size if coercion back to the original size has the same raw bits as the original.\n### \u00a7\u27e810\u27e9Compatibility with Other Implementations\nThe ciborium project follows the Robustness Principle\u27e811\u27e9. Therefore, we aim to be liberal in what we accept. This implies that we aim to be wire-compatible with other implementations in decoding, but not necessarily encoding.\nOne notable example of this is that `serde_cbor` uses fixed-width encoding of numbers and doesn\u2019t losslessly coerce. This implies that `ciborium` will successfully decode `serde_cbor` encodings, but the opposite may not be the case.\n### \u00a7\u27e812\u27e9Representing Map as a Sequence of Values\nOther serde parsers have generally taken the route of using `BTreeMap` or `HashMap` to implement their encoding\u2019s underlying `Map` type. This crate chooses to represent the `Map` type using `Vec<(Value, Value)>` instead.\nThis decision was made because this type preserves the order of the pairs on the wire. Further, for those that need the properties of `BTreeMap` or `HashMap`, you can simply `collect()` the values into the respective type. This provides maximum flexibility.\n### \u00a7\u27e813\u27e9Low-level Library\nThe ciborium crate has the beginnings of a low-level library in the (private) `basic` module. We may extend this to be more robust and expose it for application consumption once we have it in a good state. If you\u2019d like to collaborate with us on that, please contact us. Alternatively, we might fork this code into a separate crate with no serde dependency.\n### \u00a7\u27e814\u27e9Internal Types\nThe ciborium crate contains a number of internal types that implement useful serde traits. While these are not currently exposed, we might choose to expose them in the future if there is demand. Generally, this crate takes a conservative approach to exposing APIs to avoid breakage.\n### \u00a7\u27e815\u27e9Packed Encoding?\nPacked encoding uses numerical offsets to represent structure field names and enum variant names. This can save significant space on the wire.\nWhile the authors of this crate like packed encoding, it should generally be avoided because it can be fragile as it exposes invariants of your Rust code to remote actors. We might consider adding this in the future. If you are interested in this, please contact us.\n## Modules\u00a7\u27e816\u27e9\n\nde\u27e817\u27e9\n    Serde deserialization support for CBOR\n\nser\u27e818\u27e9\n    Serde serialization support for CBOR\n\ntag\u27e819\u27e9\n    Contains helper types for dealing with CBOR tags\n\nvalue\u27e820\u27e9\n    A dynamic CBOR value\n## Macros\u00a7\u27e821\u27e9\n\ncbor\u27e822\u27e9\n    Build a `Value` conveniently.\n## Enums\u00a7\u27e823\u27e9\n\nValue\u27e87\u27e9\n    A representation of a dynamic CBOR value that can handled dynamically\n## Functions\u00a7\u27e824\u27e9\n\nfrom_reader\u27e85\u27e9\n    Deserializes as CBOR from a type with `impl ciborium_io::Read`\u27e825\u27e9 using a 4KB buffer on the stack.\n\nfrom_reader_with_buffer\u27e826\u27e9\n    Deserializes as CBOR from a type with `impl ciborium_io::Read`\u27e825\u27e9, using a caller-specific buffer as a temporary scratch space.\n\ninto_writer\u27e86\u27e9\n    Serializes as CBOR into a type with `impl ciborium_io::Write`\u27e827\u27e9\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/ciborium/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/ciborium/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/ciborium/latest/src/ciborium/lib.rs.html#3-224: Source\n\u27e84\u27e9 https://docs.rs/ciborium/latest/ciborium/#quick-start: \u00a7\n\u27e85\u27e9 https://docs.rs/ciborium/latest/ciborium/fn.from_reader.html: fn ciborium::from_reader - `from_reader()`\n\u27e86\u27e9 https://docs.rs/ciborium/latest/ciborium/fn.into_writer.html: fn ciborium::into_writer - `into_writer()`\n\u27e87\u27e9 https://docs.rs/ciborium/latest/ciborium/enum.Value.html: enum ciborium::Value - `Value`\n\u27e88\u27e9 https://docs.rs/ciborium/latest/ciborium/#design-decisions: \u00a7\n\u27e89\u27e9 https://docs.rs/ciborium/latest/ciborium/#always-serialize-numeric-values-to-the-smallest-size: \u00a7\n\u27e810\u27e9 https://docs.rs/ciborium/latest/ciborium/#compatibility-with-other-implementations: \u00a7\n\u27e811\u27e9 https://en.wikipedia.org/wiki/Robustness_principle: Robustness Principle\n\u27e812\u27e9 https://docs.rs/ciborium/latest/ciborium/#representing-map-as-a-sequence-of-values: \u00a7\n\u27e813\u27e9 https://docs.rs/ciborium/latest/ciborium/#low-level-library: \u00a7\n\u27e814\u27e9 https://docs.rs/ciborium/latest/ciborium/#internal-types: \u00a7\n\u27e815\u27e9 https://docs.rs/ciborium/latest/ciborium/#packed-encoding: \u00a7\n\u27e816\u27e9 https://docs.rs/ciborium/latest/ciborium/#modules: \u00a7\n\u27e817\u27e9 https://docs.rs/ciborium/latest/ciborium/de/index.html: mod ciborium::de - de\n\u27e818\u27e9 https://docs.rs/ciborium/latest/ciborium/ser/index.html: mod ciborium::ser - ser\n\u27e819\u27e9 https://docs.rs/ciborium/latest/ciborium/tag/index.html: mod ciborium::tag - tag\n\u27e820\u27e9 https://docs.rs/ciborium/latest/ciborium/value/index.html: mod ciborium::value - value\n\u27e821\u27e9 https://docs.rs/ciborium/latest/ciborium/#macros: \u00a7\n\u27e822\u27e9 https://docs.rs/ciborium/latest/ciborium/macro.cbor.html: macro ciborium::cbor - cbor\n\u27e823\u27e9 https://docs.rs/ciborium/latest/ciborium/#enums: \u00a7\n\u27e824\u27e9 https://docs.rs/ciborium/latest/ciborium/#functions: \u00a7\n\u27e825\u27e9 https://docs.rs/ciborium-io/0.2.2/x86_64-unknown-linux-gnu/ciborium_io/trait.Read.html: trait ciborium_io::Read - `impl ciborium_io::Read`\n\u27e826\u27e9 https://docs.rs/ciborium/latest/ciborium/fn.from_reader_with_buffer.html: fn ciborium::from_reader_with_buffer - from_reader_with_buffer\n\u27e827\u27e9 https://docs.rs/ciborium-io/0.2.2/x86_64-unknown-linux-gnu/ciborium_io/trait.Write.html: trait ciborium_io::Write - `impl ciborium_io::Write`\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `ciborium` crate provides CBOR (Concise Binary Object Representation) serialization and deserialization implementations for `serde`, with key functions like `from_reader` and `into_writer` for handling streams or byte slices. It ensures numeric values are serialized to their smallest lossless size, maintains wire compatibility with other implementations, and represents maps as ordered sequences (`Vec<(Value, Value)>`) for flexibility. Additionally, it offers dynamic CBOR value manipulation via the `Value` enum and supports helper modules for tags, serialization, and deserialization.",
    "feature_summary": null,
    "use_case": "Serialization",
    "score": 6.0,
    "factual_counterfactual": "### Pair 1: Numeric Serialization  \n\u2705 **Factual:** The `ciborium` crate always serializes numeric values to the smallest possible lossless encoding, such as serializing `1u128` as a single byte (`01`).  \n\u274c **Counterfactual:** The `ciborium` crate uses fixed-width encoding for numeric values, meaning `1u128` would always be serialized as a 16-byte value.  \n\n---\n\n### Pair 2: Map Representation  \n\u2705 **Factual:** The `ciborium` crate represents CBOR maps as `Vec<(Value, Value)>`, preserving the order of key-value pairs on the wire.  \n\u274c **Counterfactual:** The `ciborium` crate represents CBOR maps exclusively as `HashMap` or `BTreeMap`, which does not preserve the order of key-value pairs.  \n\n---\n\n### Pair 3: Compatibility with Other CBOR Implementations  \n\u2705 **Factual:** The `ciborium` crate is designed to decode CBOR encodings from `serde_cbor` but may produce encodings that `serde_cbor` cannot decode due to differences in numeric width handling.  \n\u274c **Counterfactual:** The `ciborium` crate ensures full bidirectional compatibility with `serde_cbor`, including encoding and decoding without any discrepancies.",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}