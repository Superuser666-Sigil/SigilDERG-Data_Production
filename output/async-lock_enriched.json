{
    "name": "async-lock",
    "version": "3.4.0",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/async-lock/latest/async_lock/all.html \"show sidebar\")\n# Crate async_lockCopy item path\n[Settings](https://docs.rs/async-lock/latest/settings.html)\n[Help](https://docs.rs/async-lock/latest/help.html)\nSummary[Source](https://docs.rs/async-lock/latest/src/async_lock/lib.rs.html#1-168)\nExpand description\nAsync synchronization primitives.\nThis crate provides the following primitives:\n  * [`Barrier`](https://docs.rs/async-lock/latest/async_lock/struct.Barrier.html \"struct async_lock::Barrier\") - enables tasks to synchronize all together at the same time.\n  * [`Mutex`](https://docs.rs/async-lock/latest/async_lock/struct.Mutex.html \"struct async_lock::Mutex\") - a mutual exclusion lock.\n  * [`RwLock`](https://docs.rs/async-lock/latest/async_lock/struct.RwLock.html \"struct async_lock::RwLock\") - a reader-writer lock, allowing any number of readers or a single writer.\n  * [`Semaphore`](https://docs.rs/async-lock/latest/async_lock/struct.Semaphore.html \"struct async_lock::Semaphore\") - limits the number of concurrent operations.\n\n\n### [\u00a7](https://docs.rs/async-lock/latest/async_lock/#relationship-with-stdsync)Relationship with `std::sync`\nIn general, you should consider using [`std::sync`](https://doc.rust-lang.org/std/sync/index.html) types over types from this crate.\nThere are two primary use cases for types from this crate:\n  * You need to use a synchronization primitive in a `no_std` environment.\n  * You need to hold a lock across an `.await` point. (Holding an [`std::sync`](https://doc.rust-lang.org/std/sync/index.html) lock guard across an `.await` will make your future non-`Send`, and is also highly likely to cause deadlocks.)\n\n\nIf you already use `libstd` and you aren\u2019t holding locks across await points (there is a Clippy lint called [`await_holding_lock`](https://rust-lang.github.io/rust-clippy/stable/index.html#/await_holding_lock) that emits warnings for this scenario), you should consider [`std::sync`](https://doc.rust-lang.org/std/sync/index.html) instead of this crate. Those types are optimized for the currently running operating system, are less complex and are generally much faster.\nIn contrast, `async-lock`\u2019s notification system uses `std::sync::Mutex` under the hood if the `std` feature is enabled, and will fall back to a significantly slower strategy if it is not. So, there are few cases where `async-lock` is a win for performance over [`std::sync`](https://doc.rust-lang.org/std/sync/index.html).\n## Modules[\u00a7](https://docs.rs/async-lock/latest/async_lock/#modules)\n\n[futures](https://docs.rs/async-lock/latest/async_lock/futures/index.html \"mod async_lock::futures\")\n    Named futures for use with `async_lock` primitives.\n## Structs[\u00a7](https://docs.rs/async-lock/latest/async_lock/#structs)\n\n[Barrier](https://docs.rs/async-lock/latest/async_lock/struct.Barrier.html \"struct async_lock::Barrier\")\n    A counter to synchronize multiple tasks at the same time.\n\n[BarrierWaitResult](https://docs.rs/async-lock/latest/async_lock/struct.BarrierWaitResult.html \"struct async_lock::BarrierWaitResult\")\n    Returned by [`Barrier::wait()`](https://docs.rs/async-lock/latest/async_lock/struct.Barrier.html#method.wait \"method async_lock::Barrier::wait\") when all tasks have called it.\n\n[Mutex](https://docs.rs/async-lock/latest/async_lock/struct.Mutex.html \"struct async_lock::Mutex\")\n    An async mutex.\n\n[MutexGuard](https://docs.rs/async-lock/latest/async_lock/struct.MutexGuard.html \"struct async_lock::MutexGuard\")\n    A guard that releases the mutex when dropped.\n\n[MutexGuardArc](https://docs.rs/async-lock/latest/async_lock/struct.MutexGuardArc.html \"struct async_lock::MutexGuardArc\")\n    An owned guard that releases the mutex when dropped.\n\n[OnceCell](https://docs.rs/async-lock/latest/async_lock/struct.OnceCell.html \"struct async_lock::OnceCell\")\n    A memory location that can be written to at most once.\n\n[RwLock](https://docs.rs/async-lock/latest/async_lock/struct.RwLock.html \"struct async_lock::RwLock\")\n    An async reader-writer lock.\n\n[RwLockReadGuard](https://docs.rs/async-lock/latest/async_lock/struct.RwLockReadGuard.html \"struct async_lock::RwLockReadGuard\")\n    A guard that releases the read lock when dropped.\n\n[RwLockReadGuardArc](https://docs.rs/async-lock/latest/async_lock/struct.RwLockReadGuardArc.html \"struct async_lock::RwLockReadGuardArc\")\n    An owned, reference-counting guard that releases the read lock when dropped.\n\n[RwLockUpgradableReadGuard](https://docs.rs/async-lock/latest/async_lock/struct.RwLockUpgradableReadGuard.html \"struct async_lock::RwLockUpgradableReadGuard\")\n    A guard that releases the upgradable read lock when dropped.\n\n[RwLockUpgradableReadGuardArc](https://docs.rs/async-lock/latest/async_lock/struct.RwLockUpgradableReadGuardArc.html \"struct async_lock::RwLockUpgradableReadGuardArc\")\n    An owned, reference-counting guard that releases the upgradable read lock when dropped.\n\n[RwLockWriteGuard](https://docs.rs/async-lock/latest/async_lock/struct.RwLockWriteGuard.html \"struct async_lock::RwLockWriteGuard\")\n    A guard that releases the write lock when dropped.\n\n[RwLockWriteGuardArc](https://docs.rs/async-lock/latest/async_lock/struct.RwLockWriteGuardArc.html \"struct async_lock::RwLockWriteGuardArc\")\n    An owned, reference-counted guard that releases the write lock when dropped.\n\n[Semaphore](https://docs.rs/async-lock/latest/async_lock/struct.Semaphore.html \"struct async_lock::Semaphore\")\n    A counter for limiting the number of concurrent operations.\n\n[SemaphoreGuard](https://docs.rs/async-lock/latest/async_lock/struct.SemaphoreGuard.html \"struct async_lock::SemaphoreGuard\")\n    A guard that releases the acquired permit.\n\n[SemaphoreGuardArc](https://docs.rs/async-lock/latest/async_lock/struct.SemaphoreGuardArc.html \"struct async_lock::SemaphoreGuardArc\")\n    An owned guard that releases the acquired permit.\n",
        "markdown_with_citations": "[](https://docs.rs/async-lock/latest/async_lock/all.html \"show sidebar\")\n# Crate async_lockCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nAsync synchronization primitives.\nThis crate provides the following primitives:\n  * `Barrier`\u27e84\u27e9 - enables tasks to synchronize all together at the same time.\n  * `Mutex`\u27e85\u27e9 - a mutual exclusion lock.\n  * `RwLock`\u27e86\u27e9 - a reader-writer lock, allowing any number of readers or a single writer.\n  * `Semaphore`\u27e87\u27e9 - limits the number of concurrent operations.\n\n\n### \u00a7\u27e88\u27e9Relationship with `std::sync`\nIn general, you should consider using `std::sync`\u27e89\u27e9 types over types from this crate.\nThere are two primary use cases for types from this crate:\n  * You need to use a synchronization primitive in a `no_std` environment.\n  * You need to hold a lock across an `.await` point. (Holding an `std::sync`\u27e89\u27e9 lock guard across an `.await` will make your future non-`Send`, and is also highly likely to cause deadlocks.)\n\n\nIf you already use `libstd` and you aren\u2019t holding locks across await points (there is a Clippy lint called `await_holding_lock`\u27e810\u27e9 that emits warnings for this scenario), you should consider `std::sync`\u27e89\u27e9 instead of this crate. Those types are optimized for the currently running operating system, are less complex and are generally much faster.\nIn contrast, `async-lock`\u2019s notification system uses `std::sync::Mutex` under the hood if the `std` feature is enabled, and will fall back to a significantly slower strategy if it is not. So, there are few cases where `async-lock` is a win for performance over `std::sync`\u27e89\u27e9.\n## Modules\u00a7\u27e811\u27e9\n\nfutures\u27e812\u27e9\n    Named futures for use with `async_lock` primitives.\n## Structs\u00a7\u27e813\u27e9\n\nBarrier\u27e84\u27e9\n    A counter to synchronize multiple tasks at the same time.\n\nBarrierWaitResult\u27e814\u27e9\n    Returned by `Barrier::wait()`\u27e815\u27e9 when all tasks have called it.\n\nMutex\u27e85\u27e9\n    An async mutex.\n\nMutexGuard\u27e816\u27e9\n    A guard that releases the mutex when dropped.\n\nMutexGuardArc\u27e817\u27e9\n    An owned guard that releases the mutex when dropped.\n\nOnceCell\u27e818\u27e9\n    A memory location that can be written to at most once.\n\nRwLock\u27e86\u27e9\n    An async reader-writer lock.\n\nRwLockReadGuard\u27e819\u27e9\n    A guard that releases the read lock when dropped.\n\nRwLockReadGuardArc\u27e820\u27e9\n    An owned, reference-counting guard that releases the read lock when dropped.\n\nRwLockUpgradableReadGuard\u27e821\u27e9\n    A guard that releases the upgradable read lock when dropped.\n\nRwLockUpgradableReadGuardArc\u27e822\u27e9\n    An owned, reference-counting guard that releases the upgradable read lock when dropped.\n\nRwLockWriteGuard\u27e823\u27e9\n    A guard that releases the write lock when dropped.\n\nRwLockWriteGuardArc\u27e824\u27e9\n    An owned, reference-counted guard that releases the write lock when dropped.\n\nSemaphore\u27e87\u27e9\n    A counter for limiting the number of concurrent operations.\n\nSemaphoreGuard\u27e825\u27e9\n    A guard that releases the acquired permit.\n\nSemaphoreGuardArc\u27e826\u27e9\n    An owned guard that releases the acquired permit.\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/async-lock/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/async-lock/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/async-lock/latest/src/async_lock/lib.rs.html#1-168: Source\n\u27e84\u27e9 https://docs.rs/async-lock/latest/async_lock/struct.Barrier.html: struct async_lock::Barrier - `Barrier`\n\u27e85\u27e9 https://docs.rs/async-lock/latest/async_lock/struct.Mutex.html: struct async_lock::Mutex - `Mutex`\n\u27e86\u27e9 https://docs.rs/async-lock/latest/async_lock/struct.RwLock.html: struct async_lock::RwLock - `RwLock`\n\u27e87\u27e9 https://docs.rs/async-lock/latest/async_lock/struct.Semaphore.html: struct async_lock::Semaphore - `Semaphore`\n\u27e88\u27e9 https://docs.rs/async-lock/latest/async_lock/#relationship-with-stdsync: \u00a7\n\u27e89\u27e9 https://doc.rust-lang.org/std/sync/index.html: `std::sync`\n\u27e810\u27e9 https://rust-lang.github.io/rust-clippy/stable/index.html#/await_holding_lock: `await_holding_lock`\n\u27e811\u27e9 https://docs.rs/async-lock/latest/async_lock/#modules: \u00a7\n\u27e812\u27e9 https://docs.rs/async-lock/latest/async_lock/futures/index.html: mod async_lock::futures - futures\n\u27e813\u27e9 https://docs.rs/async-lock/latest/async_lock/#structs: \u00a7\n\u27e814\u27e9 https://docs.rs/async-lock/latest/async_lock/struct.BarrierWaitResult.html: struct async_lock::BarrierWaitResult - BarrierWaitResult\n\u27e815\u27e9 https://docs.rs/async-lock/latest/async_lock/struct.Barrier.html#method.wait: method async_lock::Barrier::wait - `Barrier::wait()`\n\u27e816\u27e9 https://docs.rs/async-lock/latest/async_lock/struct.MutexGuard.html: struct async_lock::MutexGuard - MutexGuard\n\u27e817\u27e9 https://docs.rs/async-lock/latest/async_lock/struct.MutexGuardArc.html: struct async_lock::MutexGuardArc - MutexGuardArc\n\u27e818\u27e9 https://docs.rs/async-lock/latest/async_lock/struct.OnceCell.html: struct async_lock::OnceCell - OnceCell\n\u27e819\u27e9 https://docs.rs/async-lock/latest/async_lock/struct.RwLockReadGuard.html: struct async_lock::RwLockReadGuard - RwLockReadGuard\n\u27e820\u27e9 https://docs.rs/async-lock/latest/async_lock/struct.RwLockReadGuardArc.html: struct async_lock::RwLockReadGuardArc - RwLockReadGuardArc\n\u27e821\u27e9 https://docs.rs/async-lock/latest/async_lock/struct.RwLockUpgradableReadGuard.html: struct async_lock::RwLockUpgradableReadGuard - RwLockUpgradableReadGuard\n\u27e822\u27e9 https://docs.rs/async-lock/latest/async_lock/struct.RwLockUpgradableReadGuardArc.html: struct async_lock::RwLockUpgradableReadGuardArc - RwLockUpgradableReadGuardArc\n\u27e823\u27e9 https://docs.rs/async-lock/latest/async_lock/struct.RwLockWriteGuard.html: struct async_lock::RwLockWriteGuard - RwLockWriteGuard\n\u27e824\u27e9 https://docs.rs/async-lock/latest/async_lock/struct.RwLockWriteGuardArc.html: struct async_lock::RwLockWriteGuardArc - RwLockWriteGuardArc\n\u27e825\u27e9 https://docs.rs/async-lock/latest/async_lock/struct.SemaphoreGuard.html: struct async_lock::SemaphoreGuard - SemaphoreGuard\n\u27e826\u27e9 https://docs.rs/async-lock/latest/async_lock/struct.SemaphoreGuardArc.html: struct async_lock::SemaphoreGuardArc - SemaphoreGuardArc\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `async-lock` crate provides asynchronous synchronization primitives for Rust, including `Barrier`, `Mutex`, `RwLock`, and `Semaphore`, enabling task coordination, mutual exclusion, reader-writer locks, and concurrency limits. It is particularly useful in `no_std` environments or when locks need to be held across `.await` points, avoiding issues like non-`Send` futures or deadlocks. While it leverages `std::sync::Mutex` when the `std` feature is enabled, it is generally less performant than `std::sync` primitives.",
    "feature_summary": null,
    "use_case": "Utilities",
    "score": 6.0,
    "factual_counterfactual": "### Pair 1: Synchronization Primitives  \n\u2705 Factual: The `async-lock` crate provides an `RwLock` that allows multiple readers or a single writer, making it suitable for scenarios requiring concurrent read access.  \n\u274c Counterfactual: The `async-lock` crate's `RwLock` allows simultaneous writers, enabling high-performance concurrent writes.  \n\n---\n\n### Pair 2: Relationship with `std::sync`  \n\u2705 Factual: The `async-lock` crate is recommended for use in `no_std` environments or when locks need to be held across `.await` points, as `std::sync` primitives are not designed for these scenarios.  \n\u274c Counterfactual: The `async-lock` crate is faster than `std::sync` primitives in all cases, including standard synchronous operations.  \n\n---\n\n### Pair 3: Performance Characteristics  \n\u2705 Factual: When the `std` feature is enabled, `async-lock` uses `std::sync::Mutex` under the hood, but falls back to slower strategies in `no_std` environments.  \n\u274c Counterfactual: The `async-lock` crate always outperforms `std::sync::Mutex`, regardless of whether the `std` feature is enabled or not.",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}