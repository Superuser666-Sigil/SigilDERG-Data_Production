{
    "name": "paste",
    "version": "1.0.15",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/paste/latest/paste/all.html \"show sidebar\")\n# Crate pasteCopy item path\n[Settings](https://docs.rs/paste/latest/settings.html)\n[Help](https://docs.rs/paste/latest/help.html)\nSummary[Source](https://docs.rs/paste/latest/src/paste/lib.rs.html#1-454)\nExpand description\n[![github](https://img.shields.io/badge/github-8da0cb?style=for-the-badge&labelColor=555555&logo=github)](https://github.com/dtolnay/paste) [![crates-io](https://img.shields.io/badge/crates.io-fc8d62?style=for-the-badge&labelColor=555555&logo=rust)](https://crates.io/crates/paste) [![docs-rs](https://img.shields.io/badge/docs.rs-66c2a5?style=for-the-badge&labelColor=555555&logo=docs.rs)](https://docs.rs/paste)\nThe nightly-only [`concat_idents!`](https://doc.rust-lang.org/std/macro.concat_idents.html) macro in the Rust standard library is notoriously underpowered in that its concatenated identifiers can only refer to existing items, they can never be used to define something new.\nThis crate provides a flexible way to paste together identifiers in a macro, including using pasted identifiers to define new items.\nThis approach works with any Rust compiler 1.31+.\n## [\u00a7](https://docs.rs/paste/latest/paste/#pasting-identifiers)Pasting identifiers\nWithin the `paste!` macro, identifiers inside `[<`\u2026`>]` are pasted together to form a single identifier.\n```\nuse paste::paste;\npaste! {\n  // Defines a const called `QRST`.\n  const [<Q R S T>]: &str = \"success!\";\n}\nfn main() {\n  assert_eq!(\n    paste! { [<Q R S T>].len() },\n    8,\n  );\n}\n```\n\n## [\u00a7](https://docs.rs/paste/latest/paste/#more-elaborate-example)More elaborate example\nThe next example shows a macro that generates accessor methods for some struct fields. It demonstrates how you might find it useful to bundle a paste invocation inside of a macro_rules macro.\n```\nuse paste::paste;\nmacro_rules! make_a_struct_and_getters {\n  ($name:ident { $($field:ident),* }) => {\n    // Define a struct. This expands to:\n    //\n    //   pub struct S {\n    //     a: String,\n    //     b: String,\n    //     c: String,\n    //   }\n    pub struct $name {\n      $(\n        $field: String,\n      )*\n    }\n    // Build an impl block with getters. This expands to:\n    //\n    //   impl S {\n    //     pub fn get_a(&self) -> &str { &self.a }\n    //     pub fn get_b(&self) -> &str { &self.b }\n    //     pub fn get_c(&self) -> &str { &self.c }\n    //   }\n    paste! {\n      impl $name {\n        $(\n          pub fn [<get_ $field>](&self) -> &str {\n            &self.$field\n          }\n        )*\n      }\n    }\n  }\n}\nmake_a_struct_and_getters!(S { a, b, c });\nfn call_some_getters(s: &S) -> bool {\n  s.get_a() == s.get_b() && s.get_c().is_empty()\n}\n```\n\n## [\u00a7](https://docs.rs/paste/latest/paste/#case-conversion)Case conversion\nUse `$var:lower` or `$var:upper` in the segment list to convert an interpolated segment to lower- or uppercase as part of the paste. For example, `[<ld_ $reg:lower _expr>]` would paste to `ld_bc_expr` if invoked with $reg=`Bc`.\nUse `$var:snake` to convert CamelCase input to snake_case. Use `$var:camel` to convert snake_case to CamelCase. These compose, so for example `$var:snake:upper` would give you SCREAMING_CASE.\nThe precise Unicode conversions are as defined by [`str::to_lowercase`](https://doc.rust-lang.org/std/primitive.str.html#method.to_lowercase) and [`str::to_uppercase`](https://doc.rust-lang.org/std/primitive.str.html#method.to_uppercase).\n## [\u00a7](https://docs.rs/paste/latest/paste/#pasting-documentation-strings)Pasting documentation strings\nWithin the `paste!` macro, arguments to a #[doc \u2026] attribute are implicitly concatenated together to form a coherent documentation string.\n```\nuse paste::paste;\nmacro_rules! method_new {\n  ($ret:ident) => {\n    paste! {\n      #[doc = \"Create a new `\" $ret \"` object.\"]\n      pub fn new() -> $ret { todo!() }\n    }\n  };\n}\npub struct Paste {}\nmethod_new!(Paste); // expands to #[doc = \"Create a new `Paste` object\"]\n```\n\n## Macros[\u00a7](https://docs.rs/paste/latest/paste/#macros)\n\n[paste](https://docs.rs/paste/latest/paste/macro.paste.html \"macro paste::paste\")\n\n",
        "markdown_with_citations": "[](https://docs.rs/paste/latest/paste/all.html \"show sidebar\")\n# Crate pasteCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\n![github\u27e84\u27e9](https://github.com/dtolnay/paste) ![crates-io\u27e85\u27e9](https://crates.io/crates/paste) ![docs-rs\u27e86\u27e9](https://docs.rs/paste)\nThe nightly-only `concat_idents!`\u27e87\u27e9 macro in the Rust standard library is notoriously underpowered in that its concatenated identifiers can only refer to existing items, they can never be used to define something new.\nThis crate provides a flexible way to paste together identifiers in a macro, including using pasted identifiers to define new items.\nThis approach works with any Rust compiler 1.31+.\n## \u00a7\u27e88\u27e9Pasting identifiers\nWithin the `paste!` macro, identifiers inside `[<`\u2026`>]` are pasted together to form a single identifier.\n```\nuse paste::paste;\npaste! {\n  // Defines a const called `QRST`.\n  const [<Q R S T>]: &str = \"success!\";\n}\nfn main() {\n  assert_eq!(\n    paste! { [<Q R S T>].len() },\n    8,\n  );\n}\n```\n\n## \u00a7\u27e89\u27e9More elaborate example\nThe next example shows a macro that generates accessor methods for some struct fields. It demonstrates how you might find it useful to bundle a paste invocation inside of a macro_rules macro.\n```\nuse paste::paste;\nmacro_rules! make_a_struct_and_getters {\n  ($name:ident { $($field:ident),* }) => {\n    // Define a struct. This expands to:\n    //\n    //   pub struct S {\n    //     a: String,\n    //     b: String,\n    //     c: String,\n    //   }\n    pub struct $name {\n      $(\n        $field: String,\n      )*\n    }\n    // Build an impl block with getters. This expands to:\n    //\n    //   impl S {\n    //     pub fn get_a(&self) -> &str { &self.a }\n    //     pub fn get_b(&self) -> &str { &self.b }\n    //     pub fn get_c(&self) -> &str { &self.c }\n    //   }\n    paste! {\n      impl $name {\n        $(\n          pub fn <get_ $field>\u27e810\u27e9 -> &str {\n            &self.$field\n          }\n        )*\n      }\n    }\n  }\n}\nmake_a_struct_and_getters!(S { a, b, c });\nfn call_some_getters(s: &S) -> bool {\n  s.get_a() == s.get_b() && s.get_c().is_empty()\n}\n```\n\n## \u00a7\u27e811\u27e9Case conversion\nUse `$var:lower` or `$var:upper` in the segment list to convert an interpolated segment to lower- or uppercase as part of the paste. For example, `[<ld_ $reg:lower _expr>]` would paste to `ld_bc_expr` if invoked with $reg=`Bc`.\nUse `$var:snake` to convert CamelCase input to snake_case. Use `$var:camel` to convert snake_case to CamelCase. These compose, so for example `$var:snake:upper` would give you SCREAMING_CASE.\nThe precise Unicode conversions are as defined by `str::to_lowercase`\u27e812\u27e9 and `str::to_uppercase`\u27e813\u27e9.\n## \u00a7\u27e814\u27e9Pasting documentation strings\nWithin the `paste!` macro, arguments to a #[doc \u2026] attribute are implicitly concatenated together to form a coherent documentation string.\n```\nuse paste::paste;\nmacro_rules! method_new {\n  ($ret:ident) => {\n    paste! {\n      #[doc = \"Create a new `\" $ret \"` object.\"]\n      pub fn new() -> $ret { todo!() }\n    }\n  };\n}\npub struct Paste {}\nmethod_new!(Paste); // expands to #[doc = \"Create a new `Paste` object\"]\n```\n\n## Macros\u00a7\u27e815\u27e9\n\npaste\u27e816\u27e9\n\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/paste/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/paste/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/paste/latest/src/paste/lib.rs.html#1-454: Source\n\u27e84\u27e9 https://img.shields.io/badge/github-8da0cb?style=for-the-badge&labelColor=555555&logo=github: ![github\n\u27e85\u27e9 https://img.shields.io/badge/crates.io-fc8d62?style=for-the-badge&labelColor=555555&logo=rust: ![crates-io\n\u27e86\u27e9 https://img.shields.io/badge/docs.rs-66c2a5?style=for-the-badge&labelColor=555555&logo=docs.rs: ![docs-rs\n\u27e87\u27e9 https://doc.rust-lang.org/std/macro.concat_idents.html: `concat_idents!`\n\u27e88\u27e9 https://docs.rs/paste/latest/paste/#pasting-identifiers: \u00a7\n\u27e89\u27e9 https://docs.rs/paste/latest/paste/#more-elaborate-example: \u00a7\n\u27e810\u27e9 https://docs.rs/paste/latest/paste/&self: <get_ $field>\n\u27e811\u27e9 https://docs.rs/paste/latest/paste/#case-conversion: \u00a7\n\u27e812\u27e9 https://doc.rust-lang.org/std/primitive.str.html#method.to_lowercase: `str::to_lowercase`\n\u27e813\u27e9 https://doc.rust-lang.org/std/primitive.str.html#method.to_uppercase: `str::to_uppercase`\n\u27e814\u27e9 https://docs.rs/paste/latest/paste/#pasting-documentation-strings: \u00a7\n\u27e815\u27e9 https://docs.rs/paste/latest/paste/#macros: \u00a7\n\u27e816\u27e9 https://docs.rs/paste/latest/paste/macro.paste.html: macro paste::paste - paste\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `paste` crate provides a powerful macro, `paste!`, for concatenating identifiers and defining new items in Rust, overcoming limitations of the standard library's `concat_idents!`. It supports advanced features like case conversion (e.g., snake_case to CamelCase), documentation string concatenation, and integration with `macro_rules!` for generating code dynamically. Compatible with Rust 1.31+, it simplifies metaprogramming tasks.",
    "feature_summary": null,
    "use_case": "Utilities",
    "score": 8.0,
    "factual_counterfactual": "### Pair 1: Identifier Pasting\n\u2705 **Factual**: The `paste!` macro allows concatenation of identifiers using `[< ... >]` syntax, enabling the creation of new identifiers dynamically, even for defining new items.  \n\u274c **Counterfactual**: The `paste!` macro can concatenate identifiers using `[< ... >]` syntax, but it only works with existing identifiers and cannot be used to define new items.  \n\n---\n\n### Pair 2: Compatibility with Rust Versions\n\u2705 **Factual**: The `paste` crate works with any Rust compiler version 1.31 or later, making it broadly compatible with stable Rust releases.  \n\u274c **Counterfactual**: The `paste` crate requires nightly Rust and does not work with stable Rust versions, including Rust 1.31 or later.  \n\n---\n\n### Pair 3: Case Conversion\n\u2705 **Factual**: The `paste!` macro supports case conversion, allowing transformations like `$var:lower`, `$var:upper`, `$var:snake`, and `$var:camel` to adjust identifier formats dynamically.  \n\u274c **Counterfactual**: The `paste!` macro does not support case conversion, and identifiers must be pasted exactly as provided without any transformations.",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}