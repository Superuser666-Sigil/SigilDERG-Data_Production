{
    "name": "num-derive",
    "version": "0.4.2",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/num-derive/latest/num_derive/all.html \"show sidebar\")\n# Crate num_deriveCopy item path\n[Settings](https://docs.rs/num-derive/latest/settings.html)\n[Help](https://docs.rs/num-derive/latest/help.html)\nSummary[Source](https://docs.rs/num-derive/latest/src/num_derive/lib.rs.html#11-1004)\nExpand description\nProcedural macros to derive numeric traits in Rust.\n### [\u00a7](https://docs.rs/num-derive/latest/num_derive/#usage)Usage\nAdd this to your `Cargo.toml`:\n```\n[dependencies]\nnum-traits = \"0.2\"\nnum-derive = \"0.3\"\n```\n\nThen you can derive traits on your own types:\n```\n#[macro_use]\nextern crate num_derive;\n#[derive(FromPrimitive, ToPrimitive)]\nenum Color {\n  Red,\n  Blue,\n  Green,\n}\n```\n\n### [\u00a7](https://docs.rs/num-derive/latest/num_derive/#explicit-import)Explicit import\nBy default the `num_derive` procedural macros assume that the `num_traits` crate is a direct dependency. If `num_traits` is instead a transitive dependency, the `num_traits` helper attribute can be used to tell `num_derive` to use a specific identifier for its imports.\n```\n#[macro_use]\nextern crate num_derive;\n// Lets pretend this is a transitive dependency from another crate\n// reexported as `some_other_ident`.\nextern crate num_traits as some_other_ident;\n#[derive(FromPrimitive, ToPrimitive)]\n#[num_traits = \"some_other_ident\"]\nenum Color {\n  Red,\n  Blue,\n  Green,\n}\n```\n\n## Derive Macros[\u00a7](https://docs.rs/num-derive/latest/num_derive/#derives)\n\n[Float](https://docs.rs/num-derive/latest/num_derive/derive.Float.html \"derive num_derive::Float\")\n    Derives [`num_traits::Float`](https://docs.rs/num-traits/0.2/num_traits/float/trait.Float.html) for newtypes. The inner type must already implement `Float`.\n\n[FromPrimitive](https://docs.rs/num-derive/latest/num_derive/derive.FromPrimitive.html \"derive num_derive::FromPrimitive\")\n    Derives [`num_traits::FromPrimitive`](https://docs.rs/num-traits/0.2/num_traits/cast/trait.FromPrimitive.html) for simple enums and newtypes.\n\n[Num](https://docs.rs/num-derive/latest/num_derive/derive.Num.html \"derive num_derive::Num\")\n    Derives [`num_traits::Num`](https://docs.rs/num-traits/0.2/num_traits/trait.Num.html) for newtypes. The inner type must already implement `Num`.\n\n[NumCast](https://docs.rs/num-derive/latest/num_derive/derive.NumCast.html \"derive num_derive::NumCast\")\n    Derives [`num_traits::NumCast`](https://docs.rs/num-traits/0.2/num_traits/cast/trait.NumCast.html) for newtypes. The inner type must already implement `NumCast`.\n\n[NumOps](https://docs.rs/num-derive/latest/num_derive/derive.NumOps.html \"derive num_derive::NumOps\")\n    Derives [`num_traits::NumOps`](https://docs.rs/num-traits/0.2/num_traits/trait.NumOps.html) for newtypes. The inner type must already implement `NumOps`.\n\n[One](https://docs.rs/num-derive/latest/num_derive/derive.One.html \"derive num_derive::One\")\n    Derives [`num_traits::One`](https://docs.rs/num-traits/0.2/num_traits/identities/trait.One.html) for newtypes. The inner type must already implement `One`.\n\n[Signed](https://docs.rs/num-derive/latest/num_derive/derive.Signed.html \"derive num_derive::Signed\")\n    Derives [`num_traits::Signed`](https://docs.rs/num-traits/0.2/num_traits/sign/trait.Signed.html) for newtypes. The inner type must already implement `Signed`.\n\n[ToPrimitive](https://docs.rs/num-derive/latest/num_derive/derive.ToPrimitive.html \"derive num_derive::ToPrimitive\")\n    Derives [`num_traits::ToPrimitive`](https://docs.rs/num-traits/0.2/num_traits/cast/trait.ToPrimitive.html) for simple enums and newtypes.\n\n[Unsigned](https://docs.rs/num-derive/latest/num_derive/derive.Unsigned.html \"derive num_derive::Unsigned\")\n    Derives [`num_traits::Unsigned`](https://docs.rs/num/latest/num/traits/trait.Unsigned.html). The inner type must already implement `Unsigned`.\n\n[Zero](https://docs.rs/num-derive/latest/num_derive/derive.Zero.html \"derive num_derive::Zero\")\n    Derives [`num_traits::Zero`](https://docs.rs/num-traits/0.2/num_traits/identities/trait.Zero.html) for newtypes. The inner type must already implement `Zero`.\n",
        "markdown_with_citations": "[](https://docs.rs/num-derive/latest/num_derive/all.html \"show sidebar\")\n# Crate num_deriveCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nProcedural macros to derive numeric traits in Rust.\n### \u00a7\u27e84\u27e9Usage\nAdd this to your `Cargo.toml`:\n```\n[dependencies]\nnum-traits = \"0.2\"\nnum-derive = \"0.3\"\n```\n\nThen you can derive traits on your own types:\n```\n#[macro_use]\nextern crate num_derive;\n#[derive(FromPrimitive, ToPrimitive)]\nenum Color {\n  Red,\n  Blue,\n  Green,\n}\n```\n\n### \u00a7\u27e85\u27e9Explicit import\nBy default the `num_derive` procedural macros assume that the `num_traits` crate is a direct dependency. If `num_traits` is instead a transitive dependency, the `num_traits` helper attribute can be used to tell `num_derive` to use a specific identifier for its imports.\n```\n#[macro_use]\nextern crate num_derive;\n// Lets pretend this is a transitive dependency from another crate\n// reexported as `some_other_ident`.\nextern crate num_traits as some_other_ident;\n#[derive(FromPrimitive, ToPrimitive)]\n#[num_traits = \"some_other_ident\"]\nenum Color {\n  Red,\n  Blue,\n  Green,\n}\n```\n\n## Derive Macros\u00a7\u27e86\u27e9\n\nFloat\u27e87\u27e9\n    Derives `num_traits::Float`\u27e88\u27e9 for newtypes. The inner type must already implement `Float`.\n\nFromPrimitive\u27e89\u27e9\n    Derives `num_traits::FromPrimitive`\u27e810\u27e9 for simple enums and newtypes.\n\nNum\u27e811\u27e9\n    Derives `num_traits::Num`\u27e812\u27e9 for newtypes. The inner type must already implement `Num`.\n\nNumCast\u27e813\u27e9\n    Derives `num_traits::NumCast`\u27e814\u27e9 for newtypes. The inner type must already implement `NumCast`.\n\nNumOps\u27e815\u27e9\n    Derives `num_traits::NumOps`\u27e816\u27e9 for newtypes. The inner type must already implement `NumOps`.\n\nOne\u27e817\u27e9\n    Derives `num_traits::One`\u27e818\u27e9 for newtypes. The inner type must already implement `One`.\n\nSigned\u27e819\u27e9\n    Derives `num_traits::Signed`\u27e820\u27e9 for newtypes. The inner type must already implement `Signed`.\n\nToPrimitive\u27e821\u27e9\n    Derives `num_traits::ToPrimitive`\u27e822\u27e9 for simple enums and newtypes.\n\nUnsigned\u27e823\u27e9\n    Derives `num_traits::Unsigned`\u27e824\u27e9. The inner type must already implement `Unsigned`.\n\nZero\u27e825\u27e9\n    Derives `num_traits::Zero`\u27e826\u27e9 for newtypes. The inner type must already implement `Zero`.\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/num-derive/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/num-derive/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/num-derive/latest/src/num_derive/lib.rs.html#11-1004: Source\n\u27e84\u27e9 https://docs.rs/num-derive/latest/num_derive/#usage: \u00a7\n\u27e85\u27e9 https://docs.rs/num-derive/latest/num_derive/#explicit-import: \u00a7\n\u27e86\u27e9 https://docs.rs/num-derive/latest/num_derive/#derives: \u00a7\n\u27e87\u27e9 https://docs.rs/num-derive/latest/num_derive/derive.Float.html: derive num_derive::Float - Float\n\u27e88\u27e9 https://docs.rs/num-traits/0.2/num_traits/float/trait.Float.html: `num_traits::Float`\n\u27e89\u27e9 https://docs.rs/num-derive/latest/num_derive/derive.FromPrimitive.html: derive num_derive::FromPrimitive - FromPrimitive\n\u27e810\u27e9 https://docs.rs/num-traits/0.2/num_traits/cast/trait.FromPrimitive.html: `num_traits::FromPrimitive`\n\u27e811\u27e9 https://docs.rs/num-derive/latest/num_derive/derive.Num.html: derive num_derive::Num - Num\n\u27e812\u27e9 https://docs.rs/num-traits/0.2/num_traits/trait.Num.html: `num_traits::Num`\n\u27e813\u27e9 https://docs.rs/num-derive/latest/num_derive/derive.NumCast.html: derive num_derive::NumCast - NumCast\n\u27e814\u27e9 https://docs.rs/num-traits/0.2/num_traits/cast/trait.NumCast.html: `num_traits::NumCast`\n\u27e815\u27e9 https://docs.rs/num-derive/latest/num_derive/derive.NumOps.html: derive num_derive::NumOps - NumOps\n\u27e816\u27e9 https://docs.rs/num-traits/0.2/num_traits/trait.NumOps.html: `num_traits::NumOps`\n\u27e817\u27e9 https://docs.rs/num-derive/latest/num_derive/derive.One.html: derive num_derive::One - One\n\u27e818\u27e9 https://docs.rs/num-traits/0.2/num_traits/identities/trait.One.html: `num_traits::One`\n\u27e819\u27e9 https://docs.rs/num-derive/latest/num_derive/derive.Signed.html: derive num_derive::Signed - Signed\n\u27e820\u27e9 https://docs.rs/num-traits/0.2/num_traits/sign/trait.Signed.html: `num_traits::Signed`\n\u27e821\u27e9 https://docs.rs/num-derive/latest/num_derive/derive.ToPrimitive.html: derive num_derive::ToPrimitive - ToPrimitive\n\u27e822\u27e9 https://docs.rs/num-traits/0.2/num_traits/cast/trait.ToPrimitive.html: `num_traits::ToPrimitive`\n\u27e823\u27e9 https://docs.rs/num-derive/latest/num_derive/derive.Unsigned.html: derive num_derive::Unsigned - Unsigned\n\u27e824\u27e9 https://docs.rs/num/latest/num/traits/trait.Unsigned.html: `num_traits::Unsigned`\n\u27e825\u27e9 https://docs.rs/num-derive/latest/num_derive/derive.Zero.html: derive num_derive::Zero - Zero\n\u27e826\u27e9 https://docs.rs/num-traits/0.2/num_traits/identities/trait.Zero.html: `num_traits::Zero`\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `num-derive` crate provides procedural macros to automatically derive numeric traits from the `num-traits` crate for enums and newtypes in Rust. It supports traits like `FromPrimitive`, `ToPrimitive`, `Float`, `Num`, `NumOps`, `Signed`, `Unsigned`, `Zero`, and `One`, simplifying implementations for numeric conversions and operations. Additionally, it allows explicit imports for transitive dependencies of `num-traits`.",
    "feature_summary": null,
    "use_case": "Utilities",
    "score": 6.0,
    "factual_counterfactual": "### Pair 1: Trait Derivation for Enums  \n\u2705 Factual: The `num-derive` crate allows deriving numeric traits such as `FromPrimitive` and `ToPrimitive` for simple enums, enabling conversion between numeric types and enum variants.  \n\u274c Counterfactual: The `num-derive` crate supports deriving numeric traits for complex enums with associated data, allowing conversion for nested enum structures.  \n\n---\n\n### Pair 2: Dependency Requirements  \n\u2705 Factual: The `num-derive` crate requires the `num-traits` crate as a direct dependency by default, but it can use a transitive dependency if explicitly specified using the `#[num_traits = \"identifier\"]` attribute.  \n\u274c Counterfactual: The `num-derive` crate automatically detects and uses transitive dependencies of `num-traits` without requiring any additional configuration.  \n\n---\n\n### Pair 3: Supported Traits for Newtypes  \n\u2705 Factual: The `num-derive` crate can derive traits like `Zero`, `One`, and `Signed` for newtypes, provided the inner type already implements the corresponding traits.  \n\u274c Counterfactual: The `num-derive` crate can derive traits like `Zero`, `One`, and `Signed` for newtypes, even if the inner type does not implement the corresponding traits.",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}