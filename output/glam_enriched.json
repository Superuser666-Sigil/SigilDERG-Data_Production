{
    "name": "glam",
    "version": "0.30.4",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/glam/latest/glam/all.html \"show sidebar\")\n# Crate glamCopy item path\n[Settings](https://docs.rs/glam/latest/settings.html)\n[Help](https://docs.rs/glam/latest/help.html)\nSummary[Source](https://docs.rs/glam/latest/src/glam/lib.rs.html#1-383)\nExpand description\n## [\u00a7](https://docs.rs/glam/latest/glam/#glam)glam\n`glam` is a simple and fast linear algebra library for games and graphics.\n### [\u00a7](https://docs.rs/glam/latest/glam/#features)Features\n  * [`f32`](https://docs.rs/glam/latest/glam/f32/index.html \"mod glam::f32\") types \n    * vectors: [`Vec2`](https://docs.rs/glam/latest/glam/f32/struct.Vec2.html \"struct glam::f32::Vec2\"), [`Vec3`](https://docs.rs/glam/latest/glam/f32/struct.Vec3.html \"struct glam::f32::Vec3\"), [`Vec3A`](https://docs.rs/glam/latest/glam/f32/struct.Vec3A.html \"struct glam::f32::Vec3A\") and [`Vec4`](https://docs.rs/glam/latest/glam/f32/struct.Vec4.html \"struct glam::f32::Vec4\")\n    * square matrices: [`Mat2`](https://docs.rs/glam/latest/glam/f32/struct.Mat2.html \"struct glam::f32::Mat2\"), [`Mat3`](https://docs.rs/glam/latest/glam/f32/struct.Mat3.html \"struct glam::f32::Mat3\"), [`Mat3A`](https://docs.rs/glam/latest/glam/f32/struct.Mat3A.html \"struct glam::f32::Mat3A\") and [`Mat4`](https://docs.rs/glam/latest/glam/f32/struct.Mat4.html \"struct glam::f32::Mat4\")\n    * a quaternion type: [`Quat`](https://docs.rs/glam/latest/glam/f32/struct.Quat.html \"struct glam::f32::Quat\")\n    * affine transformation types: [`Affine2`](https://docs.rs/glam/latest/glam/f32/struct.Affine2.html \"struct glam::f32::Affine2\") and [`Affine3A`](https://docs.rs/glam/latest/glam/f32/struct.Affine3A.html \"struct glam::f32::Affine3A\")\n  * [`f64`](https://docs.rs/glam/latest/glam/f64/index.html \"mod glam::f64\") types \n    * vectors: [`DVec2`](https://docs.rs/glam/latest/glam/f64/struct.DVec2.html \"struct glam::f64::DVec2\"), [`DVec3`](https://docs.rs/glam/latest/glam/f64/struct.DVec3.html \"struct glam::f64::DVec3\") and [`DVec4`](https://docs.rs/glam/latest/glam/f64/struct.DVec4.html \"struct glam::f64::DVec4\")\n    * square matrices: [`DMat2`](https://docs.rs/glam/latest/glam/f64/struct.DMat2.html \"struct glam::f64::DMat2\"), [`DMat3`](https://docs.rs/glam/latest/glam/f64/struct.DMat3.html \"struct glam::f64::DMat3\") and [`DMat4`](https://docs.rs/glam/latest/glam/f64/struct.DMat4.html \"struct glam::f64::DMat4\")\n    * a quaternion type: [`DQuat`](https://docs.rs/glam/latest/glam/f64/struct.DQuat.html \"struct glam::f64::DQuat\")\n    * affine transformation types: [`DAffine2`](https://docs.rs/glam/latest/glam/f64/struct.DAffine2.html \"struct glam::f64::DAffine2\") and [`DAffine3`](https://docs.rs/glam/latest/glam/f64/struct.DAffine3.html \"struct glam::f64::DAffine3\")\n  * [`i8`](https://docs.rs/glam/latest/glam/i8/index.html \"mod glam::i8\") types \n    * vectors: [`I8Vec2`](https://docs.rs/glam/latest/glam/i8/struct.I8Vec2.html \"struct glam::i8::I8Vec2\"), [`I8Vec3`](https://docs.rs/glam/latest/glam/i8/struct.I8Vec3.html \"struct glam::i8::I8Vec3\") and [`I8Vec4`](https://docs.rs/glam/latest/glam/i8/struct.I8Vec4.html \"struct glam::i8::I8Vec4\")\n  * [`u8`](https://docs.rs/glam/latest/glam/u8/index.html \"mod glam::u8\") types \n    * vectors: [`U8Vec2`](https://docs.rs/glam/latest/glam/u8/struct.U8Vec2.html \"struct glam::u8::U8Vec2\"), [`U8Vec3`](https://docs.rs/glam/latest/glam/u8/struct.U8Vec3.html \"struct glam::u8::U8Vec3\") and [`U8Vec4`](https://docs.rs/glam/latest/glam/u8/struct.U8Vec4.html \"struct glam::u8::U8Vec4\")\n  * [`i16`](https://docs.rs/glam/latest/glam/i16/index.html \"mod glam::i16\") types \n    * vectors: [`I16Vec2`](https://docs.rs/glam/latest/glam/i16/struct.I16Vec2.html \"struct glam::i16::I16Vec2\"), [`I16Vec3`](https://docs.rs/glam/latest/glam/i16/struct.I16Vec3.html \"struct glam::i16::I16Vec3\") and [`I16Vec4`](https://docs.rs/glam/latest/glam/i16/struct.I16Vec4.html \"struct glam::i16::I16Vec4\")\n  * [`u16`](https://docs.rs/glam/latest/glam/u16/index.html \"mod glam::u16\") types \n    * vectors: [`U16Vec2`](https://docs.rs/glam/latest/glam/u16/struct.U16Vec2.html \"struct glam::u16::U16Vec2\"), [`U16Vec3`](https://docs.rs/glam/latest/glam/u16/struct.U16Vec3.html \"struct glam::u16::U16Vec3\") and [`U16Vec4`](https://docs.rs/glam/latest/glam/u16/struct.U16Vec4.html \"struct glam::u16::U16Vec4\")\n  * [`i32`](https://docs.rs/glam/latest/glam/i32/index.html \"mod glam::i32\") types \n    * vectors: [`IVec2`](https://docs.rs/glam/latest/glam/i32/struct.IVec2.html \"struct glam::i32::IVec2\"), [`IVec3`](https://docs.rs/glam/latest/glam/i32/struct.IVec3.html \"struct glam::i32::IVec3\") and [`IVec4`](https://docs.rs/glam/latest/glam/i32/struct.IVec4.html \"struct glam::i32::IVec4\")\n  * [`u32`](https://docs.rs/glam/latest/glam/u32/index.html \"mod glam::u32\") types \n    * vectors: [`UVec2`](https://docs.rs/glam/latest/glam/u32/struct.UVec2.html \"struct glam::u32::UVec2\"), [`UVec3`](https://docs.rs/glam/latest/glam/u32/struct.UVec3.html \"struct glam::u32::UVec3\") and [`UVec4`](https://docs.rs/glam/latest/glam/u32/struct.UVec4.html \"struct glam::u32::UVec4\")\n  * [`i64`](https://docs.rs/glam/latest/glam/i64/index.html \"mod glam::i64\") types \n    * vectors: [`I64Vec2`](https://docs.rs/glam/latest/glam/i64/struct.I64Vec2.html \"struct glam::i64::I64Vec2\"), [`I64Vec3`](https://docs.rs/glam/latest/glam/i64/struct.I64Vec3.html \"struct glam::i64::I64Vec3\") and [`I64Vec4`](https://docs.rs/glam/latest/glam/i64/struct.I64Vec4.html \"struct glam::i64::I64Vec4\")\n  * [`u64`](https://docs.rs/glam/latest/glam/u64/index.html \"mod glam::u64\") types \n    * vectors: [`U64Vec2`](https://docs.rs/glam/latest/glam/u64/struct.U64Vec2.html \"struct glam::u64::U64Vec2\"), [`U64Vec3`](https://docs.rs/glam/latest/glam/u64/struct.U64Vec3.html \"struct glam::u64::U64Vec3\") and [`U64Vec4`](https://docs.rs/glam/latest/glam/u64/struct.U64Vec4.html \"struct glam::u64::U64Vec4\")\n  * [`usize`](https://docs.rs/glam/latest/glam/usize/index.html \"mod glam::usize\") types \n    * vectors: [`USizeVec2`](https://docs.rs/glam/latest/glam/usize/struct.USizeVec2.html \"struct glam::usize::USizeVec2\"), [`USizeVec3`](https://docs.rs/glam/latest/glam/usize/struct.USizeVec3.html \"struct glam::usize::USizeVec3\") and [`USizeVec4`](https://docs.rs/glam/latest/glam/usize/struct.USizeVec4.html \"struct glam::usize::USizeVec4\")\n  * [`bool`](https://docs.rs/glam/latest/glam/bool/index.html \"mod glam::bool\") types \n    * vectors: [`BVec2`](https://docs.rs/glam/latest/glam/bool/struct.BVec2.html \"struct glam::bool::BVec2\"), [`BVec3`](https://docs.rs/glam/latest/glam/bool/struct.BVec3.html \"struct glam::bool::BVec3\") and [`BVec4`](https://docs.rs/glam/latest/glam/bool/struct.BVec4.html \"struct glam::bool::BVec4\")\n\n\n### [\u00a7](https://docs.rs/glam/latest/glam/#simd)SIMD\n`glam` is built with SIMD in mind. Many `f32` types use 128-bit SIMD vector types for storage and/or implementation. The use of SIMD generally enables better performance than using primitive numeric types such as `f32`.\nSome `glam` types use SIMD for storage meaning they are 16 byte aligned, these types include `Mat2`, `Mat3A`, `Mat4`, `Quat`, `Vec3A`, `Vec4`, `Affine2` an `Affine3A`. Types with an `A` suffix are a SIMD alternative to a scalar type, e.g. `Vec3` uses `f32` storage and `Vec3A` uses SIMD storage.\nWhen SIMD is not available on the target the types will maintain 16 byte alignment and internal padding so that object sizes and layouts will not change between architectures. There are scalar math fallback implementations exist when SIMD is not available. It is intended to add support for other SIMD architectures once they appear in stable Rust.\nCurrently only SSE2 on x86/x86_64, NEON on Aarch64, and simd128 on WASM are supported.\n### [\u00a7](https://docs.rs/glam/latest/glam/#vec3a-and-mat3a)Vec3A and Mat3A\n`Vec3A` is a SIMD optimized version of the `Vec3` type, which due to 16 byte alignment results in `Vec3A` containing 4 bytes of padding making it 16 bytes in size in total. `Mat3A` is composed of three `Vec3A` columns.\nType| `f32` bytes| Align bytes| Size bytes| Padding  \n---|---|---|---|---  \n[`Vec3`](https://docs.rs/glam/latest/glam/f32/struct.Vec3.html \"struct glam::f32::Vec3\")| 12| 4| 12| 0  \n[`Vec3A`](https://docs.rs/glam/latest/glam/f32/struct.Vec3A.html \"struct glam::f32::Vec3A\")| 12| 16| 16| 4  \n[`Mat3`](https://docs.rs/glam/latest/glam/f32/struct.Mat3.html \"struct glam::f32::Mat3\")| 36| 4| 36| 0  \n[`Mat3A`](https://docs.rs/glam/latest/glam/f32/struct.Mat3A.html \"struct glam::f32::Mat3A\")| 36| 16| 48| 12  \nDespite this wasted space the SIMD implementations tend to outperform `f32` implementations in [**mathbench**](https://github.com/bitshifter/mathbench-rs) benchmarks.\n`glam` treats [`Vec3`](https://docs.rs/glam/latest/glam/f32/struct.Vec3.html \"struct glam::f32::Vec3\") as the default 3D vector type and [`Vec3A`](https://docs.rs/glam/latest/glam/f32/struct.Vec3A.html \"struct glam::f32::Vec3A\") a special case for optimization. When methods need to return a 3D vector they will generally return [`Vec3`](https://docs.rs/glam/latest/glam/f32/struct.Vec3.html \"struct glam::f32::Vec3\").\nThere are [`From`](https://doc.rust-lang.org/nightly/core/convert/trait.From.html \"trait core::convert::From\") trait implementations for converting from [`Vec4`](https://docs.rs/glam/latest/glam/f32/struct.Vec4.html \"struct glam::f32::Vec4\") to a [`Vec3A`](https://docs.rs/glam/latest/glam/f32/struct.Vec3A.html \"struct glam::f32::Vec3A\") and between [`Vec3`](https://docs.rs/glam/latest/glam/f32/struct.Vec3.html \"struct glam::f32::Vec3\") and [`Vec3A`](https://docs.rs/glam/latest/glam/f32/struct.Vec3A.html \"struct glam::f32::Vec3A\") (and vice versa).\n```\nuse glam::{Vec3, Vec3A, Vec4};\nlet v4 = Vec4::new(1.0, 2.0, 3.0, 4.0);\n// Convert from `Vec4` to `Vec3A`, this is a no-op if SIMD is supported.\n// We use an explicit method here instead of a From impl as data is lost in the conversion.\nlet v3a = Vec3A::from_vec4(v4);\nassert_eq!(Vec3A::new(1.0, 2.0, 3.0), v3a);\n// Convert from `Vec3A` to `Vec3`.\nlet v3 = Vec3::from(v3a);\nassert_eq!(Vec3::new(1.0, 2.0, 3.0), v3);\n// Convert from `Vec3` to `Vec3A`.\nlet v3a = Vec3A::from(v3);\nassert_eq!(Vec3A::new(1.0, 2.0, 3.0), v3a);\n```\n\n### [\u00a7](https://docs.rs/glam/latest/glam/#affine2-and-affine3a)Affine2 and Affine3A\n`Affine2` and `Affine3A` are composed of a linear transform matrix and a vector translation. The represent 2D and 3D affine transformations which are commonly used in games.\nThe table below shows the performance advantage of `Affine2` over `Mat3A` and `Mat3A` over `Mat3`.\noperation| `Mat3`| `Mat3A`| `Affine2`  \n---|---|---|---  \ninverse| 11.4\u00b10.09ns| 7.1\u00b10.09ns| 5.4\u00b10.06ns  \nmul self| 10.5\u00b10.04ns| 5.2\u00b10.05ns| 4.0\u00b10.05ns  \ntransform point2| 2.7\u00b10.02ns| 2.7\u00b10.03ns| 2.8\u00b10.04ns  \ntransform vector2| 2.6\u00b10.01ns| 2.6\u00b10.03ns| 2.3\u00b10.02ns  \nPerformance is much closer between `Mat4` and `Affine3A` with the affine type being faster to invert.\noperation| `Mat4`| `Affine3A`  \n---|---|---  \ninverse| 15.9\u00b10.11ns| 10.8\u00b10.06ns  \nmul self| 7.3\u00b10.05ns| 7.0\u00b10.06ns  \ntransform point3| 3.6\u00b10.02ns| 4.3\u00b10.04ns  \ntransform point3a| 3.0\u00b10.02ns| 3.0\u00b10.04ns  \ntransform vector3| 4.1\u00b10.02ns| 3.9\u00b10.04ns  \ntransform vector3a| 2.8\u00b10.02ns| 2.8\u00b10.02ns  \nBenchmarks were taken on an Intel Core i7-4710HQ.\n### [\u00a7](https://docs.rs/glam/latest/glam/#linear-algebra-conventions)Linear algebra conventions\n`glam` interprets vectors as column matrices (also known as column vectors) meaning when transforming a vector with a matrix the matrix goes on the left.\n```\nuse glam::{Mat3, Vec3};\nlet m = Mat3::IDENTITY;\nlet x = Vec3::X;\nlet v = m * x;\nassert_eq!(v, x);\n```\n\nMatrices are stored in memory in column-major order.\nAll angles are in radians. Rust provides the `f32::to_radians()` and `f64::to_radians()` methods to convert from degrees.\n### [\u00a7](https://docs.rs/glam/latest/glam/#direct-element-access)Direct element access\nBecause some types may internally be implemented using SIMD types, direct access to vector elements is supported by implementing the [`Deref`](https://doc.rust-lang.org/std/ops/trait.Deref.html) and [`DerefMut`](https://doc.rust-lang.org/std/ops/trait.DerefMut.html) traits.\n```\nuse glam::Vec3A;\nlet mut v = Vec3A::new(1.0, 2.0, 3.0);\nassert_eq!(3.0, v.z);\nv.z += 1.0;\nassert_eq!(4.0, v.z);\n```\n\n### [\u00a7](https://docs.rs/glam/latest/glam/#glam-assertions)glam assertions\n`glam` does not enforce validity checks on method parameters at runtime. For example methods that require normalized vectors as input such as `Quat::from_axis_angle(axis, angle)` will not check that axis is a valid normalized vector. To help catch unintended misuse of `glam` the `debug-glam-assert` or `glam-assert` features can be enabled to add checks ensure that inputs to are valid.\n### [\u00a7](https://docs.rs/glam/latest/glam/#vector-swizzles)Vector swizzles\n`glam` vector types have functions allowing elements of vectors to be reordered, this includes creating a vector of a different size from the vectors elements.\nThe swizzle functions are implemented using traits to add them to each vector type. This is primarily because there are a lot of swizzle functions which can obfuscate the other vector functions in documentation and so on. The traits are [`Vec2Swizzles`](https://docs.rs/glam/latest/glam/swizzles/trait.Vec2Swizzles.html \"trait glam::swizzles::Vec2Swizzles\"), [`Vec3Swizzles`](https://docs.rs/glam/latest/glam/swizzles/trait.Vec3Swizzles.html \"trait glam::swizzles::Vec3Swizzles\") and [`Vec4Swizzles`](https://docs.rs/glam/latest/glam/swizzles/trait.Vec4Swizzles.html \"trait glam::swizzles::Vec4Swizzles\").\nNote that the [`Vec3Swizzles`](https://docs.rs/glam/latest/glam/swizzles/trait.Vec3Swizzles.html \"trait glam::swizzles::Vec3Swizzles\") implementation for [`Vec3A`](https://docs.rs/glam/latest/glam/f32/struct.Vec3A.html \"struct glam::f32::Vec3A\") will return a [`Vec3A`](https://docs.rs/glam/latest/glam/f32/struct.Vec3A.html \"struct glam::f32::Vec3A\") for 3 element swizzles, all other implementations will return [`Vec3`](https://docs.rs/glam/latest/glam/f32/struct.Vec3.html \"struct glam::f32::Vec3\").\n```\nuse glam::{swizzles::*, Vec2, Vec3, Vec3A, Vec4};\nlet v = Vec4::new(1.0, 2.0, 3.0, 4.0);\n// Reverse elements of `v`, if SIMD is supported this will use a vector shuffle.\nlet wzyx = v.wzyx();\nassert_eq!(Vec4::new(4.0, 3.0, 2.0, 1.0), wzyx);\n// Swizzle the yzw elements of `v` into a `Vec3`\nlet yzw = v.yzw();\nassert_eq!(Vec3::new(2.0, 3.0, 4.0), yzw);\n// To swizzle a `Vec4` into a `Vec3A` swizzle the `Vec4` first then convert to\n// `Vec3A`. If SIMD is supported this will use a vector shuffle. The last\n// element of the shuffled `Vec4` is ignored by the `Vec3A`.\nlet yzw = Vec3A::from_vec4(v.yzwx());\nassert_eq!(Vec3A::new(2.0, 3.0, 4.0), yzw);\n// You can swizzle from a `Vec4` to a `Vec2`\nlet xy = v.xy();\nassert_eq!(Vec2::new(1.0, 2.0), xy);\n// And back again\nlet yyxx = xy.yyxx();\nassert_eq!(Vec4::new(2.0, 2.0, 1.0, 1.0), yyxx);\n```\n\n### [\u00a7](https://docs.rs/glam/latest/glam/#simd-and-scalar-consistency)SIMD and scalar consistency\n`glam` types implement `serde` `Serialize` and `Deserialize` traits to ensure that they will serialize and deserialize exactly the same whether or not SIMD support is being used.\nThe SIMD versions implement the `core::fmt::Debug` and `core::fmt::Display` traits so they print the same as the scalar version.\n```\nuse glam::Vec4;\nlet a = Vec4::new(1.0, 2.0, 3.0, 4.0);\nassert_eq!(format!(\"{}\", a), \"[1, 2, 3, 4]\");\n```\n\n### [\u00a7](https://docs.rs/glam/latest/glam/#feature-gates)Feature gates\nAll `glam` dependencies are optional, however some are required for tests and benchmarks.\n  * `std` - the default feature, has no dependencies.\n  * `approx` - traits and macros for approximate float comparisons\n  * `bytemuck` - for casting into slices of bytes\n  * `libm` - uses `libm` math functions instead of `std`\n  * `nostd-libm` - uses `libm` math functions if `std` is not available\n  * `mint` - for interoperating with other 3D math libraries\n  * `rand` - implementations of `Distribution` trait for all `glam` types.\n  * `rkyv` - implementations of `Archive`, `Serialize` and `Deserialize` for all `glam` types. Note that serialization is not interoperable with and without the `scalar-math` feature. It should work between all other builds of `glam`. Endian conversion is currently not supported\n  * `bytecheck` - to perform archive validation when using the `rkyv` feature\n  * `serde` - implementations of `Serialize` and `Deserialize` for all `glam` types. Note that serialization should work between builds of `glam` with and without SIMD enabled\n  * `speedy` - implementations of `speedy`\u2019s `Readable` and `Writable` for all `glam` types.\n  * `scalar-math` - disables SIMD support and uses native alignment for all types.\n  * `debug-glam-assert` - adds assertions in debug builds which check the validity of parameters passed to `glam` to help catch runtime errors.\n  * `glam-assert` - adds assertions to all builds which check the validity of parameters passed to `glam` to help catch runtime errors.\n  * `cuda` - forces `glam` types to match expected cuda alignment\n  * `fast-math` - By default, glam attempts to provide bit-for-bit identical results on all platforms. Using this feature will enable platform specific optimizations that may not be identical to other platforms. **Intermediate libraries should not use this feature and defer the decision to the final binary build**.\n  * `core-simd` - enables SIMD support via the portable simd module. This is an unstable feature which requires a nightly Rust toolchain and `std` support.\n\n\n### [\u00a7](https://docs.rs/glam/latest/glam/#minimum-supported-rust-version-msrv)Minimum Supported Rust Version (MSRV)\nThe minimum supported Rust version is `1.68.2`.\n## Re-exports[\u00a7](https://docs.rs/glam/latest/glam/#reexports)\n\n`pub use self::swizzles::Vec2Swizzles[](https://docs.rs/glam/latest/glam/swizzles/trait.Vec2Swizzles.html \"trait glam::swizzles::Vec2Swizzles\");`\n\n\n`pub use self::swizzles::Vec3Swizzles[](https://docs.rs/glam/latest/glam/swizzles/trait.Vec3Swizzles.html \"trait glam::swizzles::Vec3Swizzles\");`\n\n\n`pub use self::swizzles::Vec4Swizzles[](https://docs.rs/glam/latest/glam/swizzles/trait.Vec4Swizzles.html \"trait glam::swizzles::Vec4Swizzles\");`\n\n\n`pub use self::bool[](https://docs.rs/glam/latest/glam/bool/index.html \"mod glam::bool\")::*;`\n\n\n`pub use self::f32[](https://docs.rs/glam/latest/glam/f32/index.html \"mod glam::f32\")::*;`\n\n\n`pub use self::f64[](https://docs.rs/glam/latest/glam/f64/index.html \"mod glam::f64\")::*;`\n\n\n`pub use self::i8[](https://docs.rs/glam/latest/glam/i8/index.html \"mod glam::i8\")::*;`\n\n\n`pub use self::u8[](https://docs.rs/glam/latest/glam/u8/index.html \"mod glam::u8\")::*;`\n\n\n`pub use self::i16[](https://docs.rs/glam/latest/glam/i16/index.html \"mod glam::i16\")::*;`\n\n\n`pub use self::u16[](https://docs.rs/glam/latest/glam/u16/index.html \"mod glam::u16\")::*;`\n\n\n`pub use self::i32[](https://docs.rs/glam/latest/glam/i32/index.html \"mod glam::i32\")::*;`\n\n\n`pub use self::u32[](https://docs.rs/glam/latest/glam/u32/index.html \"mod glam::u32\")::*;`\n\n\n`pub use self::i64[](https://docs.rs/glam/latest/glam/i64/index.html \"mod glam::i64\")::*;`\n\n\n`pub use self::u64[](https://docs.rs/glam/latest/glam/u64/index.html \"mod glam::u64\")::*;`\n\n\n`pub use self::usize[](https://docs.rs/glam/latest/glam/usize/index.html \"mod glam::usize\")::*;`\n\n## Modules[\u00a7](https://docs.rs/glam/latest/glam/#modules)\n\n[bool](https://docs.rs/glam/latest/glam/bool/index.html \"mod glam::bool\")\n    `bool` vector mask types.\n\n[f32](https://docs.rs/glam/latest/glam/f32/index.html \"mod glam::f32\")\n    `f32` vector, quaternion and matrix types.\n\n[f64](https://docs.rs/glam/latest/glam/f64/index.html \"mod glam::f64\")\n    `f64` vector, quaternion and matrix types.\n\n[i8](https://docs.rs/glam/latest/glam/i8/index.html \"mod glam::i8\")\n    `i8` vector types.\n\n[i16](https://docs.rs/glam/latest/glam/i16/index.html \"mod glam::i16\")\n    `i16` vector types.\n\n[i32](https://docs.rs/glam/latest/glam/i32/index.html \"mod glam::i32\")\n    `i32` vector types.\n\n[i64](https://docs.rs/glam/latest/glam/i64/index.html \"mod glam::i64\")\n    `i64` vector types.\n\n[swizzles](https://docs.rs/glam/latest/glam/swizzles/index.html \"mod glam::swizzles\")\n    Traits adding swizzle methods to all vector types.\n\n[u8](https://docs.rs/glam/latest/glam/u8/index.html \"mod glam::u8\")\n    `u8` vector types.\n\n[u16](https://docs.rs/glam/latest/glam/u16/index.html \"mod glam::u16\")\n    `u16` vector types.\n\n[u32](https://docs.rs/glam/latest/glam/u32/index.html \"mod glam::u32\")\n    `u32` vector types.\n\n[u64](https://docs.rs/glam/latest/glam/u64/index.html \"mod glam::u64\")\n    `u64` vector types.\n\n[usize](https://docs.rs/glam/latest/glam/usize/index.html \"mod glam::usize\")\n    `usize` vector types.\n## Enums[\u00a7](https://docs.rs/glam/latest/glam/#enums)\n\n[EulerRot](https://docs.rs/glam/latest/glam/enum.EulerRot.html \"enum glam::EulerRot\")\n    Rotation Helper Euler rotation sequences.\n## Traits[\u00a7](https://docs.rs/glam/latest/glam/#traits)\n\n[FloatExt](https://docs.rs/glam/latest/glam/trait.FloatExt.html \"trait glam::FloatExt\")\n    A trait for extending [`f32`](https://doc.rust-lang.org/nightly/std/primitive.f32.html \"primitive f32\") and [`f64`](https://doc.rust-lang.org/nightly/std/primitive.f64.html \"primitive f64\") with extra methods.\n",
        "markdown_with_citations": "[](https://docs.rs/glam/latest/glam/all.html \"show sidebar\")\n# Crate glamCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\n## \u00a7\u27e84\u27e9glam\n`glam` is a simple and fast linear algebra library for games and graphics.\n### \u00a7\u27e85\u27e9Features\n  * `f32`\u27e86\u27e9 types \n    * vectors: `Vec2`\u27e87\u27e9, `Vec3`\u27e88\u27e9, `Vec3A`\u27e89\u27e9 and `Vec4`\u27e810\u27e9\n    * square matrices: `Mat2`\u27e811\u27e9, `Mat3`\u27e812\u27e9, `Mat3A`\u27e813\u27e9 and `Mat4`\u27e814\u27e9\n    * a quaternion type: `Quat`\u27e815\u27e9\n    * affine transformation types: `Affine2`\u27e816\u27e9 and `Affine3A`\u27e817\u27e9\n  * `f64`\u27e818\u27e9 types \n    * vectors: `DVec2`\u27e819\u27e9, `DVec3`\u27e820\u27e9 and `DVec4`\u27e821\u27e9\n    * square matrices: `DMat2`\u27e822\u27e9, `DMat3`\u27e823\u27e9 and `DMat4`\u27e824\u27e9\n    * a quaternion type: `DQuat`\u27e825\u27e9\n    * affine transformation types: `DAffine2`\u27e826\u27e9 and `DAffine3`\u27e827\u27e9\n  * `i8`\u27e828\u27e9 types \n    * vectors: `I8Vec2`\u27e829\u27e9, `I8Vec3`\u27e830\u27e9 and `I8Vec4`\u27e831\u27e9\n  * `u8`\u27e832\u27e9 types \n    * vectors: `U8Vec2`\u27e833\u27e9, `U8Vec3`\u27e834\u27e9 and `U8Vec4`\u27e835\u27e9\n  * `i16`\u27e836\u27e9 types \n    * vectors: `I16Vec2`\u27e837\u27e9, `I16Vec3`\u27e838\u27e9 and `I16Vec4`\u27e839\u27e9\n  * `u16`\u27e840\u27e9 types \n    * vectors: `U16Vec2`\u27e841\u27e9, `U16Vec3`\u27e842\u27e9 and `U16Vec4`\u27e843\u27e9\n  * `i32`\u27e844\u27e9 types \n    * vectors: `IVec2`\u27e845\u27e9, `IVec3`\u27e846\u27e9 and `IVec4`\u27e847\u27e9\n  * `u32`\u27e848\u27e9 types \n    * vectors: `UVec2`\u27e849\u27e9, `UVec3`\u27e850\u27e9 and `UVec4`\u27e851\u27e9\n  * `i64`\u27e852\u27e9 types \n    * vectors: `I64Vec2`\u27e853\u27e9, `I64Vec3`\u27e854\u27e9 and `I64Vec4`\u27e855\u27e9\n  * `u64`\u27e856\u27e9 types \n    * vectors: `U64Vec2`\u27e857\u27e9, `U64Vec3`\u27e858\u27e9 and `U64Vec4`\u27e859\u27e9\n  * `usize`\u27e860\u27e9 types \n    * vectors: `USizeVec2`\u27e861\u27e9, `USizeVec3`\u27e862\u27e9 and `USizeVec4`\u27e863\u27e9\n  * `bool`\u27e864\u27e9 types \n    * vectors: `BVec2`\u27e865\u27e9, `BVec3`\u27e866\u27e9 and `BVec4`\u27e867\u27e9\n\n\n### \u00a7\u27e868\u27e9SIMD\n`glam` is built with SIMD in mind. Many `f32` types use 128-bit SIMD vector types for storage and/or implementation. The use of SIMD generally enables better performance than using primitive numeric types such as `f32`.\nSome `glam` types use SIMD for storage meaning they are 16 byte aligned, these types include `Mat2`, `Mat3A`, `Mat4`, `Quat`, `Vec3A`, `Vec4`, `Affine2` an `Affine3A`. Types with an `A` suffix are a SIMD alternative to a scalar type, e.g. `Vec3` uses `f32` storage and `Vec3A` uses SIMD storage.\nWhen SIMD is not available on the target the types will maintain 16 byte alignment and internal padding so that object sizes and layouts will not change between architectures. There are scalar math fallback implementations exist when SIMD is not available. It is intended to add support for other SIMD architectures once they appear in stable Rust.\nCurrently only SSE2 on x86/x86_64, NEON on Aarch64, and simd128 on WASM are supported.\n### \u00a7\u27e869\u27e9Vec3A and Mat3A\n`Vec3A` is a SIMD optimized version of the `Vec3` type, which due to 16 byte alignment results in `Vec3A` containing 4 bytes of padding making it 16 bytes in size in total. `Mat3A` is composed of three `Vec3A` columns.\nType| `f32` bytes| Align bytes| Size bytes| Padding  \n---|---|---|---|---  \n`Vec3`\u27e88\u27e9| 12| 4| 12| 0  \n`Vec3A`\u27e89\u27e9| 12| 16| 16| 4  \n`Mat3`\u27e812\u27e9| 36| 4| 36| 0  \n`Mat3A`\u27e813\u27e9| 36| 16| 48| 12  \nDespite this wasted space the SIMD implementations tend to outperform `f32` implementations in **mathbench**\u27e870\u27e9 benchmarks.\n`glam` treats `Vec3`\u27e88\u27e9 as the default 3D vector type and `Vec3A`\u27e89\u27e9 a special case for optimization. When methods need to return a 3D vector they will generally return `Vec3`\u27e88\u27e9.\nThere are `From`\u27e871\u27e9 trait implementations for converting from `Vec4`\u27e810\u27e9 to a `Vec3A`\u27e89\u27e9 and between `Vec3`\u27e88\u27e9 and `Vec3A`\u27e89\u27e9 (and vice versa).\n```\nuse glam::{Vec3, Vec3A, Vec4};\nlet v4 = Vec4::new(1.0, 2.0, 3.0, 4.0);\n// Convert from `Vec4` to `Vec3A`, this is a no-op if SIMD is supported.\n// We use an explicit method here instead of a From impl as data is lost in the conversion.\nlet v3a = Vec3A::from_vec4(v4);\nassert_eq!(Vec3A::new(1.0, 2.0, 3.0), v3a);\n// Convert from `Vec3A` to `Vec3`.\nlet v3 = Vec3::from(v3a);\nassert_eq!(Vec3::new(1.0, 2.0, 3.0), v3);\n// Convert from `Vec3` to `Vec3A`.\nlet v3a = Vec3A::from(v3);\nassert_eq!(Vec3A::new(1.0, 2.0, 3.0), v3a);\n```\n\n### \u00a7\u27e872\u27e9Affine2 and Affine3A\n`Affine2` and `Affine3A` are composed of a linear transform matrix and a vector translation. The represent 2D and 3D affine transformations which are commonly used in games.\nThe table below shows the performance advantage of `Affine2` over `Mat3A` and `Mat3A` over `Mat3`.\noperation| `Mat3`| `Mat3A`| `Affine2`  \n---|---|---|---  \ninverse| 11.4\u00b10.09ns| 7.1\u00b10.09ns| 5.4\u00b10.06ns  \nmul self| 10.5\u00b10.04ns| 5.2\u00b10.05ns| 4.0\u00b10.05ns  \ntransform point2| 2.7\u00b10.02ns| 2.7\u00b10.03ns| 2.8\u00b10.04ns  \ntransform vector2| 2.6\u00b10.01ns| 2.6\u00b10.03ns| 2.3\u00b10.02ns  \nPerformance is much closer between `Mat4` and `Affine3A` with the affine type being faster to invert.\noperation| `Mat4`| `Affine3A`  \n---|---|---  \ninverse| 15.9\u00b10.11ns| 10.8\u00b10.06ns  \nmul self| 7.3\u00b10.05ns| 7.0\u00b10.06ns  \ntransform point3| 3.6\u00b10.02ns| 4.3\u00b10.04ns  \ntransform point3a| 3.0\u00b10.02ns| 3.0\u00b10.04ns  \ntransform vector3| 4.1\u00b10.02ns| 3.9\u00b10.04ns  \ntransform vector3a| 2.8\u00b10.02ns| 2.8\u00b10.02ns  \nBenchmarks were taken on an Intel Core i7-4710HQ.\n### \u00a7\u27e873\u27e9Linear algebra conventions\n`glam` interprets vectors as column matrices (also known as column vectors) meaning when transforming a vector with a matrix the matrix goes on the left.\n```\nuse glam::{Mat3, Vec3};\nlet m = Mat3::IDENTITY;\nlet x = Vec3::X;\nlet v = m * x;\nassert_eq!(v, x);\n```\n\nMatrices are stored in memory in column-major order.\nAll angles are in radians. Rust provides the `f32::to_radians()` and `f64::to_radians()` methods to convert from degrees.\n### \u00a7\u27e874\u27e9Direct element access\nBecause some types may internally be implemented using SIMD types, direct access to vector elements is supported by implementing the `Deref`\u27e875\u27e9 and `DerefMut`\u27e876\u27e9 traits.\n```\nuse glam::Vec3A;\nlet mut v = Vec3A::new(1.0, 2.0, 3.0);\nassert_eq!(3.0, v.z);\nv.z += 1.0;\nassert_eq!(4.0, v.z);\n```\n\n### \u00a7\u27e877\u27e9glam assertions\n`glam` does not enforce validity checks on method parameters at runtime. For example methods that require normalized vectors as input such as `Quat::from_axis_angle(axis, angle)` will not check that axis is a valid normalized vector. To help catch unintended misuse of `glam` the `debug-glam-assert` or `glam-assert` features can be enabled to add checks ensure that inputs to are valid.\n### \u00a7\u27e878\u27e9Vector swizzles\n`glam` vector types have functions allowing elements of vectors to be reordered, this includes creating a vector of a different size from the vectors elements.\nThe swizzle functions are implemented using traits to add them to each vector type. This is primarily because there are a lot of swizzle functions which can obfuscate the other vector functions in documentation and so on. The traits are `Vec2Swizzles`\u27e879\u27e9, `Vec3Swizzles`\u27e880\u27e9 and `Vec4Swizzles`\u27e881\u27e9.\nNote that the `Vec3Swizzles`\u27e880\u27e9 implementation for `Vec3A`\u27e89\u27e9 will return a `Vec3A`\u27e89\u27e9 for 3 element swizzles, all other implementations will return `Vec3`\u27e88\u27e9.\n```\nuse glam::{swizzles::*, Vec2, Vec3, Vec3A, Vec4};\nlet v = Vec4::new(1.0, 2.0, 3.0, 4.0);\n// Reverse elements of `v`, if SIMD is supported this will use a vector shuffle.\nlet wzyx = v.wzyx();\nassert_eq!(Vec4::new(4.0, 3.0, 2.0, 1.0), wzyx);\n// Swizzle the yzw elements of `v` into a `Vec3`\nlet yzw = v.yzw();\nassert_eq!(Vec3::new(2.0, 3.0, 4.0), yzw);\n// To swizzle a `Vec4` into a `Vec3A` swizzle the `Vec4` first then convert to\n// `Vec3A`. If SIMD is supported this will use a vector shuffle. The last\n// element of the shuffled `Vec4` is ignored by the `Vec3A`.\nlet yzw = Vec3A::from_vec4(v.yzwx());\nassert_eq!(Vec3A::new(2.0, 3.0, 4.0), yzw);\n// You can swizzle from a `Vec4` to a `Vec2`\nlet xy = v.xy();\nassert_eq!(Vec2::new(1.0, 2.0), xy);\n// And back again\nlet yyxx = xy.yyxx();\nassert_eq!(Vec4::new(2.0, 2.0, 1.0, 1.0), yyxx);\n```\n\n### \u00a7\u27e882\u27e9SIMD and scalar consistency\n`glam` types implement `serde` `Serialize` and `Deserialize` traits to ensure that they will serialize and deserialize exactly the same whether or not SIMD support is being used.\nThe SIMD versions implement the `core::fmt::Debug` and `core::fmt::Display` traits so they print the same as the scalar version.\n```\nuse glam::Vec4;\nlet a = Vec4::new(1.0, 2.0, 3.0, 4.0);\nassert_eq!(format!(\"{}\", a), \"[1, 2, 3, 4]\");\n```\n\n### \u00a7\u27e883\u27e9Feature gates\nAll `glam` dependencies are optional, however some are required for tests and benchmarks.\n  * `std` - the default feature, has no dependencies.\n  * `approx` - traits and macros for approximate float comparisons\n  * `bytemuck` - for casting into slices of bytes\n  * `libm` - uses `libm` math functions instead of `std`\n  * `nostd-libm` - uses `libm` math functions if `std` is not available\n  * `mint` - for interoperating with other 3D math libraries\n  * `rand` - implementations of `Distribution` trait for all `glam` types.\n  * `rkyv` - implementations of `Archive`, `Serialize` and `Deserialize` for all `glam` types. Note that serialization is not interoperable with and without the `scalar-math` feature. It should work between all other builds of `glam`. Endian conversion is currently not supported\n  * `bytecheck` - to perform archive validation when using the `rkyv` feature\n  * `serde` - implementations of `Serialize` and `Deserialize` for all `glam` types. Note that serialization should work between builds of `glam` with and without SIMD enabled\n  * `speedy` - implementations of `speedy`\u2019s `Readable` and `Writable` for all `glam` types.\n  * `scalar-math` - disables SIMD support and uses native alignment for all types.\n  * `debug-glam-assert` - adds assertions in debug builds which check the validity of parameters passed to `glam` to help catch runtime errors.\n  * `glam-assert` - adds assertions to all builds which check the validity of parameters passed to `glam` to help catch runtime errors.\n  * `cuda` - forces `glam` types to match expected cuda alignment\n  * `fast-math` - By default, glam attempts to provide bit-for-bit identical results on all platforms. Using this feature will enable platform specific optimizations that may not be identical to other platforms. **Intermediate libraries should not use this feature and defer the decision to the final binary build**.\n  * `core-simd` - enables SIMD support via the portable simd module. This is an unstable feature which requires a nightly Rust toolchain and `std` support.\n\n\n### \u00a7\u27e884\u27e9Minimum Supported Rust Version (MSRV)\nThe minimum supported Rust version is `1.68.2`.\n## Re-exports\u00a7\u27e885\u27e9\n\n`pub use self::swizzles::Vec2Swizzles[](https://docs.rs/glam/latest/glam/swizzles/trait.Vec2Swizzles.html \"trait glam::swizzles::Vec2Swizzles\");`\n\n\n`pub use self::swizzles::Vec3Swizzles[](https://docs.rs/glam/latest/glam/swizzles/trait.Vec3Swizzles.html \"trait glam::swizzles::Vec3Swizzles\");`\n\n\n`pub use self::swizzles::Vec4Swizzles[](https://docs.rs/glam/latest/glam/swizzles/trait.Vec4Swizzles.html \"trait glam::swizzles::Vec4Swizzles\");`\n\n\n`pub use self::bool[](https://docs.rs/glam/latest/glam/bool/index.html \"mod glam::bool\")::*;`\n\n\n`pub use self::f32[](https://docs.rs/glam/latest/glam/f32/index.html \"mod glam::f32\")::*;`\n\n\n`pub use self::f64[](https://docs.rs/glam/latest/glam/f64/index.html \"mod glam::f64\")::*;`\n\n\n`pub use self::i8[](https://docs.rs/glam/latest/glam/i8/index.html \"mod glam::i8\")::*;`\n\n\n`pub use self::u8[](https://docs.rs/glam/latest/glam/u8/index.html \"mod glam::u8\")::*;`\n\n\n`pub use self::i16[](https://docs.rs/glam/latest/glam/i16/index.html \"mod glam::i16\")::*;`\n\n\n`pub use self::u16[](https://docs.rs/glam/latest/glam/u16/index.html \"mod glam::u16\")::*;`\n\n\n`pub use self::i32[](https://docs.rs/glam/latest/glam/i32/index.html \"mod glam::i32\")::*;`\n\n\n`pub use self::u32[](https://docs.rs/glam/latest/glam/u32/index.html \"mod glam::u32\")::*;`\n\n\n`pub use self::i64[](https://docs.rs/glam/latest/glam/i64/index.html \"mod glam::i64\")::*;`\n\n\n`pub use self::u64[](https://docs.rs/glam/latest/glam/u64/index.html \"mod glam::u64\")::*;`\n\n\n`pub use self::usize[](https://docs.rs/glam/latest/glam/usize/index.html \"mod glam::usize\")::*;`\n\n## Modules\u00a7\u27e886\u27e9\n\nbool\u27e864\u27e9\n    `bool` vector mask types.\n\nf32\u27e86\u27e9\n    `f32` vector, quaternion and matrix types.\n\nf64\u27e818\u27e9\n    `f64` vector, quaternion and matrix types.\n\ni8\u27e828\u27e9\n    `i8` vector types.\n\ni16\u27e836\u27e9\n    `i16` vector types.\n\ni32\u27e844\u27e9\n    `i32` vector types.\n\ni64\u27e852\u27e9\n    `i64` vector types.\n\nswizzles\u27e887\u27e9\n    Traits adding swizzle methods to all vector types.\n\nu8\u27e832\u27e9\n    `u8` vector types.\n\nu16\u27e840\u27e9\n    `u16` vector types.\n\nu32\u27e848\u27e9\n    `u32` vector types.\n\nu64\u27e856\u27e9\n    `u64` vector types.\n\nusize\u27e860\u27e9\n    `usize` vector types.\n## Enums\u00a7\u27e888\u27e9\n\nEulerRot\u27e889\u27e9\n    Rotation Helper Euler rotation sequences.\n## Traits\u00a7\u27e890\u27e9\n\nFloatExt\u27e891\u27e9\n    A trait for extending `f32`\u27e892\u27e9 and `f64`\u27e893\u27e9 with extra methods.\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/glam/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/glam/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/glam/latest/src/glam/lib.rs.html#1-383: Source\n\u27e84\u27e9 https://docs.rs/glam/latest/glam/#glam: \u00a7\n\u27e85\u27e9 https://docs.rs/glam/latest/glam/#features: \u00a7\n\u27e86\u27e9 https://docs.rs/glam/latest/glam/f32/index.html: mod glam::f32 - `f32`\n\u27e87\u27e9 https://docs.rs/glam/latest/glam/f32/struct.Vec2.html: struct glam::f32::Vec2 - `Vec2`\n\u27e88\u27e9 https://docs.rs/glam/latest/glam/f32/struct.Vec3.html: struct glam::f32::Vec3 - `Vec3`\n\u27e89\u27e9 https://docs.rs/glam/latest/glam/f32/struct.Vec3A.html: struct glam::f32::Vec3A - `Vec3A`\n\u27e810\u27e9 https://docs.rs/glam/latest/glam/f32/struct.Vec4.html: struct glam::f32::Vec4 - `Vec4`\n\u27e811\u27e9 https://docs.rs/glam/latest/glam/f32/struct.Mat2.html: struct glam::f32::Mat2 - `Mat2`\n\u27e812\u27e9 https://docs.rs/glam/latest/glam/f32/struct.Mat3.html: struct glam::f32::Mat3 - `Mat3`\n\u27e813\u27e9 https://docs.rs/glam/latest/glam/f32/struct.Mat3A.html: struct glam::f32::Mat3A - `Mat3A`\n\u27e814\u27e9 https://docs.rs/glam/latest/glam/f32/struct.Mat4.html: struct glam::f32::Mat4 - `Mat4`\n\u27e815\u27e9 https://docs.rs/glam/latest/glam/f32/struct.Quat.html: struct glam::f32::Quat - `Quat`\n\u27e816\u27e9 https://docs.rs/glam/latest/glam/f32/struct.Affine2.html: struct glam::f32::Affine2 - `Affine2`\n\u27e817\u27e9 https://docs.rs/glam/latest/glam/f32/struct.Affine3A.html: struct glam::f32::Affine3A - `Affine3A`\n\u27e818\u27e9 https://docs.rs/glam/latest/glam/f64/index.html: mod glam::f64 - `f64`\n\u27e819\u27e9 https://docs.rs/glam/latest/glam/f64/struct.DVec2.html: struct glam::f64::DVec2 - `DVec2`\n\u27e820\u27e9 https://docs.rs/glam/latest/glam/f64/struct.DVec3.html: struct glam::f64::DVec3 - `DVec3`\n\u27e821\u27e9 https://docs.rs/glam/latest/glam/f64/struct.DVec4.html: struct glam::f64::DVec4 - `DVec4`\n\u27e822\u27e9 https://docs.rs/glam/latest/glam/f64/struct.DMat2.html: struct glam::f64::DMat2 - `DMat2`\n\u27e823\u27e9 https://docs.rs/glam/latest/glam/f64/struct.DMat3.html: struct glam::f64::DMat3 - `DMat3`\n\u27e824\u27e9 https://docs.rs/glam/latest/glam/f64/struct.DMat4.html: struct glam::f64::DMat4 - `DMat4`\n\u27e825\u27e9 https://docs.rs/glam/latest/glam/f64/struct.DQuat.html: struct glam::f64::DQuat - `DQuat`\n\u27e826\u27e9 https://docs.rs/glam/latest/glam/f64/struct.DAffine2.html: struct glam::f64::DAffine2 - `DAffine2`\n\u27e827\u27e9 https://docs.rs/glam/latest/glam/f64/struct.DAffine3.html: struct glam::f64::DAffine3 - `DAffine3`\n\u27e828\u27e9 https://docs.rs/glam/latest/glam/i8/index.html: mod glam::i8 - `i8`\n\u27e829\u27e9 https://docs.rs/glam/latest/glam/i8/struct.I8Vec2.html: struct glam::i8::I8Vec2 - `I8Vec2`\n\u27e830\u27e9 https://docs.rs/glam/latest/glam/i8/struct.I8Vec3.html: struct glam::i8::I8Vec3 - `I8Vec3`\n\u27e831\u27e9 https://docs.rs/glam/latest/glam/i8/struct.I8Vec4.html: struct glam::i8::I8Vec4 - `I8Vec4`\n\u27e832\u27e9 https://docs.rs/glam/latest/glam/u8/index.html: mod glam::u8 - `u8`\n\u27e833\u27e9 https://docs.rs/glam/latest/glam/u8/struct.U8Vec2.html: struct glam::u8::U8Vec2 - `U8Vec2`\n\u27e834\u27e9 https://docs.rs/glam/latest/glam/u8/struct.U8Vec3.html: struct glam::u8::U8Vec3 - `U8Vec3`\n\u27e835\u27e9 https://docs.rs/glam/latest/glam/u8/struct.U8Vec4.html: struct glam::u8::U8Vec4 - `U8Vec4`\n\u27e836\u27e9 https://docs.rs/glam/latest/glam/i16/index.html: mod glam::i16 - `i16`\n\u27e837\u27e9 https://docs.rs/glam/latest/glam/i16/struct.I16Vec2.html: struct glam::i16::I16Vec2 - `I16Vec2`\n\u27e838\u27e9 https://docs.rs/glam/latest/glam/i16/struct.I16Vec3.html: struct glam::i16::I16Vec3 - `I16Vec3`\n\u27e839\u27e9 https://docs.rs/glam/latest/glam/i16/struct.I16Vec4.html: struct glam::i16::I16Vec4 - `I16Vec4`\n\u27e840\u27e9 https://docs.rs/glam/latest/glam/u16/index.html: mod glam::u16 - `u16`\n\u27e841\u27e9 https://docs.rs/glam/latest/glam/u16/struct.U16Vec2.html: struct glam::u16::U16Vec2 - `U16Vec2`\n\u27e842\u27e9 https://docs.rs/glam/latest/glam/u16/struct.U16Vec3.html: struct glam::u16::U16Vec3 - `U16Vec3`\n\u27e843\u27e9 https://docs.rs/glam/latest/glam/u16/struct.U16Vec4.html: struct glam::u16::U16Vec4 - `U16Vec4`\n\u27e844\u27e9 https://docs.rs/glam/latest/glam/i32/index.html: mod glam::i32 - `i32`\n\u27e845\u27e9 https://docs.rs/glam/latest/glam/i32/struct.IVec2.html: struct glam::i32::IVec2 - `IVec2`\n\u27e846\u27e9 https://docs.rs/glam/latest/glam/i32/struct.IVec3.html: struct glam::i32::IVec3 - `IVec3`\n\u27e847\u27e9 https://docs.rs/glam/latest/glam/i32/struct.IVec4.html: struct glam::i32::IVec4 - `IVec4`\n\u27e848\u27e9 https://docs.rs/glam/latest/glam/u32/index.html: mod glam::u32 - `u32`\n\u27e849\u27e9 https://docs.rs/glam/latest/glam/u32/struct.UVec2.html: struct glam::u32::UVec2 - `UVec2`\n\u27e850\u27e9 https://docs.rs/glam/latest/glam/u32/struct.UVec3.html: struct glam::u32::UVec3 - `UVec3`\n\u27e851\u27e9 https://docs.rs/glam/latest/glam/u32/struct.UVec4.html: struct glam::u32::UVec4 - `UVec4`\n\u27e852\u27e9 https://docs.rs/glam/latest/glam/i64/index.html: mod glam::i64 - `i64`\n\u27e853\u27e9 https://docs.rs/glam/latest/glam/i64/struct.I64Vec2.html: struct glam::i64::I64Vec2 - `I64Vec2`\n\u27e854\u27e9 https://docs.rs/glam/latest/glam/i64/struct.I64Vec3.html: struct glam::i64::I64Vec3 - `I64Vec3`\n\u27e855\u27e9 https://docs.rs/glam/latest/glam/i64/struct.I64Vec4.html: struct glam::i64::I64Vec4 - `I64Vec4`\n\u27e856\u27e9 https://docs.rs/glam/latest/glam/u64/index.html: mod glam::u64 - `u64`\n\u27e857\u27e9 https://docs.rs/glam/latest/glam/u64/struct.U64Vec2.html: struct glam::u64::U64Vec2 - `U64Vec2`\n\u27e858\u27e9 https://docs.rs/glam/latest/glam/u64/struct.U64Vec3.html: struct glam::u64::U64Vec3 - `U64Vec3`\n\u27e859\u27e9 https://docs.rs/glam/latest/glam/u64/struct.U64Vec4.html: struct glam::u64::U64Vec4 - `U64Vec4`\n\u27e860\u27e9 https://docs.rs/glam/latest/glam/usize/index.html: mod glam::usize - `usize`\n\u27e861\u27e9 https://docs.rs/glam/latest/glam/usize/struct.USizeVec2.html: struct glam::usize::USizeVec2 - `USizeVec2`\n\u27e862\u27e9 https://docs.rs/glam/latest/glam/usize/struct.USizeVec3.html: struct glam::usize::USizeVec3 - `USizeVec3`\n\u27e863\u27e9 https://docs.rs/glam/latest/glam/usize/struct.USizeVec4.html: struct glam::usize::USizeVec4 - `USizeVec4`\n\u27e864\u27e9 https://docs.rs/glam/latest/glam/bool/index.html: mod glam::bool - `bool`\n\u27e865\u27e9 https://docs.rs/glam/latest/glam/bool/struct.BVec2.html: struct glam::bool::BVec2 - `BVec2`\n\u27e866\u27e9 https://docs.rs/glam/latest/glam/bool/struct.BVec3.html: struct glam::bool::BVec3 - `BVec3`\n\u27e867\u27e9 https://docs.rs/glam/latest/glam/bool/struct.BVec4.html: struct glam::bool::BVec4 - `BVec4`\n\u27e868\u27e9 https://docs.rs/glam/latest/glam/#simd: \u00a7\n\u27e869\u27e9 https://docs.rs/glam/latest/glam/#vec3a-and-mat3a: \u00a7\n\u27e870\u27e9 https://github.com/bitshifter/mathbench-rs: **mathbench**\n\u27e871\u27e9 https://doc.rust-lang.org/nightly/core/convert/trait.From.html: trait core::convert::From - `From`\n\u27e872\u27e9 https://docs.rs/glam/latest/glam/#affine2-and-affine3a: \u00a7\n\u27e873\u27e9 https://docs.rs/glam/latest/glam/#linear-algebra-conventions: \u00a7\n\u27e874\u27e9 https://docs.rs/glam/latest/glam/#direct-element-access: \u00a7\n\u27e875\u27e9 https://doc.rust-lang.org/std/ops/trait.Deref.html: `Deref`\n\u27e876\u27e9 https://doc.rust-lang.org/std/ops/trait.DerefMut.html: `DerefMut`\n\u27e877\u27e9 https://docs.rs/glam/latest/glam/#glam-assertions: \u00a7\n\u27e878\u27e9 https://docs.rs/glam/latest/glam/#vector-swizzles: \u00a7\n\u27e879\u27e9 https://docs.rs/glam/latest/glam/swizzles/trait.Vec2Swizzles.html: trait glam::swizzles::Vec2Swizzles - `Vec2Swizzles`\n\u27e880\u27e9 https://docs.rs/glam/latest/glam/swizzles/trait.Vec3Swizzles.html: trait glam::swizzles::Vec3Swizzles - `Vec3Swizzles`\n\u27e881\u27e9 https://docs.rs/glam/latest/glam/swizzles/trait.Vec4Swizzles.html: trait glam::swizzles::Vec4Swizzles - `Vec4Swizzles`\n\u27e882\u27e9 https://docs.rs/glam/latest/glam/#simd-and-scalar-consistency: \u00a7\n\u27e883\u27e9 https://docs.rs/glam/latest/glam/#feature-gates: \u00a7\n\u27e884\u27e9 https://docs.rs/glam/latest/glam/#minimum-supported-rust-version-msrv: \u00a7\n\u27e885\u27e9 https://docs.rs/glam/latest/glam/#reexports: \u00a7\n\u27e886\u27e9 https://docs.rs/glam/latest/glam/#modules: \u00a7\n\u27e887\u27e9 https://docs.rs/glam/latest/glam/swizzles/index.html: mod glam::swizzles - swizzles\n\u27e888\u27e9 https://docs.rs/glam/latest/glam/#enums: \u00a7\n\u27e889\u27e9 https://docs.rs/glam/latest/glam/enum.EulerRot.html: enum glam::EulerRot - EulerRot\n\u27e890\u27e9 https://docs.rs/glam/latest/glam/#traits: \u00a7\n\u27e891\u27e9 https://docs.rs/glam/latest/glam/trait.FloatExt.html: trait glam::FloatExt - FloatExt\n\u27e892\u27e9 https://doc.rust-lang.org/nightly/std/primitive.f32.html: primitive f32 - `f32`\n\u27e893\u27e9 https://doc.rust-lang.org/nightly/std/primitive.f64.html: primitive f64 - `f64`\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `glam` crate is a fast and simple linear algebra library optimized for games and graphics, featuring support for vectors, matrices, quaternions, and affine transformations across various scalar types (`f32`, `f64`, integers, and booleans). It leverages SIMD for performance, offers swizzle operations for vector manipulation, and provides feature gates for customization, including serialization, approximate comparisons, and runtime assertions. Designed with consistency and efficiency, it supports both SIMD and scalar fallback implementations.",
    "feature_summary": null,
    "use_case": "Utilities",
    "score": 8.5,
    "factual_counterfactual": "### Pair 1: SIMD Optimization  \n\u2705 Factual: `glam` uses SIMD for many `f32` types, such as `Vec3A` and `Mat3A`, enabling better performance compared to scalar implementations.  \n\u274c Counterfactual: `glam` requires SIMD support on the target architecture to function correctly and does not provide scalar math fallbacks.  \n\n---\n\n### Pair 2: Affine Transformations  \n\u2705 Factual: `Affine2` and `Affine3A` in `glam` provide optimized representations for 2D and 3D affine transformations, outperforming `Mat3` and `Mat4` in operations like inversion.  \n\u274c Counterfactual: `Affine2` and `Affine3A` are slower than `Mat3` and `Mat4` for matrix inversion due to their more complex internal structure.  \n\n---\n\n### Pair 3: Vector Swizzling  \n\u2705 Factual: `glam` supports vector swizzling, allowing elements of vectors to be reordered or used to create vectors of different sizes using traits like `Vec3Swizzles`.  \n\u274c Counterfactual: Vector swizzling in `glam` is only supported for `f32` types and does not work for other numeric types like `i32` or `u64`.",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}