{
    "name": "serde_cbor",
    "version": "0.11.2",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/serde_cbor/latest/serde_cbor/all.html \"show sidebar\")\n# Crate serde_cborCopy item path\n[Settings](https://docs.rs/serde_cbor/latest/settings.html)\n[Help](https://docs.rs/serde_cbor/latest/help.html)\nSummary[Source](https://docs.rs/serde_cbor/latest/src/serde_cbor/lib.rs.html#1-369)\nExpand description\nCBOR and serialization.\n## [\u00a7](https://docs.rs/serde_cbor/latest/serde_cbor/#usage)Usage\nSerde CBOR supports Rust 1.40 and up. Add this to your `Cargo.toml`:\n```\n[dependencies]\nserde_cbor = \"0.10\"\n```\n\nStoring and loading Rust types is easy and requires only minimal modifications to the program code.\n```\nuse serde_derive::{Deserialize, Serialize};\nuse std::error::Error;\nuse std::fs::File;\n// Types annotated with `Serialize` can be stored as CBOR.\n// To be able to load them again add `Deserialize`.\n#[derive(Debug, Serialize, Deserialize)]\nstruct Mascot {\n  name: String,\n  species: String,\n  year_of_birth: u32,\n}\nfn main() -> Result<(), Box<dyn Error>> {\n  let ferris = Mascot {\n    name: \"Ferris\".to_owned(),\n    species: \"crab\".to_owned(),\n    year_of_birth: 2015,\n  };\n  let ferris_file = File::create(\"examples/ferris.cbor\")?;\n  // Write Ferris to the given file.\n  // Instead of a file you can use any type that implements `io::Write`\n  // like a HTTP body, database connection etc.\n  serde_cbor::to_writer(ferris_file, &ferris)?;\n  let tux_file = File::open(\"examples/tux.cbor\")?;\n  // Load Tux from a file.\n  // Serde CBOR performs roundtrip serialization meaning that\n  // the data will not change in any way.\n  let tux: Mascot = serde_cbor::from_reader(tux_file)?;\n  println!(\"{:?}\", tux);\n  // prints: Mascot { name: \"Tux\", species: \"penguin\", year_of_birth: 1996 }\n  Ok(())\n}\n```\n\nThere are a lot of options available to customize the format. To operate on untyped CBOR values have a look at the `Value` type.\n## [\u00a7](https://docs.rs/serde_cbor/latest/serde_cbor/#type-based-serialization-and-deserialization)Type-based Serialization and Deserialization\nSerde provides a mechanism for low boilerplate serialization & deserialization of values to and from CBOR via the serialization API. To be able to serialize a piece of data, it must implement the `serde::Serialize` trait. To be able to deserialize a piece of data, it must implement the `serde::Deserialize` trait. Serde provides an annotation to automatically generate the code for these traits: `#[derive(Serialize, Deserialize)]`.\nThe CBOR API also provides an enum `serde_cbor::Value`.\n## [\u00a7](https://docs.rs/serde_cbor/latest/serde_cbor/#packed-encoding)Packed Encoding\nWhen serializing structs or enums in CBOR the keys or enum variant names will be serialized as string keys to a map. Especially in embedded environments this can increase the file size too much. In packed encoding all struct keys, as well as any enum variant that has no data, will be serialized as variable sized integers. The first 24 entries in any struct consume only a single byte! Packed encoding uses serde\u2019s preferred [externally tagged enum format](https://serde.rs/enum-representations.html) and therefore serializes enum variant names as string keys when that variant contains data. So, in the packed encoding example, `FirstVariant` encodes to a single byte, but encoding `SecondVariant` requires 16 bytes.\nTo serialize a document in this format use `Serializer::new(writer).packed_format()` or the shorthand `ser::to_vec_packed`. The deserialization works without any changes.\nIf you would like to omit the enum variant encoding for all variants, including ones that contain data, you can add `legacy_enums()` in addition to `packed_format()`, as can seen in the Serialize using minimal encoding example.\n## [\u00a7](https://docs.rs/serde_cbor/latest/serde_cbor/#self-describing-documents)Self describing documents\nIn some contexts different formats are used but there is no way to declare the format used out of band. For this reason CBOR has a magic number that may be added before any document. Self describing documents are created with `serializer.self_describe()`.\n## [\u00a7](https://docs.rs/serde_cbor/latest/serde_cbor/#examples)Examples\nRead a CBOR value that is known to be a map of string keys to string values and print it.\n```\nuse std::collections::BTreeMap;\nuse serde_cbor::from_slice;\nlet slice = b\"\\xa5aaaAabaBacaCadaDaeaE\";\nlet value: BTreeMap<String, String> = from_slice(slice).unwrap();\nprintln!(\"{:?}\", value); // {\"e\": \"E\", \"d\": \"D\", \"a\": \"A\", \"c\": \"C\", \"b\": \"B\"}\n```\n\nRead a general CBOR value with an unknown content.\n```\nuse serde_cbor::from_slice;\nuse serde_cbor::value::Value;\nlet slice = b\"\\x82\\x01\\xa1aaab\";\nlet value: Value = from_slice(slice).unwrap();\nprintln!(\"{:?}\", value); // Array([U64(1), Object({String(\"a\"): String(\"b\")})])\n```\n\nSerialize an object.\n```\nuse std::collections::BTreeMap;\nuse serde_cbor::to_vec;\nlet mut programming_languages = BTreeMap::new();\nprogramming_languages.insert(\"rust\", vec![\"safe\", \"concurrent\", \"fast\"]);\nprogramming_languages.insert(\"python\", vec![\"powerful\", \"friendly\", \"open\"]);\nprogramming_languages.insert(\"js\", vec![\"lightweight\", \"interpreted\", \"object-oriented\"]);\nlet encoded = to_vec(&programming_languages);\nassert_eq!(encoded.unwrap().len(), 103);\n```\n\nDeserializing data in the middle of a slice\n```\nuse serde_cbor::Deserializer;\nlet data: Vec<u8> = vec![\n  0x66, 0x66, 0x6f, 0x6f, 0x62, 0x61, 0x72, 0x66, 0x66, 0x6f, 0x6f, 0x62,\n  0x61, 0x72,\n];\nlet mut deserializer = Deserializer::from_slice(&data);\nlet value: &str = serde::de::Deserialize::deserialize(&mut deserializer)\n  .unwrap();\nlet rest = &data[deserializer.byte_offset()..];\nassert_eq!(value, \"foobar\");\nassert_eq!(rest, &[0x66, 0x66, 0x6f, 0x6f, 0x62, 0x61, 0x72]);\n```\n\nSerialize using packed encoding\n```\nuse serde_derive::{Deserialize, Serialize};\nuse serde_cbor::ser::to_vec_packed;\nuse WithTwoVariants::*;\n#[derive(Debug, Serialize, Deserialize)]\nenum WithTwoVariants {\n  FirstVariant,\n  SecondVariant(u8),\n}\nlet cbor = to_vec_packed(&FirstVariant).unwrap();\nassert_eq!(cbor.len(), 1);\nlet cbor = to_vec_packed(&SecondVariant(0)).unwrap();\nassert_eq!(cbor.len(), 16); // Includes 13 bytes of \"SecondVariant\"\n```\n\nSerialize using minimal encoding\n```\nuse serde_derive::{Deserialize, Serialize};\nuse serde_cbor::{Result, Serializer, ser::{self, IoWrite}};\nuse WithTwoVariants::*;\nfn to_vec_minimal<T>(value: &T) -> Result<Vec<u8>>\nwhere\n  T: serde::Serialize,\n{\n  let mut vec = Vec::new();\n  value.serialize(&mut Serializer::new(&mut IoWrite::new(&mut vec)).packed_format().legacy_enums())?;\n  Ok(vec)\n}\n#[derive(Debug, Serialize, Deserialize)]\nenum WithTwoVariants {\n  FirstVariant,\n  SecondVariant(u8),\n}\nlet cbor = to_vec_minimal(&FirstVariant).unwrap();\nassert_eq!(cbor.len(), 1);\nlet cbor = to_vec_minimal(&SecondVariant(0)).unwrap();\nassert_eq!(cbor.len(), 3);\n```\n\n## [\u00a7](https://docs.rs/serde_cbor/latest/serde_cbor/#no-std-support)`no-std` support\nSerde CBOR supports building in a `no_std` context, use the following lines in your `Cargo.toml` dependencies:\n```\n[dependencies]\nserde = { version = \"1.0\", default-features = false }\nserde_cbor = { version = \"0.10\", default-features = false }\n```\n\nWithout the `std` feature the functions [from_reader](https://docs.rs/serde_cbor/latest/serde_cbor/fn.from_reader.html \"fn serde_cbor::from_reader\"), [from_slice](https://docs.rs/serde_cbor/latest/serde_cbor/fn.from_slice.html \"fn serde_cbor::from_slice\"), [to_vec](https://docs.rs/serde_cbor/latest/serde_cbor/fn.to_vec.html \"fn serde_cbor::to_vec\"), and [to_writer](https://docs.rs/serde_cbor/latest/serde_cbor/fn.to_writer.html \"fn serde_cbor::to_writer\") are not exported. To export [from_slice](https://docs.rs/serde_cbor/latest/serde_cbor/fn.from_slice.html \"fn serde_cbor::from_slice\") and [to_vec](https://docs.rs/serde_cbor/latest/serde_cbor/fn.to_vec.html \"fn serde_cbor::to_vec\") enable the `alloc` feature. The `alloc` feature uses the [`alloc` library](https://doc.rust-lang.org/alloc/) and requires at least version 1.36.0 of Rust.\n_Note_ : to use derive macros in serde you will need to declare `serde` dependency like so:\n```\nserde = { version = \"1.0\", default-features = false, features = [\"derive\"] }\n```\n\nSerialize an object with `no_std` and without `alloc`.\n```\nuse serde::Serialize;\nuse serde_cbor::Serializer;\nuse serde_cbor::ser::SliceWrite;\n#[derive(Serialize)]\nstruct User {\n  user_id: u32,\n  password_hash: [u8; 4],\n}\nlet mut buf = [0u8; 100];\nlet writer = SliceWrite::new(&mut buf[..]);\nlet mut ser = Serializer::new(writer);\nlet user = User {\n  user_id: 42,\n  password_hash: [1, 2, 3, 4],\n};\nuser.serialize(&mut ser)?;\nlet writer = ser.into_inner();\nlet size = writer.bytes_written();\nlet expected = [\n  0xa2, 0x67, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x2a, 0x6d,\n  0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x5f, 0x68, 0x61, 0x73,\n  0x68, 0x84, 0x1, 0x2, 0x3, 0x4\n];\nassert_eq!(&buf[..size], expected);\n```\n\nDeserialize an object.\n```\n#[derive(Debug, PartialEq, Deserialize)]\nstruct User {\n  user_id: u32,\n  password_hash: [u8; 4],\n}\nlet value = [\n  0xa2, 0x67, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x2a, 0x6d,\n  0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x5f, 0x68, 0x61, 0x73,\n  0x68, 0x84, 0x1, 0x2, 0x3, 0x4\n];\n// from_slice_with_scratch will not alter input data, use it whenever you\n// borrow from somewhere else.\n// You will have to size your scratch according to the input data you\n// expect.\nuse serde_cbor::de::from_slice_with_scratch;\nlet mut scratch = [0u8; 32];\nlet user: User = from_slice_with_scratch(&value[..], &mut scratch)?;\nassert_eq!(user, User {\n  user_id: 42,\n  password_hash: [1, 2, 3, 4],\n});\nlet mut value = [\n  0xa2, 0x67, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x2a, 0x6d,\n  0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x5f, 0x68, 0x61, 0x73,\n  0x68, 0x84, 0x1, 0x2, 0x3, 0x4\n];\n// from_mut_slice will move data around the input slice, you may only use it\n// on data you may own or can modify.\nuse serde_cbor::de::from_mut_slice;\nlet user: User = from_mut_slice(&mut value[..])?;\nassert_eq!(user, User {\n  user_id: 42,\n  password_hash: [1, 2, 3, 4],\n});\n```\n\n## [\u00a7](https://docs.rs/serde_cbor/latest/serde_cbor/#limitations)Limitations\nWhile Serde CBOR strives to support all features of Serde and CBOR there are a few limitations.\n  * [Tags](https://tools.ietf.org/html/rfc7049#section-2.4.4) are ignored during deserialization and can\u2019t be emitted during serialization. This is because Serde has no concept of tagged values. See: [#3](https://github.com/pyfisch/cbor/issues/3)\n  * Unknown [simple values](https://tools.ietf.org/html/rfc7049#section-3.5) cause an `UnassignedCode` error. The simple values _False_ and _True_ are recognized and parsed as bool. _Null_ and _Undefined_ are both deserialized as _unit_. The _unit_ type is serialized as _Null_. See: [#86](https://github.com/pyfisch/cbor/issues/86)\n  * [128-bit integers](https://doc.rust-lang.org/std/primitive.u128.html) can\u2019t be directly encoded in CBOR. If you need them store them as a byte string. See: [#77](https://github.com/pyfisch/cbor/issues/77)\n\n\n## Modules[\u00a7](https://docs.rs/serde_cbor/latest/serde_cbor/#modules)\n\n[de](https://docs.rs/serde_cbor/latest/serde_cbor/de/index.html \"mod serde_cbor::de\")\n    Deserialization.\n\n[error](https://docs.rs/serde_cbor/latest/serde_cbor/error/index.html \"mod serde_cbor::error\")\n    When serializing or deserializing CBOR goes wrong.\n\n[ser](https://docs.rs/serde_cbor/latest/serde_cbor/ser/index.html \"mod serde_cbor::ser\")\n    Serialize a Rust data structure to CBOR data.\n\n[tags](https://docs.rs/serde_cbor/latest/serde_cbor/tags/index.html \"mod serde_cbor::tags\")\n    Support for cbor tags\n\n[value](https://docs.rs/serde_cbor/latest/serde_cbor/value/index.html \"mod serde_cbor::value\")\n    CBOR values, keys and serialization routines.\n## Structs[\u00a7](https://docs.rs/serde_cbor/latest/serde_cbor/#structs)\n\n[Deserializer](https://docs.rs/serde_cbor/latest/serde_cbor/struct.Deserializer.html \"struct serde_cbor::Deserializer\")\n    A Serde `Deserialize`r of CBOR data.\n\n[Error](https://docs.rs/serde_cbor/latest/serde_cbor/struct.Error.html \"struct serde_cbor::Error\")\n    This type represents all possible errors that can occur when serializing or deserializing CBOR data.\n\n[Serializer](https://docs.rs/serde_cbor/latest/serde_cbor/struct.Serializer.html \"struct serde_cbor::Serializer\")\n    A structure for serializing Rust values to CBOR.\n\n[StreamDeserializer](https://docs.rs/serde_cbor/latest/serde_cbor/struct.StreamDeserializer.html \"struct serde_cbor::StreamDeserializer\")\n    Iterator that deserializes a stream into multiple CBOR values.\n## Enums[\u00a7](https://docs.rs/serde_cbor/latest/serde_cbor/#enums)\n\n[Value](https://docs.rs/serde_cbor/latest/serde_cbor/enum.Value.html \"enum serde_cbor::Value\")\n    The `Value` enum, a loosely typed way of representing any valid CBOR value.\n## Functions[\u00a7](https://docs.rs/serde_cbor/latest/serde_cbor/#functions)\n\n[from_reader](https://docs.rs/serde_cbor/latest/serde_cbor/fn.from_reader.html \"fn serde_cbor::from_reader\")\n    Decodes a value from CBOR data in a reader.\n\n[from_slice](https://docs.rs/serde_cbor/latest/serde_cbor/fn.from_slice.html \"fn serde_cbor::from_slice\")\n    Decodes a value from CBOR data in a slice.\n\n[to_vec](https://docs.rs/serde_cbor/latest/serde_cbor/fn.to_vec.html \"fn serde_cbor::to_vec\")\n    Serializes a value to a vector.\n\n[to_writer](https://docs.rs/serde_cbor/latest/serde_cbor/fn.to_writer.html \"fn serde_cbor::to_writer\")\n    Serializes a value to a writer.\n## Type Aliases[\u00a7](https://docs.rs/serde_cbor/latest/serde_cbor/#types)\n\n[Result](https://docs.rs/serde_cbor/latest/serde_cbor/type.Result.html \"type serde_cbor::Result\")\n    Alias for a `Result` with the error type `serde_cbor::Error`.\n",
        "markdown_with_citations": "[](https://docs.rs/serde_cbor/latest/serde_cbor/all.html \"show sidebar\")\n# Crate serde_cborCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nCBOR and serialization.\n## \u00a7\u27e84\u27e9Usage\nSerde CBOR supports Rust 1.40 and up. Add this to your `Cargo.toml`:\n```\n[dependencies]\nserde_cbor = \"0.10\"\n```\n\nStoring and loading Rust types is easy and requires only minimal modifications to the program code.\n```\nuse serde_derive::{Deserialize, Serialize};\nuse std::error::Error;\nuse std::fs::File;\n// Types annotated with `Serialize` can be stored as CBOR.\n// To be able to load them again add `Deserialize`.\n#[derive(Debug, Serialize, Deserialize)]\nstruct Mascot {\n  name: String,\n  species: String,\n  year_of_birth: u32,\n}\nfn main() -> Result<(), Box<dyn Error>> {\n  let ferris = Mascot {\n    name: \"Ferris\".to_owned(),\n    species: \"crab\".to_owned(),\n    year_of_birth: 2015,\n  };\n  let ferris_file = File::create(\"examples/ferris.cbor\")?;\n  // Write Ferris to the given file.\n  // Instead of a file you can use any type that implements `io::Write`\n  // like a HTTP body, database connection etc.\n  serde_cbor::to_writer(ferris_file, &ferris)?;\n  let tux_file = File::open(\"examples/tux.cbor\")?;\n  // Load Tux from a file.\n  // Serde CBOR performs roundtrip serialization meaning that\n  // the data will not change in any way.\n  let tux: Mascot = serde_cbor::from_reader(tux_file)?;\n  println!(\"{:?}\", tux);\n  // prints: Mascot { name: \"Tux\", species: \"penguin\", year_of_birth: 1996 }\n  Ok(())\n}\n```\n\nThere are a lot of options available to customize the format. To operate on untyped CBOR values have a look at the `Value` type.\n## \u00a7\u27e85\u27e9Type-based Serialization and Deserialization\nSerde provides a mechanism for low boilerplate serialization & deserialization of values to and from CBOR via the serialization API. To be able to serialize a piece of data, it must implement the `serde::Serialize` trait. To be able to deserialize a piece of data, it must implement the `serde::Deserialize` trait. Serde provides an annotation to automatically generate the code for these traits: `#[derive(Serialize, Deserialize)]`.\nThe CBOR API also provides an enum `serde_cbor::Value`.\n## \u00a7\u27e86\u27e9Packed Encoding\nWhen serializing structs or enums in CBOR the keys or enum variant names will be serialized as string keys to a map. Especially in embedded environments this can increase the file size too much. In packed encoding all struct keys, as well as any enum variant that has no data, will be serialized as variable sized integers. The first 24 entries in any struct consume only a single byte! Packed encoding uses serde\u2019s preferred externally tagged enum format\u27e87\u27e9 and therefore serializes enum variant names as string keys when that variant contains data. So, in the packed encoding example, `FirstVariant` encodes to a single byte, but encoding `SecondVariant` requires 16 bytes.\nTo serialize a document in this format use `Serializer::new(writer).packed_format()` or the shorthand `ser::to_vec_packed`. The deserialization works without any changes.\nIf you would like to omit the enum variant encoding for all variants, including ones that contain data, you can add `legacy_enums()` in addition to `packed_format()`, as can seen in the Serialize using minimal encoding example.\n## \u00a7\u27e88\u27e9Self describing documents\nIn some contexts different formats are used but there is no way to declare the format used out of band. For this reason CBOR has a magic number that may be added before any document. Self describing documents are created with `serializer.self_describe()`.\n## \u00a7\u27e89\u27e9Examples\nRead a CBOR value that is known to be a map of string keys to string values and print it.\n```\nuse std::collections::BTreeMap;\nuse serde_cbor::from_slice;\nlet slice = b\"\\xa5aaaAabaBacaCadaDaeaE\";\nlet value: BTreeMap<String, String> = from_slice(slice).unwrap();\nprintln!(\"{:?}\", value); // {\"e\": \"E\", \"d\": \"D\", \"a\": \"A\", \"c\": \"C\", \"b\": \"B\"}\n```\n\nRead a general CBOR value with an unknown content.\n```\nuse serde_cbor::from_slice;\nuse serde_cbor::value::Value;\nlet slice = b\"\\x82\\x01\\xa1aaab\";\nlet value: Value = from_slice(slice).unwrap();\nprintln!(\"{:?}\", value); // Array([U64(1), Object({String(\"a\"): String(\"b\")})])\n```\n\nSerialize an object.\n```\nuse std::collections::BTreeMap;\nuse serde_cbor::to_vec;\nlet mut programming_languages = BTreeMap::new();\nprogramming_languages.insert(\"rust\", vec![\"safe\", \"concurrent\", \"fast\"]);\nprogramming_languages.insert(\"python\", vec![\"powerful\", \"friendly\", \"open\"]);\nprogramming_languages.insert(\"js\", vec![\"lightweight\", \"interpreted\", \"object-oriented\"]);\nlet encoded = to_vec(&programming_languages);\nassert_eq!(encoded.unwrap().len(), 103);\n```\n\nDeserializing data in the middle of a slice\n```\nuse serde_cbor::Deserializer;\nlet data: Vec<u8> = vec![\n  0x66, 0x66, 0x6f, 0x6f, 0x62, 0x61, 0x72, 0x66, 0x66, 0x6f, 0x6f, 0x62,\n  0x61, 0x72,\n];\nlet mut deserializer = Deserializer::from_slice(&data);\nlet value: &str = serde::de::Deserialize::deserialize(&mut deserializer)\n  .unwrap();\nlet rest = &data[deserializer.byte_offset()..];\nassert_eq!(value, \"foobar\");\nassert_eq!(rest, &[0x66, 0x66, 0x6f, 0x6f, 0x62, 0x61, 0x72]);\n```\n\nSerialize using packed encoding\n```\nuse serde_derive::{Deserialize, Serialize};\nuse serde_cbor::ser::to_vec_packed;\nuse WithTwoVariants::*;\n#[derive(Debug, Serialize, Deserialize)]\nenum WithTwoVariants {\n  FirstVariant,\n  SecondVariant(u8),\n}\nlet cbor = to_vec_packed(&FirstVariant).unwrap();\nassert_eq!(cbor.len(), 1);\nlet cbor = to_vec_packed(&SecondVariant(0)).unwrap();\nassert_eq!(cbor.len(), 16); // Includes 13 bytes of \"SecondVariant\"\n```\n\nSerialize using minimal encoding\n```\nuse serde_derive::{Deserialize, Serialize};\nuse serde_cbor::{Result, Serializer, ser::{self, IoWrite}};\nuse WithTwoVariants::*;\nfn to_vec_minimal<T>(value: &T) -> Result<Vec<u8>>\nwhere\n  T: serde::Serialize,\n{\n  let mut vec = Vec::new();\n  value.serialize(&mut Serializer::new(&mut IoWrite::new(&mut vec)).packed_format().legacy_enums())?;\n  Ok(vec)\n}\n#[derive(Debug, Serialize, Deserialize)]\nenum WithTwoVariants {\n  FirstVariant,\n  SecondVariant(u8),\n}\nlet cbor = to_vec_minimal(&FirstVariant).unwrap();\nassert_eq!(cbor.len(), 1);\nlet cbor = to_vec_minimal(&SecondVariant(0)).unwrap();\nassert_eq!(cbor.len(), 3);\n```\n\n## \u00a7\u27e810\u27e9`no-std` support\nSerde CBOR supports building in a `no_std` context, use the following lines in your `Cargo.toml` dependencies:\n```\n[dependencies]\nserde = { version = \"1.0\", default-features = false }\nserde_cbor = { version = \"0.10\", default-features = false }\n```\n\nWithout the `std` feature the functions from_reader\u27e811\u27e9, from_slice\u27e812\u27e9, to_vec\u27e813\u27e9, and to_writer\u27e814\u27e9 are not exported. To export from_slice\u27e812\u27e9 and to_vec\u27e813\u27e9 enable the `alloc` feature. The `alloc` feature uses the `alloc` library\u27e815\u27e9 and requires at least version 1.36.0 of Rust.\n_Note_ : to use derive macros in serde you will need to declare `serde` dependency like so:\n```\nserde = { version = \"1.0\", default-features = false, features = [\"derive\"] }\n```\n\nSerialize an object with `no_std` and without `alloc`.\n```\nuse serde::Serialize;\nuse serde_cbor::Serializer;\nuse serde_cbor::ser::SliceWrite;\n#[derive(Serialize)]\nstruct User {\n  user_id: u32,\n  password_hash: [u8; 4],\n}\nlet mut buf = [0u8; 100];\nlet writer = SliceWrite::new(&mut buf[..]);\nlet mut ser = Serializer::new(writer);\nlet user = User {\n  user_id: 42,\n  password_hash: [1, 2, 3, 4],\n};\nuser.serialize(&mut ser)?;\nlet writer = ser.into_inner();\nlet size = writer.bytes_written();\nlet expected = [\n  0xa2, 0x67, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x2a, 0x6d,\n  0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x5f, 0x68, 0x61, 0x73,\n  0x68, 0x84, 0x1, 0x2, 0x3, 0x4\n];\nassert_eq!(&buf[..size], expected);\n```\n\nDeserialize an object.\n```\n#[derive(Debug, PartialEq, Deserialize)]\nstruct User {\n  user_id: u32,\n  password_hash: [u8; 4],\n}\nlet value = [\n  0xa2, 0x67, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x2a, 0x6d,\n  0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x5f, 0x68, 0x61, 0x73,\n  0x68, 0x84, 0x1, 0x2, 0x3, 0x4\n];\n// from_slice_with_scratch will not alter input data, use it whenever you\n// borrow from somewhere else.\n// You will have to size your scratch according to the input data you\n// expect.\nuse serde_cbor::de::from_slice_with_scratch;\nlet mut scratch = [0u8; 32];\nlet user: User = from_slice_with_scratch(&value[..], &mut scratch)?;\nassert_eq!(user, User {\n  user_id: 42,\n  password_hash: [1, 2, 3, 4],\n});\nlet mut value = [\n  0xa2, 0x67, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x2a, 0x6d,\n  0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x5f, 0x68, 0x61, 0x73,\n  0x68, 0x84, 0x1, 0x2, 0x3, 0x4\n];\n// from_mut_slice will move data around the input slice, you may only use it\n// on data you may own or can modify.\nuse serde_cbor::de::from_mut_slice;\nlet user: User = from_mut_slice(&mut value[..])?;\nassert_eq!(user, User {\n  user_id: 42,\n  password_hash: [1, 2, 3, 4],\n});\n```\n\n## \u00a7\u27e816\u27e9Limitations\nWhile Serde CBOR strives to support all features of Serde and CBOR there are a few limitations.\n  * Tags\u27e817\u27e9 are ignored during deserialization and can\u2019t be emitted during serialization. This is because Serde has no concept of tagged values. See: #3\u27e818\u27e9\n  * Unknown simple values\u27e819\u27e9 cause an `UnassignedCode` error. The simple values _False_ and _True_ are recognized and parsed as bool. _Null_ and _Undefined_ are both deserialized as _unit_. The _unit_ type is serialized as _Null_. See: #86\u27e820\u27e9\n  * 128-bit integers\u27e821\u27e9 can\u2019t be directly encoded in CBOR. If you need them store them as a byte string. See: #77\u27e822\u27e9\n\n\n## Modules\u00a7\u27e823\u27e9\n\nde\u27e824\u27e9\n    Deserialization.\n\nerror\u27e825\u27e9\n    When serializing or deserializing CBOR goes wrong.\n\nser\u27e826\u27e9\n    Serialize a Rust data structure to CBOR data.\n\ntags\u27e827\u27e9\n    Support for cbor tags\n\nvalue\u27e828\u27e9\n    CBOR values, keys and serialization routines.\n## Structs\u00a7\u27e829\u27e9\n\nDeserializer\u27e830\u27e9\n    A Serde `Deserialize`r of CBOR data.\n\nError\u27e831\u27e9\n    This type represents all possible errors that can occur when serializing or deserializing CBOR data.\n\nSerializer\u27e832\u27e9\n    A structure for serializing Rust values to CBOR.\n\nStreamDeserializer\u27e833\u27e9\n    Iterator that deserializes a stream into multiple CBOR values.\n## Enums\u00a7\u27e834\u27e9\n\nValue\u27e835\u27e9\n    The `Value` enum, a loosely typed way of representing any valid CBOR value.\n## Functions\u00a7\u27e836\u27e9\n\nfrom_reader\u27e811\u27e9\n    Decodes a value from CBOR data in a reader.\n\nfrom_slice\u27e812\u27e9\n    Decodes a value from CBOR data in a slice.\n\nto_vec\u27e813\u27e9\n    Serializes a value to a vector.\n\nto_writer\u27e814\u27e9\n    Serializes a value to a writer.\n## Type Aliases\u00a7\u27e837\u27e9\n\nResult\u27e838\u27e9\n    Alias for a `Result` with the error type `serde_cbor::Error`.\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/serde_cbor/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/serde_cbor/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/serde_cbor/latest/src/serde_cbor/lib.rs.html#1-369: Source\n\u27e84\u27e9 https://docs.rs/serde_cbor/latest/serde_cbor/#usage: \u00a7\n\u27e85\u27e9 https://docs.rs/serde_cbor/latest/serde_cbor/#type-based-serialization-and-deserialization: \u00a7\n\u27e86\u27e9 https://docs.rs/serde_cbor/latest/serde_cbor/#packed-encoding: \u00a7\n\u27e87\u27e9 https://serde.rs/enum-representations.html: externally tagged enum format\n\u27e88\u27e9 https://docs.rs/serde_cbor/latest/serde_cbor/#self-describing-documents: \u00a7\n\u27e89\u27e9 https://docs.rs/serde_cbor/latest/serde_cbor/#examples: \u00a7\n\u27e810\u27e9 https://docs.rs/serde_cbor/latest/serde_cbor/#no-std-support: \u00a7\n\u27e811\u27e9 https://docs.rs/serde_cbor/latest/serde_cbor/fn.from_reader.html: fn serde_cbor::from_reader - from_reader\n\u27e812\u27e9 https://docs.rs/serde_cbor/latest/serde_cbor/fn.from_slice.html: fn serde_cbor::from_slice - from_slice\n\u27e813\u27e9 https://docs.rs/serde_cbor/latest/serde_cbor/fn.to_vec.html: fn serde_cbor::to_vec - to_vec\n\u27e814\u27e9 https://docs.rs/serde_cbor/latest/serde_cbor/fn.to_writer.html: fn serde_cbor::to_writer - to_writer\n\u27e815\u27e9 https://doc.rust-lang.org/alloc/: `alloc` library\n\u27e816\u27e9 https://docs.rs/serde_cbor/latest/serde_cbor/#limitations: \u00a7\n\u27e817\u27e9 https://tools.ietf.org/html/rfc7049#section-2.4.4: Tags\n\u27e818\u27e9 https://github.com/pyfisch/cbor/issues/3: #3\n\u27e819\u27e9 https://tools.ietf.org/html/rfc7049#section-3.5: simple values\n\u27e820\u27e9 https://github.com/pyfisch/cbor/issues/86: #86\n\u27e821\u27e9 https://doc.rust-lang.org/std/primitive.u128.html: 128-bit integers\n\u27e822\u27e9 https://github.com/pyfisch/cbor/issues/77: #77\n\u27e823\u27e9 https://docs.rs/serde_cbor/latest/serde_cbor/#modules: \u00a7\n\u27e824\u27e9 https://docs.rs/serde_cbor/latest/serde_cbor/de/index.html: mod serde_cbor::de - de\n\u27e825\u27e9 https://docs.rs/serde_cbor/latest/serde_cbor/error/index.html: mod serde_cbor::error - error\n\u27e826\u27e9 https://docs.rs/serde_cbor/latest/serde_cbor/ser/index.html: mod serde_cbor::ser - ser\n\u27e827\u27e9 https://docs.rs/serde_cbor/latest/serde_cbor/tags/index.html: mod serde_cbor::tags - tags\n\u27e828\u27e9 https://docs.rs/serde_cbor/latest/serde_cbor/value/index.html: mod serde_cbor::value - value\n\u27e829\u27e9 https://docs.rs/serde_cbor/latest/serde_cbor/#structs: \u00a7\n\u27e830\u27e9 https://docs.rs/serde_cbor/latest/serde_cbor/struct.Deserializer.html: struct serde_cbor::Deserializer - Deserializer\n\u27e831\u27e9 https://docs.rs/serde_cbor/latest/serde_cbor/struct.Error.html: struct serde_cbor::Error - Error\n\u27e832\u27e9 https://docs.rs/serde_cbor/latest/serde_cbor/struct.Serializer.html: struct serde_cbor::Serializer - Serializer\n\u27e833\u27e9 https://docs.rs/serde_cbor/latest/serde_cbor/struct.StreamDeserializer.html: struct serde_cbor::StreamDeserializer - StreamDeserializer\n\u27e834\u27e9 https://docs.rs/serde_cbor/latest/serde_cbor/#enums: \u00a7\n\u27e835\u27e9 https://docs.rs/serde_cbor/latest/serde_cbor/enum.Value.html: enum serde_cbor::Value - Value\n\u27e836\u27e9 https://docs.rs/serde_cbor/latest/serde_cbor/#functions: \u00a7\n\u27e837\u27e9 https://docs.rs/serde_cbor/latest/serde_cbor/#types: \u00a7\n\u27e838\u27e9 https://docs.rs/serde_cbor/latest/serde_cbor/type.Result.html: type serde_cbor::Result - Result\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `serde_cbor` crate provides efficient serialization and deserialization of Rust data structures to and from the CBOR (Concise Binary Object Representation) format. It supports type-based serialization with `#[derive(Serialize, Deserialize)]`, packed encoding for reduced file size, self-describing documents, and `no-std` environments. Additionally, it offers customization options, a loosely-typed `Value` enum for untyped CBOR data, and handles embedded use cases effectively.",
    "feature_summary": null,
    "use_case": "Serialization",
    "score": 8.0,
    "factual_counterfactual": "### Pair 1: Serialization and Deserialization  \n\u2705 Factual: Serde CBOR supports roundtrip serialization, ensuring that serialized data retains its original structure and values when deserialized.  \n\u274c Counterfactual: Serde CBOR modifies the structure of serialized data during roundtrip serialization, making it incompatible with the original format.  \n\n---\n\n### Pair 2: Packed Encoding Efficiency  \n\u2705 Factual: Packed encoding in Serde CBOR reduces the size of serialized data by using variable-sized integers for struct keys and enum variants, with the first 24 entries consuming only a single byte.  \n\u274c Counterfactual: Packed encoding in Serde CBOR increases the size of serialized data by converting all keys and enum variants into fixed-length strings.  \n\n---\n\n### Pair 3: `no-std` Support  \n\u2705 Factual: Serde CBOR supports `no-std` environments by disabling the `std` feature and optionally enabling the `alloc` feature for functions like `from_slice` and `to_vec`.  \n\u274c Counterfactual: Serde CBOR requires the `std` feature to be enabled and cannot be used in `no-std` environments.",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}