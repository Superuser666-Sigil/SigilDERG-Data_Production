{
    "name": "siphasher",
    "version": "1.0.1",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/siphasher/latest/siphasher/all.html \"show sidebar\")\n# Crate siphasherCopy item path\n[Settings](https://docs.rs/siphasher/latest/settings.html)\n[Help](https://docs.rs/siphasher/latest/help.html)\nSummary[Source](https://docs.rs/siphasher/latest/src/siphasher/lib.rs.html#1-30)\nExpand description\n## [\u00a7](https://docs.rs/siphasher/latest/siphasher/#siphash-implementation-for-rust)SipHash implementation for Rust\nThis crates implements SipHash-2-4 and SipHash-1-3 in Rust.\nIt is based on the original implementation from rust-core and exposes the same API.\nIt also implements SipHash variants returning 128-bit tags.\nThe `sip` module implements the standard 64-bit mode, whereas the `sip128` module implements the 128-bit mode.\n### [\u00a7](https://docs.rs/siphasher/latest/siphasher/#usage)Usage\nIn `Cargo.toml`:\n```\n[dependencies]\nsiphasher = \"1\"\n```\n\nIf you want [serde](https://github.com/serde-rs/serde) support, include the feature like this:\n```\n[dependencies]\nsiphasher = { version = \"1\", features = [\"serde\"] }\n```\n\n64-bit mode:\n```\nuse siphasher::sip::{SipHasher, SipHasher13, SipHasher24};\n// one-shot:\nlet array: &[u8] = &[1, 2, 3];\nlet key: &[u8; 16] = &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16];\nlet hasher = SipHasher13::new_with_key(key);\nlet h = hasher.hash(array);\n// incremental:\nuse core::hash::Hasher;\nlet array1: &[u8] = &[1, 2, 3];\nlet array2: &[u8] = &[4, 5, 6];\nlet key: &[u8; 16] = &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16];\nlet mut hasher = SipHasher13::new_with_key(key);\nhasher.write(array1);\nhasher.write(array2);\nlet h = hasher.finish();\n```\n\n128-bit mode:\n```\nuse siphasher::sip128::{Hasher128, SipHasher, SipHasher13, SipHasher24};\n// one-shot:\nlet array: &[u8] = &[1, 2, 3];\nlet key: &[u8; 16] = &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16];\nlet hasher = SipHasher13::new_with_key(key);\nlet h = hasher.hash(array).as_bytes();\n// incremental:\nuse core::hash::Hasher;\nlet array1: &[u8] = &[1, 2, 3];\nlet array2: &[u8] = &[4, 5, 6];\nlet key: &[u8; 16] = &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16];\nlet mut hasher = SipHasher13::new_with_key(key);\nhasher.write(array1);\nhasher.write(array2);\nlet h = hasher.finish128().as_bytes();\n```\n\n### [\u00a7](https://docs.rs/siphasher/latest/siphasher/#api-documentation)[API documentation](https://docs.rs/siphasher/)\n### [\u00a7](https://docs.rs/siphasher/latest/siphasher/#note)Note\nDue to a confusing and not well documented API, methods from the `Hasher` trait of the standard library (`std::hash::Hasher`, `core::hash::Hasher`) produce non-portable results.\nThis is not specific to SipHash, and affects all hash functions.\nThe only safe methods in that trait are `write()` and `finish()`.\nIt is thus recommended to use SipHash (and all other hash functions, actually) as documented above.\n## Modules[\u00a7](https://docs.rs/siphasher/latest/siphasher/#modules)\n\n[prelude](https://docs.rs/siphasher/latest/siphasher/prelude/index.html \"mod siphasher::prelude\")\n\n\n[sip](https://docs.rs/siphasher/latest/siphasher/sip/index.html \"mod siphasher::sip\")\n    An implementation of SipHash.\n\n[sip128](https://docs.rs/siphasher/latest/siphasher/sip128/index.html \"mod siphasher::sip128\")\n    An implementation of SipHash with a 128-bit output.\n",
        "markdown_with_citations": "[](https://docs.rs/siphasher/latest/siphasher/all.html \"show sidebar\")\n# Crate siphasherCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\n## \u00a7\u27e84\u27e9SipHash implementation for Rust\nThis crates implements SipHash-2-4 and SipHash-1-3 in Rust.\nIt is based on the original implementation from rust-core and exposes the same API.\nIt also implements SipHash variants returning 128-bit tags.\nThe `sip` module implements the standard 64-bit mode, whereas the `sip128` module implements the 128-bit mode.\n### \u00a7\u27e85\u27e9Usage\nIn `Cargo.toml`:\n```\n[dependencies]\nsiphasher = \"1\"\n```\n\nIf you want serde\u27e86\u27e9 support, include the feature like this:\n```\n[dependencies]\nsiphasher = { version = \"1\", features = [\"serde\"] }\n```\n\n64-bit mode:\n```\nuse siphasher::sip::{SipHasher, SipHasher13, SipHasher24};\n// one-shot:\nlet array: &[u8] = &[1, 2, 3];\nlet key: &[u8; 16] = &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16];\nlet hasher = SipHasher13::new_with_key(key);\nlet h = hasher.hash(array);\n// incremental:\nuse core::hash::Hasher;\nlet array1: &[u8] = &[1, 2, 3];\nlet array2: &[u8] = &[4, 5, 6];\nlet key: &[u8; 16] = &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16];\nlet mut hasher = SipHasher13::new_with_key(key);\nhasher.write(array1);\nhasher.write(array2);\nlet h = hasher.finish();\n```\n\n128-bit mode:\n```\nuse siphasher::sip128::{Hasher128, SipHasher, SipHasher13, SipHasher24};\n// one-shot:\nlet array: &[u8] = &[1, 2, 3];\nlet key: &[u8; 16] = &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16];\nlet hasher = SipHasher13::new_with_key(key);\nlet h = hasher.hash(array).as_bytes();\n// incremental:\nuse core::hash::Hasher;\nlet array1: &[u8] = &[1, 2, 3];\nlet array2: &[u8] = &[4, 5, 6];\nlet key: &[u8; 16] = &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16];\nlet mut hasher = SipHasher13::new_with_key(key);\nhasher.write(array1);\nhasher.write(array2);\nlet h = hasher.finish128().as_bytes();\n```\n\n### \u00a7\u27e87\u27e9API documentation\u27e88\u27e9\n### \u00a7\u27e89\u27e9Note\nDue to a confusing and not well documented API, methods from the `Hasher` trait of the standard library (`std::hash::Hasher`, `core::hash::Hasher`) produce non-portable results.\nThis is not specific to SipHash, and affects all hash functions.\nThe only safe methods in that trait are `write()` and `finish()`.\nIt is thus recommended to use SipHash (and all other hash functions, actually) as documented above.\n## Modules\u00a7\u27e810\u27e9\n\nprelude\u27e811\u27e9\n\n\nsip\u27e812\u27e9\n    An implementation of SipHash.\n\nsip128\u27e813\u27e9\n    An implementation of SipHash with a 128-bit output.\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/siphasher/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/siphasher/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/siphasher/latest/src/siphasher/lib.rs.html#1-30: Source\n\u27e84\u27e9 https://docs.rs/siphasher/latest/siphasher/#siphash-implementation-for-rust: \u00a7\n\u27e85\u27e9 https://docs.rs/siphasher/latest/siphasher/#usage: \u00a7\n\u27e86\u27e9 https://github.com/serde-rs/serde: serde\n\u27e87\u27e9 https://docs.rs/siphasher/latest/siphasher/#api-documentation: \u00a7\n\u27e88\u27e9 https://docs.rs/siphasher/: API documentation\n\u27e89\u27e9 https://docs.rs/siphasher/latest/siphasher/#note: \u00a7\n\u27e810\u27e9 https://docs.rs/siphasher/latest/siphasher/#modules: \u00a7\n\u27e811\u27e9 https://docs.rs/siphasher/latest/siphasher/prelude/index.html: mod siphasher::prelude - prelude\n\u27e812\u27e9 https://docs.rs/siphasher/latest/siphasher/sip/index.html: mod siphasher::sip - sip\n\u27e813\u27e9 https://docs.rs/siphasher/latest/siphasher/sip128/index.html: mod siphasher::sip128 - sip128\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `siphasher` crate provides a Rust implementation of SipHash-2-4 and SipHash-1-3, offering both 64-bit and 128-bit hashing modes via the `sip` and `sip128` modules. It supports one-shot and incremental hashing, with optional integration for `serde`. The crate emphasizes safe usage of the `Hasher` trait to avoid non-portable results.",
    "feature_summary": null,
    "use_case": "Utilities",
    "score": 6.0,
    "factual_counterfactual": "### Pair 1: SipHash Modes\n\u2705 Factual: The `siphasher` crate implements both SipHash-2-4 and SipHash-1-3 algorithms, with the `sip` module providing 64-bit hashing and the `sip128` module offering 128-bit hashing.  \n\u274c Counterfactual: The `siphasher` crate only supports SipHash-2-4 and does not include SipHash-1-3 or a 128-bit hashing mode.  \n\n---\n\n### Pair 2: Serde Integration\n\u2705 Factual: The `siphasher` crate supports integration with Serde for serialization and deserialization when the `serde` feature is enabled in `Cargo.toml`.  \n\u274c Counterfactual: The `siphasher` crate has built-in Serde support enabled by default without requiring any additional features.  \n\n---\n\n### Pair 3: API Portability\n\u2705 Factual: The `siphasher` crate's API recommends using `write()` and `finish()` methods from the `Hasher` trait to avoid non-portable results, as other methods in the trait may produce inconsistent outputs across platforms.  \n\u274c Counterfactual: All methods in the `Hasher` trait, including `write()` and `finish()`, produce portable and consistent results across all platforms.",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}