{
    "name": "h2",
    "version": "0.4.10",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/h2/latest/h2/all.html \"show sidebar\")\n# Crate h2Copy item path\n[Settings](https://docs.rs/h2/latest/settings.html)\n[Help](https://docs.rs/h2/latest/help.html)\nSummary[Source](https://docs.rs/h2/latest/src/h2/lib.rs.html#1-162)\nExpand description\nAn asynchronous, HTTP/2 server and client implementation.\nThis library implements the [HTTP/2](https://http2.github.io/) specification. The implementation is asynchronous, using [futures](https://docs.rs/futures/) as the basis for the API. The implementation is also decoupled from TCP or TLS details. The user must handle ALPN and HTTP/1.1 upgrades themselves.\n## [\u00a7](https://docs.rs/h2/latest/h2/#getting-started)Getting started\nAdd the following to your `Cargo.toml` file:\n```\n[dependencies]\nh2 = \"0.4\"\n```\n\n## [\u00a7](https://docs.rs/h2/latest/h2/#layout-1)Layout\nThe crate is split into [`client`](https://docs.rs/h2/latest/h2/client/index.html) and [`server`](https://docs.rs/h2/latest/h2/server/index.html) modules. Types that are common to both clients and servers are located at the root of the crate.\nSee module level documentation for more details on how to use `h2`.\n## [\u00a7](https://docs.rs/h2/latest/h2/#handshake)Handshake\nBoth the client and the server require a connection to already be in a state ready to start the HTTP/2 handshake. This library does not provide facilities to do this.\nThere are three ways to reach an appropriate state to start the HTTP/2 handshake.\n  * Opening an HTTP/1.1 connection and performing an [upgrade](https://developer.mozilla.org/en-US/docs/Web/HTTP/Protocol_upgrade_mechanism).\n  * Opening a connection with TLS and use ALPN to negotiate the protocol.\n  * Open a connection with prior knowledge, i.e. both the client and the server assume that the connection is immediately ready to start the HTTP/2 handshake once opened.\n\n\nOnce the connection is ready to start the HTTP/2 handshake, it can be passed to [`server::handshake`](https://docs.rs/h2/latest/h2/server/fn.handshake.html) or [`client::handshake`](https://docs.rs/h2/latest/h2/client/fn.handshake.html). At this point, the library will start the handshake process, which consists of:\n  * The client sends the connection preface (a predefined sequence of 24 octets).\n  * Both the client and the server sending a SETTINGS frame.\n\n\nSee the [Starting HTTP/2](http://httpwg.org/specs/rfc7540.html#starting) in the specification for more details.\n## [\u00a7](https://docs.rs/h2/latest/h2/#flow-control)Flow control\n[Flow control](http://httpwg.org/specs/rfc7540.html#FlowControl) is a fundamental feature of HTTP/2. The `h2` library exposes flow control to the user.\nAn HTTP/2 client or server may not send unlimited data to the peer. When a stream is initiated, both the client and the server are provided with an initial window size for that stream. A window size is the number of bytes the endpoint can send to the peer. At any point in time, the peer may increase this window size by sending a `WINDOW_UPDATE` frame. Once a client or server has sent data filling the window for a stream, no further data may be sent on that stream until the peer increases the window.\nThere is also a **connection level** window governing data sent across all streams.\nManaging flow control for inbound data is done through [`FlowControl`](https://docs.rs/h2/latest/h2/struct.FlowControl.html). Managing flow control for outbound data is done through [`SendStream`](https://docs.rs/h2/latest/h2/struct.SendStream.html). See the struct level documentation for those two types for more details.\n## Modules[\u00a7](https://docs.rs/h2/latest/h2/#modules)\n\n[client](https://docs.rs/h2/latest/h2/client/index.html \"mod h2::client\")\n    Client implementation of the HTTP/2 protocol.\n\n[ext](https://docs.rs/h2/latest/h2/ext/index.html \"mod h2::ext\")\n    Extensions specific to the HTTP/2 protocol.\n\n[server](https://docs.rs/h2/latest/h2/server/index.html \"mod h2::server\")\n    Server implementation of the HTTP/2 protocol.\n## Structs[\u00a7](https://docs.rs/h2/latest/h2/#structs)\n\n[Error](https://docs.rs/h2/latest/h2/struct.Error.html \"struct h2::Error\")\n    Represents HTTP/2 operation errors.\n\n[FlowControl](https://docs.rs/h2/latest/h2/struct.FlowControl.html \"struct h2::FlowControl\")\n    A handle to release window capacity to a remote stream.\n\n[Ping](https://docs.rs/h2/latest/h2/struct.Ping.html \"struct h2::Ping\")\n    Sent via [`PingPong`](https://docs.rs/h2/latest/h2/struct.PingPong.html) to send a PING frame to a peer.\n\n[PingPong](https://docs.rs/h2/latest/h2/struct.PingPong.html \"struct h2::PingPong\")\n    A handle to send and receive PING frames with the peer.\n\n[Pong](https://docs.rs/h2/latest/h2/struct.Pong.html \"struct h2::Pong\")\n    Received via [`PingPong`](https://docs.rs/h2/latest/h2/struct.PingPong.html) when a peer acknowledges a [`Ping`](https://docs.rs/h2/latest/h2/struct.Ping.html).\n\n[Reason](https://docs.rs/h2/latest/h2/struct.Reason.html \"struct h2::Reason\")\n    HTTP/2 error codes.\n\n[RecvStream](https://docs.rs/h2/latest/h2/struct.RecvStream.html \"struct h2::RecvStream\")\n    Receives the body stream and trailers from the remote peer.\n\n[SendStream](https://docs.rs/h2/latest/h2/struct.SendStream.html \"struct h2::SendStream\")\n    Sends the body stream and trailers to the remote peer.\n\n[StreamId](https://docs.rs/h2/latest/h2/struct.StreamId.html \"struct h2::StreamId\")\n    A stream identifier, as described in [Section 5.1.1](https://tools.ietf.org/html/rfc7540#section-5.1.1) of RFC 7540.\n",
        "markdown_with_citations": "[](https://docs.rs/h2/latest/h2/all.html \"show sidebar\")\n# Crate h2Copy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nAn asynchronous, HTTP/2 server and client implementation.\nThis library implements the HTTP/2\u27e84\u27e9 specification. The implementation is asynchronous, using futures\u27e85\u27e9 as the basis for the API. The implementation is also decoupled from TCP or TLS details. The user must handle ALPN and HTTP/1.1 upgrades themselves.\n## \u00a7\u27e86\u27e9Getting started\nAdd the following to your `Cargo.toml` file:\n```\n[dependencies]\nh2 = \"0.4\"\n```\n\n## \u00a7\u27e87\u27e9Layout\nThe crate is split into `client`\u27e88\u27e9 and `server`\u27e89\u27e9 modules. Types that are common to both clients and servers are located at the root of the crate.\nSee module level documentation for more details on how to use `h2`.\n## \u00a7\u27e810\u27e9Handshake\nBoth the client and the server require a connection to already be in a state ready to start the HTTP/2 handshake. This library does not provide facilities to do this.\nThere are three ways to reach an appropriate state to start the HTTP/2 handshake.\n  * Opening an HTTP/1.1 connection and performing an upgrade\u27e811\u27e9.\n  * Opening a connection with TLS and use ALPN to negotiate the protocol.\n  * Open a connection with prior knowledge, i.e. both the client and the server assume that the connection is immediately ready to start the HTTP/2 handshake once opened.\n\n\nOnce the connection is ready to start the HTTP/2 handshake, it can be passed to `server::handshake`\u27e812\u27e9 or `client::handshake`\u27e813\u27e9. At this point, the library will start the handshake process, which consists of:\n  * The client sends the connection preface (a predefined sequence of 24 octets).\n  * Both the client and the server sending a SETTINGS frame.\n\n\nSee the Starting HTTP/2\u27e814\u27e9 in the specification for more details.\n## \u00a7\u27e815\u27e9Flow control\nFlow control\u27e816\u27e9 is a fundamental feature of HTTP/2. The `h2` library exposes flow control to the user.\nAn HTTP/2 client or server may not send unlimited data to the peer. When a stream is initiated, both the client and the server are provided with an initial window size for that stream. A window size is the number of bytes the endpoint can send to the peer. At any point in time, the peer may increase this window size by sending a `WINDOW_UPDATE` frame. Once a client or server has sent data filling the window for a stream, no further data may be sent on that stream until the peer increases the window.\nThere is also a **connection level** window governing data sent across all streams.\nManaging flow control for inbound data is done through `FlowControl`\u27e817\u27e9. Managing flow control for outbound data is done through `SendStream`\u27e818\u27e9. See the struct level documentation for those two types for more details.\n## Modules\u00a7\u27e819\u27e9\n\nclient\u27e88\u27e9\n    Client implementation of the HTTP/2 protocol.\n\next\u27e820\u27e9\n    Extensions specific to the HTTP/2 protocol.\n\nserver\u27e89\u27e9\n    Server implementation of the HTTP/2 protocol.\n## Structs\u00a7\u27e821\u27e9\n\nError\u27e822\u27e9\n    Represents HTTP/2 operation errors.\n\nFlowControl\u27e817\u27e9\n    A handle to release window capacity to a remote stream.\n\nPing\u27e823\u27e9\n    Sent via `PingPong`\u27e824\u27e9 to send a PING frame to a peer.\n\nPingPong\u27e824\u27e9\n    A handle to send and receive PING frames with the peer.\n\nPong\u27e825\u27e9\n    Received via `PingPong`\u27e824\u27e9 when a peer acknowledges a `Ping`\u27e823\u27e9.\n\nReason\u27e826\u27e9\n    HTTP/2 error codes.\n\nRecvStream\u27e827\u27e9\n    Receives the body stream and trailers from the remote peer.\n\nSendStream\u27e818\u27e9\n    Sends the body stream and trailers to the remote peer.\n\nStreamId\u27e828\u27e9\n    A stream identifier, as described in Section 5.1.1\u27e829\u27e9 of RFC 7540.\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/h2/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/h2/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/h2/latest/src/h2/lib.rs.html#1-162: Source\n\u27e84\u27e9 https://http2.github.io/: HTTP/2\n\u27e85\u27e9 https://docs.rs/futures/: futures\n\u27e86\u27e9 https://docs.rs/h2/latest/h2/#getting-started: \u00a7\n\u27e87\u27e9 https://docs.rs/h2/latest/h2/#layout-1: \u00a7\n\u27e88\u27e9 https://docs.rs/h2/latest/h2/client/index.html: `client`\n\u27e89\u27e9 https://docs.rs/h2/latest/h2/server/index.html: `server`\n\u27e810\u27e9 https://docs.rs/h2/latest/h2/#handshake: \u00a7\n\u27e811\u27e9 https://developer.mozilla.org/en-US/docs/Web/HTTP/Protocol_upgrade_mechanism: upgrade\n\u27e812\u27e9 https://docs.rs/h2/latest/h2/server/fn.handshake.html: `server::handshake`\n\u27e813\u27e9 https://docs.rs/h2/latest/h2/client/fn.handshake.html: `client::handshake`\n\u27e814\u27e9 http://httpwg.org/specs/rfc7540.html#starting: Starting HTTP/2\n\u27e815\u27e9 https://docs.rs/h2/latest/h2/#flow-control: \u00a7\n\u27e816\u27e9 http://httpwg.org/specs/rfc7540.html#FlowControl: Flow control\n\u27e817\u27e9 https://docs.rs/h2/latest/h2/struct.FlowControl.html: `FlowControl`\n\u27e818\u27e9 https://docs.rs/h2/latest/h2/struct.SendStream.html: `SendStream`\n\u27e819\u27e9 https://docs.rs/h2/latest/h2/#modules: \u00a7\n\u27e820\u27e9 https://docs.rs/h2/latest/h2/ext/index.html: mod h2::ext - ext\n\u27e821\u27e9 https://docs.rs/h2/latest/h2/#structs: \u00a7\n\u27e822\u27e9 https://docs.rs/h2/latest/h2/struct.Error.html: struct h2::Error - Error\n\u27e823\u27e9 https://docs.rs/h2/latest/h2/struct.Ping.html: struct h2::Ping - Ping\n\u27e824\u27e9 https://docs.rs/h2/latest/h2/struct.PingPong.html: `PingPong`\n\u27e825\u27e9 https://docs.rs/h2/latest/h2/struct.Pong.html: struct h2::Pong - Pong\n\u27e826\u27e9 https://docs.rs/h2/latest/h2/struct.Reason.html: struct h2::Reason - Reason\n\u27e827\u27e9 https://docs.rs/h2/latest/h2/struct.RecvStream.html: struct h2::RecvStream - RecvStream\n\u27e828\u27e9 https://docs.rs/h2/latest/h2/struct.StreamId.html: struct h2::StreamId - StreamId\n\u27e829\u27e9 https://tools.ietf.org/html/rfc7540#section-5.1.1: Section 5.1.1\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `h2` crate is an asynchronous implementation of the HTTP/2 protocol for both clients and servers, built on the `futures` API. It is transport-agnostic, requiring users to handle connection setup (e.g., ALPN or HTTP/1.1 upgrades) before initiating the HTTP/2 handshake. Key features include flow control management, modular client/server APIs, and support for HTTP/2 frames like PING, SETTINGS, and WINDOW_UPDATE.",
    "feature_summary": null,
    "use_case": "Networking",
    "score": 8.0,
    "factual_counterfactual": "### Pair 1: Handshake Process\n\u2705 **Factual:** The `h2` crate requires a connection to be in a state ready to start the HTTP/2 handshake, and it does not handle ALPN or HTTP/1.1 upgrades itself.  \n\u274c **Counterfactual:** The `h2` crate automatically handles ALPN and HTTP/1.1 upgrades as part of the HTTP/2 handshake process.  \n\n---\n\n### Pair 2: Flow Control\n\u2705 **Factual:** The `h2` crate provides flow control mechanisms through the `FlowControl` and `SendStream` structs, allowing users to manage inbound and outbound data windows.  \n\u274c **Counterfactual:** The `h2` crate automatically manages flow control internally, and users do not need to interact with `FlowControl` or `SendStream` structs.  \n\n---\n\n### Pair 3: Decoupling from Transport Layers\n\u2705 **Factual:** The `h2` crate is decoupled from TCP and TLS transport layers, requiring users to manage these details separately.  \n\u274c **Counterfactual:** The `h2` crate includes built-in support for managing TCP and TLS transport layers, including ALPN negotiation.",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}