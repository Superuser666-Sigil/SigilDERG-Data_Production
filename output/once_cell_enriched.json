{
    "name": "once_cell",
    "version": "1.21.3",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/once_cell/latest/once_cell/all.html \"show sidebar\")\n# Crate once_cellCopy item path\n[Settings](https://docs.rs/once_cell/latest/settings.html)\n[Help](https://docs.rs/once_cell/latest/help.html)\nSummary[Source](https://docs.rs/once_cell/latest/src/once_cell/lib.rs.html#1-1412)\nExpand description\n## [\u00a7](https://docs.rs/once_cell/latest/once_cell/#overview)Overview\n`once_cell` provides two new cell-like types, [`unsync::OnceCell`](https://docs.rs/once_cell/latest/once_cell/unsync/struct.OnceCell.html) and [`sync::OnceCell`](https://docs.rs/once_cell/latest/once_cell/sync/struct.OnceCell.html). A `OnceCell` might store arbitrary non-`Copy` types, can be assigned to at most once and provides direct access to the stored contents. The core API looks _roughly_ like this (and there\u2019s much more inside, read on!):\n[\u24d8](https://docs.rs/once_cell/latest/once_cell/ \"This example is not tested\")```\nimpl<T> OnceCell<T> {\n  const fn new() -> OnceCell<T> { ... }\n  fn set(&self, value: T) -> Result<(), T> { ... }\n  fn get(&self) -> Option<&T> { ... }\n}\n```\n\nNote that, like with [`RefCell`](https://doc.rust-lang.org/std/cell/struct.RefCell.html) and [`Mutex`](https://doc.rust-lang.org/std/sync/struct.Mutex.html), the `set` method requires only a shared reference. Because of the single assignment restriction `get` can return a `&T` instead of `Ref<T>` or `MutexGuard<T>`.\nThe `sync` flavor is thread-safe (that is, implements the [`Sync`](https://doc.rust-lang.org/std/marker/trait.Sync.html) trait), while the `unsync` one is not.\n## [\u00a7](https://docs.rs/once_cell/latest/once_cell/#recipes)Recipes\n`OnceCell` might be useful for a variety of patterns.\n### [\u00a7](https://docs.rs/once_cell/latest/once_cell/#safe-initialization-of-global-data)Safe Initialization of Global Data\n```\nuse std::{env, io};\nuse once_cell::sync::OnceCell;\n#[derive(Debug)]\npub struct Logger {\n  // ...\n}\nstatic INSTANCE: OnceCell<Logger> = OnceCell::new();\nimpl Logger {\n  pub fn global() -> &'static Logger {\n    INSTANCE.get().expect(\"logger is not initialized\")\n  }\n  fn from_cli(args: env::Args) -> Result<Logger, std::io::Error> {\n    // ...\n  }\n}\nfn main() {\n  let logger = Logger::from_cli(env::args()).unwrap();\n  INSTANCE.set(logger).unwrap();\n  // use `Logger::global()` from now on\n}\n```\n\n### [\u00a7](https://docs.rs/once_cell/latest/once_cell/#lazy-initialized-global-data)Lazy Initialized Global Data\nThis is essentially the `lazy_static!` macro, but without a macro.\n```\nuse std::{sync::Mutex, collections::HashMap};\nuse once_cell::sync::OnceCell;\nfn global_data() -> &'static Mutex<HashMap<i32, String>> {\n  static INSTANCE: OnceCell<Mutex<HashMap<i32, String>>> = OnceCell::new();\n  INSTANCE.get_or_init(|| {\n    let mut m = HashMap::new();\n    m.insert(13, \"Spica\".to_string());\n    m.insert(74, \"Hoyten\".to_string());\n    Mutex::new(m)\n  })\n}\n```\n\nThere are also the [`sync::Lazy`](https://docs.rs/once_cell/latest/once_cell/sync/struct.Lazy.html) and [`unsync::Lazy`](https://docs.rs/once_cell/latest/once_cell/unsync/struct.Lazy.html) convenience types to streamline this pattern:\n```\nuse std::{sync::Mutex, collections::HashMap};\nuse once_cell::sync::Lazy;\nstatic GLOBAL_DATA: Lazy<Mutex<HashMap<i32, String>>> = Lazy::new(|| {\n  let mut m = HashMap::new();\n  m.insert(13, \"Spica\".to_string());\n  m.insert(74, \"Hoyten\".to_string());\n  Mutex::new(m)\n});\nfn main() {\n  println!(\"{:?}\", GLOBAL_DATA.lock().unwrap());\n}\n```\n\nNote that the variable that holds `Lazy` is declared as `static`, _not_ `const`. This is important: using `const` instead compiles, but works wrong.\n### [\u00a7](https://docs.rs/once_cell/latest/once_cell/#general-purpose-lazy-evaluation)General purpose lazy evaluation\nUnlike `lazy_static!`, `Lazy` works with local variables.\n```\nuse once_cell::unsync::Lazy;\nfn main() {\n  let ctx = vec![1, 2, 3];\n  let thunk = Lazy::new(|| {\n    ctx.iter().sum::<i32>()\n  });\n  assert_eq!(*thunk, 6);\n}\n```\n\nIf you need a lazy field in a struct, you probably should use `OnceCell` directly, because that will allow you to access `self` during initialization.\n```\nuse std::{fs, path::PathBuf};\nuse once_cell::unsync::OnceCell;\nstruct Ctx {\n  config_path: PathBuf,\n  config: OnceCell<String>,\n}\nimpl Ctx {\n  pub fn get_config(&self) -> Result<&str, std::io::Error> {\n    let cfg = self.config.get_or_try_init(|| {\n      fs::read_to_string(&self.config_path)\n    })?;\n    Ok(cfg.as_str())\n  }\n}\n```\n\n### [\u00a7](https://docs.rs/once_cell/latest/once_cell/#lazily-compiled-regex)Lazily Compiled Regex\nThis is a `regex!` macro which takes a string literal and returns an _expression_ that evaluates to a `&'static Regex`:\n```\nmacro_rules! regex {\n  ($re:literal $(,)?) => {{\n    static RE: once_cell::sync::OnceCell<regex::Regex> = once_cell::sync::OnceCell::new();\n    RE.get_or_init(|| regex::Regex::new($re).unwrap())\n  }};\n}\n```\n\nThis macro can be useful to avoid the \u201ccompile regex on every loop iteration\u201d problem.\n### [\u00a7](https://docs.rs/once_cell/latest/once_cell/#runtime-include_bytes)Runtime `include_bytes!`\nThe `include_bytes` macro is useful to include test resources, but it slows down test compilation a lot. An alternative is to load the resources at runtime:\n```\nuse std::path::Path;\nuse once_cell::sync::OnceCell;\npub struct TestResource {\n  path: &'static str,\n  cell: OnceCell<Vec<u8>>,\n}\nimpl TestResource {\n  pub const fn new(path: &'static str) -> TestResource {\n    TestResource { path, cell: OnceCell::new() }\n  }\n  pub fn bytes(&self) -> &[u8] {\n    self.cell.get_or_init(|| {\n      let dir = std::env::var(\"CARGO_MANIFEST_DIR\").unwrap();\n      let path = Path::new(dir.as_str()).join(self.path);\n      std::fs::read(&path).unwrap_or_else(|_err| {\n        panic!(\"failed to load test resource: {}\", path.display())\n      })\n    }).as_slice()\n  }\n}\nstatic TEST_IMAGE: TestResource = TestResource::new(\"test_data/lena.png\");\n#[test]\nfn test_sobel_filter() {\n  let rgb: &[u8] = TEST_IMAGE.bytes();\n  // ...\n}\n```\n\n### [\u00a7](https://docs.rs/once_cell/latest/once_cell/#lateinit)`lateinit`\n`LateInit` type for delayed initialization. It is reminiscent of Kotlin\u2019s `lateinit` keyword and allows construction of cyclic data structures:\n```\nuse once_cell::sync::OnceCell;\npub struct LateInit<T> { cell: OnceCell<T> }\nimpl<T> LateInit<T> {\n  pub fn init(&self, value: T) {\n    assert!(self.cell.set(value).is_ok())\n  }\n}\nimpl<T> Default for LateInit<T> {\n  fn default() -> Self { LateInit { cell: OnceCell::default() } }\n}\nimpl<T> std::ops::Deref for LateInit<T> {\n  type Target = T;\n  fn deref(&self) -> &T {\n    self.cell.get().unwrap()\n  }\n}\n#[derive(Default)]\nstruct A<'a> {\n  b: LateInit<&'a B<'a>>,\n}\n#[derive(Default)]\nstruct B<'a> {\n  a: LateInit<&'a A<'a>>\n}\n\nfn build_cycle() {\n  let a = A::default();\n  let b = B::default();\n  a.b.init(&b);\n  b.a.init(&a);\n  let _a = &a.b.a.b.a;\n}\n```\n\n## [\u00a7](https://docs.rs/once_cell/latest/once_cell/#comparison-with-std)Comparison with std\n`!Sync` types| Access Mode| Drawbacks  \n---|---|---  \n`Cell<T>`| `T`| requires `T: Copy` for `get`  \n`RefCell<T>`| `RefMut<T>` / `Ref<T>`| may panic at runtime  \n`unsync::OnceCell<T>`| `&T`| assignable only once  \n`Sync` types| Access Mode| Drawbacks  \n---|---|---  \n`AtomicT`| `T`| works only with certain `Copy` types  \n`Mutex<T>`| `MutexGuard<T>`| may deadlock at runtime, may block the thread  \n`sync::OnceCell<T>`| `&T`| assignable only once, may block the thread  \nTechnically, calling `get_or_init` will also cause a panic or a deadlock if it recursively calls itself. However, because the assignment can happen only once, such cases should be more rare than equivalents with `RefCell` and `Mutex`.\n## [\u00a7](https://docs.rs/once_cell/latest/once_cell/#minimum-supported-rustc-version)Minimum Supported `rustc` Version\nIf only the `std`, `alloc`, or `race` features are enabled, MSRV will be updated conservatively, supporting at least latest 8 versions of the compiler. When using other features, like `parking_lot`, MSRV might be updated more frequently, up to the latest stable. In both cases, increasing MSRV is _not_ considered a semver-breaking change and requires only a minor version bump.\n## [\u00a7](https://docs.rs/once_cell/latest/once_cell/#implementation-details)Implementation details\nThe implementation is based on the [`lazy_static`](https://github.com/rust-lang-nursery/lazy-static.rs/) and [`lazy_cell`](https://github.com/indiv0/lazycell/) crates and [`std::sync::Once`](https://doc.rust-lang.org/std/sync/struct.Once.html). In some sense, `once_cell` just streamlines and unifies those APIs.\nTo implement a sync flavor of `OnceCell`, this crates uses either a custom re-implementation of `std::sync::Once` or `parking_lot::Mutex`. This is controlled by the `parking_lot` feature (disabled by default). Performance is the same for both cases, but the `parking_lot` based `OnceCell<T>` is smaller by up to 16 bytes.\nThis crate uses `unsafe`.\n## [\u00a7](https://docs.rs/once_cell/latest/once_cell/#faq)F.A.Q.\n**Should I use the sync or unsync flavor?**\nBecause Rust compiler checks thread safety for you, it\u2019s impossible to accidentally use `unsync` where `sync` is required. So, use `unsync` in single-threaded code and `sync` in multi-threaded. It\u2019s easy to switch between the two if code becomes multi-threaded later.\nAt the moment, `unsync` has an additional benefit that reentrant initialization causes a panic, which might be easier to debug than a deadlock.\n**Does this crate support async?**\nNo, but you can use [`async_once_cell`](https://crates.io/crates/async_once_cell) instead.\n**Does this crate support`no_std`?**\nYes, but with caveats. `OnceCell` is a synchronization primitive which _semantically_ relies on blocking. `OnceCell` guarantees that at most one `f` will be called to compute the value. If two threads of execution call `get_or_init` concurrently, one of them has to wait.\nWaiting fundamentally requires OS support. Execution environment needs to understand who waits on whom to prevent deadlocks due to priority inversion. You _could_ make code to compile by blindly using pure spinlocks, but the runtime behavior would be subtly wrong.\nGiven these constraints, `once_cell` provides the following options:\n  * The `race` module provides similar, but distinct synchronization primitive which is compatible with `no_std`. With `race`, the `f` function can be called multiple times by different threads, but only one thread will win to install the value.\n  * `critical-section` feature (with a `-`, not `_`) uses `critical_section` to implement blocking.\n\n\n**Can I bring my own mutex?**\nThere is [generic_once_cell](https://crates.io/crates/generic_once_cell) to allow just that.\n**Should I use`std::cell::OnceCell` , `once_cell`, or `lazy_static`?**\nIf you can use `std` version (your MSRV is at least 1.70, and you don\u2019t need extra features `once_cell` provides), use `std`. Otherwise, use `once_cell`. Don\u2019t use `lazy_static`.\n## [\u00a7](https://docs.rs/once_cell/latest/once_cell/#related-crates)Related crates\n  * Most of this crate\u2019s functionality is available in `std` starting with Rust 1.70. See `std::cell::OnceCell` and `std::sync::OnceLock`.\n  * [double-checked-cell](https://github.com/niklasf/double-checked-cell)\n  * [lazy-init](https://crates.io/crates/lazy-init)\n  * [lazycell](https://crates.io/crates/lazycell)\n  * [mitochondria](https://crates.io/crates/mitochondria)\n  * [lazy_static](https://crates.io/crates/lazy_static)\n  * [async_once_cell](https://crates.io/crates/async_once_cell)\n  * [generic_once_cell](https://crates.io/crates/generic_once_cell) (bring your own mutex)\n\n\n## Modules[\u00a7](https://docs.rs/once_cell/latest/once_cell/#modules)\n\n[race](https://docs.rs/once_cell/latest/once_cell/race/index.html \"mod once_cell::race\")\n    Thread-safe, non-blocking, \u201cfirst one wins\u201d flavor of `OnceCell`.\n\n[sync](https://docs.rs/once_cell/latest/once_cell/sync/index.html \"mod once_cell::sync\")\n    Thread-safe, blocking version of `OnceCell`.\n\n[unsync](https://docs.rs/once_cell/latest/once_cell/unsync/index.html \"mod once_cell::unsync\")\n    Single-threaded version of `OnceCell`.\n",
        "markdown_with_citations": "[](https://docs.rs/once_cell/latest/once_cell/all.html \"show sidebar\")\n# Crate once_cellCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\n## \u00a7\u27e84\u27e9Overview\n`once_cell` provides two new cell-like types, `unsync::OnceCell`\u27e85\u27e9 and `sync::OnceCell`\u27e86\u27e9. A `OnceCell` might store arbitrary non-`Copy` types, can be assigned to at most once and provides direct access to the stored contents. The core API looks _roughly_ like this (and there\u2019s much more inside, read on!):\n\u24d8\u27e87\u27e9```\nimpl<T> OnceCell<T> {\n  const fn new() -> OnceCell<T> { ... }\n  fn set(&self, value: T) -> Result<(), T> { ... }\n  fn get(&self) -> Option<&T> { ... }\n}\n```\n\nNote that, like with `RefCell`\u27e88\u27e9 and `Mutex`\u27e89\u27e9, the `set` method requires only a shared reference. Because of the single assignment restriction `get` can return a `&T` instead of `Ref<T>` or `MutexGuard<T>`.\nThe `sync` flavor is thread-safe (that is, implements the `Sync`\u27e810\u27e9 trait), while the `unsync` one is not.\n## \u00a7\u27e811\u27e9Recipes\n`OnceCell` might be useful for a variety of patterns.\n### \u00a7\u27e812\u27e9Safe Initialization of Global Data\n```\nuse std::{env, io};\nuse once_cell::sync::OnceCell;\n#[derive(Debug)]\npub struct Logger {\n  // ...\n}\nstatic INSTANCE: OnceCell<Logger> = OnceCell::new();\nimpl Logger {\n  pub fn global() -> &'static Logger {\n    INSTANCE.get().expect(\"logger is not initialized\")\n  }\n  fn from_cli(args: env::Args) -> Result<Logger, std::io::Error> {\n    // ...\n  }\n}\nfn main() {\n  let logger = Logger::from_cli(env::args()).unwrap();\n  INSTANCE.set(logger).unwrap();\n  // use `Logger::global()` from now on\n}\n```\n\n### \u00a7\u27e813\u27e9Lazy Initialized Global Data\nThis is essentially the `lazy_static!` macro, but without a macro.\n```\nuse std::{sync::Mutex, collections::HashMap};\nuse once_cell::sync::OnceCell;\nfn global_data() -> &'static Mutex<HashMap<i32, String>> {\n  static INSTANCE: OnceCell<Mutex<HashMap<i32, String>>> = OnceCell::new();\n  INSTANCE.get_or_init(|| {\n    let mut m = HashMap::new();\n    m.insert(13, \"Spica\".to_string());\n    m.insert(74, \"Hoyten\".to_string());\n    Mutex::new(m)\n  })\n}\n```\n\nThere are also the `sync::Lazy`\u27e814\u27e9 and `unsync::Lazy`\u27e815\u27e9 convenience types to streamline this pattern:\n```\nuse std::{sync::Mutex, collections::HashMap};\nuse once_cell::sync::Lazy;\nstatic GLOBAL_DATA: Lazy<Mutex<HashMap<i32, String>>> = Lazy::new(|| {\n  let mut m = HashMap::new();\n  m.insert(13, \"Spica\".to_string());\n  m.insert(74, \"Hoyten\".to_string());\n  Mutex::new(m)\n});\nfn main() {\n  println!(\"{:?}\", GLOBAL_DATA.lock().unwrap());\n}\n```\n\nNote that the variable that holds `Lazy` is declared as `static`, _not_ `const`. This is important: using `const` instead compiles, but works wrong.\n### \u00a7\u27e816\u27e9General purpose lazy evaluation\nUnlike `lazy_static!`, `Lazy` works with local variables.\n```\nuse once_cell::unsync::Lazy;\nfn main() {\n  let ctx = vec![1, 2, 3];\n  let thunk = Lazy::new(|| {\n    ctx.iter().sum::<i32>()\n  });\n  assert_eq!(*thunk, 6);\n}\n```\n\nIf you need a lazy field in a struct, you probably should use `OnceCell` directly, because that will allow you to access `self` during initialization.\n```\nuse std::{fs, path::PathBuf};\nuse once_cell::unsync::OnceCell;\nstruct Ctx {\n  config_path: PathBuf,\n  config: OnceCell<String>,\n}\nimpl Ctx {\n  pub fn get_config(&self) -> Result<&str, std::io::Error> {\n    let cfg = self.config.get_or_try_init(|| {\n      fs::read_to_string(&self.config_path)\n    })?;\n    Ok(cfg.as_str())\n  }\n}\n```\n\n### \u00a7\u27e817\u27e9Lazily Compiled Regex\nThis is a `regex!` macro which takes a string literal and returns an _expression_ that evaluates to a `&'static Regex`:\n```\nmacro_rules! regex {\n  ($re:literal $(,)?) => {{\n    static RE: once_cell::sync::OnceCell<regex::Regex> = once_cell::sync::OnceCell::new();\n    RE.get_or_init(|| regex::Regex::new($re).unwrap())\n  }};\n}\n```\n\nThis macro can be useful to avoid the \u201ccompile regex on every loop iteration\u201d problem.\n### \u00a7\u27e818\u27e9Runtime `include_bytes!`\nThe `include_bytes` macro is useful to include test resources, but it slows down test compilation a lot. An alternative is to load the resources at runtime:\n```\nuse std::path::Path;\nuse once_cell::sync::OnceCell;\npub struct TestResource {\n  path: &'static str,\n  cell: OnceCell<Vec<u8>>,\n}\nimpl TestResource {\n  pub const fn new(path: &'static str) -> TestResource {\n    TestResource { path, cell: OnceCell::new() }\n  }\n  pub fn bytes(&self) -> &[u8] {\n    self.cell.get_or_init(|| {\n      let dir = std::env::var(\"CARGO_MANIFEST_DIR\").unwrap();\n      let path = Path::new(dir.as_str()).join(self.path);\n      std::fs::read(&path).unwrap_or_else(|_err| {\n        panic!(\"failed to load test resource: {}\", path.display())\n      })\n    }).as_slice()\n  }\n}\nstatic TEST_IMAGE: TestResource = TestResource::new(\"test_data/lena.png\");\n#[test]\nfn test_sobel_filter() {\n  let rgb: &[u8] = TEST_IMAGE.bytes();\n  // ...\n}\n```\n\n### \u00a7\u27e819\u27e9`lateinit`\n`LateInit` type for delayed initialization. It is reminiscent of Kotlin\u2019s `lateinit` keyword and allows construction of cyclic data structures:\n```\nuse once_cell::sync::OnceCell;\npub struct LateInit<T> { cell: OnceCell<T> }\nimpl<T> LateInit<T> {\n  pub fn init(&self, value: T) {\n    assert!(self.cell.set(value).is_ok())\n  }\n}\nimpl<T> Default for LateInit<T> {\n  fn default() -> Self { LateInit { cell: OnceCell::default() } }\n}\nimpl<T> std::ops::Deref for LateInit<T> {\n  type Target = T;\n  fn deref(&self) -> &T {\n    self.cell.get().unwrap()\n  }\n}\n#[derive(Default)]\nstruct A<'a> {\n  b: LateInit<&'a B<'a>>,\n}\n#[derive(Default)]\nstruct B<'a> {\n  a: LateInit<&'a A<'a>>\n}\n\nfn build_cycle() {\n  let a = A::default();\n  let b = B::default();\n  a.b.init(&b);\n  b.a.init(&a);\n  let _a = &a.b.a.b.a;\n}\n```\n\n## \u00a7\u27e820\u27e9Comparison with std\n`!Sync` types| Access Mode| Drawbacks  \n---|---|---  \n`Cell<T>`| `T`| requires `T: Copy` for `get`  \n`RefCell<T>`| `RefMut<T>` / `Ref<T>`| may panic at runtime  \n`unsync::OnceCell<T>`| `&T`| assignable only once  \n`Sync` types| Access Mode| Drawbacks  \n---|---|---  \n`AtomicT`| `T`| works only with certain `Copy` types  \n`Mutex<T>`| `MutexGuard<T>`| may deadlock at runtime, may block the thread  \n`sync::OnceCell<T>`| `&T`| assignable only once, may block the thread  \nTechnically, calling `get_or_init` will also cause a panic or a deadlock if it recursively calls itself. However, because the assignment can happen only once, such cases should be more rare than equivalents with `RefCell` and `Mutex`.\n## \u00a7\u27e821\u27e9Minimum Supported `rustc` Version\nIf only the `std`, `alloc`, or `race` features are enabled, MSRV will be updated conservatively, supporting at least latest 8 versions of the compiler. When using other features, like `parking_lot`, MSRV might be updated more frequently, up to the latest stable. In both cases, increasing MSRV is _not_ considered a semver-breaking change and requires only a minor version bump.\n## \u00a7\u27e822\u27e9Implementation details\nThe implementation is based on the `lazy_static`\u27e823\u27e9 and `lazy_cell`\u27e824\u27e9 crates and `std::sync::Once`\u27e825\u27e9. In some sense, `once_cell` just streamlines and unifies those APIs.\nTo implement a sync flavor of `OnceCell`, this crates uses either a custom re-implementation of `std::sync::Once` or `parking_lot::Mutex`. This is controlled by the `parking_lot` feature (disabled by default). Performance is the same for both cases, but the `parking_lot` based `OnceCell<T>` is smaller by up to 16 bytes.\nThis crate uses `unsafe`.\n## \u00a7\u27e826\u27e9F.A.Q.\n**Should I use the sync or unsync flavor?**\nBecause Rust compiler checks thread safety for you, it\u2019s impossible to accidentally use `unsync` where `sync` is required. So, use `unsync` in single-threaded code and `sync` in multi-threaded. It\u2019s easy to switch between the two if code becomes multi-threaded later.\nAt the moment, `unsync` has an additional benefit that reentrant initialization causes a panic, which might be easier to debug than a deadlock.\n**Does this crate support async?**\nNo, but you can use `async_once_cell`\u27e827\u27e9 instead.\n**Does this crate support`no_std`?**\nYes, but with caveats. `OnceCell` is a synchronization primitive which _semantically_ relies on blocking. `OnceCell` guarantees that at most one `f` will be called to compute the value. If two threads of execution call `get_or_init` concurrently, one of them has to wait.\nWaiting fundamentally requires OS support. Execution environment needs to understand who waits on whom to prevent deadlocks due to priority inversion. You _could_ make code to compile by blindly using pure spinlocks, but the runtime behavior would be subtly wrong.\nGiven these constraints, `once_cell` provides the following options:\n  * The `race` module provides similar, but distinct synchronization primitive which is compatible with `no_std`. With `race`, the `f` function can be called multiple times by different threads, but only one thread will win to install the value.\n  * `critical-section` feature (with a `-`, not `_`) uses `critical_section` to implement blocking.\n\n\n**Can I bring my own mutex?**\nThere is generic_once_cell\u27e828\u27e9 to allow just that.\n**Should I use`std::cell::OnceCell` , `once_cell`, or `lazy_static`?**\nIf you can use `std` version (your MSRV is at least 1.70, and you don\u2019t need extra features `once_cell` provides), use `std`. Otherwise, use `once_cell`. Don\u2019t use `lazy_static`.\n## \u00a7\u27e829\u27e9Related crates\n  * Most of this crate\u2019s functionality is available in `std` starting with Rust 1.70. See `std::cell::OnceCell` and `std::sync::OnceLock`.\n  * double-checked-cell\u27e830\u27e9\n  * lazy-init\u27e831\u27e9\n  * lazycell\u27e832\u27e9\n  * mitochondria\u27e833\u27e9\n  * lazy_static\u27e834\u27e9\n  * async_once_cell\u27e827\u27e9\n  * generic_once_cell\u27e828\u27e9 (bring your own mutex)\n\n\n## Modules\u00a7\u27e835\u27e9\n\nrace\u27e836\u27e9\n    Thread-safe, non-blocking, \u201cfirst one wins\u201d flavor of `OnceCell`.\n\nsync\u27e837\u27e9\n    Thread-safe, blocking version of `OnceCell`.\n\nunsync\u27e838\u27e9\n    Single-threaded version of `OnceCell`.\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/once_cell/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/once_cell/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/once_cell/latest/src/once_cell/lib.rs.html#1-1412: Source\n\u27e84\u27e9 https://docs.rs/once_cell/latest/once_cell/#overview: \u00a7\n\u27e85\u27e9 https://docs.rs/once_cell/latest/once_cell/unsync/struct.OnceCell.html: `unsync::OnceCell`\n\u27e86\u27e9 https://docs.rs/once_cell/latest/once_cell/sync/struct.OnceCell.html: `sync::OnceCell`\n\u27e87\u27e9 https://docs.rs/once_cell/latest/once_cell/: This example is not tested - \u24d8\n\u27e88\u27e9 https://doc.rust-lang.org/std/cell/struct.RefCell.html: `RefCell`\n\u27e89\u27e9 https://doc.rust-lang.org/std/sync/struct.Mutex.html: `Mutex`\n\u27e810\u27e9 https://doc.rust-lang.org/std/marker/trait.Sync.html: `Sync`\n\u27e811\u27e9 https://docs.rs/once_cell/latest/once_cell/#recipes: \u00a7\n\u27e812\u27e9 https://docs.rs/once_cell/latest/once_cell/#safe-initialization-of-global-data: \u00a7\n\u27e813\u27e9 https://docs.rs/once_cell/latest/once_cell/#lazy-initialized-global-data: \u00a7\n\u27e814\u27e9 https://docs.rs/once_cell/latest/once_cell/sync/struct.Lazy.html: `sync::Lazy`\n\u27e815\u27e9 https://docs.rs/once_cell/latest/once_cell/unsync/struct.Lazy.html: `unsync::Lazy`\n\u27e816\u27e9 https://docs.rs/once_cell/latest/once_cell/#general-purpose-lazy-evaluation: \u00a7\n\u27e817\u27e9 https://docs.rs/once_cell/latest/once_cell/#lazily-compiled-regex: \u00a7\n\u27e818\u27e9 https://docs.rs/once_cell/latest/once_cell/#runtime-include_bytes: \u00a7\n\u27e819\u27e9 https://docs.rs/once_cell/latest/once_cell/#lateinit: \u00a7\n\u27e820\u27e9 https://docs.rs/once_cell/latest/once_cell/#comparison-with-std: \u00a7\n\u27e821\u27e9 https://docs.rs/once_cell/latest/once_cell/#minimum-supported-rustc-version: \u00a7\n\u27e822\u27e9 https://docs.rs/once_cell/latest/once_cell/#implementation-details: \u00a7\n\u27e823\u27e9 https://github.com/rust-lang-nursery/lazy-static.rs/: `lazy_static`\n\u27e824\u27e9 https://github.com/indiv0/lazycell/: `lazy_cell`\n\u27e825\u27e9 https://doc.rust-lang.org/std/sync/struct.Once.html: `std::sync::Once`\n\u27e826\u27e9 https://docs.rs/once_cell/latest/once_cell/#faq: \u00a7\n\u27e827\u27e9 https://crates.io/crates/async_once_cell: `async_once_cell`\n\u27e828\u27e9 https://crates.io/crates/generic_once_cell: generic_once_cell\n\u27e829\u27e9 https://docs.rs/once_cell/latest/once_cell/#related-crates: \u00a7\n\u27e830\u27e9 https://github.com/niklasf/double-checked-cell: double-checked-cell\n\u27e831\u27e9 https://crates.io/crates/lazy-init: lazy-init\n\u27e832\u27e9 https://crates.io/crates/lazycell: lazycell\n\u27e833\u27e9 https://crates.io/crates/mitochondria: mitochondria\n\u27e834\u27e9 https://crates.io/crates/lazy_static: lazy_static\n\u27e835\u27e9 https://docs.rs/once_cell/latest/once_cell/#modules: \u00a7\n\u27e836\u27e9 https://docs.rs/once_cell/latest/once_cell/race/index.html: mod once_cell::race - race\n\u27e837\u27e9 https://docs.rs/once_cell/latest/once_cell/sync/index.html: mod once_cell::sync - sync\n\u27e838\u27e9 https://docs.rs/once_cell/latest/once_cell/unsync/index.html: mod once_cell::unsync - unsync\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `once_cell` crate provides `OnceCell` and `Lazy` types for single-assignment and lazy initialization of values, supporting both thread-safe (`sync`) and single-threaded (`unsync`) variants. It simplifies patterns like global data initialization, lazy evaluation, and cyclic data structures, offering a more ergonomic alternative to `lazy_static` and similar constructs. Key features include `get_or_init` for lazy computation, compatibility with `no_std`, and integration with custom mutexes via related crates.",
    "feature_summary": null,
    "use_case": "Utilities",
    "score": 8.5,
    "factual_counterfactual": "### Pair 1: Thread Safety\n\u2705 **Factual:** The `sync::OnceCell` type in the `once_cell` crate is thread-safe and implements the `Sync` trait, allowing safe initialization in multi-threaded environments.  \n\u274c **Counterfactual:** The `unsync::OnceCell` type is thread-safe and can be used safely in multi-threaded environments without implementing the `Sync` trait.\n\n---\n\n### Pair 2: Lazy Initialization\n\u2705 **Factual:** The `sync::Lazy` type in the `once_cell` crate provides a convenient way to lazily initialize global data without requiring a macro like `lazy_static!`.  \n\u274c **Counterfactual:** The `sync::Lazy` type in the `once_cell` crate requires the use of a macro to perform lazy initialization.\n\n---\n\n### Pair 3: Comparison with `std::sync::Once`\n\u2705 **Factual:** The `once_cell` crate builds on `std::sync::Once` to provide a more ergonomic API for single-assignment cells, supporting both thread-safe and single-threaded use cases.  \n\u274c **Counterfactual:** The `once_cell` crate directly replaces `std::sync::Once` and does not rely on it for its implementation.",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}