{
    "name": "embassy-executor",
    "version": "0.7.0",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/embassy-executor/latest/embassy_executor/all.html \"show sidebar\")\n# Crate embassy_executorCopy item path\n[Settings](https://docs.rs/embassy-executor/latest/settings.html)\n[Help](https://docs.rs/embassy-executor/latest/help.html)\nSummary[Source](https://docs.rs/embassy-executor/latest/src/embassy_executor/lib.rs.html#1-150)\nExpand description\n## [\u00a7](https://docs.rs/embassy-executor/latest/embassy_executor/#embassy-executor)embassy-executor\nAn async/await executor designed for embedded usage.\n  * No `alloc`, no heap needed.\n  * With nightly Rust, task futures can be fully statically allocated.\n  * No \u201cfixed capacity\u201d data structures, executor works with 1 or 1000 tasks without needing config/tuning.\n  * Integrated timer queue: sleeping is easy, just do `Timer::after_secs(1).await;`.\n  * No busy-loop polling: CPU sleeps when there\u2019s no work to do, using interrupts or `WFE/SEV`.\n  * Efficient polling: a wake will only poll the woken task, not all of them.\n  * Fair: a task can\u2019t monopolize CPU time even if it\u2019s constantly being woken. All other tasks get a chance to run before a given task gets polled for the second time.\n  * Creating multiple executor instances is supported, to run tasks with multiple priority levels. This allows higher-priority tasks to preempt lower-priority tasks.\n\n\n### [\u00a7](https://docs.rs/embassy-executor/latest/embassy_executor/#task-arena)Task arena\nWhen the `nightly` Cargo feature is not enabled, `embassy-executor` allocates tasks out of an arena (a very simple bump allocator).\nIf the task arena gets full, the program will panic at runtime. To guarantee this doesn\u2019t happen, you must set the size to the sum of sizes of all tasks.\nTasks are allocated from the arena when spawned for the first time. If the task exists, the allocation is not released to the arena, but can be reused to spawn the task again. For multiple-instance tasks (like `#[embassy_executor::task(pool_size = 4)]`), the first spawn will allocate memory for all instances. This is done for performance and to increase predictability (for example, spawning at least 1 instance of every task at boot guarantees an immediate panic if the arena is too small, while allocating instances on-demand could delay the panic to only when the program is under load).\nThe arena size can be configured in two ways:\n  * Via Cargo features: enable a Cargo feature like `task-arena-size-8192`. Only a selection of values is available, see [Task Area Sizes](https://docs.rs/embassy-executor/latest/embassy_executor/#task-arena-size) for reference.\n  * Via environment variables at build time: set the variable named `EMBASSY_EXECUTOR_TASK_ARENA_SIZE`. For example `EMBASSY_EXECUTOR_TASK_ARENA_SIZE=4321 cargo build`. You can also set them in the `[env]` section of `.cargo/config.toml`. Any value can be set, unlike with Cargo features.\n\n\nEnvironment variables take precedence over Cargo features. If two Cargo features are enabled for the same setting with different values, compilation fails.\n### [\u00a7](https://docs.rs/embassy-executor/latest/embassy_executor/#statically-allocating-tasks)Statically allocating tasks\nWhen using nightly Rust, enable the `nightly` Cargo feature. This will make `embassy-executor` use the `type_alias_impl_trait` feature to allocate all tasks in `static`s. Each task gets its own `static`, with the exact size to hold the task (or multiple instances of it, if using `pool_size`) calculated automatically at compile time. If tasks don\u2019t fit in RAM, this is detected at compile time by the linker. Runtime panics due to running out of memory are not possible.\nThe configured arena size is ignored, no arena is used at all.\n### [\u00a7](https://docs.rs/embassy-executor/latest/embassy_executor/#feature-flags)Feature flags\n  * `nightly` \u2014 Enable nightly-only features\n\n\n#### [\u00a7](https://docs.rs/embassy-executor/latest/embassy_executor/#architecture)Architecture\n  * `arch-std` \u2014 std\n  * `arch-cortex-m` \u2014 Cortex-M\n  * `arch-riscv32` \u2014 RISC-V 32\n  * `arch-wasm` \u2014 WASM\n  * `arch-avr` \u2014 AVR\n  * `arch-spin` \u2014 spin (architecture agnostic; never sleeps)\n\n\n#### [\u00a7](https://docs.rs/embassy-executor/latest/embassy_executor/#executor)Executor\n  * `executor-thread` \u2014 Enable the thread-mode executor (using WFE/SEV in Cortex-M, WFI in other embedded archs)\n  * `executor-interrupt` \u2014 Enable the interrupt-mode executor (available in Cortex-M only)\n  * `trace` \u2014 Enable tracing support (adds some overhead)\n  * `rtos-trace` \u2014 Enable support for rtos-trace framework\n\n\n#### [\u00a7](https://docs.rs/embassy-executor/latest/embassy_executor/#timer-item-payload-size)Timer Item Payload Size\nSets the size of the payload for timer items, allowing integrated timer implementors to store additional data in the timer item. The payload field will be aligned to this value as well. If these features are not defined, the timer item will contain no payload field.\n  * `timer-item-payload-size-1` \u2014 1 bytes\n  * `timer-item-payload-size-2` \u2014 2 bytes\n  * `timer-item-payload-size-4` \u2014 4 bytes\n  * `timer-item-payload-size-8` \u2014 8 bytes\n\n\n#### [\u00a7](https://docs.rs/embassy-executor/latest/embassy_executor/#task-arena-size)Task Arena Size\nSets the [task arena](https://docs.rs/embassy-executor/latest/embassy_executor/#task-arena) size. Necessary if you\u2019re not using `nightly`.\nPreconfigured Task Arena Sizes:\n  * `task-arena-size-64` \u2014 64\n  * `task-arena-size-128` \u2014 128\n  * `task-arena-size-192` \u2014 192\n  * `task-arena-size-256` \u2014 256\n  * `task-arena-size-320` \u2014 320\n  * `task-arena-size-384` \u2014 384\n  * `task-arena-size-512` \u2014 512\n  * `task-arena-size-640` \u2014 640\n  * `task-arena-size-768` \u2014 768\n  * `task-arena-size-1024` \u2014 1024\n  * `task-arena-size-1280` \u2014 1280\n  * `task-arena-size-1536` \u2014 1536\n  * `task-arena-size-2048` \u2014 2048\n  * `task-arena-size-2560` \u2014 2560\n  * `task-arena-size-3072` \u2014 3072\n  * `task-arena-size-4096` \u2014 4096 (default)\n  * `task-arena-size-5120` \u2014 5120\n  * `task-arena-size-6144` \u2014 6144\n  * `task-arena-size-8192` \u2014 8192\n  * `task-arena-size-10240` \u2014 10240\n  * `task-arena-size-12288` \u2014 12288\n  * `task-arena-size-16384` \u2014 16384\n  * `task-arena-size-20480` \u2014 20480\n  * `task-arena-size-24576` \u2014 24576\n  * `task-arena-size-32768` \u2014 32768\n  * `task-arena-size-40960` \u2014 40960\n  * `task-arena-size-49152` \u2014 49152\n  * `task-arena-size-65536` \u2014 65536\n  * `task-arena-size-81920` \u2014 81920\n  * `task-arena-size-98304` \u2014 98304\n  * `task-arena-size-131072` \u2014 131072\n  * `task-arena-size-163840` \u2014 163840\n  * `task-arena-size-196608` \u2014 196608\n  * `task-arena-size-262144` \u2014 262144\n  * `task-arena-size-327680` \u2014 327680\n  * `task-arena-size-393216` \u2014 393216\n  * `task-arena-size-524288` \u2014 524288\n  * `task-arena-size-655360` \u2014 655360\n  * `task-arena-size-786432` \u2014 786432\n  * `task-arena-size-1048576` \u2014 1048576\n\n\n## Modules[\u00a7](https://docs.rs/embassy-executor/latest/embassy_executor/#modules)\n\n[raw](https://docs.rs/embassy-executor/latest/embassy_executor/raw/index.html \"mod embassy_executor::raw\")\n    Raw executor.\n## Structs[\u00a7](https://docs.rs/embassy-executor/latest/embassy_executor/#structs)\n\n[Executor](https://docs.rs/embassy-executor/latest/embassy_executor/struct.Executor.html \"struct embassy_executor::Executor\")\n    Thread mode executor, using WFE/SEV.\n\n[InterruptExecutor](https://docs.rs/embassy-executor/latest/embassy_executor/struct.InterruptExecutor.html \"struct embassy_executor::InterruptExecutor\")\n    Interrupt mode executor.\n\n[SendSpawner](https://docs.rs/embassy-executor/latest/embassy_executor/struct.SendSpawner.html \"struct embassy_executor::SendSpawner\")\n    Handle to spawn tasks into an executor from any thread.\n\n[SpawnToken](https://docs.rs/embassy-executor/latest/embassy_executor/struct.SpawnToken.html \"struct embassy_executor::SpawnToken\")\n    Token to spawn a newly-created task in an executor.\n\n[Spawner](https://docs.rs/embassy-executor/latest/embassy_executor/struct.Spawner.html \"struct embassy_executor::Spawner\")\n    Handle to spawn tasks into an executor.\n## Enums[\u00a7](https://docs.rs/embassy-executor/latest/embassy_executor/#enums)\n\n[SpawnError](https://docs.rs/embassy-executor/latest/embassy_executor/enum.SpawnError.html \"enum embassy_executor::SpawnError\")\n    Error returned when spawning a task.\n## Attribute Macros[\u00a7](https://docs.rs/embassy-executor/latest/embassy_executor/#attributes)\n\n[main](https://docs.rs/embassy-executor/latest/embassy_executor/attr.main.html \"attr embassy_executor::main\")\n    Creates a new `executor` instance and declares an application entry point for Cortex-M spawning the corresponding function body as an async task.\n\n[task](https://docs.rs/embassy-executor/latest/embassy_executor/attr.task.html \"attr embassy_executor::task\")\n    Declares an async task that can be run by `embassy-executor`. The optional `pool_size` parameter can be used to specify how many concurrent tasks can be spawned (default is 1) for the function.\n",
        "markdown_with_citations": "[](https://docs.rs/embassy-executor/latest/embassy_executor/all.html \"show sidebar\")\n# Crate embassy_executorCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\n## \u00a7\u27e84\u27e9embassy-executor\nAn async/await executor designed for embedded usage.\n  * No `alloc`, no heap needed.\n  * With nightly Rust, task futures can be fully statically allocated.\n  * No \u201cfixed capacity\u201d data structures, executor works with 1 or 1000 tasks without needing config/tuning.\n  * Integrated timer queue: sleeping is easy, just do `Timer::after_secs(1).await;`.\n  * No busy-loop polling: CPU sleeps when there\u2019s no work to do, using interrupts or `WFE/SEV`.\n  * Efficient polling: a wake will only poll the woken task, not all of them.\n  * Fair: a task can\u2019t monopolize CPU time even if it\u2019s constantly being woken. All other tasks get a chance to run before a given task gets polled for the second time.\n  * Creating multiple executor instances is supported, to run tasks with multiple priority levels. This allows higher-priority tasks to preempt lower-priority tasks.\n\n\n### \u00a7\u27e85\u27e9Task arena\nWhen the `nightly` Cargo feature is not enabled, `embassy-executor` allocates tasks out of an arena (a very simple bump allocator).\nIf the task arena gets full, the program will panic at runtime. To guarantee this doesn\u2019t happen, you must set the size to the sum of sizes of all tasks.\nTasks are allocated from the arena when spawned for the first time. If the task exists, the allocation is not released to the arena, but can be reused to spawn the task again. For multiple-instance tasks (like `#[embassy_executor::task(pool_size = 4)]`), the first spawn will allocate memory for all instances. This is done for performance and to increase predictability (for example, spawning at least 1 instance of every task at boot guarantees an immediate panic if the arena is too small, while allocating instances on-demand could delay the panic to only when the program is under load).\nThe arena size can be configured in two ways:\n  * Via Cargo features: enable a Cargo feature like `task-arena-size-8192`. Only a selection of values is available, see Task Area Sizes\u27e86\u27e9 for reference.\n  * Via environment variables at build time: set the variable named `EMBASSY_EXECUTOR_TASK_ARENA_SIZE`. For example `EMBASSY_EXECUTOR_TASK_ARENA_SIZE=4321 cargo build`. You can also set them in the `[env]` section of `.cargo/config.toml`. Any value can be set, unlike with Cargo features.\n\n\nEnvironment variables take precedence over Cargo features. If two Cargo features are enabled for the same setting with different values, compilation fails.\n### \u00a7\u27e87\u27e9Statically allocating tasks\nWhen using nightly Rust, enable the `nightly` Cargo feature. This will make `embassy-executor` use the `type_alias_impl_trait` feature to allocate all tasks in `static`s. Each task gets its own `static`, with the exact size to hold the task (or multiple instances of it, if using `pool_size`) calculated automatically at compile time. If tasks don\u2019t fit in RAM, this is detected at compile time by the linker. Runtime panics due to running out of memory are not possible.\nThe configured arena size is ignored, no arena is used at all.\n### \u00a7\u27e88\u27e9Feature flags\n  * `nightly` \u2014 Enable nightly-only features\n\n\n#### \u00a7\u27e89\u27e9Architecture\n  * `arch-std` \u2014 std\n  * `arch-cortex-m` \u2014 Cortex-M\n  * `arch-riscv32` \u2014 RISC-V 32\n  * `arch-wasm` \u2014 WASM\n  * `arch-avr` \u2014 AVR\n  * `arch-spin` \u2014 spin (architecture agnostic; never sleeps)\n\n\n#### \u00a7\u27e810\u27e9Executor\n  * `executor-thread` \u2014 Enable the thread-mode executor (using WFE/SEV in Cortex-M, WFI in other embedded archs)\n  * `executor-interrupt` \u2014 Enable the interrupt-mode executor (available in Cortex-M only)\n  * `trace` \u2014 Enable tracing support (adds some overhead)\n  * `rtos-trace` \u2014 Enable support for rtos-trace framework\n\n\n#### \u00a7\u27e811\u27e9Timer Item Payload Size\nSets the size of the payload for timer items, allowing integrated timer implementors to store additional data in the timer item. The payload field will be aligned to this value as well. If these features are not defined, the timer item will contain no payload field.\n  * `timer-item-payload-size-1` \u2014 1 bytes\n  * `timer-item-payload-size-2` \u2014 2 bytes\n  * `timer-item-payload-size-4` \u2014 4 bytes\n  * `timer-item-payload-size-8` \u2014 8 bytes\n\n\n#### \u00a7\u27e86\u27e9Task Arena Size\nSets the task arena\u27e85\u27e9 size. Necessary if you\u2019re not using `nightly`.\nPreconfigured Task Arena Sizes:\n  * `task-arena-size-64` \u2014 64\n  * `task-arena-size-128` \u2014 128\n  * `task-arena-size-192` \u2014 192\n  * `task-arena-size-256` \u2014 256\n  * `task-arena-size-320` \u2014 320\n  * `task-arena-size-384` \u2014 384\n  * `task-arena-size-512` \u2014 512\n  * `task-arena-size-640` \u2014 640\n  * `task-arena-size-768` \u2014 768\n  * `task-arena-size-1024` \u2014 1024\n  * `task-arena-size-1280` \u2014 1280\n  * `task-arena-size-1536` \u2014 1536\n  * `task-arena-size-2048` \u2014 2048\n  * `task-arena-size-2560` \u2014 2560\n  * `task-arena-size-3072` \u2014 3072\n  * `task-arena-size-4096` \u2014 4096 (default)\n  * `task-arena-size-5120` \u2014 5120\n  * `task-arena-size-6144` \u2014 6144\n  * `task-arena-size-8192` \u2014 8192\n  * `task-arena-size-10240` \u2014 10240\n  * `task-arena-size-12288` \u2014 12288\n  * `task-arena-size-16384` \u2014 16384\n  * `task-arena-size-20480` \u2014 20480\n  * `task-arena-size-24576` \u2014 24576\n  * `task-arena-size-32768` \u2014 32768\n  * `task-arena-size-40960` \u2014 40960\n  * `task-arena-size-49152` \u2014 49152\n  * `task-arena-size-65536` \u2014 65536\n  * `task-arena-size-81920` \u2014 81920\n  * `task-arena-size-98304` \u2014 98304\n  * `task-arena-size-131072` \u2014 131072\n  * `task-arena-size-163840` \u2014 163840\n  * `task-arena-size-196608` \u2014 196608\n  * `task-arena-size-262144` \u2014 262144\n  * `task-arena-size-327680` \u2014 327680\n  * `task-arena-size-393216` \u2014 393216\n  * `task-arena-size-524288` \u2014 524288\n  * `task-arena-size-655360` \u2014 655360\n  * `task-arena-size-786432` \u2014 786432\n  * `task-arena-size-1048576` \u2014 1048576\n\n\n## Modules\u00a7\u27e812\u27e9\n\nraw\u27e813\u27e9\n    Raw executor.\n## Structs\u00a7\u27e814\u27e9\n\nExecutor\u27e815\u27e9\n    Thread mode executor, using WFE/SEV.\n\nInterruptExecutor\u27e816\u27e9\n    Interrupt mode executor.\n\nSendSpawner\u27e817\u27e9\n    Handle to spawn tasks into an executor from any thread.\n\nSpawnToken\u27e818\u27e9\n    Token to spawn a newly-created task in an executor.\n\nSpawner\u27e819\u27e9\n    Handle to spawn tasks into an executor.\n## Enums\u00a7\u27e820\u27e9\n\nSpawnError\u27e821\u27e9\n    Error returned when spawning a task.\n## Attribute Macros\u00a7\u27e822\u27e9\n\nmain\u27e823\u27e9\n    Creates a new `executor` instance and declares an application entry point for Cortex-M spawning the corresponding function body as an async task.\n\ntask\u27e824\u27e9\n    Declares an async task that can be run by `embassy-executor`. The optional `pool_size` parameter can be used to specify how many concurrent tasks can be spawned (default is 1) for the function.\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/embassy-executor/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/embassy-executor/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/embassy-executor/latest/src/embassy_executor/lib.rs.html#1-150: Source\n\u27e84\u27e9 https://docs.rs/embassy-executor/latest/embassy_executor/#embassy-executor: \u00a7\n\u27e85\u27e9 https://docs.rs/embassy-executor/latest/embassy_executor/#task-arena: \u00a7\n\u27e86\u27e9 https://docs.rs/embassy-executor/latest/embassy_executor/#task-arena-size: Task Area Sizes\n\u27e87\u27e9 https://docs.rs/embassy-executor/latest/embassy_executor/#statically-allocating-tasks: \u00a7\n\u27e88\u27e9 https://docs.rs/embassy-executor/latest/embassy_executor/#feature-flags: \u00a7\n\u27e89\u27e9 https://docs.rs/embassy-executor/latest/embassy_executor/#architecture: \u00a7\n\u27e810\u27e9 https://docs.rs/embassy-executor/latest/embassy_executor/#executor: \u00a7\n\u27e811\u27e9 https://docs.rs/embassy-executor/latest/embassy_executor/#timer-item-payload-size: \u00a7\n\u27e812\u27e9 https://docs.rs/embassy-executor/latest/embassy_executor/#modules: \u00a7\n\u27e813\u27e9 https://docs.rs/embassy-executor/latest/embassy_executor/raw/index.html: mod embassy_executor::raw - raw\n\u27e814\u27e9 https://docs.rs/embassy-executor/latest/embassy_executor/#structs: \u00a7\n\u27e815\u27e9 https://docs.rs/embassy-executor/latest/embassy_executor/struct.Executor.html: struct embassy_executor::Executor - Executor\n\u27e816\u27e9 https://docs.rs/embassy-executor/latest/embassy_executor/struct.InterruptExecutor.html: struct embassy_executor::InterruptExecutor - InterruptExecutor\n\u27e817\u27e9 https://docs.rs/embassy-executor/latest/embassy_executor/struct.SendSpawner.html: struct embassy_executor::SendSpawner - SendSpawner\n\u27e818\u27e9 https://docs.rs/embassy-executor/latest/embassy_executor/struct.SpawnToken.html: struct embassy_executor::SpawnToken - SpawnToken\n\u27e819\u27e9 https://docs.rs/embassy-executor/latest/embassy_executor/struct.Spawner.html: struct embassy_executor::Spawner - Spawner\n\u27e820\u27e9 https://docs.rs/embassy-executor/latest/embassy_executor/#enums: \u00a7\n\u27e821\u27e9 https://docs.rs/embassy-executor/latest/embassy_executor/enum.SpawnError.html: enum embassy_executor::SpawnError - SpawnError\n\u27e822\u27e9 https://docs.rs/embassy-executor/latest/embassy_executor/#attributes: \u00a7\n\u27e823\u27e9 https://docs.rs/embassy-executor/latest/embassy_executor/attr.main.html: attr embassy_executor::main - main\n\u27e824\u27e9 https://docs.rs/embassy-executor/latest/embassy_executor/attr.task.html: attr embassy_executor::task - task\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `embassy-executor` crate is an async/await executor optimized for embedded systems, requiring no heap allocation and supporting fully static task allocation with nightly Rust. It features integrated timers, efficient and fair task polling, and support for multiple executors to enable task prioritization. Additionally, it offers configurable task arenas for stable Rust and architecture-specific modes like thread or interrupt-based execution.",
    "feature_summary": null,
    "use_case": "Utilities",
    "score": 6.0,
    "factual_counterfactual": "### Pair 1: Task Allocation\n\u2705 Factual: The `embassy-executor` crate allows tasks to be statically allocated when the `nightly` Cargo feature is enabled, ensuring compile-time detection of memory overflows without runtime panics.  \n\u274c Counterfactual: The `embassy-executor` crate always uses static allocation for tasks, regardless of whether the `nightly` Cargo feature is enabled.\n\n---\n\n### Pair 2: Task Arena Configuration\n\u2705 Factual: When the `nightly` feature is not enabled, `embassy-executor` uses a task arena with a configurable size, which can be set via environment variables or preconfigured Cargo features.  \n\u274c Counterfactual: The task arena size in `embassy-executor` can only be configured using environment variables and does not support preconfigured Cargo features.\n\n---\n\n### Pair 3: Executor Instances\n\u2705 Factual: `embassy-executor` supports creating multiple executor instances to run tasks with different priority levels, allowing higher-priority tasks to preempt lower-priority ones.  \n\u274c Counterfactual: `embassy-executor` only supports a single executor instance, making it impossible to implement task prioritization.",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}