{
    "name": "tarpc",
    "version": "0.36.0",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/tarpc/latest/tarpc/all.html \"show sidebar\")\n# Crate tarpcCopy item path\n[Settings](https://docs.rs/tarpc/latest/settings.html)\n[Help](https://docs.rs/tarpc/latest/help.html)\nSummary[Source](https://docs.rs/tarpc/latest/src/tarpc/lib.rs.html#6-557)\nExpand description\n _Disclaimer_ : This is not an official Google product.\ntarpc is an RPC framework for rust with a focus on ease of use. Defining a service can be done in just a few lines of code, and most of the boilerplate of writing a server is taken care of for you.\n[Documentation](https://docs.rs/crate/tarpc/)\n### [\u00a7](https://docs.rs/tarpc/latest/tarpc/#what-is-an-rpc-framework)What is an RPC framework?\n\u201cRPC\u201d stands for \u201cRemote Procedure Call,\u201d a function call where the work of producing the return value is being done somewhere else. When an rpc function is invoked, behind the scenes the function contacts some other process somewhere and asks them to evaluate the function instead. The original function then returns the value produced by the other process.\nRPC frameworks are a fundamental building block of most microservices-oriented architectures. Two well-known ones are [gRPC](http://www.grpc.io) and [Cap\u2019n Proto](https://capnproto.org/).\ntarpc differentiates itself from other RPC frameworks by defining the schema in code, rather than in a separate language such as .proto. This means there\u2019s no separate compilation process, and no context switching between different languages.\nSome other features of tarpc:\n  * Pluggable transport: any type implementing `Stream<Item = Request> + Sink<Response>` can be used as a transport to connect the client and server.\n  * `Send + 'static` optional: if the transport doesn\u2019t require it, neither does tarpc!\n  * Cascading cancellation: dropping a request will send a cancellation message to the server. The server will cease any unfinished work on the request, subsequently cancelling any of its own requests, repeating for the entire chain of transitive dependencies.\n  * Configurable deadlines and deadline propagation: request deadlines default to 10s if unspecified. The server will automatically cease work when the deadline has passed. Any requests sent by the server that use the request context will propagate the request deadline. For example, if a server is handling a request with a 10s deadline, does 2s of work, then sends a request to another server, that server will see an 8s deadline.\n  * Distributed tracing: tarpc is instrumented with [tracing](https://github.com/tokio-rs/tracing) primitives extended with [OpenTelemetry](https://opentelemetry.io/) traces. Using a compatible tracing subscriber like [OTLP](https://github.com/open-telemetry/opentelemetry-rust/tree/main/opentelemetry-otlp), each RPC can be traced through the client, server, and other dependencies downstream of the server. Even for applications not connected to a distributed tracing collector, the instrumentation can also be ingested by regular loggers like [env_logger](https://github.com/env-logger-rs/env_logger/).\n  * Serde serialization: enabling the `serde1` Cargo feature will make service requests and responses `Serialize + Deserialize`. It\u2019s entirely optional, though: in-memory transports can be used, as well, so the price of serialization doesn\u2019t have to be paid when it\u2019s not needed.\n\n\n### [\u00a7](https://docs.rs/tarpc/latest/tarpc/#usage)Usage\nAdd to your `Cargo.toml` dependencies:\n```\ntarpc = \"0.36\"\n```\n\nThe `tarpc::service` attribute expands to a collection of items that form an rpc service. These generated types make it easy and ergonomic to write servers with less boilerplate. Simply implement the generated service trait, and you\u2019re off to the races!\n### [\u00a7](https://docs.rs/tarpc/latest/tarpc/#example)Example\nThis example uses [tokio](https://tokio.rs), so add the following dependencies to your `Cargo.toml`:\n```\nanyhow = \"1.0\"\nfutures = \"0.3\"\ntarpc = { version = \"0.36\", features = [\"tokio1\"] }\ntokio = { version = \"1.0\", features = [\"macros\"] }\n```\n\nIn the following example, we use an in-process channel for communication between client and server. In real code, you will likely communicate over the network. For a more real-world example, see [example-service](https://docs.rs/tarpc/latest/tarpc/example-service).\nFirst, let\u2019s set up the dependencies and service definition.\n```\n\nuse futures::{\n  prelude::*,\n};\nuse tarpc::{\n  client, context,\n  server::{self, incoming::Incoming, Channel},\n};\n// This is the service definition. It looks a lot like a trait definition.\n// It defines one RPC, hello, which takes one arg, name, and returns a String.\n#[tarpc::service]\ntrait World {\n  /// Returns a greeting for name.\n  async fn hello(name: String) -> String;\n}\n```\n\nThis service definition generates a trait called `World`. Next we need to implement it for our Server struct.\n```\n// This is the type that implements the generated World trait. It is the business logic\n// and is used to start the server.\n#[derive(Clone)]\nstruct HelloServer;\nimpl World for HelloServer {\n  // Each defined rpc generates an async fn that serves the RPC\n  async fn hello(self, _: context::Context, name: String) -> String {\n    format!(\"Hello, {name}!\")\n  }\n}\n```\n\nLastly let\u2019s write our `main` that will start the server. While this example uses an [in-process channel](https://docs.rs/tarpc/latest/tarpc/transport/channel/index.html \"mod tarpc::transport::channel\"), tarpc also ships a generic [`serde_transport`](https://docs.rs/tarpc/latest/tarpc/serde_transport/index.html \"mod tarpc::serde_transport\") behind the `serde-transport` feature, with additional [TCP](https://docs.rs/tarpc/latest/tarpc/serde_transport/tcp/index.html \"mod tarpc::serde_transport::tcp\") functionality available behind the `tcp` feature.\n```\n  // Each defined rpc generates an async fn that serves the RPC\n#[tokio::main]\nasync fn main() -> anyhow::Result<()> {\n  let (client_transport, server_transport) = tarpc::transport::channel::unbounded();\n  let server = server::BaseChannel::with_defaults(server_transport);\n  tokio::spawn(\n    server.execute(HelloServer.serve())\n      // Handle all requests concurrently.\n      .for_each(|response| async move {\n        tokio::spawn(response);\n      }));\n  // WorldClient is generated by the #[tarpc::service] attribute. It has a constructor `new`\n  // that takes a config and any Transport as input.\n  let mut client = WorldClient::new(client::Config::default(), client_transport).spawn();\n  // The client has an RPC method for each RPC defined in the annotated trait. It takes the same\n  // args as defined, with the addition of a Context, which is always the first arg. The Context\n  // specifies a deadline and trace information which can be helpful in debugging requests.\n  let hello = client.hello(context::current(), \"Stim\".to_string()).await?;\n  println!(\"{hello}\");\n  Ok(())\n}\n```\n\n### [\u00a7](https://docs.rs/tarpc/latest/tarpc/#service-documentation)Service Documentation\nUse `cargo doc` as you normally would to see the documentation created for all items expanded by a `service!` invocation.\n## Re-exports[\u00a7](https://docs.rs/tarpc/latest/tarpc/#reexports)\n\n`pub use tokio_serde[](https://docs.rs/tokio-serde/0.9.0/x86_64-unknown-linux-gnu/tokio_serde/index.html \"mod tokio_serde\");`\n\n\n`pub use tokio_util[](https://docs.rs/tokio-util/0.7.15/x86_64-unknown-linux-gnu/tokio_util/index.html \"mod tokio_util\");`\n\n## Modules[\u00a7](https://docs.rs/tarpc/latest/tarpc/#modules)\n\n[client](https://docs.rs/tarpc/latest/tarpc/client/index.html \"mod tarpc::client\")\n    Provides a client that connects to a server and sends multiplexed requests.\n\n[context](https://docs.rs/tarpc/latest/tarpc/context/index.html \"mod tarpc::context\")\n    Provides a request context that carries a deadline and trace context. This context is sent from client to server and is used by the server to enforce response deadlines.\n\n[serde_transport](https://docs.rs/tarpc/latest/tarpc/serde_transport/index.html \"mod tarpc::serde_transport\")`serde-transport`\n    A generic Serde-based `Transport` that can serialize anything supported by `tokio-serde` via any medium that implements `AsyncRead` and `AsyncWrite`.\n\n[server](https://docs.rs/tarpc/latest/tarpc/server/index.html \"mod tarpc::server\")\n    Provides a server that concurrently handles many connections sending multiplexed requests.\n\n[trace](https://docs.rs/tarpc/latest/tarpc/trace/index.html \"mod tarpc::trace\")\n    Provides building blocks for tracing distributed programs.\n\n[transport](https://docs.rs/tarpc/latest/tarpc/transport/index.html \"mod tarpc::transport\")\n    Provides a [`Transport`](https://docs.rs/tarpc/latest/tarpc/trait.Transport.html \"trait tarpc::Transport\") trait as well as implementations.\n## Structs[\u00a7](https://docs.rs/tarpc/latest/tarpc/#structs)\n\n[Request](https://docs.rs/tarpc/latest/tarpc/struct.Request.html \"struct tarpc::Request\")\n    A request from a client to a server.\n\n[Response](https://docs.rs/tarpc/latest/tarpc/struct.Response.html \"struct tarpc::Response\")\n    A response from a server to a client.\n\n[ServerError](https://docs.rs/tarpc/latest/tarpc/struct.ServerError.html \"struct tarpc::ServerError\")\n    An error indicating the server aborted the request early, e.g., due to request throttling.\n## Enums[\u00a7](https://docs.rs/tarpc/latest/tarpc/#enums)\n\n[ChannelError](https://docs.rs/tarpc/latest/tarpc/enum.ChannelError.html \"enum tarpc::ChannelError\")\n    Critical errors that result in a Channel disconnecting.\n\n[ClientMessage](https://docs.rs/tarpc/latest/tarpc/enum.ClientMessage.html \"enum tarpc::ClientMessage\")\n    A message from a client to a server.\n## Traits[\u00a7](https://docs.rs/tarpc/latest/tarpc/#traits)\n\n[RequestName](https://docs.rs/tarpc/latest/tarpc/trait.RequestName.html \"trait tarpc::RequestName\")\n    Implemented by the request types generated by tarpc::service.\n\n[Transport](https://docs.rs/tarpc/latest/tarpc/trait.Transport.html \"trait tarpc::Transport\")\n    A bidirectional stream ([`Sink`](https://docs.rs/futures-sink/0.3.31/x86_64-unknown-linux-gnu/futures_sink/trait.Sink.html \"trait futures_sink::Sink\") + [`Stream`](https://docs.rs/futures-core/0.3.31/x86_64-unknown-linux-gnu/futures_core/stream/trait.Stream.html \"trait futures_core::stream::Stream\")) of messages.\n## Attribute Macros[\u00a7](https://docs.rs/tarpc/latest/tarpc/#attributes)\n\n[derive_serde](https://docs.rs/tarpc/latest/tarpc/attr.derive_serde.html \"attr tarpc::derive_serde\")\n    A helper attribute to avoid a direct dependency on Serde.\n\n[service](https://docs.rs/tarpc/latest/tarpc/attr.service.html \"attr tarpc::service\")\n    The main macro that creates RPC services.\n",
        "markdown_with_citations": "[](https://docs.rs/tarpc/latest/tarpc/all.html \"show sidebar\")\n# Crate tarpcCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\n _Disclaimer_ : This is not an official Google product.\ntarpc is an RPC framework for rust with a focus on ease of use. Defining a service can be done in just a few lines of code, and most of the boilerplate of writing a server is taken care of for you.\nDocumentation\u27e84\u27e9\n### \u00a7\u27e85\u27e9What is an RPC framework?\n\u201cRPC\u201d stands for \u201cRemote Procedure Call,\u201d a function call where the work of producing the return value is being done somewhere else. When an rpc function is invoked, behind the scenes the function contacts some other process somewhere and asks them to evaluate the function instead. The original function then returns the value produced by the other process.\nRPC frameworks are a fundamental building block of most microservices-oriented architectures. Two well-known ones are gRPC\u27e86\u27e9 and Cap\u2019n Proto\u27e87\u27e9.\ntarpc differentiates itself from other RPC frameworks by defining the schema in code, rather than in a separate language such as .proto. This means there\u2019s no separate compilation process, and no context switching between different languages.\nSome other features of tarpc:\n  * Pluggable transport: any type implementing `Stream<Item = Request> + Sink<Response>` can be used as a transport to connect the client and server.\n  * `Send + 'static` optional: if the transport doesn\u2019t require it, neither does tarpc!\n  * Cascading cancellation: dropping a request will send a cancellation message to the server. The server will cease any unfinished work on the request, subsequently cancelling any of its own requests, repeating for the entire chain of transitive dependencies.\n  * Configurable deadlines and deadline propagation: request deadlines default to 10s if unspecified. The server will automatically cease work when the deadline has passed. Any requests sent by the server that use the request context will propagate the request deadline. For example, if a server is handling a request with a 10s deadline, does 2s of work, then sends a request to another server, that server will see an 8s deadline.\n  * Distributed tracing: tarpc is instrumented with tracing\u27e88\u27e9 primitives extended with OpenTelemetry\u27e89\u27e9 traces. Using a compatible tracing subscriber like OTLP\u27e810\u27e9, each RPC can be traced through the client, server, and other dependencies downstream of the server. Even for applications not connected to a distributed tracing collector, the instrumentation can also be ingested by regular loggers like env_logger\u27e811\u27e9.\n  * Serde serialization: enabling the `serde1` Cargo feature will make service requests and responses `Serialize + Deserialize`. It\u2019s entirely optional, though: in-memory transports can be used, as well, so the price of serialization doesn\u2019t have to be paid when it\u2019s not needed.\n\n\n### \u00a7\u27e812\u27e9Usage\nAdd to your `Cargo.toml` dependencies:\n```\ntarpc = \"0.36\"\n```\n\nThe `tarpc::service` attribute expands to a collection of items that form an rpc service. These generated types make it easy and ergonomic to write servers with less boilerplate. Simply implement the generated service trait, and you\u2019re off to the races!\n### \u00a7\u27e813\u27e9Example\nThis example uses tokio\u27e814\u27e9, so add the following dependencies to your `Cargo.toml`:\n```\nanyhow = \"1.0\"\nfutures = \"0.3\"\ntarpc = { version = \"0.36\", features = [\"tokio1\"] }\ntokio = { version = \"1.0\", features = [\"macros\"] }\n```\n\nIn the following example, we use an in-process channel for communication between client and server. In real code, you will likely communicate over the network. For a more real-world example, see example-service\u27e815\u27e9.\nFirst, let\u2019s set up the dependencies and service definition.\n```\n\nuse futures::{\n  prelude::*,\n};\nuse tarpc::{\n  client, context,\n  server::{self, incoming::Incoming, Channel},\n};\n// This is the service definition. It looks a lot like a trait definition.\n// It defines one RPC, hello, which takes one arg, name, and returns a String.\n#[tarpc::service]\ntrait World {\n  /// Returns a greeting for name.\n  async fn hello(name: String) -> String;\n}\n```\n\nThis service definition generates a trait called `World`. Next we need to implement it for our Server struct.\n```\n// This is the type that implements the generated World trait. It is the business logic\n// and is used to start the server.\n#[derive(Clone)]\nstruct HelloServer;\nimpl World for HelloServer {\n  // Each defined rpc generates an async fn that serves the RPC\n  async fn hello(self, _: context::Context, name: String) -> String {\n    format!(\"Hello, {name}!\")\n  }\n}\n```\n\nLastly let\u2019s write our `main` that will start the server. While this example uses an in-process channel\u27e816\u27e9, tarpc also ships a generic `serde_transport`\u27e817\u27e9 behind the `serde-transport` feature, with additional TCP\u27e818\u27e9 functionality available behind the `tcp` feature.\n```\n  // Each defined rpc generates an async fn that serves the RPC\n#[tokio::main]\nasync fn main() -> anyhow::Result<()> {\n  let (client_transport, server_transport) = tarpc::transport::channel::unbounded();\n  let server = server::BaseChannel::with_defaults(server_transport);\n  tokio::spawn(\n    server.execute(HelloServer.serve())\n      // Handle all requests concurrently.\n      .for_each(|response| async move {\n        tokio::spawn(response);\n      }));\n  // WorldClient is generated by the #[tarpc::service] attribute. It has a constructor `new`\n  // that takes a config and any Transport as input.\n  let mut client = WorldClient::new(client::Config::default(), client_transport).spawn();\n  // The client has an RPC method for each RPC defined in the annotated trait. It takes the same\n  // args as defined, with the addition of a Context, which is always the first arg. The Context\n  // specifies a deadline and trace information which can be helpful in debugging requests.\n  let hello = client.hello(context::current(), \"Stim\".to_string()).await?;\n  println!(\"{hello}\");\n  Ok(())\n}\n```\n\n### \u00a7\u27e819\u27e9Service Documentation\nUse `cargo doc` as you normally would to see the documentation created for all items expanded by a `service!` invocation.\n## Re-exports\u00a7\u27e820\u27e9\n\n`pub use tokio_serde[](https://docs.rs/tokio-serde/0.9.0/x86_64-unknown-linux-gnu/tokio_serde/index.html \"mod tokio_serde\");`\n\n\n`pub use tokio_util[](https://docs.rs/tokio-util/0.7.15/x86_64-unknown-linux-gnu/tokio_util/index.html \"mod tokio_util\");`\n\n## Modules\u00a7\u27e821\u27e9\n\nclient\u27e822\u27e9\n    Provides a client that connects to a server and sends multiplexed requests.\n\ncontext\u27e823\u27e9\n    Provides a request context that carries a deadline and trace context. This context is sent from client to server and is used by the server to enforce response deadlines.\n\nserde_transport\u27e817\u27e9`serde-transport`\n    A generic Serde-based `Transport` that can serialize anything supported by `tokio-serde` via any medium that implements `AsyncRead` and `AsyncWrite`.\n\nserver\u27e824\u27e9\n    Provides a server that concurrently handles many connections sending multiplexed requests.\n\ntrace\u27e825\u27e9\n    Provides building blocks for tracing distributed programs.\n\ntransport\u27e826\u27e9\n    Provides a `Transport`\u27e827\u27e9 trait as well as implementations.\n## Structs\u00a7\u27e828\u27e9\n\nRequest\u27e829\u27e9\n    A request from a client to a server.\n\nResponse\u27e830\u27e9\n    A response from a server to a client.\n\nServerError\u27e831\u27e9\n    An error indicating the server aborted the request early, e.g., due to request throttling.\n## Enums\u00a7\u27e832\u27e9\n\nChannelError\u27e833\u27e9\n    Critical errors that result in a Channel disconnecting.\n\nClientMessage\u27e834\u27e9\n    A message from a client to a server.\n## Traits\u00a7\u27e835\u27e9\n\nRequestName\u27e836\u27e9\n    Implemented by the request types generated by tarpc::service.\n\nTransport\u27e827\u27e9\n    A bidirectional stream (`Sink`\u27e837\u27e9 + `Stream`\u27e838\u27e9) of messages.\n## Attribute Macros\u00a7\u27e839\u27e9\n\nderive_serde\u27e840\u27e9\n    A helper attribute to avoid a direct dependency on Serde.\n\nservice\u27e841\u27e9\n    The main macro that creates RPC services.\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/tarpc/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/tarpc/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/tarpc/latest/src/tarpc/lib.rs.html#6-557: Source\n\u27e84\u27e9 https://docs.rs/crate/tarpc/: Documentation\n\u27e85\u27e9 https://docs.rs/tarpc/latest/tarpc/#what-is-an-rpc-framework: \u00a7\n\u27e86\u27e9 http://www.grpc.io: gRPC\n\u27e87\u27e9 https://capnproto.org/: Cap\u2019n Proto\n\u27e88\u27e9 https://github.com/tokio-rs/tracing: tracing\n\u27e89\u27e9 https://opentelemetry.io/: OpenTelemetry\n\u27e810\u27e9 https://github.com/open-telemetry/opentelemetry-rust/tree/main/opentelemetry-otlp: OTLP\n\u27e811\u27e9 https://github.com/env-logger-rs/env_logger/: env_logger\n\u27e812\u27e9 https://docs.rs/tarpc/latest/tarpc/#usage: \u00a7\n\u27e813\u27e9 https://docs.rs/tarpc/latest/tarpc/#example: \u00a7\n\u27e814\u27e9 https://tokio.rs: tokio\n\u27e815\u27e9 https://docs.rs/tarpc/latest/tarpc/example-service: example-service\n\u27e816\u27e9 https://docs.rs/tarpc/latest/tarpc/transport/channel/index.html: mod tarpc::transport::channel - in-process channel\n\u27e817\u27e9 https://docs.rs/tarpc/latest/tarpc/serde_transport/index.html: mod tarpc::serde_transport - `serde_transport`\n\u27e818\u27e9 https://docs.rs/tarpc/latest/tarpc/serde_transport/tcp/index.html: mod tarpc::serde_transport::tcp - TCP\n\u27e819\u27e9 https://docs.rs/tarpc/latest/tarpc/#service-documentation: \u00a7\n\u27e820\u27e9 https://docs.rs/tarpc/latest/tarpc/#reexports: \u00a7\n\u27e821\u27e9 https://docs.rs/tarpc/latest/tarpc/#modules: \u00a7\n\u27e822\u27e9 https://docs.rs/tarpc/latest/tarpc/client/index.html: mod tarpc::client - client\n\u27e823\u27e9 https://docs.rs/tarpc/latest/tarpc/context/index.html: mod tarpc::context - context\n\u27e824\u27e9 https://docs.rs/tarpc/latest/tarpc/server/index.html: mod tarpc::server - server\n\u27e825\u27e9 https://docs.rs/tarpc/latest/tarpc/trace/index.html: mod tarpc::trace - trace\n\u27e826\u27e9 https://docs.rs/tarpc/latest/tarpc/transport/index.html: mod tarpc::transport - transport\n\u27e827\u27e9 https://docs.rs/tarpc/latest/tarpc/trait.Transport.html: trait tarpc::Transport - `Transport`\n\u27e828\u27e9 https://docs.rs/tarpc/latest/tarpc/#structs: \u00a7\n\u27e829\u27e9 https://docs.rs/tarpc/latest/tarpc/struct.Request.html: struct tarpc::Request - Request\n\u27e830\u27e9 https://docs.rs/tarpc/latest/tarpc/struct.Response.html: struct tarpc::Response - Response\n\u27e831\u27e9 https://docs.rs/tarpc/latest/tarpc/struct.ServerError.html: struct tarpc::ServerError - ServerError\n\u27e832\u27e9 https://docs.rs/tarpc/latest/tarpc/#enums: \u00a7\n\u27e833\u27e9 https://docs.rs/tarpc/latest/tarpc/enum.ChannelError.html: enum tarpc::ChannelError - ChannelError\n\u27e834\u27e9 https://docs.rs/tarpc/latest/tarpc/enum.ClientMessage.html: enum tarpc::ClientMessage - ClientMessage\n\u27e835\u27e9 https://docs.rs/tarpc/latest/tarpc/#traits: \u00a7\n\u27e836\u27e9 https://docs.rs/tarpc/latest/tarpc/trait.RequestName.html: trait tarpc::RequestName - RequestName\n\u27e837\u27e9 https://docs.rs/futures-sink/0.3.31/x86_64-unknown-linux-gnu/futures_sink/trait.Sink.html: trait futures_sink::Sink - `Sink`\n\u27e838\u27e9 https://docs.rs/futures-core/0.3.31/x86_64-unknown-linux-gnu/futures_core/stream/trait.Stream.html: trait futures_core::stream::Stream - `Stream`\n\u27e839\u27e9 https://docs.rs/tarpc/latest/tarpc/#attributes: \u00a7\n\u27e840\u27e9 https://docs.rs/tarpc/latest/tarpc/attr.derive_serde.html: attr tarpc::derive_serde - derive_serde\n\u27e841\u27e9 https://docs.rs/tarpc/latest/tarpc/attr.service.html: attr tarpc::service - service\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `tarpc` crate is a Rust RPC framework designed for simplicity and ease of use, allowing services to be defined directly in code without external schema files. It supports pluggable transports, cascading cancellation, configurable deadlines, distributed tracing with OpenTelemetry, and optional Serde serialization. With minimal boilerplate, it enables developers to implement and run asynchronous RPC services efficiently.",
    "feature_summary": null,
    "use_case": "Networking",
    "score": 6.5,
    "factual_counterfactual": "### Pair 1: Schema Definition\n\u2705 Factual: `tarpc` allows defining RPC schemas directly in Rust code using the `#[tarpc::service]` attribute, eliminating the need for separate schema definition files like `.proto` used in frameworks such as gRPC.  \n\u274c Counterfactual: `tarpc` requires schemas to be defined in `.proto` files, which are then compiled into Rust code using a separate toolchain.\n\n---\n\n### Pair 2: Transport Flexibility\n\u2705 Factual: `tarpc` supports pluggable transport mechanisms, allowing any type implementing `Stream<Item = Request> + Sink<Response>` to be used for communication between client and server.  \n\u274c Counterfactual: `tarpc` only supports TCP-based transport and does not allow custom transport implementations.\n\n---\n\n### Pair 3: Serialization Options\n\u2705 Factual: `tarpc` provides optional Serde serialization via the `serde1` Cargo feature, enabling requests and responses to implement `Serialize` and `Deserialize`. This feature can be disabled for in-memory transports to avoid serialization overhead.  \n\u274c Counterfactual: `tarpc` requires all requests and responses to be serialized using Serde, even for in-memory communication, making serialization mandatory in all use cases.",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}