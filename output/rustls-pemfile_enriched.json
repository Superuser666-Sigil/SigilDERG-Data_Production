{
    "name": "rustls-pemfile",
    "version": "2.2.0",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/rustls-pemfile/latest/rustls_pemfile/all.html \"show sidebar\")\n# Crate rustls_pemfileCopy item path\n[Settings](https://docs.rs/rustls-pemfile/latest/settings.html)\n[Help](https://docs.rs/rustls-pemfile/latest/help.html)\nSummary[Source](https://docs.rs/rustls-pemfile/latest/src/rustls_pemfile/lib.rs.html#1-212)\nExpand description\n## [\u00a7](https://docs.rs/rustls-pemfile/latest/rustls_pemfile/#rustls-pemfile)rustls-pemfile\nA basic parser for .pem files containing cryptographic keys and certificates.\nThe input to this crate is a .pem file containing potentially many sections, and the output is those sections as alleged DER-encodings. This crate does not decode the actual DER-encoded keys/certificates.\n### [\u00a7](https://docs.rs/rustls-pemfile/latest/rustls_pemfile/#quick-start)Quick start\nStarting with an `io::BufRead` containing the file to be read:\n  * Use `read_all()` to ingest the whole file, then work through the contents in-memory, or,\n  * Use `read_one()` to stream through the file, processing the items as found, or,\n  * Use `certs()` to extract just the certificates (silently discarding other sections), and similarly for `rsa_private_keys()` and `pkcs8_private_keys()`.\n\n\n## [\u00a7](https://docs.rs/rustls-pemfile/latest/rustls_pemfile/#no-std-support)no-std support\nThe opt-out \u201cstd\u201d Cargo feature can be disabled to put this crate in no-std mode.\nIn no-std mode, the `read_one_from_slice` API can be used to parse a .pem file that has already been loaded into memory.\n### [\u00a7](https://docs.rs/rustls-pemfile/latest/rustls_pemfile/#example-code)Example code\n```\nuse std::iter;\nuse rustls_pemfile::{Item, read_one};\n// Assume `reader` is any std::io::BufRead implementor\nfor item in iter::from_fn(|| read_one(&mut reader).transpose()) {\n  match item.unwrap() {\n    Item::X509Certificate(cert) => println!(\"certificate {:?}\", cert),\n    Item::Crl(crl) => println!(\"certificate revocation list: {:?}\", crl),\n    Item::Csr(csr) => println!(\"certificate signing request: {:?}\", csr),\n    Item::Pkcs1Key(key) => println!(\"rsa pkcs1 key {:?}\", key),\n    Item::Pkcs8Key(key) => println!(\"pkcs8 key {:?}\", key),\n    Item::Sec1Key(key) => println!(\"sec1 ec key {:?}\", key),\n    _ => println!(\"unhandled item\"),\n  }\n}\n```\n\n## Enums[\u00a7](https://docs.rs/rustls-pemfile/latest/rustls_pemfile/#enums)\n\n[Error](https://docs.rs/rustls-pemfile/latest/rustls_pemfile/enum.Error.html \"enum rustls_pemfile::Error\")\n    Errors that may arise when parsing the contents of a PEM file\n\n[Item](https://docs.rs/rustls-pemfile/latest/rustls_pemfile/enum.Item.html \"enum rustls_pemfile::Item\")\n    The contents of a single recognised block in a PEM file.\n## Functions[\u00a7](https://docs.rs/rustls-pemfile/latest/rustls_pemfile/#functions)\n\n[certs](https://docs.rs/rustls-pemfile/latest/rustls_pemfile/fn.certs.html \"fn rustls_pemfile::certs\")\n    Return an iterator over certificates from `rd`.\n\n[crls](https://docs.rs/rustls-pemfile/latest/rustls_pemfile/fn.crls.html \"fn rustls_pemfile::crls\")\n    Return an iterator certificate revocation lists (CRLs) from `rd`.\n\n[csr](https://docs.rs/rustls-pemfile/latest/rustls_pemfile/fn.csr.html \"fn rustls_pemfile::csr\")\n    Return the first certificate signing request (CSR) found in `rd`.\n\n[ec_private_keys](https://docs.rs/rustls-pemfile/latest/rustls_pemfile/fn.ec_private_keys.html \"fn rustls_pemfile::ec_private_keys\")\n    Return an iterator over SEC1-encoded EC private keys from `rd`.\n\n[pkcs8_private_keys](https://docs.rs/rustls-pemfile/latest/rustls_pemfile/fn.pkcs8_private_keys.html \"fn rustls_pemfile::pkcs8_private_keys\")\n    Return an iterator over PKCS8-encoded private keys from `rd`.\n\n[private_key](https://docs.rs/rustls-pemfile/latest/rustls_pemfile/fn.private_key.html \"fn rustls_pemfile::private_key\")\n    Return the first private key found in `rd`.\n\n[public_keys](https://docs.rs/rustls-pemfile/latest/rustls_pemfile/fn.public_keys.html \"fn rustls_pemfile::public_keys\")\n    Return an iterator over SPKI-encoded keys from `rd`.\n\n[read_all](https://docs.rs/rustls-pemfile/latest/rustls_pemfile/fn.read_all.html \"fn rustls_pemfile::read_all\")\n    Extract and return all PEM sections by reading `rd`.\n\n[read_one](https://docs.rs/rustls-pemfile/latest/rustls_pemfile/fn.read_one.html \"fn rustls_pemfile::read_one\")\n    Extract and decode the next PEM section from `rd`.\n\n[read_one_from_slice](https://docs.rs/rustls-pemfile/latest/rustls_pemfile/fn.read_one_from_slice.html \"fn rustls_pemfile::read_one_from_slice\")\n    Extract and decode the next PEM section from `input`\n\n[rsa_private_keys](https://docs.rs/rustls-pemfile/latest/rustls_pemfile/fn.rsa_private_keys.html \"fn rustls_pemfile::rsa_private_keys\")\n    Return an iterator over RSA private keys from `rd`.\n",
        "markdown_with_citations": "[](https://docs.rs/rustls-pemfile/latest/rustls_pemfile/all.html \"show sidebar\")\n# Crate rustls_pemfileCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\n## \u00a7\u27e84\u27e9rustls-pemfile\nA basic parser for .pem files containing cryptographic keys and certificates.\nThe input to this crate is a .pem file containing potentially many sections, and the output is those sections as alleged DER-encodings. This crate does not decode the actual DER-encoded keys/certificates.\n### \u00a7\u27e85\u27e9Quick start\nStarting with an `io::BufRead` containing the file to be read:\n  * Use `read_all()` to ingest the whole file, then work through the contents in-memory, or,\n  * Use `read_one()` to stream through the file, processing the items as found, or,\n  * Use `certs()` to extract just the certificates (silently discarding other sections), and similarly for `rsa_private_keys()` and `pkcs8_private_keys()`.\n\n\n## \u00a7\u27e86\u27e9no-std support\nThe opt-out \u201cstd\u201d Cargo feature can be disabled to put this crate in no-std mode.\nIn no-std mode, the `read_one_from_slice` API can be used to parse a .pem file that has already been loaded into memory.\n### \u00a7\u27e87\u27e9Example code\n```\nuse std::iter;\nuse rustls_pemfile::{Item, read_one};\n// Assume `reader` is any std::io::BufRead implementor\nfor item in iter::from_fn(|| read_one(&mut reader).transpose()) {\n  match item.unwrap() {\n    Item::X509Certificate(cert) => println!(\"certificate {:?}\", cert),\n    Item::Crl(crl) => println!(\"certificate revocation list: {:?}\", crl),\n    Item::Csr(csr) => println!(\"certificate signing request: {:?}\", csr),\n    Item::Pkcs1Key(key) => println!(\"rsa pkcs1 key {:?}\", key),\n    Item::Pkcs8Key(key) => println!(\"pkcs8 key {:?}\", key),\n    Item::Sec1Key(key) => println!(\"sec1 ec key {:?}\", key),\n    _ => println!(\"unhandled item\"),\n  }\n}\n```\n\n## Enums\u00a7\u27e88\u27e9\n\nError\u27e89\u27e9\n    Errors that may arise when parsing the contents of a PEM file\n\nItem\u27e810\u27e9\n    The contents of a single recognised block in a PEM file.\n## Functions\u00a7\u27e811\u27e9\n\ncerts\u27e812\u27e9\n    Return an iterator over certificates from `rd`.\n\ncrls\u27e813\u27e9\n    Return an iterator certificate revocation lists (CRLs) from `rd`.\n\ncsr\u27e814\u27e9\n    Return the first certificate signing request (CSR) found in `rd`.\n\nec_private_keys\u27e815\u27e9\n    Return an iterator over SEC1-encoded EC private keys from `rd`.\n\npkcs8_private_keys\u27e816\u27e9\n    Return an iterator over PKCS8-encoded private keys from `rd`.\n\nprivate_key\u27e817\u27e9\n    Return the first private key found in `rd`.\n\npublic_keys\u27e818\u27e9\n    Return an iterator over SPKI-encoded keys from `rd`.\n\nread_all\u27e819\u27e9\n    Extract and return all PEM sections by reading `rd`.\n\nread_one\u27e820\u27e9\n    Extract and decode the next PEM section from `rd`.\n\nread_one_from_slice\u27e821\u27e9\n    Extract and decode the next PEM section from `input`\n\nrsa_private_keys\u27e822\u27e9\n    Return an iterator over RSA private keys from `rd`.\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/rustls-pemfile/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/rustls-pemfile/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/rustls-pemfile/latest/src/rustls_pemfile/lib.rs.html#1-212: Source\n\u27e84\u27e9 https://docs.rs/rustls-pemfile/latest/rustls_pemfile/#rustls-pemfile: \u00a7\n\u27e85\u27e9 https://docs.rs/rustls-pemfile/latest/rustls_pemfile/#quick-start: \u00a7\n\u27e86\u27e9 https://docs.rs/rustls-pemfile/latest/rustls_pemfile/#no-std-support: \u00a7\n\u27e87\u27e9 https://docs.rs/rustls-pemfile/latest/rustls_pemfile/#example-code: \u00a7\n\u27e88\u27e9 https://docs.rs/rustls-pemfile/latest/rustls_pemfile/#enums: \u00a7\n\u27e89\u27e9 https://docs.rs/rustls-pemfile/latest/rustls_pemfile/enum.Error.html: enum rustls_pemfile::Error - Error\n\u27e810\u27e9 https://docs.rs/rustls-pemfile/latest/rustls_pemfile/enum.Item.html: enum rustls_pemfile::Item - Item\n\u27e811\u27e9 https://docs.rs/rustls-pemfile/latest/rustls_pemfile/#functions: \u00a7\n\u27e812\u27e9 https://docs.rs/rustls-pemfile/latest/rustls_pemfile/fn.certs.html: fn rustls_pemfile::certs - certs\n\u27e813\u27e9 https://docs.rs/rustls-pemfile/latest/rustls_pemfile/fn.crls.html: fn rustls_pemfile::crls - crls\n\u27e814\u27e9 https://docs.rs/rustls-pemfile/latest/rustls_pemfile/fn.csr.html: fn rustls_pemfile::csr - csr\n\u27e815\u27e9 https://docs.rs/rustls-pemfile/latest/rustls_pemfile/fn.ec_private_keys.html: fn rustls_pemfile::ec_private_keys - ec_private_keys\n\u27e816\u27e9 https://docs.rs/rustls-pemfile/latest/rustls_pemfile/fn.pkcs8_private_keys.html: fn rustls_pemfile::pkcs8_private_keys - pkcs8_private_keys\n\u27e817\u27e9 https://docs.rs/rustls-pemfile/latest/rustls_pemfile/fn.private_key.html: fn rustls_pemfile::private_key - private_key\n\u27e818\u27e9 https://docs.rs/rustls-pemfile/latest/rustls_pemfile/fn.public_keys.html: fn rustls_pemfile::public_keys - public_keys\n\u27e819\u27e9 https://docs.rs/rustls-pemfile/latest/rustls_pemfile/fn.read_all.html: fn rustls_pemfile::read_all - read_all\n\u27e820\u27e9 https://docs.rs/rustls-pemfile/latest/rustls_pemfile/fn.read_one.html: fn rustls_pemfile::read_one - read_one\n\u27e821\u27e9 https://docs.rs/rustls-pemfile/latest/rustls_pemfile/fn.read_one_from_slice.html: fn rustls_pemfile::read_one_from_slice - read_one_from_slice\n\u27e822\u27e9 https://docs.rs/rustls-pemfile/latest/rustls_pemfile/fn.rsa_private_keys.html: fn rustls_pemfile::rsa_private_keys - rsa_private_keys\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `rustls-pemfile` crate provides a lightweight parser for `.pem` files containing cryptographic keys and certificates, outputting their sections as DER-encoded data without decoding the contents. It offers APIs to extract specific items like certificates, RSA/PKCS8 private keys, and EC keys, with support for streaming (`read_one`) or in-memory processing (`read_all`). Additionally, it supports `no-std` environments via the `read_one_from_slice` API.",
    "feature_summary": null,
    "use_case": "Cryptography",
    "score": 6.0,
    "factual_counterfactual": "### Pair 1: Parsing Capabilities\n\u2705 Factual: The `rustls-pemfile` crate can parse PEM files and extract sections as alleged DER-encodings but does not decode the DER-encoded keys or certificates.  \n\u274c Counterfactual: The `rustls-pemfile` crate can fully decode DER-encoded keys and certificates from PEM files, making them ready for cryptographic operations.\n\n---\n\n### Pair 2: API Features\n\u2705 Factual: The `rustls-pemfile` crate provides the `read_one()` function to stream through a PEM file section by section, processing each item as it is found.  \n\u274c Counterfactual: The `rustls-pemfile` crate requires the entire PEM file to be loaded into memory before any sections can be processed.\n\n---\n\n### Pair 3: No-std Support\n\u2705 Factual: The `rustls-pemfile` crate supports no-std environments by disabling the \"std\" feature and using the `read_one_from_slice` API to parse PEM files from preloaded memory slices.  \n\u274c Counterfactual: The `rustls-pemfile` crate cannot be used in no-std environments because it relies exclusively on standard library features like `std::io::BufRead`.",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}