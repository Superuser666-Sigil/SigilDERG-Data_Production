{
    "name": "csv",
    "version": "1.3.1",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/csv/latest/csv/all.html \"show sidebar\")\n# Crate csvCopy item path\n[Settings](https://docs.rs/csv/latest/settings.html)\n[Help](https://docs.rs/csv/latest/help.html)\nSummary[Source](https://docs.rs/csv/latest/src/csv/lib.rs.html#1-345)\nExpand description\nThe `csv` crate provides a fast and flexible CSV reader and writer, with support for Serde.\nThe [tutorial](https://docs.rs/csv/latest/csv/tutorial/index.html) is a good place to start if you\u2019re new to Rust.\nThe [cookbook](https://docs.rs/csv/latest/csv/cookbook/index.html) will give you a variety of complete Rust programs that do CSV reading and writing.\n## [\u00a7](https://docs.rs/csv/latest/csv/#brief-overview)Brief overview\n**If you\u2019re new to Rust** , you might find the [tutorial](https://docs.rs/csv/latest/csv/tutorial/index.html) to be a good place to start.\nThe primary types in this crate are [`Reader`](https://docs.rs/csv/latest/csv/struct.Reader.html) and [`Writer`](https://docs.rs/csv/latest/csv/struct.Writer.html), for reading and writing CSV data respectively. Correspondingly, to support CSV data with custom field or record delimiters (among many other things), you should use either a [`ReaderBuilder`](https://docs.rs/csv/latest/csv/struct.ReaderBuilder.html) or a [`WriterBuilder`](https://docs.rs/csv/latest/csv/struct.WriterBuilder.html), depending on whether you\u2019re reading or writing CSV data.\nUnless you\u2019re using Serde, the standard CSV record types are [`StringRecord`](https://docs.rs/csv/latest/csv/struct.StringRecord.html) and [`ByteRecord`](https://docs.rs/csv/latest/csv/struct.ByteRecord.html). `StringRecord` should be used when you know your data to be valid UTF-8. For data that may be invalid UTF-8, `ByteRecord` is suitable.\nFinally, the set of errors is described by the [`Error`](https://docs.rs/csv/latest/csv/struct.Error.html) type.\nThe rest of the types in this crate mostly correspond to more detailed errors, position information, configuration knobs or iterator types.\n## [\u00a7](https://docs.rs/csv/latest/csv/#setup)Setup\nRun `cargo add csv` to add the latest version of the `csv` crate to your Cargo.toml.\nIf you want to use Serde\u2019s custom derive functionality on your custom structs, then run `cargo add serde --features derive` to add the `serde` crate with its `derive` feature enabled to your `Cargo.toml`.\n## [\u00a7](https://docs.rs/csv/latest/csv/#example)Example\nThis example shows how to read CSV data from stdin and print each record to stdout.\nThere are more examples in the [cookbook](https://docs.rs/csv/latest/csv/cookbook/index.html).\n```\nuse std::{error::Error, io, process};\nfn example() -> Result<(), Box<dyn Error>> {\n  // Build the CSV reader and iterate over each record.\n  let mut rdr = csv::Reader::from_reader(io::stdin());\n  for result in rdr.records() {\n    // The iterator yields Result<StringRecord, Error>, so we check the\n    // error here.\n    let record = result?;\n    println!(\"{:?}\", record);\n  }\n  Ok(())\n}\nfn main() {\n  if let Err(err) = example() {\n    println!(\"error running example: {}\", err);\n    process::exit(1);\n  }\n}\n```\n\nThe above example can be run like so:\n[\u24d8](https://docs.rs/csv/latest/csv/ \"This example is not tested\")```\n$ git clone git://github.com/BurntSushi/rust-csv\n$ cd rust-csv\n$ cargo run --example cookbook-read-basic < examples/data/smallpop.csv\n```\n\n## [\u00a7](https://docs.rs/csv/latest/csv/#example-with-serde)Example with Serde\nThis example shows how to read CSV data from stdin into your own custom struct. By default, the member names of the struct are matched with the values in the header record of your CSV data.\n```\nuse std::{error::Error, io, process};\n#[derive(Debug, serde::Deserialize)]\nstruct Record {\n  city: String,\n  region: String,\n  country: String,\n  population: Option<u64>,\n}\nfn example() -> Result<(), Box<dyn Error>> {\n  let mut rdr = csv::Reader::from_reader(io::stdin());\n  for result in rdr.deserialize() {\n    // Notice that we need to provide a type hint for automatic\n    // deserialization.\n    let record: Record = result?;\n    println!(\"{:?}\", record);\n  }\n  Ok(())\n}\nfn main() {\n  if let Err(err) = example() {\n    println!(\"error running example: {}\", err);\n    process::exit(1);\n  }\n}\n```\n\nThe above example can be run like so:\n[\u24d8](https://docs.rs/csv/latest/csv/ \"This example is not tested\")```\n$ git clone git://github.com/BurntSushi/rust-csv\n$ cd rust-csv\n$ cargo run --example cookbook-read-serde < examples/data/smallpop.csv\n```\n\n## Modules[\u00a7](https://docs.rs/csv/latest/csv/#modules)\n\n[cookbook](https://docs.rs/csv/latest/csv/cookbook/index.html \"mod csv::cookbook\")\n    A cookbook of examples for CSV reading and writing.\n\n[tutorial](https://docs.rs/csv/latest/csv/tutorial/index.html \"mod csv::tutorial\")\n    A tutorial for handling CSV data in Rust.\n## Structs[\u00a7](https://docs.rs/csv/latest/csv/#structs)\n\n[ByteRecord](https://docs.rs/csv/latest/csv/struct.ByteRecord.html \"struct csv::ByteRecord\")\n    A single CSV record stored as raw bytes.\n\n[ByteRecordIter](https://docs.rs/csv/latest/csv/struct.ByteRecordIter.html \"struct csv::ByteRecordIter\")\n    A double-ended iterator over the fields in a byte record.\n\n[ByteRecordsIntoIter](https://docs.rs/csv/latest/csv/struct.ByteRecordsIntoIter.html \"struct csv::ByteRecordsIntoIter\")\n    An owned iterator over records as raw bytes.\n\n[ByteRecordsIter](https://docs.rs/csv/latest/csv/struct.ByteRecordsIter.html \"struct csv::ByteRecordsIter\")\n    A borrowed iterator over records as raw bytes.\n\n[DeserializeError](https://docs.rs/csv/latest/csv/struct.DeserializeError.html \"struct csv::DeserializeError\")\n    An Serde deserialization error.\n\n[DeserializeRecordsIntoIter](https://docs.rs/csv/latest/csv/struct.DeserializeRecordsIntoIter.html \"struct csv::DeserializeRecordsIntoIter\")\n    An owned iterator over deserialized records.\n\n[DeserializeRecordsIter](https://docs.rs/csv/latest/csv/struct.DeserializeRecordsIter.html \"struct csv::DeserializeRecordsIter\")\n    A borrowed iterator over deserialized records.\n\n[Error](https://docs.rs/csv/latest/csv/struct.Error.html \"struct csv::Error\")\n    An error that can occur when processing CSV data.\n\n[FromUtf8Error](https://docs.rs/csv/latest/csv/struct.FromUtf8Error.html \"struct csv::FromUtf8Error\")\n    A UTF-8 validation error during record conversion.\n\n[IntoInnerError](https://docs.rs/csv/latest/csv/struct.IntoInnerError.html \"struct csv::IntoInnerError\")\n    `IntoInnerError` occurs when consuming a `Writer` fails.\n\n[Position](https://docs.rs/csv/latest/csv/struct.Position.html \"struct csv::Position\")\n    A position in CSV data.\n\n[Reader](https://docs.rs/csv/latest/csv/struct.Reader.html \"struct csv::Reader\")\n    A already configured CSV reader.\n\n[ReaderBuilder](https://docs.rs/csv/latest/csv/struct.ReaderBuilder.html \"struct csv::ReaderBuilder\")\n    Builds a CSV reader with various configuration knobs.\n\n[StringRecord](https://docs.rs/csv/latest/csv/struct.StringRecord.html \"struct csv::StringRecord\")\n    A single CSV record stored as valid UTF-8 bytes.\n\n[StringRecordIter](https://docs.rs/csv/latest/csv/struct.StringRecordIter.html \"struct csv::StringRecordIter\")\n    An iterator over the fields in a string record.\n\n[StringRecordsIntoIter](https://docs.rs/csv/latest/csv/struct.StringRecordsIntoIter.html \"struct csv::StringRecordsIntoIter\")\n    An owned iterator over records as strings.\n\n[StringRecordsIter](https://docs.rs/csv/latest/csv/struct.StringRecordsIter.html \"struct csv::StringRecordsIter\")\n    A borrowed iterator over records as strings.\n\n[Utf8Error](https://docs.rs/csv/latest/csv/struct.Utf8Error.html \"struct csv::Utf8Error\")\n    A UTF-8 validation error.\n\n[Writer](https://docs.rs/csv/latest/csv/struct.Writer.html \"struct csv::Writer\")\n    An already configured CSV writer.\n\n[WriterBuilder](https://docs.rs/csv/latest/csv/struct.WriterBuilder.html \"struct csv::WriterBuilder\")\n    Builds a CSV writer with various configuration knobs.\n## Enums[\u00a7](https://docs.rs/csv/latest/csv/#enums)\n\n[DeserializeErrorKind](https://docs.rs/csv/latest/csv/enum.DeserializeErrorKind.html \"enum csv::DeserializeErrorKind\")\n    The type of a Serde deserialization error.\n\n[ErrorKind](https://docs.rs/csv/latest/csv/enum.ErrorKind.html \"enum csv::ErrorKind\")\n    The specific type of an error.\n\n[QuoteStyle](https://docs.rs/csv/latest/csv/enum.QuoteStyle.html \"enum csv::QuoteStyle\")\n    The quoting style to use when writing CSV data.\n\n[Terminator](https://docs.rs/csv/latest/csv/enum.Terminator.html \"enum csv::Terminator\")\n    A record terminator.\n\n[Trim](https://docs.rs/csv/latest/csv/enum.Trim.html \"enum csv::Trim\")\n    The whitespace preservation behaviour when reading CSV data.\n## Functions[\u00a7](https://docs.rs/csv/latest/csv/#functions)\n\n[invalid_option](https://docs.rs/csv/latest/csv/fn.invalid_option.html \"fn csv::invalid_option\")\n    A custom Serde deserializer for possibly invalid `Option<T>` fields.\n## Type Aliases[\u00a7](https://docs.rs/csv/latest/csv/#types)\n\n[Result](https://docs.rs/csv/latest/csv/type.Result.html \"type csv::Result\")\n    A type alias for `Result<T, csv::Error>`.\n",
        "markdown_with_citations": "[](https://docs.rs/csv/latest/csv/all.html \"show sidebar\")\n# Crate csvCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nThe `csv` crate provides a fast and flexible CSV reader and writer, with support for Serde.\nThe tutorial\u27e84\u27e9 is a good place to start if you\u2019re new to Rust.\nThe cookbook\u27e85\u27e9 will give you a variety of complete Rust programs that do CSV reading and writing.\n## \u00a7\u27e86\u27e9Brief overview\n**If you\u2019re new to Rust** , you might find the tutorial\u27e84\u27e9 to be a good place to start.\nThe primary types in this crate are `Reader`\u27e87\u27e9 and `Writer`\u27e88\u27e9, for reading and writing CSV data respectively. Correspondingly, to support CSV data with custom field or record delimiters (among many other things), you should use either a `ReaderBuilder`\u27e89\u27e9 or a `WriterBuilder`\u27e810\u27e9, depending on whether you\u2019re reading or writing CSV data.\nUnless you\u2019re using Serde, the standard CSV record types are `StringRecord`\u27e811\u27e9 and `ByteRecord`\u27e812\u27e9. `StringRecord` should be used when you know your data to be valid UTF-8. For data that may be invalid UTF-8, `ByteRecord` is suitable.\nFinally, the set of errors is described by the `Error`\u27e813\u27e9 type.\nThe rest of the types in this crate mostly correspond to more detailed errors, position information, configuration knobs or iterator types.\n## \u00a7\u27e814\u27e9Setup\nRun `cargo add csv` to add the latest version of the `csv` crate to your Cargo.toml.\nIf you want to use Serde\u2019s custom derive functionality on your custom structs, then run `cargo add serde --features derive` to add the `serde` crate with its `derive` feature enabled to your `Cargo.toml`.\n## \u00a7\u27e815\u27e9Example\nThis example shows how to read CSV data from stdin and print each record to stdout.\nThere are more examples in the cookbook\u27e85\u27e9.\n```\nuse std::{error::Error, io, process};\nfn example() -> Result<(), Box<dyn Error>> {\n  // Build the CSV reader and iterate over each record.\n  let mut rdr = csv::Reader::from_reader(io::stdin());\n  for result in rdr.records() {\n    // The iterator yields Result<StringRecord, Error>, so we check the\n    // error here.\n    let record = result?;\n    println!(\"{:?}\", record);\n  }\n  Ok(())\n}\nfn main() {\n  if let Err(err) = example() {\n    println!(\"error running example: {}\", err);\n    process::exit(1);\n  }\n}\n```\n\nThe above example can be run like so:\n\u24d8\u27e816\u27e9```\n$ git clone git://github.com/BurntSushi/rust-csv\n$ cd rust-csv\n$ cargo run --example cookbook-read-basic < examples/data/smallpop.csv\n```\n\n## \u00a7\u27e817\u27e9Example with Serde\nThis example shows how to read CSV data from stdin into your own custom struct. By default, the member names of the struct are matched with the values in the header record of your CSV data.\n```\nuse std::{error::Error, io, process};\n#[derive(Debug, serde::Deserialize)]\nstruct Record {\n  city: String,\n  region: String,\n  country: String,\n  population: Option<u64>,\n}\nfn example() -> Result<(), Box<dyn Error>> {\n  let mut rdr = csv::Reader::from_reader(io::stdin());\n  for result in rdr.deserialize() {\n    // Notice that we need to provide a type hint for automatic\n    // deserialization.\n    let record: Record = result?;\n    println!(\"{:?}\", record);\n  }\n  Ok(())\n}\nfn main() {\n  if let Err(err) = example() {\n    println!(\"error running example: {}\", err);\n    process::exit(1);\n  }\n}\n```\n\nThe above example can be run like so:\n\u24d8\u27e816\u27e9```\n$ git clone git://github.com/BurntSushi/rust-csv\n$ cd rust-csv\n$ cargo run --example cookbook-read-serde < examples/data/smallpop.csv\n```\n\n## Modules\u00a7\u27e818\u27e9\n\ncookbook\u27e85\u27e9\n    A cookbook of examples for CSV reading and writing.\n\ntutorial\u27e84\u27e9\n    A tutorial for handling CSV data in Rust.\n## Structs\u00a7\u27e819\u27e9\n\nByteRecord\u27e812\u27e9\n    A single CSV record stored as raw bytes.\n\nByteRecordIter\u27e820\u27e9\n    A double-ended iterator over the fields in a byte record.\n\nByteRecordsIntoIter\u27e821\u27e9\n    An owned iterator over records as raw bytes.\n\nByteRecordsIter\u27e822\u27e9\n    A borrowed iterator over records as raw bytes.\n\nDeserializeError\u27e823\u27e9\n    An Serde deserialization error.\n\nDeserializeRecordsIntoIter\u27e824\u27e9\n    An owned iterator over deserialized records.\n\nDeserializeRecordsIter\u27e825\u27e9\n    A borrowed iterator over deserialized records.\n\nError\u27e813\u27e9\n    An error that can occur when processing CSV data.\n\nFromUtf8Error\u27e826\u27e9\n    A UTF-8 validation error during record conversion.\n\nIntoInnerError\u27e827\u27e9\n    `IntoInnerError` occurs when consuming a `Writer` fails.\n\nPosition\u27e828\u27e9\n    A position in CSV data.\n\nReader\u27e87\u27e9\n    A already configured CSV reader.\n\nReaderBuilder\u27e89\u27e9\n    Builds a CSV reader with various configuration knobs.\n\nStringRecord\u27e811\u27e9\n    A single CSV record stored as valid UTF-8 bytes.\n\nStringRecordIter\u27e829\u27e9\n    An iterator over the fields in a string record.\n\nStringRecordsIntoIter\u27e830\u27e9\n    An owned iterator over records as strings.\n\nStringRecordsIter\u27e831\u27e9\n    A borrowed iterator over records as strings.\n\nUtf8Error\u27e832\u27e9\n    A UTF-8 validation error.\n\nWriter\u27e88\u27e9\n    An already configured CSV writer.\n\nWriterBuilder\u27e810\u27e9\n    Builds a CSV writer with various configuration knobs.\n## Enums\u00a7\u27e833\u27e9\n\nDeserializeErrorKind\u27e834\u27e9\n    The type of a Serde deserialization error.\n\nErrorKind\u27e835\u27e9\n    The specific type of an error.\n\nQuoteStyle\u27e836\u27e9\n    The quoting style to use when writing CSV data.\n\nTerminator\u27e837\u27e9\n    A record terminator.\n\nTrim\u27e838\u27e9\n    The whitespace preservation behaviour when reading CSV data.\n## Functions\u00a7\u27e839\u27e9\n\ninvalid_option\u27e840\u27e9\n    A custom Serde deserializer for possibly invalid `Option<T>` fields.\n## Type Aliases\u00a7\u27e841\u27e9\n\nResult\u27e842\u27e9\n    A type alias for `Result<T, csv::Error>`.\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/csv/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/csv/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/csv/latest/src/csv/lib.rs.html#1-345: Source\n\u27e84\u27e9 https://docs.rs/csv/latest/csv/tutorial/index.html: tutorial\n\u27e85\u27e9 https://docs.rs/csv/latest/csv/cookbook/index.html: cookbook\n\u27e86\u27e9 https://docs.rs/csv/latest/csv/#brief-overview: \u00a7\n\u27e87\u27e9 https://docs.rs/csv/latest/csv/struct.Reader.html: `Reader`\n\u27e88\u27e9 https://docs.rs/csv/latest/csv/struct.Writer.html: `Writer`\n\u27e89\u27e9 https://docs.rs/csv/latest/csv/struct.ReaderBuilder.html: `ReaderBuilder`\n\u27e810\u27e9 https://docs.rs/csv/latest/csv/struct.WriterBuilder.html: `WriterBuilder`\n\u27e811\u27e9 https://docs.rs/csv/latest/csv/struct.StringRecord.html: `StringRecord`\n\u27e812\u27e9 https://docs.rs/csv/latest/csv/struct.ByteRecord.html: `ByteRecord`\n\u27e813\u27e9 https://docs.rs/csv/latest/csv/struct.Error.html: `Error`\n\u27e814\u27e9 https://docs.rs/csv/latest/csv/#setup: \u00a7\n\u27e815\u27e9 https://docs.rs/csv/latest/csv/#example: \u00a7\n\u27e816\u27e9 https://docs.rs/csv/latest/csv/: This example is not tested - \u24d8\n\u27e817\u27e9 https://docs.rs/csv/latest/csv/#example-with-serde: \u00a7\n\u27e818\u27e9 https://docs.rs/csv/latest/csv/#modules: \u00a7\n\u27e819\u27e9 https://docs.rs/csv/latest/csv/#structs: \u00a7\n\u27e820\u27e9 https://docs.rs/csv/latest/csv/struct.ByteRecordIter.html: struct csv::ByteRecordIter - ByteRecordIter\n\u27e821\u27e9 https://docs.rs/csv/latest/csv/struct.ByteRecordsIntoIter.html: struct csv::ByteRecordsIntoIter - ByteRecordsIntoIter\n\u27e822\u27e9 https://docs.rs/csv/latest/csv/struct.ByteRecordsIter.html: struct csv::ByteRecordsIter - ByteRecordsIter\n\u27e823\u27e9 https://docs.rs/csv/latest/csv/struct.DeserializeError.html: struct csv::DeserializeError - DeserializeError\n\u27e824\u27e9 https://docs.rs/csv/latest/csv/struct.DeserializeRecordsIntoIter.html: struct csv::DeserializeRecordsIntoIter - DeserializeRecordsIntoIter\n\u27e825\u27e9 https://docs.rs/csv/latest/csv/struct.DeserializeRecordsIter.html: struct csv::DeserializeRecordsIter - DeserializeRecordsIter\n\u27e826\u27e9 https://docs.rs/csv/latest/csv/struct.FromUtf8Error.html: struct csv::FromUtf8Error - FromUtf8Error\n\u27e827\u27e9 https://docs.rs/csv/latest/csv/struct.IntoInnerError.html: struct csv::IntoInnerError - IntoInnerError\n\u27e828\u27e9 https://docs.rs/csv/latest/csv/struct.Position.html: struct csv::Position - Position\n\u27e829\u27e9 https://docs.rs/csv/latest/csv/struct.StringRecordIter.html: struct csv::StringRecordIter - StringRecordIter\n\u27e830\u27e9 https://docs.rs/csv/latest/csv/struct.StringRecordsIntoIter.html: struct csv::StringRecordsIntoIter - StringRecordsIntoIter\n\u27e831\u27e9 https://docs.rs/csv/latest/csv/struct.StringRecordsIter.html: struct csv::StringRecordsIter - StringRecordsIter\n\u27e832\u27e9 https://docs.rs/csv/latest/csv/struct.Utf8Error.html: struct csv::Utf8Error - Utf8Error\n\u27e833\u27e9 https://docs.rs/csv/latest/csv/#enums: \u00a7\n\u27e834\u27e9 https://docs.rs/csv/latest/csv/enum.DeserializeErrorKind.html: enum csv::DeserializeErrorKind - DeserializeErrorKind\n\u27e835\u27e9 https://docs.rs/csv/latest/csv/enum.ErrorKind.html: enum csv::ErrorKind - ErrorKind\n\u27e836\u27e9 https://docs.rs/csv/latest/csv/enum.QuoteStyle.html: enum csv::QuoteStyle - QuoteStyle\n\u27e837\u27e9 https://docs.rs/csv/latest/csv/enum.Terminator.html: enum csv::Terminator - Terminator\n\u27e838\u27e9 https://docs.rs/csv/latest/csv/enum.Trim.html: enum csv::Trim - Trim\n\u27e839\u27e9 https://docs.rs/csv/latest/csv/#functions: \u00a7\n\u27e840\u27e9 https://docs.rs/csv/latest/csv/fn.invalid_option.html: fn csv::invalid_option - invalid_option\n\u27e841\u27e9 https://docs.rs/csv/latest/csv/#types: \u00a7\n\u27e842\u27e9 https://docs.rs/csv/latest/csv/type.Result.html: type csv::Result - Result\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `csv` crate provides a fast and flexible CSV reader and writer for Rust, with seamless integration with Serde for serialization and deserialization of custom structs. It supports configurable delimiters, UTF-8 and raw byte handling, and includes robust error handling. Key types include `Reader`, `Writer`, `StringRecord`, and `ByteRecord`, alongside builder patterns for customization.",
    "feature_summary": null,
    "use_case": "Serialization",
    "score": 8.5,
    "factual_counterfactual": "### Pair 1: Reader and Writer Capabilities  \n\u2705 Factual: The `csv` crate provides `Reader` and `Writer` types for reading and writing CSV data, with additional configuration options available through `ReaderBuilder` and `WriterBuilder`.  \n\u274c Counterfactual: The `csv` crate only supports reading CSV data and does not provide functionality for writing CSV files.  \n\n---\n\n### Pair 2: Serde Integration  \n\u2705 Factual: The `csv` crate integrates with Serde to allow automatic deserialization of CSV data into custom structs, provided the `serde` crate is included with the `derive` feature enabled.  \n\u274c Counterfactual: The `csv` crate does not support Serde integration, requiring manual parsing of CSV data into custom structs.  \n\n---\n\n### Pair 3: UTF-8 Handling  \n\u2705 Factual: The `csv` crate uses `StringRecord` for CSV records that are guaranteed to be valid UTF-8 and `ByteRecord` for records that may contain invalid UTF-8.  \n\u274c Counterfactual: The `csv` crate enforces UTF-8 validation on all CSV data, disallowing the use of non-UTF-8 encoded files.",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}