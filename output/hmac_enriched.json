{
    "name": "hmac",
    "version": "0.13.0-rc.0",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/hmac/latest/hmac/all.html \"show sidebar\")\n# Crate hmacCopy item path\n[Settings](https://docs.rs/hmac/latest/settings.html)\n[Help](https://docs.rs/hmac/latest/help.html)\nSummary[Source](https://docs.rs/hmac/latest/src/hmac/lib.rs.html#1-131)\nExpand description\nGeneric implementation of Hash-based Message Authentication Code (HMAC).\nTo use it you will need a cryptographic hash function implementation which implements the [`digest`](https://docs.rs/digest) crate traits. You can find compatible crates (e.g. [`sha2`](https://docs.rs/sha2)) in the [`RustCrypto/hashes`](https://github.com/RustCrypto/hashes) repository.\nThis crate provides two HMAC implementation [`Hmac`](https://docs.rs/hmac/latest/hmac/type.Hmac.html \"type hmac::Hmac\") and [`SimpleHmac`](https://docs.rs/hmac/latest/hmac/struct.SimpleHmac.html \"struct hmac::SimpleHmac\"). The first one is a buffered wrapper around block-level [`HmacCore`](https://docs.rs/hmac/latest/hmac/struct.HmacCore.html \"struct hmac::HmacCore\"). Internally it uses efficient state representation, but works only with hash functions which expose block-level API and consume blocks eagerly (e.g. it will not work with the BLAKE2 family of hash functions). On the other hand, [`SimpleHmac`](https://docs.rs/hmac/latest/hmac/struct.SimpleHmac.html \"struct hmac::SimpleHmac\") is a bit less efficient memory-wise, but works with all hash functions which implement the [`Digest`](https://docs.rs/digest) trait.\n## [\u00a7](https://docs.rs/hmac/latest/hmac/#examples)Examples\nLet us demonstrate how to use HMAC using the SHA-256 hash function.\nIn the following examples [`Hmac`](https://docs.rs/hmac/latest/hmac/type.Hmac.html \"type hmac::Hmac\") is interchangeable with [`SimpleHmac`](https://docs.rs/hmac/latest/hmac/struct.SimpleHmac.html \"struct hmac::SimpleHmac\").\nTo get authentication code:\n```\nuse sha2::Sha256;\nuse hmac::{Hmac, Mac};\nuse hex_literal::hex;\n// Create alias for HMAC-SHA256\ntype HmacSha256 = Hmac<Sha256>;\nlet mut mac = HmacSha256::new_from_slice(b\"my secret and secure key\")\n  .expect(\"HMAC can take key of any size\");\nmac.update(b\"input message\");\n// `result` has type `CtOutput` which is a thin wrapper around array of\n// bytes for providing constant time equality check\nlet result = mac.finalize();\n// To get underlying array use `into_bytes`, but be careful, since\n// incorrect use of the code value may permit timing attacks which defeats\n// the security provided by the `CtOutput`\nlet code_bytes = result.into_bytes();\nlet expected = hex!(\"\n  97d2a569059bbcd8ead4444ff99071f4\n  c01d005bcefe0d3567e1be628e5fdcd9\n\");\nassert_eq!(code_bytes[..], expected[..]);\n```\n\nTo verify the message:\n```\nlet mut mac = HmacSha256::new_from_slice(b\"my secret and secure key\")\n  .expect(\"HMAC can take key of any size\");\nmac.update(b\"input message\");\nlet code_bytes = hex!(\"\n  97d2a569059bbcd8ead4444ff99071f4\n  c01d005bcefe0d3567e1be628e5fdcd9\n\");\n// `verify_slice` will return `Ok(())` if code is correct, `Err(MacError)` otherwise\nmac.verify_slice(&code_bytes[..]).unwrap();\n```\n\n## [\u00a7](https://docs.rs/hmac/latest/hmac/#block-and-input-sizes)Block and input sizes\nUsually it is assumed that block size is larger than output size. Due to the generic nature of the implementation, this edge case must be handled as well to remove potential panic. This is done by truncating hash output to the hash block size if needed.\n## Re-exports[\u00a7](https://docs.rs/hmac/latest/hmac/#reexports)\n\n`pub use digest[](https://docs.rs/digest/0.10.7/x86_64-unknown-linux-gnu/digest/index.html \"mod digest\");`\n\n## Structs[\u00a7](https://docs.rs/hmac/latest/hmac/#structs)\n\n[HmacCore](https://docs.rs/hmac/latest/hmac/struct.HmacCore.html \"struct hmac::HmacCore\")\n    Generic core HMAC instance, which operates over blocks.\n\n[SimpleHmac](https://docs.rs/hmac/latest/hmac/struct.SimpleHmac.html \"struct hmac::SimpleHmac\")\n    Simplified HMAC instance able to operate over hash functions which do not expose block-level API and hash functions which process blocks lazily (e.g. BLAKE2).\n## Traits[\u00a7](https://docs.rs/hmac/latest/hmac/#traits)\n\n[Mac](https://docs.rs/hmac/latest/hmac/trait.Mac.html \"trait hmac::Mac\")\n    Convenience wrapper trait covering functionality of Message Authentication algorithms.\n## Type Aliases[\u00a7](https://docs.rs/hmac/latest/hmac/#types)\n\n[Hmac](https://docs.rs/hmac/latest/hmac/type.Hmac.html \"type hmac::Hmac\")\n    Generic HMAC instance.\n",
        "markdown_with_citations": "[](https://docs.rs/hmac/latest/hmac/all.html \"show sidebar\")\n# Crate hmacCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nGeneric implementation of Hash-based Message Authentication Code (HMAC).\nTo use it you will need a cryptographic hash function implementation which implements the `digest`\u27e84\u27e9 crate traits. You can find compatible crates (e.g. `sha2`\u27e85\u27e9) in the `RustCrypto/hashes`\u27e86\u27e9 repository.\nThis crate provides two HMAC implementation `Hmac`\u27e87\u27e9 and `SimpleHmac`\u27e88\u27e9. The first one is a buffered wrapper around block-level `HmacCore`\u27e89\u27e9. Internally it uses efficient state representation, but works only with hash functions which expose block-level API and consume blocks eagerly (e.g. it will not work with the BLAKE2 family of hash functions). On the other hand, `SimpleHmac`\u27e88\u27e9 is a bit less efficient memory-wise, but works with all hash functions which implement the `Digest`\u27e84\u27e9 trait.\n## \u00a7\u27e810\u27e9Examples\nLet us demonstrate how to use HMAC using the SHA-256 hash function.\nIn the following examples `Hmac`\u27e87\u27e9 is interchangeable with `SimpleHmac`\u27e88\u27e9.\nTo get authentication code:\n```\nuse sha2::Sha256;\nuse hmac::{Hmac, Mac};\nuse hex_literal::hex;\n// Create alias for HMAC-SHA256\ntype HmacSha256 = Hmac<Sha256>;\nlet mut mac = HmacSha256::new_from_slice(b\"my secret and secure key\")\n  .expect(\"HMAC can take key of any size\");\nmac.update(b\"input message\");\n// `result` has type `CtOutput` which is a thin wrapper around array of\n// bytes for providing constant time equality check\nlet result = mac.finalize();\n// To get underlying array use `into_bytes`, but be careful, since\n// incorrect use of the code value may permit timing attacks which defeats\n// the security provided by the `CtOutput`\nlet code_bytes = result.into_bytes();\nlet expected = hex!(\"\n  97d2a569059bbcd8ead4444ff99071f4\n  c01d005bcefe0d3567e1be628e5fdcd9\n\");\nassert_eq!(code_bytes[..], expected[..]);\n```\n\nTo verify the message:\n```\nlet mut mac = HmacSha256::new_from_slice(b\"my secret and secure key\")\n  .expect(\"HMAC can take key of any size\");\nmac.update(b\"input message\");\nlet code_bytes = hex!(\"\n  97d2a569059bbcd8ead4444ff99071f4\n  c01d005bcefe0d3567e1be628e5fdcd9\n\");\n// `verify_slice` will return `Ok(())` if code is correct, `Err(MacError)` otherwise\nmac.verify_slice(&code_bytes[..]).unwrap();\n```\n\n## \u00a7\u27e811\u27e9Block and input sizes\nUsually it is assumed that block size is larger than output size. Due to the generic nature of the implementation, this edge case must be handled as well to remove potential panic. This is done by truncating hash output to the hash block size if needed.\n## Re-exports\u00a7\u27e812\u27e9\n\n`pub use digest[](https://docs.rs/digest/0.10.7/x86_64-unknown-linux-gnu/digest/index.html \"mod digest\");`\n\n## Structs\u00a7\u27e813\u27e9\n\nHmacCore\u27e89\u27e9\n    Generic core HMAC instance, which operates over blocks.\n\nSimpleHmac\u27e88\u27e9\n    Simplified HMAC instance able to operate over hash functions which do not expose block-level API and hash functions which process blocks lazily (e.g. BLAKE2).\n## Traits\u00a7\u27e814\u27e9\n\nMac\u27e815\u27e9\n    Convenience wrapper trait covering functionality of Message Authentication algorithms.\n## Type Aliases\u00a7\u27e816\u27e9\n\nHmac\u27e87\u27e9\n    Generic HMAC instance.\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/hmac/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/hmac/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/hmac/latest/src/hmac/lib.rs.html#1-131: Source\n\u27e84\u27e9 https://docs.rs/digest: `digest`\n\u27e85\u27e9 https://docs.rs/sha2: `sha2`\n\u27e86\u27e9 https://github.com/RustCrypto/hashes: `RustCrypto/hashes`\n\u27e87\u27e9 https://docs.rs/hmac/latest/hmac/type.Hmac.html: type hmac::Hmac - `Hmac`\n\u27e88\u27e9 https://docs.rs/hmac/latest/hmac/struct.SimpleHmac.html: struct hmac::SimpleHmac - `SimpleHmac`\n\u27e89\u27e9 https://docs.rs/hmac/latest/hmac/struct.HmacCore.html: struct hmac::HmacCore - `HmacCore`\n\u27e810\u27e9 https://docs.rs/hmac/latest/hmac/#examples: \u00a7\n\u27e811\u27e9 https://docs.rs/hmac/latest/hmac/#block-and-input-sizes: \u00a7\n\u27e812\u27e9 https://docs.rs/hmac/latest/hmac/#reexports: \u00a7\n\u27e813\u27e9 https://docs.rs/hmac/latest/hmac/#structs: \u00a7\n\u27e814\u27e9 https://docs.rs/hmac/latest/hmac/#traits: \u00a7\n\u27e815\u27e9 https://docs.rs/hmac/latest/hmac/trait.Mac.html: trait hmac::Mac - Mac\n\u27e816\u27e9 https://docs.rs/hmac/latest/hmac/#types: \u00a7\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `hmac` crate provides a generic implementation of Hash-based Message Authentication Code (HMAC), supporting cryptographic hash functions compatible with the `digest` crate (e.g., `sha2`). It offers two implementations: `Hmac`, optimized for block-level APIs, and `SimpleHmac`, compatible with all `Digest`-trait hash functions, including those with lazy block processing (e.g., BLAKE2). The crate ensures constant-time operations for security and includes functionality for generating and verifying authentication codes.",
    "feature_summary": null,
    "use_case": "Cryptography",
    "score": 7.0,
    "factual_counterfactual": "### Pair 1: HMAC Implementations\n\u2705 **Factual:** The `hmac` crate provides two implementations: `Hmac`, which is optimized for hash functions with block-level APIs, and `SimpleHmac`, which works with all hash functions implementing the `Digest` trait, including those that process blocks lazily like the BLAKE2 family.  \n\u274c **Counterfactual:** The `hmac` crate only supports the `Hmac` implementation, which works universally with all hash functions, regardless of their block-level API or processing behavior.\n\n---\n\n### Pair 2: Key Size Flexibility\n\u2705 **Factual:** The `Hmac` implementation in the crate can accept keys of any size, making it flexible for various cryptographic use cases.  \n\u274c **Counterfactual:** The `Hmac` implementation requires keys to be of a fixed size matching the block size of the underlying hash function.\n\n---\n\n### Pair 3: Performance Characteristics\n\u2705 **Factual:** `Hmac` is more memory-efficient than `SimpleHmac` due to its buffered approach and optimized state representation, but it is limited to hash functions with block-level APIs.  \n\u274c **Counterfactual:** `SimpleHmac` is more memory-efficient than `Hmac` because it avoids the overhead of buffering and state representation.",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}