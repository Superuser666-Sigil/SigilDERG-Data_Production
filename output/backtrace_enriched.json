{
    "name": "backtrace",
    "version": "0.3.75",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/backtrace/latest/backtrace/all.html \"show sidebar\")\n# Crate backtraceCopy item path\n[Settings](https://docs.rs/backtrace/latest/settings.html)\n[Help](https://docs.rs/backtrace/latest/help.html)\nSummary[Source](https://docs.rs/backtrace/latest/src/backtrace/lib.rs.html#1-251)\nExpand description\nA library for acquiring a backtrace at runtime\nThis library is meant to supplement the `RUST_BACKTRACE=1` support of the standard library by allowing an acquisition of a backtrace at runtime programmatically. The backtraces generated by this library do not need to be parsed, for example, and expose the functionality of multiple backend implementations.\n## [\u00a7](https://docs.rs/backtrace/latest/backtrace/#usage)Usage\nFirst, add this to your Cargo.toml\n```\n[dependencies]\nbacktrace = \"0.3\"\n```\n\nNext:\n```\nbacktrace::trace(|frame| {\n  let ip = frame.ip();\n  let symbol_address = frame.symbol_address();\n  // Resolve this instruction pointer to a symbol name\n  backtrace::resolve_frame(frame, |symbol| {\n    if let Some(name) = symbol.name() {\n      // ...\n    }\n    if let Some(filename) = symbol.filename() {\n      // ...\n    }\n  });\n  true // keep going to the next frame\n});\n```\n\n## [\u00a7](https://docs.rs/backtrace/latest/backtrace/#backtrace-accuracy)Backtrace accuracy\nThis crate implements best-effort attempts to get the native backtrace. This is not always guaranteed to work, and some platforms don\u2019t return any backtrace at all. If your application requires accurate backtraces then it\u2019s recommended to closely evaluate this crate to see whether it\u2019s suitable for your use case on your target platforms.\nEven on supported platforms, there\u2019s a number of reasons that backtraces may be less-than-accurate, including but not limited to:\n  * Unwind information may not be available. This crate primarily implements backtraces by unwinding the stack, but not all functions may have unwinding information (e.g. DWARF unwinding information).\n  * Rust code may be compiled without unwinding information for some functions. This can also happen for Rust code compiled with `-Cpanic=abort`. You can remedy this, however, with `-Cforce-unwind-tables` as a compiler option.\n  * Unwind information may be inaccurate or corrupt. In the worst case inaccurate unwind information can lead this library to segfault. In the best case inaccurate information will result in a truncated stack trace.\n  * Backtraces may not report filenames/line numbers correctly due to missing or corrupt debug information. This won\u2019t lead to segfaults unlike corrupt unwinding information, but missing or malformed debug information will mean that filenames and line numbers will not be available. This may be because debug information wasn\u2019t generated by the compiler, or it\u2019s just missing on the filesystem.\n  * Not all platforms are supported. For example there\u2019s no way to get a backtrace on WebAssembly at the moment.\n  * Crate features may be disabled. Currently this crate supports using Gimli libbacktrace on non-Windows platforms for reading debuginfo for backtraces. If both crate features are disabled, however, then these platforms will generate a backtrace but be unable to generate symbols for it.\n\n\nIn most standard workflows for most standard platforms you generally don\u2019t need to worry about these caveats. We\u2019ll try to fix ones where we can over time, but otherwise it\u2019s important to be aware of the limitations of unwinding-based backtraces!\n## Structs[\u00a7](https://docs.rs/backtrace/latest/backtrace/#structs)\n\n[Backtrace](https://docs.rs/backtrace/latest/backtrace/struct.Backtrace.html \"struct backtrace::Backtrace\")\n    Representation of an owned and self-contained backtrace.\n\n[BacktraceFmt](https://docs.rs/backtrace/latest/backtrace/struct.BacktraceFmt.html \"struct backtrace::BacktraceFmt\")\n    A formatter for backtraces.\n\n[BacktraceFrame](https://docs.rs/backtrace/latest/backtrace/struct.BacktraceFrame.html \"struct backtrace::BacktraceFrame\")\n    Captured version of a frame in a backtrace.\n\n[BacktraceFrameFmt](https://docs.rs/backtrace/latest/backtrace/struct.BacktraceFrameFmt.html \"struct backtrace::BacktraceFrameFmt\")\n    A formatter for just one frame of a backtrace.\n\n[BacktraceSymbol](https://docs.rs/backtrace/latest/backtrace/struct.BacktraceSymbol.html \"struct backtrace::BacktraceSymbol\")\n    Captured version of a symbol in a backtrace.\n\n[Frame](https://docs.rs/backtrace/latest/backtrace/struct.Frame.html \"struct backtrace::Frame\")\n    A trait representing one frame of a backtrace, yielded to the `trace` function of this crate.\n\n[Symbol](https://docs.rs/backtrace/latest/backtrace/struct.Symbol.html \"struct backtrace::Symbol\")\n    A trait representing the resolution of a symbol in a file.\n\n[SymbolName](https://docs.rs/backtrace/latest/backtrace/struct.SymbolName.html \"struct backtrace::SymbolName\")\n    A wrapper around a symbol name to provide ergonomic accessors to the demangled name, the raw bytes, the raw string, etc.\n## Enums[\u00a7](https://docs.rs/backtrace/latest/backtrace/#enums)\n\n[BytesOrWideString](https://docs.rs/backtrace/latest/backtrace/enum.BytesOrWideString.html \"enum backtrace::BytesOrWideString\")\n    A platform independent representation of a string. When working with `std` enabled it is recommended to the convenience methods for providing conversions to `std` types.\n\n[PrintFmt](https://docs.rs/backtrace/latest/backtrace/enum.PrintFmt.html \"enum backtrace::PrintFmt\")\n    The styles of printing that we can print\n## Functions[\u00a7](https://docs.rs/backtrace/latest/backtrace/#functions)\n\n[clear_symbol_cache](https://docs.rs/backtrace/latest/backtrace/fn.clear_symbol_cache.html \"fn backtrace::clear_symbol_cache\")\n    Attempt to reclaim that cached memory used to symbolicate addresses.\n\n[resolve](https://docs.rs/backtrace/latest/backtrace/fn.resolve.html \"fn backtrace::resolve\")\n    Resolve an address to a symbol, passing the symbol to the specified closure.\n\n[resolve_frame](https://docs.rs/backtrace/latest/backtrace/fn.resolve_frame.html \"fn backtrace::resolve_frame\")\n    Resolve a previously captured frame to a symbol, passing the symbol to the specified closure.\n\n[resolve_frame_unsynchronized](https://docs.rs/backtrace/latest/backtrace/fn.resolve_frame_unsynchronized.html \"fn backtrace::resolve_frame_unsynchronized\")\u26a0\n    Same as `resolve_frame`, only unsafe as it\u2019s unsynchronized.\n\n[resolve_unsynchronized](https://docs.rs/backtrace/latest/backtrace/fn.resolve_unsynchronized.html \"fn backtrace::resolve_unsynchronized\")\u26a0\n    Same as `resolve`, only unsafe as it\u2019s unsynchronized.\n\n[trace](https://docs.rs/backtrace/latest/backtrace/fn.trace.html \"fn backtrace::trace\")\n    Inspects the current call-stack, passing all active frames into the closure provided to calculate a stack trace.\n\n[trace_unsynchronized](https://docs.rs/backtrace/latest/backtrace/fn.trace_unsynchronized.html \"fn backtrace::trace_unsynchronized\")\u26a0\n    Same as `trace`, only unsafe as it\u2019s unsynchronized.\n",
        "markdown_with_citations": "[](https://docs.rs/backtrace/latest/backtrace/all.html \"show sidebar\")\n# Crate backtraceCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nA library for acquiring a backtrace at runtime\nThis library is meant to supplement the `RUST_BACKTRACE=1` support of the standard library by allowing an acquisition of a backtrace at runtime programmatically. The backtraces generated by this library do not need to be parsed, for example, and expose the functionality of multiple backend implementations.\n## \u00a7\u27e84\u27e9Usage\nFirst, add this to your Cargo.toml\n```\n[dependencies]\nbacktrace = \"0.3\"\n```\n\nNext:\n```\nbacktrace::trace(|frame| {\n  let ip = frame.ip();\n  let symbol_address = frame.symbol_address();\n  // Resolve this instruction pointer to a symbol name\n  backtrace::resolve_frame(frame, |symbol| {\n    if let Some(name) = symbol.name() {\n      // ...\n    }\n    if let Some(filename) = symbol.filename() {\n      // ...\n    }\n  });\n  true // keep going to the next frame\n});\n```\n\n## \u00a7\u27e85\u27e9Backtrace accuracy\nThis crate implements best-effort attempts to get the native backtrace. This is not always guaranteed to work, and some platforms don\u2019t return any backtrace at all. If your application requires accurate backtraces then it\u2019s recommended to closely evaluate this crate to see whether it\u2019s suitable for your use case on your target platforms.\nEven on supported platforms, there\u2019s a number of reasons that backtraces may be less-than-accurate, including but not limited to:\n  * Unwind information may not be available. This crate primarily implements backtraces by unwinding the stack, but not all functions may have unwinding information (e.g. DWARF unwinding information).\n  * Rust code may be compiled without unwinding information for some functions. This can also happen for Rust code compiled with `-Cpanic=abort`. You can remedy this, however, with `-Cforce-unwind-tables` as a compiler option.\n  * Unwind information may be inaccurate or corrupt. In the worst case inaccurate unwind information can lead this library to segfault. In the best case inaccurate information will result in a truncated stack trace.\n  * Backtraces may not report filenames/line numbers correctly due to missing or corrupt debug information. This won\u2019t lead to segfaults unlike corrupt unwinding information, but missing or malformed debug information will mean that filenames and line numbers will not be available. This may be because debug information wasn\u2019t generated by the compiler, or it\u2019s just missing on the filesystem.\n  * Not all platforms are supported. For example there\u2019s no way to get a backtrace on WebAssembly at the moment.\n  * Crate features may be disabled. Currently this crate supports using Gimli libbacktrace on non-Windows platforms for reading debuginfo for backtraces. If both crate features are disabled, however, then these platforms will generate a backtrace but be unable to generate symbols for it.\n\n\nIn most standard workflows for most standard platforms you generally don\u2019t need to worry about these caveats. We\u2019ll try to fix ones where we can over time, but otherwise it\u2019s important to be aware of the limitations of unwinding-based backtraces!\n## Structs\u00a7\u27e86\u27e9\n\nBacktrace\u27e87\u27e9\n    Representation of an owned and self-contained backtrace.\n\nBacktraceFmt\u27e88\u27e9\n    A formatter for backtraces.\n\nBacktraceFrame\u27e89\u27e9\n    Captured version of a frame in a backtrace.\n\nBacktraceFrameFmt\u27e810\u27e9\n    A formatter for just one frame of a backtrace.\n\nBacktraceSymbol\u27e811\u27e9\n    Captured version of a symbol in a backtrace.\n\nFrame\u27e812\u27e9\n    A trait representing one frame of a backtrace, yielded to the `trace` function of this crate.\n\nSymbol\u27e813\u27e9\n    A trait representing the resolution of a symbol in a file.\n\nSymbolName\u27e814\u27e9\n    A wrapper around a symbol name to provide ergonomic accessors to the demangled name, the raw bytes, the raw string, etc.\n## Enums\u00a7\u27e815\u27e9\n\nBytesOrWideString\u27e816\u27e9\n    A platform independent representation of a string. When working with `std` enabled it is recommended to the convenience methods for providing conversions to `std` types.\n\nPrintFmt\u27e817\u27e9\n    The styles of printing that we can print\n## Functions\u00a7\u27e818\u27e9\n\nclear_symbol_cache\u27e819\u27e9\n    Attempt to reclaim that cached memory used to symbolicate addresses.\n\nresolve\u27e820\u27e9\n    Resolve an address to a symbol, passing the symbol to the specified closure.\n\nresolve_frame\u27e821\u27e9\n    Resolve a previously captured frame to a symbol, passing the symbol to the specified closure.\n\nresolve_frame_unsynchronized\u27e822\u27e9\u26a0\n    Same as `resolve_frame`, only unsafe as it\u2019s unsynchronized.\n\nresolve_unsynchronized\u27e823\u27e9\u26a0\n    Same as `resolve`, only unsafe as it\u2019s unsynchronized.\n\ntrace\u27e824\u27e9\n    Inspects the current call-stack, passing all active frames into the closure provided to calculate a stack trace.\n\ntrace_unsynchronized\u27e825\u27e9\u26a0\n    Same as `trace`, only unsafe as it\u2019s unsynchronized.\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/backtrace/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/backtrace/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/backtrace/latest/src/backtrace/lib.rs.html#1-251: Source\n\u27e84\u27e9 https://docs.rs/backtrace/latest/backtrace/#usage: \u00a7\n\u27e85\u27e9 https://docs.rs/backtrace/latest/backtrace/#backtrace-accuracy: \u00a7\n\u27e86\u27e9 https://docs.rs/backtrace/latest/backtrace/#structs: \u00a7\n\u27e87\u27e9 https://docs.rs/backtrace/latest/backtrace/struct.Backtrace.html: struct backtrace::Backtrace - Backtrace\n\u27e88\u27e9 https://docs.rs/backtrace/latest/backtrace/struct.BacktraceFmt.html: struct backtrace::BacktraceFmt - BacktraceFmt\n\u27e89\u27e9 https://docs.rs/backtrace/latest/backtrace/struct.BacktraceFrame.html: struct backtrace::BacktraceFrame - BacktraceFrame\n\u27e810\u27e9 https://docs.rs/backtrace/latest/backtrace/struct.BacktraceFrameFmt.html: struct backtrace::BacktraceFrameFmt - BacktraceFrameFmt\n\u27e811\u27e9 https://docs.rs/backtrace/latest/backtrace/struct.BacktraceSymbol.html: struct backtrace::BacktraceSymbol - BacktraceSymbol\n\u27e812\u27e9 https://docs.rs/backtrace/latest/backtrace/struct.Frame.html: struct backtrace::Frame - Frame\n\u27e813\u27e9 https://docs.rs/backtrace/latest/backtrace/struct.Symbol.html: struct backtrace::Symbol - Symbol\n\u27e814\u27e9 https://docs.rs/backtrace/latest/backtrace/struct.SymbolName.html: struct backtrace::SymbolName - SymbolName\n\u27e815\u27e9 https://docs.rs/backtrace/latest/backtrace/#enums: \u00a7\n\u27e816\u27e9 https://docs.rs/backtrace/latest/backtrace/enum.BytesOrWideString.html: enum backtrace::BytesOrWideString - BytesOrWideString\n\u27e817\u27e9 https://docs.rs/backtrace/latest/backtrace/enum.PrintFmt.html: enum backtrace::PrintFmt - PrintFmt\n\u27e818\u27e9 https://docs.rs/backtrace/latest/backtrace/#functions: \u00a7\n\u27e819\u27e9 https://docs.rs/backtrace/latest/backtrace/fn.clear_symbol_cache.html: fn backtrace::clear_symbol_cache - clear_symbol_cache\n\u27e820\u27e9 https://docs.rs/backtrace/latest/backtrace/fn.resolve.html: fn backtrace::resolve - resolve\n\u27e821\u27e9 https://docs.rs/backtrace/latest/backtrace/fn.resolve_frame.html: fn backtrace::resolve_frame - resolve_frame\n\u27e822\u27e9 https://docs.rs/backtrace/latest/backtrace/fn.resolve_frame_unsynchronized.html: fn backtrace::resolve_frame_unsynchronized - resolve_frame_unsynchronized\n\u27e823\u27e9 https://docs.rs/backtrace/latest/backtrace/fn.resolve_unsynchronized.html: fn backtrace::resolve_unsynchronized - resolve_unsynchronized\n\u27e824\u27e9 https://docs.rs/backtrace/latest/backtrace/fn.trace.html: fn backtrace::trace - trace\n\u27e825\u27e9 https://docs.rs/backtrace/latest/backtrace/fn.trace_unsynchronized.html: fn backtrace::trace_unsynchronized - trace_unsynchronized\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `backtrace` crate provides runtime programmatic access to stack traces, supplementing the `RUST_BACKTRACE=1` environment variable. It supports resolving instruction pointers to symbols, filenames, and line numbers, with multiple backend implementations for symbolication. Key features include stack unwinding, symbol resolution, and utilities for formatting and managing backtrace data, though accuracy varies across platforms and configurations.",
    "feature_summary": null,
    "use_case": "DevTools",
    "score": 7.0,
    "factual_counterfactual": "### Pair 1: Backtrace Generation\n\u2705 **Factual:** The `backtrace` crate allows programmatic acquisition of stack traces at runtime, supplementing the `RUST_BACKTRACE=1` environment variable functionality in the Rust standard library.  \n\u274c **Counterfactual:** The `backtrace` crate requires `RUST_BACKTRACE=1` to function and cannot generate stack traces programmatically without it.\n\n---\n\n### Pair 2: Platform Support\n\u2705 **Factual:** The `backtrace` crate does not support generating stack traces on WebAssembly due to platform limitations.  \n\u274c **Counterfactual:** The `backtrace` crate has full support for WebAssembly and can generate stack traces on this platform.\n\n---\n\n### Pair 3: Debug Information\n\u2705 **Factual:** Missing or corrupt debug information can prevent the `backtrace` crate from reporting filenames and line numbers in stack traces, though it will still generate the trace itself.  \n\u274c **Counterfactual:** The `backtrace` crate guarantees accurate filenames and line numbers in stack traces, even if debug information is missing or corrupt.",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}