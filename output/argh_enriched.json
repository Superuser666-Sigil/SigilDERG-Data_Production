{
    "name": "argh",
    "version": "0.1.13",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/argh/latest/argh/all.html \"show sidebar\")\n# Crate arghCopy item path\n[Settings](https://docs.rs/argh/latest/settings.html)\n[Help](https://docs.rs/argh/latest/help.html)\nSummary[Source](https://docs.rs/argh/latest/src/argh/lib.rs.html#5-1251)\nExpand description\nDerive-based argument parsing optimized for code size and conformance to the Fuchsia commandline tools specification\nThe public API of this library consists primarily of the `FromArgs` derive and the `from_env` function, which can be used to produce a top-level `FromArgs` type from the current program\u2019s commandline arguments.\n### [\u00a7](https://docs.rs/argh/latest/argh/#basic-example)Basic Example\n```\nuse argh::FromArgs;\n#[derive(FromArgs)]\n/// Reach new heights.\nstruct GoUp {\n  /// whether or not to jump\n  #[argh(switch, short = 'j')]\n  jump: bool,\n  /// how high to go\n  #[argh(option)]\n  height: usize,\n  /// an optional nickname for the pilot\n  #[argh(option)]\n  pilot_nickname: Option<String>,\n}\nlet up: GoUp = argh::from_env();\n```\n\n`./some_bin --help` will then output the following:\n```\nUsage: cmdname [-j] --height <height> [--pilot-nickname <pilot-nickname>]\nReach new heights.\nOptions:\n -j, --jump    whether or not to jump\n --height     how high to go\n --pilot-nickname an optional nickname for the pilot\n --help, help   display usage information\n```\n\nThe resulting program can then be used in any of these ways:\n  * `./some_bin --height 5`\n  * `./some_bin -j --height 5`\n  * `./some_bin --jump --height 5 --pilot-nickname Wes`\n\n\nSwitches, like `jump`, are optional and will be set to true if provided.\nOptions, like `height` and `pilot_nickname`, can be either required, optional, or repeating, depending on whether they are contained in an `Option` or a `Vec`. Default values can be provided using the `#[argh(default = \"<your_code_here>\")]` attribute, and in this case an option is treated as optional.\n```\nuse argh::FromArgs;\nfn default_height() -> usize {\n  5\n}\n#[derive(FromArgs)]\n/// Reach new heights.\n#[argh(help_triggers(\"-h\", \"--help\", \"help\"))]\nstruct GoUp {\n  /// an optional nickname for the pilot\n  #[argh(option)]\n  pilot_nickname: Option<String>,\n  /// an optional height\n  #[argh(option, default = \"default_height()\")]\n  height: usize,\n  /// an optional direction which is \"up\" by default\n  #[argh(option, default = \"String::from(\\\"only up\\\")\")]\n  direction: String,\n}\nfn main() {\n  let up: GoUp = argh::from_env();\n}\n```\n\nCustom option types can be deserialized so long as they implement the `FromArgValue` trait (automatically implemented for all `FromStr` types). If more customized parsing is required, you can supply a custom `fn(&str) -> Result<T, String>` using the `from_str_fn` attribute:\n```\n\n#[derive(FromArgs)]\n/// Goofy thing.\nstruct FiveStruct {\n  /// always five\n  #[argh(option, from_str_fn(always_five))]\n  five: usize,\n}\nfn always_five(_value: &str) -> Result<usize, String> {\n  Ok(5)\n}\n```\n\nPositional arguments can be declared using `#[argh(positional)]`. These arguments will be parsed in order of their declaration in the structure:\n```\nuse argh::FromArgs;\n#[derive(FromArgs, PartialEq, Debug)]\n/// A command with positional arguments.\nstruct WithPositional {\n  #[argh(positional)]\n  first: String,\n}\n```\n\nThe last positional argument may include a default, or be wrapped in `Option` or `Vec` to indicate an optional or repeating positional argument.\nIf your final positional argument has the `greedy` option on it, it will consume any arguments after it as if a `--` were placed before the first argument to match the greedy positional:\n```\nuse argh::FromArgs;\n#[derive(FromArgs, PartialEq, Debug)]\n/// A command with a greedy positional argument at the end.\nstruct WithGreedyPositional {\n  /// some stuff\n  #[argh(option)]\n  stuff: Option<String>,\n  #[argh(positional, greedy)]\n  all_the_rest: Vec<String>,\n}\n```\n\nNow if you pass `--stuff Something` after a positional argument, it will be consumed by `all_the_rest` instead of setting the `stuff` field.\nNote that `all_the_rest` won\u2019t be listed as a positional argument in the long text part of help output (and it will be listed at the end of the usage line as `[all_the_rest...]`), and it\u2019s up to the caller to append any extra help output for the meaning of the captured arguments. This is to enable situations where some amount of argument processing needs to happen before the rest of the arguments can be interpreted, and shouldn\u2019t be used for regular use as it might be confusing.\nSubcommands are also supported. To use a subcommand, declare a separate `FromArgs` type for each subcommand as well as an enum that cases over each command:\n```\n\n#[derive(FromArgs, PartialEq, Debug)]\n/// Top-level command.\nstruct TopLevel {\n  #[argh(subcommand)]\n  nested: MySubCommandEnum,\n}\n#[derive(FromArgs, PartialEq, Debug)]\n#[argh(subcommand)]\nenum MySubCommandEnum {\n  One(SubCommandOne),\n  Two(SubCommandTwo),\n}\n#[derive(FromArgs, PartialEq, Debug)]\n/// First subcommand.\n#[argh(subcommand, name = \"one\")]\nstruct SubCommandOne {\n  #[argh(option)]\n  /// how many x\n  x: usize,\n}\n#[derive(FromArgs, PartialEq, Debug)]\n/// Second subcommand.\n#[argh(subcommand, name = \"two\")]\nstruct SubCommandTwo {\n  #[argh(switch)]\n  /// whether to fooey\n  fooey: bool,\n}\n```\n\nYou can also discover subcommands dynamically at runtime. To do this, declare subcommands as usual and add a variant to the enum with the `dynamic` attribute. Instead of deriving `FromArgs`, the value inside the dynamic variant should implement `DynamicSubCommand`.\n```\n\n#[derive(FromArgs, PartialEq, Debug)]\n/// Top-level command.\nstruct TopLevel {\n  #[argh(subcommand)]\n  nested: MySubCommandEnum,\n}\n#[derive(FromArgs, PartialEq, Debug)]\n#[argh(subcommand)]\nenum MySubCommandEnum {\n  Normal(NormalSubCommand),\n  #[argh(dynamic)]\n  Dynamic(Dynamic),\n}\n#[derive(FromArgs, PartialEq, Debug)]\n/// Normal subcommand.\n#[argh(subcommand, name = \"normal\")]\nstruct NormalSubCommand {\n  #[argh(option)]\n  /// how many x\n  x: usize,\n}\n/// Dynamic subcommand.\n#[derive(PartialEq, Debug)]\nstruct Dynamic {\n  name: String\n}\nimpl DynamicSubCommand for Dynamic {\n  fn commands() -> &'static [&'static CommandInfo] {\n    static RET: OnceCell<Vec<&'static CommandInfo>> = OnceCell::new();\n    RET.get_or_init(|| {\n      let mut commands = Vec::new();\n      // argh needs the `CommandInfo` structs we generate to be valid\n      // for the static lifetime. We can allocate the structures on\n      // the heap with `Box::new` and use `Box::leak` to get a static\n      // reference to them. We could also just use a constant\n      // reference, but only because this is a synthetic example; the\n      // point of using dynamic commands is to have commands you\n      // don't know about until runtime!\n      commands.push(&*Box::leak(Box::new(CommandInfo {\n        name: \"dynamic_command\",\n        description: \"A dynamic command\",\n      })));\n      commands\n    })\n  }\n  fn try_redact_arg_values(\n    command_name: &[&str],\n    args: &[&str],\n  ) -> Option<Result<Vec<String>, EarlyExit>> {\n    for command in Self::commands() {\n      if command_name.last() == Some(&command.name) {\n        // Process arguments and redact values here.\n        if !args.is_empty() {\n          return Some(Err(\"Our example dynamic command never takes arguments!\"\n                  .to_string().into()));\n        }\n        return Some(Ok(Vec::new()))\n      }\n    }\n    None\n  }\n  fn try_from_args(command_name: &[&str], args: &[&str]) -> Option<Result<Self, EarlyExit>> {\n    for command in Self::commands() {\n      if command_name.last() == Some(&command.name) {\n        if !args.is_empty() {\n          return Some(Err(\"Our example dynamic command never takes arguments!\"\n                  .to_string().into()));\n        }\n        return Some(Ok(Dynamic { name: command.name.to_string() }))\n      }\n    }\n    None\n  }\n}\n```\n\nPrograms that are run from an environment such as cargo may find it useful to have positional arguments present in the structure but omitted from the usage output. This can be accomplished by adding the `hidden_help` attribute to that argument:\n```\n\n#[derive(FromArgs)]\n/// Cargo arguments\nstruct CargoArgs {\n  // Cargo puts the command name invoked into the first argument,\n  // so we don't want this argument to show up in the usage text.\n  #[argh(positional, hidden_help)]\n  command: String,\n  /// an option used for internal debugging\n  #[argh(option, hidden_help)]\n  internal_debugging: String,\n  #[argh(positional)]\n  real_first_arg: String,\n}\n```\n\n## Structs[\u00a7](https://docs.rs/argh/latest/argh/#structs)\n\n[EarlyExit](https://docs.rs/argh/latest/argh/struct.EarlyExit.html \"struct argh::EarlyExit\")\n    Information to display to the user about why a `FromArgs` construction exited early.\n\n[ErrorCodeInfo](https://docs.rs/argh/latest/argh/struct.ErrorCodeInfo.html \"struct argh::ErrorCodeInfo\")\n    Information about a documented error code.\n\n[FlagInfo](https://docs.rs/argh/latest/argh/struct.FlagInfo.html \"struct argh::FlagInfo\")\n    Information about a flag or option.\n\n[PositionalInfo](https://docs.rs/argh/latest/argh/struct.PositionalInfo.html \"struct argh::PositionalInfo\")\n    Information about positional arguments\n## Enums[\u00a7](https://docs.rs/argh/latest/argh/#enums)\n\n[FlagInfoKind](https://docs.rs/argh/latest/argh/enum.FlagInfoKind.html \"enum argh::FlagInfoKind\")\n    The kind of flags.\n\n[Optionality](https://docs.rs/argh/latest/argh/enum.Optionality.html \"enum argh::Optionality\")\n    The optionality defines the requirements related to the presence of the argument on the command line.\n## Traits[\u00a7](https://docs.rs/argh/latest/argh/#traits)\n\n[ArgsInfo](https://docs.rs/argh/latest/argh/trait.ArgsInfo.html \"trait argh::ArgsInfo\")\n    Structured information about the command line arguments.\n\n[DynamicSubCommand](https://docs.rs/argh/latest/argh/trait.DynamicSubCommand.html \"trait argh::DynamicSubCommand\")\n    Trait implemented by values returned from a dynamic subcommand handler.\n\n[Flag](https://docs.rs/argh/latest/argh/trait.Flag.html \"trait argh::Flag\")\n    A type which can be the receiver of a `Flag`.\n\n[FromArgValue](https://docs.rs/argh/latest/argh/trait.FromArgValue.html \"trait argh::FromArgValue\")\n    Types which can be constructed from a single commandline value.\n\n[FromArgs](https://docs.rs/argh/latest/argh/trait.FromArgs.html \"trait argh::FromArgs\")\n    Types which can be constructed from a set of commandline arguments.\n\n[SubCommand](https://docs.rs/argh/latest/argh/trait.SubCommand.html \"trait argh::SubCommand\")\n    A `FromArgs` implementation that represents a single subcommand.\n\n[SubCommands](https://docs.rs/argh/latest/argh/trait.SubCommands.html \"trait argh::SubCommands\")\n    A `FromArgs` implementation that can parse into one or more subcommands.\n\n[TopLevelCommand](https://docs.rs/argh/latest/argh/trait.TopLevelCommand.html \"trait argh::TopLevelCommand\")\n    A top-level `FromArgs` implementation that is not a subcommand.\n## Functions[\u00a7](https://docs.rs/argh/latest/argh/#functions)\n\n[cargo_from_env](https://docs.rs/argh/latest/argh/fn.cargo_from_env.html \"fn argh::cargo_from_env\")\n    Create a `FromArgs` type from the current process\u2019s `env::args`.\n\n[from_env](https://docs.rs/argh/latest/argh/fn.from_env.html \"fn argh::from_env\")\n    Create a `FromArgs` type from the current process\u2019s `env::args`.\n## Type Aliases[\u00a7](https://docs.rs/argh/latest/argh/#types)\n\n[CommandInfo](https://docs.rs/argh/latest/argh/type.CommandInfo.html \"type argh::CommandInfo\")\n    Information about a particular command used for output.\n\n[CommandInfoWithArgs](https://docs.rs/argh/latest/argh/type.CommandInfoWithArgs.html \"type argh::CommandInfoWithArgs\")\n    Information about the command including the options and arguments.\n\n[SubCommandInfo](https://docs.rs/argh/latest/argh/type.SubCommandInfo.html \"type argh::SubCommandInfo\")\n    Information about a subcommand.\n## Derive Macros[\u00a7](https://docs.rs/argh/latest/argh/#derives)\n\n[ArgsInfo](https://docs.rs/argh/latest/argh/derive.ArgsInfo.html \"derive argh::ArgsInfo\")\n    Entrypoint for `#[derive(ArgsInfo)]`.\n\n[FromArgs](https://docs.rs/argh/latest/argh/derive.FromArgs.html \"derive argh::FromArgs\")\n    Entrypoint for `#[derive(FromArgs)]`.\n",
        "markdown_with_citations": "[](https://docs.rs/argh/latest/argh/all.html \"show sidebar\")\n# Crate arghCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nDerive-based argument parsing optimized for code size and conformance to the Fuchsia commandline tools specification\nThe public API of this library consists primarily of the `FromArgs` derive and the `from_env` function, which can be used to produce a top-level `FromArgs` type from the current program\u2019s commandline arguments.\n### \u00a7\u27e84\u27e9Basic Example\n```\nuse argh::FromArgs;\n#[derive(FromArgs)]\n/// Reach new heights.\nstruct GoUp {\n  /// whether or not to jump\n  #[argh(switch, short = 'j')]\n  jump: bool,\n  /// how high to go\n  #[argh(option)]\n  height: usize,\n  /// an optional nickname for the pilot\n  #[argh(option)]\n  pilot_nickname: Option<String>,\n}\nlet up: GoUp = argh::from_env();\n```\n\n`./some_bin --help` will then output the following:\n```\nUsage: cmdname [-j] --height <height> [--pilot-nickname <pilot-nickname>]\nReach new heights.\nOptions:\n -j, --jump    whether or not to jump\n --height     how high to go\n --pilot-nickname an optional nickname for the pilot\n --help, help   display usage information\n```\n\nThe resulting program can then be used in any of these ways:\n  * `./some_bin --height 5`\n  * `./some_bin -j --height 5`\n  * `./some_bin --jump --height 5 --pilot-nickname Wes`\n\n\nSwitches, like `jump`, are optional and will be set to true if provided.\nOptions, like `height` and `pilot_nickname`, can be either required, optional, or repeating, depending on whether they are contained in an `Option` or a `Vec`. Default values can be provided using the `#[argh(default = \"<your_code_here>\")]` attribute, and in this case an option is treated as optional.\n```\nuse argh::FromArgs;\nfn default_height() -> usize {\n  5\n}\n#[derive(FromArgs)]\n/// Reach new heights.\n#[argh(help_triggers(\"-h\", \"--help\", \"help\"))]\nstruct GoUp {\n  /// an optional nickname for the pilot\n  #[argh(option)]\n  pilot_nickname: Option<String>,\n  /// an optional height\n  #[argh(option, default = \"default_height()\")]\n  height: usize,\n  /// an optional direction which is \"up\" by default\n  #[argh(option, default = \"String::from(\\\"only up\\\")\")]\n  direction: String,\n}\nfn main() {\n  let up: GoUp = argh::from_env();\n}\n```\n\nCustom option types can be deserialized so long as they implement the `FromArgValue` trait (automatically implemented for all `FromStr` types). If more customized parsing is required, you can supply a custom `fn(&str) -> Result<T, String>` using the `from_str_fn` attribute:\n```\n\n#[derive(FromArgs)]\n/// Goofy thing.\nstruct FiveStruct {\n  /// always five\n  #[argh(option, from_str_fn(always_five))]\n  five: usize,\n}\nfn always_five(_value: &str) -> Result<usize, String> {\n  Ok(5)\n}\n```\n\nPositional arguments can be declared using `#[argh(positional)]`. These arguments will be parsed in order of their declaration in the structure:\n```\nuse argh::FromArgs;\n#[derive(FromArgs, PartialEq, Debug)]\n/// A command with positional arguments.\nstruct WithPositional {\n  #[argh(positional)]\n  first: String,\n}\n```\n\nThe last positional argument may include a default, or be wrapped in `Option` or `Vec` to indicate an optional or repeating positional argument.\nIf your final positional argument has the `greedy` option on it, it will consume any arguments after it as if a `--` were placed before the first argument to match the greedy positional:\n```\nuse argh::FromArgs;\n#[derive(FromArgs, PartialEq, Debug)]\n/// A command with a greedy positional argument at the end.\nstruct WithGreedyPositional {\n  /// some stuff\n  #[argh(option)]\n  stuff: Option<String>,\n  #[argh(positional, greedy)]\n  all_the_rest: Vec<String>,\n}\n```\n\nNow if you pass `--stuff Something` after a positional argument, it will be consumed by `all_the_rest` instead of setting the `stuff` field.\nNote that `all_the_rest` won\u2019t be listed as a positional argument in the long text part of help output (and it will be listed at the end of the usage line as `[all_the_rest...]`), and it\u2019s up to the caller to append any extra help output for the meaning of the captured arguments. This is to enable situations where some amount of argument processing needs to happen before the rest of the arguments can be interpreted, and shouldn\u2019t be used for regular use as it might be confusing.\nSubcommands are also supported. To use a subcommand, declare a separate `FromArgs` type for each subcommand as well as an enum that cases over each command:\n```\n\n#[derive(FromArgs, PartialEq, Debug)]\n/// Top-level command.\nstruct TopLevel {\n  #[argh(subcommand)]\n  nested: MySubCommandEnum,\n}\n#[derive(FromArgs, PartialEq, Debug)]\n#[argh(subcommand)]\nenum MySubCommandEnum {\n  One(SubCommandOne),\n  Two(SubCommandTwo),\n}\n#[derive(FromArgs, PartialEq, Debug)]\n/// First subcommand.\n#[argh(subcommand, name = \"one\")]\nstruct SubCommandOne {\n  #[argh(option)]\n  /// how many x\n  x: usize,\n}\n#[derive(FromArgs, PartialEq, Debug)]\n/// Second subcommand.\n#[argh(subcommand, name = \"two\")]\nstruct SubCommandTwo {\n  #[argh(switch)]\n  /// whether to fooey\n  fooey: bool,\n}\n```\n\nYou can also discover subcommands dynamically at runtime. To do this, declare subcommands as usual and add a variant to the enum with the `dynamic` attribute. Instead of deriving `FromArgs`, the value inside the dynamic variant should implement `DynamicSubCommand`.\n```\n\n#[derive(FromArgs, PartialEq, Debug)]\n/// Top-level command.\nstruct TopLevel {\n  #[argh(subcommand)]\n  nested: MySubCommandEnum,\n}\n#[derive(FromArgs, PartialEq, Debug)]\n#[argh(subcommand)]\nenum MySubCommandEnum {\n  Normal(NormalSubCommand),\n  #[argh(dynamic)]\n  Dynamic(Dynamic),\n}\n#[derive(FromArgs, PartialEq, Debug)]\n/// Normal subcommand.\n#[argh(subcommand, name = \"normal\")]\nstruct NormalSubCommand {\n  #[argh(option)]\n  /// how many x\n  x: usize,\n}\n/// Dynamic subcommand.\n#[derive(PartialEq, Debug)]\nstruct Dynamic {\n  name: String\n}\nimpl DynamicSubCommand for Dynamic {\n  fn commands() -> &'static [&'static CommandInfo] {\n    static RET: OnceCell<Vec<&'static CommandInfo>> = OnceCell::new();\n    RET.get_or_init(|| {\n      let mut commands = Vec::new();\n      // argh needs the `CommandInfo` structs we generate to be valid\n      // for the static lifetime. We can allocate the structures on\n      // the heap with `Box::new` and use `Box::leak` to get a static\n      // reference to them. We could also just use a constant\n      // reference, but only because this is a synthetic example; the\n      // point of using dynamic commands is to have commands you\n      // don't know about until runtime!\n      commands.push(&*Box::leak(Box::new(CommandInfo {\n        name: \"dynamic_command\",\n        description: \"A dynamic command\",\n      })));\n      commands\n    })\n  }\n  fn try_redact_arg_values(\n    command_name: &[&str],\n    args: &[&str],\n  ) -> Option<Result<Vec<String>, EarlyExit>> {\n    for command in Self::commands() {\n      if command_name.last() == Some(&command.name) {\n        // Process arguments and redact values here.\n        if !args.is_empty() {\n          return Some(Err(\"Our example dynamic command never takes arguments!\"\n                  .to_string().into()));\n        }\n        return Some(Ok(Vec::new()))\n      }\n    }\n    None\n  }\n  fn try_from_args(command_name: &[&str], args: &[&str]) -> Option<Result<Self, EarlyExit>> {\n    for command in Self::commands() {\n      if command_name.last() == Some(&command.name) {\n        if !args.is_empty() {\n          return Some(Err(\"Our example dynamic command never takes arguments!\"\n                  .to_string().into()));\n        }\n        return Some(Ok(Dynamic { name: command.name.to_string() }))\n      }\n    }\n    None\n  }\n}\n```\n\nPrograms that are run from an environment such as cargo may find it useful to have positional arguments present in the structure but omitted from the usage output. This can be accomplished by adding the `hidden_help` attribute to that argument:\n```\n\n#[derive(FromArgs)]\n/// Cargo arguments\nstruct CargoArgs {\n  // Cargo puts the command name invoked into the first argument,\n  // so we don't want this argument to show up in the usage text.\n  #[argh(positional, hidden_help)]\n  command: String,\n  /// an option used for internal debugging\n  #[argh(option, hidden_help)]\n  internal_debugging: String,\n  #[argh(positional)]\n  real_first_arg: String,\n}\n```\n\n## Structs\u00a7\u27e85\u27e9\n\nEarlyExit\u27e86\u27e9\n    Information to display to the user about why a `FromArgs` construction exited early.\n\nErrorCodeInfo\u27e87\u27e9\n    Information about a documented error code.\n\nFlagInfo\u27e88\u27e9\n    Information about a flag or option.\n\nPositionalInfo\u27e89\u27e9\n    Information about positional arguments\n## Enums\u00a7\u27e810\u27e9\n\nFlagInfoKind\u27e811\u27e9\n    The kind of flags.\n\nOptionality\u27e812\u27e9\n    The optionality defines the requirements related to the presence of the argument on the command line.\n## Traits\u00a7\u27e813\u27e9\n\nArgsInfo\u27e814\u27e9\n    Structured information about the command line arguments.\n\nDynamicSubCommand\u27e815\u27e9\n    Trait implemented by values returned from a dynamic subcommand handler.\n\nFlag\u27e816\u27e9\n    A type which can be the receiver of a `Flag`.\n\nFromArgValue\u27e817\u27e9\n    Types which can be constructed from a single commandline value.\n\nFromArgs\u27e818\u27e9\n    Types which can be constructed from a set of commandline arguments.\n\nSubCommand\u27e819\u27e9\n    A `FromArgs` implementation that represents a single subcommand.\n\nSubCommands\u27e820\u27e9\n    A `FromArgs` implementation that can parse into one or more subcommands.\n\nTopLevelCommand\u27e821\u27e9\n    A top-level `FromArgs` implementation that is not a subcommand.\n## Functions\u00a7\u27e822\u27e9\n\ncargo_from_env\u27e823\u27e9\n    Create a `FromArgs` type from the current process\u2019s `env::args`.\n\nfrom_env\u27e824\u27e9\n    Create a `FromArgs` type from the current process\u2019s `env::args`.\n## Type Aliases\u00a7\u27e825\u27e9\n\nCommandInfo\u27e826\u27e9\n    Information about a particular command used for output.\n\nCommandInfoWithArgs\u27e827\u27e9\n    Information about the command including the options and arguments.\n\nSubCommandInfo\u27e828\u27e9\n    Information about a subcommand.\n## Derive Macros\u00a7\u27e829\u27e9\n\nArgsInfo\u27e830\u27e9\n    Entrypoint for `#[derive(ArgsInfo)]`.\n\nFromArgs\u27e831\u27e9\n    Entrypoint for `#[derive(FromArgs)]`.\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/argh/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/argh/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/argh/latest/src/argh/lib.rs.html#5-1251: Source\n\u27e84\u27e9 https://docs.rs/argh/latest/argh/#basic-example: \u00a7\n\u27e85\u27e9 https://docs.rs/argh/latest/argh/#structs: \u00a7\n\u27e86\u27e9 https://docs.rs/argh/latest/argh/struct.EarlyExit.html: struct argh::EarlyExit - EarlyExit\n\u27e87\u27e9 https://docs.rs/argh/latest/argh/struct.ErrorCodeInfo.html: struct argh::ErrorCodeInfo - ErrorCodeInfo\n\u27e88\u27e9 https://docs.rs/argh/latest/argh/struct.FlagInfo.html: struct argh::FlagInfo - FlagInfo\n\u27e89\u27e9 https://docs.rs/argh/latest/argh/struct.PositionalInfo.html: struct argh::PositionalInfo - PositionalInfo\n\u27e810\u27e9 https://docs.rs/argh/latest/argh/#enums: \u00a7\n\u27e811\u27e9 https://docs.rs/argh/latest/argh/enum.FlagInfoKind.html: enum argh::FlagInfoKind - FlagInfoKind\n\u27e812\u27e9 https://docs.rs/argh/latest/argh/enum.Optionality.html: enum argh::Optionality - Optionality\n\u27e813\u27e9 https://docs.rs/argh/latest/argh/#traits: \u00a7\n\u27e814\u27e9 https://docs.rs/argh/latest/argh/trait.ArgsInfo.html: trait argh::ArgsInfo - ArgsInfo\n\u27e815\u27e9 https://docs.rs/argh/latest/argh/trait.DynamicSubCommand.html: trait argh::DynamicSubCommand - DynamicSubCommand\n\u27e816\u27e9 https://docs.rs/argh/latest/argh/trait.Flag.html: trait argh::Flag - Flag\n\u27e817\u27e9 https://docs.rs/argh/latest/argh/trait.FromArgValue.html: trait argh::FromArgValue - FromArgValue\n\u27e818\u27e9 https://docs.rs/argh/latest/argh/trait.FromArgs.html: trait argh::FromArgs - FromArgs\n\u27e819\u27e9 https://docs.rs/argh/latest/argh/trait.SubCommand.html: trait argh::SubCommand - SubCommand\n\u27e820\u27e9 https://docs.rs/argh/latest/argh/trait.SubCommands.html: trait argh::SubCommands - SubCommands\n\u27e821\u27e9 https://docs.rs/argh/latest/argh/trait.TopLevelCommand.html: trait argh::TopLevelCommand - TopLevelCommand\n\u27e822\u27e9 https://docs.rs/argh/latest/argh/#functions: \u00a7\n\u27e823\u27e9 https://docs.rs/argh/latest/argh/fn.cargo_from_env.html: fn argh::cargo_from_env - cargo_from_env\n\u27e824\u27e9 https://docs.rs/argh/latest/argh/fn.from_env.html: fn argh::from_env - from_env\n\u27e825\u27e9 https://docs.rs/argh/latest/argh/#types: \u00a7\n\u27e826\u27e9 https://docs.rs/argh/latest/argh/type.CommandInfo.html: type argh::CommandInfo - CommandInfo\n\u27e827\u27e9 https://docs.rs/argh/latest/argh/type.CommandInfoWithArgs.html: type argh::CommandInfoWithArgs - CommandInfoWithArgs\n\u27e828\u27e9 https://docs.rs/argh/latest/argh/type.SubCommandInfo.html: type argh::SubCommandInfo - SubCommandInfo\n\u27e829\u27e9 https://docs.rs/argh/latest/argh/#derives: \u00a7\n\u27e830\u27e9 https://docs.rs/argh/latest/argh/derive.ArgsInfo.html: derive argh::ArgsInfo - ArgsInfo\n\u27e831\u27e9 https://docs.rs/argh/latest/argh/derive.FromArgs.html: derive argh::FromArgs - FromArgs\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `argh` crate provides derive-based argument parsing optimized for minimal code size and adherence to the Fuchsia command-line tools specification. It supports parsing switches, options (with defaults), positional arguments, subcommands (including dynamic discovery), and custom deserialization via the `FromArgs` derive macro. It is designed for simplicity and flexibility in handling command-line inputs.",
    "feature_summary": null,
    "use_case": "Utilities",
    "score": 4.0,
    "factual_counterfactual": "### Pair 1: Argument Parsing\n\u2705 Factual: The `argh` crate allows you to define command-line arguments using the `FromArgs` derive macro, supporting switches, options, and positional arguments.  \n\u274c Counterfactual: The `argh` crate requires you to manually implement argument parsing logic without any derive macros or helper functions.  \n\n---\n\n### Pair 2: Subcommands\n\u2705 Factual: The `argh` crate supports subcommands by using enums annotated with the `#[argh(subcommand)]` attribute, enabling nested command structures.  \n\u274c Counterfactual: The `argh` crate does not support subcommands and only works with flat, top-level command structures.  \n\n---\n\n### Pair 3: Default Values\n\u2705 Factual: The `argh` crate allows you to specify default values for options using the `#[argh(default = \"<your_code_here>\")]` attribute.  \n\u274c Counterfactual: The `argh` crate does not support default values for options, requiring all options to be explicitly provided by the user.",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}