{
    "name": "indicatif",
    "version": "0.17.11",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/indicatif/latest/indicatif/all.html \"show sidebar\")\n# Crate indicatifCopy item path\n[Settings](https://docs.rs/indicatif/latest/settings.html)\n[Help](https://docs.rs/indicatif/latest/help.html)\nSummary[Source](https://docs.rs/indicatif/latest/src/indicatif/lib.rs.html#1-292)\nExpand description\nindicatif is a library for Rust that helps you build command line interfaces that report progress to users. It comes with various tools and utilities for formatting anything that indicates progress.\nPlatform support:\n  * Linux\n  * macOS\n  * Windows (colors require Windows 10)\n\n\nBest paired with other libraries in the family:\n  * [console](https://docs.rs/console)\n  * [dialoguer](https://docs.rs/dialoguer)\n\n\n## [\u00a7](https://docs.rs/indicatif/latest/indicatif/#crate-contents)Crate Contents\n  * **Progress bars**\n    * [`ProgressBar`](https://docs.rs/indicatif/latest/indicatif/struct.ProgressBar.html) for bars and spinners\n    * [`MultiProgress`](https://docs.rs/indicatif/latest/indicatif/struct.MultiProgress.html) for multiple bars\n  * **Data Formatting**\n    * [`HumanBytes`](https://docs.rs/indicatif/latest/indicatif/struct.HumanBytes.html) for formatting bytes\n    * [`DecimalBytes`](https://docs.rs/indicatif/latest/indicatif/struct.DecimalBytes.html) for formatting bytes using SI prefixes\n    * [`BinaryBytes`](https://docs.rs/indicatif/latest/indicatif/struct.BinaryBytes.html) for formatting bytes using ISO/IEC prefixes\n    * [`HumanDuration`](https://docs.rs/indicatif/latest/indicatif/struct.HumanDuration.html) for formatting durations\n    * [`HumanCount`](https://docs.rs/indicatif/latest/indicatif/struct.HumanCount.html) for formatting large counts\n    * [`HumanFloatCount`](https://docs.rs/indicatif/latest/indicatif/struct.HumanFloatCount.html) for formatting large float counts\n\n\n## [\u00a7](https://docs.rs/indicatif/latest/indicatif/#progress-bars-and-spinners)Progress Bars and Spinners\nindicatif comes with a [`ProgressBar`](https://docs.rs/indicatif/latest/indicatif/struct.ProgressBar.html \"struct indicatif::ProgressBar\") type that supports both bounded progress bar uses as well as unbounded \u201cspinner\u201d type progress reports. Progress bars are [`Sync`](https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html \"trait core::marker::Sync\") and [`Send`](https://doc.rust-lang.org/nightly/core/marker/trait.Send.html \"trait core::marker::Send\") objects which means that they are internally locked and can be passed from thread to thread.\nAdditionally a [`MultiProgress`](https://docs.rs/indicatif/latest/indicatif/struct.MultiProgress.html \"struct indicatif::MultiProgress\") utility is provided that can manage rendering multiple progress bars at once (eg: from multiple threads).\nTo whet your appetite, this is what this can look like:\n![](https://github.com/console-rs/indicatif/raw/main/screenshots/yarn.gif?raw=true)\nProgress bars are manually advanced and by default draw to stderr. When you are done, the progress bar can be finished either visibly (eg: the progress bar stays on the screen) or cleared (the progress bar will be removed).\n```\nuse indicatif::ProgressBar;\nlet bar = ProgressBar::new(1000);\nfor _ in 0..1000 {\n  bar.inc(1);\n  // ...\n}\nbar.finish();\n```\n\nSpinners can be manually advanced with [`tick`](https://docs.rs/indicatif/latest/indicatif/struct.ProgressBar.html#method.tick \"method indicatif::ProgressBar::tick\"), or you can set them up to spin automatically with [`enable_steady_tick`](https://docs.rs/indicatif/latest/indicatif/struct.ProgressBar.html#method.enable_steady_tick \"method indicatif::ProgressBar::enable_steady_tick\"):\n```\nuse std::time::Duration;\nuse indicatif::ProgressBar;\nlet bar = ProgressBar::new_spinner();\nbar.enable_steady_tick(Duration::from_millis(100));\n// ... do some work\nbar.finish();\n```\n\nGeneral progress bar behaviors:\n  * if a non terminal is detected the progress bar will be completely hidden. This makes piping programs to logfiles make sense out of the box.\n  * a progress bar only starts drawing when [`set_message`](https://docs.rs/indicatif/latest/indicatif/struct.ProgressBar.html#method.set_message \"method indicatif::ProgressBar::set_message\"), [`inc`](https://docs.rs/indicatif/latest/indicatif/struct.ProgressBar.html#method.inc \"method indicatif::ProgressBar::inc\"), [`set_position`](https://docs.rs/indicatif/latest/indicatif/struct.ProgressBar.html#method.set_position \"method indicatif::ProgressBar::set_position\") or [`tick`](https://docs.rs/indicatif/latest/indicatif/struct.ProgressBar.html#method.tick \"method indicatif::ProgressBar::tick\") are called. In some situations you might have to call [`tick`](https://docs.rs/indicatif/latest/indicatif/struct.ProgressBar.html#method.tick \"method indicatif::ProgressBar::tick\") once to draw it.\n  * progress bars should be explicitly finished to reset the rendering for others. Either by also clearing them or by replacing them with a new message / retaining the current message.\n  * the default template renders neither message nor prefix.\n\n\n## [\u00a7](https://docs.rs/indicatif/latest/indicatif/#iterators)Iterators\nSimilar to [tqdm](https://github.com/tqdm/tqdm), progress bars can be associated with an iterator. For example:\n```\nuse indicatif::ProgressIterator;\nfor _ in (0..1000).progress() {\n  // ...\n}\n```\n\nSee the [`ProgressIterator`](https://docs.rs/indicatif/latest/indicatif/trait.ProgressIterator.html) trait for more methods to configure the number of elements in the iterator or change the progress bar style. Indicatif also has optional support for parallel iterators with [Rayon](https://github.com/rayon-rs/rayon). In your `Cargo.toml`, use the \u201crayon\u201d feature:\n```\n[dependencies]\nindicatif = {version = \"*\", features = [\"rayon\"]}\n```\n\nAnd then use it like this:\n[\u24d8](https://docs.rs/indicatif/latest/indicatif/ \"This example is not tested\")```\nuse indicatif::ParallelProgressIterator;\nuse rayon::iter::{ParallelIterator, IntoParallelRefIterator};\nlet v: Vec<_> = (0..100000).collect();\nlet v2: Vec<_> = v.par_iter().progress_count(v.len() as u64).map(|i| i + 1).collect();\nassert_eq!(v2[0], 1);\n```\n\nOr if you\u2019d like to customize the progress bar:\n[\u24d8](https://docs.rs/indicatif/latest/indicatif/ \"This example is not tested\")```\nuse indicatif::{ProgressBar, ParallelProgressIterator, ProgressStyle};\nuse rayon::iter::{ParallelIterator, IntoParallelRefIterator};\n// Alternatively, use `ProgressBar::new().with_style()`\nlet style = ProgressStyle::default_bar();\nlet v: Vec<_> = (0..100000).collect();\nlet v2: Vec<_> = v.par_iter().progress_with_style(style).map(|i| i + 1).collect();\nassert_eq!(v2[0], 1);\n```\n\n## [\u00a7](https://docs.rs/indicatif/latest/indicatif/#templates)Templates\nProgress bars can be styled with simple format strings similar to the ones in Rust itself. The format for a placeholder is `{key:options}` where the `options` part is optional. If provided the format is this:\n```\n<^>       for an optional alignment specification (left, center and right respectively)\nWIDTH      an optional width as positive integer\n!        an optional exclamation mark to enable truncation\n.STYLE     an optional dot separated style string\n/STYLE     an optional dot separated alternative style string\n```\n\nFor the style component see [`Style::from_dotted_str`](https://docs.rs/console/0.7.5/console/struct.Style.html#method.from_dotted_str) for more information. Indicatif uses the `console` base crate for all colorization and formatting options.\nSome examples for templates:\n```\n[{elapsed_precise}] {bar:40.cyan/blue} {pos:>7}/{len:7} {msg}\n```\n\nThis sets a progress bar that is 40 characters wide and has cyan as primary style color and blue as alternative style color. Alternative styles are currently only used for progress bars.\nExample configuration:\n```\nbar.set_style(ProgressStyle::with_template(\"[{elapsed_precise}] {bar:40.cyan/blue} {pos:>7}/{len:7} {msg}\")\n  .unwrap()\n  .progress_chars(\"##-\"));\n```\n\nThe following keys exist:\n  * `bar`: renders a progress bar. By default 20 characters wide. The style string is used to color the elapsed part, the alternative style is used for the bar that is yet to render.\n  * `wide_bar`: like `bar` but always fills the remaining space. It should not be used with `wide_msg`.\n  * `spinner`: renders the spinner (current tick string). Note that spinners do not automatically tick by default. You either need to call `enable_steady_tick` or manually call `tick`.\n  * `prefix`: renders the prefix set on the progress bar.\n  * `msg`: renders the currently set message on the progress bar.\n  * `wide_msg`: like `msg` but always fills the remaining space and truncates. It should not be used with `wide_bar`.\n  * `pos`: renders the current position of the bar as integer\n  * `human_pos`: renders the current position of the bar as an integer, with commas as the thousands separator.\n  * `len`: renders the amount of work to be done as an integer\n  * `human_len`: renders the total length of the bar as an integer, with commas as the thousands separator.\n  * `percent`: renders the current position of the bar as a percentage of the total length (as an integer).\n  * `percent_precise`: renders the current position of the bar as a percentage of the total length (with 3 fraction digits).\n  * `bytes`: renders the current position of the bar as bytes (alias of `binary_bytes`).\n  * `total_bytes`: renders the total length of the bar as bytes (alias of `binary_total_bytes`).\n  * `decimal_bytes`: renders the current position of the bar as bytes using power-of-10 units, i.e. `MB`, `kB`, etc.\n  * `decimal_total_bytes`: renders the total length of the bar as bytes using power-of-10 units, i.e. `MB`, `kB`, etc.\n  * `binary_bytes`: renders the current position of the bar as bytes using power-of-two units, i.e. `MiB`, `KiB`, etc.\n  * `binary_total_bytes`: renders the total length of the bar as bytes using power-of-two units, i.e. `MiB`, `KiB`, etc.\n  * `elapsed_precise`: renders the elapsed time as `HH:MM:SS`.\n  * `elapsed`: renders the elapsed time as `42s`, `1m` etc.\n  * `per_sec`: renders the speed in steps per second.\n  * `bytes_per_sec`: renders the speed in bytes per second (alias of `binary_bytes_per_sec`).\n  * `decimal_bytes_per_sec`: renders the speed in bytes per second using power-of-10 units, i.e. `MB`, `kB`, etc.\n  * `binary_bytes_per_sec`: renders the speed in bytes per second using power-of-two units, i.e. `MiB`, `KiB`, etc.\n  * `eta_precise`: the remaining time (like `elapsed_precise`).\n  * `eta`: the remaining time (like `elapsed`).\n  * `duration_precise`: the extrapolated total duration (like `elapsed_precise`).\n  * `duration`: the extrapolated total duration time (like `elapsed`).\n\n\nIf the list above does not contain the value you need, consider creating a custom [`ProgressTracker`](https://docs.rs/indicatif/latest/indicatif/style/trait.ProgressTracker.html \"trait indicatif::style::ProgressTracker\") implementation.\nThe design of the progress bar can be altered with the integrated template functionality. The template can be set by changing a [`ProgressStyle`](https://docs.rs/indicatif/latest/indicatif/style/struct.ProgressStyle.html \"struct indicatif::style::ProgressStyle\") and attaching it to the progress bar.\n## [\u00a7](https://docs.rs/indicatif/latest/indicatif/#human-readable-formatting)Human Readable Formatting\nThere are some formatting wrappers for showing elapsed time and file sizes for human users:\n```\nuse indicatif::{HumanBytes, HumanCount, HumanDuration, HumanFloatCount};\nassert_eq!(\"3.00 MiB\", HumanBytes(3*1024*1024).to_string());\nassert_eq!(\"8 seconds\", HumanDuration(Duration::from_secs(8)).to_string());\nassert_eq!(\"33,857,009\", HumanCount(33857009).to_string());\nassert_eq!(\"33,857,009.1235\", HumanFloatCount(33857009.123456).to_string());\n```\n\n## [\u00a7](https://docs.rs/indicatif/latest/indicatif/#feature-flags)Feature Flags\n  * `rayon`: adds rayon support\n  * `improved_unicode`: adds improved unicode support (graphemes, better width calculation)\n\n\n## Re-exports[\u00a7](https://docs.rs/indicatif/latest/indicatif/#reexports)\n\n`pub use crate::style::ProgressStyle[](https://docs.rs/indicatif/latest/indicatif/style/struct.ProgressStyle.html \"struct indicatif::style::ProgressStyle\");`\n\n## Modules[\u00a7](https://docs.rs/indicatif/latest/indicatif/#modules)\n\n[style](https://docs.rs/indicatif/latest/indicatif/style/index.html \"mod indicatif::style\")\n\n## Structs[\u00a7](https://docs.rs/indicatif/latest/indicatif/#structs)\n\n[BinaryBytes](https://docs.rs/indicatif/latest/indicatif/struct.BinaryBytes.html \"struct indicatif::BinaryBytes\")\n    Formats bytes for human readability using ISO/IEC prefixes\n\n[DecimalBytes](https://docs.rs/indicatif/latest/indicatif/struct.DecimalBytes.html \"struct indicatif::DecimalBytes\")\n    Formats bytes for human readability using SI prefixes\n\n[FormattedDuration](https://docs.rs/indicatif/latest/indicatif/struct.FormattedDuration.html \"struct indicatif::FormattedDuration\")\n    Wraps an std duration for human basic formatting.\n\n[HumanBytes](https://docs.rs/indicatif/latest/indicatif/struct.HumanBytes.html \"struct indicatif::HumanBytes\")\n    Formats bytes for human readability\n\n[HumanCount](https://docs.rs/indicatif/latest/indicatif/struct.HumanCount.html \"struct indicatif::HumanCount\")\n    Formats counts for human readability using commas\n\n[HumanDuration](https://docs.rs/indicatif/latest/indicatif/struct.HumanDuration.html \"struct indicatif::HumanDuration\")\n    Wraps an std duration for human readable formatting.\n\n[HumanFloatCount](https://docs.rs/indicatif/latest/indicatif/struct.HumanFloatCount.html \"struct indicatif::HumanFloatCount\")\n    Formats counts for human readability using commas for floats\n\n[InMemoryTerm](https://docs.rs/indicatif/latest/indicatif/struct.InMemoryTerm.html \"struct indicatif::InMemoryTerm\")\n    A thin wrapper around [`vt100::Parser`](https://docs.rs/vt100/0.15.2/x86_64-unknown-linux-gnu/vt100/parser/struct.Parser.html \"struct vt100::parser::Parser\").\n\n[MultiProgress](https://docs.rs/indicatif/latest/indicatif/struct.MultiProgress.html \"struct indicatif::MultiProgress\")\n    Manages multiple progress bars from different threads\n\n[ProgressBar](https://docs.rs/indicatif/latest/indicatif/struct.ProgressBar.html \"struct indicatif::ProgressBar\")\n    A progress bar or spinner\n\n[ProgressBarIter](https://docs.rs/indicatif/latest/indicatif/struct.ProgressBarIter.html \"struct indicatif::ProgressBarIter\")\n    Wraps an iterator to display its progress.\n\n[ProgressDrawTarget](https://docs.rs/indicatif/latest/indicatif/struct.ProgressDrawTarget.html \"struct indicatif::ProgressDrawTarget\")\n    Target for draw operations\n\n[ProgressState](https://docs.rs/indicatif/latest/indicatif/struct.ProgressState.html \"struct indicatif::ProgressState\")\n    The state of a progress bar at a moment in time.\n\n[WeakProgressBar](https://docs.rs/indicatif/latest/indicatif/struct.WeakProgressBar.html \"struct indicatif::WeakProgressBar\")\n    A weak reference to a [`ProgressBar`](https://docs.rs/indicatif/latest/indicatif/struct.ProgressBar.html \"struct indicatif::ProgressBar\").\n## Enums[\u00a7](https://docs.rs/indicatif/latest/indicatif/#enums)\n\n[MultiProgressAlignment](https://docs.rs/indicatif/latest/indicatif/enum.MultiProgressAlignment.html \"enum indicatif::MultiProgressAlignment\")\n    Vertical alignment of a multi progress.\n\n[ProgressFinish](https://docs.rs/indicatif/latest/indicatif/enum.ProgressFinish.html \"enum indicatif::ProgressFinish\")\n    Behavior of a progress bar when it is finished\n## Traits[\u00a7](https://docs.rs/indicatif/latest/indicatif/#traits)\n\n[ParallelProgressIterator](https://docs.rs/indicatif/latest/indicatif/trait.ParallelProgressIterator.html \"trait indicatif::ParallelProgressIterator\")\n    Wraps a Rayon parallel iterator.\n\n[ProgressIterator](https://docs.rs/indicatif/latest/indicatif/trait.ProgressIterator.html \"trait indicatif::ProgressIterator\")\n    Wraps an iterator to display its progress.\n\n[TermLike](https://docs.rs/indicatif/latest/indicatif/trait.TermLike.html \"trait indicatif::TermLike\")\n    A trait for minimal terminal-like behavior.\n",
        "markdown_with_citations": "[](https://docs.rs/indicatif/latest/indicatif/all.html \"show sidebar\")\n# Crate indicatifCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nindicatif is a library for Rust that helps you build command line interfaces that report progress to users. It comes with various tools and utilities for formatting anything that indicates progress.\nPlatform support:\n  * Linux\n  * macOS\n  * Windows (colors require Windows 10)\n\n\nBest paired with other libraries in the family:\n  * console\u27e84\u27e9\n  * dialoguer\u27e85\u27e9\n\n\n## \u00a7\u27e86\u27e9Crate Contents\n  * **Progress bars**\n    * `ProgressBar`\u27e87\u27e9 for bars and spinners\n    * `MultiProgress`\u27e88\u27e9 for multiple bars\n  * **Data Formatting**\n    * `HumanBytes`\u27e89\u27e9 for formatting bytes\n    * `DecimalBytes`\u27e810\u27e9 for formatting bytes using SI prefixes\n    * `BinaryBytes`\u27e811\u27e9 for formatting bytes using ISO/IEC prefixes\n    * `HumanDuration`\u27e812\u27e9 for formatting durations\n    * `HumanCount`\u27e813\u27e9 for formatting large counts\n    * `HumanFloatCount`\u27e814\u27e9 for formatting large float counts\n\n\n## \u00a7\u27e815\u27e9Progress Bars and Spinners\nindicatif comes with a `ProgressBar`\u27e87\u27e9 type that supports both bounded progress bar uses as well as unbounded \u201cspinner\u201d type progress reports. Progress bars are `Sync`\u27e816\u27e9 and `Send`\u27e817\u27e9 objects which means that they are internally locked and can be passed from thread to thread.\nAdditionally a `MultiProgress`\u27e88\u27e9 utility is provided that can manage rendering multiple progress bars at once (eg: from multiple threads).\nTo whet your appetite, this is what this can look like:\n![](https://github.com/console-rs/indicatif/raw/main/screenshots/yarn.gif?raw=true)\nProgress bars are manually advanced and by default draw to stderr. When you are done, the progress bar can be finished either visibly (eg: the progress bar stays on the screen) or cleared (the progress bar will be removed).\n```\nuse indicatif::ProgressBar;\nlet bar = ProgressBar::new(1000);\nfor _ in 0..1000 {\n  bar.inc(1);\n  // ...\n}\nbar.finish();\n```\n\nSpinners can be manually advanced with `tick`\u27e818\u27e9, or you can set them up to spin automatically with `enable_steady_tick`\u27e819\u27e9:\n```\nuse std::time::Duration;\nuse indicatif::ProgressBar;\nlet bar = ProgressBar::new_spinner();\nbar.enable_steady_tick(Duration::from_millis(100));\n// ... do some work\nbar.finish();\n```\n\nGeneral progress bar behaviors:\n  * if a non terminal is detected the progress bar will be completely hidden. This makes piping programs to logfiles make sense out of the box.\n  * a progress bar only starts drawing when `set_message`\u27e820\u27e9, `inc`\u27e821\u27e9, `set_position`\u27e822\u27e9 or `tick`\u27e818\u27e9 are called. In some situations you might have to call `tick`\u27e818\u27e9 once to draw it.\n  * progress bars should be explicitly finished to reset the rendering for others. Either by also clearing them or by replacing them with a new message / retaining the current message.\n  * the default template renders neither message nor prefix.\n\n\n## \u00a7\u27e823\u27e9Iterators\nSimilar to tqdm\u27e824\u27e9, progress bars can be associated with an iterator. For example:\n```\nuse indicatif::ProgressIterator;\nfor _ in (0..1000).progress() {\n  // ...\n}\n```\n\nSee the `ProgressIterator`\u27e825\u27e9 trait for more methods to configure the number of elements in the iterator or change the progress bar style. Indicatif also has optional support for parallel iterators with Rayon\u27e826\u27e9. In your `Cargo.toml`, use the \u201crayon\u201d feature:\n```\n[dependencies]\nindicatif = {version = \"*\", features = [\"rayon\"]}\n```\n\nAnd then use it like this:\n\u24d8\u27e827\u27e9```\nuse indicatif::ParallelProgressIterator;\nuse rayon::iter::{ParallelIterator, IntoParallelRefIterator};\nlet v: Vec<_> = (0..100000).collect();\nlet v2: Vec<_> = v.par_iter().progress_count(v.len() as u64).map(|i| i + 1).collect();\nassert_eq!(v2[0], 1);\n```\n\nOr if you\u2019d like to customize the progress bar:\n\u24d8\u27e827\u27e9```\nuse indicatif::{ProgressBar, ParallelProgressIterator, ProgressStyle};\nuse rayon::iter::{ParallelIterator, IntoParallelRefIterator};\n// Alternatively, use `ProgressBar::new().with_style()`\nlet style = ProgressStyle::default_bar();\nlet v: Vec<_> = (0..100000).collect();\nlet v2: Vec<_> = v.par_iter().progress_with_style(style).map(|i| i + 1).collect();\nassert_eq!(v2[0], 1);\n```\n\n## \u00a7\u27e828\u27e9Templates\nProgress bars can be styled with simple format strings similar to the ones in Rust itself. The format for a placeholder is `{key:options}` where the `options` part is optional. If provided the format is this:\n```\n<^>       for an optional alignment specification (left, center and right respectively)\nWIDTH      an optional width as positive integer\n!        an optional exclamation mark to enable truncation\n.STYLE     an optional dot separated style string\n/STYLE     an optional dot separated alternative style string\n```\n\nFor the style component see `Style::from_dotted_str`\u27e829\u27e9 for more information. Indicatif uses the `console` base crate for all colorization and formatting options.\nSome examples for templates:\n```\n[{elapsed_precise}] {bar:40.cyan/blue} {pos:>7}/{len:7} {msg}\n```\n\nThis sets a progress bar that is 40 characters wide and has cyan as primary style color and blue as alternative style color. Alternative styles are currently only used for progress bars.\nExample configuration:\n```\nbar.set_style(ProgressStyle::with_template(\"[{elapsed_precise}] {bar:40.cyan/blue} {pos:>7}/{len:7} {msg}\")\n  .unwrap()\n  .progress_chars(\"##-\"));\n```\n\nThe following keys exist:\n  * `bar`: renders a progress bar. By default 20 characters wide. The style string is used to color the elapsed part, the alternative style is used for the bar that is yet to render.\n  * `wide_bar`: like `bar` but always fills the remaining space. It should not be used with `wide_msg`.\n  * `spinner`: renders the spinner (current tick string). Note that spinners do not automatically tick by default. You either need to call `enable_steady_tick` or manually call `tick`.\n  * `prefix`: renders the prefix set on the progress bar.\n  * `msg`: renders the currently set message on the progress bar.\n  * `wide_msg`: like `msg` but always fills the remaining space and truncates. It should not be used with `wide_bar`.\n  * `pos`: renders the current position of the bar as integer\n  * `human_pos`: renders the current position of the bar as an integer, with commas as the thousands separator.\n  * `len`: renders the amount of work to be done as an integer\n  * `human_len`: renders the total length of the bar as an integer, with commas as the thousands separator.\n  * `percent`: renders the current position of the bar as a percentage of the total length (as an integer).\n  * `percent_precise`: renders the current position of the bar as a percentage of the total length (with 3 fraction digits).\n  * `bytes`: renders the current position of the bar as bytes (alias of `binary_bytes`).\n  * `total_bytes`: renders the total length of the bar as bytes (alias of `binary_total_bytes`).\n  * `decimal_bytes`: renders the current position of the bar as bytes using power-of-10 units, i.e. `MB`, `kB`, etc.\n  * `decimal_total_bytes`: renders the total length of the bar as bytes using power-of-10 units, i.e. `MB`, `kB`, etc.\n  * `binary_bytes`: renders the current position of the bar as bytes using power-of-two units, i.e. `MiB`, `KiB`, etc.\n  * `binary_total_bytes`: renders the total length of the bar as bytes using power-of-two units, i.e. `MiB`, `KiB`, etc.\n  * `elapsed_precise`: renders the elapsed time as `HH:MM:SS`.\n  * `elapsed`: renders the elapsed time as `42s`, `1m` etc.\n  * `per_sec`: renders the speed in steps per second.\n  * `bytes_per_sec`: renders the speed in bytes per second (alias of `binary_bytes_per_sec`).\n  * `decimal_bytes_per_sec`: renders the speed in bytes per second using power-of-10 units, i.e. `MB`, `kB`, etc.\n  * `binary_bytes_per_sec`: renders the speed in bytes per second using power-of-two units, i.e. `MiB`, `KiB`, etc.\n  * `eta_precise`: the remaining time (like `elapsed_precise`).\n  * `eta`: the remaining time (like `elapsed`).\n  * `duration_precise`: the extrapolated total duration (like `elapsed_precise`).\n  * `duration`: the extrapolated total duration time (like `elapsed`).\n\n\nIf the list above does not contain the value you need, consider creating a custom `ProgressTracker`\u27e830\u27e9 implementation.\nThe design of the progress bar can be altered with the integrated template functionality. The template can be set by changing a `ProgressStyle`\u27e831\u27e9 and attaching it to the progress bar.\n## \u00a7\u27e832\u27e9Human Readable Formatting\nThere are some formatting wrappers for showing elapsed time and file sizes for human users:\n```\nuse indicatif::{HumanBytes, HumanCount, HumanDuration, HumanFloatCount};\nassert_eq!(\"3.00 MiB\", HumanBytes(3*1024*1024).to_string());\nassert_eq!(\"8 seconds\", HumanDuration(Duration::from_secs(8)).to_string());\nassert_eq!(\"33,857,009\", HumanCount(33857009).to_string());\nassert_eq!(\"33,857,009.1235\", HumanFloatCount(33857009.123456).to_string());\n```\n\n## \u00a7\u27e833\u27e9Feature Flags\n  * `rayon`: adds rayon support\n  * `improved_unicode`: adds improved unicode support (graphemes, better width calculation)\n\n\n## Re-exports\u00a7\u27e834\u27e9\n\n`pub use crate::style::ProgressStyle[](https://docs.rs/indicatif/latest/indicatif/style/struct.ProgressStyle.html \"struct indicatif::style::ProgressStyle\");`\n\n## Modules\u00a7\u27e835\u27e9\n\nstyle\u27e836\u27e9\n\n## Structs\u00a7\u27e837\u27e9\n\nBinaryBytes\u27e811\u27e9\n    Formats bytes for human readability using ISO/IEC prefixes\n\nDecimalBytes\u27e810\u27e9\n    Formats bytes for human readability using SI prefixes\n\nFormattedDuration\u27e838\u27e9\n    Wraps an std duration for human basic formatting.\n\nHumanBytes\u27e89\u27e9\n    Formats bytes for human readability\n\nHumanCount\u27e813\u27e9\n    Formats counts for human readability using commas\n\nHumanDuration\u27e812\u27e9\n    Wraps an std duration for human readable formatting.\n\nHumanFloatCount\u27e814\u27e9\n    Formats counts for human readability using commas for floats\n\nInMemoryTerm\u27e839\u27e9\n    A thin wrapper around `vt100::Parser`\u27e840\u27e9.\n\nMultiProgress\u27e88\u27e9\n    Manages multiple progress bars from different threads\n\nProgressBar\u27e87\u27e9\n    A progress bar or spinner\n\nProgressBarIter\u27e841\u27e9\n    Wraps an iterator to display its progress.\n\nProgressDrawTarget\u27e842\u27e9\n    Target for draw operations\n\nProgressState\u27e843\u27e9\n    The state of a progress bar at a moment in time.\n\nWeakProgressBar\u27e844\u27e9\n    A weak reference to a `ProgressBar`\u27e87\u27e9.\n## Enums\u00a7\u27e845\u27e9\n\nMultiProgressAlignment\u27e846\u27e9\n    Vertical alignment of a multi progress.\n\nProgressFinish\u27e847\u27e9\n    Behavior of a progress bar when it is finished\n## Traits\u00a7\u27e848\u27e9\n\nParallelProgressIterator\u27e849\u27e9\n    Wraps a Rayon parallel iterator.\n\nProgressIterator\u27e825\u27e9\n    Wraps an iterator to display its progress.\n\nTermLike\u27e850\u27e9\n    A trait for minimal terminal-like behavior.\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/indicatif/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/indicatif/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/indicatif/latest/src/indicatif/lib.rs.html#1-292: Source\n\u27e84\u27e9 https://docs.rs/console: console\n\u27e85\u27e9 https://docs.rs/dialoguer: dialoguer\n\u27e86\u27e9 https://docs.rs/indicatif/latest/indicatif/#crate-contents: \u00a7\n\u27e87\u27e9 https://docs.rs/indicatif/latest/indicatif/struct.ProgressBar.html: `ProgressBar`\n\u27e88\u27e9 https://docs.rs/indicatif/latest/indicatif/struct.MultiProgress.html: `MultiProgress`\n\u27e89\u27e9 https://docs.rs/indicatif/latest/indicatif/struct.HumanBytes.html: `HumanBytes`\n\u27e810\u27e9 https://docs.rs/indicatif/latest/indicatif/struct.DecimalBytes.html: `DecimalBytes`\n\u27e811\u27e9 https://docs.rs/indicatif/latest/indicatif/struct.BinaryBytes.html: `BinaryBytes`\n\u27e812\u27e9 https://docs.rs/indicatif/latest/indicatif/struct.HumanDuration.html: `HumanDuration`\n\u27e813\u27e9 https://docs.rs/indicatif/latest/indicatif/struct.HumanCount.html: `HumanCount`\n\u27e814\u27e9 https://docs.rs/indicatif/latest/indicatif/struct.HumanFloatCount.html: `HumanFloatCount`\n\u27e815\u27e9 https://docs.rs/indicatif/latest/indicatif/#progress-bars-and-spinners: \u00a7\n\u27e816\u27e9 https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html: trait core::marker::Sync - `Sync`\n\u27e817\u27e9 https://doc.rust-lang.org/nightly/core/marker/trait.Send.html: trait core::marker::Send - `Send`\n\u27e818\u27e9 https://docs.rs/indicatif/latest/indicatif/struct.ProgressBar.html#method.tick: method indicatif::ProgressBar::tick - `tick`\n\u27e819\u27e9 https://docs.rs/indicatif/latest/indicatif/struct.ProgressBar.html#method.enable_steady_tick: method indicatif::ProgressBar::enable_steady_tick - `enable_steady_tick`\n\u27e820\u27e9 https://docs.rs/indicatif/latest/indicatif/struct.ProgressBar.html#method.set_message: method indicatif::ProgressBar::set_message - `set_message`\n\u27e821\u27e9 https://docs.rs/indicatif/latest/indicatif/struct.ProgressBar.html#method.inc: method indicatif::ProgressBar::inc - `inc`\n\u27e822\u27e9 https://docs.rs/indicatif/latest/indicatif/struct.ProgressBar.html#method.set_position: method indicatif::ProgressBar::set_position - `set_position`\n\u27e823\u27e9 https://docs.rs/indicatif/latest/indicatif/#iterators: \u00a7\n\u27e824\u27e9 https://github.com/tqdm/tqdm: tqdm\n\u27e825\u27e9 https://docs.rs/indicatif/latest/indicatif/trait.ProgressIterator.html: `ProgressIterator`\n\u27e826\u27e9 https://github.com/rayon-rs/rayon: Rayon\n\u27e827\u27e9 https://docs.rs/indicatif/latest/indicatif/: This example is not tested - \u24d8\n\u27e828\u27e9 https://docs.rs/indicatif/latest/indicatif/#templates: \u00a7\n\u27e829\u27e9 https://docs.rs/console/0.7.5/console/struct.Style.html#method.from_dotted_str: `Style::from_dotted_str`\n\u27e830\u27e9 https://docs.rs/indicatif/latest/indicatif/style/trait.ProgressTracker.html: trait indicatif::style::ProgressTracker - `ProgressTracker`\n\u27e831\u27e9 https://docs.rs/indicatif/latest/indicatif/style/struct.ProgressStyle.html: struct indicatif::style::ProgressStyle - `ProgressStyle`\n\u27e832\u27e9 https://docs.rs/indicatif/latest/indicatif/#human-readable-formatting: \u00a7\n\u27e833\u27e9 https://docs.rs/indicatif/latest/indicatif/#feature-flags: \u00a7\n\u27e834\u27e9 https://docs.rs/indicatif/latest/indicatif/#reexports: \u00a7\n\u27e835\u27e9 https://docs.rs/indicatif/latest/indicatif/#modules: \u00a7\n\u27e836\u27e9 https://docs.rs/indicatif/latest/indicatif/style/index.html: mod indicatif::style - style\n\u27e837\u27e9 https://docs.rs/indicatif/latest/indicatif/#structs: \u00a7\n\u27e838\u27e9 https://docs.rs/indicatif/latest/indicatif/struct.FormattedDuration.html: struct indicatif::FormattedDuration - FormattedDuration\n\u27e839\u27e9 https://docs.rs/indicatif/latest/indicatif/struct.InMemoryTerm.html: struct indicatif::InMemoryTerm - InMemoryTerm\n\u27e840\u27e9 https://docs.rs/vt100/0.15.2/x86_64-unknown-linux-gnu/vt100/parser/struct.Parser.html: struct vt100::parser::Parser - `vt100::Parser`\n\u27e841\u27e9 https://docs.rs/indicatif/latest/indicatif/struct.ProgressBarIter.html: struct indicatif::ProgressBarIter - ProgressBarIter\n\u27e842\u27e9 https://docs.rs/indicatif/latest/indicatif/struct.ProgressDrawTarget.html: struct indicatif::ProgressDrawTarget - ProgressDrawTarget\n\u27e843\u27e9 https://docs.rs/indicatif/latest/indicatif/struct.ProgressState.html: struct indicatif::ProgressState - ProgressState\n\u27e844\u27e9 https://docs.rs/indicatif/latest/indicatif/struct.WeakProgressBar.html: struct indicatif::WeakProgressBar - WeakProgressBar\n\u27e845\u27e9 https://docs.rs/indicatif/latest/indicatif/#enums: \u00a7\n\u27e846\u27e9 https://docs.rs/indicatif/latest/indicatif/enum.MultiProgressAlignment.html: enum indicatif::MultiProgressAlignment - MultiProgressAlignment\n\u27e847\u27e9 https://docs.rs/indicatif/latest/indicatif/enum.ProgressFinish.html: enum indicatif::ProgressFinish - ProgressFinish\n\u27e848\u27e9 https://docs.rs/indicatif/latest/indicatif/#traits: \u00a7\n\u27e849\u27e9 https://docs.rs/indicatif/latest/indicatif/trait.ParallelProgressIterator.html: trait indicatif::ParallelProgressIterator - ParallelProgressIterator\n\u27e850\u27e9 https://docs.rs/indicatif/latest/indicatif/trait.TermLike.html: trait indicatif::TermLike - TermLike\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `indicatif` crate is a Rust library for creating progress bars, spinners, and human-readable data formatting in command-line interfaces. It supports single and multi-threaded progress bars (`ProgressBar`, `MultiProgress`), customizable templates, iterator integration (including parallel iterators with Rayon), and formatting utilities for durations, byte sizes, and large numbers. It also offers feature flags for improved Unicode support and Rayon integration.",
    "feature_summary": null,
    "use_case": "Utilities",
    "score": 8.5,
    "factual_counterfactual": "### Pair 1: Progress Bar Features\n\u2705 Factual: The `indicatif` crate provides a `ProgressBar` type that supports both bounded progress bars and unbounded spinner-type progress reports, making it suitable for a variety of use cases.  \n\u274c Counterfactual: The `indicatif` crate only supports bounded progress bars and cannot be used for spinner-type progress reports.\n\n---\n\n### Pair 2: Thread Safety\n\u2705 Factual: Progress bars in `indicatif` are `Sync` and `Send`, meaning they are internally locked and can be safely passed between threads for concurrent rendering.  \n\u274c Counterfactual: Progress bars in `indicatif` are not thread-safe and cannot be shared between threads.\n\n---\n\n### Pair 3: Iterator Integration\n\u2705 Factual: `indicatif` integrates with iterators using the `ProgressIterator` trait, allowing developers to track progress while iterating over items, similar to Python's `tqdm`.  \n\u274c Counterfactual: `indicatif` does not support iterator integration, requiring developers to manually update progress bars during iteration.",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}