{
    "name": "base64",
    "version": "0.22.1",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/base64/latest/base64/all.html \"show sidebar\")\n# Crate base64Copy item path\n[Settings](https://docs.rs/base64/latest/settings.html)\n[Help](https://docs.rs/base64/latest/help.html)\nSummary[Source](https://docs.rs/base64/latest/src/base64/lib.rs.html#1-277)\nExpand description\nCorrect, fast, and configurable [base64](https://developer.mozilla.org/en-US/docs/Glossary/Base64) decoding and encoding. Base64 transports binary data efficiently in contexts where only plain text is allowed.\n## [\u00a7](https://docs.rs/base64/latest/base64/#usage)Usage\nUse an [`Engine`](https://docs.rs/base64/latest/base64/engine/trait.Engine.html \"trait base64::engine::Engine\") to decode or encode base64, configured with the base64 alphabet and padding behavior best suited to your application.\n### [\u00a7](https://docs.rs/base64/latest/base64/#engine-setup)Engine setup\nThere is more than one way to encode a stream of bytes as \u201cbase64\u201d. Different applications use different encoding [alphabets](https://docs.rs/base64/latest/base64/alphabet/struct.Alphabet.html \"struct base64::alphabet::Alphabet\") and [padding behaviors](https://docs.rs/base64/latest/base64/engine/general_purpose/struct.GeneralPurposeConfig.html \"struct base64::engine::general_purpose::GeneralPurposeConfig\").\n#### [\u00a7](https://docs.rs/base64/latest/base64/#encoding-alphabet)Encoding alphabet\nAlmost all base64 [alphabets](https://docs.rs/base64/latest/base64/alphabet/struct.Alphabet.html \"struct base64::alphabet::Alphabet\") use `A-Z`, `a-z`, and `0-9`, which gives nearly 64 characters (26 + 26 + 10 = 62), but they differ in their choice of their final 2.\nMost applications use the [standard](https://docs.rs/base64/latest/base64/alphabet/constant.STANDARD.html \"constant base64::alphabet::STANDARD\") alphabet specified in [RFC 4648](https://datatracker.ietf.org/doc/html/rfc4648#section-4). If that\u2019s all you need, you can get started quickly by using the pre-configured [`STANDARD`](https://docs.rs/base64/latest/base64/engine/general_purpose/constant.STANDARD.html \"constant base64::engine::general_purpose::STANDARD\") engine, which is also available in the [`prelude`](https://docs.rs/base64/latest/base64/prelude/index.html \"mod base64::prelude\") module as shown here, if you prefer a minimal `use` footprint.\n```\nuse base64::prelude::*;\nassert_eq!(BASE64_STANDARD.decode(b\"+uwgVQA=\")?, b\"\\xFA\\xEC\\x20\\x55\\0\");\nassert_eq!(BASE64_STANDARD.encode(b\"\\xFF\\xEC\\x20\\x55\\0\"), \"/+wgVQA=\");\n```\n\nOther common alphabets are available in the [`alphabet`](https://docs.rs/base64/latest/base64/alphabet/index.html \"mod base64::alphabet\") module.\n##### [\u00a7](https://docs.rs/base64/latest/base64/#url-safe-alphabet)URL-safe alphabet\nThe standard alphabet uses `+` and `/` as its two non-alphanumeric tokens, which cannot be safely used in URL\u2019s without encoding them as `%2B` and `%2F`.\nTo avoid that, some applications use a [\u201cURL-safe\u201d alphabet](https://docs.rs/base64/latest/base64/alphabet/constant.URL_SAFE.html \"constant base64::alphabet::URL_SAFE\"), which uses `-` and `_` instead. To use that alternative alphabet, use the [`URL_SAFE`](https://docs.rs/base64/latest/base64/engine/general_purpose/constant.URL_SAFE.html \"constant base64::engine::general_purpose::URL_SAFE\") engine. This example doesn\u2019t use [`prelude`](https://docs.rs/base64/latest/base64/prelude/index.html \"mod base64::prelude\") to show what a more explicit `use` would look like.\n```\nuse base64::{engine::general_purpose::URL_SAFE, Engine as _};\nassert_eq!(URL_SAFE.decode(b\"-uwgVQA=\")?, b\"\\xFA\\xEC\\x20\\x55\\0\");\nassert_eq!(URL_SAFE.encode(b\"\\xFF\\xEC\\x20\\x55\\0\"), \"_-wgVQA=\");\n```\n\n#### [\u00a7](https://docs.rs/base64/latest/base64/#padding-characters)Padding characters\nEach base64 character represents 6 bits (2\u2076 = 64) of the original binary data, and every 3 bytes of input binary data will encode to 4 base64 characters (8 bits \u00d7 3 = 6 bits \u00d7 4 = 24 bits).\nWhen the input is not an even multiple of 3 bytes in length, [canonical](https://datatracker.ietf.org/doc/html/rfc4648#section-3.5) base64 encoders insert padding characters at the end, so that the output length is always a multiple of 4:\n```\nuse base64::{engine::general_purpose::STANDARD, Engine as _};\nassert_eq!(STANDARD.encode(b\"\"),  \"\");\nassert_eq!(STANDARD.encode(b\"f\"),  \"Zg==\");\nassert_eq!(STANDARD.encode(b\"fo\"), \"Zm8=\");\nassert_eq!(STANDARD.encode(b\"foo\"), \"Zm9v\");\n```\n\nCanonical encoding ensures that base64 encodings will be exactly the same, byte-for-byte, regardless of input length. But the `=` padding characters aren\u2019t necessary for decoding, and they may be omitted by using a [`NO_PAD`](https://docs.rs/base64/latest/base64/engine/general_purpose/constant.NO_PAD.html \"constant base64::engine::general_purpose::NO_PAD\") configuration:\n```\nuse base64::{engine::general_purpose::STANDARD_NO_PAD, Engine as _};\nassert_eq!(STANDARD_NO_PAD.encode(b\"\"),  \"\");\nassert_eq!(STANDARD_NO_PAD.encode(b\"f\"),  \"Zg\");\nassert_eq!(STANDARD_NO_PAD.encode(b\"fo\"), \"Zm8\");\nassert_eq!(STANDARD_NO_PAD.encode(b\"foo\"), \"Zm9v\");\n```\n\nThe pre-configured `NO_PAD` engines will reject inputs containing padding `=` characters. To encode without padding and still accept padding while decoding, create an [engine](https://docs.rs/base64/latest/base64/engine/general_purpose/struct.GeneralPurpose.html \"struct base64::engine::general_purpose::GeneralPurpose\") with that [padding mode](https://docs.rs/base64/latest/base64/engine/enum.DecodePaddingMode.html \"enum base64::engine::DecodePaddingMode\").\n```\nassert_eq!(STANDARD_NO_PAD.decode(b\"Zm8=\"), Err(base64::DecodeError::InvalidPadding));\n```\n\n#### [\u00a7](https://docs.rs/base64/latest/base64/#further-customization)Further customization\nDecoding and encoding behavior can be customized by creating an [engine](https://docs.rs/base64/latest/base64/engine/general_purpose/struct.GeneralPurpose.html \"struct base64::engine::general_purpose::GeneralPurpose\") with an [alphabet](https://docs.rs/base64/latest/base64/alphabet/struct.Alphabet.html \"struct base64::alphabet::Alphabet\") and [padding configuration](https://docs.rs/base64/latest/base64/engine/general_purpose/struct.GeneralPurposeConfig.html \"struct base64::engine::general_purpose::GeneralPurposeConfig\"):\n```\nuse base64::{engine, alphabet, Engine as _};\n// bizarro-world base64: +/ as the first symbols instead of the last\nlet alphabet =\n  alphabet::Alphabet::new(\"+/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\")\n  .unwrap();\n// a very weird config that encodes with padding but requires no padding when decoding...?\nlet crazy_config = engine::GeneralPurposeConfig::new()\n  .with_decode_allow_trailing_bits(true)\n  .with_encode_padding(true)\n  .with_decode_padding_mode(engine::DecodePaddingMode::RequireNone);\nlet crazy_engine = engine::GeneralPurpose::new(&alphabet, crazy_config);\nlet encoded = crazy_engine.encode(b\"abc 123\");\n\n```\n\n### [\u00a7](https://docs.rs/base64/latest/base64/#memory-allocation)Memory allocation\nThe [decode](https://docs.rs/base64/latest/base64/engine/trait.Engine.html#method.decode \"method base64::engine::Engine::decode\") and [encode](https://docs.rs/base64/latest/base64/engine/trait.Engine.html#method.encode \"method base64::engine::Engine::encode\") engine methods allocate memory for their results \u2013 `decode` returns a `Vec<u8>` and `encode` returns a `String`. To instead decode or encode into a buffer that you allocated, use one of the alternative methods:\n##### [\u00a7](https://docs.rs/base64/latest/base64/#decoding)Decoding\nMethod| Output| Allocates memory  \n---|---|---  \n[`Engine::decode`](https://docs.rs/base64/latest/base64/engine/trait.Engine.html#method.decode \"method base64::engine::Engine::decode\")| returns a new `Vec<u8>`| always  \n[`Engine::decode_vec`](https://docs.rs/base64/latest/base64/engine/trait.Engine.html#method.decode_vec \"method base64::engine::Engine::decode_vec\")| appends to provided `Vec<u8>`| if `Vec` lacks capacity  \n[`Engine::decode_slice`](https://docs.rs/base64/latest/base64/engine/trait.Engine.html#method.decode_slice \"method base64::engine::Engine::decode_slice\")| writes to provided `&[u8]`| never  \n##### [\u00a7](https://docs.rs/base64/latest/base64/#encoding)Encoding\nMethod| Output| Allocates memory  \n---|---|---  \n[`Engine::encode`](https://docs.rs/base64/latest/base64/engine/trait.Engine.html#method.encode \"method base64::engine::Engine::encode\")| returns a new `String`| always  \n[`Engine::encode_string`](https://docs.rs/base64/latest/base64/engine/trait.Engine.html#method.encode_string \"method base64::engine::Engine::encode_string\")| appends to provided `String`| if `String` lacks capacity  \n[`Engine::encode_slice`](https://docs.rs/base64/latest/base64/engine/trait.Engine.html#method.encode_slice \"method base64::engine::Engine::encode_slice\")| writes to provided `&[u8]`| never  \n### [\u00a7](https://docs.rs/base64/latest/base64/#input-and-output)Input and output\nThe `base64` crate can [decode](https://docs.rs/base64/latest/base64/engine/trait.Engine.html#method.decode \"method base64::engine::Engine::decode\") and [encode](https://docs.rs/base64/latest/base64/engine/trait.Engine.html#method.encode \"method base64::engine::Engine::encode\") values in memory, or [`DecoderReader`](https://docs.rs/base64/latest/base64/read/struct.DecoderReader.html \"struct base64::read::DecoderReader\") and [`EncoderWriter`](https://docs.rs/base64/latest/base64/write/struct.EncoderWriter.html \"struct base64::write::EncoderWriter\") provide streaming decoding and encoding for any [readable](https://doc.rust-lang.org/nightly/std/io/trait.Read.html \"trait std::io::Read\") or [writable](https://doc.rust-lang.org/nightly/std/io/trait.Write.html \"trait std::io::Write\") byte stream.\n##### [\u00a7](https://docs.rs/base64/latest/base64/#decoding-1)Decoding\n```\nuse base64::{engine::general_purpose::STANDARD, read::DecoderReader};\nlet mut input = io::stdin();\nlet mut decoder = DecoderReader::new(&mut input, &STANDARD);\nio::copy(&mut decoder, &mut io::stdout())?;\n```\n\n##### [\u00a7](https://docs.rs/base64/latest/base64/#encoding-1)Encoding\n```\nuse base64::{engine::general_purpose::STANDARD, write::EncoderWriter};\nlet mut output = io::stdout();\nlet mut encoder = EncoderWriter::new(&mut output, &STANDARD);\nio::copy(&mut io::stdin(), &mut encoder)?;\n```\n\n##### [\u00a7](https://docs.rs/base64/latest/base64/#display)Display\nIf you only need a base64 representation for implementing the [`Display`](https://doc.rust-lang.org/nightly/core/fmt/trait.Display.html \"trait core::fmt::Display\") trait, use [`Base64Display`](https://docs.rs/base64/latest/base64/display/struct.Base64Display.html \"struct base64::display::Base64Display\"):\n```\nuse base64::{display::Base64Display, engine::general_purpose::STANDARD};\nlet value = Base64Display::new(b\"\\0\\x01\\x02\\x03\", &STANDARD);\nassert_eq!(\"base64: AAECAw==\", format!(\"base64: {}\", value));\n```\n\n## [\u00a7](https://docs.rs/base64/latest/base64/#panics)Panics\nIf length calculations result in overflowing `usize`, a panic will result.\n## Re-exports[\u00a7](https://docs.rs/base64/latest/base64/#reexports)\n\n`pub use engine::Engine[](https://docs.rs/base64/latest/base64/engine/trait.Engine.html \"trait base64::engine::Engine\");`\n\n## Modules[\u00a7](https://docs.rs/base64/latest/base64/#modules)\n\n[alphabet](https://docs.rs/base64/latest/base64/alphabet/index.html \"mod base64::alphabet\")\n    Provides [Alphabet](https://docs.rs/base64/latest/base64/alphabet/struct.Alphabet.html \"struct base64::alphabet::Alphabet\") and constants for alphabets commonly used in the wild.\n\n[display](https://docs.rs/base64/latest/base64/display/index.html \"mod base64::display\")\n    Enables base64\u2019d output anywhere you might use a `Display` implementation, like a format string.\n\n[engine](https://docs.rs/base64/latest/base64/engine/index.html \"mod base64::engine\")\n    Provides the [Engine](https://docs.rs/base64/latest/base64/engine/trait.Engine.html \"trait base64::engine::Engine\") abstraction and out of the box implementations.\n\n[prelude](https://docs.rs/base64/latest/base64/prelude/index.html \"mod base64::prelude\")\n    Preconfigured engines for common use cases.\n\n[read](https://docs.rs/base64/latest/base64/read/index.html \"mod base64::read\")\n    Implementations of `io::Read` to transparently decode base64.\n\n[write](https://docs.rs/base64/latest/base64/write/index.html \"mod base64::write\")\n    Implementations of `io::Write` to transparently handle base64.\n## Enums[\u00a7](https://docs.rs/base64/latest/base64/#enums)\n\n[DecodeError](https://docs.rs/base64/latest/base64/enum.DecodeError.html \"enum base64::DecodeError\")\n    Errors that can occur while decoding.\n\n[DecodeSliceError](https://docs.rs/base64/latest/base64/enum.DecodeSliceError.html \"enum base64::DecodeSliceError\")\n    Errors that can occur while decoding into a slice.\n\n[EncodeSliceError](https://docs.rs/base64/latest/base64/enum.EncodeSliceError.html \"enum base64::EncodeSliceError\")\n    Errors that can occur while encoding into a slice.\n## Functions[\u00a7](https://docs.rs/base64/latest/base64/#functions)\n\n[decode](https://docs.rs/base64/latest/base64/fn.decode.html \"fn base64::decode\")Deprecated\n    Decode base64 using the [`STANDARD` engine](https://docs.rs/base64/latest/base64/engine/general_purpose/constant.STANDARD.html \"constant base64::engine::general_purpose::STANDARD\").\n\n[decode_engine](https://docs.rs/base64/latest/base64/fn.decode_engine.html \"fn base64::decode_engine\")Deprecated\n    Decode from string reference as octets using the specified [Engine](https://docs.rs/base64/latest/base64/engine/trait.Engine.html \"trait base64::engine::Engine\").\n\n[decode_engine_slice](https://docs.rs/base64/latest/base64/fn.decode_engine_slice.html \"fn base64::decode_engine_slice\")Deprecated\n    Decode the input into the provided output slice.\n\n[decode_engine_vec](https://docs.rs/base64/latest/base64/fn.decode_engine_vec.html \"fn base64::decode_engine_vec\")Deprecated\n    Decode from string reference as octets.\n\n[decoded_len_estimate](https://docs.rs/base64/latest/base64/fn.decoded_len_estimate.html \"fn base64::decoded_len_estimate\")\n    Returns a conservative estimate of the decoded size of `encoded_len` base64 symbols (rounded up to the next group of 3 decoded bytes).\n\n[encode](https://docs.rs/base64/latest/base64/fn.encode.html \"fn base64::encode\")Deprecated\n    Encode arbitrary octets as base64 using the [`STANDARD` engine](https://docs.rs/base64/latest/base64/engine/general_purpose/constant.STANDARD.html \"constant base64::engine::general_purpose::STANDARD\").\n\n[encode_engine](https://docs.rs/base64/latest/base64/fn.encode_engine.html \"fn base64::encode_engine\")Deprecated\n    Encode arbitrary octets as base64 using the provided `Engine` into a new `String`.\n\n[encode_engine_slice](https://docs.rs/base64/latest/base64/fn.encode_engine_slice.html \"fn base64::encode_engine_slice\")Deprecated\n    Encode arbitrary octets as base64 into a supplied slice.\n\n[encode_engine_string](https://docs.rs/base64/latest/base64/fn.encode_engine_string.html \"fn base64::encode_engine_string\")Deprecated\n    Encode arbitrary octets as base64 into a supplied `String`.\n\n[encoded_len](https://docs.rs/base64/latest/base64/fn.encoded_len.html \"fn base64::encoded_len\")\n    Calculate the base64 encoded length for a given input length, optionally including any appropriate padding bytes.\n",
        "markdown_with_citations": "[](https://docs.rs/base64/latest/base64/all.html \"show sidebar\")\n# Crate base64Copy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nCorrect, fast, and configurable base64\u27e84\u27e9 decoding and encoding. Base64 transports binary data efficiently in contexts where only plain text is allowed.\n## \u00a7\u27e85\u27e9Usage\nUse an `Engine`\u27e86\u27e9 to decode or encode base64, configured with the base64 alphabet and padding behavior best suited to your application.\n### \u00a7\u27e87\u27e9Engine setup\nThere is more than one way to encode a stream of bytes as \u201cbase64\u201d. Different applications use different encoding alphabets\u27e88\u27e9 and padding behaviors\u27e89\u27e9.\n#### \u00a7\u27e810\u27e9Encoding alphabet\nAlmost all base64 alphabets\u27e88\u27e9 use `A-Z`, `a-z`, and `0-9`, which gives nearly 64 characters (26 + 26 + 10 = 62), but they differ in their choice of their final 2.\nMost applications use the standard\u27e811\u27e9 alphabet specified in RFC 4648\u27e812\u27e9. If that\u2019s all you need, you can get started quickly by using the pre-configured `STANDARD`\u27e813\u27e9 engine, which is also available in the `prelude`\u27e814\u27e9 module as shown here, if you prefer a minimal `use` footprint.\n```\nuse base64::prelude::*;\nassert_eq!(BASE64_STANDARD.decode(b\"+uwgVQA=\")?, b\"\\xFA\\xEC\\x20\\x55\\0\");\nassert_eq!(BASE64_STANDARD.encode(b\"\\xFF\\xEC\\x20\\x55\\0\"), \"/+wgVQA=\");\n```\n\nOther common alphabets are available in the `alphabet`\u27e815\u27e9 module.\n##### \u00a7\u27e816\u27e9URL-safe alphabet\nThe standard alphabet uses `+` and `/` as its two non-alphanumeric tokens, which cannot be safely used in URL\u2019s without encoding them as `%2B` and `%2F`.\nTo avoid that, some applications use a \u201cURL-safe\u201d alphabet\u27e817\u27e9, which uses `-` and `_` instead. To use that alternative alphabet, use the `URL_SAFE`\u27e818\u27e9 engine. This example doesn\u2019t use `prelude`\u27e814\u27e9 to show what a more explicit `use` would look like.\n```\nuse base64::{engine::general_purpose::URL_SAFE, Engine as _};\nassert_eq!(URL_SAFE.decode(b\"-uwgVQA=\")?, b\"\\xFA\\xEC\\x20\\x55\\0\");\nassert_eq!(URL_SAFE.encode(b\"\\xFF\\xEC\\x20\\x55\\0\"), \"_-wgVQA=\");\n```\n\n#### \u00a7\u27e819\u27e9Padding characters\nEach base64 character represents 6 bits (2\u2076 = 64) of the original binary data, and every 3 bytes of input binary data will encode to 4 base64 characters (8 bits \u00d7 3 = 6 bits \u00d7 4 = 24 bits).\nWhen the input is not an even multiple of 3 bytes in length, canonical\u27e820\u27e9 base64 encoders insert padding characters at the end, so that the output length is always a multiple of 4:\n```\nuse base64::{engine::general_purpose::STANDARD, Engine as _};\nassert_eq!(STANDARD.encode(b\"\"),  \"\");\nassert_eq!(STANDARD.encode(b\"f\"),  \"Zg==\");\nassert_eq!(STANDARD.encode(b\"fo\"), \"Zm8=\");\nassert_eq!(STANDARD.encode(b\"foo\"), \"Zm9v\");\n```\n\nCanonical encoding ensures that base64 encodings will be exactly the same, byte-for-byte, regardless of input length. But the `=` padding characters aren\u2019t necessary for decoding, and they may be omitted by using a `NO_PAD`\u27e821\u27e9 configuration:\n```\nuse base64::{engine::general_purpose::STANDARD_NO_PAD, Engine as _};\nassert_eq!(STANDARD_NO_PAD.encode(b\"\"),  \"\");\nassert_eq!(STANDARD_NO_PAD.encode(b\"f\"),  \"Zg\");\nassert_eq!(STANDARD_NO_PAD.encode(b\"fo\"), \"Zm8\");\nassert_eq!(STANDARD_NO_PAD.encode(b\"foo\"), \"Zm9v\");\n```\n\nThe pre-configured `NO_PAD` engines will reject inputs containing padding `=` characters. To encode without padding and still accept padding while decoding, create an engine\u27e822\u27e9 with that padding mode\u27e823\u27e9.\n```\nassert_eq!(STANDARD_NO_PAD.decode(b\"Zm8=\"), Err(base64::DecodeError::InvalidPadding));\n```\n\n#### \u00a7\u27e824\u27e9Further customization\nDecoding and encoding behavior can be customized by creating an engine\u27e822\u27e9 with an alphabet\u27e88\u27e9 and padding configuration\u27e89\u27e9:\n```\nuse base64::{engine, alphabet, Engine as _};\n// bizarro-world base64: +/ as the first symbols instead of the last\nlet alphabet =\n  alphabet::Alphabet::new(\"+/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\")\n  .unwrap();\n// a very weird config that encodes with padding but requires no padding when decoding...?\nlet crazy_config = engine::GeneralPurposeConfig::new()\n  .with_decode_allow_trailing_bits(true)\n  .with_encode_padding(true)\n  .with_decode_padding_mode(engine::DecodePaddingMode::RequireNone);\nlet crazy_engine = engine::GeneralPurpose::new(&alphabet, crazy_config);\nlet encoded = crazy_engine.encode(b\"abc 123\");\n\n```\n\n### \u00a7\u27e825\u27e9Memory allocation\nThe decode\u27e826\u27e9 and encode\u27e827\u27e9 engine methods allocate memory for their results \u2013 `decode` returns a `Vec<u8>` and `encode` returns a `String`. To instead decode or encode into a buffer that you allocated, use one of the alternative methods:\n##### \u00a7\u27e828\u27e9Decoding\nMethod| Output| Allocates memory  \n---|---|---  \n`Engine::decode`\u27e826\u27e9| returns a new `Vec<u8>`| always  \n`Engine::decode_vec`\u27e829\u27e9| appends to provided `Vec<u8>`| if `Vec` lacks capacity  \n`Engine::decode_slice`\u27e830\u27e9| writes to provided `&[u8]`| never  \n##### \u00a7\u27e831\u27e9Encoding\nMethod| Output| Allocates memory  \n---|---|---  \n`Engine::encode`\u27e827\u27e9| returns a new `String`| always  \n`Engine::encode_string`\u27e832\u27e9| appends to provided `String`| if `String` lacks capacity  \n`Engine::encode_slice`\u27e833\u27e9| writes to provided `&[u8]`| never  \n### \u00a7\u27e834\u27e9Input and output\nThe `base64` crate can decode\u27e826\u27e9 and encode\u27e827\u27e9 values in memory, or `DecoderReader`\u27e835\u27e9 and `EncoderWriter`\u27e836\u27e9 provide streaming decoding and encoding for any readable\u27e837\u27e9 or writable\u27e838\u27e9 byte stream.\n##### \u00a7\u27e839\u27e9Decoding\n```\nuse base64::{engine::general_purpose::STANDARD, read::DecoderReader};\nlet mut input = io::stdin();\nlet mut decoder = DecoderReader::new(&mut input, &STANDARD);\nio::copy(&mut decoder, &mut io::stdout())?;\n```\n\n##### \u00a7\u27e840\u27e9Encoding\n```\nuse base64::{engine::general_purpose::STANDARD, write::EncoderWriter};\nlet mut output = io::stdout();\nlet mut encoder = EncoderWriter::new(&mut output, &STANDARD);\nio::copy(&mut io::stdin(), &mut encoder)?;\n```\n\n##### \u00a7\u27e841\u27e9Display\nIf you only need a base64 representation for implementing the `Display`\u27e842\u27e9 trait, use `Base64Display`\u27e843\u27e9:\n```\nuse base64::{display::Base64Display, engine::general_purpose::STANDARD};\nlet value = Base64Display::new(b\"\\0\\x01\\x02\\x03\", &STANDARD);\nassert_eq!(\"base64: AAECAw==\", format!(\"base64: {}\", value));\n```\n\n## \u00a7\u27e844\u27e9Panics\nIf length calculations result in overflowing `usize`, a panic will result.\n## Re-exports\u00a7\u27e845\u27e9\n\n`pub use engine::Engine[](https://docs.rs/base64/latest/base64/engine/trait.Engine.html \"trait base64::engine::Engine\");`\n\n## Modules\u00a7\u27e846\u27e9\n\nalphabet\u27e815\u27e9\n    Provides Alphabet\u27e88\u27e9 and constants for alphabets commonly used in the wild.\n\ndisplay\u27e847\u27e9\n    Enables base64\u2019d output anywhere you might use a `Display` implementation, like a format string.\n\nengine\u27e848\u27e9\n    Provides the Engine\u27e86\u27e9 abstraction and out of the box implementations.\n\nprelude\u27e814\u27e9\n    Preconfigured engines for common use cases.\n\nread\u27e849\u27e9\n    Implementations of `io::Read` to transparently decode base64.\n\nwrite\u27e850\u27e9\n    Implementations of `io::Write` to transparently handle base64.\n## Enums\u00a7\u27e851\u27e9\n\nDecodeError\u27e852\u27e9\n    Errors that can occur while decoding.\n\nDecodeSliceError\u27e853\u27e9\n    Errors that can occur while decoding into a slice.\n\nEncodeSliceError\u27e854\u27e9\n    Errors that can occur while encoding into a slice.\n## Functions\u00a7\u27e855\u27e9\n\ndecode\u27e856\u27e9Deprecated\n    Decode base64 using the `STANDARD` engine\u27e813\u27e9.\n\ndecode_engine\u27e857\u27e9Deprecated\n    Decode from string reference as octets using the specified Engine\u27e86\u27e9.\n\ndecode_engine_slice\u27e858\u27e9Deprecated\n    Decode the input into the provided output slice.\n\ndecode_engine_vec\u27e859\u27e9Deprecated\n    Decode from string reference as octets.\n\ndecoded_len_estimate\u27e860\u27e9\n    Returns a conservative estimate of the decoded size of `encoded_len` base64 symbols (rounded up to the next group of 3 decoded bytes).\n\nencode\u27e861\u27e9Deprecated\n    Encode arbitrary octets as base64 using the `STANDARD` engine\u27e813\u27e9.\n\nencode_engine\u27e862\u27e9Deprecated\n    Encode arbitrary octets as base64 using the provided `Engine` into a new `String`.\n\nencode_engine_slice\u27e863\u27e9Deprecated\n    Encode arbitrary octets as base64 into a supplied slice.\n\nencode_engine_string\u27e864\u27e9Deprecated\n    Encode arbitrary octets as base64 into a supplied `String`.\n\nencoded_len\u27e865\u27e9\n    Calculate the base64 encoded length for a given input length, optionally including any appropriate padding bytes.\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/base64/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/base64/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/base64/latest/src/base64/lib.rs.html#1-277: Source\n\u27e84\u27e9 https://developer.mozilla.org/en-US/docs/Glossary/Base64: base64\n\u27e85\u27e9 https://docs.rs/base64/latest/base64/#usage: \u00a7\n\u27e86\u27e9 https://docs.rs/base64/latest/base64/engine/trait.Engine.html: trait base64::engine::Engine - `Engine`\n\u27e87\u27e9 https://docs.rs/base64/latest/base64/#engine-setup: \u00a7\n\u27e88\u27e9 https://docs.rs/base64/latest/base64/alphabet/struct.Alphabet.html: struct base64::alphabet::Alphabet - alphabets\n\u27e89\u27e9 https://docs.rs/base64/latest/base64/engine/general_purpose/struct.GeneralPurposeConfig.html: struct base64::engine::general_purpose::GeneralPurposeConfig - padding behaviors\n\u27e810\u27e9 https://docs.rs/base64/latest/base64/#encoding-alphabet: \u00a7\n\u27e811\u27e9 https://docs.rs/base64/latest/base64/alphabet/constant.STANDARD.html: constant base64::alphabet::STANDARD - standard\n\u27e812\u27e9 https://datatracker.ietf.org/doc/html/rfc4648#section-4: RFC 4648\n\u27e813\u27e9 https://docs.rs/base64/latest/base64/engine/general_purpose/constant.STANDARD.html: constant base64::engine::general_purpose::STANDARD - `STANDARD`\n\u27e814\u27e9 https://docs.rs/base64/latest/base64/prelude/index.html: mod base64::prelude - `prelude`\n\u27e815\u27e9 https://docs.rs/base64/latest/base64/alphabet/index.html: mod base64::alphabet - `alphabet`\n\u27e816\u27e9 https://docs.rs/base64/latest/base64/#url-safe-alphabet: \u00a7\n\u27e817\u27e9 https://docs.rs/base64/latest/base64/alphabet/constant.URL_SAFE.html: constant base64::alphabet::URL_SAFE - \u201cURL-safe\u201d alphabet\n\u27e818\u27e9 https://docs.rs/base64/latest/base64/engine/general_purpose/constant.URL_SAFE.html: constant base64::engine::general_purpose::URL_SAFE - `URL_SAFE`\n\u27e819\u27e9 https://docs.rs/base64/latest/base64/#padding-characters: \u00a7\n\u27e820\u27e9 https://datatracker.ietf.org/doc/html/rfc4648#section-3.5: canonical\n\u27e821\u27e9 https://docs.rs/base64/latest/base64/engine/general_purpose/constant.NO_PAD.html: constant base64::engine::general_purpose::NO_PAD - `NO_PAD`\n\u27e822\u27e9 https://docs.rs/base64/latest/base64/engine/general_purpose/struct.GeneralPurpose.html: struct base64::engine::general_purpose::GeneralPurpose - engine\n\u27e823\u27e9 https://docs.rs/base64/latest/base64/engine/enum.DecodePaddingMode.html: enum base64::engine::DecodePaddingMode - padding mode\n\u27e824\u27e9 https://docs.rs/base64/latest/base64/#further-customization: \u00a7\n\u27e825\u27e9 https://docs.rs/base64/latest/base64/#memory-allocation: \u00a7\n\u27e826\u27e9 https://docs.rs/base64/latest/base64/engine/trait.Engine.html#method.decode: method base64::engine::Engine::decode - decode\n\u27e827\u27e9 https://docs.rs/base64/latest/base64/engine/trait.Engine.html#method.encode: method base64::engine::Engine::encode - encode\n\u27e828\u27e9 https://docs.rs/base64/latest/base64/#decoding: \u00a7\n\u27e829\u27e9 https://docs.rs/base64/latest/base64/engine/trait.Engine.html#method.decode_vec: method base64::engine::Engine::decode_vec - `Engine::decode_vec`\n\u27e830\u27e9 https://docs.rs/base64/latest/base64/engine/trait.Engine.html#method.decode_slice: method base64::engine::Engine::decode_slice - `Engine::decode_slice`\n\u27e831\u27e9 https://docs.rs/base64/latest/base64/#encoding: \u00a7\n\u27e832\u27e9 https://docs.rs/base64/latest/base64/engine/trait.Engine.html#method.encode_string: method base64::engine::Engine::encode_string - `Engine::encode_string`\n\u27e833\u27e9 https://docs.rs/base64/latest/base64/engine/trait.Engine.html#method.encode_slice: method base64::engine::Engine::encode_slice - `Engine::encode_slice`\n\u27e834\u27e9 https://docs.rs/base64/latest/base64/#input-and-output: \u00a7\n\u27e835\u27e9 https://docs.rs/base64/latest/base64/read/struct.DecoderReader.html: struct base64::read::DecoderReader - `DecoderReader`\n\u27e836\u27e9 https://docs.rs/base64/latest/base64/write/struct.EncoderWriter.html: struct base64::write::EncoderWriter - `EncoderWriter`\n\u27e837\u27e9 https://doc.rust-lang.org/nightly/std/io/trait.Read.html: trait std::io::Read - readable\n\u27e838\u27e9 https://doc.rust-lang.org/nightly/std/io/trait.Write.html: trait std::io::Write - writable\n\u27e839\u27e9 https://docs.rs/base64/latest/base64/#decoding-1: \u00a7\n\u27e840\u27e9 https://docs.rs/base64/latest/base64/#encoding-1: \u00a7\n\u27e841\u27e9 https://docs.rs/base64/latest/base64/#display: \u00a7\n\u27e842\u27e9 https://doc.rust-lang.org/nightly/core/fmt/trait.Display.html: trait core::fmt::Display - `Display`\n\u27e843\u27e9 https://docs.rs/base64/latest/base64/display/struct.Base64Display.html: struct base64::display::Base64Display - `Base64Display`\n\u27e844\u27e9 https://docs.rs/base64/latest/base64/#panics: \u00a7\n\u27e845\u27e9 https://docs.rs/base64/latest/base64/#reexports: \u00a7\n\u27e846\u27e9 https://docs.rs/base64/latest/base64/#modules: \u00a7\n\u27e847\u27e9 https://docs.rs/base64/latest/base64/display/index.html: mod base64::display - display\n\u27e848\u27e9 https://docs.rs/base64/latest/base64/engine/index.html: mod base64::engine - engine\n\u27e849\u27e9 https://docs.rs/base64/latest/base64/read/index.html: mod base64::read - read\n\u27e850\u27e9 https://docs.rs/base64/latest/base64/write/index.html: mod base64::write - write\n\u27e851\u27e9 https://docs.rs/base64/latest/base64/#enums: \u00a7\n\u27e852\u27e9 https://docs.rs/base64/latest/base64/enum.DecodeError.html: enum base64::DecodeError - DecodeError\n\u27e853\u27e9 https://docs.rs/base64/latest/base64/enum.DecodeSliceError.html: enum base64::DecodeSliceError - DecodeSliceError\n\u27e854\u27e9 https://docs.rs/base64/latest/base64/enum.EncodeSliceError.html: enum base64::EncodeSliceError - EncodeSliceError\n\u27e855\u27e9 https://docs.rs/base64/latest/base64/#functions: \u00a7\n\u27e856\u27e9 https://docs.rs/base64/latest/base64/fn.decode.html: fn base64::decode - decode\n\u27e857\u27e9 https://docs.rs/base64/latest/base64/fn.decode_engine.html: fn base64::decode_engine - decode_engine\n\u27e858\u27e9 https://docs.rs/base64/latest/base64/fn.decode_engine_slice.html: fn base64::decode_engine_slice - decode_engine_slice\n\u27e859\u27e9 https://docs.rs/base64/latest/base64/fn.decode_engine_vec.html: fn base64::decode_engine_vec - decode_engine_vec\n\u27e860\u27e9 https://docs.rs/base64/latest/base64/fn.decoded_len_estimate.html: fn base64::decoded_len_estimate - decoded_len_estimate\n\u27e861\u27e9 https://docs.rs/base64/latest/base64/fn.encode.html: fn base64::encode - encode\n\u27e862\u27e9 https://docs.rs/base64/latest/base64/fn.encode_engine.html: fn base64::encode_engine - encode_engine\n\u27e863\u27e9 https://docs.rs/base64/latest/base64/fn.encode_engine_slice.html: fn base64::encode_engine_slice - encode_engine_slice\n\u27e864\u27e9 https://docs.rs/base64/latest/base64/fn.encode_engine_string.html: fn base64::encode_engine_string - encode_engine_string\n\u27e865\u27e9 https://docs.rs/base64/latest/base64/fn.encoded_len.html: fn base64::encoded_len - encoded_len\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `base64` crate provides fast, configurable encoding and decoding of binary data to and from Base64, supporting various alphabets (e.g., standard, URL-safe) and padding behaviors. It offers memory-efficient methods for in-place operations, streaming capabilities via `DecoderReader` and `EncoderWriter`, and customization options through the `Engine` abstraction. Preconfigured engines and utilities like `Base64Display` simplify common use cases.",
    "feature_summary": null,
    "use_case": "Serialization",
    "score": 8.0,
    "factual_counterfactual": "### Pair 1: Encoding and Decoding with Standard Alphabet  \n\u2705 Factual: The `base64` crate provides a pre-configured `STANDARD` engine that uses the standard Base64 alphabet (`A-Z`, `a-z`, `0-9`, `+`, `/`) and padding characters (`=`) as specified by RFC 4648.  \n\u274c Counterfactual: The `base64` crate only supports the `STANDARD` alphabet for encoding and decoding and does not provide configurations for other alphabets like URL-safe Base64.  \n\n---\n\n### Pair 2: Memory Allocation During Encoding  \n\u2705 Factual: The `Engine::encode_slice` method in the `base64` crate allows encoding directly into a pre-allocated buffer without additional memory allocation.  \n\u274c Counterfactual: The `Engine::encode_slice` method always allocates a new `String` for the encoded output, regardless of whether a buffer is provided.  \n\n---\n\n### Pair 3: Handling Padding Characters  \n\u2705 Factual: The `base64` crate supports configurations to omit padding characters (`=`) during encoding using the `NO_PAD` engine, but such configurations will reject inputs containing padding during decoding.  \n\u274c Counterfactual: The `base64` crate automatically removes padding characters during decoding, regardless of the engine configuration, and accepts padded inputs without error.",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}