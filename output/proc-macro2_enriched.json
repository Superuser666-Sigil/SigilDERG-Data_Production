{
    "name": "proc-macro2",
    "version": "1.0.95",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/proc-macro2/latest/proc_macro2/all.html \"show sidebar\")\n# Crate proc_macro2Copy item path\n[Settings](https://docs.rs/proc-macro2/latest/settings.html)\n[Help](https://docs.rs/proc-macro2/latest/help.html)\nSummary[Source](https://docs.rs/proc-macro2/latest/src/proc_macro2/lib.rs.html#1-1351)\nExpand description\n[![github](https://img.shields.io/badge/github-8da0cb?style=for-the-badge&labelColor=555555&logo=github)](https://github.com/dtolnay/proc-macro2) [![crates-io](https://img.shields.io/badge/crates.io-fc8d62?style=for-the-badge&labelColor=555555&logo=rust)](https://crates.io/crates/proc-macro2) [![docs-rs](https://img.shields.io/badge/docs.rs-66c2a5?style=for-the-badge&labelColor=555555&logo=docs.rs)](https://docs.rs/proc-macro2/latest/proc_macro2/index.html \"mod proc_macro2\")\nA wrapper around the procedural macro API of the compiler\u2019s [`proc_macro`](https://doc.rust-lang.org/proc_macro/index.html \"mod proc_macro\") crate. This library serves two purposes:\n  * **Bring proc-macro-like functionality to other contexts like build.rs and main.rs.** Types from `proc_macro` are entirely specific to procedural macros and cannot ever exist in code outside of a procedural macro. Meanwhile `proc_macro2` types may exist anywhere including non-macro code. By developing foundational libraries like [syn](https://github.com/dtolnay/syn) and [quote](https://github.com/dtolnay/quote) against `proc_macro2` rather than `proc_macro`, the procedural macro ecosystem becomes easily applicable to many other use cases and we avoid reimplementing non-macro equivalents of those libraries.\n  * **Make procedural macros unit testable.** As a consequence of being specific to procedural macros, nothing that uses `proc_macro` can be executed from a unit test. In order for helper libraries or components of a macro to be testable in isolation, they must be implemented using `proc_macro2`.\n\n\n## [\u00a7](https://docs.rs/proc-macro2/latest/proc_macro2/#usage)Usage\nThe skeleton of a typical procedural macro typically looks like this:\n```\nextern crate proc_macro;\n#[proc_macro_derive(MyDerive)]\npub fn my_derive(input: proc_macro::TokenStream) -> proc_macro::TokenStream {\n  let input = proc_macro2::TokenStream::from(input);\n  let output: proc_macro2::TokenStream = {\n    /* transform input */\n  };\n  proc_macro::TokenStream::from(output)\n}\n```\n\nIf parsing with [Syn](https://github.com/dtolnay/syn), you\u2019ll use [`parse_macro_input!`](https://docs.rs/syn/2.0/syn/macro.parse_macro_input.html) instead to propagate parse errors correctly back to the compiler when parsing fails.\n## [\u00a7](https://docs.rs/proc-macro2/latest/proc_macro2/#unstable-features)Unstable features\nThe default feature set of proc-macro2 tracks the most recent stable compiler API. Functionality in `proc_macro` that is not yet stable is not exposed by proc-macro2 by default.\nTo opt into the additional APIs available in the most recent nightly compiler, the `procmacro2_semver_exempt` config flag must be passed to rustc. We will polyfill those nightly-only APIs back to Rust 1.56.0. As these are unstable APIs that track the nightly compiler, minor versions of proc-macro2 may make breaking changes to them at any time.\n```\nRUSTFLAGS='--cfg procmacro2_semver_exempt' cargo build\n```\n\nNote that this must not only be done for your crate, but for any crate that depends on your crate. This infectious nature is intentional, as it serves as a reminder that you are outside of the normal semver guarantees.\nSemver exempt methods are marked as such in the proc-macro2 documentation.\n## [\u00a7](https://docs.rs/proc-macro2/latest/proc_macro2/#thread-safety)Thread-Safety\nMost types in this crate are `!Sync` because the underlying compiler types make use of thread-local memory, meaning they cannot be accessed from a different thread.\n## Modules[\u00a7](https://docs.rs/proc-macro2/latest/proc_macro2/#modules)\n\n[extra](https://docs.rs/proc-macro2/latest/proc_macro2/extra/index.html \"mod proc_macro2::extra\")\n    Items which do not have a correspondence to any API in the proc_macro crate, but are necessary to include in proc-macro2.\n\n[token_stream](https://docs.rs/proc-macro2/latest/proc_macro2/token_stream/index.html \"mod proc_macro2::token_stream\")\n    Public implementation details for the `TokenStream` type, such as iterators.\n## Structs[\u00a7](https://docs.rs/proc-macro2/latest/proc_macro2/#structs)\n\n[Group](https://docs.rs/proc-macro2/latest/proc_macro2/struct.Group.html \"struct proc_macro2::Group\")\n    A delimited token stream.\n\n[Ident](https://docs.rs/proc-macro2/latest/proc_macro2/struct.Ident.html \"struct proc_macro2::Ident\")\n    A word of Rust code, which may be a keyword or legal variable name.\n\n[LexError](https://docs.rs/proc-macro2/latest/proc_macro2/struct.LexError.html \"struct proc_macro2::LexError\")\n    Error returned from `TokenStream::from_str`.\n\n[LineColumn](https://docs.rs/proc-macro2/latest/proc_macro2/struct.LineColumn.html \"struct proc_macro2::LineColumn\")`span-locations`\n    A line-column pair representing the start or end of a `Span`.\n\n[Literal](https://docs.rs/proc-macro2/latest/proc_macro2/struct.Literal.html \"struct proc_macro2::Literal\")\n    A literal string (`\"hello\"`), byte string (`b\"hello\"`), character (`'a'`), byte character (`b'a'`), an integer or floating point number with or without a suffix (`1`, `1u8`, `2.3`, `2.3f32`).\n\n[Punct](https://docs.rs/proc-macro2/latest/proc_macro2/struct.Punct.html \"struct proc_macro2::Punct\")\n    A `Punct` is a single punctuation character like `+`, `-` or `#`.\n\n[Span](https://docs.rs/proc-macro2/latest/proc_macro2/struct.Span.html \"struct proc_macro2::Span\")\n    A region of source code, along with macro expansion information.\n\n[TokenStream](https://docs.rs/proc-macro2/latest/proc_macro2/struct.TokenStream.html \"struct proc_macro2::TokenStream\")\n    An abstract stream of tokens, or more concretely a sequence of token trees.\n## Enums[\u00a7](https://docs.rs/proc-macro2/latest/proc_macro2/#enums)\n\n[Delimiter](https://docs.rs/proc-macro2/latest/proc_macro2/enum.Delimiter.html \"enum proc_macro2::Delimiter\")\n    Describes how a sequence of token trees is delimited.\n\n[Spacing](https://docs.rs/proc-macro2/latest/proc_macro2/enum.Spacing.html \"enum proc_macro2::Spacing\")\n    Whether a `Punct` is followed immediately by another `Punct` or followed by another token or whitespace.\n\n[TokenTree](https://docs.rs/proc-macro2/latest/proc_macro2/enum.TokenTree.html \"enum proc_macro2::TokenTree\")\n    A single token or a delimited sequence of token trees (e.g. `[1, (), ..]`).\n",
        "markdown_with_citations": "[](https://docs.rs/proc-macro2/latest/proc_macro2/all.html \"show sidebar\")\n# Crate proc_macro2Copy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\n![github\u27e84\u27e9](https://github.com/dtolnay/proc-macro2) ![crates-io\u27e85\u27e9](https://crates.io/crates/proc-macro2) ![docs-rs\u27e86\u27e9](https://docs.rs/proc-macro2/latest/proc_macro2/index.html \"mod proc_macro2\")\nA wrapper around the procedural macro API of the compiler\u2019s `proc_macro`\u27e87\u27e9 crate. This library serves two purposes:\n  * **Bring proc-macro-like functionality to other contexts like build.rs and main.rs.** Types from `proc_macro` are entirely specific to procedural macros and cannot ever exist in code outside of a procedural macro. Meanwhile `proc_macro2` types may exist anywhere including non-macro code. By developing foundational libraries like syn\u27e88\u27e9 and quote\u27e89\u27e9 against `proc_macro2` rather than `proc_macro`, the procedural macro ecosystem becomes easily applicable to many other use cases and we avoid reimplementing non-macro equivalents of those libraries.\n  * **Make procedural macros unit testable.** As a consequence of being specific to procedural macros, nothing that uses `proc_macro` can be executed from a unit test. In order for helper libraries or components of a macro to be testable in isolation, they must be implemented using `proc_macro2`.\n\n\n## \u00a7\u27e810\u27e9Usage\nThe skeleton of a typical procedural macro typically looks like this:\n```\nextern crate proc_macro;\n#[proc_macro_derive(MyDerive)]\npub fn my_derive(input: proc_macro::TokenStream) -> proc_macro::TokenStream {\n  let input = proc_macro2::TokenStream::from(input);\n  let output: proc_macro2::TokenStream = {\n    /* transform input */\n  };\n  proc_macro::TokenStream::from(output)\n}\n```\n\nIf parsing with Syn\u27e88\u27e9, you\u2019ll use `parse_macro_input!`\u27e811\u27e9 instead to propagate parse errors correctly back to the compiler when parsing fails.\n## \u00a7\u27e812\u27e9Unstable features\nThe default feature set of proc-macro2 tracks the most recent stable compiler API. Functionality in `proc_macro` that is not yet stable is not exposed by proc-macro2 by default.\nTo opt into the additional APIs available in the most recent nightly compiler, the `procmacro2_semver_exempt` config flag must be passed to rustc. We will polyfill those nightly-only APIs back to Rust 1.56.0. As these are unstable APIs that track the nightly compiler, minor versions of proc-macro2 may make breaking changes to them at any time.\n```\nRUSTFLAGS='--cfg procmacro2_semver_exempt' cargo build\n```\n\nNote that this must not only be done for your crate, but for any crate that depends on your crate. This infectious nature is intentional, as it serves as a reminder that you are outside of the normal semver guarantees.\nSemver exempt methods are marked as such in the proc-macro2 documentation.\n## \u00a7\u27e813\u27e9Thread-Safety\nMost types in this crate are `!Sync` because the underlying compiler types make use of thread-local memory, meaning they cannot be accessed from a different thread.\n## Modules\u00a7\u27e814\u27e9\n\nextra\u27e815\u27e9\n    Items which do not have a correspondence to any API in the proc_macro crate, but are necessary to include in proc-macro2.\n\ntoken_stream\u27e816\u27e9\n    Public implementation details for the `TokenStream` type, such as iterators.\n## Structs\u00a7\u27e817\u27e9\n\nGroup\u27e818\u27e9\n    A delimited token stream.\n\nIdent\u27e819\u27e9\n    A word of Rust code, which may be a keyword or legal variable name.\n\nLexError\u27e820\u27e9\n    Error returned from `TokenStream::from_str`.\n\nLineColumn\u27e821\u27e9`span-locations`\n    A line-column pair representing the start or end of a `Span`.\n\nLiteral\u27e822\u27e9\n    A literal string (`\"hello\"`), byte string (`b\"hello\"`), character (`'a'`), byte character (`b'a'`), an integer or floating point number with or without a suffix (`1`, `1u8`, `2.3`, `2.3f32`).\n\nPunct\u27e823\u27e9\n    A `Punct` is a single punctuation character like `+`, `-` or `#`.\n\nSpan\u27e824\u27e9\n    A region of source code, along with macro expansion information.\n\nTokenStream\u27e825\u27e9\n    An abstract stream of tokens, or more concretely a sequence of token trees.\n## Enums\u00a7\u27e826\u27e9\n\nDelimiter\u27e827\u27e9\n    Describes how a sequence of token trees is delimited.\n\nSpacing\u27e828\u27e9\n    Whether a `Punct` is followed immediately by another `Punct` or followed by another token or whitespace.\n\nTokenTree\u27e829\u27e9\n    A single token or a delimited sequence of token trees (e.g. `[1, (), ..]`).\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/proc-macro2/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/proc-macro2/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/proc-macro2/latest/src/proc_macro2/lib.rs.html#1-1351: Source\n\u27e84\u27e9 https://img.shields.io/badge/github-8da0cb?style=for-the-badge&labelColor=555555&logo=github: ![github\n\u27e85\u27e9 https://img.shields.io/badge/crates.io-fc8d62?style=for-the-badge&labelColor=555555&logo=rust: ![crates-io\n\u27e86\u27e9 https://img.shields.io/badge/docs.rs-66c2a5?style=for-the-badge&labelColor=555555&logo=docs.rs: ![docs-rs\n\u27e87\u27e9 https://doc.rust-lang.org/proc_macro/index.html: mod proc_macro - `proc_macro`\n\u27e88\u27e9 https://github.com/dtolnay/syn: syn\n\u27e89\u27e9 https://github.com/dtolnay/quote: quote\n\u27e810\u27e9 https://docs.rs/proc-macro2/latest/proc_macro2/#usage: \u00a7\n\u27e811\u27e9 https://docs.rs/syn/2.0/syn/macro.parse_macro_input.html: `parse_macro_input!`\n\u27e812\u27e9 https://docs.rs/proc-macro2/latest/proc_macro2/#unstable-features: \u00a7\n\u27e813\u27e9 https://docs.rs/proc-macro2/latest/proc_macro2/#thread-safety: \u00a7\n\u27e814\u27e9 https://docs.rs/proc-macro2/latest/proc_macro2/#modules: \u00a7\n\u27e815\u27e9 https://docs.rs/proc-macro2/latest/proc_macro2/extra/index.html: mod proc_macro2::extra - extra\n\u27e816\u27e9 https://docs.rs/proc-macro2/latest/proc_macro2/token_stream/index.html: mod proc_macro2::token_stream - token_stream\n\u27e817\u27e9 https://docs.rs/proc-macro2/latest/proc_macro2/#structs: \u00a7\n\u27e818\u27e9 https://docs.rs/proc-macro2/latest/proc_macro2/struct.Group.html: struct proc_macro2::Group - Group\n\u27e819\u27e9 https://docs.rs/proc-macro2/latest/proc_macro2/struct.Ident.html: struct proc_macro2::Ident - Ident\n\u27e820\u27e9 https://docs.rs/proc-macro2/latest/proc_macro2/struct.LexError.html: struct proc_macro2::LexError - LexError\n\u27e821\u27e9 https://docs.rs/proc-macro2/latest/proc_macro2/struct.LineColumn.html: struct proc_macro2::LineColumn - LineColumn\n\u27e822\u27e9 https://docs.rs/proc-macro2/latest/proc_macro2/struct.Literal.html: struct proc_macro2::Literal - Literal\n\u27e823\u27e9 https://docs.rs/proc-macro2/latest/proc_macro2/struct.Punct.html: struct proc_macro2::Punct - Punct\n\u27e824\u27e9 https://docs.rs/proc-macro2/latest/proc_macro2/struct.Span.html: struct proc_macro2::Span - Span\n\u27e825\u27e9 https://docs.rs/proc-macro2/latest/proc_macro2/struct.TokenStream.html: struct proc_macro2::TokenStream - TokenStream\n\u27e826\u27e9 https://docs.rs/proc-macro2/latest/proc_macro2/#enums: \u00a7\n\u27e827\u27e9 https://docs.rs/proc-macro2/latest/proc_macro2/enum.Delimiter.html: enum proc_macro2::Delimiter - Delimiter\n\u27e828\u27e9 https://docs.rs/proc-macro2/latest/proc_macro2/enum.Spacing.html: enum proc_macro2::Spacing - Spacing\n\u27e829\u27e9 https://docs.rs/proc-macro2/latest/proc_macro2/enum.TokenTree.html: enum proc_macro2::TokenTree - TokenTree\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `proc-macro2` crate provides a wrapper around Rust's `proc_macro` API, enabling procedural macro-like functionality in non-macro contexts (e.g., `build.rs` or `main.rs`) and making procedural macros unit-testable. It offers types like `TokenStream`, `Span`, and `Ident` that can be used outside of procedural macros, supports stable and nightly compiler APIs, and includes utilities for token manipulation. Additionally, it integrates well with libraries like `syn` and `quote` for macro development.",
    "feature_summary": null,
    "use_case": "DevTools",
    "score": 9.5,
    "factual_counterfactual": "### Pair 1: Procedural Macro Contexts  \n\u2705 **Factual:** The `proc-macro2` crate allows procedural macro-like functionality to be used in contexts outside of procedural macros, such as `build.rs` or `main.rs`, by providing types that are not restricted to the procedural macro environment.  \n\u274c **Counterfactual:** The `proc-macro2` crate is limited to procedural macros and cannot be used in non-macro contexts like `build.rs` or `main.rs`.  \n\n---\n\n### Pair 2: Unit Testing Support  \n\u2705 **Factual:** The `proc-macro2` crate enables unit testing of procedural macros by providing types that can be executed outside of the procedural macro environment, which is not possible with the native `proc_macro` crate.  \n\u274c **Counterfactual:** The `proc-macro2` crate does not support unit testing of procedural macros and requires the use of the native `proc_macro` crate for testing.  \n\n---\n\n### Pair 3: Thread Safety  \n\u2705 **Factual:** Most types in the `proc-macro2` crate are `!Sync` because they rely on thread-local memory from the underlying compiler types, which prevents them from being accessed across threads.  \n\u274c **Counterfactual:** All types in the `proc-macro2` crate are `Sync`, allowing them to be safely shared across threads without restrictions.",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}