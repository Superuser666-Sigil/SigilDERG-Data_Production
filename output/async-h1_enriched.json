{
    "name": "async-h1",
    "version": "2.3.4",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/async-h1/latest/async_h1/all.html \"show sidebar\")\n# Crate async_h1Copy item path\n[Settings](https://docs.rs/async-h1/latest/settings.html)\n[Help](https://docs.rs/async-h1/latest/help.html)\nSummary[Source](https://docs.rs/async-h1/latest/src/async_h1/lib.rs.html#1-137)\nExpand description\nStreaming async HTTP 1.1 parser.\nAt its core HTTP is a stateful RPC protocol, where a client and server communicate with one another by encoding and decoding messages between them.\n  * `client` encodes HTTP requests, and decodes HTTP responses.\n  * `server` decodes HTTP requests, and encodes HTTP responses.\n\n\nA client always starts the HTTP connection. The lifetime of an HTTP connection looks like this:\n```\n1. encode      2. decode\n    \\      /\n    -> request ->\n client        server\n    <- response <-\n    /      \\\n4. decode      3. encode\n```\n\nSee also [`async-tls`](https://docs.rs/async-tls), [`async-std`](https://docs.rs/async-std).\n## [\u00a7](https://docs.rs/async-h1/latest/async_h1/#example)Example\n**HTTP client**\n```\nuse async_std::net::TcpStream;\nuse http_types::{Method, Request, Url};\n#[async_std::main]\nasync fn main() -> http_types::Result<()> {\n  let stream = TcpStream::connect(\"127.0.0.1:8080\").await?;\n  let peer_addr = stream.peer_addr()?;\n  println!(\"connecting to {}\", peer_addr);\n  let url = Url::parse(&format!(\"http://{}/foo\", peer_addr))?;\n  let req = Request::new(Method::Get, url);\n  let res = async_h1::connect(stream.clone(), req).await?;\n  println!(\"{:?}\", res);\n  Ok(())\n}\n```\n\n**HTTP Server**\n```\nuse async_std::net::{TcpStream, TcpListener};\nuse async_std::prelude::*;\nuse async_std::task;\nuse http_types::{Response, StatusCode};\n#[async_std::main]\nasync fn main() -> http_types::Result<()> {\n  // Open up a TCP connection and create a URL.\n  let listener = TcpListener::bind((\"127.0.0.1\", 8080)).await?;\n  let addr = format!(\"http://{}\", listener.local_addr()?);\n  println!(\"listening on {}\", addr);\n  // For each incoming TCP connection, spawn a task and call `accept`.\n  let mut incoming = listener.incoming();\n  while let Some(stream) = incoming.next().await {\n    let stream = stream?;\n    task::spawn(async {\n      if let Err(err) = accept(stream).await {\n        eprintln!(\"{}\", err);\n      }\n    });\n  }\n  Ok(())\n}\n// Take a TCP stream, and convert it into sequential HTTP request / response pairs.\nasync fn accept(stream: TcpStream) -> http_types::Result<()> {\n  println!(\"starting new connection from {}\", stream.peer_addr()?);\n  async_h1::accept(stream.clone(), |_req| async move {\n    let mut res = Response::new(StatusCode::Ok);\n    res.insert_header(\"Content-Type\", \"text/plain\");\n    res.set_body(\"Hello\");\n    Ok(res)\n  })\n  .await?;\n  Ok(())\n}\n```\n\n## Re-exports[\u00a7](https://docs.rs/async-h1/latest/async_h1/#reexports)\n\n`pub use client::connect[](https://docs.rs/async-h1/latest/async_h1/client/fn.connect.html \"fn async_h1::client::connect\");`\n\n\n`pub use server::accept[](https://docs.rs/async-h1/latest/async_h1/server/fn.accept.html \"fn async_h1::server::accept\");`\n\n\n`pub use server::accept_with_opts[](https://docs.rs/async-h1/latest/async_h1/server/fn.accept_with_opts.html \"fn async_h1::server::accept_with_opts\");`\n\n\n`pub use server::ServerOptions[](https://docs.rs/async-h1/latest/async_h1/server/struct.ServerOptions.html \"struct async_h1::server::ServerOptions\");`\n\n## Modules[\u00a7](https://docs.rs/async-h1/latest/async_h1/#modules)\n\n[client](https://docs.rs/async-h1/latest/async_h1/client/index.html \"mod async_h1::client\")\n    Process HTTP connections on the client.\n\n[server](https://docs.rs/async-h1/latest/async_h1/server/index.html \"mod async_h1::server\")\n    Process HTTP connections on the server.\n## Macros[\u00a7](https://docs.rs/async-h1/latest/async_h1/#macros)\n\n[read_to_end](https://docs.rs/async-h1/latest/async_h1/macro.read_to_end.html \"macro async_h1::read_to_end\")\n    like ready! but early-returns the Poll<Result> early in all situations other than Ready(Ok(0))\n",
        "markdown_with_citations": "[](https://docs.rs/async-h1/latest/async_h1/all.html \"show sidebar\")\n# Crate async_h1Copy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nStreaming async HTTP 1.1 parser.\nAt its core HTTP is a stateful RPC protocol, where a client and server communicate with one another by encoding and decoding messages between them.\n  * `client` encodes HTTP requests, and decodes HTTP responses.\n  * `server` decodes HTTP requests, and encodes HTTP responses.\n\n\nA client always starts the HTTP connection. The lifetime of an HTTP connection looks like this:\n```\n1. encode      2. decode\n    \\      /\n    -> request ->\n client        server\n    <- response <-\n    /      \\\n4. decode      3. encode\n```\n\nSee also `async-tls`\u27e84\u27e9, `async-std`\u27e85\u27e9.\n## \u00a7\u27e86\u27e9Example\n**HTTP client**\n```\nuse async_std::net::TcpStream;\nuse http_types::{Method, Request, Url};\n#[async_std::main]\nasync fn main() -> http_types::Result<()> {\n  let stream = TcpStream::connect(\"127.0.0.1:8080\").await?;\n  let peer_addr = stream.peer_addr()?;\n  println!(\"connecting to {}\", peer_addr);\n  let url = Url::parse(&format!(\"http://{}/foo\", peer_addr))?;\n  let req = Request::new(Method::Get, url);\n  let res = async_h1::connect(stream.clone(), req).await?;\n  println!(\"{:?}\", res);\n  Ok(())\n}\n```\n\n**HTTP Server**\n```\nuse async_std::net::{TcpStream, TcpListener};\nuse async_std::prelude::*;\nuse async_std::task;\nuse http_types::{Response, StatusCode};\n#[async_std::main]\nasync fn main() -> http_types::Result<()> {\n  // Open up a TCP connection and create a URL.\n  let listener = TcpListener::bind((\"127.0.0.1\", 8080)).await?;\n  let addr = format!(\"http://{}\", listener.local_addr()?);\n  println!(\"listening on {}\", addr);\n  // For each incoming TCP connection, spawn a task and call `accept`.\n  let mut incoming = listener.incoming();\n  while let Some(stream) = incoming.next().await {\n    let stream = stream?;\n    task::spawn(async {\n      if let Err(err) = accept(stream).await {\n        eprintln!(\"{}\", err);\n      }\n    });\n  }\n  Ok(())\n}\n// Take a TCP stream, and convert it into sequential HTTP request / response pairs.\nasync fn accept(stream: TcpStream) -> http_types::Result<()> {\n  println!(\"starting new connection from {}\", stream.peer_addr()?);\n  async_h1::accept(stream.clone(), |_req| async move {\n    let mut res = Response::new(StatusCode::Ok);\n    res.insert_header(\"Content-Type\", \"text/plain\");\n    res.set_body(\"Hello\");\n    Ok(res)\n  })\n  .await?;\n  Ok(())\n}\n```\n\n## Re-exports\u00a7\u27e87\u27e9\n\n`pub use client::connect[](https://docs.rs/async-h1/latest/async_h1/client/fn.connect.html \"fn async_h1::client::connect\");`\n\n\n`pub use server::accept[](https://docs.rs/async-h1/latest/async_h1/server/fn.accept.html \"fn async_h1::server::accept\");`\n\n\n`pub use server::accept_with_opts[](https://docs.rs/async-h1/latest/async_h1/server/fn.accept_with_opts.html \"fn async_h1::server::accept_with_opts\");`\n\n\n`pub use server::ServerOptions[](https://docs.rs/async-h1/latest/async_h1/server/struct.ServerOptions.html \"struct async_h1::server::ServerOptions\");`\n\n## Modules\u00a7\u27e88\u27e9\n\nclient\u27e89\u27e9\n    Process HTTP connections on the client.\n\nserver\u27e810\u27e9\n    Process HTTP connections on the server.\n## Macros\u00a7\u27e811\u27e9\n\nread_to_end\u27e812\u27e9\n    like ready! but early-returns the Poll<Result> early in all situations other than Ready(Ok(0))\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/async-h1/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/async-h1/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/async-h1/latest/src/async_h1/lib.rs.html#1-137: Source\n\u27e84\u27e9 https://docs.rs/async-tls: `async-tls`\n\u27e85\u27e9 https://docs.rs/async-std: `async-std`\n\u27e86\u27e9 https://docs.rs/async-h1/latest/async_h1/#example: \u00a7\n\u27e87\u27e9 https://docs.rs/async-h1/latest/async_h1/#reexports: \u00a7\n\u27e88\u27e9 https://docs.rs/async-h1/latest/async_h1/#modules: \u00a7\n\u27e89\u27e9 https://docs.rs/async-h1/latest/async_h1/client/index.html: mod async_h1::client - client\n\u27e810\u27e9 https://docs.rs/async-h1/latest/async_h1/server/index.html: mod async_h1::server - server\n\u27e811\u27e9 https://docs.rs/async-h1/latest/async_h1/#macros: \u00a7\n\u27e812\u27e9 https://docs.rs/async-h1/latest/async_h1/macro.read_to_end.html: macro async_h1::read_to_end - read_to_end\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `async-h1` crate is a streaming asynchronous HTTP/1.1 parser designed for both client and server-side communication. It provides utilities to encode and decode HTTP requests and responses, enabling seamless handling of HTTP connections. Key features include `connect` for client-side requests, `accept` for server-side handling, and support for custom server options, all built on `async-std` for async I/O.",
    "feature_summary": null,
    "use_case": "Web Framework",
    "score": 4.0,
    "factual_counterfactual": "### Pair 1: HTTP Protocol Support  \n\u2705 Factual: The `async-h1` crate provides a streaming asynchronous HTTP/1.1 parser, allowing both client-side and server-side HTTP communication.  \n\u274c Counterfactual: The `async-h1` crate supports HTTP/2 and HTTP/3 protocols in addition to HTTP/1.1.  \n\n---\n\n### Pair 2: Integration with Async Ecosystem  \n\u2705 Factual: The `async-h1` crate is designed to work seamlessly with the `async-std` runtime and can integrate with `async-tls` for secure connections.  \n\u274c Counterfactual: The `async-h1` crate is incompatible with the `async-std` runtime and requires a custom runtime for operation.  \n\n---\n\n### Pair 3: Server Options and Customization  \n\u2705 Factual: The `async-h1` crate provides the `ServerOptions` struct, enabling customization of server behavior during HTTP request handling.  \n\u274c Counterfactual: The `async-h1` crate does not support any customization for server behavior and only provides a fixed configuration for HTTP request handling.",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}