{
    "name": "futures",
    "version": "0.3.31",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/futures/latest/futures/all.html \"show sidebar\")\n# Crate futuresCopy item path\n[Settings](https://docs.rs/futures/latest/settings.html)\n[Help](https://docs.rs/futures/latest/help.html)\nSummary[Source](https://docs.rs/futures/latest/src/futures/lib.rs.html#1-254)\nExpand description\nAbstractions for asynchronous programming.\nThis crate provides a number of core abstractions for writing asynchronous code:\n  * [Futures](https://docs.rs/futures/latest/futures/future/index.html \"mod futures::future\") are single eventual values produced by asynchronous computations. Some programming languages (e.g. JavaScript) call this concept \u201cpromise\u201d.\n  * [Streams](https://docs.rs/futures/latest/futures/stream/index.html \"mod futures::stream\") represent a series of values produced asynchronously.\n  * [Sinks](https://docs.rs/futures/latest/futures/sink/index.html \"mod futures::sink\") provide support for asynchronous writing of data.\n  * [Executors](https://docs.rs/futures/latest/futures/executor/index.html \"mod futures::executor\") are responsible for running asynchronous tasks.\n\n\nThe crate also contains abstractions for [asynchronous I/O](https://docs.rs/futures/latest/futures/io/index.html \"mod futures::io\") and [cross-task communication](https://docs.rs/futures/latest/futures/channel/index.html \"mod futures::channel\").\nUnderlying all of this is the _task system_ , which is a form of lightweight threading. Large asynchronous computations are built up using futures, streams and sinks, and then spawned as independent tasks that are run to completion, but _do not block_ the thread running them.\nThe following example describes how the task system context is built and used within macros and keywords such as async and await!.\n```\nfn main() {\n  let pool = ThreadPool::new().expect(\"Failed to build pool\");\n  let (tx, rx) = mpsc::unbounded::<i32>();\n  // Create a future by an async block, where async is responsible for an\n  // implementation of Future. At this point no executor has been provided\n  // to this future, so it will not be running.\n  let fut_values = async {\n    // Create another async block, again where the Future implementation\n    // is generated by async. Since this is inside of a parent async block,\n    // it will be provided with the executor of the parent block when the parent\n    // block is executed.\n    //\n    // This executor chaining is done by Future::poll whose second argument\n    // is a std::task::Context. This represents our executor, and the Future\n    // implemented by this async block can be polled using the parent async\n    // block's executor.\n    let fut_tx_result = async move {\n      (0..100).for_each(|v| {\n        tx.unbounded_send(v).expect(\"Failed to send\");\n      })\n    };\n    // Use the provided thread pool to spawn the generated future\n    // responsible for transmission\n    pool.spawn_ok(fut_tx_result);\n    let fut_values = rx\n      .map(|v| v * 2)\n      .collect();\n    // Use the executor provided to this async block to wait for the\n    // future to complete.\n    fut_values.await\n  };\n  // Actually execute the above future, which will invoke Future::poll and\n  // subsequently chain appropriate Future::poll and methods needing executors\n  // to drive all futures. Eventually fut_values will be driven to completion.\n  let values: Vec<i32> = executor::block_on(fut_values);\n  println!(\"Values={:?}\", values);\n}\n```\n\nThe majority of examples and code snippets in this crate assume that they are inside an async block as written above.\n## Re-exports[\u00a7](https://docs.rs/futures/latest/futures/#reexports)\n\n`pub use futures_core::future::Future[](https://docs.rs/futures/latest/futures/prelude/trait.Future.html \"trait futures::prelude::Future\");`\n\n\n`pub use futures_core::future::TryFuture[](https://docs.rs/futures/latest/futures/prelude/trait.TryFuture.html \"trait futures::prelude::TryFuture\");`\n\n\n`pub use futures_util::future::FutureExt[](https://docs.rs/futures/latest/futures/future/trait.FutureExt.html \"trait futures::future::FutureExt\");`\n\n\n`pub use futures_util::future::TryFutureExt[](https://docs.rs/futures/latest/futures/future/trait.TryFutureExt.html \"trait futures::future::TryFutureExt\");`\n\n\n`pub use futures_core::stream::Stream[](https://docs.rs/futures/latest/futures/prelude/trait.Stream.html \"trait futures::prelude::Stream\");`\n\n\n`pub use futures_core::stream::TryStream[](https://docs.rs/futures/latest/futures/prelude/trait.TryStream.html \"trait futures::prelude::TryStream\");`\n\n\n`pub use futures_util::stream::StreamExt[](https://docs.rs/futures/latest/futures/stream/trait.StreamExt.html \"trait futures::stream::StreamExt\");`\n\n\n`pub use futures_util::stream::TryStreamExt[](https://docs.rs/futures/latest/futures/stream/trait.TryStreamExt.html \"trait futures::stream::TryStreamExt\");`\n\n\n`pub use futures_sink::Sink[](https://docs.rs/futures/latest/futures/prelude/trait.Sink.html \"trait futures::prelude::Sink\");`\n\n\n`pub use futures_util::sink::SinkExt[](https://docs.rs/futures/latest/futures/sink/trait.SinkExt.html \"trait futures::sink::SinkExt\");`\n\n\n`pub use futures_io::AsyncBufRead[](https://docs.rs/futures/latest/futures/prelude/trait.AsyncBufRead.html \"trait futures::prelude::AsyncBufRead\");`\n\n\n`pub use futures_io::AsyncRead[](https://docs.rs/futures/latest/futures/prelude/trait.AsyncRead.html \"trait futures::prelude::AsyncRead\");`\n\n\n`pub use futures_io::AsyncSeek[](https://docs.rs/futures/latest/futures/prelude/trait.AsyncSeek.html \"trait futures::prelude::AsyncSeek\");`\n\n\n`pub use futures_io::AsyncWrite[](https://docs.rs/futures/latest/futures/prelude/trait.AsyncWrite.html \"trait futures::prelude::AsyncWrite\");`\n\n\n`pub use futures_util::AsyncBufReadExt[](https://docs.rs/futures/latest/futures/io/trait.AsyncBufReadExt.html \"trait futures::io::AsyncBufReadExt\");`\n\n\n`pub use futures_util::AsyncReadExt[](https://docs.rs/futures/latest/futures/io/trait.AsyncReadExt.html \"trait futures::io::AsyncReadExt\");`\n\n\n`pub use futures_util::AsyncSeekExt[](https://docs.rs/futures/latest/futures/io/trait.AsyncSeekExt.html \"trait futures::io::AsyncSeekExt\");`\n\n\n`pub use futures_util::AsyncWriteExt[](https://docs.rs/futures/latest/futures/io/trait.AsyncWriteExt.html \"trait futures::io::AsyncWriteExt\");`\n\n## Modules[\u00a7](https://docs.rs/futures/latest/futures/#modules)\n\n[channel](https://docs.rs/futures/latest/futures/channel/index.html \"mod futures::channel\")\n    Asynchronous channels.\n\n[compat](https://docs.rs/futures/latest/futures/compat/index.html \"mod futures::compat\")`compat`\n    Interop between `futures` 0.1 and 0.3.\n\n[executor](https://docs.rs/futures/latest/futures/executor/index.html \"mod futures::executor\")`executor`\n    Built-in executors and related tools.\n\n[future](https://docs.rs/futures/latest/futures/future/index.html \"mod futures::future\")\n    Asynchronous values.\n\n[io](https://docs.rs/futures/latest/futures/io/index.html \"mod futures::io\")\n    Asynchronous I/O.\n\n[lock](https://docs.rs/futures/latest/futures/lock/index.html \"mod futures::lock\")\n    Futures-powered synchronization primitives.\n\n[never](https://docs.rs/futures/latest/futures/never/index.html \"mod futures::never\")\n    This module contains the `Never` type.\n\n[prelude](https://docs.rs/futures/latest/futures/prelude/index.html \"mod futures::prelude\")\n    A \u201cprelude\u201d for crates using the `futures` crate.\n\n[sink](https://docs.rs/futures/latest/futures/sink/index.html \"mod futures::sink\")\n    Asynchronous sinks.\n\n[stream](https://docs.rs/futures/latest/futures/stream/index.html \"mod futures::stream\")\n    Asynchronous streams.\n\n[task](https://docs.rs/futures/latest/futures/task/index.html \"mod futures::task\")\n    Tools for working with tasks.\n## Macros[\u00a7](https://docs.rs/futures/latest/futures/#macros)\n\n[join](https://docs.rs/futures/latest/futures/macro.join.html \"macro futures::join\")\n    Polls multiple futures simultaneously, returning a tuple of all results once complete.\n\n[pending](https://docs.rs/futures/latest/futures/macro.pending.html \"macro futures::pending\")\n    A macro which yields to the event loop once.\n\n[pin_mut](https://docs.rs/futures/latest/futures/macro.pin_mut.html \"macro futures::pin_mut\")\n    Pins a value on the stack.\n\n[poll](https://docs.rs/futures/latest/futures/macro.poll.html \"macro futures::poll\")\n    A macro which returns the result of polling a future once within the current `async` context.\n\n[ready](https://docs.rs/futures/latest/futures/macro.ready.html \"macro futures::ready\")\n    Extracts the successful type of a `Poll<T>`.\n\n[select](https://docs.rs/futures/latest/futures/macro.select.html \"macro futures::select\")\n    Polls multiple futures and streams simultaneously, executing the branch for the future that finishes first. If multiple futures are ready, one will be pseudo-randomly selected at runtime. Futures directly passed to `select!` must be `Unpin` and implement `FusedFuture`.\n\n[select_biased](https://docs.rs/futures/latest/futures/macro.select_biased.html \"macro futures::select_biased\")\n    Polls multiple futures and streams simultaneously, executing the branch for the future that finishes first. Unlike [`select!`](https://docs.rs/futures/latest/futures/macro.select.html), if multiple futures are ready, one will be selected in order of declaration. Futures directly passed to `select_biased!` must be `Unpin` and implement `FusedFuture`.\n\n[stream_select](https://docs.rs/futures/latest/futures/macro.stream_select.html \"macro futures::stream_select\")\n    Combines several streams, all producing the same `Item` type, into one stream. This is similar to `select_all` but does not require the streams to all be the same type. It also keeps the streams inline, and does not require `Box<dyn Stream>`s to be allocated. Streams passed to this macro must be `Unpin`.\n\n[try_join](https://docs.rs/futures/latest/futures/macro.try_join.html \"macro futures::try_join\")\n    Polls multiple futures simultaneously, resolving to a [`Result`](https://doc.rust-lang.org/nightly/core/result/enum.Result.html \"enum core::result::Result\") containing either a tuple of the successful outputs or an error.\n",
        "markdown_with_citations": "[](https://docs.rs/futures/latest/futures/all.html \"show sidebar\")\n# Crate futuresCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nAbstractions for asynchronous programming.\nThis crate provides a number of core abstractions for writing asynchronous code:\n  * Futures\u27e84\u27e9 are single eventual values produced by asynchronous computations. Some programming languages (e.g. JavaScript) call this concept \u201cpromise\u201d.\n  * Streams\u27e85\u27e9 represent a series of values produced asynchronously.\n  * Sinks\u27e86\u27e9 provide support for asynchronous writing of data.\n  * Executors\u27e87\u27e9 are responsible for running asynchronous tasks.\n\n\nThe crate also contains abstractions for asynchronous I/O\u27e88\u27e9 and cross-task communication\u27e89\u27e9.\nUnderlying all of this is the _task system_ , which is a form of lightweight threading. Large asynchronous computations are built up using futures, streams and sinks, and then spawned as independent tasks that are run to completion, but _do not block_ the thread running them.\nThe following example describes how the task system context is built and used within macros and keywords such as async and await!.\n```\nfn main() {\n  let pool = ThreadPool::new().expect(\"Failed to build pool\");\n  let (tx, rx) = mpsc::unbounded::<i32>();\n  // Create a future by an async block, where async is responsible for an\n  // implementation of Future. At this point no executor has been provided\n  // to this future, so it will not be running.\n  let fut_values = async {\n    // Create another async block, again where the Future implementation\n    // is generated by async. Since this is inside of a parent async block,\n    // it will be provided with the executor of the parent block when the parent\n    // block is executed.\n    //\n    // This executor chaining is done by Future::poll whose second argument\n    // is a std::task::Context. This represents our executor, and the Future\n    // implemented by this async block can be polled using the parent async\n    // block's executor.\n    let fut_tx_result = async move {\n      (0..100).for_each(|v| {\n        tx.unbounded_send(v).expect(\"Failed to send\");\n      })\n    };\n    // Use the provided thread pool to spawn the generated future\n    // responsible for transmission\n    pool.spawn_ok(fut_tx_result);\n    let fut_values = rx\n      .map(|v| v * 2)\n      .collect();\n    // Use the executor provided to this async block to wait for the\n    // future to complete.\n    fut_values.await\n  };\n  // Actually execute the above future, which will invoke Future::poll and\n  // subsequently chain appropriate Future::poll and methods needing executors\n  // to drive all futures. Eventually fut_values will be driven to completion.\n  let values: Vec<i32> = executor::block_on(fut_values);\n  println!(\"Values={:?}\", values);\n}\n```\n\nThe majority of examples and code snippets in this crate assume that they are inside an async block as written above.\n## Re-exports\u00a7\u27e810\u27e9\n\n`pub use futures_core::future::Future[](https://docs.rs/futures/latest/futures/prelude/trait.Future.html \"trait futures::prelude::Future\");`\n\n\n`pub use futures_core::future::TryFuture[](https://docs.rs/futures/latest/futures/prelude/trait.TryFuture.html \"trait futures::prelude::TryFuture\");`\n\n\n`pub use futures_util::future::FutureExt[](https://docs.rs/futures/latest/futures/future/trait.FutureExt.html \"trait futures::future::FutureExt\");`\n\n\n`pub use futures_util::future::TryFutureExt[](https://docs.rs/futures/latest/futures/future/trait.TryFutureExt.html \"trait futures::future::TryFutureExt\");`\n\n\n`pub use futures_core::stream::Stream[](https://docs.rs/futures/latest/futures/prelude/trait.Stream.html \"trait futures::prelude::Stream\");`\n\n\n`pub use futures_core::stream::TryStream[](https://docs.rs/futures/latest/futures/prelude/trait.TryStream.html \"trait futures::prelude::TryStream\");`\n\n\n`pub use futures_util::stream::StreamExt[](https://docs.rs/futures/latest/futures/stream/trait.StreamExt.html \"trait futures::stream::StreamExt\");`\n\n\n`pub use futures_util::stream::TryStreamExt[](https://docs.rs/futures/latest/futures/stream/trait.TryStreamExt.html \"trait futures::stream::TryStreamExt\");`\n\n\n`pub use futures_sink::Sink[](https://docs.rs/futures/latest/futures/prelude/trait.Sink.html \"trait futures::prelude::Sink\");`\n\n\n`pub use futures_util::sink::SinkExt[](https://docs.rs/futures/latest/futures/sink/trait.SinkExt.html \"trait futures::sink::SinkExt\");`\n\n\n`pub use futures_io::AsyncBufRead[](https://docs.rs/futures/latest/futures/prelude/trait.AsyncBufRead.html \"trait futures::prelude::AsyncBufRead\");`\n\n\n`pub use futures_io::AsyncRead[](https://docs.rs/futures/latest/futures/prelude/trait.AsyncRead.html \"trait futures::prelude::AsyncRead\");`\n\n\n`pub use futures_io::AsyncSeek[](https://docs.rs/futures/latest/futures/prelude/trait.AsyncSeek.html \"trait futures::prelude::AsyncSeek\");`\n\n\n`pub use futures_io::AsyncWrite[](https://docs.rs/futures/latest/futures/prelude/trait.AsyncWrite.html \"trait futures::prelude::AsyncWrite\");`\n\n\n`pub use futures_util::AsyncBufReadExt[](https://docs.rs/futures/latest/futures/io/trait.AsyncBufReadExt.html \"trait futures::io::AsyncBufReadExt\");`\n\n\n`pub use futures_util::AsyncReadExt[](https://docs.rs/futures/latest/futures/io/trait.AsyncReadExt.html \"trait futures::io::AsyncReadExt\");`\n\n\n`pub use futures_util::AsyncSeekExt[](https://docs.rs/futures/latest/futures/io/trait.AsyncSeekExt.html \"trait futures::io::AsyncSeekExt\");`\n\n\n`pub use futures_util::AsyncWriteExt[](https://docs.rs/futures/latest/futures/io/trait.AsyncWriteExt.html \"trait futures::io::AsyncWriteExt\");`\n\n## Modules\u00a7\u27e811\u27e9\n\nchannel\u27e89\u27e9\n    Asynchronous channels.\n\ncompat\u27e812\u27e9`compat`\n    Interop between `futures` 0.1 and 0.3.\n\nexecutor\u27e87\u27e9`executor`\n    Built-in executors and related tools.\n\nfuture\u27e84\u27e9\n    Asynchronous values.\n\nio\u27e88\u27e9\n    Asynchronous I/O.\n\nlock\u27e813\u27e9\n    Futures-powered synchronization primitives.\n\nnever\u27e814\u27e9\n    This module contains the `Never` type.\n\nprelude\u27e815\u27e9\n    A \u201cprelude\u201d for crates using the `futures` crate.\n\nsink\u27e86\u27e9\n    Asynchronous sinks.\n\nstream\u27e85\u27e9\n    Asynchronous streams.\n\ntask\u27e816\u27e9\n    Tools for working with tasks.\n## Macros\u00a7\u27e817\u27e9\n\njoin\u27e818\u27e9\n    Polls multiple futures simultaneously, returning a tuple of all results once complete.\n\npending\u27e819\u27e9\n    A macro which yields to the event loop once.\n\npin_mut\u27e820\u27e9\n    Pins a value on the stack.\n\npoll\u27e821\u27e9\n    A macro which returns the result of polling a future once within the current `async` context.\n\nready\u27e822\u27e9\n    Extracts the successful type of a `Poll<T>`.\n\nselect\u27e823\u27e9\n    Polls multiple futures and streams simultaneously, executing the branch for the future that finishes first. If multiple futures are ready, one will be pseudo-randomly selected at runtime. Futures directly passed to `select!` must be `Unpin` and implement `FusedFuture`.\n\nselect_biased\u27e824\u27e9\n    Polls multiple futures and streams simultaneously, executing the branch for the future that finishes first. Unlike `select!`\u27e823\u27e9, if multiple futures are ready, one will be selected in order of declaration. Futures directly passed to `select_biased!` must be `Unpin` and implement `FusedFuture`.\n\nstream_select\u27e825\u27e9\n    Combines several streams, all producing the same `Item` type, into one stream. This is similar to `select_all` but does not require the streams to all be the same type. It also keeps the streams inline, and does not require `Box<dyn Stream>`s to be allocated. Streams passed to this macro must be `Unpin`.\n\ntry_join\u27e826\u27e9\n    Polls multiple futures simultaneously, resolving to a `Result`\u27e827\u27e9 containing either a tuple of the successful outputs or an error.\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/futures/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/futures/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/futures/latest/src/futures/lib.rs.html#1-254: Source\n\u27e84\u27e9 https://docs.rs/futures/latest/futures/future/index.html: mod futures::future - Futures\n\u27e85\u27e9 https://docs.rs/futures/latest/futures/stream/index.html: mod futures::stream - Streams\n\u27e86\u27e9 https://docs.rs/futures/latest/futures/sink/index.html: mod futures::sink - Sinks\n\u27e87\u27e9 https://docs.rs/futures/latest/futures/executor/index.html: mod futures::executor - Executors\n\u27e88\u27e9 https://docs.rs/futures/latest/futures/io/index.html: mod futures::io - asynchronous I/O\n\u27e89\u27e9 https://docs.rs/futures/latest/futures/channel/index.html: mod futures::channel - cross-task communication\n\u27e810\u27e9 https://docs.rs/futures/latest/futures/#reexports: \u00a7\n\u27e811\u27e9 https://docs.rs/futures/latest/futures/#modules: \u00a7\n\u27e812\u27e9 https://docs.rs/futures/latest/futures/compat/index.html: mod futures::compat - compat\n\u27e813\u27e9 https://docs.rs/futures/latest/futures/lock/index.html: mod futures::lock - lock\n\u27e814\u27e9 https://docs.rs/futures/latest/futures/never/index.html: mod futures::never - never\n\u27e815\u27e9 https://docs.rs/futures/latest/futures/prelude/index.html: mod futures::prelude - prelude\n\u27e816\u27e9 https://docs.rs/futures/latest/futures/task/index.html: mod futures::task - task\n\u27e817\u27e9 https://docs.rs/futures/latest/futures/#macros: \u00a7\n\u27e818\u27e9 https://docs.rs/futures/latest/futures/macro.join.html: macro futures::join - join\n\u27e819\u27e9 https://docs.rs/futures/latest/futures/macro.pending.html: macro futures::pending - pending\n\u27e820\u27e9 https://docs.rs/futures/latest/futures/macro.pin_mut.html: macro futures::pin_mut - pin_mut\n\u27e821\u27e9 https://docs.rs/futures/latest/futures/macro.poll.html: macro futures::poll - poll\n\u27e822\u27e9 https://docs.rs/futures/latest/futures/macro.ready.html: macro futures::ready - ready\n\u27e823\u27e9 https://docs.rs/futures/latest/futures/macro.select.html: macro futures::select - select\n\u27e824\u27e9 https://docs.rs/futures/latest/futures/macro.select_biased.html: macro futures::select_biased - select_biased\n\u27e825\u27e9 https://docs.rs/futures/latest/futures/macro.stream_select.html: macro futures::stream_select - stream_select\n\u27e826\u27e9 https://docs.rs/futures/latest/futures/macro.try_join.html: macro futures::try_join - try_join\n\u27e827\u27e9 https://doc.rust-lang.org/nightly/core/result/enum.Result.html: enum core::result::Result - `Result`\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `futures` crate provides foundational abstractions for asynchronous programming in Rust, including `Future` for single asynchronous values, `Stream` for sequences of values, and `Sink` for asynchronous data writing. It also includes tools for asynchronous I/O, task execution, and cross-task communication, leveraging a lightweight task system to avoid thread blocking. Additional features include built-in executors, synchronization primitives, and macros like `join`, `select`, and `try_join` for managing multiple asynchronous operations.",
    "feature_summary": null,
    "use_case": "Utilities",
    "score": 9.0,
    "factual_counterfactual": "### Pair 1: Futures and Asynchronous Computations  \n\u2705 Factual: The `futures` crate provides abstractions like `Future`, which represent single eventual values produced by asynchronous computations, similar to promises in JavaScript.  \n\u274c Counterfactual: The `futures` crate only supports synchronous computations and does not provide abstractions for asynchronous programming.  \n\n---\n\n### Pair 2: Streams and Data Flow  \n\u2705 Factual: The `Stream` abstraction in the `futures` crate allows asynchronous iteration over a sequence of values, enabling efficient processing of data as it becomes available.  \n\u274c Counterfactual: The `Stream` abstraction in the `futures` crate is designed for synchronous iteration over precomputed sequences of values.  \n\n---\n\n### Pair 3: Executors and Task Management  \n\u2705 Factual: The `futures::executor` module provides built-in executors, such as `ThreadPool`, to manage and run asynchronous tasks efficiently.  \n\u274c Counterfactual: The `futures` crate does not include any executor implementations, requiring users to write their own task management systems from scratch.",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}