{
    "name": "async-channel",
    "version": "2.3.1",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/async-channel/latest/async_channel/all.html \"show sidebar\")\n# Crate async_channelCopy item path\n[Settings](https://docs.rs/async-channel/latest/settings.html)\n[Help](https://docs.rs/async-channel/latest/help.html)\nSummary[Source](https://docs.rs/async-channel/latest/src/async_channel/lib.rs.html#1-1262)\nExpand description\nAn async multi-producer multi-consumer channel, where each message can be received by only one of all existing consumers.\nThere are two kinds of channels:\n  1. [Bounded](https://docs.rs/async-channel/latest/async_channel/fn.bounded.html \"fn async_channel::bounded\") channel with limited capacity.\n  2. [Unbounded](https://docs.rs/async-channel/latest/async_channel/fn.unbounded.html \"fn async_channel::unbounded\") channel with unlimited capacity.\n\n\nA channel has the [`Sender`](https://docs.rs/async-channel/latest/async_channel/struct.Sender.html \"struct async_channel::Sender\") and [`Receiver`](https://docs.rs/async-channel/latest/async_channel/struct.Receiver.html \"struct async_channel::Receiver\") side. Both sides are cloneable and can be shared among multiple threads.\nWhen all [`Sender`](https://docs.rs/async-channel/latest/async_channel/struct.Sender.html \"struct async_channel::Sender\")s or all [`Receiver`](https://docs.rs/async-channel/latest/async_channel/struct.Receiver.html \"struct async_channel::Receiver\")s are dropped, the channel becomes closed. When a channel is closed, no more messages can be sent, but remaining messages can still be received.\nThe channel can also be closed manually by calling [`Sender::close()`](https://docs.rs/async-channel/latest/async_channel/struct.Sender.html#method.close \"method async_channel::Sender::close\") or [`Receiver::close()`](https://docs.rs/async-channel/latest/async_channel/struct.Receiver.html#method.close \"method async_channel::Receiver::close\").\n## [\u00a7](https://docs.rs/async-channel/latest/async_channel/#examples)Examples\n```\nlet (s, r) = async_channel::unbounded();\nassert_eq!(s.send(\"Hello\").await, Ok(()));\nassert_eq!(r.recv().await, Ok(\"Hello\"));\n```\n\n## Structs[\u00a7](https://docs.rs/async-channel/latest/async_channel/#structs)\n\n[Receiver](https://docs.rs/async-channel/latest/async_channel/struct.Receiver.html \"struct async_channel::Receiver\")\n    The receiving side of a channel.\n\n[Recv](https://docs.rs/async-channel/latest/async_channel/struct.Recv.html \"struct async_channel::Recv\")\n    A future returned by [`Receiver::recv()`](https://docs.rs/async-channel/latest/async_channel/struct.Receiver.html#method.recv \"method async_channel::Receiver::recv\").\n\n[RecvError](https://docs.rs/async-channel/latest/async_channel/struct.RecvError.html \"struct async_channel::RecvError\")\n    An error returned from [`Receiver::recv()`](https://docs.rs/async-channel/latest/async_channel/struct.Receiver.html#method.recv \"method async_channel::Receiver::recv\").\n\n[Send](https://docs.rs/async-channel/latest/async_channel/struct.Send.html \"struct async_channel::Send\")\n    A future returned by [`Sender::send()`](https://docs.rs/async-channel/latest/async_channel/struct.Sender.html#method.send \"method async_channel::Sender::send\").\n\n[SendError](https://docs.rs/async-channel/latest/async_channel/struct.SendError.html \"struct async_channel::SendError\")\n    An error returned from [`Sender::send()`](https://docs.rs/async-channel/latest/async_channel/struct.Sender.html#method.send \"method async_channel::Sender::send\").\n\n[Sender](https://docs.rs/async-channel/latest/async_channel/struct.Sender.html \"struct async_channel::Sender\")\n    The sending side of a channel.\n\n[WeakReceiver](https://docs.rs/async-channel/latest/async_channel/struct.WeakReceiver.html \"struct async_channel::WeakReceiver\")\n    A [`Receiver`](https://docs.rs/async-channel/latest/async_channel/struct.Receiver.html \"struct async_channel::Receiver\") that prevents the channel from not being closed.\n\n[WeakSender](https://docs.rs/async-channel/latest/async_channel/struct.WeakSender.html \"struct async_channel::WeakSender\")\n    A [`Sender`](https://docs.rs/async-channel/latest/async_channel/struct.Sender.html \"struct async_channel::Sender\") that prevents the channel from not being closed.\n## Enums[\u00a7](https://docs.rs/async-channel/latest/async_channel/#enums)\n\n[TryRecvError](https://docs.rs/async-channel/latest/async_channel/enum.TryRecvError.html \"enum async_channel::TryRecvError\")\n    An error returned from [`Receiver::try_recv()`](https://docs.rs/async-channel/latest/async_channel/struct.Receiver.html#method.try_recv \"method async_channel::Receiver::try_recv\").\n\n[TrySendError](https://docs.rs/async-channel/latest/async_channel/enum.TrySendError.html \"enum async_channel::TrySendError\")\n    An error returned from [`Sender::try_send()`](https://docs.rs/async-channel/latest/async_channel/struct.Sender.html#method.try_send \"method async_channel::Sender::try_send\").\n## Functions[\u00a7](https://docs.rs/async-channel/latest/async_channel/#functions)\n\n[bounded](https://docs.rs/async-channel/latest/async_channel/fn.bounded.html \"fn async_channel::bounded\")\n    Creates a bounded channel.\n\n[unbounded](https://docs.rs/async-channel/latest/async_channel/fn.unbounded.html \"fn async_channel::unbounded\")\n    Creates an unbounded channel.\n",
        "markdown_with_citations": "[](https://docs.rs/async-channel/latest/async_channel/all.html \"show sidebar\")\n# Crate async_channelCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nAn async multi-producer multi-consumer channel, where each message can be received by only one of all existing consumers.\nThere are two kinds of channels:\n  1. Bounded\u27e84\u27e9 channel with limited capacity.\n  2. Unbounded\u27e85\u27e9 channel with unlimited capacity.\n\n\nA channel has the `Sender`\u27e86\u27e9 and `Receiver`\u27e87\u27e9 side. Both sides are cloneable and can be shared among multiple threads.\nWhen all `Sender`\u27e86\u27e9s or all `Receiver`\u27e87\u27e9s are dropped, the channel becomes closed. When a channel is closed, no more messages can be sent, but remaining messages can still be received.\nThe channel can also be closed manually by calling `Sender::close()`\u27e88\u27e9 or `Receiver::close()`\u27e89\u27e9.\n## \u00a7\u27e810\u27e9Examples\n```\nlet (s, r) = async_channel::unbounded();\nassert_eq!(s.send(\"Hello\").await, Ok(()));\nassert_eq!(r.recv().await, Ok(\"Hello\"));\n```\n\n## Structs\u00a7\u27e811\u27e9\n\nReceiver\u27e87\u27e9\n    The receiving side of a channel.\n\nRecv\u27e812\u27e9\n    A future returned by `Receiver::recv()`\u27e813\u27e9.\n\nRecvError\u27e814\u27e9\n    An error returned from `Receiver::recv()`\u27e813\u27e9.\n\nSend\u27e815\u27e9\n    A future returned by `Sender::send()`\u27e816\u27e9.\n\nSendError\u27e817\u27e9\n    An error returned from `Sender::send()`\u27e816\u27e9.\n\nSender\u27e86\u27e9\n    The sending side of a channel.\n\nWeakReceiver\u27e818\u27e9\n    A `Receiver`\u27e87\u27e9 that prevents the channel from not being closed.\n\nWeakSender\u27e819\u27e9\n    A `Sender`\u27e86\u27e9 that prevents the channel from not being closed.\n## Enums\u00a7\u27e820\u27e9\n\nTryRecvError\u27e821\u27e9\n    An error returned from `Receiver::try_recv()`\u27e822\u27e9.\n\nTrySendError\u27e823\u27e9\n    An error returned from `Sender::try_send()`\u27e824\u27e9.\n## Functions\u00a7\u27e825\u27e9\n\nbounded\u27e84\u27e9\n    Creates a bounded channel.\n\nunbounded\u27e85\u27e9\n    Creates an unbounded channel.\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/async-channel/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/async-channel/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/async-channel/latest/src/async_channel/lib.rs.html#1-1262: Source\n\u27e84\u27e9 https://docs.rs/async-channel/latest/async_channel/fn.bounded.html: fn async_channel::bounded - Bounded\n\u27e85\u27e9 https://docs.rs/async-channel/latest/async_channel/fn.unbounded.html: fn async_channel::unbounded - Unbounded\n\u27e86\u27e9 https://docs.rs/async-channel/latest/async_channel/struct.Sender.html: struct async_channel::Sender - `Sender`\n\u27e87\u27e9 https://docs.rs/async-channel/latest/async_channel/struct.Receiver.html: struct async_channel::Receiver - `Receiver`\n\u27e88\u27e9 https://docs.rs/async-channel/latest/async_channel/struct.Sender.html#method.close: method async_channel::Sender::close - `Sender::close()`\n\u27e89\u27e9 https://docs.rs/async-channel/latest/async_channel/struct.Receiver.html#method.close: method async_channel::Receiver::close - `Receiver::close()`\n\u27e810\u27e9 https://docs.rs/async-channel/latest/async_channel/#examples: \u00a7\n\u27e811\u27e9 https://docs.rs/async-channel/latest/async_channel/#structs: \u00a7\n\u27e812\u27e9 https://docs.rs/async-channel/latest/async_channel/struct.Recv.html: struct async_channel::Recv - Recv\n\u27e813\u27e9 https://docs.rs/async-channel/latest/async_channel/struct.Receiver.html#method.recv: method async_channel::Receiver::recv - `Receiver::recv()`\n\u27e814\u27e9 https://docs.rs/async-channel/latest/async_channel/struct.RecvError.html: struct async_channel::RecvError - RecvError\n\u27e815\u27e9 https://docs.rs/async-channel/latest/async_channel/struct.Send.html: struct async_channel::Send - Send\n\u27e816\u27e9 https://docs.rs/async-channel/latest/async_channel/struct.Sender.html#method.send: method async_channel::Sender::send - `Sender::send()`\n\u27e817\u27e9 https://docs.rs/async-channel/latest/async_channel/struct.SendError.html: struct async_channel::SendError - SendError\n\u27e818\u27e9 https://docs.rs/async-channel/latest/async_channel/struct.WeakReceiver.html: struct async_channel::WeakReceiver - WeakReceiver\n\u27e819\u27e9 https://docs.rs/async-channel/latest/async_channel/struct.WeakSender.html: struct async_channel::WeakSender - WeakSender\n\u27e820\u27e9 https://docs.rs/async-channel/latest/async_channel/#enums: \u00a7\n\u27e821\u27e9 https://docs.rs/async-channel/latest/async_channel/enum.TryRecvError.html: enum async_channel::TryRecvError - TryRecvError\n\u27e822\u27e9 https://docs.rs/async-channel/latest/async_channel/struct.Receiver.html#method.try_recv: method async_channel::Receiver::try_recv - `Receiver::try_recv()`\n\u27e823\u27e9 https://docs.rs/async-channel/latest/async_channel/enum.TrySendError.html: enum async_channel::TrySendError - TrySendError\n\u27e824\u27e9 https://docs.rs/async-channel/latest/async_channel/struct.Sender.html#method.try_send: method async_channel::Sender::try_send - `Sender::try_send()`\n\u27e825\u27e9 https://docs.rs/async-channel/latest/async_channel/#functions: \u00a7\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `async-channel` crate provides asynchronous multi-producer, multi-consumer channels where each message is received by only one consumer. It supports both bounded (limited capacity) and unbounded (unlimited capacity) channels, with cloneable and thread-safe `Sender` and `Receiver` sides. Channels can be manually or automatically closed, ensuring remaining messages are still receivable after closure.",
    "feature_summary": null,
    "use_case": "Networking",
    "score": 6.0,
    "factual_counterfactual": "### Pair 1: Channel Types  \n\u2705 **Factual:** The `async-channel` crate provides two types of channels: bounded channels with a limited capacity and unbounded channels with unlimited capacity.  \n\u274c **Counterfactual:** The `async-channel` crate only supports bounded channels and does not provide an unbounded channel option.  \n\n---\n\n### Pair 2: Cloneability  \n\u2705 **Factual:** Both `Sender` and `Receiver` in `async-channel` are cloneable, allowing them to be shared across multiple threads.  \n\u274c **Counterfactual:** `Sender` and `Receiver` in `async-channel` cannot be cloned, meaning they must be used exclusively by the thread that creates them.  \n\n---\n\n### Pair 3: Closing Channels  \n\u2705 **Factual:** Channels in `async-channel` can be closed manually by calling `Sender::close()` or `Receiver::close()`, after which no new messages can be sent, but remaining messages can still be received.  \n\u274c **Counterfactual:** Once a channel in `async-channel` is closed, all remaining messages in the channel are immediately discarded and cannot be received.",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}