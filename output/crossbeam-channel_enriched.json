{
    "name": "crossbeam-channel",
    "version": "0.5.15",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/all.html \"show sidebar\")\n# Crate crossbeam_channelCopy item path\n[Settings](https://docs.rs/crossbeam-channel/latest/settings.html)\n[Help](https://docs.rs/crossbeam-channel/latest/help.html)\nSummary[Source](https://docs.rs/crossbeam-channel/latest/src/crossbeam_channel/lib.rs.html#1-378)\nExpand description\nMulti-producer multi-consumer channels for message passing.\nThis crate is an alternative to [`std::sync::mpsc`](https://doc.rust-lang.org/nightly/std/sync/mpsc/index.html \"mod std::sync::mpsc\") with more features and better performance.\n## [\u00a7](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#hello-world)Hello, world!\n```\nuse crossbeam_channel::unbounded;\n// Create a channel of unbounded capacity.\nlet (s, r) = unbounded();\n// Send a message into the channel.\ns.send(\"Hello, world!\").unwrap();\n// Receive the message from the channel.\nassert_eq!(r.recv(), Ok(\"Hello, world!\"));\n```\n\n## [\u00a7](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#channel-types)Channel types\nChannels can be created using two functions:\n  * [`bounded`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/fn.bounded.html \"fn crossbeam_channel::bounded\") creates a channel of bounded capacity, i.e. there is a limit to how many messages it can hold at a time.\n  * [`unbounded`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/fn.unbounded.html \"fn crossbeam_channel::unbounded\") creates a channel of unbounded capacity, i.e. it can hold any number of messages at a time.\n\n\nBoth functions return a [`Sender`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Sender.html \"struct crossbeam_channel::Sender\") and a [`Receiver`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Receiver.html \"struct crossbeam_channel::Receiver\"), which represent the two opposite sides of a channel.\nCreating a bounded channel:\n```\nuse crossbeam_channel::bounded;\n// Create a channel that can hold at most 5 messages at a time.\nlet (s, r) = bounded(5);\n// Can send only 5 messages without blocking.\nfor i in 0..5 {\n  s.send(i).unwrap();\n}\n// Another call to `send` would block because the channel is full.\n// s.send(5).unwrap();\n```\n\nCreating an unbounded channel:\n```\nuse crossbeam_channel::unbounded;\n// Create an unbounded channel.\nlet (s, r) = unbounded();\n// Can send any number of messages into the channel without blocking.\nfor i in 0..1000 {\n  s.send(i).unwrap();\n}\n```\n\nA special case is zero-capacity channel, which cannot hold any messages. Instead, send and receive operations must appear at the same time in order to pair up and pass the message over:\n```\nuse std::thread;\nuse crossbeam_channel::bounded;\n// Create a zero-capacity channel.\nlet (s, r) = bounded(0);\n// Sending blocks until a receive operation appears on the other side.\nthread::spawn(move || s.send(\"Hi!\").unwrap());\n// Receiving blocks until a send operation appears on the other side.\nassert_eq!(r.recv(), Ok(\"Hi!\"));\n```\n\n## [\u00a7](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#sharing-channels)Sharing channels\nSenders and receivers can be cloned and sent to other threads:\n```\nuse std::thread;\nuse crossbeam_channel::bounded;\nlet (s1, r1) = bounded(0);\nlet (s2, r2) = (s1.clone(), r1.clone());\n// Spawn a thread that receives a message and then sends one.\nthread::spawn(move || {\n  r2.recv().unwrap();\n  s2.send(2).unwrap();\n});\n// Send a message and then receive one.\ns1.send(1).unwrap();\nr1.recv().unwrap();\n```\n\nNote that cloning only creates a new handle to the same sending or receiving side. It does not create a separate stream of messages in any way:\n```\nuse crossbeam_channel::unbounded;\nlet (s1, r1) = unbounded();\nlet (s2, r2) = (s1.clone(), r1.clone());\nlet (s3, r3) = (s2.clone(), r2.clone());\ns1.send(10).unwrap();\ns2.send(20).unwrap();\ns3.send(30).unwrap();\nassert_eq!(r3.recv(), Ok(10));\nassert_eq!(r1.recv(), Ok(20));\nassert_eq!(r2.recv(), Ok(30));\n```\n\nIt\u2019s also possible to share senders and receivers by reference:\n```\nuse crossbeam_channel::bounded;\nuse crossbeam_utils::thread::scope;\nlet (s, r) = bounded(0);\nscope(|scope| {\n  // Spawn a thread that receives a message and then sends one.\n  scope.spawn(|_| {\n    r.recv().unwrap();\n    s.send(2).unwrap();\n  });\n  // Send a message and then receive one.\n  s.send(1).unwrap();\n  r.recv().unwrap();\n}).unwrap();\n```\n\n## [\u00a7](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#disconnection)Disconnection\nWhen all senders or all receivers associated with a channel get dropped, the channel becomes disconnected. No more messages can be sent, but any remaining messages can still be received. Send and receive operations on a disconnected channel never block.\n```\nuse crossbeam_channel::{unbounded, RecvError};\nlet (s, r) = unbounded();\ns.send(1).unwrap();\ns.send(2).unwrap();\ns.send(3).unwrap();\n// The only sender is dropped, disconnecting the channel.\ndrop(s);\n// The remaining messages can be received.\nassert_eq!(r.recv(), Ok(1));\nassert_eq!(r.recv(), Ok(2));\nassert_eq!(r.recv(), Ok(3));\n// There are no more messages in the channel.\nassert!(r.is_empty());\n// Note that calling `r.recv()` does not block.\n// Instead, `Err(RecvError)` is returned immediately.\nassert_eq!(r.recv(), Err(RecvError));\n```\n\n## [\u00a7](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#blocking-operations)Blocking operations\nSend and receive operations come in three flavors:\n  * Non-blocking (returns immediately with success or failure).\n  * Blocking (waits until the operation succeeds or the channel becomes disconnected).\n  * Blocking with a timeout (blocks only for a certain duration of time).\n\n\nA simple example showing the difference between non-blocking and blocking operations:\n```\nuse crossbeam_channel::{bounded, RecvError, TryRecvError};\nlet (s, r) = bounded(1);\n// Send a message into the channel.\ns.send(\"foo\").unwrap();\n// This call would block because the channel is full.\n// s.send(\"bar\").unwrap();\n// Receive the message.\nassert_eq!(r.recv(), Ok(\"foo\"));\n// This call would block because the channel is empty.\n// r.recv();\n// Try receiving a message without blocking.\nassert_eq!(r.try_recv(), Err(TryRecvError::Empty));\n// Disconnect the channel.\ndrop(s);\n// This call doesn't block because the channel is now disconnected.\nassert_eq!(r.recv(), Err(RecvError));\n```\n\n## [\u00a7](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#iteration)Iteration\nReceivers can be used as iterators. For example, method [`iter`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Receiver.html#method.iter \"method crossbeam_channel::Receiver::iter\") creates an iterator that receives messages until the channel becomes empty and disconnected. Note that iteration may block waiting for next message to arrive.\n```\nuse std::thread;\nuse crossbeam_channel::unbounded;\nlet (s, r) = unbounded();\nthread::spawn(move || {\n  s.send(1).unwrap();\n  s.send(2).unwrap();\n  s.send(3).unwrap();\n  drop(s); // Disconnect the channel.\n});\n// Collect all messages from the channel.\n// Note that the call to `collect` blocks until the sender is dropped.\nlet v: Vec<_> = r.iter().collect();\nassert_eq!(v, [1, 2, 3]);\n```\n\nA non-blocking iterator can be created using [`try_iter`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Receiver.html#method.try_iter \"method crossbeam_channel::Receiver::try_iter\"), which receives all available messages without blocking:\n```\nuse crossbeam_channel::unbounded;\nlet (s, r) = unbounded();\ns.send(1).unwrap();\ns.send(2).unwrap();\ns.send(3).unwrap();\n// No need to drop the sender.\n// Receive all messages currently in the channel.\nlet v: Vec<_> = r.try_iter().collect();\nassert_eq!(v, [1, 2, 3]);\n```\n\n## [\u00a7](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#selection)Selection\nThe [`select!`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/macro.select.html \"macro crossbeam_channel::select\") macro allows you to define a set of channel operations, wait until any one of them becomes ready, and finally execute it. If multiple operations are ready at the same time, a random one among them is selected.\nIt is also possible to define a `default` case that gets executed if none of the operations are ready, either right away or for a certain duration of time.\nAn operation is considered to be ready if it doesn\u2019t have to block. Note that it is ready even when it will simply return an error because the channel is disconnected.\nAn example of receiving a message from two channels:\n```\nuse std::thread;\nuse std::time::Duration;\nuse crossbeam_channel::{select, unbounded};\nlet (s1, r1) = unbounded();\nlet (s2, r2) = unbounded();\nthread::spawn(move || s1.send(10).unwrap());\nthread::spawn(move || s2.send(20).unwrap());\n// At most one of these two receive operations will be executed.\nselect! {\n  recv(r1) -> msg => assert_eq!(msg, Ok(10)),\n  recv(r2) -> msg => assert_eq!(msg, Ok(20)),\n  default(Duration::from_secs(1)) => println!(\"timed out\"),\n}\n```\n\nIf you need to select over a dynamically created list of channel operations, use [`Select`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Select.html \"struct crossbeam_channel::Select\") instead. The [`select!`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/macro.select.html \"macro crossbeam_channel::select\") macro is just a convenience wrapper around [`Select`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Select.html \"struct crossbeam_channel::Select\").\n## [\u00a7](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#extra-channels)Extra channels\nThree functions can create special kinds of channels, all of which return just a [`Receiver`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Receiver.html \"struct crossbeam_channel::Receiver\") handle:\n  * [`after`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/fn.after.html \"fn crossbeam_channel::after\") creates a channel that delivers a single message after a certain duration of time.\n  * [`tick`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/fn.tick.html \"fn crossbeam_channel::tick\") creates a channel that delivers messages periodically.\n  * [`never`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/fn.never.html \"fn crossbeam_channel::never\") creates a channel that never delivers messages.\n\n\nThese channels are very efficient because messages get lazily generated on receive operations.\nAn example that prints elapsed time every 50 milliseconds for the duration of 1 second:\n```\nuse std::time::{Duration, Instant};\nuse crossbeam_channel::{after, select, tick};\nlet start = Instant::now();\nlet ticker = tick(Duration::from_millis(50));\nlet timeout = after(Duration::from_secs(1));\nloop {\n  select! {\n    recv(ticker) -> _ => println!(\"elapsed: {:?}\", start.elapsed()),\n    recv(timeout) -> _ => break,\n  }\n}\n```\n\n## Macros[\u00a7](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#macros)\n\n[select](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/macro.select.html \"macro crossbeam_channel::select\")\n    Selects from a set of channel operations.\n\n[select_biased](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/macro.select_biased.html \"macro crossbeam_channel::select_biased\")\n    Selects from a set of channel operations.\n## Structs[\u00a7](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#structs)\n\n[IntoIter](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.IntoIter.html \"struct crossbeam_channel::IntoIter\")\n    A blocking iterator over messages in a channel.\n\n[Iter](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Iter.html \"struct crossbeam_channel::Iter\")\n    A blocking iterator over messages in a channel.\n\n[ReadyTimeoutError](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.ReadyTimeoutError.html \"struct crossbeam_channel::ReadyTimeoutError\")\n    An error returned from the [`ready_timeout`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Select.html#method.ready_timeout \"method crossbeam_channel::Select::ready_timeout\") method.\n\n[Receiver](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Receiver.html \"struct crossbeam_channel::Receiver\")\n    The receiving side of a channel.\n\n[RecvError](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.RecvError.html \"struct crossbeam_channel::RecvError\")\n    An error returned from the [`recv`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Receiver.html#method.recv \"method crossbeam_channel::Receiver::recv\") method.\n\n[Select](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Select.html \"struct crossbeam_channel::Select\")\n    Selects from a set of channel operations.\n\n[SelectTimeoutError](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.SelectTimeoutError.html \"struct crossbeam_channel::SelectTimeoutError\")\n    An error returned from the [`select_timeout`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Select.html#method.select_timeout \"method crossbeam_channel::Select::select_timeout\") method.\n\n[SelectedOperation](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.SelectedOperation.html \"struct crossbeam_channel::SelectedOperation\")\n    A selected operation that needs to be completed.\n\n[SendError](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.SendError.html \"struct crossbeam_channel::SendError\")\n    An error returned from the [`send`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Sender.html#method.send \"method crossbeam_channel::Sender::send\") method.\n\n[Sender](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Sender.html \"struct crossbeam_channel::Sender\")\n    The sending side of a channel.\n\n[TryIter](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.TryIter.html \"struct crossbeam_channel::TryIter\")\n    A non-blocking iterator over messages in a channel.\n\n[TryReadyError](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.TryReadyError.html \"struct crossbeam_channel::TryReadyError\")\n    An error returned from the [`try_ready`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Select.html#method.try_ready \"method crossbeam_channel::Select::try_ready\") method.\n\n[TrySelectError](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.TrySelectError.html \"struct crossbeam_channel::TrySelectError\")\n    An error returned from the [`try_select`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Select.html#method.try_select \"method crossbeam_channel::Select::try_select\") method.\n## Enums[\u00a7](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#enums)\n\n[RecvTimeoutError](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/enum.RecvTimeoutError.html \"enum crossbeam_channel::RecvTimeoutError\")\n    An error returned from the [`recv_timeout`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Receiver.html#method.recv_timeout \"method crossbeam_channel::Receiver::recv_timeout\") method.\n\n[SendTimeoutError](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/enum.SendTimeoutError.html \"enum crossbeam_channel::SendTimeoutError\")\n    An error returned from the [`send_timeout`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Sender.html#method.send_timeout \"method crossbeam_channel::Sender::send_timeout\") method.\n\n[TryRecvError](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/enum.TryRecvError.html \"enum crossbeam_channel::TryRecvError\")\n    An error returned from the [`try_recv`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Receiver.html#method.try_recv \"method crossbeam_channel::Receiver::try_recv\") method.\n\n[TrySendError](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/enum.TrySendError.html \"enum crossbeam_channel::TrySendError\")\n    An error returned from the [`try_send`](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Sender.html#method.try_send \"method crossbeam_channel::Sender::try_send\") method.\n## Functions[\u00a7](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#functions)\n\n[after](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/fn.after.html \"fn crossbeam_channel::after\")\n    Creates a receiver that delivers a message after a certain duration of time.\n\n[at](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/fn.at.html \"fn crossbeam_channel::at\")\n    Creates a receiver that delivers a message at a certain instant in time.\n\n[bounded](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/fn.bounded.html \"fn crossbeam_channel::bounded\")\n    Creates a channel of bounded capacity.\n\n[never](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/fn.never.html \"fn crossbeam_channel::never\")\n    Creates a receiver that never delivers messages.\n\n[tick](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/fn.tick.html \"fn crossbeam_channel::tick\")\n    Creates a receiver that delivers messages periodically.\n\n[unbounded](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/fn.unbounded.html \"fn crossbeam_channel::unbounded\")\n    Creates a channel of unbounded capacity.\n",
        "markdown_with_citations": "[](https://docs.rs/crossbeam-channel/latest/crossbeam_channel/all.html \"show sidebar\")\n# Crate crossbeam_channelCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nMulti-producer multi-consumer channels for message passing.\nThis crate is an alternative to `std::sync::mpsc`\u27e84\u27e9 with more features and better performance.\n## \u00a7\u27e85\u27e9Hello, world!\n```\nuse crossbeam_channel::unbounded;\n// Create a channel of unbounded capacity.\nlet (s, r) = unbounded();\n// Send a message into the channel.\ns.send(\"Hello, world!\").unwrap();\n// Receive the message from the channel.\nassert_eq!(r.recv(), Ok(\"Hello, world!\"));\n```\n\n## \u00a7\u27e86\u27e9Channel types\nChannels can be created using two functions:\n  * `bounded`\u27e87\u27e9 creates a channel of bounded capacity, i.e. there is a limit to how many messages it can hold at a time.\n  * `unbounded`\u27e88\u27e9 creates a channel of unbounded capacity, i.e. it can hold any number of messages at a time.\n\n\nBoth functions return a `Sender`\u27e89\u27e9 and a `Receiver`\u27e810\u27e9, which represent the two opposite sides of a channel.\nCreating a bounded channel:\n```\nuse crossbeam_channel::bounded;\n// Create a channel that can hold at most 5 messages at a time.\nlet (s, r) = bounded(5);\n// Can send only 5 messages without blocking.\nfor i in 0..5 {\n  s.send(i).unwrap();\n}\n// Another call to `send` would block because the channel is full.\n// s.send(5).unwrap();\n```\n\nCreating an unbounded channel:\n```\nuse crossbeam_channel::unbounded;\n// Create an unbounded channel.\nlet (s, r) = unbounded();\n// Can send any number of messages into the channel without blocking.\nfor i in 0..1000 {\n  s.send(i).unwrap();\n}\n```\n\nA special case is zero-capacity channel, which cannot hold any messages. Instead, send and receive operations must appear at the same time in order to pair up and pass the message over:\n```\nuse std::thread;\nuse crossbeam_channel::bounded;\n// Create a zero-capacity channel.\nlet (s, r) = bounded(0);\n// Sending blocks until a receive operation appears on the other side.\nthread::spawn(move || s.send(\"Hi!\").unwrap());\n// Receiving blocks until a send operation appears on the other side.\nassert_eq!(r.recv(), Ok(\"Hi!\"));\n```\n\n## \u00a7\u27e811\u27e9Sharing channels\nSenders and receivers can be cloned and sent to other threads:\n```\nuse std::thread;\nuse crossbeam_channel::bounded;\nlet (s1, r1) = bounded(0);\nlet (s2, r2) = (s1.clone(), r1.clone());\n// Spawn a thread that receives a message and then sends one.\nthread::spawn(move || {\n  r2.recv().unwrap();\n  s2.send(2).unwrap();\n});\n// Send a message and then receive one.\ns1.send(1).unwrap();\nr1.recv().unwrap();\n```\n\nNote that cloning only creates a new handle to the same sending or receiving side. It does not create a separate stream of messages in any way:\n```\nuse crossbeam_channel::unbounded;\nlet (s1, r1) = unbounded();\nlet (s2, r2) = (s1.clone(), r1.clone());\nlet (s3, r3) = (s2.clone(), r2.clone());\ns1.send(10).unwrap();\ns2.send(20).unwrap();\ns3.send(30).unwrap();\nassert_eq!(r3.recv(), Ok(10));\nassert_eq!(r1.recv(), Ok(20));\nassert_eq!(r2.recv(), Ok(30));\n```\n\nIt\u2019s also possible to share senders and receivers by reference:\n```\nuse crossbeam_channel::bounded;\nuse crossbeam_utils::thread::scope;\nlet (s, r) = bounded(0);\nscope(|scope| {\n  // Spawn a thread that receives a message and then sends one.\n  scope.spawn(|_| {\n    r.recv().unwrap();\n    s.send(2).unwrap();\n  });\n  // Send a message and then receive one.\n  s.send(1).unwrap();\n  r.recv().unwrap();\n}).unwrap();\n```\n\n## \u00a7\u27e812\u27e9Disconnection\nWhen all senders or all receivers associated with a channel get dropped, the channel becomes disconnected. No more messages can be sent, but any remaining messages can still be received. Send and receive operations on a disconnected channel never block.\n```\nuse crossbeam_channel::{unbounded, RecvError};\nlet (s, r) = unbounded();\ns.send(1).unwrap();\ns.send(2).unwrap();\ns.send(3).unwrap();\n// The only sender is dropped, disconnecting the channel.\ndrop(s);\n// The remaining messages can be received.\nassert_eq!(r.recv(), Ok(1));\nassert_eq!(r.recv(), Ok(2));\nassert_eq!(r.recv(), Ok(3));\n// There are no more messages in the channel.\nassert!(r.is_empty());\n// Note that calling `r.recv()` does not block.\n// Instead, `Err(RecvError)` is returned immediately.\nassert_eq!(r.recv(), Err(RecvError));\n```\n\n## \u00a7\u27e813\u27e9Blocking operations\nSend and receive operations come in three flavors:\n  * Non-blocking (returns immediately with success or failure).\n  * Blocking (waits until the operation succeeds or the channel becomes disconnected).\n  * Blocking with a timeout (blocks only for a certain duration of time).\n\n\nA simple example showing the difference between non-blocking and blocking operations:\n```\nuse crossbeam_channel::{bounded, RecvError, TryRecvError};\nlet (s, r) = bounded(1);\n// Send a message into the channel.\ns.send(\"foo\").unwrap();\n// This call would block because the channel is full.\n// s.send(\"bar\").unwrap();\n// Receive the message.\nassert_eq!(r.recv(), Ok(\"foo\"));\n// This call would block because the channel is empty.\n// r.recv();\n// Try receiving a message without blocking.\nassert_eq!(r.try_recv(), Err(TryRecvError::Empty));\n// Disconnect the channel.\ndrop(s);\n// This call doesn't block because the channel is now disconnected.\nassert_eq!(r.recv(), Err(RecvError));\n```\n\n## \u00a7\u27e814\u27e9Iteration\nReceivers can be used as iterators. For example, method `iter`\u27e815\u27e9 creates an iterator that receives messages until the channel becomes empty and disconnected. Note that iteration may block waiting for next message to arrive.\n```\nuse std::thread;\nuse crossbeam_channel::unbounded;\nlet (s, r) = unbounded();\nthread::spawn(move || {\n  s.send(1).unwrap();\n  s.send(2).unwrap();\n  s.send(3).unwrap();\n  drop(s); // Disconnect the channel.\n});\n// Collect all messages from the channel.\n// Note that the call to `collect` blocks until the sender is dropped.\nlet v: Vec<_> = r.iter().collect();\nassert_eq!(v, [1, 2, 3]);\n```\n\nA non-blocking iterator can be created using `try_iter`\u27e816\u27e9, which receives all available messages without blocking:\n```\nuse crossbeam_channel::unbounded;\nlet (s, r) = unbounded();\ns.send(1).unwrap();\ns.send(2).unwrap();\ns.send(3).unwrap();\n// No need to drop the sender.\n// Receive all messages currently in the channel.\nlet v: Vec<_> = r.try_iter().collect();\nassert_eq!(v, [1, 2, 3]);\n```\n\n## \u00a7\u27e817\u27e9Selection\nThe `select!`\u27e818\u27e9 macro allows you to define a set of channel operations, wait until any one of them becomes ready, and finally execute it. If multiple operations are ready at the same time, a random one among them is selected.\nIt is also possible to define a `default` case that gets executed if none of the operations are ready, either right away or for a certain duration of time.\nAn operation is considered to be ready if it doesn\u2019t have to block. Note that it is ready even when it will simply return an error because the channel is disconnected.\nAn example of receiving a message from two channels:\n```\nuse std::thread;\nuse std::time::Duration;\nuse crossbeam_channel::{select, unbounded};\nlet (s1, r1) = unbounded();\nlet (s2, r2) = unbounded();\nthread::spawn(move || s1.send(10).unwrap());\nthread::spawn(move || s2.send(20).unwrap());\n// At most one of these two receive operations will be executed.\nselect! {\n  recv(r1) -> msg => assert_eq!(msg, Ok(10)),\n  recv(r2) -> msg => assert_eq!(msg, Ok(20)),\n  default(Duration::from_secs(1)) => println!(\"timed out\"),\n}\n```\n\nIf you need to select over a dynamically created list of channel operations, use `Select`\u27e819\u27e9 instead. The `select!`\u27e818\u27e9 macro is just a convenience wrapper around `Select`\u27e819\u27e9.\n## \u00a7\u27e820\u27e9Extra channels\nThree functions can create special kinds of channels, all of which return just a `Receiver`\u27e810\u27e9 handle:\n  * `after`\u27e821\u27e9 creates a channel that delivers a single message after a certain duration of time.\n  * `tick`\u27e822\u27e9 creates a channel that delivers messages periodically.\n  * `never`\u27e823\u27e9 creates a channel that never delivers messages.\n\n\nThese channels are very efficient because messages get lazily generated on receive operations.\nAn example that prints elapsed time every 50 milliseconds for the duration of 1 second:\n```\nuse std::time::{Duration, Instant};\nuse crossbeam_channel::{after, select, tick};\nlet start = Instant::now();\nlet ticker = tick(Duration::from_millis(50));\nlet timeout = after(Duration::from_secs(1));\nloop {\n  select! {\n    recv(ticker) -> _ => println!(\"elapsed: {:?}\", start.elapsed()),\n    recv(timeout) -> _ => break,\n  }\n}\n```\n\n## Macros\u00a7\u27e824\u27e9\n\nselect\u27e818\u27e9\n    Selects from a set of channel operations.\n\nselect_biased\u27e825\u27e9\n    Selects from a set of channel operations.\n## Structs\u00a7\u27e826\u27e9\n\nIntoIter\u27e827\u27e9\n    A blocking iterator over messages in a channel.\n\nIter\u27e828\u27e9\n    A blocking iterator over messages in a channel.\n\nReadyTimeoutError\u27e829\u27e9\n    An error returned from the `ready_timeout`\u27e830\u27e9 method.\n\nReceiver\u27e810\u27e9\n    The receiving side of a channel.\n\nRecvError\u27e831\u27e9\n    An error returned from the `recv`\u27e832\u27e9 method.\n\nSelect\u27e819\u27e9\n    Selects from a set of channel operations.\n\nSelectTimeoutError\u27e833\u27e9\n    An error returned from the `select_timeout`\u27e834\u27e9 method.\n\nSelectedOperation\u27e835\u27e9\n    A selected operation that needs to be completed.\n\nSendError\u27e836\u27e9\n    An error returned from the `send`\u27e837\u27e9 method.\n\nSender\u27e89\u27e9\n    The sending side of a channel.\n\nTryIter\u27e838\u27e9\n    A non-blocking iterator over messages in a channel.\n\nTryReadyError\u27e839\u27e9\n    An error returned from the `try_ready`\u27e840\u27e9 method.\n\nTrySelectError\u27e841\u27e9\n    An error returned from the `try_select`\u27e842\u27e9 method.\n## Enums\u00a7\u27e843\u27e9\n\nRecvTimeoutError\u27e844\u27e9\n    An error returned from the `recv_timeout`\u27e845\u27e9 method.\n\nSendTimeoutError\u27e846\u27e9\n    An error returned from the `send_timeout`\u27e847\u27e9 method.\n\nTryRecvError\u27e848\u27e9\n    An error returned from the `try_recv`\u27e849\u27e9 method.\n\nTrySendError\u27e850\u27e9\n    An error returned from the `try_send`\u27e851\u27e9 method.\n## Functions\u00a7\u27e852\u27e9\n\nafter\u27e821\u27e9\n    Creates a receiver that delivers a message after a certain duration of time.\n\nat\u27e853\u27e9\n    Creates a receiver that delivers a message at a certain instant in time.\n\nbounded\u27e87\u27e9\n    Creates a channel of bounded capacity.\n\nnever\u27e823\u27e9\n    Creates a receiver that never delivers messages.\n\ntick\u27e822\u27e9\n    Creates a receiver that delivers messages periodically.\n\nunbounded\u27e88\u27e9\n    Creates a channel of unbounded capacity.\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/crossbeam-channel/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/crossbeam-channel/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/crossbeam-channel/latest/src/crossbeam_channel/lib.rs.html#1-378: Source\n\u27e84\u27e9 https://doc.rust-lang.org/nightly/std/sync/mpsc/index.html: mod std::sync::mpsc - `std::sync::mpsc`\n\u27e85\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#hello-world: \u00a7\n\u27e86\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#channel-types: \u00a7\n\u27e87\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/fn.bounded.html: fn crossbeam_channel::bounded - `bounded`\n\u27e88\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/fn.unbounded.html: fn crossbeam_channel::unbounded - `unbounded`\n\u27e89\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Sender.html: struct crossbeam_channel::Sender - `Sender`\n\u27e810\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Receiver.html: struct crossbeam_channel::Receiver - `Receiver`\n\u27e811\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#sharing-channels: \u00a7\n\u27e812\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#disconnection: \u00a7\n\u27e813\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#blocking-operations: \u00a7\n\u27e814\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#iteration: \u00a7\n\u27e815\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Receiver.html#method.iter: method crossbeam_channel::Receiver::iter - `iter`\n\u27e816\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Receiver.html#method.try_iter: method crossbeam_channel::Receiver::try_iter - `try_iter`\n\u27e817\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#selection: \u00a7\n\u27e818\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/macro.select.html: macro crossbeam_channel::select - `select!`\n\u27e819\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Select.html: struct crossbeam_channel::Select - `Select`\n\u27e820\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#extra-channels: \u00a7\n\u27e821\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/fn.after.html: fn crossbeam_channel::after - `after`\n\u27e822\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/fn.tick.html: fn crossbeam_channel::tick - `tick`\n\u27e823\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/fn.never.html: fn crossbeam_channel::never - `never`\n\u27e824\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#macros: \u00a7\n\u27e825\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/macro.select_biased.html: macro crossbeam_channel::select_biased - select_biased\n\u27e826\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#structs: \u00a7\n\u27e827\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.IntoIter.html: struct crossbeam_channel::IntoIter - IntoIter\n\u27e828\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Iter.html: struct crossbeam_channel::Iter - Iter\n\u27e829\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.ReadyTimeoutError.html: struct crossbeam_channel::ReadyTimeoutError - ReadyTimeoutError\n\u27e830\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Select.html#method.ready_timeout: method crossbeam_channel::Select::ready_timeout - `ready_timeout`\n\u27e831\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.RecvError.html: struct crossbeam_channel::RecvError - RecvError\n\u27e832\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Receiver.html#method.recv: method crossbeam_channel::Receiver::recv - `recv`\n\u27e833\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.SelectTimeoutError.html: struct crossbeam_channel::SelectTimeoutError - SelectTimeoutError\n\u27e834\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Select.html#method.select_timeout: method crossbeam_channel::Select::select_timeout - `select_timeout`\n\u27e835\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.SelectedOperation.html: struct crossbeam_channel::SelectedOperation - SelectedOperation\n\u27e836\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.SendError.html: struct crossbeam_channel::SendError - SendError\n\u27e837\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Sender.html#method.send: method crossbeam_channel::Sender::send - `send`\n\u27e838\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.TryIter.html: struct crossbeam_channel::TryIter - TryIter\n\u27e839\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.TryReadyError.html: struct crossbeam_channel::TryReadyError - TryReadyError\n\u27e840\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Select.html#method.try_ready: method crossbeam_channel::Select::try_ready - `try_ready`\n\u27e841\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.TrySelectError.html: struct crossbeam_channel::TrySelectError - TrySelectError\n\u27e842\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Select.html#method.try_select: method crossbeam_channel::Select::try_select - `try_select`\n\u27e843\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#enums: \u00a7\n\u27e844\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/enum.RecvTimeoutError.html: enum crossbeam_channel::RecvTimeoutError - RecvTimeoutError\n\u27e845\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Receiver.html#method.recv_timeout: method crossbeam_channel::Receiver::recv_timeout - `recv_timeout`\n\u27e846\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/enum.SendTimeoutError.html: enum crossbeam_channel::SendTimeoutError - SendTimeoutError\n\u27e847\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Sender.html#method.send_timeout: method crossbeam_channel::Sender::send_timeout - `send_timeout`\n\u27e848\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/enum.TryRecvError.html: enum crossbeam_channel::TryRecvError - TryRecvError\n\u27e849\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Receiver.html#method.try_recv: method crossbeam_channel::Receiver::try_recv - `try_recv`\n\u27e850\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/enum.TrySendError.html: enum crossbeam_channel::TrySendError - TrySendError\n\u27e851\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/struct.Sender.html#method.try_send: method crossbeam_channel::Sender::try_send - `try_send`\n\u27e852\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/#functions: \u00a7\n\u27e853\u27e9 https://docs.rs/crossbeam-channel/latest/crossbeam_channel/fn.at.html: fn crossbeam_channel::at - at\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `crossbeam-channel` crate provides multi-producer, multi-consumer channels for efficient message passing, serving as an enhanced alternative to `std::sync::mpsc`. It supports bounded, unbounded, and zero-capacity channels, offers blocking, non-blocking, and timeout-based operations, and enables channel sharing across threads. Additional features include iteration, dynamic selection with the `select!` macro, and specialized channels like `tick`, `after`, and `never` for timed or periodic messaging.",
    "feature_summary": null,
    "use_case": "Utilities",
    "score": 8.5,
    "factual_counterfactual": "### Pair 1: Channel Types  \n\u2705 **Factual:** The `crossbeam-channel` crate provides two primary types of channels: `bounded`, which limits the number of messages in the channel, and `unbounded`, which allows an unlimited number of messages.  \n\u274c **Counterfactual:** The `crossbeam-channel` crate only supports bounded channels, requiring users to specify a capacity for every channel created.  \n\n---\n\n### Pair 2: Zero-Capacity Channels  \n\u2705 **Factual:** Zero-capacity channels in `crossbeam-channel` require send and receive operations to occur simultaneously, as they cannot hold any messages.  \n\u274c **Counterfactual:** Zero-capacity channels in `crossbeam-channel` automatically queue messages if a receiver is not immediately available.  \n\n---\n\n### Pair 3: Iteration  \n\u2705 **Factual:** Receivers in `crossbeam-channel` can be used as blocking iterators with the `iter` method, which waits for messages until the channel becomes empty and disconnected.  \n\u274c **Counterfactual:** The `iter` method on receivers in `crossbeam-channel` only retrieves messages that are already in the channel and does not block for new messages.  \n\n---",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}