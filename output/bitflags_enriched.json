{
    "name": "bitflags",
    "version": "2.9.1",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/bitflags/latest/bitflags/all.html \"show sidebar\")\n# Crate bitflagsCopy item path\n[Settings](https://docs.rs/bitflags/latest/settings.html)\n[Help](https://docs.rs/bitflags/latest/help.html)\nSummary[Source](https://docs.rs/bitflags/latest/src/bitflags/lib.rs.html#11-1034)\nExpand description\nGenerate types for C-style flags with ergonomic APIs.\n## [\u00a7](https://docs.rs/bitflags/latest/bitflags/#getting-started)Getting started\nAdd `bitflags` to your `Cargo.toml`:\n```\n[dependencies.bitflags]\nversion = \"2.9.1\"\n```\n\n### [\u00a7](https://docs.rs/bitflags/latest/bitflags/#crate-features)Crate features\nThe `bitflags` library defines a few Cargo features that you can opt-in to:\n  * `std`: Implement the `Error` trait on error types used by `bitflags`.\n  * `serde`: Support deriving `serde` traits on generated flags types.\n  * `arbitrary`: Support deriving `arbitrary` traits on generated flags types.\n  * `bytemuck`: Support deriving `bytemuck` traits on generated flags types.\n\n\n### [\u00a7](https://docs.rs/bitflags/latest/bitflags/#generating-flags-types)Generating flags types\nUse the [`bitflags`](https://docs.rs/bitflags/latest/bitflags/macro.bitflags.html \"macro bitflags::bitflags\") macro to generate flags types:\n```\nuse bitflags::bitflags;\nbitflags! {\n  pub struct Flags: u32 {\n    const A = 0b00000001;\n    const B = 0b00000010;\n    const C = 0b00000100;\n  }\n}\n```\n\nSee the docs for the `bitflags` macro for the full syntax.\nAlso see the [`example_generated`](https://docs.rs/bitflags/latest/bitflags/example_generated/index.html) module for an example of what the `bitflags` macro generates for a flags type.\n#### [\u00a7](https://docs.rs/bitflags/latest/bitflags/#externally-defined-flags)Externally defined flags\nIf you\u2019re generating flags types for an external source, such as a C API, you can define an extra unnamed flag as a mask of all bits the external source may ever set. Usually this would be all bits (`!0`):\n```\nbitflags! {\n  pub struct Flags: u32 {\n    const A = 0b00000001;\n    const B = 0b00000010;\n    const C = 0b00000100;\n    // The source may set any bits\n    const _ = !0;\n  }\n}\n```\n\nWhy should you do this? Generated methods like `all` and truncating operators like `!` only consider bits in defined flags. Adding an unnamed flag makes those methods consider additional bits, without generating additional constants for them. It helps compatibility when the external source may start setting additional bits at any time. The [known and unknown bits](https://docs.rs/bitflags/latest/bitflags/#known-and-unknown-bits) section has more details on this behavior.\n#### [\u00a7](https://docs.rs/bitflags/latest/bitflags/#custom-derives)Custom derives\nYou can derive some traits on generated flags types if you enable Cargo features. The following libraries are currently supported:\n  * `serde`: Support `#[derive(Serialize, Deserialize)]`, using text for human-readable formats, and a raw number for binary formats.\n  * `arbitrary`: Support `#[derive(Arbitrary)]`, only generating flags values with known bits.\n  * `bytemuck`: Support `#[derive(Pod, Zeroable)]`, for casting between flags values and their underlying bits values.\n\n\nYou can also define your own flags type outside of the [`bitflags`](https://docs.rs/bitflags/latest/bitflags/macro.bitflags.html \"macro bitflags::bitflags\") macro and then use it to generate methods. This can be useful if you need a custom `#[derive]` attribute for a library that `bitflags` doesn\u2019t natively support:\n```\n#[derive(SomeTrait)]\npub struct Flags(u32);\nbitflags! {\n  impl Flags: u32 {\n    const A = 0b00000001;\n    const B = 0b00000010;\n    const C = 0b00000100;\n  }\n}\n```\n\n#### [\u00a7](https://docs.rs/bitflags/latest/bitflags/#adding-custom-methods)Adding custom methods\nThe [`bitflags`](https://docs.rs/bitflags/latest/bitflags/macro.bitflags.html \"macro bitflags::bitflags\") macro supports attributes on generated flags types within the macro itself, while `impl` blocks can be added outside of it:\n```\nbitflags! {\n  // Attributes can be applied to flags types\n  #[repr(transparent)]\n  #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n  pub struct Flags: u32 {\n    const A = 0b00000001;\n    const B = 0b00000010;\n    const C = 0b00000100;\n  }\n}\n// Impl blocks can be added to flags types\nimpl Flags {\n  pub fn as_u64(&self) -> u64 {\n    self.bits() as u64\n  }\n}\n```\n\n### [\u00a7](https://docs.rs/bitflags/latest/bitflags/#working-with-flags-values)Working with flags values\nUse generated constants and standard bitwise operators to interact with flags values:\n```\n// union\nlet ab = Flags::A | Flags::B;\n// intersection\nlet a = ab & Flags::A;\n// difference\nlet b = ab - Flags::A;\n// complement\nlet c = !ab;\n```\n\nSee the docs for the [`Flags`](https://docs.rs/bitflags/latest/bitflags/trait.Flags.html \"trait bitflags::Flags\") trait for more details on operators and how they behave.\n## [\u00a7](https://docs.rs/bitflags/latest/bitflags/#formatting-and-parsing)Formatting and parsing\n`bitflags` defines a text format that can be used to convert any flags value to and from strings.\nSee the [`parser`](https://docs.rs/bitflags/latest/bitflags/parser/index.html \"mod bitflags::parser\") module for more details.\n## [\u00a7](https://docs.rs/bitflags/latest/bitflags/#specification)Specification\nThe terminology and behavior of generated flags types is [specified in the source repository](https://github.com/bitflags/bitflags/blob/main/spec.md). Details are repeated in these docs where appropriate, but is exhaustively listed in the spec. Some things are worth calling out explicitly here.\n### [\u00a7](https://docs.rs/bitflags/latest/bitflags/#flags-types-flags-values-flags)Flags types, flags values, flags\nThe spec and these docs use consistent terminology to refer to things in the bitflags domain:\n  * **Bits type** : A type that defines a fixed number of bits at specific locations.\n  * **Flag** : A set of bits in a bits type that may have a unique name.\n  * **Flags type** : A set of defined flags over a specific bits type.\n  * **Flags value** : An instance of a flags type using its specific bits value for storage.\n\n\n```\nbitflags! {\n  struct FlagsType: u8 {\n//          -- Bits type\n//     --------- Flags type\n    const A = 1;\n//      ----- Flag\n  }\n}\nlet flag = FlagsType::A;\n// ---- Flags value\n```\n\n### [\u00a7](https://docs.rs/bitflags/latest/bitflags/#known-and-unknown-bits)Known and unknown bits\nAny bits in a flag you define are called _known bits_. Any other bits are _unknown bits_. In the following flags type:\n```\nbitflags! {\n  struct Flags: u8 {\n    const A = 1;\n    const B = 1 << 1;\n    const C = 1 << 2;\n  }\n}\n```\n\nThe known bits are `0b0000_0111` and the unknown bits are `0b1111_1000`.\n`bitflags` doesn\u2019t guarantee that a flags value will only ever have known bits set, but some operators will unset any unknown bits they encounter. In a future version of `bitflags`, all operators will unset unknown bits.\nIf you\u2019re using `bitflags` for flags types defined externally, such as from C, you probably want all bits to be considered known, in case that external source changes. You can do this using an unnamed flag, as described in [externally defined flags](https://docs.rs/bitflags/latest/bitflags/#externally-defined-flags).\n### [\u00a7](https://docs.rs/bitflags/latest/bitflags/#zero-bit-flags)Zero-bit flags\nFlags with no bits set should be avoided because they interact strangely with [`Flags::contains`](https://docs.rs/bitflags/latest/bitflags/trait.Flags.html#method.contains \"method bitflags::Flags::contains\") and [`Flags::intersects`](https://docs.rs/bitflags/latest/bitflags/trait.Flags.html#method.intersects \"method bitflags::Flags::intersects\"). A zero-bit flag is always contained, but is never intersected. The names of zero-bit flags can be parsed, but are never formatted.\n### [\u00a7](https://docs.rs/bitflags/latest/bitflags/#multi-bit-flags)Multi-bit flags\nFlags that set multiple bits should be avoided unless each bit is also in a single-bit flag. Take the following flags type as an example:\n```\nbitflags! {\n  struct Flags: u8 {\n    const A = 1;\n    const B = 1 | 1 << 1;\n  }\n}\n```\n\nThe result of `Flags::A ^ Flags::B` is `0b0000_0010`, which doesn\u2019t correspond to either `Flags::A` or `Flags::B` even though it\u2019s still a known bit.\n## Modules[\u00a7](https://docs.rs/bitflags/latest/bitflags/#modules)\n\n[example_generated](https://docs.rs/bitflags/latest/bitflags/example_generated/index.html \"mod bitflags::example_generated\")\n    This module shows an example of code generated by the macro. **IT MUST NOT BE USED OUTSIDE THIS CRATE**.\n\n[iter](https://docs.rs/bitflags/latest/bitflags/iter/index.html \"mod bitflags::iter\")\n    Yield the bits of a source flags value in a set of contained flags values.\n\n[parser](https://docs.rs/bitflags/latest/bitflags/parser/index.html \"mod bitflags::parser\")\n    Parsing flags from text.\n## Macros[\u00a7](https://docs.rs/bitflags/latest/bitflags/#macros)\n\n[bitflags](https://docs.rs/bitflags/latest/bitflags/macro.bitflags.html \"macro bitflags::bitflags\")\n    Generate a flags type.\n\n[bitflags_match](https://docs.rs/bitflags/latest/bitflags/macro.bitflags_match.html \"macro bitflags::bitflags_match\")\n    A macro that matches flags values, similar to Rust\u2019s `match` statement.\n## Structs[\u00a7](https://docs.rs/bitflags/latest/bitflags/#structs)\n\n[Flag](https://docs.rs/bitflags/latest/bitflags/struct.Flag.html \"struct bitflags::Flag\")\n    A defined flags value that may be named or unnamed.\n## Traits[\u00a7](https://docs.rs/bitflags/latest/bitflags/#traits)\n\n[Bits](https://docs.rs/bitflags/latest/bitflags/trait.Bits.html \"trait bitflags::Bits\")\n    A bits type that can be used as storage for a flags type.\n\n[Flags](https://docs.rs/bitflags/latest/bitflags/trait.Flags.html \"trait bitflags::Flags\")\n    A set of defined flags using a bits type as storage.\n",
        "markdown_with_citations": "[](https://docs.rs/bitflags/latest/bitflags/all.html \"show sidebar\")\n# Crate bitflagsCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nGenerate types for C-style flags with ergonomic APIs.\n## \u00a7\u27e84\u27e9Getting started\nAdd `bitflags` to your `Cargo.toml`:\n```\n[dependencies.bitflags]\nversion = \"2.9.1\"\n```\n\n### \u00a7\u27e85\u27e9Crate features\nThe `bitflags` library defines a few Cargo features that you can opt-in to:\n  * `std`: Implement the `Error` trait on error types used by `bitflags`.\n  * `serde`: Support deriving `serde` traits on generated flags types.\n  * `arbitrary`: Support deriving `arbitrary` traits on generated flags types.\n  * `bytemuck`: Support deriving `bytemuck` traits on generated flags types.\n\n\n### \u00a7\u27e86\u27e9Generating flags types\nUse the `bitflags`\u27e87\u27e9 macro to generate flags types:\n```\nuse bitflags::bitflags;\nbitflags! {\n  pub struct Flags: u32 {\n    const A = 0b00000001;\n    const B = 0b00000010;\n    const C = 0b00000100;\n  }\n}\n```\n\nSee the docs for the `bitflags` macro for the full syntax.\nAlso see the `example_generated`\u27e88\u27e9 module for an example of what the `bitflags` macro generates for a flags type.\n#### \u00a7\u27e89\u27e9Externally defined flags\nIf you\u2019re generating flags types for an external source, such as a C API, you can define an extra unnamed flag as a mask of all bits the external source may ever set. Usually this would be all bits (`!0`):\n```\nbitflags! {\n  pub struct Flags: u32 {\n    const A = 0b00000001;\n    const B = 0b00000010;\n    const C = 0b00000100;\n    // The source may set any bits\n    const _ = !0;\n  }\n}\n```\n\nWhy should you do this? Generated methods like `all` and truncating operators like `!` only consider bits in defined flags. Adding an unnamed flag makes those methods consider additional bits, without generating additional constants for them. It helps compatibility when the external source may start setting additional bits at any time. The known and unknown bits\u27e810\u27e9 section has more details on this behavior.\n#### \u00a7\u27e811\u27e9Custom derives\nYou can derive some traits on generated flags types if you enable Cargo features. The following libraries are currently supported:\n  * `serde`: Support `#[derive(Serialize, Deserialize)]`, using text for human-readable formats, and a raw number for binary formats.\n  * `arbitrary`: Support `#[derive(Arbitrary)]`, only generating flags values with known bits.\n  * `bytemuck`: Support `#[derive(Pod, Zeroable)]`, for casting between flags values and their underlying bits values.\n\n\nYou can also define your own flags type outside of the `bitflags`\u27e87\u27e9 macro and then use it to generate methods. This can be useful if you need a custom `#[derive]` attribute for a library that `bitflags` doesn\u2019t natively support:\n```\n#[derive(SomeTrait)]\npub struct Flags(u32);\nbitflags! {\n  impl Flags: u32 {\n    const A = 0b00000001;\n    const B = 0b00000010;\n    const C = 0b00000100;\n  }\n}\n```\n\n#### \u00a7\u27e812\u27e9Adding custom methods\nThe `bitflags`\u27e87\u27e9 macro supports attributes on generated flags types within the macro itself, while `impl` blocks can be added outside of it:\n```\nbitflags! {\n  // Attributes can be applied to flags types\n  #[repr(transparent)]\n  #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n  pub struct Flags: u32 {\n    const A = 0b00000001;\n    const B = 0b00000010;\n    const C = 0b00000100;\n  }\n}\n// Impl blocks can be added to flags types\nimpl Flags {\n  pub fn as_u64(&self) -> u64 {\n    self.bits() as u64\n  }\n}\n```\n\n### \u00a7\u27e813\u27e9Working with flags values\nUse generated constants and standard bitwise operators to interact with flags values:\n```\n// union\nlet ab = Flags::A | Flags::B;\n// intersection\nlet a = ab & Flags::A;\n// difference\nlet b = ab - Flags::A;\n// complement\nlet c = !ab;\n```\n\nSee the docs for the `Flags`\u27e814\u27e9 trait for more details on operators and how they behave.\n## \u00a7\u27e815\u27e9Formatting and parsing\n`bitflags` defines a text format that can be used to convert any flags value to and from strings.\nSee the `parser`\u27e816\u27e9 module for more details.\n## \u00a7\u27e817\u27e9Specification\nThe terminology and behavior of generated flags types is specified in the source repository\u27e818\u27e9. Details are repeated in these docs where appropriate, but is exhaustively listed in the spec. Some things are worth calling out explicitly here.\n### \u00a7\u27e819\u27e9Flags types, flags values, flags\nThe spec and these docs use consistent terminology to refer to things in the bitflags domain:\n  * **Bits type** : A type that defines a fixed number of bits at specific locations.\n  * **Flag** : A set of bits in a bits type that may have a unique name.\n  * **Flags type** : A set of defined flags over a specific bits type.\n  * **Flags value** : An instance of a flags type using its specific bits value for storage.\n\n\n```\nbitflags! {\n  struct FlagsType: u8 {\n//          -- Bits type\n//     --------- Flags type\n    const A = 1;\n//      ----- Flag\n  }\n}\nlet flag = FlagsType::A;\n// ---- Flags value\n```\n\n### \u00a7\u27e810\u27e9Known and unknown bits\nAny bits in a flag you define are called _known bits_. Any other bits are _unknown bits_. In the following flags type:\n```\nbitflags! {\n  struct Flags: u8 {\n    const A = 1;\n    const B = 1 << 1;\n    const C = 1 << 2;\n  }\n}\n```\n\nThe known bits are `0b0000_0111` and the unknown bits are `0b1111_1000`.\n`bitflags` doesn\u2019t guarantee that a flags value will only ever have known bits set, but some operators will unset any unknown bits they encounter. In a future version of `bitflags`, all operators will unset unknown bits.\nIf you\u2019re using `bitflags` for flags types defined externally, such as from C, you probably want all bits to be considered known, in case that external source changes. You can do this using an unnamed flag, as described in externally defined flags\u27e89\u27e9.\n### \u00a7\u27e820\u27e9Zero-bit flags\nFlags with no bits set should be avoided because they interact strangely with `Flags::contains`\u27e821\u27e9 and `Flags::intersects`\u27e822\u27e9. A zero-bit flag is always contained, but is never intersected. The names of zero-bit flags can be parsed, but are never formatted.\n### \u00a7\u27e823\u27e9Multi-bit flags\nFlags that set multiple bits should be avoided unless each bit is also in a single-bit flag. Take the following flags type as an example:\n```\nbitflags! {\n  struct Flags: u8 {\n    const A = 1;\n    const B = 1 | 1 << 1;\n  }\n}\n```\n\nThe result of `Flags::A ^ Flags::B` is `0b0000_0010`, which doesn\u2019t correspond to either `Flags::A` or `Flags::B` even though it\u2019s still a known bit.\n## Modules\u00a7\u27e824\u27e9\n\nexample_generated\u27e88\u27e9\n    This module shows an example of code generated by the macro. **IT MUST NOT BE USED OUTSIDE THIS CRATE**.\n\niter\u27e825\u27e9\n    Yield the bits of a source flags value in a set of contained flags values.\n\nparser\u27e816\u27e9\n    Parsing flags from text.\n## Macros\u00a7\u27e826\u27e9\n\nbitflags\u27e87\u27e9\n    Generate a flags type.\n\nbitflags_match\u27e827\u27e9\n    A macro that matches flags values, similar to Rust\u2019s `match` statement.\n## Structs\u00a7\u27e828\u27e9\n\nFlag\u27e829\u27e9\n    A defined flags value that may be named or unnamed.\n## Traits\u00a7\u27e830\u27e9\n\nBits\u27e831\u27e9\n    A bits type that can be used as storage for a flags type.\n\nFlags\u27e814\u27e9\n    A set of defined flags using a bits type as storage.\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/bitflags/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/bitflags/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/bitflags/latest/src/bitflags/lib.rs.html#11-1034: Source\n\u27e84\u27e9 https://docs.rs/bitflags/latest/bitflags/#getting-started: \u00a7\n\u27e85\u27e9 https://docs.rs/bitflags/latest/bitflags/#crate-features: \u00a7\n\u27e86\u27e9 https://docs.rs/bitflags/latest/bitflags/#generating-flags-types: \u00a7\n\u27e87\u27e9 https://docs.rs/bitflags/latest/bitflags/macro.bitflags.html: macro bitflags::bitflags - `bitflags`\n\u27e88\u27e9 https://docs.rs/bitflags/latest/bitflags/example_generated/index.html: `example_generated`\n\u27e89\u27e9 https://docs.rs/bitflags/latest/bitflags/#externally-defined-flags: \u00a7\n\u27e810\u27e9 https://docs.rs/bitflags/latest/bitflags/#known-and-unknown-bits: known and unknown bits\n\u27e811\u27e9 https://docs.rs/bitflags/latest/bitflags/#custom-derives: \u00a7\n\u27e812\u27e9 https://docs.rs/bitflags/latest/bitflags/#adding-custom-methods: \u00a7\n\u27e813\u27e9 https://docs.rs/bitflags/latest/bitflags/#working-with-flags-values: \u00a7\n\u27e814\u27e9 https://docs.rs/bitflags/latest/bitflags/trait.Flags.html: trait bitflags::Flags - `Flags`\n\u27e815\u27e9 https://docs.rs/bitflags/latest/bitflags/#formatting-and-parsing: \u00a7\n\u27e816\u27e9 https://docs.rs/bitflags/latest/bitflags/parser/index.html: mod bitflags::parser - `parser`\n\u27e817\u27e9 https://docs.rs/bitflags/latest/bitflags/#specification: \u00a7\n\u27e818\u27e9 https://github.com/bitflags/bitflags/blob/main/spec.md: specified in the source repository\n\u27e819\u27e9 https://docs.rs/bitflags/latest/bitflags/#flags-types-flags-values-flags: \u00a7\n\u27e820\u27e9 https://docs.rs/bitflags/latest/bitflags/#zero-bit-flags: \u00a7\n\u27e821\u27e9 https://docs.rs/bitflags/latest/bitflags/trait.Flags.html#method.contains: method bitflags::Flags::contains - `Flags::contains`\n\u27e822\u27e9 https://docs.rs/bitflags/latest/bitflags/trait.Flags.html#method.intersects: method bitflags::Flags::intersects - `Flags::intersects`\n\u27e823\u27e9 https://docs.rs/bitflags/latest/bitflags/#multi-bit-flags: \u00a7\n\u27e824\u27e9 https://docs.rs/bitflags/latest/bitflags/#modules: \u00a7\n\u27e825\u27e9 https://docs.rs/bitflags/latest/bitflags/iter/index.html: mod bitflags::iter - iter\n\u27e826\u27e9 https://docs.rs/bitflags/latest/bitflags/#macros: \u00a7\n\u27e827\u27e9 https://docs.rs/bitflags/latest/bitflags/macro.bitflags_match.html: macro bitflags::bitflags_match - bitflags_match\n\u27e828\u27e9 https://docs.rs/bitflags/latest/bitflags/#structs: \u00a7\n\u27e829\u27e9 https://docs.rs/bitflags/latest/bitflags/struct.Flag.html: struct bitflags::Flag - Flag\n\u27e830\u27e9 https://docs.rs/bitflags/latest/bitflags/#traits: \u00a7\n\u27e831\u27e9 https://docs.rs/bitflags/latest/bitflags/trait.Bits.html: trait bitflags::Bits - Bits\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `bitflags` crate provides a macro to define types for C-style bit flags with ergonomic APIs, enabling easy manipulation using bitwise operators. It supports custom derives (`serde`, `arbitrary`, `bytemuck`), allows integration with external flag definitions, and offers methods for formatting, parsing, and adding custom functionality. Key features include handling known/unknown bits, compatibility with external sources, and robust operator behavior for flags management.",
    "feature_summary": null,
    "use_case": "Utilities",
    "score": 8.5,
    "factual_counterfactual": "### Pair 1: Generating Flags Types  \n\u2705 Factual: The `bitflags` macro allows users to define flags types with ergonomic APIs, enabling bitwise operations like union (`|`), intersection (`&`), difference (`-`), and complement (`!`).  \n\u274c Counterfactual: The `bitflags` macro automatically generates flags types that support runtime reflection for dynamically inspecting all defined flags.  \n\n---\n\n### Pair 2: Custom Derives  \n\u2705 Factual: Enabling the `serde` feature allows flags types generated by `bitflags` to derive `Serialize` and `Deserialize`, supporting both human-readable text formats and raw binary formats.  \n\u274c Counterfactual: The `serde` feature automatically enables serialization of unknown bits in flags types, even if they are not explicitly defined.  \n\n---\n\n### Pair 3: Known and Unknown Bits  \n\u2705 Factual: The `bitflags` crate distinguishes between known bits (defined flags) and unknown bits, and operators like `!` can unset unknown bits to ensure compatibility with external sources.  \n\u274c Counterfactual: The `bitflags` crate guarantees that flags values will never contain unknown bits, regardless of external sources or operations performed on them.",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}