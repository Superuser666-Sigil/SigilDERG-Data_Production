{
    "name": "native-tls",
    "version": "0.2.14",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/native-tls/latest/native_tls/all.html \"show sidebar\")\n# Crate native_tlsCopy item path\n[Settings](https://docs.rs/native-tls/latest/settings.html)\n[Help](https://docs.rs/native-tls/latest/help.html)\nSummary[Source](https://docs.rs/native-tls/latest/src/native_tls/lib.rs.html#1-719)\nExpand description\nAn abstraction over platform-specific TLS implementations.\nMany applications require TLS/SSL communication in one form or another as part of their implementation, but finding a library for this isn\u2019t always trivial! The purpose of this crate is to provide a seamless integration experience on all platforms with a cross-platform API that deals with all the underlying details for you.\n## [\u00a7](https://docs.rs/native-tls/latest/native_tls/#how-is-this-implemented)How is this implemented?\nThis crate uses SChannel on Windows (via the `schannel` crate), Secure Transport on OSX (via the `security-framework` crate), and OpenSSL (via the `openssl` crate) on all other platforms. Future features may also enable other TLS frameworks as well, but these initial libraries are likely to remain as the defaults.\nNote that this crate also strives to be secure-by-default. For example when using OpenSSL it will configure validation callbacks to ensure that hostnames match certificates, use strong ciphers, etc. This implies that this crate is _not_ just a thin abstraction around the underlying libraries, but also an implementation that strives to strike reasonable defaults.\n## [\u00a7](https://docs.rs/native-tls/latest/native_tls/#supported-features)Supported features\nThis crate supports the following features out of the box:\n  * TLS/SSL client communication\n  * TLS/SSL server communication\n  * PKCS#12 encoded identities\n  * X.509/PKCS#8 encoded identities\n  * Secure-by-default for client and server \n    * Includes hostname verification for clients\n  * Supports asynchronous I/O for both the server and the client\n\n\n## [\u00a7](https://docs.rs/native-tls/latest/native_tls/#cargo-features)Cargo Features\n  * `vendored` - If enabled, the crate will compile and statically link to a vendored copy of OpenSSL. This feature has no effect on Windows and macOS, where OpenSSL is not used.\n\n\n## [\u00a7](https://docs.rs/native-tls/latest/native_tls/#examples)Examples\nTo connect as a client to a remote server:\n```\nuse native_tls::TlsConnector;\nuse std::io::{Read, Write};\nuse std::net::TcpStream;\nlet connector = TlsConnector::new().unwrap();\nlet stream = TcpStream::connect(\"google.com:443\").unwrap();\nlet mut stream = connector.connect(\"google.com\", stream).unwrap();\nstream.write_all(b\"GET / HTTP/1.0\\r\\n\\r\\n\").unwrap();\nlet mut res = vec![];\nstream.read_to_end(&mut res).unwrap();\nprintln!(\"{}\", String::from_utf8_lossy(&res));\n```\n\nTo accept connections as a server from remote clients:\n```\nuse native_tls::{Identity, TlsAcceptor, TlsStream};\nuse std::fs::File;\nuse std::io::{Read};\nuse std::net::{TcpListener, TcpStream};\nuse std::sync::Arc;\nuse std::thread;\nlet mut file = File::open(\"identity.pfx\").unwrap();\nlet mut identity = vec![];\nfile.read_to_end(&mut identity).unwrap();\nlet identity = Identity::from_pkcs12(&identity, \"hunter2\").unwrap();\nlet listener = TcpListener::bind(\"0.0.0.0:8443\").unwrap();\nlet acceptor = TlsAcceptor::new(identity).unwrap();\nlet acceptor = Arc::new(acceptor);\nfn handle_client(stream: TlsStream<TcpStream>) {\n  // ...\n}\nfor stream in listener.incoming() {\n  match stream {\n    Ok(stream) => {\n      let acceptor = acceptor.clone();\n      thread::spawn(move || {\n        let stream = acceptor.accept(stream).unwrap();\n        handle_client(stream);\n      });\n    }\n    Err(e) => { /* connection failed */ }\n  }\n}\n```\n\n## Structs[\u00a7](https://docs.rs/native-tls/latest/native_tls/#structs)\n\n[Certificate](https://docs.rs/native-tls/latest/native_tls/struct.Certificate.html \"struct native_tls::Certificate\")\n    An X509 certificate.\n\n[Error](https://docs.rs/native-tls/latest/native_tls/struct.Error.html \"struct native_tls::Error\")\n    An error returned from the TLS implementation.\n\n[Identity](https://docs.rs/native-tls/latest/native_tls/struct.Identity.html \"struct native_tls::Identity\")\n    A cryptographic identity.\n\n[MidHandshakeTlsStream](https://docs.rs/native-tls/latest/native_tls/struct.MidHandshakeTlsStream.html \"struct native_tls::MidHandshakeTlsStream\")\n    A TLS stream which has been interrupted midway through the handshake process.\n\n[TlsAcceptor](https://docs.rs/native-tls/latest/native_tls/struct.TlsAcceptor.html \"struct native_tls::TlsAcceptor\")\n    A builder for server-side TLS connections.\n\n[TlsAcceptorBuilder](https://docs.rs/native-tls/latest/native_tls/struct.TlsAcceptorBuilder.html \"struct native_tls::TlsAcceptorBuilder\")\n    A builder for `TlsAcceptor`s.\n\n[TlsConnector](https://docs.rs/native-tls/latest/native_tls/struct.TlsConnector.html \"struct native_tls::TlsConnector\")\n    A builder for client-side TLS connections.\n\n[TlsConnectorBuilder](https://docs.rs/native-tls/latest/native_tls/struct.TlsConnectorBuilder.html \"struct native_tls::TlsConnectorBuilder\")\n    A builder for `TlsConnector`s.\n\n[TlsStream](https://docs.rs/native-tls/latest/native_tls/struct.TlsStream.html \"struct native_tls::TlsStream\")\n    A stream managing a TLS session.\n## Enums[\u00a7](https://docs.rs/native-tls/latest/native_tls/#enums)\n\n[HandshakeError](https://docs.rs/native-tls/latest/native_tls/enum.HandshakeError.html \"enum native_tls::HandshakeError\")\n    An error returned from `ClientBuilder::handshake`.\n\n[Protocol](https://docs.rs/native-tls/latest/native_tls/enum.Protocol.html \"enum native_tls::Protocol\")\n    SSL/TLS protocol versions.\n## Type Aliases[\u00a7](https://docs.rs/native-tls/latest/native_tls/#types)\n\n[Result](https://docs.rs/native-tls/latest/native_tls/type.Result.html \"type native_tls::Result\")\n    A typedef of the result-type returned by many methods.\n",
        "markdown_with_citations": "[](https://docs.rs/native-tls/latest/native_tls/all.html \"show sidebar\")\n# Crate native_tlsCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nAn abstraction over platform-specific TLS implementations.\nMany applications require TLS/SSL communication in one form or another as part of their implementation, but finding a library for this isn\u2019t always trivial! The purpose of this crate is to provide a seamless integration experience on all platforms with a cross-platform API that deals with all the underlying details for you.\n## \u00a7\u27e84\u27e9How is this implemented?\nThis crate uses SChannel on Windows (via the `schannel` crate), Secure Transport on OSX (via the `security-framework` crate), and OpenSSL (via the `openssl` crate) on all other platforms. Future features may also enable other TLS frameworks as well, but these initial libraries are likely to remain as the defaults.\nNote that this crate also strives to be secure-by-default. For example when using OpenSSL it will configure validation callbacks to ensure that hostnames match certificates, use strong ciphers, etc. This implies that this crate is _not_ just a thin abstraction around the underlying libraries, but also an implementation that strives to strike reasonable defaults.\n## \u00a7\u27e85\u27e9Supported features\nThis crate supports the following features out of the box:\n  * TLS/SSL client communication\n  * TLS/SSL server communication\n  * PKCS#12 encoded identities\n  * X.509/PKCS#8 encoded identities\n  * Secure-by-default for client and server \n    * Includes hostname verification for clients\n  * Supports asynchronous I/O for both the server and the client\n\n\n## \u00a7\u27e86\u27e9Cargo Features\n  * `vendored` - If enabled, the crate will compile and statically link to a vendored copy of OpenSSL. This feature has no effect on Windows and macOS, where OpenSSL is not used.\n\n\n## \u00a7\u27e87\u27e9Examples\nTo connect as a client to a remote server:\n```\nuse native_tls::TlsConnector;\nuse std::io::{Read, Write};\nuse std::net::TcpStream;\nlet connector = TlsConnector::new().unwrap();\nlet stream = TcpStream::connect(\"google.com:443\").unwrap();\nlet mut stream = connector.connect(\"google.com\", stream).unwrap();\nstream.write_all(b\"GET / HTTP/1.0\\r\\n\\r\\n\").unwrap();\nlet mut res = vec![];\nstream.read_to_end(&mut res).unwrap();\nprintln!(\"{}\", String::from_utf8_lossy(&res));\n```\n\nTo accept connections as a server from remote clients:\n```\nuse native_tls::{Identity, TlsAcceptor, TlsStream};\nuse std::fs::File;\nuse std::io::{Read};\nuse std::net::{TcpListener, TcpStream};\nuse std::sync::Arc;\nuse std::thread;\nlet mut file = File::open(\"identity.pfx\").unwrap();\nlet mut identity = vec![];\nfile.read_to_end(&mut identity).unwrap();\nlet identity = Identity::from_pkcs12(&identity, \"hunter2\").unwrap();\nlet listener = TcpListener::bind(\"0.0.0.0:8443\").unwrap();\nlet acceptor = TlsAcceptor::new(identity).unwrap();\nlet acceptor = Arc::new(acceptor);\nfn handle_client(stream: TlsStream<TcpStream>) {\n  // ...\n}\nfor stream in listener.incoming() {\n  match stream {\n    Ok(stream) => {\n      let acceptor = acceptor.clone();\n      thread::spawn(move || {\n        let stream = acceptor.accept(stream).unwrap();\n        handle_client(stream);\n      });\n    }\n    Err(e) => { /* connection failed */ }\n  }\n}\n```\n\n## Structs\u00a7\u27e88\u27e9\n\nCertificate\u27e89\u27e9\n    An X509 certificate.\n\nError\u27e810\u27e9\n    An error returned from the TLS implementation.\n\nIdentity\u27e811\u27e9\n    A cryptographic identity.\n\nMidHandshakeTlsStream\u27e812\u27e9\n    A TLS stream which has been interrupted midway through the handshake process.\n\nTlsAcceptor\u27e813\u27e9\n    A builder for server-side TLS connections.\n\nTlsAcceptorBuilder\u27e814\u27e9\n    A builder for `TlsAcceptor`s.\n\nTlsConnector\u27e815\u27e9\n    A builder for client-side TLS connections.\n\nTlsConnectorBuilder\u27e816\u27e9\n    A builder for `TlsConnector`s.\n\nTlsStream\u27e817\u27e9\n    A stream managing a TLS session.\n## Enums\u00a7\u27e818\u27e9\n\nHandshakeError\u27e819\u27e9\n    An error returned from `ClientBuilder::handshake`.\n\nProtocol\u27e820\u27e9\n    SSL/TLS protocol versions.\n## Type Aliases\u00a7\u27e821\u27e9\n\nResult\u27e822\u27e9\n    A typedef of the result-type returned by many methods.\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/native-tls/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/native-tls/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/native-tls/latest/src/native_tls/lib.rs.html#1-719: Source\n\u27e84\u27e9 https://docs.rs/native-tls/latest/native_tls/#how-is-this-implemented: \u00a7\n\u27e85\u27e9 https://docs.rs/native-tls/latest/native_tls/#supported-features: \u00a7\n\u27e86\u27e9 https://docs.rs/native-tls/latest/native_tls/#cargo-features: \u00a7\n\u27e87\u27e9 https://docs.rs/native-tls/latest/native_tls/#examples: \u00a7\n\u27e88\u27e9 https://docs.rs/native-tls/latest/native_tls/#structs: \u00a7\n\u27e89\u27e9 https://docs.rs/native-tls/latest/native_tls/struct.Certificate.html: struct native_tls::Certificate - Certificate\n\u27e810\u27e9 https://docs.rs/native-tls/latest/native_tls/struct.Error.html: struct native_tls::Error - Error\n\u27e811\u27e9 https://docs.rs/native-tls/latest/native_tls/struct.Identity.html: struct native_tls::Identity - Identity\n\u27e812\u27e9 https://docs.rs/native-tls/latest/native_tls/struct.MidHandshakeTlsStream.html: struct native_tls::MidHandshakeTlsStream - MidHandshakeTlsStream\n\u27e813\u27e9 https://docs.rs/native-tls/latest/native_tls/struct.TlsAcceptor.html: struct native_tls::TlsAcceptor - TlsAcceptor\n\u27e814\u27e9 https://docs.rs/native-tls/latest/native_tls/struct.TlsAcceptorBuilder.html: struct native_tls::TlsAcceptorBuilder - TlsAcceptorBuilder\n\u27e815\u27e9 https://docs.rs/native-tls/latest/native_tls/struct.TlsConnector.html: struct native_tls::TlsConnector - TlsConnector\n\u27e816\u27e9 https://docs.rs/native-tls/latest/native_tls/struct.TlsConnectorBuilder.html: struct native_tls::TlsConnectorBuilder - TlsConnectorBuilder\n\u27e817\u27e9 https://docs.rs/native-tls/latest/native_tls/struct.TlsStream.html: struct native_tls::TlsStream - TlsStream\n\u27e818\u27e9 https://docs.rs/native-tls/latest/native_tls/#enums: \u00a7\n\u27e819\u27e9 https://docs.rs/native-tls/latest/native_tls/enum.HandshakeError.html: enum native_tls::HandshakeError - HandshakeError\n\u27e820\u27e9 https://docs.rs/native-tls/latest/native_tls/enum.Protocol.html: enum native_tls::Protocol - Protocol\n\u27e821\u27e9 https://docs.rs/native-tls/latest/native_tls/#types: \u00a7\n\u27e822\u27e9 https://docs.rs/native-tls/latest/native_tls/type.Result.html: type native_tls::Result - Result\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `native-tls` crate provides a cross-platform abstraction for TLS/SSL communication, leveraging platform-specific implementations like SChannel (Windows), Secure Transport (macOS), and OpenSSL (other platforms). It supports secure-by-default client and server communication, PKCS#12 and X.509 identities, hostname verification, and asynchronous I/O. Additionally, it offers a `vendored` feature for statically linking OpenSSL on non-Windows/macOS systems.",
    "feature_summary": null,
    "use_case": "Networking",
    "score": 7.0,
    "factual_counterfactual": "### Pair 1: Platform-Specific Implementations  \n\u2705 **Factual:** The `native-tls` crate uses SChannel on Windows, Secure Transport on macOS, and OpenSSL on other platforms to provide TLS functionality.  \n\u274c **Counterfactual:** The `native-tls` crate exclusively uses OpenSSL for TLS functionality across all platforms, including Windows and macOS.\n\n---\n\n### Pair 2: Secure Defaults  \n\u2705 **Factual:** The `native-tls` crate is secure-by-default, ensuring hostname verification and strong cipher suites when using OpenSSL.  \n\u274c **Counterfactual:** The `native-tls` crate requires manual configuration for hostname verification and cipher suite selection, as it does not provide secure defaults.\n\n---\n\n### Pair 3: Asynchronous I/O Support  \n\u2705 **Factual:** The `native-tls` crate supports asynchronous I/O for both TLS clients and servers, making it suitable for non-blocking applications.  \n\u274c **Counterfactual:** The `native-tls` crate only supports synchronous I/O and does not provide features for asynchronous communication.",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}