{
    "name": "calloop",
    "version": "0.14.2",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/calloop/latest/calloop/all.html \"show sidebar\")\n# Crate calloopCopy item path\n[Settings](https://docs.rs/calloop/latest/settings.html)\n[Help](https://docs.rs/calloop/latest/help.html)\nSummary[Source](https://docs.rs/calloop/latest/src/calloop/lib.rs.html#1-163)\nExpand description\nCalloop, a Callback-based Event Loop\nThis crate provides an [`EventLoop`](https://docs.rs/calloop/latest/calloop/struct.EventLoop.html \"struct calloop::EventLoop\") type, which is a small abstraction over a polling system. The main difference between this crate and other traditional rust event loops is that it is based on callbacks: you can register several event sources, each being associated with a callback closure that will be invoked whenever the associated event source generates events.\nThe main target use of this event loop is thus for apps that expect to spend most of their time waiting for events and wishes to do so in a cheap and convenient way. It is not meant for large scale high performance IO.\n### [\u00a7](https://docs.rs/calloop/latest/calloop/#how-to-use-it)How to use it\nBelow is a quick usage example of calloop. For a more in-depth tutorial, see the [calloop book](https://smithay.github.io/calloop).\nFor simple uses, you can just add event sources with callbacks to the event loop. For example, here\u2019s a runnable program that exits after five seconds:\n```\nuse calloop::{timer::{Timer, TimeoutAction}, EventLoop, LoopSignal};\nfn main() {\n  // Create the event loop. The loop is parameterised by the kind of shared\n  // data you want the callbacks to use. In this case, we want to be able to\n  // stop the loop when the timer fires, so we provide the loop with a\n  // LoopSignal, which has the ability to stop the loop from within events. We\n  // just annotate the type here; the actual data is provided later in the\n  // run() call.\n  let mut event_loop: EventLoop<LoopSignal> =\n    EventLoop::try_new().expect(\"Failed to initialize the event loop!\");\n  // Retrieve a handle. It is used to insert new sources into the event loop\n  // It can be cloned, allowing you to insert sources from within source\n  // callbacks.\n  let handle = event_loop.handle();\n  // Create our event source, a timer, that will expire in 2 seconds\n  let source = Timer::from_duration(std::time::Duration::from_secs(2));\n  // Inserting an event source takes this general form. It can also be done\n  // from within the callback of another event source.\n  handle\n    .insert_source(\n      // a type which implements the EventSource trait\n      source,\n      // a callback that is invoked whenever this source generates an event\n      |event, _metadata, shared_data| {\n        // This callback is given 3 values:\n        // - the event generated by the source (in our case, timer events are the Instant\n        //  representing the deadline for which it has fired)\n        // - &mut access to some metadata, specific to the event source (in our case, a\n        //  timer handle)\n        // - &mut access to the global shared data that was passed to EventLoop::run or\n        //  EventLoop::dispatch (in our case, a LoopSignal object to stop the loop)\n        //\n        // The return type is just () because nothing uses it. Some\n        // sources will expect a Result of some kind instead.\n        println!(\"Timeout for {:?} expired!\", event);\n        // notify the event loop to stop running using the signal in the shared data\n        // (see below)\n        shared_data.stop();\n        // The timer event source requires us to return a TimeoutAction to\n        // specify if the timer should be rescheduled. In our case we just drop it.\n        TimeoutAction::Drop\n      },\n    )\n    .expect(\"Failed to insert event source!\");\n  // Create the shared data for our loop.\n  let mut shared_data = event_loop.get_signal();\n  // Actually run the event loop. This will dispatch received events to their\n  // callbacks, waiting at most 20ms for new events between each invocation of\n  // the provided callback (pass None for the timeout argument if you want to\n  // wait indefinitely between events).\n  //\n  // This is where we pass the *value* of the shared data, as a mutable\n  // reference that will be forwarded to all your callbacks, allowing them to\n  // share some state\n  event_loop\n    .run(\n      std::time::Duration::from_millis(20),\n      &mut shared_data,\n      |_shared_data| {\n        // Finally, this is where you can insert the processing you need\n        // to do do between each waiting event eg. drawing logic if\n        // you're doing a GUI app.\n      },\n    )\n    .expect(\"Error during event loop!\");\n}\n```\n\n### [\u00a7](https://docs.rs/calloop/latest/calloop/#event-source-types)Event source types\nThe event loop is backed by an OS provided polling selector (epoll on Linux).\nThis crate also provide some adapters for common event sources such as:\n  * [MPSC channels](https://docs.rs/calloop/latest/calloop/channel/index.html \"mod calloop::channel\")\n  * [Timers](https://docs.rs/calloop/latest/calloop/timer/index.html \"mod calloop::timer\")\n  * [unix signals](https://docs.rs/calloop/latest/calloop/signals/index.html \"mod calloop::signals\") on Linux\n\n\nAs well as generic objects backed by file descriptors.\nIt is also possible to insert \u201cidle\u201d callbacks. These callbacks represent computations that need to be done at some point, but are not as urgent as processing the events. These callbacks are stored and then executed during [`EventLoop::dispatch`](https://docs.rs/calloop/latest/calloop/struct.EventLoop.html#method.dispatch \"struct calloop::EventLoop\"), once all events from the sources have been processed.\n### [\u00a7](https://docs.rs/calloop/latest/calloop/#asyncawait-compatibility)Async/Await compatibility\n`calloop` can be used with futures, both as an executor and for monitoring Async IO.\nActivating the `executor` cargo feature will add the [`futures`](https://docs.rs/calloop/latest/calloop/futures/index.html \"mod calloop::futures\") module, which provides a future executor that can be inserted into an [`EventLoop`](https://docs.rs/calloop/latest/calloop/struct.EventLoop.html \"struct calloop::EventLoop\") as yet another [`EventSource`](https://docs.rs/calloop/latest/calloop/trait.EventSource.html \"trait calloop::EventSource\").\nIO objects can be made Async-aware via the [`LoopHandle::adapt_io`](https://docs.rs/calloop/latest/calloop/struct.LoopHandle.html#method.adapt_io \"struct calloop::LoopHandle\") method. Waking up the futures using these objects is handled by the associated [`EventLoop`](https://docs.rs/calloop/latest/calloop/struct.EventLoop.html \"struct calloop::EventLoop\") directly.\n### [\u00a7](https://docs.rs/calloop/latest/calloop/#custom-event-sources)Custom event sources\nYou can create custom event sources can will be inserted in the event loop by implementing the [`EventSource`](https://docs.rs/calloop/latest/calloop/trait.EventSource.html \"trait calloop::EventSource\") trait. This can be done either directly from the file descriptors of your source of interest, or by wrapping an other event source and further processing its events. An [`EventSource`](https://docs.rs/calloop/latest/calloop/trait.EventSource.html \"trait calloop::EventSource\") can register more than one file descriptor and aggregate them.\n### [\u00a7](https://docs.rs/calloop/latest/calloop/#platforms-support)Platforms support\nCurrently, calloop is tested on Linux, FreeBSD and macOS.\nThe following platforms are also enabled at compile time but not tested: Android, NetBSD, OpenBSD, DragonFlyBSD.\nThose platforms _should_ work based on the fact that they have the same polling mechanism as tested platforms, but some subtle bugs might still occur.\n## Re-exports[\u00a7](https://docs.rs/calloop/latest/calloop/#reexports)\n\n`pub use error::Error[](https://docs.rs/calloop/latest/calloop/error/enum.Error.html \"enum calloop::error::Error\");`\n\n\n`pub use error::InsertError[](https://docs.rs/calloop/latest/calloop/error/struct.InsertError.html \"struct calloop::error::InsertError\");`\n\n\n`pub use error::Result[](https://docs.rs/calloop/latest/calloop/error/type.Result.html \"type calloop::error::Result\");`\n\n## Modules[\u00a7](https://docs.rs/calloop/latest/calloop/#modules)\n\n[channel](https://docs.rs/calloop/latest/calloop/channel/index.html \"mod calloop::channel\")\n    An MPSC channel whose receiving end is an event source\n\n[error](https://docs.rs/calloop/latest/calloop/error/index.html \"mod calloop::error\")\n    Error types used and generated by Calloop.\n\n[futures](https://docs.rs/calloop/latest/calloop/futures/index.html \"mod calloop::futures\")`executor`\n    A futures executor as an event source\n\n[generic](https://docs.rs/calloop/latest/calloop/generic/index.html \"mod calloop::generic\")\n    A generic event source wrapping an IO objects or file descriptor\n\n[io](https://docs.rs/calloop/latest/calloop/io/index.html \"mod calloop::io\")\n    Adapters for async IO objects\n\n[ping](https://docs.rs/calloop/latest/calloop/ping/index.html \"mod calloop::ping\")\n    Ping to the event loop\n\n[signals](https://docs.rs/calloop/latest/calloop/signals/index.html \"mod calloop::signals\")Linux\n    Event source for tracking Unix signals\n\n[timer](https://docs.rs/calloop/latest/calloop/timer/index.html \"mod calloop::timer\")\n    Timer event source\n\n[transient](https://docs.rs/calloop/latest/calloop/transient/index.html \"mod calloop::transient\")\n    Wrapper for a transient Calloop event source.\n## Macros[\u00a7](https://docs.rs/calloop/latest/calloop/#macros)\n\n[batch_register](https://docs.rs/calloop/latest/calloop/macro.batch_register.html \"macro calloop::batch_register\")\n    Register a set of event sources. Effectively calls [`EventSource::register()`](https://docs.rs/calloop/latest/calloop/trait.EventSource.html#tymethod.register \"method calloop::EventSource::register\") for all the sources provided.\n\n[batch_reregister](https://docs.rs/calloop/latest/calloop/macro.batch_reregister.html \"macro calloop::batch_reregister\")\n    Reregister a set of event sources. Effectively calls [`EventSource::reregister()`](https://docs.rs/calloop/latest/calloop/trait.EventSource.html#tymethod.reregister \"method calloop::EventSource::reregister\") for all the sources provided.\n\n[batch_unregister](https://docs.rs/calloop/latest/calloop/macro.batch_unregister.html \"macro calloop::batch_unregister\")\n    Unregister a set of event sources. Effectively calls [`EventSource::unregister()`](https://docs.rs/calloop/latest/calloop/trait.EventSource.html#tymethod.unregister \"method calloop::EventSource::unregister\") for all the sources provided.\n## Structs[\u00a7](https://docs.rs/calloop/latest/calloop/#structs)\n\n[Dispatcher](https://docs.rs/calloop/latest/calloop/struct.Dispatcher.html \"struct calloop::Dispatcher\")\n    An event source with its callback.\n\n[EventIterator](https://docs.rs/calloop/latest/calloop/struct.EventIterator.html \"struct calloop::EventIterator\")\n    The EventIterator is an `Iterator` over the events relevant to a particular source This type is used in the [`EventSource::before_handle_events`](https://docs.rs/calloop/latest/calloop/trait.EventSource.html#method.before_handle_events \"method calloop::EventSource::before_handle_events\") methods for two main reasons:\n\n[EventLoop](https://docs.rs/calloop/latest/calloop/struct.EventLoop.html \"struct calloop::EventLoop\")\n    An event loop\n\n[Idle](https://docs.rs/calloop/latest/calloop/struct.Idle.html \"struct calloop::Idle\")\n    An idle callback that was inserted in this loop\n\n[Interest](https://docs.rs/calloop/latest/calloop/struct.Interest.html \"struct calloop::Interest\")\n    Interest to register regarding the file descriptor\n\n[LoopHandle](https://docs.rs/calloop/latest/calloop/struct.LoopHandle.html \"struct calloop::LoopHandle\")\n    An handle to an event loop\n\n[LoopSignal](https://docs.rs/calloop/latest/calloop/struct.LoopSignal.html \"struct calloop::LoopSignal\")\n    A signal that can be shared between thread to stop or wakeup a running event loop\n\n[Poll](https://docs.rs/calloop/latest/calloop/struct.Poll.html \"struct calloop::Poll\")\n    The polling system\n\n[Readiness](https://docs.rs/calloop/latest/calloop/struct.Readiness.html \"struct calloop::Readiness\")\n    Readiness for a file descriptor notification\n\n[RegistrationToken](https://docs.rs/calloop/latest/calloop/struct.RegistrationToken.html \"struct calloop::RegistrationToken\")\n    A token representing a registration in the [`EventLoop`](https://docs.rs/calloop/latest/calloop/struct.EventLoop.html \"struct calloop::EventLoop\").\n\n[Token](https://docs.rs/calloop/latest/calloop/struct.Token.html \"struct calloop::Token\")\n    A token (for implementation of the [`EventSource`](https://docs.rs/calloop/latest/calloop/trait.EventSource.html \"trait calloop::EventSource\") trait)\n\n[TokenFactory](https://docs.rs/calloop/latest/calloop/struct.TokenFactory.html \"struct calloop::TokenFactory\")\n    Factory for creating tokens in your registrations\n## Enums[\u00a7](https://docs.rs/calloop/latest/calloop/#enums)\n\n[Mode](https://docs.rs/calloop/latest/calloop/enum.Mode.html \"enum calloop::Mode\")\n    Possible modes for registering a file descriptor\n\n[PostAction](https://docs.rs/calloop/latest/calloop/enum.PostAction.html \"enum calloop::PostAction\")\n    Possible actions that can be requested to the event loop by an event source once its events have been processed.\n## Traits[\u00a7](https://docs.rs/calloop/latest/calloop/#traits)\n\n[EventSource](https://docs.rs/calloop/latest/calloop/trait.EventSource.html \"trait calloop::EventSource\")\n    Trait representing an event source\n",
        "markdown_with_citations": "[](https://docs.rs/calloop/latest/calloop/all.html \"show sidebar\")\n# Crate calloopCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nCalloop, a Callback-based Event Loop\nThis crate provides an `EventLoop`\u27e84\u27e9 type, which is a small abstraction over a polling system. The main difference between this crate and other traditional rust event loops is that it is based on callbacks: you can register several event sources, each being associated with a callback closure that will be invoked whenever the associated event source generates events.\nThe main target use of this event loop is thus for apps that expect to spend most of their time waiting for events and wishes to do so in a cheap and convenient way. It is not meant for large scale high performance IO.\n### \u00a7\u27e85\u27e9How to use it\nBelow is a quick usage example of calloop. For a more in-depth tutorial, see the calloop book\u27e86\u27e9.\nFor simple uses, you can just add event sources with callbacks to the event loop. For example, here\u2019s a runnable program that exits after five seconds:\n```\nuse calloop::{timer::{Timer, TimeoutAction}, EventLoop, LoopSignal};\nfn main() {\n  // Create the event loop. The loop is parameterised by the kind of shared\n  // data you want the callbacks to use. In this case, we want to be able to\n  // stop the loop when the timer fires, so we provide the loop with a\n  // LoopSignal, which has the ability to stop the loop from within events. We\n  // just annotate the type here; the actual data is provided later in the\n  // run() call.\n  let mut event_loop: EventLoop<LoopSignal> =\n    EventLoop::try_new().expect(\"Failed to initialize the event loop!\");\n  // Retrieve a handle. It is used to insert new sources into the event loop\n  // It can be cloned, allowing you to insert sources from within source\n  // callbacks.\n  let handle = event_loop.handle();\n  // Create our event source, a timer, that will expire in 2 seconds\n  let source = Timer::from_duration(std::time::Duration::from_secs(2));\n  // Inserting an event source takes this general form. It can also be done\n  // from within the callback of another event source.\n  handle\n    .insert_source(\n      // a type which implements the EventSource trait\n      source,\n      // a callback that is invoked whenever this source generates an event\n      |event, _metadata, shared_data| {\n        // This callback is given 3 values:\n        // - the event generated by the source (in our case, timer events are the Instant\n        //  representing the deadline for which it has fired)\n        // - &mut access to some metadata, specific to the event source (in our case, a\n        //  timer handle)\n        // - &mut access to the global shared data that was passed to EventLoop::run or\n        //  EventLoop::dispatch (in our case, a LoopSignal object to stop the loop)\n        //\n        // The return type is just () because nothing uses it. Some\n        // sources will expect a Result of some kind instead.\n        println!(\"Timeout for {:?} expired!\", event);\n        // notify the event loop to stop running using the signal in the shared data\n        // (see below)\n        shared_data.stop();\n        // The timer event source requires us to return a TimeoutAction to\n        // specify if the timer should be rescheduled. In our case we just drop it.\n        TimeoutAction::Drop\n      },\n    )\n    .expect(\"Failed to insert event source!\");\n  // Create the shared data for our loop.\n  let mut shared_data = event_loop.get_signal();\n  // Actually run the event loop. This will dispatch received events to their\n  // callbacks, waiting at most 20ms for new events between each invocation of\n  // the provided callback (pass None for the timeout argument if you want to\n  // wait indefinitely between events).\n  //\n  // This is where we pass the *value* of the shared data, as a mutable\n  // reference that will be forwarded to all your callbacks, allowing them to\n  // share some state\n  event_loop\n    .run(\n      std::time::Duration::from_millis(20),\n      &mut shared_data,\n      |_shared_data| {\n        // Finally, this is where you can insert the processing you need\n        // to do do between each waiting event eg. drawing logic if\n        // you're doing a GUI app.\n      },\n    )\n    .expect(\"Error during event loop!\");\n}\n```\n\n### \u00a7\u27e87\u27e9Event source types\nThe event loop is backed by an OS provided polling selector (epoll on Linux).\nThis crate also provide some adapters for common event sources such as:\n  * MPSC channels\u27e88\u27e9\n  * Timers\u27e89\u27e9\n  * unix signals\u27e810\u27e9 on Linux\n\n\nAs well as generic objects backed by file descriptors.\nIt is also possible to insert \u201cidle\u201d callbacks. These callbacks represent computations that need to be done at some point, but are not as urgent as processing the events. These callbacks are stored and then executed during `EventLoop::dispatch`\u27e811\u27e9, once all events from the sources have been processed.\n### \u00a7\u27e812\u27e9Async/Await compatibility\n`calloop` can be used with futures, both as an executor and for monitoring Async IO.\nActivating the `executor` cargo feature will add the `futures`\u27e813\u27e9 module, which provides a future executor that can be inserted into an `EventLoop`\u27e84\u27e9 as yet another `EventSource`\u27e814\u27e9.\nIO objects can be made Async-aware via the `LoopHandle::adapt_io`\u27e815\u27e9 method. Waking up the futures using these objects is handled by the associated `EventLoop`\u27e84\u27e9 directly.\n### \u00a7\u27e816\u27e9Custom event sources\nYou can create custom event sources can will be inserted in the event loop by implementing the `EventSource`\u27e814\u27e9 trait. This can be done either directly from the file descriptors of your source of interest, or by wrapping an other event source and further processing its events. An `EventSource`\u27e814\u27e9 can register more than one file descriptor and aggregate them.\n### \u00a7\u27e817\u27e9Platforms support\nCurrently, calloop is tested on Linux, FreeBSD and macOS.\nThe following platforms are also enabled at compile time but not tested: Android, NetBSD, OpenBSD, DragonFlyBSD.\nThose platforms _should_ work based on the fact that they have the same polling mechanism as tested platforms, but some subtle bugs might still occur.\n## Re-exports\u00a7\u27e818\u27e9\n\n`pub use error::Error[](https://docs.rs/calloop/latest/calloop/error/enum.Error.html \"enum calloop::error::Error\");`\n\n\n`pub use error::InsertError[](https://docs.rs/calloop/latest/calloop/error/struct.InsertError.html \"struct calloop::error::InsertError\");`\n\n\n`pub use error::Result[](https://docs.rs/calloop/latest/calloop/error/type.Result.html \"type calloop::error::Result\");`\n\n## Modules\u00a7\u27e819\u27e9\n\nchannel\u27e88\u27e9\n    An MPSC channel whose receiving end is an event source\n\nerror\u27e820\u27e9\n    Error types used and generated by Calloop.\n\nfutures\u27e813\u27e9`executor`\n    A futures executor as an event source\n\ngeneric\u27e821\u27e9\n    A generic event source wrapping an IO objects or file descriptor\n\nio\u27e822\u27e9\n    Adapters for async IO objects\n\nping\u27e823\u27e9\n    Ping to the event loop\n\nsignals\u27e810\u27e9Linux\n    Event source for tracking Unix signals\n\ntimer\u27e89\u27e9\n    Timer event source\n\ntransient\u27e824\u27e9\n    Wrapper for a transient Calloop event source.\n## Macros\u00a7\u27e825\u27e9\n\nbatch_register\u27e826\u27e9\n    Register a set of event sources. Effectively calls `EventSource::register()`\u27e827\u27e9 for all the sources provided.\n\nbatch_reregister\u27e828\u27e9\n    Reregister a set of event sources. Effectively calls `EventSource::reregister()`\u27e829\u27e9 for all the sources provided.\n\nbatch_unregister\u27e830\u27e9\n    Unregister a set of event sources. Effectively calls `EventSource::unregister()`\u27e831\u27e9 for all the sources provided.\n## Structs\u00a7\u27e832\u27e9\n\nDispatcher\u27e833\u27e9\n    An event source with its callback.\n\nEventIterator\u27e834\u27e9\n    The EventIterator is an `Iterator` over the events relevant to a particular source This type is used in the `EventSource::before_handle_events`\u27e835\u27e9 methods for two main reasons:\n\nEventLoop\u27e84\u27e9\n    An event loop\n\nIdle\u27e836\u27e9\n    An idle callback that was inserted in this loop\n\nInterest\u27e837\u27e9\n    Interest to register regarding the file descriptor\n\nLoopHandle\u27e838\u27e9\n    An handle to an event loop\n\nLoopSignal\u27e839\u27e9\n    A signal that can be shared between thread to stop or wakeup a running event loop\n\nPoll\u27e840\u27e9\n    The polling system\n\nReadiness\u27e841\u27e9\n    Readiness for a file descriptor notification\n\nRegistrationToken\u27e842\u27e9\n    A token representing a registration in the `EventLoop`\u27e84\u27e9.\n\nToken\u27e843\u27e9\n    A token (for implementation of the `EventSource`\u27e814\u27e9 trait)\n\nTokenFactory\u27e844\u27e9\n    Factory for creating tokens in your registrations\n## Enums\u00a7\u27e845\u27e9\n\nMode\u27e846\u27e9\n    Possible modes for registering a file descriptor\n\nPostAction\u27e847\u27e9\n    Possible actions that can be requested to the event loop by an event source once its events have been processed.\n## Traits\u00a7\u27e848\u27e9\n\nEventSource\u27e814\u27e9\n    Trait representing an event source\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/calloop/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/calloop/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/calloop/latest/src/calloop/lib.rs.html#1-163: Source\n\u27e84\u27e9 https://docs.rs/calloop/latest/calloop/struct.EventLoop.html: struct calloop::EventLoop - `EventLoop`\n\u27e85\u27e9 https://docs.rs/calloop/latest/calloop/#how-to-use-it: \u00a7\n\u27e86\u27e9 https://smithay.github.io/calloop: calloop book\n\u27e87\u27e9 https://docs.rs/calloop/latest/calloop/#event-source-types: \u00a7\n\u27e88\u27e9 https://docs.rs/calloop/latest/calloop/channel/index.html: mod calloop::channel - MPSC channels\n\u27e89\u27e9 https://docs.rs/calloop/latest/calloop/timer/index.html: mod calloop::timer - Timers\n\u27e810\u27e9 https://docs.rs/calloop/latest/calloop/signals/index.html: mod calloop::signals - unix signals\n\u27e811\u27e9 https://docs.rs/calloop/latest/calloop/struct.EventLoop.html#method.dispatch: struct calloop::EventLoop - `EventLoop::dispatch`\n\u27e812\u27e9 https://docs.rs/calloop/latest/calloop/#asyncawait-compatibility: \u00a7\n\u27e813\u27e9 https://docs.rs/calloop/latest/calloop/futures/index.html: mod calloop::futures - `futures`\n\u27e814\u27e9 https://docs.rs/calloop/latest/calloop/trait.EventSource.html: trait calloop::EventSource - `EventSource`\n\u27e815\u27e9 https://docs.rs/calloop/latest/calloop/struct.LoopHandle.html#method.adapt_io: struct calloop::LoopHandle - `LoopHandle::adapt_io`\n\u27e816\u27e9 https://docs.rs/calloop/latest/calloop/#custom-event-sources: \u00a7\n\u27e817\u27e9 https://docs.rs/calloop/latest/calloop/#platforms-support: \u00a7\n\u27e818\u27e9 https://docs.rs/calloop/latest/calloop/#reexports: \u00a7\n\u27e819\u27e9 https://docs.rs/calloop/latest/calloop/#modules: \u00a7\n\u27e820\u27e9 https://docs.rs/calloop/latest/calloop/error/index.html: mod calloop::error - error\n\u27e821\u27e9 https://docs.rs/calloop/latest/calloop/generic/index.html: mod calloop::generic - generic\n\u27e822\u27e9 https://docs.rs/calloop/latest/calloop/io/index.html: mod calloop::io - io\n\u27e823\u27e9 https://docs.rs/calloop/latest/calloop/ping/index.html: mod calloop::ping - ping\n\u27e824\u27e9 https://docs.rs/calloop/latest/calloop/transient/index.html: mod calloop::transient - transient\n\u27e825\u27e9 https://docs.rs/calloop/latest/calloop/#macros: \u00a7\n\u27e826\u27e9 https://docs.rs/calloop/latest/calloop/macro.batch_register.html: macro calloop::batch_register - batch_register\n\u27e827\u27e9 https://docs.rs/calloop/latest/calloop/trait.EventSource.html#tymethod.register: method calloop::EventSource::register - `EventSource::register()`\n\u27e828\u27e9 https://docs.rs/calloop/latest/calloop/macro.batch_reregister.html: macro calloop::batch_reregister - batch_reregister\n\u27e829\u27e9 https://docs.rs/calloop/latest/calloop/trait.EventSource.html#tymethod.reregister: method calloop::EventSource::reregister - `EventSource::reregister()`\n\u27e830\u27e9 https://docs.rs/calloop/latest/calloop/macro.batch_unregister.html: macro calloop::batch_unregister - batch_unregister\n\u27e831\u27e9 https://docs.rs/calloop/latest/calloop/trait.EventSource.html#tymethod.unregister: method calloop::EventSource::unregister - `EventSource::unregister()`\n\u27e832\u27e9 https://docs.rs/calloop/latest/calloop/#structs: \u00a7\n\u27e833\u27e9 https://docs.rs/calloop/latest/calloop/struct.Dispatcher.html: struct calloop::Dispatcher - Dispatcher\n\u27e834\u27e9 https://docs.rs/calloop/latest/calloop/struct.EventIterator.html: struct calloop::EventIterator - EventIterator\n\u27e835\u27e9 https://docs.rs/calloop/latest/calloop/trait.EventSource.html#method.before_handle_events: method calloop::EventSource::before_handle_events - `EventSource::before_handle_events`\n\u27e836\u27e9 https://docs.rs/calloop/latest/calloop/struct.Idle.html: struct calloop::Idle - Idle\n\u27e837\u27e9 https://docs.rs/calloop/latest/calloop/struct.Interest.html: struct calloop::Interest - Interest\n\u27e838\u27e9 https://docs.rs/calloop/latest/calloop/struct.LoopHandle.html: struct calloop::LoopHandle - LoopHandle\n\u27e839\u27e9 https://docs.rs/calloop/latest/calloop/struct.LoopSignal.html: struct calloop::LoopSignal - LoopSignal\n\u27e840\u27e9 https://docs.rs/calloop/latest/calloop/struct.Poll.html: struct calloop::Poll - Poll\n\u27e841\u27e9 https://docs.rs/calloop/latest/calloop/struct.Readiness.html: struct calloop::Readiness - Readiness\n\u27e842\u27e9 https://docs.rs/calloop/latest/calloop/struct.RegistrationToken.html: struct calloop::RegistrationToken - RegistrationToken\n\u27e843\u27e9 https://docs.rs/calloop/latest/calloop/struct.Token.html: struct calloop::Token - Token\n\u27e844\u27e9 https://docs.rs/calloop/latest/calloop/struct.TokenFactory.html: struct calloop::TokenFactory - TokenFactory\n\u27e845\u27e9 https://docs.rs/calloop/latest/calloop/#enums: \u00a7\n\u27e846\u27e9 https://docs.rs/calloop/latest/calloop/enum.Mode.html: enum calloop::Mode - Mode\n\u27e847\u27e9 https://docs.rs/calloop/latest/calloop/enum.PostAction.html: enum calloop::PostAction - PostAction\n\u27e848\u27e9 https://docs.rs/calloop/latest/calloop/#traits: \u00a7\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `calloop` crate provides a callback-based event loop abstraction over OS polling systems, such as epoll on Linux, enabling efficient event-driven programming. It supports various event sources, including timers, MPSC channels, Unix signals, and custom sources, with optional async/await compatibility via a futures executor. Designed for lightweight applications, it allows idle callbacks and is compatible with multiple platforms, including Linux, FreeBSD, and macOS.",
    "feature_summary": null,
    "use_case": "Utilities",
    "score": 6.5,
    "factual_counterfactual": "### Pair 1: Callback-based Event Handling  \n\u2705 Factual: `calloop` provides a callback-based event loop, allowing developers to register multiple event sources, each associated with a closure invoked when events occur.  \n\u274c Counterfactual: `calloop` exclusively supports synchronous event handling and does not allow asynchronous callbacks or futures integration.  \n\n---\n\n### Pair 2: Platform Support  \n\u2705 Factual: `calloop` is tested on Linux, FreeBSD, and macOS, and supports additional platforms like Android, NetBSD, and OpenBSD, though these are not officially tested.  \n\u274c Counterfactual: `calloop` is only compatible with Linux systems and cannot be used on macOS or BSD-based operating systems.  \n\n---\n\n### Pair 3: High-Performance IO  \n\u2705 Factual: `calloop` is designed for applications that spend most of their time waiting for events, but it is not intended for large-scale, high-performance IO tasks.  \n\u274c Counterfactual: `calloop` is optimized for high-throughput IO operations, making it ideal for performance-critical applications like web servers.",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}