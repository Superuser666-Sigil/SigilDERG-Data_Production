{
    "name": "secp256k1",
    "version": "0.31.1",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/secp256k1/latest/secp256k1/all.html \"show sidebar\")\n# Crate secp256k1Copy item path\n[Settings](https://docs.rs/secp256k1/latest/settings.html)\n[Help](https://docs.rs/secp256k1/latest/help.html)\nSummary[Source](https://docs.rs/secp256k1/latest/src/secp256k1/lib.rs.html#3-1052)\nExpand description\nRust bindings for Pieter Wuille\u2019s secp256k1 library, which is used for fast and accurate manipulation of ECDSA and Schnorr signatures on the secp256k1 curve. Such signatures are used extensively by the Bitcoin network and its derivatives.\nTo minimize dependencies, some functions are feature-gated. To generate random keys or to re-randomize a context object, compile with the `rand` and `std` features. If you are willing to use these features, we have enabled an additional defense-in-depth sidechannel protection for our context objects, which re-blinds certain operations on secret key data. To de/serialize objects with serde, compile with \u201cserde\u201d. **Important** : `serde` encoding is **not** the same as consensus encoding!\nWhere possible, the bindings use the Rust type system to ensure that API usage errors are impossible. For example, the library uses context objects that contain precomputation tables which are created on object construction. Since this is a slow operation (10+ milliseconds, vs ~50 microseconds for typical crypto operations, on a 2.70 Ghz i7-6820HQ) the tables are optional, giving a performance boost for users who only care about signing, only care about verification, or only care about parsing. In the upstream library, if you attempt to sign a message using a context that does not support this, it will trigger an assertion failure and terminate the program. In `rust-secp256k1`, this is caught at compile-time; in fact, it is impossible to compile code that will trigger any assertion failures in the upstream library.\n```\nuse secp256k1::rand;\nuse secp256k1::{Secp256k1, Message};\nuse secp256k1::hashes::{sha256, Hash};\nlet secp = Secp256k1::new();\nlet (secret_key, public_key) = secp.generate_keypair(&mut rand::rng());\nlet digest = sha256::Hash::hash(\"Hello World!\".as_bytes());\nlet message = Message::from_digest(digest.to_byte_array());\nlet sig = secp.sign_ecdsa(message, &secret_key);\nassert!(secp.verify_ecdsa(message, &sig, &public_key).is_ok());\n```\n\nIf the \u201cglobal-context\u201d feature is enabled you have access to an alternate API.\n```\nuse secp256k1::{rand, generate_keypair, Message};\nuse secp256k1::hashes::{sha256, Hash};\nlet (secret_key, public_key) = generate_keypair(&mut rand::rng());\nlet digest = sha256::Hash::hash(\"Hello World!\".as_bytes());\nlet message = Message::from_digest(digest.to_byte_array());\nlet sig = secret_key.sign_ecdsa(message);\nassert!(sig.verify(message, &public_key).is_ok());\n```\n\nThe above code requires `rust-secp256k1` to be compiled with the `rand`, `hashes`, and `std` feature enabled, to get access to [`generate_keypair`](https://docs.rs/secp256k1/latest/secp256k1/struct.Secp256k1.html#method.generate_keypair) Alternately, keys and messages can be parsed from slices, like\n```\nuse secp256k1::{Secp256k1, Message, SecretKey, PublicKey};\nlet secp = Secp256k1::new();\nlet secret_key = SecretKey::from_slice(&[0xcd; 32]).expect(\"32 bytes, within curve order\");\nlet public_key = PublicKey::from_secret_key(&secp, &secret_key);\n// If the supplied byte slice was *not* the output of a cryptographic hash function this would\n// be cryptographically broken. It has been trivially used in the past to execute attacks.\nlet message = Message::from_digest(compute_hash(b\"CSW is not Satoshi\"));\nlet sig = secp.sign_ecdsa(message, &secret_key);\nassert!(secp.verify_ecdsa(message, &sig, &public_key).is_ok());\n```\n\nUsers who only want to verify signatures can use a cheaper context, like so:\n```\nuse secp256k1::{Secp256k1, Message, ecdsa, PublicKey};\nlet secp = Secp256k1::verification_only();\nlet public_key = PublicKey::from_slice(&[\n  0x02,\n  0xc6, 0x6e, 0x7d, 0x89, 0x66, 0xb5, 0xc5, 0x55,\n  0xaf, 0x58, 0x05, 0x98, 0x9d, 0xa9, 0xfb, 0xf8,\n  0xdb, 0x95, 0xe1, 0x56, 0x31, 0xce, 0x35, 0x8c,\n  0x3a, 0x17, 0x10, 0xc9, 0x62, 0x67, 0x90, 0x63,\n]).expect(\"public keys must be 33 or 65 bytes, serialized according to SEC 2\");\nlet message = Message::from_digest([\n  0xaa, 0xdf, 0x7d, 0xe7, 0x82, 0x03, 0x4f, 0xbe,\n  0x3d, 0x3d, 0xb2, 0xcb, 0x13, 0xc0, 0xcd, 0x91,\n  0xbf, 0x41, 0xcb, 0x08, 0xfa, 0xc7, 0xbd, 0x61,\n  0xd5, 0x44, 0x53, 0xcf, 0x6e, 0x82, 0xb4, 0x50,\n]);\nlet sig = ecdsa::Signature::from_compact(&[\n  0xdc, 0x4d, 0xc2, 0x64, 0xa9, 0xfe, 0xf1, 0x7a,\n  0x3f, 0x25, 0x34, 0x49, 0xcf, 0x8c, 0x39, 0x7a,\n  0xb6, 0xf1, 0x6f, 0xb3, 0xd6, 0x3d, 0x86, 0x94,\n  0x0b, 0x55, 0x86, 0x82, 0x3d, 0xfd, 0x02, 0xae,\n  0x3b, 0x46, 0x1b, 0xb4, 0x33, 0x6b, 0x5e, 0xcb,\n  0xae, 0xfd, 0x66, 0x27, 0xaa, 0x92, 0x2e, 0xfc,\n  0x04, 0x8f, 0xec, 0x0c, 0x88, 0x1c, 0x10, 0xc4,\n  0xc9, 0x42, 0x8f, 0xca, 0x69, 0xc1, 0x32, 0xa2,\n]).expect(\"compact signatures are 64 bytes; DER signatures are 68-72 bytes\");\nassert!(secp.verify_ecdsa(message, &sig, &public_key).is_ok());\n```\n\nObserve that the same code using, say [`signing_only`](https://docs.rs/secp256k1/latest/secp256k1/struct.Secp256k1.html#method.signing_only) to generate a context would simply not compile.\n### [\u00a7](https://docs.rs/secp256k1/latest/secp256k1/#crate-featuresoptional-dependencies)Crate features/optional dependencies\nThis crate provides the following opt-in Cargo features:\n  * `std` - use standard Rust library, enabled by default.\n  * `alloc` - use the `alloc` standard Rust library to provide heap allocations.\n  * `rand` - use `rand` library to provide random generator (e.g. to generate keys).\n  * `hashes` - use the `hashes` library.\n  * `recovery` - enable functions that can compute the public key from signature.\n  * `lowmemory` - optimize the library for low-memory environments.\n  * `global-context` - enable use of global secp256k1 context (implies `std`).\n  * `serde` - implements serialization and deserialization for types in this crate using `serde`. **Important** : `serde` encoding is **not** the same as consensus encoding!\n\n\n## Re-exports[\u00a7](https://docs.rs/secp256k1/latest/secp256k1/#reexports)\n\n`pub extern crate hashes[](https://docs.rs/bitcoin_hashes/0.14.0/x86_64-unknown-linux-gnu/bitcoin_hashes/index.html \"mod bitcoin_hashes\");`\n\n\n`pub use crate::scalar::Scalar[](https://docs.rs/secp256k1/latest/secp256k1/scalar/struct.Scalar.html \"struct secp256k1::scalar::Scalar\");`\n\n\n`pub use rand[](https://docs.rs/rand/0.9.1/x86_64-unknown-linux-gnu/rand/index.html \"mod rand\");``rand`\n\n\n`pub use secp256k1_sys[](https://docs.rs/secp256k1-sys/0.11.0/x86_64-unknown-linux-gnu/secp256k1_sys/index.html \"mod secp256k1_sys\") as ffi;`\n\n\n`pub use serde[](https://docs.rs/serde/1.0.219/x86_64-unknown-linux-gnu/serde/index.html \"mod serde\");``serde`\n\n## Modules[\u00a7](https://docs.rs/secp256k1/latest/secp256k1/#modules)\n\n[constants](https://docs.rs/secp256k1/latest/secp256k1/constants/index.html \"mod secp256k1::constants\")\n    Constants related to the API and the underlying curve.\n\n[ecdh](https://docs.rs/secp256k1/latest/secp256k1/ecdh/index.html \"mod secp256k1::ecdh\")\n    Support for shared secret computations.\n\n[ecdsa](https://docs.rs/secp256k1/latest/secp256k1/ecdsa/index.html \"mod secp256k1::ecdsa\")\n    Structs and functionality related to the ECDSA signature algorithm.\n\n[ellswift](https://docs.rs/secp256k1/latest/secp256k1/ellswift/index.html \"mod secp256k1::ellswift\")\n    This module provides an implementation of ElligatorSwift as well as a version of x-only ECDH using it (including compatibility with BIP324).\n\n[global](https://docs.rs/secp256k1/latest/secp256k1/global/index.html \"mod secp256k1::global\")`global-context` and `std`\n    Module implementing a singleton pattern for a global `Secp256k1` context.\n\n[scalar](https://docs.rs/secp256k1/latest/secp256k1/scalar/index.html \"mod secp256k1::scalar\")\n    Provides [`Scalar`](https://docs.rs/secp256k1/latest/secp256k1/scalar/struct.Scalar.html \"struct secp256k1::scalar::Scalar\") and related types.\n\n[schnorr](https://docs.rs/secp256k1/latest/secp256k1/schnorr/index.html \"mod secp256k1::schnorr\")\n    Support for schnorr signatures.\n## Macros[\u00a7](https://docs.rs/secp256k1/latest/secp256k1/#macros)\n\n[impl_array_newtype](https://docs.rs/secp256k1/latest/secp256k1/macro.impl_array_newtype.html \"macro secp256k1::impl_array_newtype\")\n    Implement methods and traits for types that contain an inner array.\n## Structs[\u00a7](https://docs.rs/secp256k1/latest/secp256k1/#structs)\n\n[AllPreallocated](https://docs.rs/secp256k1/latest/secp256k1/struct.AllPreallocated.html \"struct secp256k1::AllPreallocated\")\n    Represents the set of all capabilities (preallocated memory).\n\n[InvalidParityValue](https://docs.rs/secp256k1/latest/secp256k1/struct.InvalidParityValue.html \"struct secp256k1::InvalidParityValue\")\n    Error returned when conversion from an integer to `Parity` fails.\n\n[Keypair](https://docs.rs/secp256k1/latest/secp256k1/struct.Keypair.html \"struct secp256k1::Keypair\")\n    Opaque data structure that holds a keypair consisting of a secret and a public key.\n\n[Message](https://docs.rs/secp256k1/latest/secp256k1/struct.Message.html \"struct secp256k1::Message\")\n    A (hashed) message input to an ECDSA signature.\n\n[PublicKey](https://docs.rs/secp256k1/latest/secp256k1/struct.PublicKey.html \"struct secp256k1::PublicKey\")\n    Public key - used to verify ECDSA signatures and to do Taproot tweaks.\n\n[Secp256k1](https://docs.rs/secp256k1/latest/secp256k1/struct.Secp256k1.html \"struct secp256k1::Secp256k1\")\n    The secp256k1 engine, used to execute all signature operations.\n\n[SecretKey](https://docs.rs/secp256k1/latest/secp256k1/struct.SecretKey.html \"struct secp256k1::SecretKey\")\n    Secret key - a 256-bit key used to create ECDSA and Taproot signatures.\n\n[SignOnlyPreallocated](https://docs.rs/secp256k1/latest/secp256k1/struct.SignOnlyPreallocated.html \"struct secp256k1::SignOnlyPreallocated\")\n    Represents the set of capabilities needed for signing (preallocated memory).\n\n[VerifyOnlyPreallocated](https://docs.rs/secp256k1/latest/secp256k1/struct.VerifyOnlyPreallocated.html \"struct secp256k1::VerifyOnlyPreallocated\")\n    Represents the set of capabilities needed for verification (preallocated memory).\n\n[XOnlyPublicKey](https://docs.rs/secp256k1/latest/secp256k1/struct.XOnlyPublicKey.html \"struct secp256k1::XOnlyPublicKey\")\n    An x-only public key, used for verification of Taproot signatures and serialized according to BIP-340.\n## Enums[\u00a7](https://docs.rs/secp256k1/latest/secp256k1/#enums)\n\n[All](https://docs.rs/secp256k1/latest/secp256k1/enum.All.html \"enum secp256k1::All\")`alloc`\n    Represents the set of all capabilities.\n\n[Error](https://docs.rs/secp256k1/latest/secp256k1/enum.Error.html \"enum secp256k1::Error\")\n    The main error type for this library.\n\n[Parity](https://docs.rs/secp256k1/latest/secp256k1/enum.Parity.html \"enum secp256k1::Parity\")\n    Represents the parity passed between FFI function calls.\n\n[SignOnly](https://docs.rs/secp256k1/latest/secp256k1/enum.SignOnly.html \"enum secp256k1::SignOnly\")`alloc`\n    Represents the set of capabilities needed for signing.\n\n[VerifyOnly](https://docs.rs/secp256k1/latest/secp256k1/enum.VerifyOnly.html \"enum secp256k1::VerifyOnly\")`alloc`\n    Represents the set of capabilities needed for verification.\n## Statics[\u00a7](https://docs.rs/secp256k1/latest/secp256k1/#statics)\n\n[SECP256K1](https://docs.rs/secp256k1/latest/secp256k1/static.SECP256K1.html \"static secp256k1::SECP256K1\")`global-context` and `std`\n    A global static context to avoid repeatedly creating contexts.\n## Traits[\u00a7](https://docs.rs/secp256k1/latest/secp256k1/#traits)\n\n[Context](https://docs.rs/secp256k1/latest/secp256k1/trait.Context.html \"trait secp256k1::Context\")\n    A trait for all kinds of contexts that lets you define the exact flags and a function to deallocate memory. It isn\u2019t possible to implement this for types outside this crate.\n\n[PreallocatedContext](https://docs.rs/secp256k1/latest/secp256k1/trait.PreallocatedContext.html \"trait secp256k1::PreallocatedContext\")\n    Trait marking that a particular context object internally points to memory that must outlive `'a`\n\n[Signing](https://docs.rs/secp256k1/latest/secp256k1/trait.Signing.html \"trait secp256k1::Signing\")\n    Marker trait for indicating that an instance of [`Secp256k1`](https://docs.rs/secp256k1/latest/secp256k1/struct.Secp256k1.html \"struct secp256k1::Secp256k1\") can be used for signing.\n\n[ThirtyTwoByteHash](https://docs.rs/secp256k1/latest/secp256k1/trait.ThirtyTwoByteHash.html \"trait secp256k1::ThirtyTwoByteHash\")Deprecated\n    Trait describing something that promises to be a 32-byte uniformly random number.\n\n[Verification](https://docs.rs/secp256k1/latest/secp256k1/trait.Verification.html \"trait secp256k1::Verification\")\n    Marker trait for indicating that an instance of [`Secp256k1`](https://docs.rs/secp256k1/latest/secp256k1/struct.Secp256k1.html \"struct secp256k1::Secp256k1\") can be used for verification.\n## Functions[\u00a7](https://docs.rs/secp256k1/latest/secp256k1/#functions)\n\n[generate_keypair](https://docs.rs/secp256k1/latest/secp256k1/fn.generate_keypair.html \"fn secp256k1::generate_keypair\")`global-context` and `rand`\n    Generates a random keypair using the global [`SECP256K1`](https://docs.rs/secp256k1/latest/secp256k1/static.SECP256K1.html \"static secp256k1::SECP256K1\") context.\n",
        "markdown_with_citations": "[](https://docs.rs/secp256k1/latest/secp256k1/all.html \"show sidebar\")\n# Crate secp256k1Copy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nRust bindings for Pieter Wuille\u2019s secp256k1 library, which is used for fast and accurate manipulation of ECDSA and Schnorr signatures on the secp256k1 curve. Such signatures are used extensively by the Bitcoin network and its derivatives.\nTo minimize dependencies, some functions are feature-gated. To generate random keys or to re-randomize a context object, compile with the `rand` and `std` features. If you are willing to use these features, we have enabled an additional defense-in-depth sidechannel protection for our context objects, which re-blinds certain operations on secret key data. To de/serialize objects with serde, compile with \u201cserde\u201d. **Important** : `serde` encoding is **not** the same as consensus encoding!\nWhere possible, the bindings use the Rust type system to ensure that API usage errors are impossible. For example, the library uses context objects that contain precomputation tables which are created on object construction. Since this is a slow operation (10+ milliseconds, vs ~50 microseconds for typical crypto operations, on a 2.70 Ghz i7-6820HQ) the tables are optional, giving a performance boost for users who only care about signing, only care about verification, or only care about parsing. In the upstream library, if you attempt to sign a message using a context that does not support this, it will trigger an assertion failure and terminate the program. In `rust-secp256k1`, this is caught at compile-time; in fact, it is impossible to compile code that will trigger any assertion failures in the upstream library.\n```\nuse secp256k1::rand;\nuse secp256k1::{Secp256k1, Message};\nuse secp256k1::hashes::{sha256, Hash};\nlet secp = Secp256k1::new();\nlet (secret_key, public_key) = secp.generate_keypair(&mut rand::rng());\nlet digest = sha256::Hash::hash(\"Hello World!\".as_bytes());\nlet message = Message::from_digest(digest.to_byte_array());\nlet sig = secp.sign_ecdsa(message, &secret_key);\nassert!(secp.verify_ecdsa(message, &sig, &public_key).is_ok());\n```\n\nIf the \u201cglobal-context\u201d feature is enabled you have access to an alternate API.\n```\nuse secp256k1::{rand, generate_keypair, Message};\nuse secp256k1::hashes::{sha256, Hash};\nlet (secret_key, public_key) = generate_keypair(&mut rand::rng());\nlet digest = sha256::Hash::hash(\"Hello World!\".as_bytes());\nlet message = Message::from_digest(digest.to_byte_array());\nlet sig = secret_key.sign_ecdsa(message);\nassert!(sig.verify(message, &public_key).is_ok());\n```\n\nThe above code requires `rust-secp256k1` to be compiled with the `rand`, `hashes`, and `std` feature enabled, to get access to `generate_keypair`\u27e84\u27e9 Alternately, keys and messages can be parsed from slices, like\n```\nuse secp256k1::{Secp256k1, Message, SecretKey, PublicKey};\nlet secp = Secp256k1::new();\nlet secret_key = SecretKey::from_slice(&[0xcd; 32]).expect(\"32 bytes, within curve order\");\nlet public_key = PublicKey::from_secret_key(&secp, &secret_key);\n// If the supplied byte slice was *not* the output of a cryptographic hash function this would\n// be cryptographically broken. It has been trivially used in the past to execute attacks.\nlet message = Message::from_digest(compute_hash(b\"CSW is not Satoshi\"));\nlet sig = secp.sign_ecdsa(message, &secret_key);\nassert!(secp.verify_ecdsa(message, &sig, &public_key).is_ok());\n```\n\nUsers who only want to verify signatures can use a cheaper context, like so:\n```\nuse secp256k1::{Secp256k1, Message, ecdsa, PublicKey};\nlet secp = Secp256k1::verification_only();\nlet public_key = PublicKey::from_slice(&[\n  0x02,\n  0xc6, 0x6e, 0x7d, 0x89, 0x66, 0xb5, 0xc5, 0x55,\n  0xaf, 0x58, 0x05, 0x98, 0x9d, 0xa9, 0xfb, 0xf8,\n  0xdb, 0x95, 0xe1, 0x56, 0x31, 0xce, 0x35, 0x8c,\n  0x3a, 0x17, 0x10, 0xc9, 0x62, 0x67, 0x90, 0x63,\n]).expect(\"public keys must be 33 or 65 bytes, serialized according to SEC 2\");\nlet message = Message::from_digest([\n  0xaa, 0xdf, 0x7d, 0xe7, 0x82, 0x03, 0x4f, 0xbe,\n  0x3d, 0x3d, 0xb2, 0xcb, 0x13, 0xc0, 0xcd, 0x91,\n  0xbf, 0x41, 0xcb, 0x08, 0xfa, 0xc7, 0xbd, 0x61,\n  0xd5, 0x44, 0x53, 0xcf, 0x6e, 0x82, 0xb4, 0x50,\n]);\nlet sig = ecdsa::Signature::from_compact(&[\n  0xdc, 0x4d, 0xc2, 0x64, 0xa9, 0xfe, 0xf1, 0x7a,\n  0x3f, 0x25, 0x34, 0x49, 0xcf, 0x8c, 0x39, 0x7a,\n  0xb6, 0xf1, 0x6f, 0xb3, 0xd6, 0x3d, 0x86, 0x94,\n  0x0b, 0x55, 0x86, 0x82, 0x3d, 0xfd, 0x02, 0xae,\n  0x3b, 0x46, 0x1b, 0xb4, 0x33, 0x6b, 0x5e, 0xcb,\n  0xae, 0xfd, 0x66, 0x27, 0xaa, 0x92, 0x2e, 0xfc,\n  0x04, 0x8f, 0xec, 0x0c, 0x88, 0x1c, 0x10, 0xc4,\n  0xc9, 0x42, 0x8f, 0xca, 0x69, 0xc1, 0x32, 0xa2,\n]).expect(\"compact signatures are 64 bytes; DER signatures are 68-72 bytes\");\nassert!(secp.verify_ecdsa(message, &sig, &public_key).is_ok());\n```\n\nObserve that the same code using, say `signing_only`\u27e85\u27e9 to generate a context would simply not compile.\n### \u00a7\u27e86\u27e9Crate features/optional dependencies\nThis crate provides the following opt-in Cargo features:\n  * `std` - use standard Rust library, enabled by default.\n  * `alloc` - use the `alloc` standard Rust library to provide heap allocations.\n  * `rand` - use `rand` library to provide random generator (e.g. to generate keys).\n  * `hashes` - use the `hashes` library.\n  * `recovery` - enable functions that can compute the public key from signature.\n  * `lowmemory` - optimize the library for low-memory environments.\n  * `global-context` - enable use of global secp256k1 context (implies `std`).\n  * `serde` - implements serialization and deserialization for types in this crate using `serde`. **Important** : `serde` encoding is **not** the same as consensus encoding!\n\n\n## Re-exports\u00a7\u27e87\u27e9\n\n`pub extern crate hashes[](https://docs.rs/bitcoin_hashes/0.14.0/x86_64-unknown-linux-gnu/bitcoin_hashes/index.html \"mod bitcoin_hashes\");`\n\n\n`pub use crate::scalar::Scalar[](https://docs.rs/secp256k1/latest/secp256k1/scalar/struct.Scalar.html \"struct secp256k1::scalar::Scalar\");`\n\n\n`pub use rand[](https://docs.rs/rand/0.9.1/x86_64-unknown-linux-gnu/rand/index.html \"mod rand\");``rand`\n\n\n`pub use secp256k1_sys[](https://docs.rs/secp256k1-sys/0.11.0/x86_64-unknown-linux-gnu/secp256k1_sys/index.html \"mod secp256k1_sys\") as ffi;`\n\n\n`pub use serde[](https://docs.rs/serde/1.0.219/x86_64-unknown-linux-gnu/serde/index.html \"mod serde\");``serde`\n\n## Modules\u00a7\u27e88\u27e9\n\nconstants\u27e89\u27e9\n    Constants related to the API and the underlying curve.\n\necdh\u27e810\u27e9\n    Support for shared secret computations.\n\necdsa\u27e811\u27e9\n    Structs and functionality related to the ECDSA signature algorithm.\n\nellswift\u27e812\u27e9\n    This module provides an implementation of ElligatorSwift as well as a version of x-only ECDH using it (including compatibility with BIP324).\n\nglobal\u27e813\u27e9`global-context` and `std`\n    Module implementing a singleton pattern for a global `Secp256k1` context.\n\nscalar\u27e814\u27e9\n    Provides `Scalar`\u27e815\u27e9 and related types.\n\nschnorr\u27e816\u27e9\n    Support for schnorr signatures.\n## Macros\u00a7\u27e817\u27e9\n\nimpl_array_newtype\u27e818\u27e9\n    Implement methods and traits for types that contain an inner array.\n## Structs\u00a7\u27e819\u27e9\n\nAllPreallocated\u27e820\u27e9\n    Represents the set of all capabilities (preallocated memory).\n\nInvalidParityValue\u27e821\u27e9\n    Error returned when conversion from an integer to `Parity` fails.\n\nKeypair\u27e822\u27e9\n    Opaque data structure that holds a keypair consisting of a secret and a public key.\n\nMessage\u27e823\u27e9\n    A (hashed) message input to an ECDSA signature.\n\nPublicKey\u27e824\u27e9\n    Public key - used to verify ECDSA signatures and to do Taproot tweaks.\n\nSecp256k1\u27e825\u27e9\n    The secp256k1 engine, used to execute all signature operations.\n\nSecretKey\u27e826\u27e9\n    Secret key - a 256-bit key used to create ECDSA and Taproot signatures.\n\nSignOnlyPreallocated\u27e827\u27e9\n    Represents the set of capabilities needed for signing (preallocated memory).\n\nVerifyOnlyPreallocated\u27e828\u27e9\n    Represents the set of capabilities needed for verification (preallocated memory).\n\nXOnlyPublicKey\u27e829\u27e9\n    An x-only public key, used for verification of Taproot signatures and serialized according to BIP-340.\n## Enums\u00a7\u27e830\u27e9\n\nAll\u27e831\u27e9`alloc`\n    Represents the set of all capabilities.\n\nError\u27e832\u27e9\n    The main error type for this library.\n\nParity\u27e833\u27e9\n    Represents the parity passed between FFI function calls.\n\nSignOnly\u27e834\u27e9`alloc`\n    Represents the set of capabilities needed for signing.\n\nVerifyOnly\u27e835\u27e9`alloc`\n    Represents the set of capabilities needed for verification.\n## Statics\u00a7\u27e836\u27e9\n\nSECP256K1\u27e837\u27e9`global-context` and `std`\n    A global static context to avoid repeatedly creating contexts.\n## Traits\u00a7\u27e838\u27e9\n\nContext\u27e839\u27e9\n    A trait for all kinds of contexts that lets you define the exact flags and a function to deallocate memory. It isn\u2019t possible to implement this for types outside this crate.\n\nPreallocatedContext\u27e840\u27e9\n    Trait marking that a particular context object internally points to memory that must outlive `'a`\n\nSigning\u27e841\u27e9\n    Marker trait for indicating that an instance of `Secp256k1`\u27e825\u27e9 can be used for signing.\n\nThirtyTwoByteHash\u27e842\u27e9Deprecated\n    Trait describing something that promises to be a 32-byte uniformly random number.\n\nVerification\u27e843\u27e9\n    Marker trait for indicating that an instance of `Secp256k1`\u27e825\u27e9 can be used for verification.\n## Functions\u00a7\u27e844\u27e9\n\ngenerate_keypair\u27e845\u27e9`global-context` and `rand`\n    Generates a random keypair using the global `SECP256K1`\u27e837\u27e9 context.\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/secp256k1/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/secp256k1/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/secp256k1/latest/src/secp256k1/lib.rs.html#3-1052: Source\n\u27e84\u27e9 https://docs.rs/secp256k1/latest/secp256k1/struct.Secp256k1.html#method.generate_keypair: `generate_keypair`\n\u27e85\u27e9 https://docs.rs/secp256k1/latest/secp256k1/struct.Secp256k1.html#method.signing_only: `signing_only`\n\u27e86\u27e9 https://docs.rs/secp256k1/latest/secp256k1/#crate-featuresoptional-dependencies: \u00a7\n\u27e87\u27e9 https://docs.rs/secp256k1/latest/secp256k1/#reexports: \u00a7\n\u27e88\u27e9 https://docs.rs/secp256k1/latest/secp256k1/#modules: \u00a7\n\u27e89\u27e9 https://docs.rs/secp256k1/latest/secp256k1/constants/index.html: mod secp256k1::constants - constants\n\u27e810\u27e9 https://docs.rs/secp256k1/latest/secp256k1/ecdh/index.html: mod secp256k1::ecdh - ecdh\n\u27e811\u27e9 https://docs.rs/secp256k1/latest/secp256k1/ecdsa/index.html: mod secp256k1::ecdsa - ecdsa\n\u27e812\u27e9 https://docs.rs/secp256k1/latest/secp256k1/ellswift/index.html: mod secp256k1::ellswift - ellswift\n\u27e813\u27e9 https://docs.rs/secp256k1/latest/secp256k1/global/index.html: mod secp256k1::global - global\n\u27e814\u27e9 https://docs.rs/secp256k1/latest/secp256k1/scalar/index.html: mod secp256k1::scalar - scalar\n\u27e815\u27e9 https://docs.rs/secp256k1/latest/secp256k1/scalar/struct.Scalar.html: struct secp256k1::scalar::Scalar - `Scalar`\n\u27e816\u27e9 https://docs.rs/secp256k1/latest/secp256k1/schnorr/index.html: mod secp256k1::schnorr - schnorr\n\u27e817\u27e9 https://docs.rs/secp256k1/latest/secp256k1/#macros: \u00a7\n\u27e818\u27e9 https://docs.rs/secp256k1/latest/secp256k1/macro.impl_array_newtype.html: macro secp256k1::impl_array_newtype - impl_array_newtype\n\u27e819\u27e9 https://docs.rs/secp256k1/latest/secp256k1/#structs: \u00a7\n\u27e820\u27e9 https://docs.rs/secp256k1/latest/secp256k1/struct.AllPreallocated.html: struct secp256k1::AllPreallocated - AllPreallocated\n\u27e821\u27e9 https://docs.rs/secp256k1/latest/secp256k1/struct.InvalidParityValue.html: struct secp256k1::InvalidParityValue - InvalidParityValue\n\u27e822\u27e9 https://docs.rs/secp256k1/latest/secp256k1/struct.Keypair.html: struct secp256k1::Keypair - Keypair\n\u27e823\u27e9 https://docs.rs/secp256k1/latest/secp256k1/struct.Message.html: struct secp256k1::Message - Message\n\u27e824\u27e9 https://docs.rs/secp256k1/latest/secp256k1/struct.PublicKey.html: struct secp256k1::PublicKey - PublicKey\n\u27e825\u27e9 https://docs.rs/secp256k1/latest/secp256k1/struct.Secp256k1.html: struct secp256k1::Secp256k1 - Secp256k1\n\u27e826\u27e9 https://docs.rs/secp256k1/latest/secp256k1/struct.SecretKey.html: struct secp256k1::SecretKey - SecretKey\n\u27e827\u27e9 https://docs.rs/secp256k1/latest/secp256k1/struct.SignOnlyPreallocated.html: struct secp256k1::SignOnlyPreallocated - SignOnlyPreallocated\n\u27e828\u27e9 https://docs.rs/secp256k1/latest/secp256k1/struct.VerifyOnlyPreallocated.html: struct secp256k1::VerifyOnlyPreallocated - VerifyOnlyPreallocated\n\u27e829\u27e9 https://docs.rs/secp256k1/latest/secp256k1/struct.XOnlyPublicKey.html: struct secp256k1::XOnlyPublicKey - XOnlyPublicKey\n\u27e830\u27e9 https://docs.rs/secp256k1/latest/secp256k1/#enums: \u00a7\n\u27e831\u27e9 https://docs.rs/secp256k1/latest/secp256k1/enum.All.html: enum secp256k1::All - All\n\u27e832\u27e9 https://docs.rs/secp256k1/latest/secp256k1/enum.Error.html: enum secp256k1::Error - Error\n\u27e833\u27e9 https://docs.rs/secp256k1/latest/secp256k1/enum.Parity.html: enum secp256k1::Parity - Parity\n\u27e834\u27e9 https://docs.rs/secp256k1/latest/secp256k1/enum.SignOnly.html: enum secp256k1::SignOnly - SignOnly\n\u27e835\u27e9 https://docs.rs/secp256k1/latest/secp256k1/enum.VerifyOnly.html: enum secp256k1::VerifyOnly - VerifyOnly\n\u27e836\u27e9 https://docs.rs/secp256k1/latest/secp256k1/#statics: \u00a7\n\u27e837\u27e9 https://docs.rs/secp256k1/latest/secp256k1/static.SECP256K1.html: static secp256k1::SECP256K1 - SECP256K1\n\u27e838\u27e9 https://docs.rs/secp256k1/latest/secp256k1/#traits: \u00a7\n\u27e839\u27e9 https://docs.rs/secp256k1/latest/secp256k1/trait.Context.html: trait secp256k1::Context - Context\n\u27e840\u27e9 https://docs.rs/secp256k1/latest/secp256k1/trait.PreallocatedContext.html: trait secp256k1::PreallocatedContext - PreallocatedContext\n\u27e841\u27e9 https://docs.rs/secp256k1/latest/secp256k1/trait.Signing.html: trait secp256k1::Signing - Signing\n\u27e842\u27e9 https://docs.rs/secp256k1/latest/secp256k1/trait.ThirtyTwoByteHash.html: trait secp256k1::ThirtyTwoByteHash - ThirtyTwoByteHash\n\u27e843\u27e9 https://docs.rs/secp256k1/latest/secp256k1/trait.Verification.html: trait secp256k1::Verification - Verification\n\u27e844\u27e9 https://docs.rs/secp256k1/latest/secp256k1/#functions: \u00a7\n\u27e845\u27e9 https://docs.rs/secp256k1/latest/secp256k1/fn.generate_keypair.html: fn secp256k1::generate_keypair - generate_keypair\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `secp256k1` crate provides Rust bindings for Pieter Wuille's secp256k1 library, enabling fast and secure manipulation of ECDSA and Schnorr signatures on the secp256k1 curve, widely used in Bitcoin and related systems. It leverages Rust's type system to prevent API misuse at compile-time and offers feature-gated options like `rand` for key generation, `serde` for serialization, and `lowmemory` for optimization. The crate supports signing, verification, context management, and advanced functionalities like shared secrets (ECDH) and Taproot tweaks.",
    "feature_summary": null,
    "use_case": "Cryptography",
    "score": 8.5,
    "factual_counterfactual": "### Pair 1: Key Generation and Context\n\u2705 Factual: The `secp256k1` crate allows users to generate a random keypair using the `generate_keypair` function, provided the `rand` and `global-context` features are enabled.  \n\u274c Counterfactual: The `secp256k1` crate can generate keypairs without requiring any feature flags, as the functionality is always available by default.\n\n---\n\n### Pair 2: Compile-Time Error Prevention\n\u2705 Factual: The `secp256k1` crate uses Rust's type system to prevent API misuse at compile-time, ensuring that invalid operations like signing with a verification-only context cannot compile.  \n\u274c Counterfactual: The `secp256k1` crate relies on runtime assertions to prevent API misuse, similar to the behavior of the upstream C library.\n\n---\n\n### Pair 3: Serde Serialization\n\u2705 Factual: The `serde` feature in the `secp256k1` crate enables serialization and deserialization of types but does not conform to Bitcoin's consensus encoding.  \n\u274c Counterfactual: The `serde` feature in the `secp256k1` crate implements serialization that is fully compatible with Bitcoin's consensus encoding format.",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}