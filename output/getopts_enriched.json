{
    "name": "getopts",
    "version": "0.2.23",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/getopts/latest/getopts/all.html \"show sidebar\")\n# Crate getoptsCopy item path\n[Settings](https://docs.rs/getopts/latest/settings.html)\n[Help](https://docs.rs/getopts/latest/help.html)\nSummary[Source](https://docs.rs/getopts/latest/src/getopts/lib.rs.html#13-1282)\nExpand description\nSimple getopt alternative.\nConstruct instance of `Options` and configure it by using `reqopt()`, `optopt()` and other methods that add option configuration. Then call `parse()` method and pass into it a vector of actual arguments (not including `argv[0]`).\nYou\u2019ll either get a failure code back, or a match. You\u2019ll have to verify whether the amount of \u2018free\u2019 arguments in the match is what you expect. Use `opt_*` accessors to get argument values out of the matches object.\nSingle-character options are expected to appear on the command line with a single preceding dash; multiple-character options are expected to be proceeded by two dashes. Options that expect an argument accept their argument following either a space or an equals sign. Single-character options don\u2019t require the space. Everything after double-dash \u201c\u2013\u201d argument is considered to be a \u2018free\u2019 argument, even if it starts with dash.\n## [\u00a7](https://docs.rs/getopts/latest/getopts/#usage)Usage\nThis crate is [on crates.io](https://crates.io/crates/getopts) and can be used by adding `getopts` to the dependencies in your project\u2019s `Cargo.toml`.\n```\n[dependencies]\ngetopts = \"0.2\"\n```\n\nand this to your crate root:\n```\nextern crate getopts;\n```\n\n## [\u00a7](https://docs.rs/getopts/latest/getopts/#example)Example\nThe following example shows simple command line parsing for an application that requires an input file to be specified, accepts an optional output file name following `-o`, and accepts both `-h` and `--help` as optional flags.\n```\nextern crate getopts;\nuse getopts::Options;\nuse std::env;\nfn do_work(inp: &str, out: Option<String>) {\n  println!(\"{}\", inp);\n  match out {\n    Some(x) => println!(\"{}\", x),\n    None => println!(\"No Output\"),\n  }\n}\nfn print_usage(program: &str, opts: Options) {\n  let brief = format!(\"Usage: {} FILE [options]\", program);\n  print!(\"{}\", opts.usage(&brief));\n}\nfn main() {\n  let args: Vec<String> = env::args().collect();\n  let program = args[0].clone();\n  let mut opts = Options::new();\n  opts.optopt(\"o\", \"\", \"set output file name\", \"NAME\");\n  opts.optflag(\"h\", \"help\", \"print this help menu\");\n  let matches = match opts.parse(&args[1..]) {\n    Ok(m) => { m }\n    Err(f) => { panic!(\"{}\", f.to_string()) }\n  };\n  if matches.opt_present(\"h\") {\n    print_usage(&program, opts);\n    return;\n  }\n  let output = matches.opt_str(\"o\");\n  let input = if !matches.free.is_empty() {\n    matches.free[0].clone()\n  } else {\n    print_usage(&program, opts);\n    return;\n  };\n  do_work(&input, output);\n}\n```\n\n## Structs[\u00a7](https://docs.rs/getopts/latest/getopts/#structs)\n\n[Matches](https://docs.rs/getopts/latest/getopts/struct.Matches.html \"struct getopts::Matches\")\n    The result of checking command line arguments. Contains a vector of matches and a vector of free strings.\n\n[Options](https://docs.rs/getopts/latest/getopts/struct.Options.html \"struct getopts::Options\")\n    A description of the options that a program can handle.\n## Enums[\u00a7](https://docs.rs/getopts/latest/getopts/#enums)\n\n[Fail](https://docs.rs/getopts/latest/getopts/enum.Fail.html \"enum getopts::Fail\")\n    The type returned when the command line does not conform to the expected format. Use the `Debug` implementation to output detailed information.\n\n[HasArg](https://docs.rs/getopts/latest/getopts/enum.HasArg.html \"enum getopts::HasArg\")\n    Describes whether an option has an argument.\n\n[Occur](https://docs.rs/getopts/latest/getopts/enum.Occur.html \"enum getopts::Occur\")\n    Describes how often an option may occur.\n\n[ParsingStyle](https://docs.rs/getopts/latest/getopts/enum.ParsingStyle.html \"enum getopts::ParsingStyle\")\n    What parsing style to use when parsing arguments.\n## Type Aliases[\u00a7](https://docs.rs/getopts/latest/getopts/#types)\n\n[Result](https://docs.rs/getopts/latest/getopts/type.Result.html \"type getopts::Result\")\n    The result of parsing a command line with a set of options.\n",
        "markdown_with_citations": "[](https://docs.rs/getopts/latest/getopts/all.html \"show sidebar\")\n# Crate getoptsCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nSimple getopt alternative.\nConstruct instance of `Options` and configure it by using `reqopt()`, `optopt()` and other methods that add option configuration. Then call `parse()` method and pass into it a vector of actual arguments (not including `argv[0]`).\nYou\u2019ll either get a failure code back, or a match. You\u2019ll have to verify whether the amount of \u2018free\u2019 arguments in the match is what you expect. Use `opt_*` accessors to get argument values out of the matches object.\nSingle-character options are expected to appear on the command line with a single preceding dash; multiple-character options are expected to be proceeded by two dashes. Options that expect an argument accept their argument following either a space or an equals sign. Single-character options don\u2019t require the space. Everything after double-dash \u201c\u2013\u201d argument is considered to be a \u2018free\u2019 argument, even if it starts with dash.\n## \u00a7\u27e84\u27e9Usage\nThis crate is on crates.io\u27e85\u27e9 and can be used by adding `getopts` to the dependencies in your project\u2019s `Cargo.toml`.\n```\n[dependencies]\ngetopts = \"0.2\"\n```\n\nand this to your crate root:\n```\nextern crate getopts;\n```\n\n## \u00a7\u27e86\u27e9Example\nThe following example shows simple command line parsing for an application that requires an input file to be specified, accepts an optional output file name following `-o`, and accepts both `-h` and `--help` as optional flags.\n```\nextern crate getopts;\nuse getopts::Options;\nuse std::env;\nfn do_work(inp: &str, out: Option<String>) {\n  println!(\"{}\", inp);\n  match out {\n    Some(x) => println!(\"{}\", x),\n    None => println!(\"No Output\"),\n  }\n}\nfn print_usage(program: &str, opts: Options) {\n  let brief = format!(\"Usage: {} FILE [options]\", program);\n  print!(\"{}\", opts.usage(&brief));\n}\nfn main() {\n  let args: Vec<String> = env::args().collect();\n  let program = args[0].clone();\n  let mut opts = Options::new();\n  opts.optopt(\"o\", \"\", \"set output file name\", \"NAME\");\n  opts.optflag(\"h\", \"help\", \"print this help menu\");\n  let matches = match opts.parse(&args[1..]) {\n    Ok(m) => { m }\n    Err(f) => { panic!(\"{}\", f.to_string()) }\n  };\n  if matches.opt_present(\"h\") {\n    print_usage(&program, opts);\n    return;\n  }\n  let output = matches.opt_str(\"o\");\n  let input = if !matches.free.is_empty() {\n    matches.free[0].clone()\n  } else {\n    print_usage(&program, opts);\n    return;\n  };\n  do_work(&input, output);\n}\n```\n\n## Structs\u00a7\u27e87\u27e9\n\nMatches\u27e88\u27e9\n    The result of checking command line arguments. Contains a vector of matches and a vector of free strings.\n\nOptions\u27e89\u27e9\n    A description of the options that a program can handle.\n## Enums\u00a7\u27e810\u27e9\n\nFail\u27e811\u27e9\n    The type returned when the command line does not conform to the expected format. Use the `Debug` implementation to output detailed information.\n\nHasArg\u27e812\u27e9\n    Describes whether an option has an argument.\n\nOccur\u27e813\u27e9\n    Describes how often an option may occur.\n\nParsingStyle\u27e814\u27e9\n    What parsing style to use when parsing arguments.\n## Type Aliases\u00a7\u27e815\u27e9\n\nResult\u27e816\u27e9\n    The result of parsing a command line with a set of options.\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/getopts/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/getopts/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/getopts/latest/src/getopts/lib.rs.html#13-1282: Source\n\u27e84\u27e9 https://docs.rs/getopts/latest/getopts/#usage: \u00a7\n\u27e85\u27e9 https://crates.io/crates/getopts: on crates.io\n\u27e86\u27e9 https://docs.rs/getopts/latest/getopts/#example: \u00a7\n\u27e87\u27e9 https://docs.rs/getopts/latest/getopts/#structs: \u00a7\n\u27e88\u27e9 https://docs.rs/getopts/latest/getopts/struct.Matches.html: struct getopts::Matches - Matches\n\u27e89\u27e9 https://docs.rs/getopts/latest/getopts/struct.Options.html: struct getopts::Options - Options\n\u27e810\u27e9 https://docs.rs/getopts/latest/getopts/#enums: \u00a7\n\u27e811\u27e9 https://docs.rs/getopts/latest/getopts/enum.Fail.html: enum getopts::Fail - Fail\n\u27e812\u27e9 https://docs.rs/getopts/latest/getopts/enum.HasArg.html: enum getopts::HasArg - HasArg\n\u27e813\u27e9 https://docs.rs/getopts/latest/getopts/enum.Occur.html: enum getopts::Occur - Occur\n\u27e814\u27e9 https://docs.rs/getopts/latest/getopts/enum.ParsingStyle.html: enum getopts::ParsingStyle - ParsingStyle\n\u27e815\u27e9 https://docs.rs/getopts/latest/getopts/#types: \u00a7\n\u27e816\u27e9 https://docs.rs/getopts/latest/getopts/type.Result.html: type getopts::Result - Result\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `getopts` crate provides a simple and lightweight alternative for parsing command-line options in Rust. It allows defining single- and multi-character options, optional or required arguments, and supports parsing arguments with spaces or equals signs. Key features include the `Options` struct for configuring options, `Matches` for accessing parsed results, and enums like `Fail` and `Occur` for handling parsing behavior and errors.",
    "feature_summary": null,
    "use_case": "Utilities",
    "score": 4.0,
    "factual_counterfactual": "### Pair 1: Command Line Parsing\n\u2705 **Factual:** The `getopts` crate allows parsing single-character options with a single preceding dash (`-`) and multiple-character options with two preceding dashes (`--`).  \n\u274c **Counterfactual:** The `getopts` crate requires all options, whether single- or multi-character, to be preceded by two dashes (`--`).\n\n---\n\n### Pair 2: Argument Handling\n\u2705 **Factual:** Options that expect arguments in `getopts` can accept their arguments either following a space or an equals sign (e.g., `-o output` or `-o=output`).  \n\u274c **Counterfactual:** Options that expect arguments in `getopts` must always have their arguments specified using an equals sign (e.g., `-o=output`).\n\n---\n\n### Pair 3: Error Handling\n\u2705 **Factual:** When parsing fails due to invalid command-line arguments, the `getopts` crate returns a `Fail` enum that provides detailed information about the error.  \n\u274c **Counterfactual:** The `getopts` crate silently ignores invalid command-line arguments and continues execution without returning an error.",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}