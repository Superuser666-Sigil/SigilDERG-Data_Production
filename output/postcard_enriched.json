{
    "name": "postcard",
    "version": "1.1.2",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/postcard/latest/postcard/all.html \"show sidebar\")\n# Crate postcardCopy item path\n[Settings](https://docs.rs/postcard/latest/settings.html)\n[Help](https://docs.rs/postcard/latest/help.html)\nSummary[Source](https://docs.rs/postcard/latest/src/postcard/lib.rs.html#1-125)\nExpand description\n## [\u00a7](https://docs.rs/postcard/latest/postcard/#postcard)Postcard\n[![Documentation](https://docs.rs/postcard/badge.svg)](https://docs.rs/postcard)\nPostcard is a `#![no_std]` focused serializer and deserializer for Serde.\nPostcard aims to be convenient for developers in constrained environments, while allowing for flexibility to customize behavior as needed.\n### [\u00a7](https://docs.rs/postcard/latest/postcard/#design-goals)Design Goals\n  1. Design primarily for `#![no_std]` usage, in embedded or other constrained contexts\n  2. Support a maximal set of `serde` features, so `postcard` can be used as a drop in replacement\n  3. Avoid special differences in code between communication code written for a microcontroller or a desktop/server PC\n  4. Be resource efficient - memory usage, code size, developer time, and CPU time; in that order\n  5. Allow library users to customize the serialization and deserialization behavior to fit their bespoke needs\n\n\n### [\u00a7](https://docs.rs/postcard/latest/postcard/#format-stability)Format Stability\nAs of v1.0.0, `postcard` has a documented and stable wire format. More information about this wire format can be found in the `spec/` folder of the Postcard repository, or viewed online at <https://postcard.jamesmunns.com>.\nWork towards the Postcard Specification and portions of the Postcard 1.0 Release were sponsored by Mozilla Corporation.\n### [\u00a7](https://docs.rs/postcard/latest/postcard/#variable-length-data)Variable Length Data\nAll signed and unsigned integers larger than eight bits are encoded using a [Varint](https://postcard.jamesmunns.com/wire-format.html#varint-encoded-integers). This includes the length of array slices, as well as the discriminant of `enums`.\nFor more information, see the [Varint](https://postcard.jamesmunns.com/wire-format.html#varint-encoded-integers) chapter of the wire specification.\n### [\u00a7](https://docs.rs/postcard/latest/postcard/#example---serializationdeserialization)Example - Serialization/Deserialization\nPostcard can serialize and deserialize messages similar to other `serde` formats.\nUsing the default `heapless` feature to serialize to a `heapless::Vec<u8>`:\n```\nuse core::ops::Deref;\nuse serde::{Serialize, Deserialize};\nuse postcard::{from_bytes, to_vec};\nuse heapless::Vec;\n#[derive(Serialize, Deserialize, Debug, Eq, PartialEq)]\nstruct RefStruct<'a> {\n  bytes: &'a [u8],\n  str_s: &'a str,\n}\nlet message = \"hElLo\";\nlet bytes = [0x01, 0x10, 0x02, 0x20];\nlet output: Vec<u8, 11> = to_vec(&RefStruct {\n  bytes: &bytes,\n  str_s: message,\n}).unwrap();\nassert_eq!(\n  &[0x04, 0x01, 0x10, 0x02, 0x20, 0x05, b'h', b'E', b'l', b'L', b'o',],\n  output.deref()\n);\nlet out: RefStruct = from_bytes(output.deref()).unwrap();\nassert_eq!(\n  out,\n  RefStruct {\n    bytes: &bytes,\n    str_s: message,\n  }\n);\n```\n\nOr the optional `alloc` feature to serialize to an `alloc::vec::Vec<u8>`:\n```\nuse core::ops::Deref;\nuse serde::{Serialize, Deserialize};\nuse postcard::{from_bytes, to_allocvec};\nextern crate alloc;\nuse alloc::vec::Vec;\n#[derive(Serialize, Deserialize, Debug, Eq, PartialEq)]\nstruct RefStruct<'a> {\n  bytes: &'a [u8],\n  str_s: &'a str,\n}\nlet message = \"hElLo\";\nlet bytes = [0x01, 0x10, 0x02, 0x20];\nlet output: Vec<u8> = to_allocvec(&RefStruct {\n  bytes: &bytes,\n  str_s: message,\n}).unwrap();\nassert_eq!(\n  &[0x04, 0x01, 0x10, 0x02, 0x20, 0x05, b'h', b'E', b'l', b'L', b'o',],\n  output.deref()\n);\nlet out: RefStruct = from_bytes(output.deref()).unwrap();\nassert_eq!(\n  out,\n  RefStruct {\n    bytes: &bytes,\n    str_s: message,\n  }\n);\n```\n\n### [\u00a7](https://docs.rs/postcard/latest/postcard/#flavors)Flavors\n`postcard` supports a system called `Flavors`, which are used to modify the way postcard serializes or processes serialized data. These flavors act as \u201cplugins\u201d or \u201cmiddlewares\u201d during the serialization or deserialization process, and can be combined to obtain complex protocol formats.\nSee the documentation of the `ser_flavors` or `de_flavors` modules for more information on usage.\n### [\u00a7](https://docs.rs/postcard/latest/postcard/#setup---cargotoml)Setup - `Cargo.toml`\nDon\u2019t forget to add [the `no-std` subset](https://serde.rs/no-std.html) of `serde` along with `postcard` to the `[dependencies]` section of your `Cargo.toml`!\n```\n[dependencies]\npostcard = \"1.0.0\"\n# By default, `serde` has the `std` feature enabled, which makes it unsuitable for embedded targets\n# disabling default-features fixes this\nserde = { version = \"1.0.*\", default-features = false }\n```\n\n### [\u00a7](https://docs.rs/postcard/latest/postcard/#license)License\nLicensed under either of\n  * Apache License, Version 2.0 ([LICENSE-APACHE](https://docs.rs/postcard/latest/postcard/LICENSE-APACHE) or <http://www.apache.org/licenses/LICENSE-2.0>)\n  * MIT license ([LICENSE-MIT](https://docs.rs/postcard/latest/postcard/LICENSE-MIT) or <http://opensource.org/licenses/MIT>)\n\n\nat your option.\n#### [\u00a7](https://docs.rs/postcard/latest/postcard/#contribution)Contribution\nUnless you explicitly state otherwise, any contribution intentionally submitted for inclusion in the work by you, as defined in the Apache-2.0 license, shall be dual licensed as above, without any additional terms or conditions.\n## Modules[\u00a7](https://docs.rs/postcard/latest/postcard/#modules)\n\n[accumulator](https://docs.rs/postcard/latest/postcard/accumulator/index.html \"mod postcard::accumulator\")\n    An accumulator used to collect chunked COBS data and deserialize it.\n\n[de_flavors](https://docs.rs/postcard/latest/postcard/de_flavors/index.html \"mod postcard::de_flavors\")\n    Deserialization Flavors\n\n[experimental](https://docs.rs/postcard/latest/postcard/experimental/index.html \"mod postcard::experimental\")\n    Experimental Postcard Features\n\n[fixint](https://docs.rs/postcard/latest/postcard/fixint/index.html \"mod postcard::fixint\")\n    Fixed Size Integers\n\n[ser_flavors](https://docs.rs/postcard/latest/postcard/ser_flavors/index.html \"mod postcard::ser_flavors\")\n    Serialization Flavors\n## Structs[\u00a7](https://docs.rs/postcard/latest/postcard/#structs)\n\n[Deserializer](https://docs.rs/postcard/latest/postcard/struct.Deserializer.html \"struct postcard::Deserializer\")\n    A `serde` compatible deserializer, generic over \u201cFlavors\u201d of deserializing plugins.\n\n[Serializer](https://docs.rs/postcard/latest/postcard/struct.Serializer.html \"struct postcard::Serializer\")\n    A `serde` compatible serializer, generic over \u201cFlavors\u201d of serializing plugins.\n## Enums[\u00a7](https://docs.rs/postcard/latest/postcard/#enums)\n\n[Error](https://docs.rs/postcard/latest/postcard/enum.Error.html \"enum postcard::Error\")\n    This is the error type used by Postcard\n## Functions[\u00a7](https://docs.rs/postcard/latest/postcard/#functions)\n\n[from_bytes](https://docs.rs/postcard/latest/postcard/fn.from_bytes.html \"fn postcard::from_bytes\")\n    Deserialize a message of type `T` from a byte slice. The unused portion (if any) of the byte slice is not returned.\n\n[from_bytes_cobs](https://docs.rs/postcard/latest/postcard/fn.from_bytes_cobs.html \"fn postcard::from_bytes_cobs\")\n    Deserialize a message of type `T` from a cobs-encoded byte slice.\n\n[from_bytes_crc32](https://docs.rs/postcard/latest/postcard/fn.from_bytes_crc32.html \"fn postcard::from_bytes_crc32\")\n    Conveniently deserialize a message of type `T` from a byte slice with a Crc. The unused portion (if any) of the byte slice is not returned.\n\n[from_eio](https://docs.rs/postcard/latest/postcard/fn.from_eio.html \"fn postcard::from_eio\")\n    Deserialize a message of type `T` from a [`embedded_io`](https://docs.rs/embedded-io/0.6.1/x86_64-unknown-linux-gnu/embedded_io/index.html \"mod embedded_io\")::[`Read`](https://docs.rs/embedded-io/0.6.1/x86_64-unknown-linux-gnu/embedded_io/trait.Read.html \"trait embedded_io::Read\").\n\n[from_io](https://docs.rs/postcard/latest/postcard/fn.from_io.html \"fn postcard::from_io\")\n    Deserialize a message of type `T` from a [`std::io::Read`](https://doc.rust-lang.org/nightly/std/io/trait.Read.html \"trait std::io::Read\").\n\n[serialize_with_flavor](https://docs.rs/postcard/latest/postcard/fn.serialize_with_flavor.html \"fn postcard::serialize_with_flavor\")\n    `serialize_with_flavor()` has three generic parameters, `T, F, O`.\n\n[take_from_bytes](https://docs.rs/postcard/latest/postcard/fn.take_from_bytes.html \"fn postcard::take_from_bytes\")\n    Deserialize a message of type `T` from a byte slice. The unused portion (if any) of the byte slice is returned for further usage\n\n[take_from_bytes_cobs](https://docs.rs/postcard/latest/postcard/fn.take_from_bytes_cobs.html \"fn postcard::take_from_bytes_cobs\")\n    Deserialize a message of type `T` from a cobs-encoded byte slice.\n\n[take_from_bytes_crc32](https://docs.rs/postcard/latest/postcard/fn.take_from_bytes_crc32.html \"fn postcard::take_from_bytes_crc32\")\n    Conveniently deserialize a message of type `T` from a byte slice with a Crc. The unused portion (if any) of the byte slice is returned for further usage\n\n[to_allocvec](https://docs.rs/postcard/latest/postcard/fn.to_allocvec.html \"fn postcard::to_allocvec\")\n    Serialize a `T` to an `alloc::vec::Vec<u8>`.\n\n[to_allocvec_cobs](https://docs.rs/postcard/latest/postcard/fn.to_allocvec_cobs.html \"fn postcard::to_allocvec_cobs\")\n    Serialize and COBS encode a `T` to an `alloc::vec::Vec<u8>`.\n\n[to_allocvec_crc32](https://docs.rs/postcard/latest/postcard/fn.to_allocvec_crc32.html \"fn postcard::to_allocvec_crc32\")\n    Conveniently serialize a `T` to a `heapless::Vec<u8>`, with the `Vec` containing data followed by a 32-bit CRC. The CRC bytes are included in the output `Vec`.\n\n[to_eio](https://docs.rs/postcard/latest/postcard/fn.to_eio.html \"fn postcard::to_eio\")\n    Serialize a `T` to an [`embedded_io Write`](https://docs.rs/embedded-io/0.6.1/x86_64-unknown-linux-gnu/embedded_io/trait.Write.html \"trait embedded_io::Write\"),\n\n[to_extend](https://docs.rs/postcard/latest/postcard/fn.to_extend.html \"fn postcard::to_extend\")\n    Serialize a `T` to a [`core::iter::Extend`](https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.Extend.html \"trait core::iter::traits::collect::Extend\"),\n\n[to_io](https://docs.rs/postcard/latest/postcard/fn.to_io.html \"fn postcard::to_io\")\n    Serialize a `T` to a [`std::io::Write`](https://doc.rust-lang.org/nightly/std/io/trait.Write.html \"trait std::io::Write\"),\n\n[to_slice](https://docs.rs/postcard/latest/postcard/fn.to_slice.html \"fn postcard::to_slice\")\n    Serialize a `T` to the given slice, with the resulting slice containing data in a serialized format.\n\n[to_slice_cobs](https://docs.rs/postcard/latest/postcard/fn.to_slice_cobs.html \"fn postcard::to_slice_cobs\")\n    Serialize a `T` to the given slice, with the resulting slice containing data in a serialized then COBS encoded format. The terminating sentinel `0x00` byte is included in the output buffer.\n\n[to_slice_crc32](https://docs.rs/postcard/latest/postcard/fn.to_slice_crc32.html \"fn postcard::to_slice_crc32\")\n    Conveniently serialize a `T` to the given slice, with the resulting slice containing data followed by a 32-bit CRC. The CRC bytes are included in the output buffer.\n\n[to_stdvec](https://docs.rs/postcard/latest/postcard/fn.to_stdvec.html \"fn postcard::to_stdvec\")\n    Serialize a `T` to a `std::vec::Vec<u8>`.\n\n[to_stdvec_cobs](https://docs.rs/postcard/latest/postcard/fn.to_stdvec_cobs.html \"fn postcard::to_stdvec_cobs\")\n    Serialize and COBS encode a `T` to a `std::vec::Vec<u8>`.\n\n[to_stdvec_crc32](https://docs.rs/postcard/latest/postcard/fn.to_stdvec_crc32.html \"fn postcard::to_stdvec_crc32\")\n    Conveniently serialize a `T` to a `heapless::Vec<u8>`, with the `Vec` containing data followed by a 32-bit CRC. The CRC bytes are included in the output `Vec`.\n\n[to_vec](https://docs.rs/postcard/latest/postcard/fn.to_vec.html \"fn postcard::to_vec\")\n    Serialize a `T` to a `heapless::Vec<u8>`, with the `Vec` containing data in a serialized format.\n\n[to_vec_cobs](https://docs.rs/postcard/latest/postcard/fn.to_vec_cobs.html \"fn postcard::to_vec_cobs\")\n    Serialize a `T` to a `heapless::Vec<u8>`, with the `Vec` containing data in a serialized then COBS encoded format. The terminating sentinel `0x00` byte is included in the output `Vec`.\n\n[to_vec_crc32](https://docs.rs/postcard/latest/postcard/fn.to_vec_crc32.html \"fn postcard::to_vec_crc32\")\n    Conveniently serialize a `T` to a `heapless::Vec<u8>`, with the `Vec` containing data followed by a 32-bit CRC. The CRC bytes are included in the output `Vec`.\n## Type Aliases[\u00a7](https://docs.rs/postcard/latest/postcard/#types)\n\n[Result](https://docs.rs/postcard/latest/postcard/type.Result.html \"type postcard::Result\")\n    This is the Result type used by Postcard.\n",
        "markdown_with_citations": "[](https://docs.rs/postcard/latest/postcard/all.html \"show sidebar\")\n# Crate postcardCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\n## \u00a7\u27e84\u27e9Postcard\n![Documentation\u27e85\u27e9](https://docs.rs/postcard)\nPostcard is a `#![no_std]` focused serializer and deserializer for Serde.\nPostcard aims to be convenient for developers in constrained environments, while allowing for flexibility to customize behavior as needed.\n### \u00a7\u27e86\u27e9Design Goals\n  1. Design primarily for `#![no_std]` usage, in embedded or other constrained contexts\n  2. Support a maximal set of `serde` features, so `postcard` can be used as a drop in replacement\n  3. Avoid special differences in code between communication code written for a microcontroller or a desktop/server PC\n  4. Be resource efficient - memory usage, code size, developer time, and CPU time; in that order\n  5. Allow library users to customize the serialization and deserialization behavior to fit their bespoke needs\n\n\n### \u00a7\u27e87\u27e9Format Stability\nAs of v1.0.0, `postcard` has a documented and stable wire format. More information about this wire format can be found in the `spec/` folder of the Postcard repository, or viewed online at <https://postcard.jamesmunns.com>.\nWork towards the Postcard Specification and portions of the Postcard 1.0 Release were sponsored by Mozilla Corporation.\n### \u00a7\u27e88\u27e9Variable Length Data\nAll signed and unsigned integers larger than eight bits are encoded using a Varint\u27e89\u27e9. This includes the length of array slices, as well as the discriminant of `enums`.\nFor more information, see the Varint\u27e89\u27e9 chapter of the wire specification.\n### \u00a7\u27e810\u27e9Example - Serialization/Deserialization\nPostcard can serialize and deserialize messages similar to other `serde` formats.\nUsing the default `heapless` feature to serialize to a `heapless::Vec<u8>`:\n```\nuse core::ops::Deref;\nuse serde::{Serialize, Deserialize};\nuse postcard::{from_bytes, to_vec};\nuse heapless::Vec;\n#[derive(Serialize, Deserialize, Debug, Eq, PartialEq)]\nstruct RefStruct<'a> {\n  bytes: &'a [u8],\n  str_s: &'a str,\n}\nlet message = \"hElLo\";\nlet bytes = [0x01, 0x10, 0x02, 0x20];\nlet output: Vec<u8, 11> = to_vec(&RefStruct {\n  bytes: &bytes,\n  str_s: message,\n}).unwrap();\nassert_eq!(\n  &[0x04, 0x01, 0x10, 0x02, 0x20, 0x05, b'h', b'E', b'l', b'L', b'o',],\n  output.deref()\n);\nlet out: RefStruct = from_bytes(output.deref()).unwrap();\nassert_eq!(\n  out,\n  RefStruct {\n    bytes: &bytes,\n    str_s: message,\n  }\n);\n```\n\nOr the optional `alloc` feature to serialize to an `alloc::vec::Vec<u8>`:\n```\nuse core::ops::Deref;\nuse serde::{Serialize, Deserialize};\nuse postcard::{from_bytes, to_allocvec};\nextern crate alloc;\nuse alloc::vec::Vec;\n#[derive(Serialize, Deserialize, Debug, Eq, PartialEq)]\nstruct RefStruct<'a> {\n  bytes: &'a [u8],\n  str_s: &'a str,\n}\nlet message = \"hElLo\";\nlet bytes = [0x01, 0x10, 0x02, 0x20];\nlet output: Vec<u8> = to_allocvec(&RefStruct {\n  bytes: &bytes,\n  str_s: message,\n}).unwrap();\nassert_eq!(\n  &[0x04, 0x01, 0x10, 0x02, 0x20, 0x05, b'h', b'E', b'l', b'L', b'o',],\n  output.deref()\n);\nlet out: RefStruct = from_bytes(output.deref()).unwrap();\nassert_eq!(\n  out,\n  RefStruct {\n    bytes: &bytes,\n    str_s: message,\n  }\n);\n```\n\n### \u00a7\u27e811\u27e9Flavors\n`postcard` supports a system called `Flavors`, which are used to modify the way postcard serializes or processes serialized data. These flavors act as \u201cplugins\u201d or \u201cmiddlewares\u201d during the serialization or deserialization process, and can be combined to obtain complex protocol formats.\nSee the documentation of the `ser_flavors` or `de_flavors` modules for more information on usage.\n### \u00a7\u27e812\u27e9Setup - `Cargo.toml`\nDon\u2019t forget to add the `no-std` subset\u27e813\u27e9 of `serde` along with `postcard` to the `[dependencies]` section of your `Cargo.toml`!\n```\n[dependencies]\npostcard = \"1.0.0\"\n# By default, `serde` has the `std` feature enabled, which makes it unsuitable for embedded targets\n# disabling default-features fixes this\nserde = { version = \"1.0.*\", default-features = false }\n```\n\n### \u00a7\u27e814\u27e9License\nLicensed under either of\n  * Apache License, Version 2.0 (LICENSE-APACHE\u27e815\u27e9 or <http://www.apache.org/licenses/LICENSE-2.0>)\n  * MIT license (LICENSE-MIT\u27e816\u27e9 or <http://opensource.org/licenses/MIT>)\n\n\nat your option.\n#### \u00a7\u27e817\u27e9Contribution\nUnless you explicitly state otherwise, any contribution intentionally submitted for inclusion in the work by you, as defined in the Apache-2.0 license, shall be dual licensed as above, without any additional terms or conditions.\n## Modules\u00a7\u27e818\u27e9\n\naccumulator\u27e819\u27e9\n    An accumulator used to collect chunked COBS data and deserialize it.\n\nde_flavors\u27e820\u27e9\n    Deserialization Flavors\n\nexperimental\u27e821\u27e9\n    Experimental Postcard Features\n\nfixint\u27e822\u27e9\n    Fixed Size Integers\n\nser_flavors\u27e823\u27e9\n    Serialization Flavors\n## Structs\u00a7\u27e824\u27e9\n\nDeserializer\u27e825\u27e9\n    A `serde` compatible deserializer, generic over \u201cFlavors\u201d of deserializing plugins.\n\nSerializer\u27e826\u27e9\n    A `serde` compatible serializer, generic over \u201cFlavors\u201d of serializing plugins.\n## Enums\u00a7\u27e827\u27e9\n\nError\u27e828\u27e9\n    This is the error type used by Postcard\n## Functions\u00a7\u27e829\u27e9\n\nfrom_bytes\u27e830\u27e9\n    Deserialize a message of type `T` from a byte slice. The unused portion (if any) of the byte slice is not returned.\n\nfrom_bytes_cobs\u27e831\u27e9\n    Deserialize a message of type `T` from a cobs-encoded byte slice.\n\nfrom_bytes_crc32\u27e832\u27e9\n    Conveniently deserialize a message of type `T` from a byte slice with a Crc. The unused portion (if any) of the byte slice is not returned.\n\nfrom_eio\u27e833\u27e9\n    Deserialize a message of type `T` from a `embedded_io`\u27e834\u27e9::`Read`\u27e835\u27e9.\n\nfrom_io\u27e836\u27e9\n    Deserialize a message of type `T` from a `std::io::Read`\u27e837\u27e9.\n\nserialize_with_flavor\u27e838\u27e9\n    `serialize_with_flavor()` has three generic parameters, `T, F, O`.\n\ntake_from_bytes\u27e839\u27e9\n    Deserialize a message of type `T` from a byte slice. The unused portion (if any) of the byte slice is returned for further usage\n\ntake_from_bytes_cobs\u27e840\u27e9\n    Deserialize a message of type `T` from a cobs-encoded byte slice.\n\ntake_from_bytes_crc32\u27e841\u27e9\n    Conveniently deserialize a message of type `T` from a byte slice with a Crc. The unused portion (if any) of the byte slice is returned for further usage\n\nto_allocvec\u27e842\u27e9\n    Serialize a `T` to an `alloc::vec::Vec<u8>`.\n\nto_allocvec_cobs\u27e843\u27e9\n    Serialize and COBS encode a `T` to an `alloc::vec::Vec<u8>`.\n\nto_allocvec_crc32\u27e844\u27e9\n    Conveniently serialize a `T` to a `heapless::Vec<u8>`, with the `Vec` containing data followed by a 32-bit CRC. The CRC bytes are included in the output `Vec`.\n\nto_eio\u27e845\u27e9\n    Serialize a `T` to an `embedded_io Write`\u27e846\u27e9,\n\nto_extend\u27e847\u27e9\n    Serialize a `T` to a `core::iter::Extend`\u27e848\u27e9,\n\nto_io\u27e849\u27e9\n    Serialize a `T` to a `std::io::Write`\u27e850\u27e9,\n\nto_slice\u27e851\u27e9\n    Serialize a `T` to the given slice, with the resulting slice containing data in a serialized format.\n\nto_slice_cobs\u27e852\u27e9\n    Serialize a `T` to the given slice, with the resulting slice containing data in a serialized then COBS encoded format. The terminating sentinel `0x00` byte is included in the output buffer.\n\nto_slice_crc32\u27e853\u27e9\n    Conveniently serialize a `T` to the given slice, with the resulting slice containing data followed by a 32-bit CRC. The CRC bytes are included in the output buffer.\n\nto_stdvec\u27e854\u27e9\n    Serialize a `T` to a `std::vec::Vec<u8>`.\n\nto_stdvec_cobs\u27e855\u27e9\n    Serialize and COBS encode a `T` to a `std::vec::Vec<u8>`.\n\nto_stdvec_crc32\u27e856\u27e9\n    Conveniently serialize a `T` to a `heapless::Vec<u8>`, with the `Vec` containing data followed by a 32-bit CRC. The CRC bytes are included in the output `Vec`.\n\nto_vec\u27e857\u27e9\n    Serialize a `T` to a `heapless::Vec<u8>`, with the `Vec` containing data in a serialized format.\n\nto_vec_cobs\u27e858\u27e9\n    Serialize a `T` to a `heapless::Vec<u8>`, with the `Vec` containing data in a serialized then COBS encoded format. The terminating sentinel `0x00` byte is included in the output `Vec`.\n\nto_vec_crc32\u27e859\u27e9\n    Conveniently serialize a `T` to a `heapless::Vec<u8>`, with the `Vec` containing data followed by a 32-bit CRC. The CRC bytes are included in the output `Vec`.\n## Type Aliases\u00a7\u27e860\u27e9\n\nResult\u27e861\u27e9\n    This is the Result type used by Postcard.\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/postcard/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/postcard/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/postcard/latest/src/postcard/lib.rs.html#1-125: Source\n\u27e84\u27e9 https://docs.rs/postcard/latest/postcard/#postcard: \u00a7\n\u27e85\u27e9 https://docs.rs/postcard/badge.svg: ![Documentation\n\u27e86\u27e9 https://docs.rs/postcard/latest/postcard/#design-goals: \u00a7\n\u27e87\u27e9 https://docs.rs/postcard/latest/postcard/#format-stability: \u00a7\n\u27e88\u27e9 https://docs.rs/postcard/latest/postcard/#variable-length-data: \u00a7\n\u27e89\u27e9 https://postcard.jamesmunns.com/wire-format.html#varint-encoded-integers: Varint\n\u27e810\u27e9 https://docs.rs/postcard/latest/postcard/#example---serializationdeserialization: \u00a7\n\u27e811\u27e9 https://docs.rs/postcard/latest/postcard/#flavors: \u00a7\n\u27e812\u27e9 https://docs.rs/postcard/latest/postcard/#setup---cargotoml: \u00a7\n\u27e813\u27e9 https://serde.rs/no-std.html: the `no-std` subset\n\u27e814\u27e9 https://docs.rs/postcard/latest/postcard/#license: \u00a7\n\u27e815\u27e9 https://docs.rs/postcard/latest/postcard/LICENSE-APACHE: LICENSE-APACHE\n\u27e816\u27e9 https://docs.rs/postcard/latest/postcard/LICENSE-MIT: LICENSE-MIT\n\u27e817\u27e9 https://docs.rs/postcard/latest/postcard/#contribution: \u00a7\n\u27e818\u27e9 https://docs.rs/postcard/latest/postcard/#modules: \u00a7\n\u27e819\u27e9 https://docs.rs/postcard/latest/postcard/accumulator/index.html: mod postcard::accumulator - accumulator\n\u27e820\u27e9 https://docs.rs/postcard/latest/postcard/de_flavors/index.html: mod postcard::de_flavors - de_flavors\n\u27e821\u27e9 https://docs.rs/postcard/latest/postcard/experimental/index.html: mod postcard::experimental - experimental\n\u27e822\u27e9 https://docs.rs/postcard/latest/postcard/fixint/index.html: mod postcard::fixint - fixint\n\u27e823\u27e9 https://docs.rs/postcard/latest/postcard/ser_flavors/index.html: mod postcard::ser_flavors - ser_flavors\n\u27e824\u27e9 https://docs.rs/postcard/latest/postcard/#structs: \u00a7\n\u27e825\u27e9 https://docs.rs/postcard/latest/postcard/struct.Deserializer.html: struct postcard::Deserializer - Deserializer\n\u27e826\u27e9 https://docs.rs/postcard/latest/postcard/struct.Serializer.html: struct postcard::Serializer - Serializer\n\u27e827\u27e9 https://docs.rs/postcard/latest/postcard/#enums: \u00a7\n\u27e828\u27e9 https://docs.rs/postcard/latest/postcard/enum.Error.html: enum postcard::Error - Error\n\u27e829\u27e9 https://docs.rs/postcard/latest/postcard/#functions: \u00a7\n\u27e830\u27e9 https://docs.rs/postcard/latest/postcard/fn.from_bytes.html: fn postcard::from_bytes - from_bytes\n\u27e831\u27e9 https://docs.rs/postcard/latest/postcard/fn.from_bytes_cobs.html: fn postcard::from_bytes_cobs - from_bytes_cobs\n\u27e832\u27e9 https://docs.rs/postcard/latest/postcard/fn.from_bytes_crc32.html: fn postcard::from_bytes_crc32 - from_bytes_crc32\n\u27e833\u27e9 https://docs.rs/postcard/latest/postcard/fn.from_eio.html: fn postcard::from_eio - from_eio\n\u27e834\u27e9 https://docs.rs/embedded-io/0.6.1/x86_64-unknown-linux-gnu/embedded_io/index.html: mod embedded_io - `embedded_io`\n\u27e835\u27e9 https://docs.rs/embedded-io/0.6.1/x86_64-unknown-linux-gnu/embedded_io/trait.Read.html: trait embedded_io::Read - `Read`\n\u27e836\u27e9 https://docs.rs/postcard/latest/postcard/fn.from_io.html: fn postcard::from_io - from_io\n\u27e837\u27e9 https://doc.rust-lang.org/nightly/std/io/trait.Read.html: trait std::io::Read - `std::io::Read`\n\u27e838\u27e9 https://docs.rs/postcard/latest/postcard/fn.serialize_with_flavor.html: fn postcard::serialize_with_flavor - serialize_with_flavor\n\u27e839\u27e9 https://docs.rs/postcard/latest/postcard/fn.take_from_bytes.html: fn postcard::take_from_bytes - take_from_bytes\n\u27e840\u27e9 https://docs.rs/postcard/latest/postcard/fn.take_from_bytes_cobs.html: fn postcard::take_from_bytes_cobs - take_from_bytes_cobs\n\u27e841\u27e9 https://docs.rs/postcard/latest/postcard/fn.take_from_bytes_crc32.html: fn postcard::take_from_bytes_crc32 - take_from_bytes_crc32\n\u27e842\u27e9 https://docs.rs/postcard/latest/postcard/fn.to_allocvec.html: fn postcard::to_allocvec - to_allocvec\n\u27e843\u27e9 https://docs.rs/postcard/latest/postcard/fn.to_allocvec_cobs.html: fn postcard::to_allocvec_cobs - to_allocvec_cobs\n\u27e844\u27e9 https://docs.rs/postcard/latest/postcard/fn.to_allocvec_crc32.html: fn postcard::to_allocvec_crc32 - to_allocvec_crc32\n\u27e845\u27e9 https://docs.rs/postcard/latest/postcard/fn.to_eio.html: fn postcard::to_eio - to_eio\n\u27e846\u27e9 https://docs.rs/embedded-io/0.6.1/x86_64-unknown-linux-gnu/embedded_io/trait.Write.html: trait embedded_io::Write - `embedded_io Write`\n\u27e847\u27e9 https://docs.rs/postcard/latest/postcard/fn.to_extend.html: fn postcard::to_extend - to_extend\n\u27e848\u27e9 https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.Extend.html: trait core::iter::traits::collect::Extend - `core::iter::Extend`\n\u27e849\u27e9 https://docs.rs/postcard/latest/postcard/fn.to_io.html: fn postcard::to_io - to_io\n\u27e850\u27e9 https://doc.rust-lang.org/nightly/std/io/trait.Write.html: trait std::io::Write - `std::io::Write`\n\u27e851\u27e9 https://docs.rs/postcard/latest/postcard/fn.to_slice.html: fn postcard::to_slice - to_slice\n\u27e852\u27e9 https://docs.rs/postcard/latest/postcard/fn.to_slice_cobs.html: fn postcard::to_slice_cobs - to_slice_cobs\n\u27e853\u27e9 https://docs.rs/postcard/latest/postcard/fn.to_slice_crc32.html: fn postcard::to_slice_crc32 - to_slice_crc32\n\u27e854\u27e9 https://docs.rs/postcard/latest/postcard/fn.to_stdvec.html: fn postcard::to_stdvec - to_stdvec\n\u27e855\u27e9 https://docs.rs/postcard/latest/postcard/fn.to_stdvec_cobs.html: fn postcard::to_stdvec_cobs - to_stdvec_cobs\n\u27e856\u27e9 https://docs.rs/postcard/latest/postcard/fn.to_stdvec_crc32.html: fn postcard::to_stdvec_crc32 - to_stdvec_crc32\n\u27e857\u27e9 https://docs.rs/postcard/latest/postcard/fn.to_vec.html: fn postcard::to_vec - to_vec\n\u27e858\u27e9 https://docs.rs/postcard/latest/postcard/fn.to_vec_cobs.html: fn postcard::to_vec_cobs - to_vec_cobs\n\u27e859\u27e9 https://docs.rs/postcard/latest/postcard/fn.to_vec_crc32.html: fn postcard::to_vec_crc32 - to_vec_crc32\n\u27e860\u27e9 https://docs.rs/postcard/latest/postcard/#types: \u00a7\n\u27e861\u27e9 https://docs.rs/postcard/latest/postcard/type.Result.html: type postcard::Result - Result\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `postcard` crate is a `#![no_std]`-focused serializer and deserializer for `serde`, designed for resource-constrained environments like embedded systems. It offers a stable wire format, efficient serialization using variable-length encoding (Varint), and supports customizable serialization behaviors through \"Flavors\" middleware. Additionally, it provides compatibility with both heapless and alloc-based data structures for flexible usage.",
    "feature_summary": null,
    "use_case": "Serialization",
    "score": 8.0,
    "factual_counterfactual": "### Pair 1: Serialization and Deserialization\n\u2705 **Factual:** `postcard` supports serialization and deserialization of data using the `serde` framework, making it compatible with both `heapless::Vec<u8>` and `alloc::vec::Vec<u8>` for constrained environments.  \n\u274c **Counterfactual:** `postcard` requires the `std` library and cannot be used in `#![no_std]` environments, limiting its use in embedded systems.  \n\n---\n\n### Pair 2: Format Stability\n\u2705 **Factual:** As of version 1.0.0, `postcard` provides a stable and documented wire format, ensuring compatibility across versions for serialized data.  \n\u274c **Counterfactual:** The wire format of `postcard` changes with every minor version update, making it unsuitable for long-term compatibility in embedded systems.  \n\n---\n\n### Pair 3: Variable-Length Data Encoding\n\u2705 **Factual:** `postcard` encodes integers larger than eight bits using a Varint format, optimizing memory usage for variable-length data.  \n\u274c **Counterfactual:** `postcard` encodes all integers using fixed-width formats, leading to inefficient memory usage for small values in constrained environments.",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}