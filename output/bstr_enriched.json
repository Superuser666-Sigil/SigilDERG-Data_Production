{
    "name": "bstr",
    "version": "1.12.0",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/bstr/latest/bstr/all.html \"show sidebar\")\n# Crate bstrCopy item path\n[Settings](https://docs.rs/bstr/latest/settings.html)\n[Help](https://docs.rs/bstr/latest/help.html)\nSummary[Source](https://docs.rs/bstr/latest/src/bstr/lib.rs.html#1-474)\nExpand description\nA byte string library.\nByte strings are just like standard Unicode strings with one very important difference: byte strings are only _conventionally_ UTF-8 while Rust\u2019s standard Unicode strings are _guaranteed_ to be valid UTF-8. The primary motivation for byte strings is for handling arbitrary bytes that are mostly UTF-8.\n## [\u00a7](https://docs.rs/bstr/latest/bstr/#overview)Overview\nThis crate provides two important traits that provide string oriented methods on `&[u8]` and `Vec<u8>` types:\n  * [`ByteSlice`](https://docs.rs/bstr/latest/bstr/trait.ByteSlice.html) extends the `[u8]` type with additional string oriented methods.\n  * [`ByteVec`](https://docs.rs/bstr/latest/bstr/trait.ByteVec.html) extends the `Vec<u8>` type with additional string oriented methods.\n\n\nAdditionally, this crate provides two concrete byte string types that deref to `[u8]` and `Vec<u8>`. These are useful for storing byte string types, and come with convenient `std::fmt::Debug` implementations:\n  * [`BStr`](https://docs.rs/bstr/latest/bstr/struct.BStr.html) is a byte string slice, analogous to `str`.\n  * [`BString`](https://docs.rs/bstr/latest/bstr/struct.BString.html) is an owned growable byte string buffer, analogous to `String`.\n\n\nAdditionally, the free function [`B`](https://docs.rs/bstr/latest/bstr/fn.B.html) serves as a convenient short hand for writing byte string literals.\n## [\u00a7](https://docs.rs/bstr/latest/bstr/#quick-examples)Quick examples\nByte strings build on the existing APIs for `Vec<u8>` and `&[u8]`, with additional string oriented methods. Operations such as iterating over graphemes, searching for substrings, replacing substrings, trimming and case conversion are examples of things not provided on the standard library `&[u8]` APIs but are provided by this crate. For example, this code iterates over all of occurrences of a substring:\n```\nuse bstr::ByteSlice;\nlet s = b\"foo bar foo foo quux foo\";\nlet mut matches = vec![];\nfor start in s.find_iter(\"foo\") {\n  matches.push(start);\n}\nassert_eq!(matches, [0, 8, 12, 21]);\n```\n\nHere\u2019s another example showing how to do a search and replace (and also showing use of the `B` function):\n```\nuse bstr::{B, ByteSlice};\nlet old = B(\"foo \u2603\u2603\u2603 foo foo quux foo\");\nlet new = old.replace(\"foo\", \"hello\");\nassert_eq!(new, B(\"hello \u2603\u2603\u2603 hello hello quux hello\"));\n```\n\nAnd here\u2019s an example that shows case conversion, even in the presence of invalid UTF-8:\n```\nuse bstr::{ByteSlice, ByteVec};\nlet mut lower = Vec::from(\"hello \u03b2\");\nlower[0] = b'\\xFF';\n// lowercase \u03b2 is uppercased to \u0392\nassert_eq!(lower.to_uppercase(), b\"\\xFFELLO \\xCE\\x92\");\n```\n\n## [\u00a7](https://docs.rs/bstr/latest/bstr/#convenient-debug-representation)Convenient debug representation\nWhen working with byte strings, it is often useful to be able to print them as if they were byte strings and not sequences of integers. While this crate cannot affect the `std::fmt::Debug` implementations for `[u8]` and `Vec<u8>`, this crate does provide the `BStr` and `BString` types which have convenient `std::fmt::Debug` implementations.\nFor example, this\n```\nuse bstr::ByteSlice;\nlet mut bytes = Vec::from(\"hello \u03b2\");\nbytes[0] = b'\\xFF';\nprintln!(\"{:?}\", bytes.as_bstr());\n```\n\nwill output `\"\\xFFello \u03b2\"`.\nThis example works because the [`ByteSlice::as_bstr`](https://docs.rs/bstr/latest/bstr/trait.ByteSlice.html#method.as_bstr) method converts any `&[u8]` to a `&BStr`.\n## [\u00a7](https://docs.rs/bstr/latest/bstr/#when-should-i-use-byte-strings)When should I use byte strings?\nThis library reflects my belief that UTF-8 by convention is a better trade off in some circumstances than guaranteed UTF-8.\nThe first time this idea hit me was in the implementation of Rust\u2019s regex engine. In particular, very little of the internal implementation cares at all about searching valid UTF-8 encoded strings. Indeed, internally, the implementation converts `&str` from the API to `&[u8]` fairly quickly and just deals with raw bytes. UTF-8 match boundaries are then guaranteed by the finite state machine itself rather than any specific string type. This makes it possible to not only run regexes on `&str` values, but also on `&[u8]` values.\nWhy would you ever want to run a regex on a `&[u8]` though? Well, `&[u8]` is the fundamental way at which one reads data from all sorts of streams, via the standard library\u2019s [`Read`](https://doc.rust-lang.org/std/io/trait.Read.html) trait. In particular, there is no platform independent way to determine whether what you\u2019re reading from is some binary file or a human readable text file. Therefore, if you\u2019re writing a program to search files, you probably need to deal with `&[u8]` directly unless you\u2019re okay with first converting it to a `&str` and dropping any bytes that aren\u2019t valid UTF-8. (Or otherwise determine the encoding\u2014which is often impractical\u2014and perform a transcoding step.) Often, the simplest and most robust way to approach this is to simply treat the contents of a file as if it were mostly valid UTF-8 and pass through invalid UTF-8 untouched. This may not be the most correct approach though!\nOne case in particular exacerbates these issues, and that\u2019s memory mapping a file. When you memory map a file, that file may be gigabytes big, but all you get is a `&[u8]`. Converting that to a `&str` all in one go is generally not a good idea because of the costs associated with doing so, and also because it generally causes one to do two passes over the data instead of one, which is quite undesirable. It is of course usually possible to do it an incremental way by only parsing chunks at a time, but this is often complex to do or impractical. For example, many regex engines only accept one contiguous sequence of bytes at a time with no way to perform incremental matching.\n## [\u00a7](https://docs.rs/bstr/latest/bstr/#bstr-in-public-apis)`bstr` in public APIs\nThis library is past version `1` and is expected to remain at version `1` for the foreseeable future. Therefore, it is encouraged to put types from `bstr` (like `BStr` and `BString`) in your public API if that makes sense for your crate.\nWith that said, in general, it should be possible to avoid putting anything in this crate into your public APIs. Namely, you should never need to use the `ByteSlice` or `ByteVec` traits as bounds on public APIs, since their only purpose is to extend the methods on the concrete types `[u8]` and `Vec<u8>`, respectively. Similarly, it should not be necessary to put either the `BStr` or `BString` types into public APIs. If you want to use them internally, then they can be converted to/from `[u8]`/`Vec<u8>` as needed. The conversions are free.\nSo while it shouldn\u2019t ever be 100% necessary to make `bstr` a public dependency, there may be cases where it is convenient to do so. This is an explicitly supported use case of `bstr`, and as such, major version releases should be exceptionally rare.\n## [\u00a7](https://docs.rs/bstr/latest/bstr/#differences-with-standard-strings)Differences with standard strings\nThe primary difference between `[u8]` and `str` is that the former is conventionally UTF-8 while the latter is guaranteed to be UTF-8. The phrase \u201cconventionally UTF-8\u201d means that a `[u8]` may contain bytes that do not form a valid UTF-8 sequence, but operations defined on the type in this crate are generally most useful on valid UTF-8 sequences. For example, iterating over Unicode codepoints or grapheme clusters is an operation that is only defined on valid UTF-8. Therefore, when invalid UTF-8 is encountered, the Unicode replacement codepoint is substituted. Thus, a byte string that is not UTF-8 at all is of limited utility when using these crate.\nHowever, not all operations on byte strings are specifically Unicode aware. For example, substring search has no specific Unicode semantics ascribed to it. It works just as well for byte strings that are completely valid UTF-8 as for byte strings that contain no valid UTF-8 at all. Similarly for replacements and various other operations that do not need any Unicode specific tailoring.\nAside from the difference in how UTF-8 is handled, the APIs between `[u8]` and `str` (and `Vec<u8>` and `String`) are intentionally very similar, including maintaining the same behavior for corner cases in things like substring splitting. There are, however, some differences:\n  * Substring search is not done with `matches`, but instead, `find_iter`. In general, this crate does not define any generic [`Pattern`](https://doc.rust-lang.org/std/str/pattern/trait.Pattern.html) infrastructure, and instead prefers adding new methods for different argument types. For example, `matches` can search by a `char` or a `&str`, where as `find_iter` can only search by a byte string. `find_char` can be used for searching by a `char`.\n  * Since `SliceConcatExt` in the standard library is unstable, it is not possible to reuse that to implement `join` and `concat` methods. Instead, [`join`](https://docs.rs/bstr/latest/bstr/fn.join.html) and [`concat`](https://docs.rs/bstr/latest/bstr/fn.concat.html) are provided as free functions that perform a similar task.\n  * This library bundles in a few more Unicode operations, such as grapheme, word and sentence iterators. More operations, such as normalization and case folding, may be provided in the future.\n  * Some `String`/`str` APIs will panic if a particular index was not on a valid UTF-8 code unit sequence boundary. Conversely, no such checking is performed in this crate, as is consistent with treating byte strings as a sequence of bytes. This means callers are responsible for maintaining a UTF-8 invariant if that\u2019s important.\n  * Some routines provided by this crate, such as `starts_with_str`, have a `_str` suffix to differentiate them from similar routines already defined on the `[u8]` type. The difference is that `starts_with` requires its parameter to be a `&[u8]`, where as `starts_with_str` permits its parameter to by anything that implements `AsRef<[u8]>`, which is more flexible. This means you can write `bytes.starts_with_str(\"\u2603\")` instead of `bytes.starts_with(\"\u2603\".as_bytes())`.\n\n\nOtherwise, you should find most of the APIs between this crate and the standard library string APIs to be very similar, if not identical.\n## [\u00a7](https://docs.rs/bstr/latest/bstr/#handling-of-invalid-utf-8)Handling of invalid UTF-8\nSince byte strings are only _conventionally_ UTF-8, there is no guarantee that byte strings contain valid UTF-8. Indeed, it is perfectly legal for a byte string to contain arbitrary bytes. However, since this library defines a _string_ type, it provides many operations specified by Unicode. These operations are typically only defined over codepoints, and thus have no real meaning on bytes that are invalid UTF-8 because they do not map to a particular codepoint.\nFor this reason, whenever operations defined only on codepoints are used, this library will automatically convert invalid UTF-8 to the Unicode replacement codepoint, `U+FFFD`, which looks like this: `\ufffd`. For example, an [iterator over codepoints](https://docs.rs/bstr/latest/bstr/struct.Chars.html) will yield a Unicode replacement codepoint whenever it comes across bytes that are not valid UTF-8:\n```\nuse bstr::ByteSlice;\nlet bs = b\"a\\xFF\\xFFz\";\nlet chars: Vec<char> = bs.chars().collect();\nassert_eq!(vec!['a', '\\u{FFFD}', '\\u{FFFD}', 'z'], chars);\n```\n\nThere are a few ways in which invalid bytes can be substituted with a Unicode replacement codepoint. One way, not used by this crate, is to replace every individual invalid byte with a single replacement codepoint. In contrast, the approach this crate uses is called the \u201csubstitution of maximal subparts,\u201d as specified by the Unicode Standard (Chapter 3, Section 9). (This approach is also used by [W3C\u2019s Encoding Standard](https://www.w3.org/TR/encoding/).) In this strategy, a replacement codepoint is inserted whenever a byte is found that cannot possibly lead to a valid UTF-8 code unit sequence. If there were previous bytes that represented a _prefix_ of a well-formed UTF-8 code unit sequence, then all of those bytes (up to 3) are substituted with a single replacement codepoint. For example:\n```\nuse bstr::ByteSlice;\nlet bs = b\"a\\xF0\\x9F\\x87z\";\nlet chars: Vec<char> = bs.chars().collect();\n// The bytes \\xF0\\x9F\\x87 could lead to a valid UTF-8 sequence, but 3 of them\n// on their own are invalid. Only one replacement codepoint is substituted,\n// which demonstrates the \"substitution of maximal subparts\" strategy.\nassert_eq!(vec!['a', '\\u{FFFD}', 'z'], chars);\n```\n\nIf you do need to access the raw bytes for some reason in an iterator like `Chars`, then you should use the iterator\u2019s \u201cindices\u201d variant, which gives the byte offsets containing the invalid UTF-8 bytes that were substituted with the replacement codepoint. For example:\n```\nuse bstr::{B, ByteSlice};\nlet bs = b\"a\\xE2\\x98z\";\nlet chars: Vec<(usize, usize, char)> = bs.char_indices().collect();\n// Even though the replacement codepoint is encoded as 3 bytes itself, the\n// byte range given here is only two bytes, corresponding to the original\n// raw bytes.\nassert_eq!(vec![(0, 1, 'a'), (1, 3, '\\u{FFFD}'), (3, 4, 'z')], chars);\n// Thus, getting the original raw bytes is as simple as slicing the original\n// byte string:\nlet chars: Vec<&[u8]> = bs.char_indices().map(|(s, e, _)| &bs[s..e]).collect();\nassert_eq!(vec![B(\"a\"), B(b\"\\xE2\\x98\"), B(\"z\")], chars);\n```\n\n## [\u00a7](https://docs.rs/bstr/latest/bstr/#file-paths-and-os-strings)File paths and OS strings\nOne of the premiere features of Rust\u2019s standard library is how it handles file paths. In particular, it makes it very hard to write incorrect code while simultaneously providing a correct cross platform abstraction for manipulating file paths. The key challenge that one faces with file paths across platforms is derived from the following observations:\n  * On most Unix-like systems, file paths are an arbitrary sequence of bytes.\n  * On Windows, file paths are an arbitrary sequence of 16-bit integers.\n\n\n(In both cases, certain sequences aren\u2019t allowed. For example a `NUL` byte is not allowed in either case. But we can ignore this for the purposes of this section.)\nByte strings, like the ones provided in this crate, line up really well with file paths on Unix like systems, which are themselves just arbitrary sequences of bytes. It turns out that if you treat them as \u201cmostly UTF-8,\u201d then things work out pretty well. On the contrary, byte strings _don\u2019t_ really work that well on Windows because it\u2019s not possible to correctly roundtrip file paths between 16-bit integers and something that looks like UTF-8 _without_ explicitly defining an encoding to do this for you, which is anathema to byte strings, which are just bytes.\nRust\u2019s standard library elegantly solves this problem by specifying an internal encoding for file paths that\u2019s only used on Windows called [WTF-8](https://simonsapin.github.io/wtf-8/). Its key properties are that they permit losslessly roundtripping file paths on Windows by extending UTF-8 to support an encoding of surrogate codepoints, while simultaneously supporting zero-cost conversion from Rust\u2019s Unicode strings to file paths. (Since UTF-8 is a proper subset of WTF-8.)\nThe fundamental point at which the above strategy fails is when you want to treat file paths as things that look like strings in a zero cost way. In most cases, this is actually the wrong thing to do, but some cases call for it, for example, glob or regex matching on file paths. This is because WTF-8 is treated as an internal implementation detail, and there is no way to access those bytes via a public API. Therefore, such consumers are limited in what they can do:\n  1. One could re-implement WTF-8 and re-encode file paths on Windows to WTF-8 by accessing their underlying 16-bit integer representation. Unfortunately, this isn\u2019t zero cost (it introduces a second WTF-8 decoding step) and it\u2019s not clear this is a good thing to do, since WTF-8 should ideally remain an internal implementation detail. This is roughly the approach taken by the [`os_str_bytes`](https://crates.io/crates/os_str_bytes) crate.\n  2. One could instead declare that they will not handle paths on Windows that are not valid UTF-16, and return an error when one is encountered.\n  3. Like (2), but instead of returning an error, lossily decode the file path on Windows that isn\u2019t valid UTF-16 into UTF-16 by replacing invalid bytes with the Unicode replacement codepoint.\n\n\nWhile this library may provide facilities for (1) in the future, currently, this library only provides facilities for (2) and (3). In particular, a suite of conversion functions are provided that permit converting between byte strings, OS strings and file paths. For owned byte strings, they are:\n  * [`ByteVec::from_os_string`](https://docs.rs/bstr/latest/bstr/trait.ByteVec.html#method.from_os_string)\n  * [`ByteVec::from_os_str_lossy`](https://docs.rs/bstr/latest/bstr/trait.ByteVec.html#method.from_os_str_lossy)\n  * [`ByteVec::from_path_buf`](https://docs.rs/bstr/latest/bstr/trait.ByteVec.html#method.from_path_buf)\n  * [`ByteVec::from_path_lossy`](https://docs.rs/bstr/latest/bstr/trait.ByteVec.html#method.from_path_lossy)\n  * [`ByteVec::into_os_string`](https://docs.rs/bstr/latest/bstr/trait.ByteVec.html#method.into_os_string)\n  * [`ByteVec::into_os_string_lossy`](https://docs.rs/bstr/latest/bstr/trait.ByteVec.html#method.into_os_string_lossy)\n  * [`ByteVec::into_path_buf`](https://docs.rs/bstr/latest/bstr/trait.ByteVec.html#method.into_path_buf)\n  * [`ByteVec::into_path_buf_lossy`](https://docs.rs/bstr/latest/bstr/trait.ByteVec.html#method.into_path_buf_lossy)\n\n\nFor byte string slices, they are:\n  * [`ByteSlice::from_os_str`](https://docs.rs/bstr/latest/bstr/trait.ByteSlice.html#method.from_os_str)\n  * [`ByteSlice::from_path`](https://docs.rs/bstr/latest/bstr/trait.ByteSlice.html#method.from_path)\n  * [`ByteSlice::to_os_str`](https://docs.rs/bstr/latest/bstr/trait.ByteSlice.html#method.to_os_str)\n  * [`ByteSlice::to_os_str_lossy`](https://docs.rs/bstr/latest/bstr/trait.ByteSlice.html#method.to_os_str_lossy)\n  * [`ByteSlice::to_path`](https://docs.rs/bstr/latest/bstr/trait.ByteSlice.html#method.to_path)\n  * [`ByteSlice::to_path_lossy`](https://docs.rs/bstr/latest/bstr/trait.ByteSlice.html#method.to_path_lossy)\n\n\nOn Unix, all of these conversions are rigorously zero cost, which gives one a way to ergonomically deal with raw file paths exactly as they are using normal string-related functions. On Windows, these conversion routines perform a UTF-8 check and either return an error or lossily decode the file path into valid UTF-8, depending on which function you use. This means that you cannot roundtrip all file paths on Windows correctly using these conversion routines. However, this may be an acceptable downside since such file paths are exceptionally rare. Moreover, roundtripping isn\u2019t always necessary, for example, if all you\u2019re doing is filtering based on file paths.\nThe reason why using byte strings for this is potentially superior than the standard library\u2019s approach is that a lot of Rust code is already lossily converting file paths to Rust\u2019s Unicode strings, which are required to be valid UTF-8, and thus contain latent bugs on Unix where paths with invalid UTF-8 are not terribly uncommon. If you instead use byte strings, then you\u2019re guaranteed to write correct code for Unix, at the cost of getting a corner case wrong on Windows.\n## [\u00a7](https://docs.rs/bstr/latest/bstr/#cargo-features)Cargo features\nThis crates comes with a few features that control standard library, serde and Unicode support.\n  * `std` - **Enabled** by default. This provides APIs that require the standard library, such as `Vec<u8>` and `PathBuf`. Enabling this feature also enables the `alloc` feature and any other relevant `std` features for dependencies.\n  * `alloc` - **Enabled** by default. This provides APIs that require allocations via the `alloc` crate, such as `Vec<u8>`.\n  * `unicode` - **Enabled** by default. This provides APIs that require sizable Unicode data compiled into the binary. This includes, but is not limited to, grapheme/word/sentence segmenters. When this is disabled, basic support such as UTF-8 decoding is still included. Note that currently, enabling this feature also requires enabling the `std` feature. It is expected that this limitation will be lifted at some point.\n  * `serde` - Enables implementations of serde traits for `BStr`, and also `BString` when `alloc` is enabled.\n\n\n## Modules[\u00a7](https://docs.rs/bstr/latest/bstr/#modules)\n\n[io](https://docs.rs/bstr/latest/bstr/io/index.html \"mod bstr::io\")`std`\n    Utilities for working with I/O using byte strings.\n## Structs[\u00a7](https://docs.rs/bstr/latest/bstr/#structs)\n\n[BStr](https://docs.rs/bstr/latest/bstr/struct.BStr.html \"struct bstr::BStr\")\n    A wrapper for `&[u8]` that provides convenient string oriented trait impls.\n\n[BString](https://docs.rs/bstr/latest/bstr/struct.BString.html \"struct bstr::BString\")`alloc`\n    A wrapper for `Vec<u8>` that provides convenient string oriented trait impls.\n\n[Bytes](https://docs.rs/bstr/latest/bstr/struct.Bytes.html \"struct bstr::Bytes\")\n    An iterator over the bytes in a byte string.\n\n[CharIndices](https://docs.rs/bstr/latest/bstr/struct.CharIndices.html \"struct bstr::CharIndices\")\n    An iterator over Unicode scalar values in a byte string and their byte index positions.\n\n[Chars](https://docs.rs/bstr/latest/bstr/struct.Chars.html \"struct bstr::Chars\")\n    An iterator over Unicode scalar values in a byte string.\n\n[DrainBytes](https://docs.rs/bstr/latest/bstr/struct.DrainBytes.html \"struct bstr::DrainBytes\")`alloc`\n    A draining byte oriented iterator for `Vec<u8>`.\n\n[EscapeBytes](https://docs.rs/bstr/latest/bstr/struct.EscapeBytes.html \"struct bstr::EscapeBytes\")\n    An iterator of `char` values that represent an escaping of arbitrary bytes.\n\n[Fields](https://docs.rs/bstr/latest/bstr/struct.Fields.html \"struct bstr::Fields\")`unicode`\n    An iterator over the fields in a byte string, separated by whitespace.\n\n[FieldsWith](https://docs.rs/bstr/latest/bstr/struct.FieldsWith.html \"struct bstr::FieldsWith\")\n    An iterator over fields in the byte string, separated by a predicate over codepoints.\n\n[Find](https://docs.rs/bstr/latest/bstr/struct.Find.html \"struct bstr::Find\")\n    An iterator over non-overlapping substring matches.\n\n[FindReverse](https://docs.rs/bstr/latest/bstr/struct.FindReverse.html \"struct bstr::FindReverse\")\n    An iterator over non-overlapping substring matches in reverse.\n\n[Finder](https://docs.rs/bstr/latest/bstr/struct.Finder.html \"struct bstr::Finder\")\n    A single substring searcher fixed to a particular needle.\n\n[FinderReverse](https://docs.rs/bstr/latest/bstr/struct.FinderReverse.html \"struct bstr::FinderReverse\")\n    A single substring reverse searcher fixed to a particular needle.\n\n[FromUtf8Error](https://docs.rs/bstr/latest/bstr/struct.FromUtf8Error.html \"struct bstr::FromUtf8Error\")`alloc`\n    An error that may occur when converting a `Vec<u8>` to a `String`.\n\n[GraphemeIndices](https://docs.rs/bstr/latest/bstr/struct.GraphemeIndices.html \"struct bstr::GraphemeIndices\")`unicode`\n    An iterator over grapheme clusters in a byte string and their byte index positions.\n\n[Graphemes](https://docs.rs/bstr/latest/bstr/struct.Graphemes.html \"struct bstr::Graphemes\")`unicode`\n    An iterator over grapheme clusters in a byte string.\n\n[Lines](https://docs.rs/bstr/latest/bstr/struct.Lines.html \"struct bstr::Lines\")\n    An iterator over all lines in a byte string, without their terminators.\n\n[LinesWithTerminator](https://docs.rs/bstr/latest/bstr/struct.LinesWithTerminator.html \"struct bstr::LinesWithTerminator\")\n    An iterator over all lines in a byte string, including their terminators.\n\n[SentenceIndices](https://docs.rs/bstr/latest/bstr/struct.SentenceIndices.html \"struct bstr::SentenceIndices\")`unicode`\n    An iterator over sentences in a byte string, along with their byte offsets.\n\n[Sentences](https://docs.rs/bstr/latest/bstr/struct.Sentences.html \"struct bstr::Sentences\")`unicode`\n    An iterator over sentences in a byte string.\n\n[Split](https://docs.rs/bstr/latest/bstr/struct.Split.html \"struct bstr::Split\")\n    An iterator over substrings in a byte string, split by a separator.\n\n[SplitN](https://docs.rs/bstr/latest/bstr/struct.SplitN.html \"struct bstr::SplitN\")\n    An iterator over at most `n` substrings in a byte string, split by a separator.\n\n[SplitNReverse](https://docs.rs/bstr/latest/bstr/struct.SplitNReverse.html \"struct bstr::SplitNReverse\")\n    An iterator over at most `n` substrings in a byte string, split by a separator, in reverse.\n\n[SplitReverse](https://docs.rs/bstr/latest/bstr/struct.SplitReverse.html \"struct bstr::SplitReverse\")\n    An iterator over substrings in a byte string, split by a separator, in reverse.\n\n[Utf8Chunk](https://docs.rs/bstr/latest/bstr/struct.Utf8Chunk.html \"struct bstr::Utf8Chunk\")\n    A chunk of valid UTF-8, possibly followed by invalid UTF-8 bytes.\n\n[Utf8Chunks](https://docs.rs/bstr/latest/bstr/struct.Utf8Chunks.html \"struct bstr::Utf8Chunks\")\n    An iterator over chunks of valid UTF-8 in a byte slice.\n\n[Utf8Error](https://docs.rs/bstr/latest/bstr/struct.Utf8Error.html \"struct bstr::Utf8Error\")\n    An error that occurs when UTF-8 decoding fails.\n\n[WordIndices](https://docs.rs/bstr/latest/bstr/struct.WordIndices.html \"struct bstr::WordIndices\")`unicode`\n    An iterator over words in a byte string and their byte index positions.\n\n[Words](https://docs.rs/bstr/latest/bstr/struct.Words.html \"struct bstr::Words\")`unicode`\n    An iterator over words in a byte string.\n\n[WordsWithBreakIndices](https://docs.rs/bstr/latest/bstr/struct.WordsWithBreakIndices.html \"struct bstr::WordsWithBreakIndices\")`unicode`\n    An iterator over all word breaks in a byte string, along with their byte index positions.\n\n[WordsWithBreaks](https://docs.rs/bstr/latest/bstr/struct.WordsWithBreaks.html \"struct bstr::WordsWithBreaks\")`unicode`\n    An iterator over all word breaks in a byte string.\n## Traits[\u00a7](https://docs.rs/bstr/latest/bstr/#traits)\n\n[ByteSlice](https://docs.rs/bstr/latest/bstr/trait.ByteSlice.html \"trait bstr::ByteSlice\")\n    A trait that extends `&[u8]` with string oriented methods.\n\n[ByteVec](https://docs.rs/bstr/latest/bstr/trait.ByteVec.html \"trait bstr::ByteVec\")`alloc`\n    A trait that extends `Vec<u8>` with string oriented methods.\n## Functions[\u00a7](https://docs.rs/bstr/latest/bstr/#functions)\n\n[B](https://docs.rs/bstr/latest/bstr/fn.B.html \"fn bstr::B\")\n    A short-hand constructor for building a `&[u8]`.\n\n[concat](https://docs.rs/bstr/latest/bstr/fn.concat.html \"fn bstr::concat\")`alloc`\n    Concatenate the elements given by the iterator together into a single `Vec<u8>`.\n\n[decode_last_utf8](https://docs.rs/bstr/latest/bstr/fn.decode_last_utf8.html \"fn bstr::decode_last_utf8\")\n    UTF-8 decode a single Unicode scalar value from the end of a slice.\n\n[decode_utf8](https://docs.rs/bstr/latest/bstr/fn.decode_utf8.html \"fn bstr::decode_utf8\")\n    UTF-8 decode a single Unicode scalar value from the beginning of a slice.\n\n[join](https://docs.rs/bstr/latest/bstr/fn.join.html \"fn bstr::join\")`alloc`\n    Join the elements given by the iterator with the given separator into a single `Vec<u8>`.\n",
        "markdown_with_citations": "[](https://docs.rs/bstr/latest/bstr/all.html \"show sidebar\")\n# Crate bstrCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nA byte string library.\nByte strings are just like standard Unicode strings with one very important difference: byte strings are only _conventionally_ UTF-8 while Rust\u2019s standard Unicode strings are _guaranteed_ to be valid UTF-8. The primary motivation for byte strings is for handling arbitrary bytes that are mostly UTF-8.\n## \u00a7\u27e84\u27e9Overview\nThis crate provides two important traits that provide string oriented methods on `&[u8]` and `Vec<u8>` types:\n  * `ByteSlice`\u27e85\u27e9 extends the `[u8]` type with additional string oriented methods.\n  * `ByteVec`\u27e86\u27e9 extends the `Vec<u8>` type with additional string oriented methods.\n\n\nAdditionally, this crate provides two concrete byte string types that deref to `[u8]` and `Vec<u8>`. These are useful for storing byte string types, and come with convenient `std::fmt::Debug` implementations:\n  * `BStr`\u27e87\u27e9 is a byte string slice, analogous to `str`.\n  * `BString`\u27e88\u27e9 is an owned growable byte string buffer, analogous to `String`.\n\n\nAdditionally, the free function `B`\u27e89\u27e9 serves as a convenient short hand for writing byte string literals.\n## \u00a7\u27e810\u27e9Quick examples\nByte strings build on the existing APIs for `Vec<u8>` and `&[u8]`, with additional string oriented methods. Operations such as iterating over graphemes, searching for substrings, replacing substrings, trimming and case conversion are examples of things not provided on the standard library `&[u8]` APIs but are provided by this crate. For example, this code iterates over all of occurrences of a substring:\n```\nuse bstr::ByteSlice;\nlet s = b\"foo bar foo foo quux foo\";\nlet mut matches = vec![];\nfor start in s.find_iter(\"foo\") {\n  matches.push(start);\n}\nassert_eq!(matches, [0, 8, 12, 21]);\n```\n\nHere\u2019s another example showing how to do a search and replace (and also showing use of the `B` function):\n```\nuse bstr::{B, ByteSlice};\nlet old = B(\"foo \u2603\u2603\u2603 foo foo quux foo\");\nlet new = old.replace(\"foo\", \"hello\");\nassert_eq!(new, B(\"hello \u2603\u2603\u2603 hello hello quux hello\"));\n```\n\nAnd here\u2019s an example that shows case conversion, even in the presence of invalid UTF-8:\n```\nuse bstr::{ByteSlice, ByteVec};\nlet mut lower = Vec::from(\"hello \u03b2\");\nlower[0] = b'\\xFF';\n// lowercase \u03b2 is uppercased to \u0392\nassert_eq!(lower.to_uppercase(), b\"\\xFFELLO \\xCE\\x92\");\n```\n\n## \u00a7\u27e811\u27e9Convenient debug representation\nWhen working with byte strings, it is often useful to be able to print them as if they were byte strings and not sequences of integers. While this crate cannot affect the `std::fmt::Debug` implementations for `[u8]` and `Vec<u8>`, this crate does provide the `BStr` and `BString` types which have convenient `std::fmt::Debug` implementations.\nFor example, this\n```\nuse bstr::ByteSlice;\nlet mut bytes = Vec::from(\"hello \u03b2\");\nbytes[0] = b'\\xFF';\nprintln!(\"{:?}\", bytes.as_bstr());\n```\n\nwill output `\"\\xFFello \u03b2\"`.\nThis example works because the `ByteSlice::as_bstr`\u27e812\u27e9 method converts any `&[u8]` to a `&BStr`.\n## \u00a7\u27e813\u27e9When should I use byte strings?\nThis library reflects my belief that UTF-8 by convention is a better trade off in some circumstances than guaranteed UTF-8.\nThe first time this idea hit me was in the implementation of Rust\u2019s regex engine. In particular, very little of the internal implementation cares at all about searching valid UTF-8 encoded strings. Indeed, internally, the implementation converts `&str` from the API to `&[u8]` fairly quickly and just deals with raw bytes. UTF-8 match boundaries are then guaranteed by the finite state machine itself rather than any specific string type. This makes it possible to not only run regexes on `&str` values, but also on `&[u8]` values.\nWhy would you ever want to run a regex on a `&[u8]` though? Well, `&[u8]` is the fundamental way at which one reads data from all sorts of streams, via the standard library\u2019s `Read`\u27e814\u27e9 trait. In particular, there is no platform independent way to determine whether what you\u2019re reading from is some binary file or a human readable text file. Therefore, if you\u2019re writing a program to search files, you probably need to deal with `&[u8]` directly unless you\u2019re okay with first converting it to a `&str` and dropping any bytes that aren\u2019t valid UTF-8. (Or otherwise determine the encoding\u2014which is often impractical\u2014and perform a transcoding step.) Often, the simplest and most robust way to approach this is to simply treat the contents of a file as if it were mostly valid UTF-8 and pass through invalid UTF-8 untouched. This may not be the most correct approach though!\nOne case in particular exacerbates these issues, and that\u2019s memory mapping a file. When you memory map a file, that file may be gigabytes big, but all you get is a `&[u8]`. Converting that to a `&str` all in one go is generally not a good idea because of the costs associated with doing so, and also because it generally causes one to do two passes over the data instead of one, which is quite undesirable. It is of course usually possible to do it an incremental way by only parsing chunks at a time, but this is often complex to do or impractical. For example, many regex engines only accept one contiguous sequence of bytes at a time with no way to perform incremental matching.\n## \u00a7\u27e815\u27e9`bstr` in public APIs\nThis library is past version `1` and is expected to remain at version `1` for the foreseeable future. Therefore, it is encouraged to put types from `bstr` (like `BStr` and `BString`) in your public API if that makes sense for your crate.\nWith that said, in general, it should be possible to avoid putting anything in this crate into your public APIs. Namely, you should never need to use the `ByteSlice` or `ByteVec` traits as bounds on public APIs, since their only purpose is to extend the methods on the concrete types `[u8]` and `Vec<u8>`, respectively. Similarly, it should not be necessary to put either the `BStr` or `BString` types into public APIs. If you want to use them internally, then they can be converted to/from `[u8]`/`Vec<u8>` as needed. The conversions are free.\nSo while it shouldn\u2019t ever be 100% necessary to make `bstr` a public dependency, there may be cases where it is convenient to do so. This is an explicitly supported use case of `bstr`, and as such, major version releases should be exceptionally rare.\n## \u00a7\u27e816\u27e9Differences with standard strings\nThe primary difference between `[u8]` and `str` is that the former is conventionally UTF-8 while the latter is guaranteed to be UTF-8. The phrase \u201cconventionally UTF-8\u201d means that a `[u8]` may contain bytes that do not form a valid UTF-8 sequence, but operations defined on the type in this crate are generally most useful on valid UTF-8 sequences. For example, iterating over Unicode codepoints or grapheme clusters is an operation that is only defined on valid UTF-8. Therefore, when invalid UTF-8 is encountered, the Unicode replacement codepoint is substituted. Thus, a byte string that is not UTF-8 at all is of limited utility when using these crate.\nHowever, not all operations on byte strings are specifically Unicode aware. For example, substring search has no specific Unicode semantics ascribed to it. It works just as well for byte strings that are completely valid UTF-8 as for byte strings that contain no valid UTF-8 at all. Similarly for replacements and various other operations that do not need any Unicode specific tailoring.\nAside from the difference in how UTF-8 is handled, the APIs between `[u8]` and `str` (and `Vec<u8>` and `String`) are intentionally very similar, including maintaining the same behavior for corner cases in things like substring splitting. There are, however, some differences:\n  * Substring search is not done with `matches`, but instead, `find_iter`. In general, this crate does not define any generic `Pattern`\u27e817\u27e9 infrastructure, and instead prefers adding new methods for different argument types. For example, `matches` can search by a `char` or a `&str`, where as `find_iter` can only search by a byte string. `find_char` can be used for searching by a `char`.\n  * Since `SliceConcatExt` in the standard library is unstable, it is not possible to reuse that to implement `join` and `concat` methods. Instead, `join`\u27e818\u27e9 and `concat`\u27e819\u27e9 are provided as free functions that perform a similar task.\n  * This library bundles in a few more Unicode operations, such as grapheme, word and sentence iterators. More operations, such as normalization and case folding, may be provided in the future.\n  * Some `String`/`str` APIs will panic if a particular index was not on a valid UTF-8 code unit sequence boundary. Conversely, no such checking is performed in this crate, as is consistent with treating byte strings as a sequence of bytes. This means callers are responsible for maintaining a UTF-8 invariant if that\u2019s important.\n  * Some routines provided by this crate, such as `starts_with_str`, have a `_str` suffix to differentiate them from similar routines already defined on the `[u8]` type. The difference is that `starts_with` requires its parameter to be a `&[u8]`, where as `starts_with_str` permits its parameter to by anything that implements `AsRef<[u8]>`, which is more flexible. This means you can write `bytes.starts_with_str(\"\u2603\")` instead of `bytes.starts_with(\"\u2603\".as_bytes())`.\n\n\nOtherwise, you should find most of the APIs between this crate and the standard library string APIs to be very similar, if not identical.\n## \u00a7\u27e820\u27e9Handling of invalid UTF-8\nSince byte strings are only _conventionally_ UTF-8, there is no guarantee that byte strings contain valid UTF-8. Indeed, it is perfectly legal for a byte string to contain arbitrary bytes. However, since this library defines a _string_ type, it provides many operations specified by Unicode. These operations are typically only defined over codepoints, and thus have no real meaning on bytes that are invalid UTF-8 because they do not map to a particular codepoint.\nFor this reason, whenever operations defined only on codepoints are used, this library will automatically convert invalid UTF-8 to the Unicode replacement codepoint, `U+FFFD`, which looks like this: `\ufffd`. For example, an iterator over codepoints\u27e821\u27e9 will yield a Unicode replacement codepoint whenever it comes across bytes that are not valid UTF-8:\n```\nuse bstr::ByteSlice;\nlet bs = b\"a\\xFF\\xFFz\";\nlet chars: Vec<char> = bs.chars().collect();\nassert_eq!(vec!['a', '\\u{FFFD}', '\\u{FFFD}', 'z'], chars);\n```\n\nThere are a few ways in which invalid bytes can be substituted with a Unicode replacement codepoint. One way, not used by this crate, is to replace every individual invalid byte with a single replacement codepoint. In contrast, the approach this crate uses is called the \u201csubstitution of maximal subparts,\u201d as specified by the Unicode Standard (Chapter 3, Section 9). (This approach is also used by W3C\u2019s Encoding Standard\u27e822\u27e9.) In this strategy, a replacement codepoint is inserted whenever a byte is found that cannot possibly lead to a valid UTF-8 code unit sequence. If there were previous bytes that represented a _prefix_ of a well-formed UTF-8 code unit sequence, then all of those bytes (up to 3) are substituted with a single replacement codepoint. For example:\n```\nuse bstr::ByteSlice;\nlet bs = b\"a\\xF0\\x9F\\x87z\";\nlet chars: Vec<char> = bs.chars().collect();\n// The bytes \\xF0\\x9F\\x87 could lead to a valid UTF-8 sequence, but 3 of them\n// on their own are invalid. Only one replacement codepoint is substituted,\n// which demonstrates the \"substitution of maximal subparts\" strategy.\nassert_eq!(vec!['a', '\\u{FFFD}', 'z'], chars);\n```\n\nIf you do need to access the raw bytes for some reason in an iterator like `Chars`, then you should use the iterator\u2019s \u201cindices\u201d variant, which gives the byte offsets containing the invalid UTF-8 bytes that were substituted with the replacement codepoint. For example:\n```\nuse bstr::{B, ByteSlice};\nlet bs = b\"a\\xE2\\x98z\";\nlet chars: Vec<(usize, usize, char)> = bs.char_indices().collect();\n// Even though the replacement codepoint is encoded as 3 bytes itself, the\n// byte range given here is only two bytes, corresponding to the original\n// raw bytes.\nassert_eq!(vec![(0, 1, 'a'), (1, 3, '\\u{FFFD}'), (3, 4, 'z')], chars);\n// Thus, getting the original raw bytes is as simple as slicing the original\n// byte string:\nlet chars: Vec<&[u8]> = bs.char_indices().map(|(s, e, _)| &bs[s..e]).collect();\nassert_eq!(vec![B(\"a\"), B(b\"\\xE2\\x98\"), B(\"z\")], chars);\n```\n\n## \u00a7\u27e823\u27e9File paths and OS strings\nOne of the premiere features of Rust\u2019s standard library is how it handles file paths. In particular, it makes it very hard to write incorrect code while simultaneously providing a correct cross platform abstraction for manipulating file paths. The key challenge that one faces with file paths across platforms is derived from the following observations:\n  * On most Unix-like systems, file paths are an arbitrary sequence of bytes.\n  * On Windows, file paths are an arbitrary sequence of 16-bit integers.\n\n\n(In both cases, certain sequences aren\u2019t allowed. For example a `NUL` byte is not allowed in either case. But we can ignore this for the purposes of this section.)\nByte strings, like the ones provided in this crate, line up really well with file paths on Unix like systems, which are themselves just arbitrary sequences of bytes. It turns out that if you treat them as \u201cmostly UTF-8,\u201d then things work out pretty well. On the contrary, byte strings _don\u2019t_ really work that well on Windows because it\u2019s not possible to correctly roundtrip file paths between 16-bit integers and something that looks like UTF-8 _without_ explicitly defining an encoding to do this for you, which is anathema to byte strings, which are just bytes.\nRust\u2019s standard library elegantly solves this problem by specifying an internal encoding for file paths that\u2019s only used on Windows called WTF-8\u27e824\u27e9. Its key properties are that they permit losslessly roundtripping file paths on Windows by extending UTF-8 to support an encoding of surrogate codepoints, while simultaneously supporting zero-cost conversion from Rust\u2019s Unicode strings to file paths. (Since UTF-8 is a proper subset of WTF-8.)\nThe fundamental point at which the above strategy fails is when you want to treat file paths as things that look like strings in a zero cost way. In most cases, this is actually the wrong thing to do, but some cases call for it, for example, glob or regex matching on file paths. This is because WTF-8 is treated as an internal implementation detail, and there is no way to access those bytes via a public API. Therefore, such consumers are limited in what they can do:\n  1. One could re-implement WTF-8 and re-encode file paths on Windows to WTF-8 by accessing their underlying 16-bit integer representation. Unfortunately, this isn\u2019t zero cost (it introduces a second WTF-8 decoding step) and it\u2019s not clear this is a good thing to do, since WTF-8 should ideally remain an internal implementation detail. This is roughly the approach taken by the `os_str_bytes`\u27e825\u27e9 crate.\n  2. One could instead declare that they will not handle paths on Windows that are not valid UTF-16, and return an error when one is encountered.\n  3. Like (2), but instead of returning an error, lossily decode the file path on Windows that isn\u2019t valid UTF-16 into UTF-16 by replacing invalid bytes with the Unicode replacement codepoint.\n\n\nWhile this library may provide facilities for (1) in the future, currently, this library only provides facilities for (2) and (3). In particular, a suite of conversion functions are provided that permit converting between byte strings, OS strings and file paths. For owned byte strings, they are:\n  * `ByteVec::from_os_string`\u27e826\u27e9\n  * `ByteVec::from_os_str_lossy`\u27e827\u27e9\n  * `ByteVec::from_path_buf`\u27e828\u27e9\n  * `ByteVec::from_path_lossy`\u27e829\u27e9\n  * `ByteVec::into_os_string`\u27e830\u27e9\n  * `ByteVec::into_os_string_lossy`\u27e831\u27e9\n  * `ByteVec::into_path_buf`\u27e832\u27e9\n  * `ByteVec::into_path_buf_lossy`\u27e833\u27e9\n\n\nFor byte string slices, they are:\n  * `ByteSlice::from_os_str`\u27e834\u27e9\n  * `ByteSlice::from_path`\u27e835\u27e9\n  * `ByteSlice::to_os_str`\u27e836\u27e9\n  * `ByteSlice::to_os_str_lossy`\u27e837\u27e9\n  * `ByteSlice::to_path`\u27e838\u27e9\n  * `ByteSlice::to_path_lossy`\u27e839\u27e9\n\n\nOn Unix, all of these conversions are rigorously zero cost, which gives one a way to ergonomically deal with raw file paths exactly as they are using normal string-related functions. On Windows, these conversion routines perform a UTF-8 check and either return an error or lossily decode the file path into valid UTF-8, depending on which function you use. This means that you cannot roundtrip all file paths on Windows correctly using these conversion routines. However, this may be an acceptable downside since such file paths are exceptionally rare. Moreover, roundtripping isn\u2019t always necessary, for example, if all you\u2019re doing is filtering based on file paths.\nThe reason why using byte strings for this is potentially superior than the standard library\u2019s approach is that a lot of Rust code is already lossily converting file paths to Rust\u2019s Unicode strings, which are required to be valid UTF-8, and thus contain latent bugs on Unix where paths with invalid UTF-8 are not terribly uncommon. If you instead use byte strings, then you\u2019re guaranteed to write correct code for Unix, at the cost of getting a corner case wrong on Windows.\n## \u00a7\u27e840\u27e9Cargo features\nThis crates comes with a few features that control standard library, serde and Unicode support.\n  * `std` - **Enabled** by default. This provides APIs that require the standard library, such as `Vec<u8>` and `PathBuf`. Enabling this feature also enables the `alloc` feature and any other relevant `std` features for dependencies.\n  * `alloc` - **Enabled** by default. This provides APIs that require allocations via the `alloc` crate, such as `Vec<u8>`.\n  * `unicode` - **Enabled** by default. This provides APIs that require sizable Unicode data compiled into the binary. This includes, but is not limited to, grapheme/word/sentence segmenters. When this is disabled, basic support such as UTF-8 decoding is still included. Note that currently, enabling this feature also requires enabling the `std` feature. It is expected that this limitation will be lifted at some point.\n  * `serde` - Enables implementations of serde traits for `BStr`, and also `BString` when `alloc` is enabled.\n\n\n## Modules\u00a7\u27e841\u27e9\n\nio\u27e842\u27e9`std`\n    Utilities for working with I/O using byte strings.\n## Structs\u00a7\u27e843\u27e9\n\nBStr\u27e87\u27e9\n    A wrapper for `&[u8]` that provides convenient string oriented trait impls.\n\nBString\u27e88\u27e9`alloc`\n    A wrapper for `Vec<u8>` that provides convenient string oriented trait impls.\n\nBytes\u27e844\u27e9\n    An iterator over the bytes in a byte string.\n\nCharIndices\u27e845\u27e9\n    An iterator over Unicode scalar values in a byte string and their byte index positions.\n\nChars\u27e821\u27e9\n    An iterator over Unicode scalar values in a byte string.\n\nDrainBytes\u27e846\u27e9`alloc`\n    A draining byte oriented iterator for `Vec<u8>`.\n\nEscapeBytes\u27e847\u27e9\n    An iterator of `char` values that represent an escaping of arbitrary bytes.\n\nFields\u27e848\u27e9`unicode`\n    An iterator over the fields in a byte string, separated by whitespace.\n\nFieldsWith\u27e849\u27e9\n    An iterator over fields in the byte string, separated by a predicate over codepoints.\n\nFind\u27e850\u27e9\n    An iterator over non-overlapping substring matches.\n\nFindReverse\u27e851\u27e9\n    An iterator over non-overlapping substring matches in reverse.\n\nFinder\u27e852\u27e9\n    A single substring searcher fixed to a particular needle.\n\nFinderReverse\u27e853\u27e9\n    A single substring reverse searcher fixed to a particular needle.\n\nFromUtf8Error\u27e854\u27e9`alloc`\n    An error that may occur when converting a `Vec<u8>` to a `String`.\n\nGraphemeIndices\u27e855\u27e9`unicode`\n    An iterator over grapheme clusters in a byte string and their byte index positions.\n\nGraphemes\u27e856\u27e9`unicode`\n    An iterator over grapheme clusters in a byte string.\n\nLines\u27e857\u27e9\n    An iterator over all lines in a byte string, without their terminators.\n\nLinesWithTerminator\u27e858\u27e9\n    An iterator over all lines in a byte string, including their terminators.\n\nSentenceIndices\u27e859\u27e9`unicode`\n    An iterator over sentences in a byte string, along with their byte offsets.\n\nSentences\u27e860\u27e9`unicode`\n    An iterator over sentences in a byte string.\n\nSplit\u27e861\u27e9\n    An iterator over substrings in a byte string, split by a separator.\n\nSplitN\u27e862\u27e9\n    An iterator over at most `n` substrings in a byte string, split by a separator.\n\nSplitNReverse\u27e863\u27e9\n    An iterator over at most `n` substrings in a byte string, split by a separator, in reverse.\n\nSplitReverse\u27e864\u27e9\n    An iterator over substrings in a byte string, split by a separator, in reverse.\n\nUtf8Chunk\u27e865\u27e9\n    A chunk of valid UTF-8, possibly followed by invalid UTF-8 bytes.\n\nUtf8Chunks\u27e866\u27e9\n    An iterator over chunks of valid UTF-8 in a byte slice.\n\nUtf8Error\u27e867\u27e9\n    An error that occurs when UTF-8 decoding fails.\n\nWordIndices\u27e868\u27e9`unicode`\n    An iterator over words in a byte string and their byte index positions.\n\nWords\u27e869\u27e9`unicode`\n    An iterator over words in a byte string.\n\nWordsWithBreakIndices\u27e870\u27e9`unicode`\n    An iterator over all word breaks in a byte string, along with their byte index positions.\n\nWordsWithBreaks\u27e871\u27e9`unicode`\n    An iterator over all word breaks in a byte string.\n## Traits\u00a7\u27e872\u27e9\n\nByteSlice\u27e85\u27e9\n    A trait that extends `&[u8]` with string oriented methods.\n\nByteVec\u27e86\u27e9`alloc`\n    A trait that extends `Vec<u8>` with string oriented methods.\n## Functions\u00a7\u27e873\u27e9\n\nB\u27e89\u27e9\n    A short-hand constructor for building a `&[u8]`.\n\nconcat\u27e819\u27e9`alloc`\n    Concatenate the elements given by the iterator together into a single `Vec<u8>`.\n\ndecode_last_utf8\u27e874\u27e9\n    UTF-8 decode a single Unicode scalar value from the end of a slice.\n\ndecode_utf8\u27e875\u27e9\n    UTF-8 decode a single Unicode scalar value from the beginning of a slice.\n\njoin\u27e818\u27e9`alloc`\n    Join the elements given by the iterator with the given separator into a single `Vec<u8>`.\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/bstr/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/bstr/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/bstr/latest/src/bstr/lib.rs.html#1-474: Source\n\u27e84\u27e9 https://docs.rs/bstr/latest/bstr/#overview: \u00a7\n\u27e85\u27e9 https://docs.rs/bstr/latest/bstr/trait.ByteSlice.html: `ByteSlice`\n\u27e86\u27e9 https://docs.rs/bstr/latest/bstr/trait.ByteVec.html: `ByteVec`\n\u27e87\u27e9 https://docs.rs/bstr/latest/bstr/struct.BStr.html: `BStr`\n\u27e88\u27e9 https://docs.rs/bstr/latest/bstr/struct.BString.html: `BString`\n\u27e89\u27e9 https://docs.rs/bstr/latest/bstr/fn.B.html: `B`\n\u27e810\u27e9 https://docs.rs/bstr/latest/bstr/#quick-examples: \u00a7\n\u27e811\u27e9 https://docs.rs/bstr/latest/bstr/#convenient-debug-representation: \u00a7\n\u27e812\u27e9 https://docs.rs/bstr/latest/bstr/trait.ByteSlice.html#method.as_bstr: `ByteSlice::as_bstr`\n\u27e813\u27e9 https://docs.rs/bstr/latest/bstr/#when-should-i-use-byte-strings: \u00a7\n\u27e814\u27e9 https://doc.rust-lang.org/std/io/trait.Read.html: `Read`\n\u27e815\u27e9 https://docs.rs/bstr/latest/bstr/#bstr-in-public-apis: \u00a7\n\u27e816\u27e9 https://docs.rs/bstr/latest/bstr/#differences-with-standard-strings: \u00a7\n\u27e817\u27e9 https://doc.rust-lang.org/std/str/pattern/trait.Pattern.html: `Pattern`\n\u27e818\u27e9 https://docs.rs/bstr/latest/bstr/fn.join.html: `join`\n\u27e819\u27e9 https://docs.rs/bstr/latest/bstr/fn.concat.html: `concat`\n\u27e820\u27e9 https://docs.rs/bstr/latest/bstr/#handling-of-invalid-utf-8: \u00a7\n\u27e821\u27e9 https://docs.rs/bstr/latest/bstr/struct.Chars.html: iterator over codepoints\n\u27e822\u27e9 https://www.w3.org/TR/encoding/: W3C\u2019s Encoding Standard\n\u27e823\u27e9 https://docs.rs/bstr/latest/bstr/#file-paths-and-os-strings: \u00a7\n\u27e824\u27e9 https://simonsapin.github.io/wtf-8/: WTF-8\n\u27e825\u27e9 https://crates.io/crates/os_str_bytes: `os_str_bytes`\n\u27e826\u27e9 https://docs.rs/bstr/latest/bstr/trait.ByteVec.html#method.from_os_string: `ByteVec::from_os_string`\n\u27e827\u27e9 https://docs.rs/bstr/latest/bstr/trait.ByteVec.html#method.from_os_str_lossy: `ByteVec::from_os_str_lossy`\n\u27e828\u27e9 https://docs.rs/bstr/latest/bstr/trait.ByteVec.html#method.from_path_buf: `ByteVec::from_path_buf`\n\u27e829\u27e9 https://docs.rs/bstr/latest/bstr/trait.ByteVec.html#method.from_path_lossy: `ByteVec::from_path_lossy`\n\u27e830\u27e9 https://docs.rs/bstr/latest/bstr/trait.ByteVec.html#method.into_os_string: `ByteVec::into_os_string`\n\u27e831\u27e9 https://docs.rs/bstr/latest/bstr/trait.ByteVec.html#method.into_os_string_lossy: `ByteVec::into_os_string_lossy`\n\u27e832\u27e9 https://docs.rs/bstr/latest/bstr/trait.ByteVec.html#method.into_path_buf: `ByteVec::into_path_buf`\n\u27e833\u27e9 https://docs.rs/bstr/latest/bstr/trait.ByteVec.html#method.into_path_buf_lossy: `ByteVec::into_path_buf_lossy`\n\u27e834\u27e9 https://docs.rs/bstr/latest/bstr/trait.ByteSlice.html#method.from_os_str: `ByteSlice::from_os_str`\n\u27e835\u27e9 https://docs.rs/bstr/latest/bstr/trait.ByteSlice.html#method.from_path: `ByteSlice::from_path`\n\u27e836\u27e9 https://docs.rs/bstr/latest/bstr/trait.ByteSlice.html#method.to_os_str: `ByteSlice::to_os_str`\n\u27e837\u27e9 https://docs.rs/bstr/latest/bstr/trait.ByteSlice.html#method.to_os_str_lossy: `ByteSlice::to_os_str_lossy`\n\u27e838\u27e9 https://docs.rs/bstr/latest/bstr/trait.ByteSlice.html#method.to_path: `ByteSlice::to_path`\n\u27e839\u27e9 https://docs.rs/bstr/latest/bstr/trait.ByteSlice.html#method.to_path_lossy: `ByteSlice::to_path_lossy`\n\u27e840\u27e9 https://docs.rs/bstr/latest/bstr/#cargo-features: \u00a7\n\u27e841\u27e9 https://docs.rs/bstr/latest/bstr/#modules: \u00a7\n\u27e842\u27e9 https://docs.rs/bstr/latest/bstr/io/index.html: mod bstr::io - io\n\u27e843\u27e9 https://docs.rs/bstr/latest/bstr/#structs: \u00a7\n\u27e844\u27e9 https://docs.rs/bstr/latest/bstr/struct.Bytes.html: struct bstr::Bytes - Bytes\n\u27e845\u27e9 https://docs.rs/bstr/latest/bstr/struct.CharIndices.html: struct bstr::CharIndices - CharIndices\n\u27e846\u27e9 https://docs.rs/bstr/latest/bstr/struct.DrainBytes.html: struct bstr::DrainBytes - DrainBytes\n\u27e847\u27e9 https://docs.rs/bstr/latest/bstr/struct.EscapeBytes.html: struct bstr::EscapeBytes - EscapeBytes\n\u27e848\u27e9 https://docs.rs/bstr/latest/bstr/struct.Fields.html: struct bstr::Fields - Fields\n\u27e849\u27e9 https://docs.rs/bstr/latest/bstr/struct.FieldsWith.html: struct bstr::FieldsWith - FieldsWith\n\u27e850\u27e9 https://docs.rs/bstr/latest/bstr/struct.Find.html: struct bstr::Find - Find\n\u27e851\u27e9 https://docs.rs/bstr/latest/bstr/struct.FindReverse.html: struct bstr::FindReverse - FindReverse\n\u27e852\u27e9 https://docs.rs/bstr/latest/bstr/struct.Finder.html: struct bstr::Finder - Finder\n\u27e853\u27e9 https://docs.rs/bstr/latest/bstr/struct.FinderReverse.html: struct bstr::FinderReverse - FinderReverse\n\u27e854\u27e9 https://docs.rs/bstr/latest/bstr/struct.FromUtf8Error.html: struct bstr::FromUtf8Error - FromUtf8Error\n\u27e855\u27e9 https://docs.rs/bstr/latest/bstr/struct.GraphemeIndices.html: struct bstr::GraphemeIndices - GraphemeIndices\n\u27e856\u27e9 https://docs.rs/bstr/latest/bstr/struct.Graphemes.html: struct bstr::Graphemes - Graphemes\n\u27e857\u27e9 https://docs.rs/bstr/latest/bstr/struct.Lines.html: struct bstr::Lines - Lines\n\u27e858\u27e9 https://docs.rs/bstr/latest/bstr/struct.LinesWithTerminator.html: struct bstr::LinesWithTerminator - LinesWithTerminator\n\u27e859\u27e9 https://docs.rs/bstr/latest/bstr/struct.SentenceIndices.html: struct bstr::SentenceIndices - SentenceIndices\n\u27e860\u27e9 https://docs.rs/bstr/latest/bstr/struct.Sentences.html: struct bstr::Sentences - Sentences\n\u27e861\u27e9 https://docs.rs/bstr/latest/bstr/struct.Split.html: struct bstr::Split - Split\n\u27e862\u27e9 https://docs.rs/bstr/latest/bstr/struct.SplitN.html: struct bstr::SplitN - SplitN\n\u27e863\u27e9 https://docs.rs/bstr/latest/bstr/struct.SplitNReverse.html: struct bstr::SplitNReverse - SplitNReverse\n\u27e864\u27e9 https://docs.rs/bstr/latest/bstr/struct.SplitReverse.html: struct bstr::SplitReverse - SplitReverse\n\u27e865\u27e9 https://docs.rs/bstr/latest/bstr/struct.Utf8Chunk.html: struct bstr::Utf8Chunk - Utf8Chunk\n\u27e866\u27e9 https://docs.rs/bstr/latest/bstr/struct.Utf8Chunks.html: struct bstr::Utf8Chunks - Utf8Chunks\n\u27e867\u27e9 https://docs.rs/bstr/latest/bstr/struct.Utf8Error.html: struct bstr::Utf8Error - Utf8Error\n\u27e868\u27e9 https://docs.rs/bstr/latest/bstr/struct.WordIndices.html: struct bstr::WordIndices - WordIndices\n\u27e869\u27e9 https://docs.rs/bstr/latest/bstr/struct.Words.html: struct bstr::Words - Words\n\u27e870\u27e9 https://docs.rs/bstr/latest/bstr/struct.WordsWithBreakIndices.html: struct bstr::WordsWithBreakIndices - WordsWithBreakIndices\n\u27e871\u27e9 https://docs.rs/bstr/latest/bstr/struct.WordsWithBreaks.html: struct bstr::WordsWithBreaks - WordsWithBreaks\n\u27e872\u27e9 https://docs.rs/bstr/latest/bstr/#traits: \u00a7\n\u27e873\u27e9 https://docs.rs/bstr/latest/bstr/#functions: \u00a7\n\u27e874\u27e9 https://docs.rs/bstr/latest/bstr/fn.decode_last_utf8.html: fn bstr::decode_last_utf8 - decode_last_utf8\n\u27e875\u27e9 https://docs.rs/bstr/latest/bstr/fn.decode_utf8.html: fn bstr::decode_utf8 - decode_utf8\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `bstr` crate provides a robust byte string library for handling `&[u8]` and `Vec<u8]` as conventionally UTF-8 strings, enabling operations like substring search, replacement, case conversion, and grapheme iteration, even with invalid UTF-8 data. It introduces convenient types (`BStr` and `BString`) with enhanced APIs and debug representations, along with traits (`ByteSlice`, `ByteVec`) to extend byte-oriented functionality. The crate also supports efficient file path and OS string conversions, Unicode-aware operations, and optional features like `serde` integration and Unicode segmentation.",
    "feature_summary": null,
    "use_case": "Utilities",
    "score": 0.0,
    "factual_counterfactual": "### Pair 1: Handling Invalid UTF-8\n\u2705 Factual: The `bstr` crate automatically replaces invalid UTF-8 bytes with the Unicode replacement codepoint (`U+FFFD`) when performing operations like iterating over codepoints.  \n\u274c Counterfactual: The `bstr` crate silently ignores invalid UTF-8 bytes without substituting them, treating them as valid during codepoint iteration.\n\n---\n\n### Pair 2: File Path Compatibility\n\u2705 Factual: On Unix-like systems, the `bstr` crate provides zero-cost conversions between byte strings and file paths since file paths are represented as arbitrary sequences of bytes.  \n\u274c Counterfactual: The `bstr` crate guarantees correct roundtripping of file paths on Windows, even for paths that contain invalid UTF-16 sequences.\n\n---\n\n### Pair 3: Substring Search\n\u2705 Factual: The `bstr` crate provides the `find_iter` method for substring search, which iterates over all non-overlapping matches in a byte string.  \n\u274c Counterfactual: The `bstr` crate uses the standard library's `matches` method for substring search, supporting both overlapping and non-overlapping matches.",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}