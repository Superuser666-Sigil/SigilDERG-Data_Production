{
    "name": "arc-swap",
    "version": "1.7.1",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/arc-swap/latest/arc_swap/all.html \"show sidebar\")\n# Crate arc_swapCopy item path\n[Settings](https://docs.rs/arc-swap/latest/settings.html)\n[Help](https://docs.rs/arc-swap/latest/help.html)\nSummary[Source](https://docs.rs/arc-swap/latest/src/arc_swap/lib.rs.html#1-1317)\nExpand description\nMaking [`Arc`](https://doc.rust-lang.org/nightly/alloc/sync/struct.Arc.html \"struct alloc::sync::Arc\") itself atomic\nThe [`ArcSwap`](https://docs.rs/arc-swap/latest/arc_swap/type.ArcSwap.html \"type arc_swap::ArcSwap\") type is a container for an `Arc` that can be changed atomically. Semantically, it is similar to something like `Atomic<Arc<T>>` (if there was such a thing) or `RwLock<Arc<T>>` (but without the need for the locking). It is optimized for read-mostly scenarios, with consistent performance characteristics.\n## [\u00a7](https://docs.rs/arc-swap/latest/arc_swap/#motivation)Motivation\nThere are many situations in which one might want to have some data structure that is often read and seldom updated. Some examples might be a configuration of a service, routing tables, snapshot of some data that is renewed every few minutes, etc.\nIn all these cases one needs:\n  * Being able to read the current value of the data structure, fast, often and concurrently from many threads.\n  * Using the same version of the data structure over longer period of time \u2012 a query should be answered by a consistent version of data, a packet should be routed either by an old or by a new version of the routing table but not by a combination, etc.\n  * Perform an update without disrupting the processing.\n\n\nThe first idea would be to use [`RwLock<T>`](https://doc.rust-lang.org/std/sync/struct.RwLock.html) and keep a read-lock for the whole time of processing. Update would, however, pause all processing until done.\nBetter option would be to have [`RwLock<Arc<T>>`](https://doc.rust-lang.org/std/sync/struct.RwLock.html). Then one would lock, clone the [Arc](https://doc.rust-lang.org/nightly/alloc/sync/struct.Arc.html \"struct alloc::sync::Arc\") and unlock. This suffers from CPU-level contention (on the lock and on the reference count of the [Arc](https://doc.rust-lang.org/nightly/alloc/sync/struct.Arc.html \"struct alloc::sync::Arc\")) which makes it relatively slow. Depending on the implementation, an update may be blocked for arbitrary long time by a steady inflow of readers.\n```\nstatic ROUTING_TABLE: Lazy<RwLock<Arc<RoutingTable>>> = Lazy::new(|| {\n  RwLock::new(Arc::new(RoutingTable))\n});\nfn process_packet(packet: Packet) {\n  let table = Arc::clone(&ROUTING_TABLE.read().unwrap());\n  table.route(packet);\n}\n```\n\nThe [ArcSwap](https://docs.rs/arc-swap/latest/arc_swap/type.ArcSwap.html \"type arc_swap::ArcSwap\") can be used instead, which solves the above problems and has better performance characteristics than the [RwLock](https://doc.rust-lang.org/std/sync/struct.RwLock.html), both in contended and non-contended scenarios.\n```\nstatic ROUTING_TABLE: Lazy<ArcSwap<RoutingTable>> = Lazy::new(|| {\n  ArcSwap::from_pointee(RoutingTable)\n});\nfn process_packet(packet: Packet) {\n  let table = ROUTING_TABLE.load();\n  table.route(packet);\n}\n```\n\n## [\u00a7](https://docs.rs/arc-swap/latest/arc_swap/#crate-contents)Crate contents\nAt the heart of the crate there are [`ArcSwap`](https://docs.rs/arc-swap/latest/arc_swap/type.ArcSwap.html \"type arc_swap::ArcSwap\") and [`ArcSwapOption`](https://docs.rs/arc-swap/latest/arc_swap/type.ArcSwapOption.html \"type arc_swap::ArcSwapOption\") types, containers for an [`Arc`](https://doc.rust-lang.org/nightly/alloc/sync/struct.Arc.html \"struct alloc::sync::Arc\") and [`Option<Arc>`](https://doc.rust-lang.org/nightly/core/option/enum.Option.html \"enum core::option::Option\").\nTechnically, these are type aliases for partial instantiations of the [`ArcSwapAny`](https://docs.rs/arc-swap/latest/arc_swap/struct.ArcSwapAny.html \"struct arc_swap::ArcSwapAny\") type. The [`ArcSwapAny`](https://docs.rs/arc-swap/latest/arc_swap/struct.ArcSwapAny.html \"struct arc_swap::ArcSwapAny\") is more flexible and allows tweaking of many things (can store other things than [`Arc`](https://doc.rust-lang.org/nightly/alloc/sync/struct.Arc.html \"struct alloc::sync::Arc\")s, can configure the locking [`Strategy`](https://docs.rs/arc-swap/latest/arc_swap/strategy/trait.Strategy.html \"trait arc_swap::strategy::Strategy\")). For details about the tweaking, see the documentation of the [`strategy`](https://docs.rs/arc-swap/latest/arc_swap/strategy/index.html \"mod arc_swap::strategy\") module and the [`RefCnt`](https://docs.rs/arc-swap/latest/arc_swap/trait.RefCnt.html \"trait arc_swap::RefCnt\") trait.\nThe [`cache`](https://docs.rs/arc-swap/latest/arc_swap/cache/index.html \"mod arc_swap::cache\") module provides means for speeding up read access of the contained data at the cost of delayed reclamation.\nThe [`access`](https://docs.rs/arc-swap/latest/arc_swap/access/index.html \"mod arc_swap::access\") module can be used to do projections into the contained data to separate parts of application from each other (eg. giving a component access to only its own part of configuration while still having it reloaded as a whole).\n## [\u00a7](https://docs.rs/arc-swap/latest/arc_swap/#before-using)Before using\nThe data structure is a bit niche. Before using, please check the [limitations and common pitfalls](https://docs.rs/arc-swap/latest/arc_swap/docs/limitations/index.html \"mod arc_swap::docs::limitations\") and the [performance characteristics](https://docs.rs/arc-swap/latest/arc_swap/docs/performance/index.html \"mod arc_swap::docs::performance\"), including choosing the right [read operation](https://docs.rs/arc-swap/latest/arc_swap/docs/performance/index.html#read-operations \"mod arc_swap::docs::performance\").\nYou can also get an inspiration about what\u2019s possible in the [common patterns](https://docs.rs/arc-swap/latest/arc_swap/docs/patterns/index.html \"mod arc_swap::docs::patterns\") section.\n## [\u00a7](https://docs.rs/arc-swap/latest/arc_swap/#examples)Examples\n```\nuse std::sync::Arc;\nuse arc_swap::ArcSwap;\nuse crossbeam_utils::thread;\nlet config = ArcSwap::from(Arc::new(String::default()));\nthread::scope(|scope| {\n  scope.spawn(|_| {\n    let new_conf = Arc::new(\"New configuration\".to_owned());\n    config.store(new_conf);\n  });\n  for _ in 0..10 {\n    scope.spawn(|_| {\n      loop {\n        let cfg = config.load();\n        if !cfg.is_empty() {\n          assert_eq!(**cfg, \"New configuration\");\n          return;\n        }\n      }\n    });\n  }\n}).unwrap();\n```\n\n## Re-exports[\u00a7](https://docs.rs/arc-swap/latest/arc_swap/#reexports)\n\n`pub use crate::cache::Cache[](https://docs.rs/arc-swap/latest/arc_swap/cache/struct.Cache.html \"struct arc_swap::cache::Cache\");`\n\n\n`pub use crate::strategy::DefaultStrategy[](https://docs.rs/arc-swap/latest/arc_swap/strategy/type.DefaultStrategy.html \"type arc_swap::strategy::DefaultStrategy\");`\n\n## Modules[\u00a7](https://docs.rs/arc-swap/latest/arc_swap/#modules)\n\n[access](https://docs.rs/arc-swap/latest/arc_swap/access/index.html \"mod arc_swap::access\")\n    Abstracting over accessing parts of stored value.\n\n[cache](https://docs.rs/arc-swap/latest/arc_swap/cache/index.html \"mod arc_swap::cache\")\n    Caching handle into the [ArcSwapAny](https://docs.rs/arc-swap/latest/arc_swap/struct.ArcSwapAny.html \"struct arc_swap::ArcSwapAny\").\n\n[docs](https://docs.rs/arc-swap/latest/arc_swap/docs/index.html \"mod arc_swap::docs\")\n    Additional documentation.\n\n[strategy](https://docs.rs/arc-swap/latest/arc_swap/strategy/index.html \"mod arc_swap::strategy\")\n    Strategies for protecting the reference counts.\n## Structs[\u00a7](https://docs.rs/arc-swap/latest/arc_swap/#structs)\n\n[ArcSwapAny](https://docs.rs/arc-swap/latest/arc_swap/struct.ArcSwapAny.html \"struct arc_swap::ArcSwapAny\")\n    An atomic storage for a reference counted smart pointer like [`Arc`](https://doc.rust-lang.org/std/sync/struct.Arc.html) or `Option<Arc>`.\n\n[Guard](https://docs.rs/arc-swap/latest/arc_swap/struct.Guard.html \"struct arc_swap::Guard\")\n    A temporary storage of the pointer.\n## Traits[\u00a7](https://docs.rs/arc-swap/latest/arc_swap/#traits)\n\n[AsRaw](https://docs.rs/arc-swap/latest/arc_swap/trait.AsRaw.html \"trait arc_swap::AsRaw\")\n    A trait describing things that can be turned into a raw pointer.\n\n[RefCnt](https://docs.rs/arc-swap/latest/arc_swap/trait.RefCnt.html \"trait arc_swap::RefCnt\")\n    A trait describing smart reference counted pointers.\n## Type Aliases[\u00a7](https://docs.rs/arc-swap/latest/arc_swap/#types)\n\n[ArcSwap](https://docs.rs/arc-swap/latest/arc_swap/type.ArcSwap.html \"type arc_swap::ArcSwap\")\n    An atomic storage for `Arc`.\n\n[ArcSwapOption](https://docs.rs/arc-swap/latest/arc_swap/type.ArcSwapOption.html \"type arc_swap::ArcSwapOption\")\n    An atomic storage for `Option<Arc>`.\n\n[ArcSwapWeak](https://docs.rs/arc-swap/latest/arc_swap/type.ArcSwapWeak.html \"type arc_swap::ArcSwapWeak\")\n    Arc swap for the [Weak](https://doc.rust-lang.org/nightly/alloc/sync/struct.Weak.html \"struct alloc::sync::Weak\") pointer.\n",
        "markdown_with_citations": "[](https://docs.rs/arc-swap/latest/arc_swap/all.html \"show sidebar\")\n# Crate arc_swapCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nMaking `Arc`\u27e84\u27e9 itself atomic\nThe `ArcSwap`\u27e85\u27e9 type is a container for an `Arc` that can be changed atomically. Semantically, it is similar to something like `Atomic<Arc<T>>` (if there was such a thing) or `RwLock<Arc<T>>` (but without the need for the locking). It is optimized for read-mostly scenarios, with consistent performance characteristics.\n## \u00a7\u27e86\u27e9Motivation\nThere are many situations in which one might want to have some data structure that is often read and seldom updated. Some examples might be a configuration of a service, routing tables, snapshot of some data that is renewed every few minutes, etc.\nIn all these cases one needs:\n  * Being able to read the current value of the data structure, fast, often and concurrently from many threads.\n  * Using the same version of the data structure over longer period of time \u2012 a query should be answered by a consistent version of data, a packet should be routed either by an old or by a new version of the routing table but not by a combination, etc.\n  * Perform an update without disrupting the processing.\n\n\nThe first idea would be to use `RwLock<T>`\u27e87\u27e9 and keep a read-lock for the whole time of processing. Update would, however, pause all processing until done.\nBetter option would be to have `RwLock<Arc<T>>`\u27e87\u27e9. Then one would lock, clone the Arc\u27e84\u27e9 and unlock. This suffers from CPU-level contention (on the lock and on the reference count of the Arc\u27e84\u27e9) which makes it relatively slow. Depending on the implementation, an update may be blocked for arbitrary long time by a steady inflow of readers.\n```\nstatic ROUTING_TABLE: Lazy<RwLock<Arc<RoutingTable>>> = Lazy::new(|| {\n  RwLock::new(Arc::new(RoutingTable))\n});\nfn process_packet(packet: Packet) {\n  let table = Arc::clone(&ROUTING_TABLE.read().unwrap());\n  table.route(packet);\n}\n```\n\nThe ArcSwap\u27e85\u27e9 can be used instead, which solves the above problems and has better performance characteristics than the RwLock\u27e87\u27e9, both in contended and non-contended scenarios.\n```\nstatic ROUTING_TABLE: Lazy<ArcSwap<RoutingTable>> = Lazy::new(|| {\n  ArcSwap::from_pointee(RoutingTable)\n});\nfn process_packet(packet: Packet) {\n  let table = ROUTING_TABLE.load();\n  table.route(packet);\n}\n```\n\n## \u00a7\u27e88\u27e9Crate contents\nAt the heart of the crate there are `ArcSwap`\u27e85\u27e9 and `ArcSwapOption`\u27e89\u27e9 types, containers for an `Arc`\u27e84\u27e9 and `Option<Arc>`\u27e810\u27e9.\nTechnically, these are type aliases for partial instantiations of the `ArcSwapAny`\u27e811\u27e9 type. The `ArcSwapAny`\u27e811\u27e9 is more flexible and allows tweaking of many things (can store other things than `Arc`\u27e84\u27e9s, can configure the locking `Strategy`\u27e812\u27e9). For details about the tweaking, see the documentation of the `strategy`\u27e813\u27e9 module and the `RefCnt`\u27e814\u27e9 trait.\nThe `cache`\u27e815\u27e9 module provides means for speeding up read access of the contained data at the cost of delayed reclamation.\nThe `access`\u27e816\u27e9 module can be used to do projections into the contained data to separate parts of application from each other (eg. giving a component access to only its own part of configuration while still having it reloaded as a whole).\n## \u00a7\u27e817\u27e9Before using\nThe data structure is a bit niche. Before using, please check the limitations and common pitfalls\u27e818\u27e9 and the performance characteristics\u27e819\u27e9, including choosing the right read operation\u27e820\u27e9.\nYou can also get an inspiration about what\u2019s possible in the common patterns\u27e821\u27e9 section.\n## \u00a7\u27e822\u27e9Examples\n```\nuse std::sync::Arc;\nuse arc_swap::ArcSwap;\nuse crossbeam_utils::thread;\nlet config = ArcSwap::from(Arc::new(String::default()));\nthread::scope(|scope| {\n  scope.spawn(|_| {\n    let new_conf = Arc::new(\"New configuration\".to_owned());\n    config.store(new_conf);\n  });\n  for _ in 0..10 {\n    scope.spawn(|_| {\n      loop {\n        let cfg = config.load();\n        if !cfg.is_empty() {\n          assert_eq!(**cfg, \"New configuration\");\n          return;\n        }\n      }\n    });\n  }\n}).unwrap();\n```\n\n## Re-exports\u00a7\u27e823\u27e9\n\n`pub use crate::cache::Cache[](https://docs.rs/arc-swap/latest/arc_swap/cache/struct.Cache.html \"struct arc_swap::cache::Cache\");`\n\n\n`pub use crate::strategy::DefaultStrategy[](https://docs.rs/arc-swap/latest/arc_swap/strategy/type.DefaultStrategy.html \"type arc_swap::strategy::DefaultStrategy\");`\n\n## Modules\u00a7\u27e824\u27e9\n\naccess\u27e816\u27e9\n    Abstracting over accessing parts of stored value.\n\ncache\u27e815\u27e9\n    Caching handle into the ArcSwapAny\u27e811\u27e9.\n\ndocs\u27e825\u27e9\n    Additional documentation.\n\nstrategy\u27e813\u27e9\n    Strategies for protecting the reference counts.\n## Structs\u00a7\u27e826\u27e9\n\nArcSwapAny\u27e811\u27e9\n    An atomic storage for a reference counted smart pointer like `Arc`\u27e827\u27e9 or `Option<Arc>`.\n\nGuard\u27e828\u27e9\n    A temporary storage of the pointer.\n## Traits\u00a7\u27e829\u27e9\n\nAsRaw\u27e830\u27e9\n    A trait describing things that can be turned into a raw pointer.\n\nRefCnt\u27e814\u27e9\n    A trait describing smart reference counted pointers.\n## Type Aliases\u00a7\u27e831\u27e9\n\nArcSwap\u27e85\u27e9\n    An atomic storage for `Arc`.\n\nArcSwapOption\u27e89\u27e9\n    An atomic storage for `Option<Arc>`.\n\nArcSwapWeak\u27e832\u27e9\n    Arc swap for the Weak\u27e833\u27e9 pointer.\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/arc-swap/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/arc-swap/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/arc-swap/latest/src/arc_swap/lib.rs.html#1-1317: Source\n\u27e84\u27e9 https://doc.rust-lang.org/nightly/alloc/sync/struct.Arc.html: struct alloc::sync::Arc - `Arc`\n\u27e85\u27e9 https://docs.rs/arc-swap/latest/arc_swap/type.ArcSwap.html: type arc_swap::ArcSwap - `ArcSwap`\n\u27e86\u27e9 https://docs.rs/arc-swap/latest/arc_swap/#motivation: \u00a7\n\u27e87\u27e9 https://doc.rust-lang.org/std/sync/struct.RwLock.html: `RwLock<T>`\n\u27e88\u27e9 https://docs.rs/arc-swap/latest/arc_swap/#crate-contents: \u00a7\n\u27e89\u27e9 https://docs.rs/arc-swap/latest/arc_swap/type.ArcSwapOption.html: type arc_swap::ArcSwapOption - `ArcSwapOption`\n\u27e810\u27e9 https://doc.rust-lang.org/nightly/core/option/enum.Option.html: enum core::option::Option - `Option<Arc>`\n\u27e811\u27e9 https://docs.rs/arc-swap/latest/arc_swap/struct.ArcSwapAny.html: struct arc_swap::ArcSwapAny - `ArcSwapAny`\n\u27e812\u27e9 https://docs.rs/arc-swap/latest/arc_swap/strategy/trait.Strategy.html: trait arc_swap::strategy::Strategy - `Strategy`\n\u27e813\u27e9 https://docs.rs/arc-swap/latest/arc_swap/strategy/index.html: mod arc_swap::strategy - `strategy`\n\u27e814\u27e9 https://docs.rs/arc-swap/latest/arc_swap/trait.RefCnt.html: trait arc_swap::RefCnt - `RefCnt`\n\u27e815\u27e9 https://docs.rs/arc-swap/latest/arc_swap/cache/index.html: mod arc_swap::cache - `cache`\n\u27e816\u27e9 https://docs.rs/arc-swap/latest/arc_swap/access/index.html: mod arc_swap::access - `access`\n\u27e817\u27e9 https://docs.rs/arc-swap/latest/arc_swap/#before-using: \u00a7\n\u27e818\u27e9 https://docs.rs/arc-swap/latest/arc_swap/docs/limitations/index.html: mod arc_swap::docs::limitations - limitations and common pitfalls\n\u27e819\u27e9 https://docs.rs/arc-swap/latest/arc_swap/docs/performance/index.html: mod arc_swap::docs::performance - performance characteristics\n\u27e820\u27e9 https://docs.rs/arc-swap/latest/arc_swap/docs/performance/index.html#read-operations: mod arc_swap::docs::performance - read operation\n\u27e821\u27e9 https://docs.rs/arc-swap/latest/arc_swap/docs/patterns/index.html: mod arc_swap::docs::patterns - common patterns\n\u27e822\u27e9 https://docs.rs/arc-swap/latest/arc_swap/#examples: \u00a7\n\u27e823\u27e9 https://docs.rs/arc-swap/latest/arc_swap/#reexports: \u00a7\n\u27e824\u27e9 https://docs.rs/arc-swap/latest/arc_swap/#modules: \u00a7\n\u27e825\u27e9 https://docs.rs/arc-swap/latest/arc_swap/docs/index.html: mod arc_swap::docs - docs\n\u27e826\u27e9 https://docs.rs/arc-swap/latest/arc_swap/#structs: \u00a7\n\u27e827\u27e9 https://doc.rust-lang.org/std/sync/struct.Arc.html: `Arc`\n\u27e828\u27e9 https://docs.rs/arc-swap/latest/arc_swap/struct.Guard.html: struct arc_swap::Guard - Guard\n\u27e829\u27e9 https://docs.rs/arc-swap/latest/arc_swap/#traits: \u00a7\n\u27e830\u27e9 https://docs.rs/arc-swap/latest/arc_swap/trait.AsRaw.html: trait arc_swap::AsRaw - AsRaw\n\u27e831\u27e9 https://docs.rs/arc-swap/latest/arc_swap/#types: \u00a7\n\u27e832\u27e9 https://docs.rs/arc-swap/latest/arc_swap/type.ArcSwapWeak.html: type arc_swap::ArcSwapWeak - ArcSwapWeak\n\u27e833\u27e9 https://doc.rust-lang.org/nightly/alloc/sync/struct.Weak.html: struct alloc::sync::Weak - Weak\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `arc-swap` crate provides atomic storage for `Arc` and `Option<Arc>` types, enabling fast, thread-safe reads and infrequent updates without locking. It is optimized for read-heavy scenarios, offering better performance than `RwLock` by avoiding contention and ensuring consistent access to shared data. Key features include `ArcSwap`, `ArcSwapOption`, flexible customization via `ArcSwapAny`, caching for faster reads, and projection capabilities for isolating parts of stored data.",
    "feature_summary": null,
    "use_case": "Utilities",
    "score": 8.0,
    "factual_counterfactual": "### Pair 1: Atomic Storage for `Arc`\n\u2705 Factual: The `ArcSwap` type in the `arc-swap` crate provides atomic storage for `Arc`, allowing threads to read and update the contained value without locking mechanisms, making it ideal for read-mostly scenarios.  \n\u274c Counterfactual: The `ArcSwap` type in the `arc-swap` crate requires a mutex for thread-safe updates, making it unsuitable for read-heavy workloads.\n\n---\n\n### Pair 2: Performance Characteristics\n\u2705 Factual: The `ArcSwap` type avoids CPU-level contention on locks and reference counts, providing better performance than `RwLock<Arc<T>>` in both contended and non-contended scenarios.  \n\u274c Counterfactual: The `ArcSwap` type introduces significant CPU-level contention, making it slower than `RwLock<Arc<T>>` for read-heavy workloads.\n\n---\n\n### Pair 3: Use Case Flexibility\n\u2705 Factual: The `ArcSwapAny` type in the `arc-swap` crate allows customization to store types other than `Arc`, enabling tailored strategies for reference counting and locking.  \n\u274c Counterfactual: The `ArcSwapAny` type is restricted to storing only `Arc` instances and cannot be customized for alternative reference-counting strategies.",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}