{
    "name": "xxhash-rust",
    "version": "0.8.15",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/xxhash-rust/latest/xxhash_rust/all.html \"show sidebar\")\n# Crate xxhash_rustCopy item path\n[Settings](https://docs.rs/xxhash-rust/latest/settings.html)\n[Help](https://docs.rs/xxhash-rust/latest/help.html)\nSummary[Source](https://docs.rs/xxhash-rust/latest/src/xxhash_rust/lib.rs.html#1-106)\nExpand description\nImplementation of [xxHash](https://github.com/Cyan4973/xxHash) in Rust\nVersion corresponds to xxHash [releases](https://github.com/Cyan4973/xxHash/releases)\nEach algorithm is implemented via feature, allowing precise control over code size.\n### [\u00a7](https://docs.rs/xxhash-rust/latest/xxhash_rust/#example)Example\n  * Cargo.toml\n\n\n```\n[dependencies.xxhash-rust]\nversion = \"0.8.5\"\nfeatures = [\"xxh3\", \"const_xxh3\"]\n```\n\n  * main.rs\n\n\n```\nuse xxhash_rust::const_xxh3::xxh3_64 as const_xxh3;\nuse xxhash_rust::xxh3::xxh3_64;\nconst TEST: u64 = const_xxh3(b\"TEST\");\nfn test_input(text: &str) -> bool {\n  match xxh3_64(text.as_bytes()) {\n    TEST => true,\n    _ => false\n  }\n}\nassert!(!test_input(\"tEST\"));\nassert!(test_input(\"TEST\"));\n```\n\n### [\u00a7](https://docs.rs/xxhash-rust/latest/xxhash_rust/#features)Features:\nBy default all features are off.\n  * `std` - Enables `std::io::Write` trait implementation\n  * `xxh32` - Enables 32bit algorithm. Suitable for x86 targets\n  * `const_xxh32` - `const fn` version of `xxh32` algorithm\n  * `xxh64` - Enables 64 algorithm. Suitable for x86_64 targets\n  * `const_xxh64` - `const fn` version of `xxh64` algorithm\n  * `xxh3` - Enables `xxh3` family of algorithms, superior to `xxh32` and `xxh64` in terms of performance.\n  * `const_xxh3` - `const fn` version of `xxh3` algorithm\n\n\n### [\u00a7](https://docs.rs/xxhash-rust/latest/xxhash_rust/#hw-acceleration)HW acceleration\nSimilar to reference implementation, crate implements various SIMDs in `xxh3` depending on provided flags. All checks are performed only at compile time, hence user is encouraged to enable these accelerations (for example via `-C target_cpu=native`)\nUsed SIMD acceleration:\n  * SSE2 - widely available, can be safely enabled in 99% of cases. Enabled by default in `x86_64` targets.\n  * AVX2;\n  * Neon - Enabled by default on aarch64 targets (most likely);\n  * Wasm SIMD128 - Has to be enabled via rust flag: `-Ctarget-feature=+simd128`\n\n\n### [\u00a7](https://docs.rs/xxhash-rust/latest/xxhash_rust/#streaming-vs-one-shot)Streaming vs One-shot\nFor performance reasons one-shot version of algorithm does not re-use streaming version. Unless needed, user is advised to use one-shot version which tends to be more optimal.\n### [\u00a7](https://docs.rs/xxhash-rust/latest/xxhash_rust/#cosnt-fn-version)`cosnt fn` version\nWhile `const fn` provides compile time implementation, it does so at performance cost. Hence you should only use it at _compile_ time.\nTo guarantee that something is computed at compile time make sure to initialize hash output as `const` or `static` variable, otherwise it is possible function is executed at runtime, which would be worse than regular algorithm.\n`const fn` is implemented in best possible way while conforming to limitations of Rust `const fn`, but these limitations are quite strict making any high performance code impossible.\n## Modules[\u00a7](https://docs.rs/xxhash-rust/latest/xxhash_rust/#modules)\n\n[const_xxh3](https://docs.rs/xxhash-rust/latest/xxhash_rust/const_xxh3/index.html \"mod xxhash_rust::const_xxh3\")\n    Xxh3 `const fn` implementation\n\n[const_xxh32](https://docs.rs/xxhash-rust/latest/xxhash_rust/const_xxh32/index.html \"mod xxhash_rust::const_xxh32\")\n    Const eval friendly xxh32 implementation.\n\n[const_xxh64](https://docs.rs/xxhash-rust/latest/xxhash_rust/const_xxh64/index.html \"mod xxhash_rust::const_xxh64\")\n    Const 64 bit version of xxhash algorithm\n\n[xxh3](https://docs.rs/xxhash-rust/latest/xxhash_rust/xxh3/index.html \"mod xxhash_rust::xxh3\")\n    XXH3 implementation\n\n[xxh32](https://docs.rs/xxhash-rust/latest/xxhash_rust/xxh32/index.html \"mod xxhash_rust::xxh32\")\n    32 bit version of xxhash algorithm\n\n[xxh64](https://docs.rs/xxhash-rust/latest/xxhash_rust/xxh64/index.html \"mod xxhash_rust::xxh64\")\n    64 bit version of xxhash algorithm\n",
        "markdown_with_citations": "[](https://docs.rs/xxhash-rust/latest/xxhash_rust/all.html \"show sidebar\")\n# Crate xxhash_rustCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nImplementation of xxHash\u27e84\u27e9 in Rust\nVersion corresponds to xxHash releases\u27e85\u27e9\nEach algorithm is implemented via feature, allowing precise control over code size.\n### \u00a7\u27e86\u27e9Example\n  * Cargo.toml\n\n\n```\n[dependencies.xxhash-rust]\nversion = \"0.8.5\"\nfeatures = [\"xxh3\", \"const_xxh3\"]\n```\n\n  * main.rs\n\n\n```\nuse xxhash_rust::const_xxh3::xxh3_64 as const_xxh3;\nuse xxhash_rust::xxh3::xxh3_64;\nconst TEST: u64 = const_xxh3(b\"TEST\");\nfn test_input(text: &str) -> bool {\n  match xxh3_64(text.as_bytes()) {\n    TEST => true,\n    _ => false\n  }\n}\nassert!(!test_input(\"tEST\"));\nassert!(test_input(\"TEST\"));\n```\n\n### \u00a7\u27e87\u27e9Features:\nBy default all features are off.\n  * `std` - Enables `std::io::Write` trait implementation\n  * `xxh32` - Enables 32bit algorithm. Suitable for x86 targets\n  * `const_xxh32` - `const fn` version of `xxh32` algorithm\n  * `xxh64` - Enables 64 algorithm. Suitable for x86_64 targets\n  * `const_xxh64` - `const fn` version of `xxh64` algorithm\n  * `xxh3` - Enables `xxh3` family of algorithms, superior to `xxh32` and `xxh64` in terms of performance.\n  * `const_xxh3` - `const fn` version of `xxh3` algorithm\n\n\n### \u00a7\u27e88\u27e9HW acceleration\nSimilar to reference implementation, crate implements various SIMDs in `xxh3` depending on provided flags. All checks are performed only at compile time, hence user is encouraged to enable these accelerations (for example via `-C target_cpu=native`)\nUsed SIMD acceleration:\n  * SSE2 - widely available, can be safely enabled in 99% of cases. Enabled by default in `x86_64` targets.\n  * AVX2;\n  * Neon - Enabled by default on aarch64 targets (most likely);\n  * Wasm SIMD128 - Has to be enabled via rust flag: `-Ctarget-feature=+simd128`\n\n\n### \u00a7\u27e89\u27e9Streaming vs One-shot\nFor performance reasons one-shot version of algorithm does not re-use streaming version. Unless needed, user is advised to use one-shot version which tends to be more optimal.\n### \u00a7\u27e810\u27e9`cosnt fn` version\nWhile `const fn` provides compile time implementation, it does so at performance cost. Hence you should only use it at _compile_ time.\nTo guarantee that something is computed at compile time make sure to initialize hash output as `const` or `static` variable, otherwise it is possible function is executed at runtime, which would be worse than regular algorithm.\n`const fn` is implemented in best possible way while conforming to limitations of Rust `const fn`, but these limitations are quite strict making any high performance code impossible.\n## Modules\u00a7\u27e811\u27e9\n\nconst_xxh3\u27e812\u27e9\n    Xxh3 `const fn` implementation\n\nconst_xxh32\u27e813\u27e9\n    Const eval friendly xxh32 implementation.\n\nconst_xxh64\u27e814\u27e9\n    Const 64 bit version of xxhash algorithm\n\nxxh3\u27e815\u27e9\n    XXH3 implementation\n\nxxh32\u27e816\u27e9\n    32 bit version of xxhash algorithm\n\nxxh64\u27e817\u27e9\n    64 bit version of xxhash algorithm\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/xxhash-rust/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/xxhash-rust/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/xxhash-rust/latest/src/xxhash_rust/lib.rs.html#1-106: Source\n\u27e84\u27e9 https://github.com/Cyan4973/xxHash: xxHash\n\u27e85\u27e9 https://github.com/Cyan4973/xxHash/releases: releases\n\u27e86\u27e9 https://docs.rs/xxhash-rust/latest/xxhash_rust/#example: \u00a7\n\u27e87\u27e9 https://docs.rs/xxhash-rust/latest/xxhash_rust/#features: \u00a7\n\u27e88\u27e9 https://docs.rs/xxhash-rust/latest/xxhash_rust/#hw-acceleration: \u00a7\n\u27e89\u27e9 https://docs.rs/xxhash-rust/latest/xxhash_rust/#streaming-vs-one-shot: \u00a7\n\u27e810\u27e9 https://docs.rs/xxhash-rust/latest/xxhash_rust/#cosnt-fn-version: \u00a7\n\u27e811\u27e9 https://docs.rs/xxhash-rust/latest/xxhash_rust/#modules: \u00a7\n\u27e812\u27e9 https://docs.rs/xxhash-rust/latest/xxhash_rust/const_xxh3/index.html: mod xxhash_rust::const_xxh3 - const_xxh3\n\u27e813\u27e9 https://docs.rs/xxhash-rust/latest/xxhash_rust/const_xxh32/index.html: mod xxhash_rust::const_xxh32 - const_xxh32\n\u27e814\u27e9 https://docs.rs/xxhash-rust/latest/xxhash_rust/const_xxh64/index.html: mod xxhash_rust::const_xxh64 - const_xxh64\n\u27e815\u27e9 https://docs.rs/xxhash-rust/latest/xxhash_rust/xxh3/index.html: mod xxhash_rust::xxh3 - xxh3\n\u27e816\u27e9 https://docs.rs/xxhash-rust/latest/xxhash_rust/xxh32/index.html: mod xxhash_rust::xxh32 - xxh32\n\u27e817\u27e9 https://docs.rs/xxhash-rust/latest/xxhash_rust/xxh64/index.html: mod xxhash_rust::xxh64 - xxh64\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `xxhash-rust` crate provides a Rust implementation of the high-performance `xxHash` algorithms, including `xxh32`, `xxh64`, and the faster `xxh3` family. It supports both runtime and `const fn` compile-time hashing, with modular features for precise control over code size. The crate also includes hardware acceleration via SIMD (e.g., SSE2, AVX2, Neon, Wasm SIMD128) and offers one-shot and streaming modes for optimal performance.",
    "feature_summary": null,
    "use_case": "Utilities",
    "score": 6.5,
    "factual_counterfactual": "### Pair 1: Feature Implementation  \n\u2705 Factual: The `xxhash-rust` crate implements the `xxh3` algorithm, which is superior to `xxh32` and `xxh64` in terms of performance and is designed for modern hardware.  \n\u274c Counterfactual: The `xxhash-rust` crate does not support the `xxh3` algorithm, focusing only on legacy implementations like `xxh32` and `xxh64`.  \n\n---\n\n### Pair 2: Compile-Time Hashing  \n\u2705 Factual: The crate provides `const fn` versions of hashing algorithms like `const_xxh3` and `const_xxh64`, enabling compile-time computation of hash values.  \n\u274c Counterfactual: The crate's hashing algorithms cannot be used in `const fn` contexts, requiring runtime execution for all hash computations.  \n\n---\n\n### Pair 3: Hardware Acceleration  \n\u2705 Factual: The `xxhash-rust` crate supports SIMD hardware acceleration, including SSE2 for x86_64, Neon for aarch64, and Wasm SIMD128 for WebAssembly targets.  \n\u274c Counterfactual: The `xxhash-rust` crate does not support hardware acceleration and relies entirely on scalar implementations without SIMD optimizations.",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}