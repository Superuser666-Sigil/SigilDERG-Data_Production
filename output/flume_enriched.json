{
    "name": "flume",
    "version": "0.11.1",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/flume/latest/flume/all.html \"show sidebar\")\n# Crate flumeCopy item path\n[Settings](https://docs.rs/flume/latest/settings.html)\n[Help](https://docs.rs/flume/latest/help.html)\nSummary[Source](https://docs.rs/flume/latest/src/flume/lib.rs.html#1-1182)\nExpand description\n## [\u00a7](https://docs.rs/flume/latest/flume/#flume)Flume\nA blazingly fast multi-producer, multi-consumer channel.\n_\u201cDo not communicate by sharing memory; instead, share memory by communicating.\u201d_\n### [\u00a7](https://docs.rs/flume/latest/flume/#why-flume)Why Flume?\n  * **Featureful** : Unbounded, bounded and rendezvous queues\n  * **Fast** : Always faster than `std::sync::mpsc` and sometimes `crossbeam-channel`\n  * **Safe** : No `unsafe` code anywhere in the codebase!\n  * **Flexible** : `Sender` and `Receiver` both implement `Send + Sync + Clone`\n  * **Familiar** : Drop-in replacement for `std::sync::mpsc`\n  * **Capable** : Additional features like MPMC support and send timeouts/deadlines\n  * **Simple** : Few dependencies, minimal codebase, fast to compile\n  * **Asynchronous** : `async` support, including mix \u2019n match with sync code\n  * **Ergonomic** : Powerful `select`-like interface\n\n\n### [\u00a7](https://docs.rs/flume/latest/flume/#example)Example\n```\nlet (tx, rx) = flume::unbounded();\ntx.send(42).unwrap();\nassert_eq!(rx.recv().unwrap(), 42);\n```\n\n## Re-exports[\u00a7](https://docs.rs/flume/latest/flume/#reexports)\n\n`pub use select::Selector[](https://docs.rs/flume/latest/flume/select/struct.Selector.html \"struct flume::select::Selector\");``select`\n\n## Modules[\u00a7](https://docs.rs/flume/latest/flume/#modules)\n\n[async](https://docs.rs/flume/latest/flume/async/index.html \"mod flume::async\")`async`\n    Futures and other types that allow asynchronous interaction with channels.\n\n[select](https://docs.rs/flume/latest/flume/select/index.html \"mod flume::select\")`select`\n    Types that permit waiting upon multiple blocking operations using the [`Selector`](https://docs.rs/flume/latest/flume/select/struct.Selector.html \"struct flume::select::Selector\") interface.\n## Structs[\u00a7](https://docs.rs/flume/latest/flume/#structs)\n\n[Drain](https://docs.rs/flume/latest/flume/struct.Drain.html \"struct flume::Drain\")\n    An fixed-sized iterator over the msgs drained from a channel.\n\n[IntoIter](https://docs.rs/flume/latest/flume/struct.IntoIter.html \"struct flume::IntoIter\")\n    An owned iterator over the msgs received from a channel.\n\n[Iter](https://docs.rs/flume/latest/flume/struct.Iter.html \"struct flume::Iter\")\n    An iterator over the msgs received from a channel.\n\n[Receiver](https://docs.rs/flume/latest/flume/struct.Receiver.html \"struct flume::Receiver\")\n    The receiving end of a channel.\n\n[SendError](https://docs.rs/flume/latest/flume/struct.SendError.html \"struct flume::SendError\")\n    An error that may be emitted when attempting to send a value into a channel on a sender when all receivers are dropped.\n\n[Sender](https://docs.rs/flume/latest/flume/struct.Sender.html \"struct flume::Sender\")\n    A transmitting end of a channel.\n\n[TryIter](https://docs.rs/flume/latest/flume/struct.TryIter.html \"struct flume::TryIter\")\n    An non-blocking iterator over the msgs received from a channel.\n\n[WeakSender](https://docs.rs/flume/latest/flume/struct.WeakSender.html \"struct flume::WeakSender\")\n    A sender that does not prevent the channel from being closed.\n## Enums[\u00a7](https://docs.rs/flume/latest/flume/#enums)\n\n[RecvError](https://docs.rs/flume/latest/flume/enum.RecvError.html \"enum flume::RecvError\")\n    An error that may be emitted when attempting to wait for a value on a receiver when all senders are dropped and there are no more messages in the channel.\n\n[RecvTimeoutError](https://docs.rs/flume/latest/flume/enum.RecvTimeoutError.html \"enum flume::RecvTimeoutError\")\n    An error that may be emitted when attempting to wait for a value on a receiver with a timeout when the receive operation times out or all senders are dropped and there are no values left in the channel.\n\n[SendTimeoutError](https://docs.rs/flume/latest/flume/enum.SendTimeoutError.html \"enum flume::SendTimeoutError\")\n    An error that may be emitted when sending a value into a channel on a sender with a timeout when the send operation times out or all receivers are dropped.\n\n[TryRecvError](https://docs.rs/flume/latest/flume/enum.TryRecvError.html \"enum flume::TryRecvError\")\n    An error that may be emitted when attempting to fetch a value on a receiver when there are no messages in the channel. If there are no messages in the channel and all senders are dropped, then `TryRecvError::Disconnected` will be returned.\n\n[TrySendError](https://docs.rs/flume/latest/flume/enum.TrySendError.html \"enum flume::TrySendError\")\n    An error that may be emitted when attempting to send a value into a channel on a sender when the channel is full or all receivers are dropped.\n## Functions[\u00a7](https://docs.rs/flume/latest/flume/#functions)\n\n[bounded](https://docs.rs/flume/latest/flume/fn.bounded.html \"fn flume::bounded\")\n    Create a channel with a maximum capacity.\n\n[unbounded](https://docs.rs/flume/latest/flume/fn.unbounded.html \"fn flume::unbounded\")\n    Create a channel with no maximum capacity.\n",
        "markdown_with_citations": "[](https://docs.rs/flume/latest/flume/all.html \"show sidebar\")\n# Crate flumeCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\n## \u00a7\u27e84\u27e9Flume\nA blazingly fast multi-producer, multi-consumer channel.\n_\u201cDo not communicate by sharing memory; instead, share memory by communicating.\u201d_\n### \u00a7\u27e85\u27e9Why Flume?\n  * **Featureful** : Unbounded, bounded and rendezvous queues\n  * **Fast** : Always faster than `std::sync::mpsc` and sometimes `crossbeam-channel`\n  * **Safe** : No `unsafe` code anywhere in the codebase!\n  * **Flexible** : `Sender` and `Receiver` both implement `Send + Sync + Clone`\n  * **Familiar** : Drop-in replacement for `std::sync::mpsc`\n  * **Capable** : Additional features like MPMC support and send timeouts/deadlines\n  * **Simple** : Few dependencies, minimal codebase, fast to compile\n  * **Asynchronous** : `async` support, including mix \u2019n match with sync code\n  * **Ergonomic** : Powerful `select`-like interface\n\n\n### \u00a7\u27e86\u27e9Example\n```\nlet (tx, rx) = flume::unbounded();\ntx.send(42).unwrap();\nassert_eq!(rx.recv().unwrap(), 42);\n```\n\n## Re-exports\u00a7\u27e87\u27e9\n\n`pub use select::Selector[](https://docs.rs/flume/latest/flume/select/struct.Selector.html \"struct flume::select::Selector\");``select`\n\n## Modules\u00a7\u27e88\u27e9\n\nasync\u27e89\u27e9`async`\n    Futures and other types that allow asynchronous interaction with channels.\n\nselect\u27e810\u27e9`select`\n    Types that permit waiting upon multiple blocking operations using the `Selector`\u27e811\u27e9 interface.\n## Structs\u00a7\u27e812\u27e9\n\nDrain\u27e813\u27e9\n    An fixed-sized iterator over the msgs drained from a channel.\n\nIntoIter\u27e814\u27e9\n    An owned iterator over the msgs received from a channel.\n\nIter\u27e815\u27e9\n    An iterator over the msgs received from a channel.\n\nReceiver\u27e816\u27e9\n    The receiving end of a channel.\n\nSendError\u27e817\u27e9\n    An error that may be emitted when attempting to send a value into a channel on a sender when all receivers are dropped.\n\nSender\u27e818\u27e9\n    A transmitting end of a channel.\n\nTryIter\u27e819\u27e9\n    An non-blocking iterator over the msgs received from a channel.\n\nWeakSender\u27e820\u27e9\n    A sender that does not prevent the channel from being closed.\n## Enums\u00a7\u27e821\u27e9\n\nRecvError\u27e822\u27e9\n    An error that may be emitted when attempting to wait for a value on a receiver when all senders are dropped and there are no more messages in the channel.\n\nRecvTimeoutError\u27e823\u27e9\n    An error that may be emitted when attempting to wait for a value on a receiver with a timeout when the receive operation times out or all senders are dropped and there are no values left in the channel.\n\nSendTimeoutError\u27e824\u27e9\n    An error that may be emitted when sending a value into a channel on a sender with a timeout when the send operation times out or all receivers are dropped.\n\nTryRecvError\u27e825\u27e9\n    An error that may be emitted when attempting to fetch a value on a receiver when there are no messages in the channel. If there are no messages in the channel and all senders are dropped, then `TryRecvError::Disconnected` will be returned.\n\nTrySendError\u27e826\u27e9\n    An error that may be emitted when attempting to send a value into a channel on a sender when the channel is full or all receivers are dropped.\n## Functions\u00a7\u27e827\u27e9\n\nbounded\u27e828\u27e9\n    Create a channel with a maximum capacity.\n\nunbounded\u27e829\u27e9\n    Create a channel with no maximum capacity.\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/flume/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/flume/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/flume/latest/src/flume/lib.rs.html#1-1182: Source\n\u27e84\u27e9 https://docs.rs/flume/latest/flume/#flume: \u00a7\n\u27e85\u27e9 https://docs.rs/flume/latest/flume/#why-flume: \u00a7\n\u27e86\u27e9 https://docs.rs/flume/latest/flume/#example: \u00a7\n\u27e87\u27e9 https://docs.rs/flume/latest/flume/#reexports: \u00a7\n\u27e88\u27e9 https://docs.rs/flume/latest/flume/#modules: \u00a7\n\u27e89\u27e9 https://docs.rs/flume/latest/flume/async/index.html: mod flume::async - async\n\u27e810\u27e9 https://docs.rs/flume/latest/flume/select/index.html: mod flume::select - select\n\u27e811\u27e9 https://docs.rs/flume/latest/flume/select/struct.Selector.html: struct flume::select::Selector - `Selector`\n\u27e812\u27e9 https://docs.rs/flume/latest/flume/#structs: \u00a7\n\u27e813\u27e9 https://docs.rs/flume/latest/flume/struct.Drain.html: struct flume::Drain - Drain\n\u27e814\u27e9 https://docs.rs/flume/latest/flume/struct.IntoIter.html: struct flume::IntoIter - IntoIter\n\u27e815\u27e9 https://docs.rs/flume/latest/flume/struct.Iter.html: struct flume::Iter - Iter\n\u27e816\u27e9 https://docs.rs/flume/latest/flume/struct.Receiver.html: struct flume::Receiver - Receiver\n\u27e817\u27e9 https://docs.rs/flume/latest/flume/struct.SendError.html: struct flume::SendError - SendError\n\u27e818\u27e9 https://docs.rs/flume/latest/flume/struct.Sender.html: struct flume::Sender - Sender\n\u27e819\u27e9 https://docs.rs/flume/latest/flume/struct.TryIter.html: struct flume::TryIter - TryIter\n\u27e820\u27e9 https://docs.rs/flume/latest/flume/struct.WeakSender.html: struct flume::WeakSender - WeakSender\n\u27e821\u27e9 https://docs.rs/flume/latest/flume/#enums: \u00a7\n\u27e822\u27e9 https://docs.rs/flume/latest/flume/enum.RecvError.html: enum flume::RecvError - RecvError\n\u27e823\u27e9 https://docs.rs/flume/latest/flume/enum.RecvTimeoutError.html: enum flume::RecvTimeoutError - RecvTimeoutError\n\u27e824\u27e9 https://docs.rs/flume/latest/flume/enum.SendTimeoutError.html: enum flume::SendTimeoutError - SendTimeoutError\n\u27e825\u27e9 https://docs.rs/flume/latest/flume/enum.TryRecvError.html: enum flume::TryRecvError - TryRecvError\n\u27e826\u27e9 https://docs.rs/flume/latest/flume/enum.TrySendError.html: enum flume::TrySendError - TrySendError\n\u27e827\u27e9 https://docs.rs/flume/latest/flume/#functions: \u00a7\n\u27e828\u27e9 https://docs.rs/flume/latest/flume/fn.bounded.html: fn flume::bounded - bounded\n\u27e829\u27e9 https://docs.rs/flume/latest/flume/fn.unbounded.html: fn flume::unbounded - unbounded\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `flume` crate provides a fast, safe, and feature-rich multi-producer, multi-consumer (MPMC) channel for message passing in Rust. It supports unbounded, bounded, and rendezvous queues, offers both synchronous and asynchronous functionality, and includes advanced features like send timeouts, deadlines, and a powerful `select`-like interface. Designed as a drop-in replacement for `std::sync::mpsc`, it is ergonomic, lightweight, and entirely free of `unsafe` code.",
    "feature_summary": null,
    "use_case": "Utilities",
    "score": 8.0,
    "factual_counterfactual": "### Pair 1: Channel Types  \n\u2705 Factual: Flume supports unbounded, bounded, and rendezvous channels, providing flexibility for different use cases.  \n\u274c Counterfactual: Flume only supports unbounded channels and does not provide bounded or rendezvous options.  \n\n---\n\n### Pair 2: Performance  \n\u2705 Factual: Flume is faster than `std::sync::mpsc` and sometimes outperforms `crossbeam-channel` in benchmarks.  \n\u274c Counterfactual: Flume is slower than `std::sync::mpsc` and comparable to `crossbeam-channel` in terms of performance.  \n\n---\n\n### Pair 3: Safety  \n\u2705 Factual: Flume's codebase contains no `unsafe` code, ensuring memory safety throughout its implementation.  \n\u274c Counterfactual: Flume relies on `unsafe` code internally to achieve its high performance.",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}