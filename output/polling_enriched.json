{
    "name": "polling",
    "version": "3.8.0",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/polling/latest/polling/all.html \"show sidebar\")\n# Crate pollingCopy item path\n[Settings](https://docs.rs/polling/latest/settings.html)\n[Help](https://docs.rs/polling/latest/help.html)\nSummary[Source](https://docs.rs/polling/latest/src/polling/lib.rs.html#1-1118)\nExpand description\nPortable interface to epoll, kqueue, event ports, and IOCP.\nSupported platforms:\n  * [epoll](https://en.wikipedia.org/wiki/Epoll): Linux, Android, RedoxOS\n  * [kqueue](https://en.wikipedia.org/wiki/Kqueue): macOS, iOS, tvOS, watchOS, visionOS, FreeBSD, NetBSD, OpenBSD, DragonFly BSD\n  * [event ports](https://illumos.org/man/port_create): illumos, Solaris\n  * [poll](https://en.wikipedia.org/wiki/Poll_\\(Unix\\)): VxWorks, Fuchsia, HermitOS, other Unix systems\n  * [IOCP](https://learn.microsoft.com/en-us/windows/win32/fileio/i-o-completion-ports): Windows, Wine (version 7.13+)\n\n\nBy default, polling is done in oneshot mode, which means interest in I/O events needs to be re-enabled after an event is delivered if we\u2019re interested in the next event of the same kind. However, level and edge triggered modes are also available for certain operating systems. See the documentation of the [`PollMode`](https://docs.rs/polling/latest/polling/enum.PollMode.html \"enum polling::PollMode\") type for more information.\nOnly one thread can be waiting for I/O events at a time.\n## [\u00a7](https://docs.rs/polling/latest/polling/#examples)Examples\n```\nuse polling::{Event, Events, Poller};\nuse std::net::TcpListener;\n// Create a TCP listener.\nlet socket = TcpListener::bind(\"127.0.0.1:8000\")?;\nsocket.set_nonblocking(true)?;\nlet key = 7; // Arbitrary key identifying the socket.\n// Create a poller and register interest in readability on the socket.\nlet poller = Poller::new()?;\nunsafe {\n  poller.add(&socket, Event::readable(key))?;\n}\n// The event loop.\nlet mut events = Events::new();\nloop {\n  // Wait for at least one I/O event.\n  events.clear();\n  poller.wait(&mut events, None)?;\n  for ev in events.iter() {\n    if ev.key == key {\n      // Perform a non-blocking accept operation.\n      socket.accept()?;\n      // Set interest in the next readability event.\n      poller.modify(&socket, Event::readable(key))?;\n    }\n  }\n}\npoller.delete(&socket)?;\n```\n\n## Modules[\u00a7](https://docs.rs/polling/latest/polling/#modules)\n\n[os](https://docs.rs/polling/latest/polling/os/index.html \"mod polling::os\")\n    Platform-specific functionality.\n## Structs[\u00a7](https://docs.rs/polling/latest/polling/#structs)\n\n[Event](https://docs.rs/polling/latest/polling/struct.Event.html \"struct polling::Event\")\n    Indicates that a file descriptor or socket can read or write without blocking.\n\n[Events](https://docs.rs/polling/latest/polling/struct.Events.html \"struct polling::Events\")\n    A container for I/O events.\n\n[Poller](https://docs.rs/polling/latest/polling/struct.Poller.html \"struct polling::Poller\")\n    Waits for I/O events.\n## Enums[\u00a7](https://docs.rs/polling/latest/polling/#enums)\n\n[PollMode](https://docs.rs/polling/latest/polling/enum.PollMode.html \"enum polling::PollMode\")\n    The mode in which the poller waits for I/O events.\n## Traits[\u00a7](https://docs.rs/polling/latest/polling/#traits)\n\n[AsRawSource](https://docs.rs/polling/latest/polling/trait.AsRawSource.html \"trait polling::AsRawSource\")\n    A resource with a raw file descriptor.\n\n[AsSource](https://docs.rs/polling/latest/polling/trait.AsSource.html \"trait polling::AsSource\")\n    A resource with a borrowed file descriptor.\n",
        "markdown_with_citations": "[](https://docs.rs/polling/latest/polling/all.html \"show sidebar\")\n# Crate pollingCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nPortable interface to epoll, kqueue, event ports, and IOCP.\nSupported platforms:\n  * epoll\u27e84\u27e9: Linux, Android, RedoxOS\n  * kqueue\u27e85\u27e9: macOS, iOS, tvOS, watchOS, visionOS, FreeBSD, NetBSD, OpenBSD, DragonFly BSD\n  * event ports\u27e86\u27e9: illumos, Solaris\n  * poll\u27e87\u27e9): VxWorks, Fuchsia, HermitOS, other Unix systems\n  * IOCP\u27e88\u27e9: Windows, Wine (version 7.13+)\n\n\nBy default, polling is done in oneshot mode, which means interest in I/O events needs to be re-enabled after an event is delivered if we\u2019re interested in the next event of the same kind. However, level and edge triggered modes are also available for certain operating systems. See the documentation of the `PollMode`\u27e89\u27e9 type for more information.\nOnly one thread can be waiting for I/O events at a time.\n## \u00a7\u27e810\u27e9Examples\n```\nuse polling::{Event, Events, Poller};\nuse std::net::TcpListener;\n// Create a TCP listener.\nlet socket = TcpListener::bind(\"127.0.0.1:8000\")?;\nsocket.set_nonblocking(true)?;\nlet key = 7; // Arbitrary key identifying the socket.\n// Create a poller and register interest in readability on the socket.\nlet poller = Poller::new()?;\nunsafe {\n  poller.add(&socket, Event::readable(key))?;\n}\n// The event loop.\nlet mut events = Events::new();\nloop {\n  // Wait for at least one I/O event.\n  events.clear();\n  poller.wait(&mut events, None)?;\n  for ev in events.iter() {\n    if ev.key == key {\n      // Perform a non-blocking accept operation.\n      socket.accept()?;\n      // Set interest in the next readability event.\n      poller.modify(&socket, Event::readable(key))?;\n    }\n  }\n}\npoller.delete(&socket)?;\n```\n\n## Modules\u00a7\u27e811\u27e9\n\nos\u27e812\u27e9\n    Platform-specific functionality.\n## Structs\u00a7\u27e813\u27e9\n\nEvent\u27e814\u27e9\n    Indicates that a file descriptor or socket can read or write without blocking.\n\nEvents\u27e815\u27e9\n    A container for I/O events.\n\nPoller\u27e816\u27e9\n    Waits for I/O events.\n## Enums\u00a7\u27e817\u27e9\n\nPollMode\u27e89\u27e9\n    The mode in which the poller waits for I/O events.\n## Traits\u00a7\u27e818\u27e9\n\nAsRawSource\u27e819\u27e9\n    A resource with a raw file descriptor.\n\nAsSource\u27e820\u27e9\n    A resource with a borrowed file descriptor.\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/polling/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/polling/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/polling/latest/src/polling/lib.rs.html#1-1118: Source\n\u27e84\u27e9 https://en.wikipedia.org/wiki/Epoll: epoll\n\u27e85\u27e9 https://en.wikipedia.org/wiki/Kqueue: kqueue\n\u27e86\u27e9 https://illumos.org/man/port_create: event ports\n\u27e87\u27e9 https://en.wikipedia.org/wiki/Poll_\\(Unix\\: poll\n\u27e88\u27e9 https://learn.microsoft.com/en-us/windows/win32/fileio/i-o-completion-ports: IOCP\n\u27e89\u27e9 https://docs.rs/polling/latest/polling/enum.PollMode.html: enum polling::PollMode - `PollMode`\n\u27e810\u27e9 https://docs.rs/polling/latest/polling/#examples: \u00a7\n\u27e811\u27e9 https://docs.rs/polling/latest/polling/#modules: \u00a7\n\u27e812\u27e9 https://docs.rs/polling/latest/polling/os/index.html: mod polling::os - os\n\u27e813\u27e9 https://docs.rs/polling/latest/polling/#structs: \u00a7\n\u27e814\u27e9 https://docs.rs/polling/latest/polling/struct.Event.html: struct polling::Event - Event\n\u27e815\u27e9 https://docs.rs/polling/latest/polling/struct.Events.html: struct polling::Events - Events\n\u27e816\u27e9 https://docs.rs/polling/latest/polling/struct.Poller.html: struct polling::Poller - Poller\n\u27e817\u27e9 https://docs.rs/polling/latest/polling/#enums: \u00a7\n\u27e818\u27e9 https://docs.rs/polling/latest/polling/#traits: \u00a7\n\u27e819\u27e9 https://docs.rs/polling/latest/polling/trait.AsRawSource.html: trait polling::AsRawSource - AsRawSource\n\u27e820\u27e9 https://docs.rs/polling/latest/polling/trait.AsSource.html: trait polling::AsSource - AsSource\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `polling` crate provides a portable interface for efficient I/O event polling across multiple platforms, supporting mechanisms like `epoll`, `kqueue`, `event ports`, `poll`, and `IOCP`. It operates primarily in oneshot mode, with options for level and edge-triggered modes, and allows a single thread to wait for I/O events. Key features include the `Poller` for event management, `Event` and `Events` structs for handling I/O readiness, and platform-specific functionality via the `os` module.",
    "feature_summary": null,
    "use_case": "Networking",
    "score": 6.0,
    "factual_counterfactual": "### Pair 1: Platform Support  \n\u2705 **Factual:** The `polling` crate provides a portable interface to epoll, kqueue, event ports, poll, and IOCP, supporting platforms like Linux, macOS, Windows, and Solaris.  \n\u274c **Counterfactual:** The `polling` crate supports all platforms uniformly, including real-time operating systems like RTEMS and embedded systems like Arduino.  \n\n---\n\n### Pair 2: Polling Modes  \n\u2705 **Factual:** By default, the `polling` crate operates in oneshot mode, requiring re-enabling interest in I/O events after an event is delivered, but it also supports level-triggered and edge-triggered modes on compatible operating systems.  \n\u274c **Counterfactual:** The `polling` crate exclusively operates in edge-triggered mode, making it incompatible with oneshot or level-triggered polling mechanisms.  \n\n---\n\n### Pair 3: Threading Behavior  \n\u2705 **Factual:** The `polling` crate restricts I/O event polling to a single thread at a time, ensuring safe and predictable usage patterns.  \n\u274c **Counterfactual:** The `polling` crate allows multiple threads to simultaneously wait for I/O events on the same poller, leveraging parallelism for higher throughput.",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}