{
    "name": "aes-gcm",
    "version": "0.11.0-rc.0",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/aes-gcm/latest/aes_gcm/all.html \"show sidebar\")\n# Crate aes_gcmCopy item path\n[Settings](https://docs.rs/aes-gcm/latest/settings.html)\n[Help](https://docs.rs/aes-gcm/latest/help.html)\nSummary[Source](https://docs.rs/aes-gcm/latest/src/aes_gcm/lib.rs.html#1-373)\nExpand description\n## [\u00a7](https://docs.rs/aes-gcm/latest/aes_gcm/#rustcrypto-aes-gcm)RustCrypto: AES-GCM\n[![crate](https://buildstats.info/crate/aes-gcm)](https://crates.io/crates/aes-gcm) [![Docs](https://docs.rs/aes-gcm/badge.svg)](https://docs.rs/aes-gcm/) ![Apache2/MIT licensed](https://img.shields.io/badge/license-Apache2.0/MIT-blue.svg) ![Rust Version](https://img.shields.io/badge/rustc-1.56+-blue.svg) [![Project Chat](https://img.shields.io/badge/zulip-join_chat-blue.svg)](https://rustcrypto.zulipchat.com/#narrow/stream/260038-AEADs) [![Build Status](https://github.com/RustCrypto/AEADs/workflows/aes-gcm/badge.svg?branch=master&event=push)](https://github.com/RustCrypto/AEADs/actions)\nPure Rust implementation of the AES-GCM [Authenticated Encryption with Associated Data (AEAD)](https://en.wikipedia.org/wiki/Authenticated_encryption) cipher.\n[Documentation](https://docs.rs/aes-gcm/)\n### [\u00a7](https://docs.rs/aes-gcm/latest/aes_gcm/#security-notes)Security Notes\nThis crate has received one [security audit by NCC Group](https://research.nccgroup.com/2020/02/26/public-report-rustcrypto-aes-gcm-and-chacha20poly1305-implementation-review/), with no significant findings. We would like to thank [MobileCoin](https://www.mobilecoin.com/) for funding the audit.\nAll implementations contained in the crate are designed to execute in constant time, either by relying on hardware intrinsics (i.e. AES-NI and CLMUL on x86/x86_64), or using a portable implementation which is only constant time on processors which implement constant-time multiplication.\nIt is not suitable for use on processors with a variable-time multiplication operation (e.g. short circuit on multiply-by-zero / multiply-by-one, such as certain 32-bit PowerPC CPUs and some non-ARM microcontrollers).\n### [\u00a7](https://docs.rs/aes-gcm/latest/aes_gcm/#license)License\nLicensed under either of:\n  * [Apache License, Version 2.0](http://www.apache.org/licenses/LICENSE-2.0)\n  * [MIT license](http://opensource.org/licenses/MIT)\n\n\nat your option.\n#### [\u00a7](https://docs.rs/aes-gcm/latest/aes_gcm/#contribution)Contribution\nUnless you explicitly state otherwise, any contribution intentionally submitted for inclusion in the work by you, as defined in the Apache-2.0 license, shall be dual licensed as above, without any additional terms or conditions.\n## [\u00a7](https://docs.rs/aes-gcm/latest/aes_gcm/#usage)Usage\nSimple usage (allocating, no associated data):\n```\nuse aes_gcm::{\n  aead::{Aead, AeadCore, KeyInit, OsRng},\n  Aes256Gcm, Nonce, Key // Or `Aes128Gcm`\n};\n// The encryption key can be generated randomly:\nlet key = Aes256Gcm::generate_key(OsRng);\n// Transformed from a byte array:\nlet key: &[u8; 32] = &[42; 32];\nlet key: &Key<Aes256Gcm> = key.into();\n// Note that you can get byte array from slice using the `TryInto` trait:\nlet key: &[u8] = &[42; 32];\nlet key: [u8; 32] = key.try_into()?;\n// Alternatively, the key can be transformed directly from a byte slice\n// (panicks on length mismatch):\nlet key = Key::<Aes256Gcm>::from_slice(key);\nlet cipher = Aes256Gcm::new(&key);\nlet nonce = Aes256Gcm::generate_nonce(&mut OsRng); // 96-bits; unique per message\nlet ciphertext = cipher.encrypt(&nonce, b\"plaintext message\".as_ref())?;\nlet plaintext = cipher.decrypt(&nonce, ciphertext.as_ref())?;\nassert_eq!(&plaintext, b\"plaintext message\");\n```\n\n### [\u00a7](https://docs.rs/aes-gcm/latest/aes_gcm/#in-place-usage-eliminates-alloc-requirement)In-place Usage (eliminates `alloc` requirement)\nThis crate has an optional `alloc` feature which can be disabled in e.g. microcontroller environments that don\u2019t have a heap.\nThe [`AeadInPlace::encrypt_in_place`](https://docs.rs/aes-gcm/latest/aes_gcm/trait.AeadInPlace.html#method.encrypt_in_place \"method aes_gcm::AeadInPlace::encrypt_in_place\") and [`AeadInPlace::decrypt_in_place`](https://docs.rs/aes-gcm/latest/aes_gcm/trait.AeadInPlace.html#method.decrypt_in_place \"method aes_gcm::AeadInPlace::decrypt_in_place\") methods accept any type that impls the [`aead::Buffer`](https://docs.rs/aead/0.5.2/x86_64-unknown-linux-gnu/aead/trait.Buffer.html \"trait aead::Buffer\") trait which contains the plaintext for encryption or ciphertext for decryption.\nNote that if you enable the `heapless` feature of this crate, you will receive an impl of [`aead::Buffer`](https://docs.rs/aead/0.5.2/x86_64-unknown-linux-gnu/aead/trait.Buffer.html \"trait aead::Buffer\") for `heapless::Vec` (re-exported from the [`aead`](https://docs.rs/aead/0.5.2/x86_64-unknown-linux-gnu/aead/index.html \"mod aead\") crate as [`aead::heapless::Vec`](https://docs.rs/heapless/0.7.17/x86_64-unknown-linux-gnu/heapless/vec/struct.Vec.html \"struct heapless::vec::Vec\")), which can then be passed as the `buffer` parameter to the in-place encrypt and decrypt methods:\n```\nuse aes_gcm::{\n  aead::{AeadCore, AeadInPlace, KeyInit, OsRng, heapless::Vec},\n  Aes256Gcm, Nonce, // Or `Aes128Gcm`\n};\nlet key = Aes256Gcm::generate_key(&mut OsRng);\nlet cipher = Aes256Gcm::new(&key);\nlet nonce = Aes256Gcm::generate_nonce(&mut OsRng); // 96-bits; unique per message\nlet mut buffer: Vec<u8, 128> = Vec::new(); // Note: buffer needs 16-bytes overhead for auth tag\nbuffer.extend_from_slice(b\"plaintext message\");\n// Encrypt `buffer` in-place, replacing the plaintext contents with ciphertext\ncipher.encrypt_in_place(&nonce, b\"\", &mut buffer)?;\n// `buffer` now contains the message ciphertext\nassert_ne!(&buffer, b\"plaintext message\");\n// Decrypt `buffer` in-place, replacing its ciphertext context with the original plaintext\ncipher.decrypt_in_place(&nonce, b\"\", &mut buffer)?;\nassert_eq!(&buffer, b\"plaintext message\");\n```\n\nSimilarly, enabling the `arrayvec` feature of this crate will provide an impl of [`aead::Buffer`](https://docs.rs/aead/0.5.2/x86_64-unknown-linux-gnu/aead/trait.Buffer.html \"trait aead::Buffer\") for `arrayvec::ArrayVec` (re-exported from the [`aead`](https://docs.rs/aead/0.5.2/x86_64-unknown-linux-gnu/aead/index.html \"mod aead\") crate as [`aead::arrayvec::ArrayVec`](https://docs.rs/arrayvec/0.7.6/x86_64-unknown-linux-gnu/arrayvec/arrayvec/struct.ArrayVec.html \"struct arrayvec::arrayvec::ArrayVec\")).\n## Re-exports[\u00a7](https://docs.rs/aes-gcm/latest/aes_gcm/#reexports)\n\n`pub use aead[](https://docs.rs/aead/0.5.2/x86_64-unknown-linux-gnu/aead/index.html \"mod aead\");`\n\n\n`pub use aes[](https://docs.rs/aes/0.8.4/x86_64-unknown-linux-gnu/aes/index.html \"mod aes\");`\n\n## Structs[\u00a7](https://docs.rs/aes-gcm/latest/aes_gcm/#structs)\n\n[AesGcm](https://docs.rs/aes-gcm/latest/aes_gcm/struct.AesGcm.html \"struct aes_gcm::AesGcm\")\n    AES-GCM: generic over an underlying AES implementation and nonce size.\n\n[Error](https://docs.rs/aes-gcm/latest/aes_gcm/struct.Error.html \"struct aes_gcm::Error\")\n    Error type.\n## Constants[\u00a7](https://docs.rs/aes-gcm/latest/aes_gcm/#constants)\n\n[A_MAX](https://docs.rs/aes-gcm/latest/aes_gcm/constant.A_MAX.html \"constant aes_gcm::A_MAX\")\n    Maximum length of associated data.\n\n[C_MAX](https://docs.rs/aes-gcm/latest/aes_gcm/constant.C_MAX.html \"constant aes_gcm::C_MAX\")\n    Maximum length of ciphertext.\n\n[P_MAX](https://docs.rs/aes-gcm/latest/aes_gcm/constant.P_MAX.html \"constant aes_gcm::P_MAX\")\n    Maximum length of plaintext.\n## Traits[\u00a7](https://docs.rs/aes-gcm/latest/aes_gcm/#traits)\n\n[AeadCore](https://docs.rs/aes-gcm/latest/aes_gcm/trait.AeadCore.html \"trait aes_gcm::AeadCore\")\n    Authenticated Encryption with Associated Data (AEAD) algorithm core trait.\n\n[AeadInPlace](https://docs.rs/aes-gcm/latest/aes_gcm/trait.AeadInPlace.html \"trait aes_gcm::AeadInPlace\")\n    In-place stateless AEAD trait.\n\n[KeyInit](https://docs.rs/aes-gcm/latest/aes_gcm/trait.KeyInit.html \"trait aes_gcm::KeyInit\")\n    Types which can be initialized from key.\n\n[KeySizeUser](https://docs.rs/aes-gcm/latest/aes_gcm/trait.KeySizeUser.html \"trait aes_gcm::KeySizeUser\")\n    Types which use key for initialization.\n\n[TagSize](https://docs.rs/aes-gcm/latest/aes_gcm/trait.TagSize.html \"trait aes_gcm::TagSize\")\n    Trait implemented for valid tag sizes, i.e. [`U12`][consts::U12], [`U13`][consts::U13], [`U14`][consts::U14], [`U15`][consts::U15] and [`U16`][consts::U16].\n## Type Aliases[\u00a7](https://docs.rs/aes-gcm/latest/aes_gcm/#types)\n\n[Aes128Gcm](https://docs.rs/aes-gcm/latest/aes_gcm/type.Aes128Gcm.html \"type aes_gcm::Aes128Gcm\")`aes`\n    AES-GCM with a 128-bit key and 96-bit nonce.\n\n[Aes256Gcm](https://docs.rs/aes-gcm/latest/aes_gcm/type.Aes256Gcm.html \"type aes_gcm::Aes256Gcm\")`aes`\n    AES-GCM with a 256-bit key and 96-bit nonce.\n\n[Key](https://docs.rs/aes-gcm/latest/aes_gcm/type.Key.html \"type aes_gcm::Key\")\n    Key used by [`KeySizeUser`](https://docs.rs/aes-gcm/latest/aes_gcm/trait.KeySizeUser.html \"trait aes_gcm::KeySizeUser\") implementors.\n\n[Nonce](https://docs.rs/aes-gcm/latest/aes_gcm/type.Nonce.html \"type aes_gcm::Nonce\")\n    AES-GCM nonces.\n\n[Tag](https://docs.rs/aes-gcm/latest/aes_gcm/type.Tag.html \"type aes_gcm::Tag\")\n    AES-GCM tags.\n",
        "markdown_with_citations": "[](https://docs.rs/aes-gcm/latest/aes_gcm/all.html \"show sidebar\")\n# Crate aes_gcmCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\n## \u00a7\u27e84\u27e9RustCrypto: AES-GCM\n![crate\u27e85\u27e9](https://crates.io/crates/aes-gcm) ![Docs\u27e86\u27e9](https://docs.rs/aes-gcm/) ![Apache2/MIT licensed\u27e87\u27e9] ![Rust Version\u27e88\u27e9] ![Project Chat\u27e89\u27e9](https://rustcrypto.zulipchat.com/#narrow/stream/260038-AEADs) ![Build Status\u27e810\u27e9](https://github.com/RustCrypto/AEADs/actions)\nPure Rust implementation of the AES-GCM Authenticated Encryption with Associated Data (AEAD)\u27e811\u27e9 cipher.\nDocumentation\u27e812\u27e9\n### \u00a7\u27e813\u27e9Security Notes\nThis crate has received one security audit by NCC Group\u27e814\u27e9, with no significant findings. We would like to thank MobileCoin\u27e815\u27e9 for funding the audit.\nAll implementations contained in the crate are designed to execute in constant time, either by relying on hardware intrinsics (i.e. AES-NI and CLMUL on x86/x86_64), or using a portable implementation which is only constant time on processors which implement constant-time multiplication.\nIt is not suitable for use on processors with a variable-time multiplication operation (e.g. short circuit on multiply-by-zero / multiply-by-one, such as certain 32-bit PowerPC CPUs and some non-ARM microcontrollers).\n### \u00a7\u27e816\u27e9License\nLicensed under either of:\n  * Apache License, Version 2.0\u27e817\u27e9\n  * MIT license\u27e818\u27e9\n\n\nat your option.\n#### \u00a7\u27e819\u27e9Contribution\nUnless you explicitly state otherwise, any contribution intentionally submitted for inclusion in the work by you, as defined in the Apache-2.0 license, shall be dual licensed as above, without any additional terms or conditions.\n## \u00a7\u27e820\u27e9Usage\nSimple usage (allocating, no associated data):\n```\nuse aes_gcm::{\n  aead::{Aead, AeadCore, KeyInit, OsRng},\n  Aes256Gcm, Nonce, Key // Or `Aes128Gcm`\n};\n// The encryption key can be generated randomly:\nlet key = Aes256Gcm::generate_key(OsRng);\n// Transformed from a byte array:\nlet key: &[u8; 32] = &[42; 32];\nlet key: &Key<Aes256Gcm> = key.into();\n// Note that you can get byte array from slice using the `TryInto` trait:\nlet key: &[u8] = &[42; 32];\nlet key: [u8; 32] = key.try_into()?;\n// Alternatively, the key can be transformed directly from a byte slice\n// (panicks on length mismatch):\nlet key = Key::<Aes256Gcm>::from_slice(key);\nlet cipher = Aes256Gcm::new(&key);\nlet nonce = Aes256Gcm::generate_nonce(&mut OsRng); // 96-bits; unique per message\nlet ciphertext = cipher.encrypt(&nonce, b\"plaintext message\".as_ref())?;\nlet plaintext = cipher.decrypt(&nonce, ciphertext.as_ref())?;\nassert_eq!(&plaintext, b\"plaintext message\");\n```\n\n### \u00a7\u27e821\u27e9In-place Usage (eliminates `alloc` requirement)\nThis crate has an optional `alloc` feature which can be disabled in e.g. microcontroller environments that don\u2019t have a heap.\nThe `AeadInPlace::encrypt_in_place`\u27e822\u27e9 and `AeadInPlace::decrypt_in_place`\u27e823\u27e9 methods accept any type that impls the `aead::Buffer`\u27e824\u27e9 trait which contains the plaintext for encryption or ciphertext for decryption.\nNote that if you enable the `heapless` feature of this crate, you will receive an impl of `aead::Buffer`\u27e824\u27e9 for `heapless::Vec` (re-exported from the `aead`\u27e825\u27e9 crate as `aead::heapless::Vec`\u27e826\u27e9), which can then be passed as the `buffer` parameter to the in-place encrypt and decrypt methods:\n```\nuse aes_gcm::{\n  aead::{AeadCore, AeadInPlace, KeyInit, OsRng, heapless::Vec},\n  Aes256Gcm, Nonce, // Or `Aes128Gcm`\n};\nlet key = Aes256Gcm::generate_key(&mut OsRng);\nlet cipher = Aes256Gcm::new(&key);\nlet nonce = Aes256Gcm::generate_nonce(&mut OsRng); // 96-bits; unique per message\nlet mut buffer: Vec<u8, 128> = Vec::new(); // Note: buffer needs 16-bytes overhead for auth tag\nbuffer.extend_from_slice(b\"plaintext message\");\n// Encrypt `buffer` in-place, replacing the plaintext contents with ciphertext\ncipher.encrypt_in_place(&nonce, b\"\", &mut buffer)?;\n// `buffer` now contains the message ciphertext\nassert_ne!(&buffer, b\"plaintext message\");\n// Decrypt `buffer` in-place, replacing its ciphertext context with the original plaintext\ncipher.decrypt_in_place(&nonce, b\"\", &mut buffer)?;\nassert_eq!(&buffer, b\"plaintext message\");\n```\n\nSimilarly, enabling the `arrayvec` feature of this crate will provide an impl of `aead::Buffer`\u27e824\u27e9 for `arrayvec::ArrayVec` (re-exported from the `aead`\u27e825\u27e9 crate as `aead::arrayvec::ArrayVec`\u27e827\u27e9).\n## Re-exports\u00a7\u27e828\u27e9\n\n`pub use aead[](https://docs.rs/aead/0.5.2/x86_64-unknown-linux-gnu/aead/index.html \"mod aead\");`\n\n\n`pub use aes[](https://docs.rs/aes/0.8.4/x86_64-unknown-linux-gnu/aes/index.html \"mod aes\");`\n\n## Structs\u00a7\u27e829\u27e9\n\nAesGcm\u27e830\u27e9\n    AES-GCM: generic over an underlying AES implementation and nonce size.\n\nError\u27e831\u27e9\n    Error type.\n## Constants\u00a7\u27e832\u27e9\n\nA_MAX\u27e833\u27e9\n    Maximum length of associated data.\n\nC_MAX\u27e834\u27e9\n    Maximum length of ciphertext.\n\nP_MAX\u27e835\u27e9\n    Maximum length of plaintext.\n## Traits\u00a7\u27e836\u27e9\n\nAeadCore\u27e837\u27e9\n    Authenticated Encryption with Associated Data (AEAD) algorithm core trait.\n\nAeadInPlace\u27e838\u27e9\n    In-place stateless AEAD trait.\n\nKeyInit\u27e839\u27e9\n    Types which can be initialized from key.\n\nKeySizeUser\u27e840\u27e9\n    Types which use key for initialization.\n\nTagSize\u27e841\u27e9\n    Trait implemented for valid tag sizes, i.e. [`U12`][consts::U12], [`U13`][consts::U13], [`U14`][consts::U14], [`U15`][consts::U15] and [`U16`][consts::U16].\n## Type Aliases\u00a7\u27e842\u27e9\n\nAes128Gcm\u27e843\u27e9`aes`\n    AES-GCM with a 128-bit key and 96-bit nonce.\n\nAes256Gcm\u27e844\u27e9`aes`\n    AES-GCM with a 256-bit key and 96-bit nonce.\n\nKey\u27e845\u27e9\n    Key used by `KeySizeUser`\u27e840\u27e9 implementors.\n\nNonce\u27e846\u27e9\n    AES-GCM nonces.\n\nTag\u27e847\u27e9\n    AES-GCM tags.\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/aes-gcm/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/aes-gcm/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/aes-gcm/latest/src/aes_gcm/lib.rs.html#1-373: Source\n\u27e84\u27e9 https://docs.rs/aes-gcm/latest/aes_gcm/#rustcrypto-aes-gcm: \u00a7\n\u27e85\u27e9 https://buildstats.info/crate/aes-gcm: ![crate\n\u27e86\u27e9 https://docs.rs/aes-gcm/badge.svg: ![Docs\n\u27e87\u27e9 https://img.shields.io/badge/license-Apache2.0/MIT-blue.svg: Apache2/MIT licensed\n\u27e88\u27e9 https://img.shields.io/badge/rustc-1.56+-blue.svg: Rust Version\n\u27e89\u27e9 https://img.shields.io/badge/zulip-join_chat-blue.svg: ![Project Chat\n\u27e810\u27e9 https://github.com/RustCrypto/AEADs/workflows/aes-gcm/badge.svg?branch=master&event=push: ![Build Status\n\u27e811\u27e9 https://en.wikipedia.org/wiki/Authenticated_encryption: Authenticated Encryption with Associated Data (AEAD)\n\u27e812\u27e9 https://docs.rs/aes-gcm/: Documentation\n\u27e813\u27e9 https://docs.rs/aes-gcm/latest/aes_gcm/#security-notes: \u00a7\n\u27e814\u27e9 https://research.nccgroup.com/2020/02/26/public-report-rustcrypto-aes-gcm-and-chacha20poly1305-implementation-review/: security audit by NCC Group\n\u27e815\u27e9 https://www.mobilecoin.com/: MobileCoin\n\u27e816\u27e9 https://docs.rs/aes-gcm/latest/aes_gcm/#license: \u00a7\n\u27e817\u27e9 http://www.apache.org/licenses/LICENSE-2.0: Apache License, Version 2.0\n\u27e818\u27e9 http://opensource.org/licenses/MIT: MIT license\n\u27e819\u27e9 https://docs.rs/aes-gcm/latest/aes_gcm/#contribution: \u00a7\n\u27e820\u27e9 https://docs.rs/aes-gcm/latest/aes_gcm/#usage: \u00a7\n\u27e821\u27e9 https://docs.rs/aes-gcm/latest/aes_gcm/#in-place-usage-eliminates-alloc-requirement: \u00a7\n\u27e822\u27e9 https://docs.rs/aes-gcm/latest/aes_gcm/trait.AeadInPlace.html#method.encrypt_in_place: method aes_gcm::AeadInPlace::encrypt_in_place - `AeadInPlace::encrypt_in_place`\n\u27e823\u27e9 https://docs.rs/aes-gcm/latest/aes_gcm/trait.AeadInPlace.html#method.decrypt_in_place: method aes_gcm::AeadInPlace::decrypt_in_place - `AeadInPlace::decrypt_in_place`\n\u27e824\u27e9 https://docs.rs/aead/0.5.2/x86_64-unknown-linux-gnu/aead/trait.Buffer.html: trait aead::Buffer - `aead::Buffer`\n\u27e825\u27e9 https://docs.rs/aead/0.5.2/x86_64-unknown-linux-gnu/aead/index.html: mod aead - `aead`\n\u27e826\u27e9 https://docs.rs/heapless/0.7.17/x86_64-unknown-linux-gnu/heapless/vec/struct.Vec.html: struct heapless::vec::Vec - `aead::heapless::Vec`\n\u27e827\u27e9 https://docs.rs/arrayvec/0.7.6/x86_64-unknown-linux-gnu/arrayvec/arrayvec/struct.ArrayVec.html: struct arrayvec::arrayvec::ArrayVec - `aead::arrayvec::ArrayVec`\n\u27e828\u27e9 https://docs.rs/aes-gcm/latest/aes_gcm/#reexports: \u00a7\n\u27e829\u27e9 https://docs.rs/aes-gcm/latest/aes_gcm/#structs: \u00a7\n\u27e830\u27e9 https://docs.rs/aes-gcm/latest/aes_gcm/struct.AesGcm.html: struct aes_gcm::AesGcm - AesGcm\n\u27e831\u27e9 https://docs.rs/aes-gcm/latest/aes_gcm/struct.Error.html: struct aes_gcm::Error - Error\n\u27e832\u27e9 https://docs.rs/aes-gcm/latest/aes_gcm/#constants: \u00a7\n\u27e833\u27e9 https://docs.rs/aes-gcm/latest/aes_gcm/constant.A_MAX.html: constant aes_gcm::A_MAX - A_MAX\n\u27e834\u27e9 https://docs.rs/aes-gcm/latest/aes_gcm/constant.C_MAX.html: constant aes_gcm::C_MAX - C_MAX\n\u27e835\u27e9 https://docs.rs/aes-gcm/latest/aes_gcm/constant.P_MAX.html: constant aes_gcm::P_MAX - P_MAX\n\u27e836\u27e9 https://docs.rs/aes-gcm/latest/aes_gcm/#traits: \u00a7\n\u27e837\u27e9 https://docs.rs/aes-gcm/latest/aes_gcm/trait.AeadCore.html: trait aes_gcm::AeadCore - AeadCore\n\u27e838\u27e9 https://docs.rs/aes-gcm/latest/aes_gcm/trait.AeadInPlace.html: trait aes_gcm::AeadInPlace - AeadInPlace\n\u27e839\u27e9 https://docs.rs/aes-gcm/latest/aes_gcm/trait.KeyInit.html: trait aes_gcm::KeyInit - KeyInit\n\u27e840\u27e9 https://docs.rs/aes-gcm/latest/aes_gcm/trait.KeySizeUser.html: trait aes_gcm::KeySizeUser - KeySizeUser\n\u27e841\u27e9 https://docs.rs/aes-gcm/latest/aes_gcm/trait.TagSize.html: trait aes_gcm::TagSize - TagSize\n\u27e842\u27e9 https://docs.rs/aes-gcm/latest/aes_gcm/#types: \u00a7\n\u27e843\u27e9 https://docs.rs/aes-gcm/latest/aes_gcm/type.Aes128Gcm.html: type aes_gcm::Aes128Gcm - Aes128Gcm\n\u27e844\u27e9 https://docs.rs/aes-gcm/latest/aes_gcm/type.Aes256Gcm.html: type aes_gcm::Aes256Gcm - Aes256Gcm\n\u27e845\u27e9 https://docs.rs/aes-gcm/latest/aes_gcm/type.Key.html: type aes_gcm::Key - Key\n\u27e846\u27e9 https://docs.rs/aes-gcm/latest/aes_gcm/type.Nonce.html: type aes_gcm::Nonce - Nonce\n\u27e847\u27e9 https://docs.rs/aes-gcm/latest/aes_gcm/type.Tag.html: type aes_gcm::Tag - Tag\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `aes-gcm` crate provides a pure Rust implementation of the AES-GCM cipher for Authenticated Encryption with Associated Data (AEAD). It supports both 128-bit and 256-bit keys, constant-time execution, and features in-place encryption/decryption to eliminate heap allocation, making it suitable for constrained environments. The crate is audited for security, offers optional features like `heapless` and `arrayvec` for buffer management, and is licensed under Apache 2.0 or MIT.",
    "feature_summary": null,
    "use_case": "Cryptography",
    "score": 8.5,
    "factual_counterfactual": "### Pair 1: Security and Audit  \n\u2705 **Factual**: The `aes-gcm` crate has undergone a security audit by NCC Group, which found no significant issues, ensuring its reliability for cryptographic applications.  \n\u274c **Counterfactual**: The `aes-gcm` crate has not been audited for security vulnerabilities, making it unsuitable for production-grade cryptographic use.  \n\n---\n\n### Pair 2: Constant-Time Execution  \n\u2705 **Factual**: The `aes-gcm` crate is designed to execute cryptographic operations in constant time, leveraging hardware intrinsics like AES-NI and CLMUL on x86/x86_64 processors.  \n\u274c **Counterfactual**: The `aes-gcm` crate does not support constant-time execution, relying entirely on variable-time operations, which could lead to side-channel vulnerabilities.  \n\n---\n\n### Pair 3: In-Place Encryption  \n\u2705 **Factual**: The `aes-gcm` crate supports in-place encryption and decryption, eliminating the need for heap allocation when the `alloc` feature is disabled, making it suitable for resource-constrained environments.  \n\u274c **Counterfactual**: The `aes-gcm` crate requires heap allocation for all encryption and decryption operations, making it incompatible with microcontroller environments lacking dynamic memory.  \n\n---",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}