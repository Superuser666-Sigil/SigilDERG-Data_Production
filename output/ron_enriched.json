{
    "name": "ron",
    "version": "0.10.1",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/ron/latest/ron/all.html \"show sidebar\")\n# Crate ronCopy item path\n[Settings](https://docs.rs/ron/latest/settings.html)\n[Help](https://docs.rs/ron/latest/help.html)\nSummary[Source](https://docs.rs/ron/latest/src/ron/lib.rs.html#1-34)\nExpand description\n## [\u00a7](https://docs.rs/ron/latest/ron/#rusty-object-notation)Rusty Object Notation\n[![MSRV](https://img.shields.io/badge/MSRV-1.64.0-orange)](https://github.com/ron-rs/ron) [![Crates.io](https://img.shields.io/crates/v/ron.svg)](https://crates.io/crates/ron) [![Docs](https://docs.rs/ron/badge.svg)](https://docs.rs/ron)\n[![CI](https://github.com/ron-rs/ron/actions/workflows/ci.yaml/badge.svg)](https://github.com/ron-rs/ron/actions/workflows/ci.yaml) [![Coverage](https://img.shields.io/endpoint?url=https%3A%2F%2Fron-rs.github.io%2Fron%2Fcoverage%2Fcoverage.json)](https://ron-rs.github.io/ron/coverage/) [![Fuzzing](https://oss-fuzz-build-logs.storage.googleapis.com/badges/ron.svg)](https://bugs.chromium.org/p/oss-fuzz/issues/list?sort=-opened&can=1&q=proj:ron)\n[![Matrix](https://img.shields.io/matrix/ron-rs:matrix.org.svg)](https://matrix.to/#/#ron-rs:matrix.org)\nRON is a simple readable data serialization format that looks similar to Rust syntax. It\u2019s designed to support all of [Serde\u2019s data model](https://serde.rs/data-model.html), so structs, enums, tuples, arrays, generic maps, and primitive values.\n### [\u00a7](https://docs.rs/ron/latest/ron/#example)Example\n```\nGameConfig( // optional struct name\n  window_size: (800, 600),\n  window_title: \"PAC-MAN\",\n  fullscreen: false,\n  mouse_sensitivity: 1.4,\n  key_bindings: {\n    \"up\": Up,\n    \"down\": Down,\n    \"left\": Left,\n    \"right\": Right,\n    // Uncomment to enable WASD controls\n    /*\n    \"W\": Up,\n    \"S\": Down,\n    \"A\": Left,\n    \"D\": Right,\n    */\n  },\n  difficulty_options: (\n    start_difficulty: Easy,\n    adaptive: false,\n  ),\n)\n```\n\n### [\u00a7](https://docs.rs/ron/latest/ron/#ron-syntax-overview)RON syntax overview\n  * Numbers: `42`, `3.14`, `0xFF`, `0b0110`\n  * Strings: `\"Hello\"`, `\"with\\\\escapes\\n\"`, `r#\"raw string, great for regex\\.\"#`\n  * Byte Strings: `b\"Hello\"`, `b\"with \\x65\\x73\\x63\\x61\\x70\\x65\\x73\\n\"`, `br#\"raw, too\"#`\n  * Booleans: `true`, `false`\n  * Chars: `'e'`, `'\\n'`\n  * Optionals: `Some(\"string\")`, `Some(Some(1.34))`, `None`\n  * Tuples: `(\"abc\", 1.23, true)`, `()`\n  * Lists: `[\"abc\", \"def\"]`\n  * Structs: `( foo: 1.0, bar: ( baz: \"I'm nested\" ) )`\n  * Maps: `{ \"arbitrary\": \"keys\", \"are\": \"allowed\" }`\n\n\n> **Note:** Serde\u2019s data model represents fixed-size Rust arrays as tuple (instead of as list)\nRON also supports several extensions, which are documented [here](https://docs.rs/ron/latest/ron/docs/extensions.md).\n### [\u00a7](https://docs.rs/ron/latest/ron/#specification)Specification\nRON\u2019s formal and complete grammar is available [here](https://docs.rs/ron/latest/ron/docs/grammar.md).\nThere also is a very basic, work in progress specification available on [the wiki page](https://github.com/ron-rs/ron/wiki/Specification).\n### [\u00a7](https://docs.rs/ron/latest/ron/#why-ron)Why RON?\n#### [\u00a7](https://docs.rs/ron/latest/ron/#example-in-json)Example in JSON\n```\n{\n  \"materials\": {\n    \"metal\": {\n      \"reflectivity\": 1.0\n    },\n    \"plastic\": {\n      \"reflectivity\": 0.5\n    }\n  },\n  \"entities\": [\n    {\n      \"name\": \"hero\",\n      \"material\": \"metal\"\n    },\n    {\n      \"name\": \"monster\",\n      \"material\": \"plastic\"\n    }\n  ]\n}\n```\n\n#### [\u00a7](https://docs.rs/ron/latest/ron/#same-example-in-ron)Same example in RON\n```\nScene( // class name is optional\n  materials: { // this is a map\n    \"metal\": (\n      reflectivity: 1.0,\n    ),\n    \"plastic\": (\n      reflectivity: 0.5,\n    ),\n  },\n  entities: [ // this is an array\n    (\n      name: \"hero\",\n      material: \"metal\",\n    ),\n    (\n      name: \"monster\",\n      material: \"plastic\",\n    ),\n  ],\n)\n```\n\nNote the following advantages of RON over JSON:\n  * trailing commas allowed\n  * single- and multi-line comments\n  * field names aren\u2019t quoted, so it\u2019s less verbose\n  * optional struct names improve readability\n  * enums are supported (and less verbose than their JSON representation)\n\n\n### [\u00a7](https://docs.rs/ron/latest/ron/#quickstart)Quickstart\n#### [\u00a7](https://docs.rs/ron/latest/ron/#cargotoml)`Cargo.toml`\n```\n[dependencies]\nron = \"0.8\"\nserde = { version = \"1\", features = [\"derive\"] }\n```\n\n#### [\u00a7](https://docs.rs/ron/latest/ron/#mainrs)`main.rs`\n```\nuse serde::{Deserialize, Serialize};\n#[derive(Debug, Deserialize, Serialize)]\nstruct MyStruct {\n  boolean: bool,\n  float: f32,\n}\nfn main() {\n  let x: MyStruct = ron::from_str(\"(boolean: true, float: 1.23)\").unwrap();\n  println!(\"RON: {}\", ron::to_string(&x).unwrap());\n  println!(\"Pretty RON: {}\", ron::ser::to_string_pretty(\n    &x, ron::ser::PrettyConfig::default()).unwrap(),\n  );\n}\n```\n\n### [\u00a7](https://docs.rs/ron/latest/ron/#tooling)Tooling\nEditor| Plugin  \n---|---  \nIntelliJ| [intellij-ron](https://github.com/ron-rs/intellij-ron)  \nVS Code| [a5huynh/vscode-ron](https://github.com/a5huynh/vscode-ron)  \nSublime Text| [RON](https://packagecontrol.io/packages/RON)  \nAtom| [language-ron](https://atom.io/packages/language-ron)  \nVim| [ron-rs/ron.vim](https://github.com/ron-rs/ron.vim)  \nEMACS| [emacs-ron](https://chiselapp.com/user/Hutzdog/repository/ron-mode/home)  \n### [\u00a7](https://docs.rs/ron/latest/ron/#limitations)Limitations\nRON requires struct, enum, and variant names to be valid Rust identifiers and will reject invalid ones created by `#[serde(rename = \"...\")]` at serialization / deserialization time.\nRON is not designed to be a fully self-describing format (unlike JSON) and is thus not guaranteed to work when [`deserialize_any`](https://docs.rs/serde/latest/serde/trait.Deserializer.html#tymethod.deserialize_any) is used instead of its typed alternatives. In particular, the following Serde attributes only have limited support:\n  * `#[serde(tag = \"tag\")]`, i.e. internally tagged enums [1](https://docs.rs/ron/latest/ron/#fn1)\n  * `#[serde(tag = \"tag\", content = \"content\")]`, i.e. adjacently tagged enums [1](https://docs.rs/ron/latest/ron/#fn1)\n  * `#[serde(untagged)]`, i.e. untagged enums [1](https://docs.rs/ron/latest/ron/#fn1)\n  * `#[serde(flatten)]`, i.e. flattening of structs into maps [2](https://docs.rs/ron/latest/ron/#fn2)\n\n\nWhile data structures with any of these attributes should generally roundtrip through RON, some restrictions apply [3](https://docs.rs/ron/latest/ron/#fn3) and their textual representation may not always match your expectation:\n  * ron only supports string keys inside maps flattened into structs\n  * internally (or adjacently) tagged or untagged enum variants or `#[serde(flatten)]`ed fields must not contain: \n    * struct names, e.g. by enabling the `#[enable(explicit_struct_names)]` extension or the `PrettyConfig::struct_names` setting\n    * newtypes\n    * zero-length arrays / tuples / tuple structs / structs / tuple variants / struct variants \n      * `Option`s with `#[enable(implicit_some)]` must not contain any of these or a unit, unit struct, or an untagged unit variant\n    * externally tagged tuple variants with just one field (that are not newtype variants)\n    * tuples or arrays or tuple structs with just one element are not supported inside newtype variants with `#[enable(unwrap_variant_newtypes)]` (including `Some`)\n    * a `ron::value::RawValue`\n  * untagged tuple / struct variants with no fields are not supported\n  * untagged tuple variants with just one field (that are not newtype variants) are not supported when the `#![enable(unwrap_variant_newtypes)]` extension is enabled\n  * serializing a `ron::value::RawValue` using a `PrettyConfig` may add leading and trailing whitespace and comments, which the `ron::value::RawValue` absorbs upon deserialization\n\n\nFurthermore, serde imposes the following restrictions for data to roundtrip:\n  * structs or struct variants that contain a `#[serde(flatten)]`ed field: \n    * are only serialised as maps and deserialised from maps\n    * must not contain duplicate fields / keys, e.g. where an inner-struct field matches an outer-struct or inner-struct field\n    * must not contain more than one (within the super-struct of all flattened structs) `#[serde(flatten)]`ed map field, which collects all unknown fields\n    * if they contain a `#[serde(flatten)]`ed map, they must not contain: \n      * a struct that is not flattened itself but contains some flattened fields and is flattened into the outer struct (variant)\n      * an untagged struct variant that contains some flattened fields\n      * a flattened externally tagged newtype, tuple, or struct variant, flattened internally tagged unit, newtype, or struct variant, or any flattened adjacently tagged variant\n      * a flattened tagged struct\n  * internally (or adjacently) tagged or untagged enum variants or `#[serde(flatten)]`ed fields must not contain: \n    * `i128` or `u128` values\n  * internally tagged newtype variants and `#[serde(flatten)]`ed fields must not contain: \n    * a unit or a unit struct inside an untagged newtype variant\n    * an untagged unit variant\n  * internally tagged newtype variants, which are `#[serde(flatten)]`ed together with other fields, must not contain: \n    * a unit or unit struct or an untagged unit variant\n\n\nWhile RON offers a best-effort implementation for `#[serde(flatten)]`, it may be unsupported in further cases and combinations not listed above. These limitations stem primarily from serde rather than RON. Enumerating all such cases based on serde\u2019s behavior is nontrivial, so the lists above are not exhaustive.\nPlease file a [new issue](https://github.com/ron-rs/ron/issues/new) if you come across a use case which is not listed among the above restrictions but still breaks.\nWhile RON guarantees roundtrips like Rust -> RON -> Rust for Rust types using non-`deserialize_any`-based implementations, RON does not yet make any guarantees about roundtrips through `ron::Value`. For instance, even when RON -> Rust works, RON -> `ron::Value` -> Rust, or RON -> `ron::Value` -> RON -> Rust may not work. We plan on improving `ron::Value` in an upcoming version of RON, though this work is partially blocked on [serde#1183](https://github.com/serde-rs/serde/issues/1183).\n### [\u00a7](https://docs.rs/ron/latest/ron/#license)License\nRON is dual-licensed under Apache-2.0 and MIT.\nAny contribution intentionally submitted for inclusion in the work must be provided under the same dual-license terms.\n  1. Deserialising an internally, adjacently, or un-tagged enum requires detecting `serde`\u2019s internal `serde::__private::de::content::Content` content type so that RON can describe the deserialised data structure in serde\u2019s internal JSON-like format. This detection only works for the automatically-derived [`Deserialize`](https://docs.rs/serde/latest/serde/de/trait.Deserialize.html) impls on enums. See [#451](https://github.com/ron-rs/ron/pull/451) for more details. [\u21a9](https://docs.rs/ron/latest/ron/#fnref1)\n  2. Deserialising a flattened struct from a map requires that the struct\u2019s [`Visitor::expecting`](https://docs.rs/serde/latest/serde/de/trait.Visitor.html#tymethod.expecting) implementation formats a string starting with `\"struct \"`. This is the case for automatically-derived [`Deserialize`](https://docs.rs/serde/latest/serde/de/trait.Deserialize.html) impls on structs. See [#455](https://github.com/ron-rs/ron/pull/455) for more details. [\u21a9](https://docs.rs/ron/latest/ron/#fnref2)\n  3. Most of these restrictions are currently blocked on [serde#1183](https://github.com/serde-rs/serde/issues/1183), which limits non-self-describing formats from roundtripping format-specific information through internally (or adjacently) tagged or untagged enums or `#[serde(flatten)]`ed fields. [\u21a9](https://docs.rs/ron/latest/ron/#fnref3)\n\n\n## Re-exports[\u00a7](https://docs.rs/ron/latest/ron/#reexports)\n\n`pub use de::from_str[](https://docs.rs/ron/latest/ron/de/fn.from_str.html \"fn ron::de::from_str\");`\n\n\n`pub use de::Deserializer[](https://docs.rs/ron/latest/ron/de/struct.Deserializer.html \"struct ron::de::Deserializer\");`\n\n\n`pub use error::Error[](https://docs.rs/ron/latest/ron/error/enum.Error.html \"enum ron::error::Error\");`\n\n\n`pub use error::Result[](https://docs.rs/ron/latest/ron/error/type.Result.html \"type ron::error::Result\");`\n\n\n`pub use options::Options[](https://docs.rs/ron/latest/ron/options/struct.Options.html \"struct ron::options::Options\");`\n\n\n`pub use ser::to_string[](https://docs.rs/ron/latest/ron/ser/fn.to_string.html \"fn ron::ser::to_string\");`\n\n\n`pub use ser::Serializer[](https://docs.rs/ron/latest/ron/ser/struct.Serializer.html \"struct ron::ser::Serializer\");`\n\n\n`pub use value::Map[](https://docs.rs/ron/latest/ron/value/struct.Map.html \"struct ron::value::Map\");`\n\n\n`pub use value::Number[](https://docs.rs/ron/latest/ron/value/enum.Number.html \"enum ron::value::Number\");`\n\n\n`pub use value::Value[](https://docs.rs/ron/latest/ron/value/enum.Value.html \"enum ron::value::Value\");`\n\n## Modules[\u00a7](https://docs.rs/ron/latest/ron/#modules)\n\n[de](https://docs.rs/ron/latest/ron/de/index.html \"mod ron::de\")\n\n\n[error](https://docs.rs/ron/latest/ron/error/index.html \"mod ron::error\")\n\n\n[extensions](https://docs.rs/ron/latest/ron/extensions/index.html \"mod ron::extensions\")\n\n\n[options](https://docs.rs/ron/latest/ron/options/index.html \"mod ron::options\")\n    Roundtrip serde Options module.\n\n[ser](https://docs.rs/ron/latest/ron/ser/index.html \"mod ron::ser\")\n\n\n[value](https://docs.rs/ron/latest/ron/value/index.html \"mod ron::value\")\n    Value module.\n",
        "markdown_with_citations": "[](https://docs.rs/ron/latest/ron/all.html \"show sidebar\")\n# Crate ronCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\n## \u00a7\u27e84\u27e9Rusty Object Notation\n![MSRV\u27e85\u27e9](https://github.com/ron-rs/ron) ![Crates.io\u27e86\u27e9](https://crates.io/crates/ron) ![Docs\u27e87\u27e9](https://docs.rs/ron)\n![CI\u27e88\u27e9](https://github.com/ron-rs/ron/actions/workflows/ci.yaml) ![Coverage\u27e89\u27e9](https://ron-rs.github.io/ron/coverage/) ![Fuzzing\u27e810\u27e9](https://bugs.chromium.org/p/oss-fuzz/issues/list?sort=-opened&can=1&q=proj:ron)\n![Matrix\u27e811\u27e9](https://matrix.to/#/#ron-rs:matrix.org)\nRON is a simple readable data serialization format that looks similar to Rust syntax. It\u2019s designed to support all of Serde\u2019s data model\u27e812\u27e9, so structs, enums, tuples, arrays, generic maps, and primitive values.\n### \u00a7\u27e813\u27e9Example\n```\nGameConfig( // optional struct name\n  window_size: (800, 600),\n  window_title: \"PAC-MAN\",\n  fullscreen: false,\n  mouse_sensitivity: 1.4,\n  key_bindings: {\n    \"up\": Up,\n    \"down\": Down,\n    \"left\": Left,\n    \"right\": Right,\n    // Uncomment to enable WASD controls\n    /*\n    \"W\": Up,\n    \"S\": Down,\n    \"A\": Left,\n    \"D\": Right,\n    */\n  },\n  difficulty_options: (\n    start_difficulty: Easy,\n    adaptive: false,\n  ),\n)\n```\n\n### \u00a7\u27e814\u27e9RON syntax overview\n  * Numbers: `42`, `3.14`, `0xFF`, `0b0110`\n  * Strings: `\"Hello\"`, `\"with\\\\escapes\\n\"`, `r#\"raw string, great for regex\\.\"#`\n  * Byte Strings: `b\"Hello\"`, `b\"with \\x65\\x73\\x63\\x61\\x70\\x65\\x73\\n\"`, `br#\"raw, too\"#`\n  * Booleans: `true`, `false`\n  * Chars: `'e'`, `'\\n'`\n  * Optionals: `Some(\"string\")`, `Some(Some(1.34))`, `None`\n  * Tuples: `(\"abc\", 1.23, true)`, `()`\n  * Lists: `[\"abc\", \"def\"]`\n  * Structs: `( foo: 1.0, bar: ( baz: \"I'm nested\" ) )`\n  * Maps: `{ \"arbitrary\": \"keys\", \"are\": \"allowed\" }`\n\n\n> **Note:** Serde\u2019s data model represents fixed-size Rust arrays as tuple (instead of as list)\nRON also supports several extensions, which are documented here\u27e815\u27e9.\n### \u00a7\u27e816\u27e9Specification\nRON\u2019s formal and complete grammar is available here\u27e817\u27e9.\nThere also is a very basic, work in progress specification available on the wiki page\u27e818\u27e9.\n### \u00a7\u27e819\u27e9Why RON?\n#### \u00a7\u27e820\u27e9Example in JSON\n```\n{\n  \"materials\": {\n    \"metal\": {\n      \"reflectivity\": 1.0\n    },\n    \"plastic\": {\n      \"reflectivity\": 0.5\n    }\n  },\n  \"entities\": [\n    {\n      \"name\": \"hero\",\n      \"material\": \"metal\"\n    },\n    {\n      \"name\": \"monster\",\n      \"material\": \"plastic\"\n    }\n  ]\n}\n```\n\n#### \u00a7\u27e821\u27e9Same example in RON\n```\nScene( // class name is optional\n  materials: { // this is a map\n    \"metal\": (\n      reflectivity: 1.0,\n    ),\n    \"plastic\": (\n      reflectivity: 0.5,\n    ),\n  },\n  entities: [ // this is an array\n    (\n      name: \"hero\",\n      material: \"metal\",\n    ),\n    (\n      name: \"monster\",\n      material: \"plastic\",\n    ),\n  ],\n)\n```\n\nNote the following advantages of RON over JSON:\n  * trailing commas allowed\n  * single- and multi-line comments\n  * field names aren\u2019t quoted, so it\u2019s less verbose\n  * optional struct names improve readability\n  * enums are supported (and less verbose than their JSON representation)\n\n\n### \u00a7\u27e822\u27e9Quickstart\n#### \u00a7\u27e823\u27e9`Cargo.toml`\n```\n[dependencies]\nron = \"0.8\"\nserde = { version = \"1\", features = [\"derive\"] }\n```\n\n#### \u00a7\u27e824\u27e9`main.rs`\n```\nuse serde::{Deserialize, Serialize};\n#[derive(Debug, Deserialize, Serialize)]\nstruct MyStruct {\n  boolean: bool,\n  float: f32,\n}\nfn main() {\n  let x: MyStruct = ron::from_str(\"(boolean: true, float: 1.23)\").unwrap();\n  println!(\"RON: {}\", ron::to_string(&x).unwrap());\n  println!(\"Pretty RON: {}\", ron::ser::to_string_pretty(\n    &x, ron::ser::PrettyConfig::default()).unwrap(),\n  );\n}\n```\n\n### \u00a7\u27e825\u27e9Tooling\nEditor| Plugin  \n---|---  \nIntelliJ| intellij-ron\u27e826\u27e9  \nVS Code| a5huynh/vscode-ron\u27e827\u27e9  \nSublime Text| RON\u27e828\u27e9  \nAtom| language-ron\u27e829\u27e9  \nVim| ron-rs/ron.vim\u27e830\u27e9  \nEMACS| emacs-ron\u27e831\u27e9  \n### \u00a7\u27e832\u27e9Limitations\nRON requires struct, enum, and variant names to be valid Rust identifiers and will reject invalid ones created by `#[serde(rename = \"...\")]` at serialization / deserialization time.\nRON is not designed to be a fully self-describing format (unlike JSON) and is thus not guaranteed to work when `deserialize_any`\u27e833\u27e9 is used instead of its typed alternatives. In particular, the following Serde attributes only have limited support:\n  * `#[serde(tag = \"tag\")]`, i.e. internally tagged enums 1\u27e834\u27e9\n  * `#[serde(tag = \"tag\", content = \"content\")]`, i.e. adjacently tagged enums 1\u27e834\u27e9\n  * `#[serde(untagged)]`, i.e. untagged enums 1\u27e834\u27e9\n  * `#[serde(flatten)]`, i.e. flattening of structs into maps 2\u27e835\u27e9\n\n\nWhile data structures with any of these attributes should generally roundtrip through RON, some restrictions apply 3\u27e836\u27e9 and their textual representation may not always match your expectation:\n  * ron only supports string keys inside maps flattened into structs\n  * internally (or adjacently) tagged or untagged enum variants or `#[serde(flatten)]`ed fields must not contain: \n    * struct names, e.g. by enabling the `#[enable(explicit_struct_names)]` extension or the `PrettyConfig::struct_names` setting\n    * newtypes\n    * zero-length arrays / tuples / tuple structs / structs / tuple variants / struct variants \n      * `Option`s with `#[enable(implicit_some)]` must not contain any of these or a unit, unit struct, or an untagged unit variant\n    * externally tagged tuple variants with just one field (that are not newtype variants)\n    * tuples or arrays or tuple structs with just one element are not supported inside newtype variants with `#[enable(unwrap_variant_newtypes)]` (including `Some`)\n    * a `ron::value::RawValue`\n  * untagged tuple / struct variants with no fields are not supported\n  * untagged tuple variants with just one field (that are not newtype variants) are not supported when the `#![enable(unwrap_variant_newtypes)]` extension is enabled\n  * serializing a `ron::value::RawValue` using a `PrettyConfig` may add leading and trailing whitespace and comments, which the `ron::value::RawValue` absorbs upon deserialization\n\n\nFurthermore, serde imposes the following restrictions for data to roundtrip:\n  * structs or struct variants that contain a `#[serde(flatten)]`ed field: \n    * are only serialised as maps and deserialised from maps\n    * must not contain duplicate fields / keys, e.g. where an inner-struct field matches an outer-struct or inner-struct field\n    * must not contain more than one (within the super-struct of all flattened structs) `#[serde(flatten)]`ed map field, which collects all unknown fields\n    * if they contain a `#[serde(flatten)]`ed map, they must not contain: \n      * a struct that is not flattened itself but contains some flattened fields and is flattened into the outer struct (variant)\n      * an untagged struct variant that contains some flattened fields\n      * a flattened externally tagged newtype, tuple, or struct variant, flattened internally tagged unit, newtype, or struct variant, or any flattened adjacently tagged variant\n      * a flattened tagged struct\n  * internally (or adjacently) tagged or untagged enum variants or `#[serde(flatten)]`ed fields must not contain: \n    * `i128` or `u128` values\n  * internally tagged newtype variants and `#[serde(flatten)]`ed fields must not contain: \n    * a unit or a unit struct inside an untagged newtype variant\n    * an untagged unit variant\n  * internally tagged newtype variants, which are `#[serde(flatten)]`ed together with other fields, must not contain: \n    * a unit or unit struct or an untagged unit variant\n\n\nWhile RON offers a best-effort implementation for `#[serde(flatten)]`, it may be unsupported in further cases and combinations not listed above. These limitations stem primarily from serde rather than RON. Enumerating all such cases based on serde\u2019s behavior is nontrivial, so the lists above are not exhaustive.\nPlease file a new issue\u27e837\u27e9 if you come across a use case which is not listed among the above restrictions but still breaks.\nWhile RON guarantees roundtrips like Rust -> RON -> Rust for Rust types using non-`deserialize_any`-based implementations, RON does not yet make any guarantees about roundtrips through `ron::Value`. For instance, even when RON -> Rust works, RON -> `ron::Value` -> Rust, or RON -> `ron::Value` -> RON -> Rust may not work. We plan on improving `ron::Value` in an upcoming version of RON, though this work is partially blocked on serde#1183\u27e838\u27e9.\n### \u00a7\u27e839\u27e9License\nRON is dual-licensed under Apache-2.0 and MIT.\nAny contribution intentionally submitted for inclusion in the work must be provided under the same dual-license terms.\n  1. Deserialising an internally, adjacently, or un-tagged enum requires detecting `serde`\u2019s internal `serde::__private::de::content::Content` content type so that RON can describe the deserialised data structure in serde\u2019s internal JSON-like format. This detection only works for the automatically-derived `Deserialize`\u27e840\u27e9 impls on enums. See #451\u27e841\u27e9 for more details. \u21a9\u27e842\u27e9\n  2. Deserialising a flattened struct from a map requires that the struct\u2019s `Visitor::expecting`\u27e843\u27e9 implementation formats a string starting with `\"struct \"`. This is the case for automatically-derived `Deserialize`\u27e840\u27e9 impls on structs. See #455\u27e844\u27e9 for more details. \u21a9\u27e845\u27e9\n  3. Most of these restrictions are currently blocked on serde#1183\u27e838\u27e9, which limits non-self-describing formats from roundtripping format-specific information through internally (or adjacently) tagged or untagged enums or `#[serde(flatten)]`ed fields. \u21a9\u27e846\u27e9\n\n\n## Re-exports\u00a7\u27e847\u27e9\n\n`pub use de::from_str[](https://docs.rs/ron/latest/ron/de/fn.from_str.html \"fn ron::de::from_str\");`\n\n\n`pub use de::Deserializer[](https://docs.rs/ron/latest/ron/de/struct.Deserializer.html \"struct ron::de::Deserializer\");`\n\n\n`pub use error::Error[](https://docs.rs/ron/latest/ron/error/enum.Error.html \"enum ron::error::Error\");`\n\n\n`pub use error::Result[](https://docs.rs/ron/latest/ron/error/type.Result.html \"type ron::error::Result\");`\n\n\n`pub use options::Options[](https://docs.rs/ron/latest/ron/options/struct.Options.html \"struct ron::options::Options\");`\n\n\n`pub use ser::to_string[](https://docs.rs/ron/latest/ron/ser/fn.to_string.html \"fn ron::ser::to_string\");`\n\n\n`pub use ser::Serializer[](https://docs.rs/ron/latest/ron/ser/struct.Serializer.html \"struct ron::ser::Serializer\");`\n\n\n`pub use value::Map[](https://docs.rs/ron/latest/ron/value/struct.Map.html \"struct ron::value::Map\");`\n\n\n`pub use value::Number[](https://docs.rs/ron/latest/ron/value/enum.Number.html \"enum ron::value::Number\");`\n\n\n`pub use value::Value[](https://docs.rs/ron/latest/ron/value/enum.Value.html \"enum ron::value::Value\");`\n\n## Modules\u00a7\u27e848\u27e9\n\nde\u27e849\u27e9\n\n\nerror\u27e850\u27e9\n\n\nextensions\u27e851\u27e9\n\n\noptions\u27e852\u27e9\n    Roundtrip serde Options module.\n\nser\u27e853\u27e9\n\n\nvalue\u27e854\u27e9\n    Value module.\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/ron/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/ron/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/ron/latest/src/ron/lib.rs.html#1-34: Source\n\u27e84\u27e9 https://docs.rs/ron/latest/ron/#rusty-object-notation: \u00a7\n\u27e85\u27e9 https://img.shields.io/badge/MSRV-1.64.0-orange: ![MSRV\n\u27e86\u27e9 https://img.shields.io/crates/v/ron.svg: ![Crates.io\n\u27e87\u27e9 https://docs.rs/ron/badge.svg: ![Docs\n\u27e88\u27e9 https://github.com/ron-rs/ron/actions/workflows/ci.yaml/badge.svg: ![CI\n\u27e89\u27e9 https://img.shields.io/endpoint?url=https%3A%2F%2Fron-rs.github.io%2Fron%2Fcoverage%2Fcoverage.json: ![Coverage\n\u27e810\u27e9 https://oss-fuzz-build-logs.storage.googleapis.com/badges/ron.svg: ![Fuzzing\n\u27e811\u27e9 https://img.shields.io/matrix/ron-rs:matrix.org.svg: ![Matrix\n\u27e812\u27e9 https://serde.rs/data-model.html: Serde\u2019s data model\n\u27e813\u27e9 https://docs.rs/ron/latest/ron/#example: \u00a7\n\u27e814\u27e9 https://docs.rs/ron/latest/ron/#ron-syntax-overview: \u00a7\n\u27e815\u27e9 https://docs.rs/ron/latest/ron/docs/extensions.md: here\n\u27e816\u27e9 https://docs.rs/ron/latest/ron/#specification: \u00a7\n\u27e817\u27e9 https://docs.rs/ron/latest/ron/docs/grammar.md: here\n\u27e818\u27e9 https://github.com/ron-rs/ron/wiki/Specification: the wiki page\n\u27e819\u27e9 https://docs.rs/ron/latest/ron/#why-ron: \u00a7\n\u27e820\u27e9 https://docs.rs/ron/latest/ron/#example-in-json: \u00a7\n\u27e821\u27e9 https://docs.rs/ron/latest/ron/#same-example-in-ron: \u00a7\n\u27e822\u27e9 https://docs.rs/ron/latest/ron/#quickstart: \u00a7\n\u27e823\u27e9 https://docs.rs/ron/latest/ron/#cargotoml: \u00a7\n\u27e824\u27e9 https://docs.rs/ron/latest/ron/#mainrs: \u00a7\n\u27e825\u27e9 https://docs.rs/ron/latest/ron/#tooling: \u00a7\n\u27e826\u27e9 https://github.com/ron-rs/intellij-ron: intellij-ron\n\u27e827\u27e9 https://github.com/a5huynh/vscode-ron: a5huynh/vscode-ron\n\u27e828\u27e9 https://packagecontrol.io/packages/RON: RON\n\u27e829\u27e9 https://atom.io/packages/language-ron: language-ron\n\u27e830\u27e9 https://github.com/ron-rs/ron.vim: ron-rs/ron.vim\n\u27e831\u27e9 https://chiselapp.com/user/Hutzdog/repository/ron-mode/home: emacs-ron\n\u27e832\u27e9 https://docs.rs/ron/latest/ron/#limitations: \u00a7\n\u27e833\u27e9 https://docs.rs/serde/latest/serde/trait.Deserializer.html#tymethod.deserialize_any: `deserialize_any`\n\u27e834\u27e9 https://docs.rs/ron/latest/ron/#fn1: 1\n\u27e835\u27e9 https://docs.rs/ron/latest/ron/#fn2: 2\n\u27e836\u27e9 https://docs.rs/ron/latest/ron/#fn3: 3\n\u27e837\u27e9 https://github.com/ron-rs/ron/issues/new: new issue\n\u27e838\u27e9 https://github.com/serde-rs/serde/issues/1183: serde#1183\n\u27e839\u27e9 https://docs.rs/ron/latest/ron/#license: \u00a7\n\u27e840\u27e9 https://docs.rs/serde/latest/serde/de/trait.Deserialize.html: `Deserialize`\n\u27e841\u27e9 https://github.com/ron-rs/ron/pull/451: #451\n\u27e842\u27e9 https://docs.rs/ron/latest/ron/#fnref1: \u21a9\n\u27e843\u27e9 https://docs.rs/serde/latest/serde/de/trait.Visitor.html#tymethod.expecting: `Visitor::expecting`\n\u27e844\u27e9 https://github.com/ron-rs/ron/pull/455: #455\n\u27e845\u27e9 https://docs.rs/ron/latest/ron/#fnref2: \u21a9\n\u27e846\u27e9 https://docs.rs/ron/latest/ron/#fnref3: \u21a9\n\u27e847\u27e9 https://docs.rs/ron/latest/ron/#reexports: \u00a7\n\u27e848\u27e9 https://docs.rs/ron/latest/ron/#modules: \u00a7\n\u27e849\u27e9 https://docs.rs/ron/latest/ron/de/index.html: mod ron::de - de\n\u27e850\u27e9 https://docs.rs/ron/latest/ron/error/index.html: mod ron::error - error\n\u27e851\u27e9 https://docs.rs/ron/latest/ron/extensions/index.html: mod ron::extensions - extensions\n\u27e852\u27e9 https://docs.rs/ron/latest/ron/options/index.html: mod ron::options - options\n\u27e853\u27e9 https://docs.rs/ron/latest/ron/ser/index.html: mod ron::ser - ser\n\u27e854\u27e9 https://docs.rs/ron/latest/ron/value/index.html: mod ron::value - value\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `ron` crate provides a human-readable data serialization format called Rusty Object Notation (RON), designed to resemble Rust syntax and fully support Serde's data model, including structs, enums, tuples, arrays, maps, and primitives. It offers advantages over JSON, such as trailing commas, comments, unquoted field names, optional struct names, and native enum support. The crate includes tooling for serialization/deserialization, pretty formatting, and editor plugins for better integration.",
    "feature_summary": null,
    "use_case": "Serialization",
    "score": 8.5,
    "factual_counterfactual": "### Pair 1: Serialization Format\n\u2705 Factual: RON is a human-readable data serialization format designed to resemble Rust syntax, supporting structs, enums, tuples, arrays, maps, and primitive values through Serde's data model.  \n\u274c Counterfactual: RON is a binary serialization format optimized for compactness and performance, similar to MessagePack or BSON.  \n\n---\n\n### Pair 2: Compatibility with Serde\n\u2705 Factual: RON integrates seamlessly with Serde, allowing serialization and deserialization of complex Rust data structures, including nested structs and enums.  \n\u274c Counterfactual: RON requires manual implementation of serialization and deserialization traits for all custom data types, as it does not support Serde.  \n\n---\n\n### Pair 3: Syntax Features\n\u2705 Factual: RON supports trailing commas, single- and multi-line comments, and unquoted field names, making it more concise and readable compared to JSON.  \n\u274c Counterfactual: RON does not allow comments or trailing commas in its syntax, making it strictly equivalent to JSON in terms of formatting rules.",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}