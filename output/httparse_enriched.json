{
    "name": "httparse",
    "version": "1.10.1",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/httparse/latest/httparse/all.html \"show sidebar\")\n# Crate httparseCopy item path\n[Settings](https://docs.rs/httparse/latest/settings.html)\n[Help](https://docs.rs/httparse/latest/help.html)\nSummary[Source](https://docs.rs/httparse/latest/src/httparse/lib.rs.html#1-2798)\nExpand description\n## [\u00a7](https://docs.rs/httparse/latest/httparse/#httparse)httparse\nA push library for parsing HTTP/1.x requests and responses.\nThe focus is on speed and safety. Unsafe code is used to keep parsing fast, but unsafety is contained in a submodule, with invariants enforced. The parsing internals use an `Iterator` instead of direct indexing, while skipping bounds checks.\nWith Rust 1.27.0 or later, support for SIMD is enabled automatically. If building an executable to be run on multiple platforms, and thus not passing `target_feature` or `target_cpu` flags to the compiler, runtime detection can still detect SSE4.2 or AVX2 support to provide massive wins.\nIf compiling for a specific target, remembering to include `-C target_cpu=native` allows the detection to become compile time checks, making it _even_ faster.\n## Structs[\u00a7](https://docs.rs/httparse/latest/httparse/#structs)\n\n[Header](https://docs.rs/httparse/latest/httparse/struct.Header.html \"struct httparse::Header\")\n    Represents a parsed header.\n\n[InvalidChunkSize](https://docs.rs/httparse/latest/httparse/struct.InvalidChunkSize.html \"struct httparse::InvalidChunkSize\")\n    An error in parsing a chunk size.\n\n[ParserConfig](https://docs.rs/httparse/latest/httparse/struct.ParserConfig.html \"struct httparse::ParserConfig\")\n    Parser configuration.\n\n[Request](https://docs.rs/httparse/latest/httparse/struct.Request.html \"struct httparse::Request\")\n    A parsed Request.\n\n[Response](https://docs.rs/httparse/latest/httparse/struct.Response.html \"struct httparse::Response\")\n    A parsed Response.\n## Enums[\u00a7](https://docs.rs/httparse/latest/httparse/#enums)\n\n[Error](https://docs.rs/httparse/latest/httparse/enum.Error.html \"enum httparse::Error\")\n    An error in parsing.\n\n[Status](https://docs.rs/httparse/latest/httparse/enum.Status.html \"enum httparse::Status\")\n    The result of a successful parse pass.\n## Constants[\u00a7](https://docs.rs/httparse/latest/httparse/#constants)\n\n[EMPTY_HEADER](https://docs.rs/httparse/latest/httparse/constant.EMPTY_HEADER.html \"constant httparse::EMPTY_HEADER\")\n    An empty header, useful for constructing a `Header` array to pass in for parsing.\n## Functions[\u00a7](https://docs.rs/httparse/latest/httparse/#functions)\n\n[parse_chunk_size](https://docs.rs/httparse/latest/httparse/fn.parse_chunk_size.html \"fn httparse::parse_chunk_size\")\n    Parse a buffer of bytes as a chunk size.\n\n[parse_headers](https://docs.rs/httparse/latest/httparse/fn.parse_headers.html \"fn httparse::parse_headers\")\n    Parse a buffer of bytes as headers.\n## Type Aliases[\u00a7](https://docs.rs/httparse/latest/httparse/#types)\n\n[Result](https://docs.rs/httparse/latest/httparse/type.Result.html \"type httparse::Result\")\n    A Result of any parsing action.\n",
        "markdown_with_citations": "[](https://docs.rs/httparse/latest/httparse/all.html \"show sidebar\")\n# Crate httparseCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\n## \u00a7\u27e84\u27e9httparse\nA push library for parsing HTTP/1.x requests and responses.\nThe focus is on speed and safety. Unsafe code is used to keep parsing fast, but unsafety is contained in a submodule, with invariants enforced. The parsing internals use an `Iterator` instead of direct indexing, while skipping bounds checks.\nWith Rust 1.27.0 or later, support for SIMD is enabled automatically. If building an executable to be run on multiple platforms, and thus not passing `target_feature` or `target_cpu` flags to the compiler, runtime detection can still detect SSE4.2 or AVX2 support to provide massive wins.\nIf compiling for a specific target, remembering to include `-C target_cpu=native` allows the detection to become compile time checks, making it _even_ faster.\n## Structs\u00a7\u27e85\u27e9\n\nHeader\u27e86\u27e9\n    Represents a parsed header.\n\nInvalidChunkSize\u27e87\u27e9\n    An error in parsing a chunk size.\n\nParserConfig\u27e88\u27e9\n    Parser configuration.\n\nRequest\u27e89\u27e9\n    A parsed Request.\n\nResponse\u27e810\u27e9\n    A parsed Response.\n## Enums\u00a7\u27e811\u27e9\n\nError\u27e812\u27e9\n    An error in parsing.\n\nStatus\u27e813\u27e9\n    The result of a successful parse pass.\n## Constants\u00a7\u27e814\u27e9\n\nEMPTY_HEADER\u27e815\u27e9\n    An empty header, useful for constructing a `Header` array to pass in for parsing.\n## Functions\u00a7\u27e816\u27e9\n\nparse_chunk_size\u27e817\u27e9\n    Parse a buffer of bytes as a chunk size.\n\nparse_headers\u27e818\u27e9\n    Parse a buffer of bytes as headers.\n## Type Aliases\u00a7\u27e819\u27e9\n\nResult\u27e820\u27e9\n    A Result of any parsing action.\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/httparse/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/httparse/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/httparse/latest/src/httparse/lib.rs.html#1-2798: Source\n\u27e84\u27e9 https://docs.rs/httparse/latest/httparse/#httparse: \u00a7\n\u27e85\u27e9 https://docs.rs/httparse/latest/httparse/#structs: \u00a7\n\u27e86\u27e9 https://docs.rs/httparse/latest/httparse/struct.Header.html: struct httparse::Header - Header\n\u27e87\u27e9 https://docs.rs/httparse/latest/httparse/struct.InvalidChunkSize.html: struct httparse::InvalidChunkSize - InvalidChunkSize\n\u27e88\u27e9 https://docs.rs/httparse/latest/httparse/struct.ParserConfig.html: struct httparse::ParserConfig - ParserConfig\n\u27e89\u27e9 https://docs.rs/httparse/latest/httparse/struct.Request.html: struct httparse::Request - Request\n\u27e810\u27e9 https://docs.rs/httparse/latest/httparse/struct.Response.html: struct httparse::Response - Response\n\u27e811\u27e9 https://docs.rs/httparse/latest/httparse/#enums: \u00a7\n\u27e812\u27e9 https://docs.rs/httparse/latest/httparse/enum.Error.html: enum httparse::Error - Error\n\u27e813\u27e9 https://docs.rs/httparse/latest/httparse/enum.Status.html: enum httparse::Status - Status\n\u27e814\u27e9 https://docs.rs/httparse/latest/httparse/#constants: \u00a7\n\u27e815\u27e9 https://docs.rs/httparse/latest/httparse/constant.EMPTY_HEADER.html: constant httparse::EMPTY_HEADER - EMPTY_HEADER\n\u27e816\u27e9 https://docs.rs/httparse/latest/httparse/#functions: \u00a7\n\u27e817\u27e9 https://docs.rs/httparse/latest/httparse/fn.parse_chunk_size.html: fn httparse::parse_chunk_size - parse_chunk_size\n\u27e818\u27e9 https://docs.rs/httparse/latest/httparse/fn.parse_headers.html: fn httparse::parse_headers - parse_headers\n\u27e819\u27e9 https://docs.rs/httparse/latest/httparse/#types: \u00a7\n\u27e820\u27e9 https://docs.rs/httparse/latest/httparse/type.Result.html: type httparse::Result - Result\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `httparse` crate is a fast and safe library for parsing HTTP/1.x requests and responses, optimized with SIMD support and runtime detection for performance gains. It provides key structures like `Request`, `Response`, and `Header`, along with functions for parsing headers and chunk sizes. Unsafe code is contained and carefully managed to ensure safety while maximizing speed.",
    "feature_summary": null,
    "use_case": "Web Framework",
    "score": 7.0,
    "factual_counterfactual": "### Pair 1: Parsing HTTP Requests and Responses  \n\u2705 Factual: The `httparse` crate is designed to parse HTTP/1.x requests and responses efficiently, with a focus on speed and safety.  \n\u274c Counterfactual: The `httparse` crate supports parsing HTTP/2 and HTTP/3 protocols in addition to HTTP/1.x.  \n\n---\n\n### Pair 2: SIMD Optimization  \n\u2705 Factual: With Rust 1.27.0 or later, `httparse` automatically enables SIMD optimizations to enhance parsing performance, detecting features like SSE4.2 or AVX2 at runtime.  \n\u274c Counterfactual: SIMD optimizations in `httparse` require manual configuration and are not enabled automatically, even when using Rust 1.27.0 or later.  \n\n---\n\n### Pair 3: Error Handling  \n\u2705 Factual: The `httparse` crate provides an `Error` enum to represent various parsing errors, such as invalid chunk sizes or malformed headers.  \n\u274c Counterfactual: The `httparse` crate does not provide any error-handling mechanisms and panics on parsing failures.",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}