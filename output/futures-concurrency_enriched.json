{
    "name": "futures-concurrency",
    "version": "7.6.3",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/futures-concurrency/latest/futures_concurrency/all.html \"show sidebar\")\n# Crate futures_concurrencyCopy item path\n[Settings](https://docs.rs/futures-concurrency/latest/settings.html)\n[Help](https://docs.rs/futures-concurrency/latest/help.html)\nSummary[Source](https://docs.rs/futures-concurrency/latest/src/futures_concurrency/lib.rs.html#1-203)\nExpand description\nPerformant, portable, structured concurrency operations for async Rust. It works with any runtime, does not erase lifetimes, always handles cancellation, and always returns output to the caller.\n`futures-concurrency` provides concurrency operations for both groups of futures and streams. Both for bounded and unbounded sets of futures and streams. In both cases performance should be on par with, if not exceed conventional executor implementations.\n## [\u00a7](https://docs.rs/futures-concurrency/latest/futures_concurrency/#examples)Examples\n**Await multiple futures of different types**\n```\nuse futures_concurrency::prelude::*;\nuse std::future;\nlet a = future::ready(1u8);\nlet b = future::ready(\"hello\");\nlet c = future::ready(3u16);\nassert_eq!((a, b, c).join().await, (1, \"hello\", 3));\n```\n\n**Concurrently process items in a collection**\n```\nuse futures_concurrency::prelude::*;\nlet v: Vec<_> = vec![\"chashu\", \"nori\"]\n  .into_co_stream()\n  .map(|msg| async move { format!(\"hello {msg}\") })\n  .collect()\n  .await;\nassert_eq!(v, &[\"hello chashu\", \"hello nori\"]);\n```\n\n**Access stack data outside the futures\u2019 scope**\n_Adapted from[`std::thread::scope`](https://doc.rust-lang.org/std/thread/fn.scope.html)._\n```\nuse futures_concurrency::prelude::*;\nlet mut container = vec![1, 2, 3];\nlet mut num = 0;\nlet a = async {\n  println!(\"hello from the first future\");\n  dbg!(&container);\n};\nlet b = async {\n  println!(\"hello from the second future\");\n  num += container[0] + container[2];\n};\nprintln!(\"hello from the main future\");\nlet _ = (a, b).join().await;\ncontainer.push(4);\nassert_eq!(num, container.len());\n```\n\n## [\u00a7](https://docs.rs/futures-concurrency/latest/futures_concurrency/#operations)Operations\n### [\u00a7](https://docs.rs/futures-concurrency/latest/futures_concurrency/#futures)Futures\nFor futures which return a regular type `T` only the `join` and `race` operations are available. `join` waits for all futures to complete, while `race` will wait for the first future to complete. However for futures which return a `Try<Output = T>` two additional operations are available. The following table describes the behavior of concurrency operations for fallible futures:\n| **Wait for all outputs**| **Wait for first output**  \n---|---|---  \n**Continue on error**| `Future::join`| `Future::race_ok`  \n**Short-circuit on error**| `Future::try_join`| `Future::race`  \nThe following futures implementations are provided by `futures-concurrency`:\n  * [`FutureGroup`](https://docs.rs/futures-concurrency/latest/futures_concurrency/future/struct.FutureGroup.html \"struct futures_concurrency::future::FutureGroup\"): A growable group of futures which operate as a single unit.\n  * `tuple`: [`join`](https://docs.rs/futures-concurrency/latest/futures_concurrency/future/trait.Join.html#impl-Join-for-\\(A,+B\\) \"trait futures_concurrency::future::Join\"), [`try_join`](https://docs.rs/futures-concurrency/latest/futures_concurrency/future/trait.TryJoin.html#impl-TryJoin-for-\\(A,+B\\) \"trait futures_concurrency::future::TryJoin\"), [`race`](https://docs.rs/futures-concurrency/latest/futures_concurrency/future/trait.Race.html#impl-Race-for-\\(A,+B\\) \"trait futures_concurrency::future::Race\"), [`race_ok`](https://docs.rs/futures-concurrency/latest/futures_concurrency/future/trait.RaceOk.html#impl-RaceOk-for-\\(A,+B\\) \"trait futures_concurrency::future::RaceOk\")\n  * `array`: [`join`](https://docs.rs/futures-concurrency/latest/futures_concurrency/future/trait.Join.html#impl-Join-for-%5C%5BFut;+N%5C%5D \"trait futures_concurrency::future::Join\"), [`try_join`](https://docs.rs/futures-concurrency/latest/futures_concurrency/future/trait.TryJoin.html#impl-TryJoin-for-%5C%5BFut;+N%5C%5D \"trait futures_concurrency::future::TryJoin\"), [`race`](https://docs.rs/futures-concurrency/latest/futures_concurrency/future/trait.Race.html#impl-Race-for-%5C%5BFut;+N%5C%5D \"trait futures_concurrency::future::Race\"), [`race_ok`](https://docs.rs/futures-concurrency/latest/futures_concurrency/future/trait.RaceOk.html#impl-RaceOk-for-%5C%5BFut;+N%5C%5D \"trait futures_concurrency::future::RaceOk\")\n  * `Vec`: [`join`](https://docs.rs/futures-concurrency/latest/futures_concurrency/future/trait.Join.html#impl-Join-for-Vec%3CFut%3E \"trait futures_concurrency::future::Join\"), [`try_join`](https://docs.rs/futures-concurrency/latest/futures_concurrency/future/trait.TryJoin.html#impl-TryJoin-for-Vec%3CFut%3E \"trait futures_concurrency::future::TryJoin\"), [`race`](https://docs.rs/futures-concurrency/latest/futures_concurrency/future/trait.Race.html#impl-Race-for-Vec%3CFut%3E \"trait futures_concurrency::future::Race\"), [`race_ok`](https://docs.rs/futures-concurrency/latest/futures_concurrency/future/trait.RaceOk.html#impl-RaceOk-for-Vec%3CFut%3E \"trait futures_concurrency::future::RaceOk\")\n\n\n### [\u00a7](https://docs.rs/futures-concurrency/latest/futures_concurrency/#streams)Streams\nStreams yield outputs one-by-one, which means that deciding to stop iterating is the same for fallible and infallible streams. The operations provided for streams can be categorized based on whether their inputs can be concurrently evaluated, and whether their outputs can be concurrently processed.\nSpecifically in the case of `merge`, it takes `N` streams in, and yields items one-by-one as soon as any are available. This enables the output of individual streams to be concurrently processed by further operations later on.\n| **Sequential output processing**| **Concurrent output processing**  \n---|---|---  \n**Sequential input evaluation**| `Stream::chain`|  _not yet available_ \u2021  \n**Concurrent input evaluation**| `Stream::zip`| `Stream::merge`  \n\u2021: _This could be addressed by a hypothetical`Stream::unzip` operation, however because we aspire for semantic compatibility with `std::iter::Iterator` in our operations, the path to adding it is currently unclear_.\nThe following streams implementations are provided by `futures-concurrency`:\n  * [`StreamGroup`](https://docs.rs/futures-concurrency/latest/futures_concurrency/stream/struct.StreamGroup.html \"struct futures_concurrency::stream::StreamGroup\"): A growable group of streams which operate as a single unit.\n  * [`ConcurrentStream`](https://docs.rs/futures-concurrency/latest/futures_concurrency/concurrent_stream/trait.ConcurrentStream.html \"trait futures_concurrency::concurrent_stream::ConcurrentStream\"): A trait for asynchronous streams which can concurrently process items.\n  * `tuple`: [`chain`](https://docs.rs/futures-concurrency/latest/futures_concurrency/stream/trait.Chain.html#impl-Chain-for-\\(A,+B\\) \"trait futures_concurrency::stream::Chain\"), [`merge`](https://docs.rs/futures-concurrency/latest/futures_concurrency/stream/trait.Merge.html#impl-Merge-for-\\(A,+B\\) \"trait futures_concurrency::stream::Merge\"), [`zip`](https://docs.rs/futures-concurrency/latest/futures_concurrency/stream/trait.Zip.html#impl-Zip-for-\\(A,+B\\) \"trait futures_concurrency::stream::Zip\")\n  * `array`: [`chain`](https://docs.rs/futures-concurrency/latest/futures_concurrency/stream/trait.Chain.html#impl-Chain-for-%5C%5BFut;+N%5C%5D \"trait futures_concurrency::stream::Chain\"), [`merge`](https://docs.rs/futures-concurrency/latest/futures_concurrency/stream/trait.Merge.html#impl-Merge-for-%5C%5BFut;+N%5C%5D \"trait futures_concurrency::stream::Merge\"), [`zip`](https://docs.rs/futures-concurrency/latest/futures_concurrency/stream/trait.Zip.html#impl-Zip-for-%5C%5BFut;+N%5C%5D \"trait futures_concurrency::stream::Zip\")\n  * `Vec`: [`chain`](https://docs.rs/futures-concurrency/latest/futures_concurrency/stream/trait.Chain.html#impl-Chain-for-Vec%3CFut%3E \"trait futures_concurrency::stream::Chain\"), [`merge`](https://docs.rs/futures-concurrency/latest/futures_concurrency/stream/trait.Merge.html#impl-Merge-for-Vec%3CFut%3E \"trait futures_concurrency::stream::Merge\"), [`zip`](https://docs.rs/futures-concurrency/latest/futures_concurrency/stream/trait.Zip.html#impl-Zip-for-Vec%3CFut%3E \"trait futures_concurrency::stream::Zip\")\n\n\n## [\u00a7](https://docs.rs/futures-concurrency/latest/futures_concurrency/#runtime-support)Runtime Support\n`futures-concurrency` does not depend on any runtime executor being present. This enables it to work out of the box with any async runtime, including: `tokio`, `async-std`, `smol`, `glommio`, and `monoio`. It also supports `#[no_std]` environments, allowing it to be used with embedded async runtimes such as `embassy`.\n## [\u00a7](https://docs.rs/futures-concurrency/latest/futures_concurrency/#feature-flags)Feature Flags\nThe `std` feature flag is enabled by default. To target `alloc` or `no_std` environments, you can enable the following configuration:\n```\n[dependencies]\n# no_std\nfutures-concurrency = { version = \"7.5.0\", default-features = false }\n# alloc\nfutures-concurrency = { version = \"7.5.0\", default-features = false, features = [\"alloc\"] }\n```\n\n## [\u00a7](https://docs.rs/futures-concurrency/latest/futures_concurrency/#further-reading)Further Reading\n`futures-concurrency` has been developed over the span of several years. It is primarily maintained by Yosh Wuyts, a member of the Rust Async WG. You can read more about the development and ideas behind `futures-concurrency` here:\n  * [Futures Concurrency I: Introduction](https://blog.yoshuawuyts.com/futures-concurrency/)\n  * [Futures Concurrency II: A Trait Approach](https://blog.yoshuawuyts.com/futures-concurrency-2/)\n  * [Futures Concurrency III: `select!`](https://blog.yoshuawuyts.com/futures-concurrency-3/)\n  * [Futures Concurrency IV: Join Semantics](https://blog.yoshuawuyts.com/futures-concurrency-4/)\n\n\n## Modules[\u00a7](https://docs.rs/futures-concurrency/latest/futures_concurrency/#modules)\n\n[array](https://docs.rs/futures-concurrency/latest/futures_concurrency/array/index.html \"mod futures_concurrency::array\")\n    Helper functions and types for fixed-length arrays.\n\n[concurrent_stream](https://docs.rs/futures-concurrency/latest/futures_concurrency/concurrent_stream/index.html \"mod futures_concurrency::concurrent_stream\")\n    Concurrent execution of streams\n\n[future](https://docs.rs/futures-concurrency/latest/futures_concurrency/future/index.html \"mod futures_concurrency::future\")\n    Asynchronous basic functionality.\n\n[prelude](https://docs.rs/futures-concurrency/latest/futures_concurrency/prelude/index.html \"mod futures_concurrency::prelude\")\n    The futures concurrency prelude.\n\n[stream](https://docs.rs/futures-concurrency/latest/futures_concurrency/stream/index.html \"mod futures_concurrency::stream\")\n    Composable asynchronous iteration.\n\n[vec](https://docs.rs/futures-concurrency/latest/futures_concurrency/vec/index.html \"mod futures_concurrency::vec\")\n    Parallel iterator types for [vectors](https://doc.rust-lang.org/std/vec/index.html) (`Vec<T>`)\n",
        "markdown_with_citations": "[](https://docs.rs/futures-concurrency/latest/futures_concurrency/all.html \"show sidebar\")\n# Crate futures_concurrencyCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nPerformant, portable, structured concurrency operations for async Rust. It works with any runtime, does not erase lifetimes, always handles cancellation, and always returns output to the caller.\n`futures-concurrency` provides concurrency operations for both groups of futures and streams. Both for bounded and unbounded sets of futures and streams. In both cases performance should be on par with, if not exceed conventional executor implementations.\n## \u00a7\u27e84\u27e9Examples\n**Await multiple futures of different types**\n```\nuse futures_concurrency::prelude::*;\nuse std::future;\nlet a = future::ready(1u8);\nlet b = future::ready(\"hello\");\nlet c = future::ready(3u16);\nassert_eq!((a, b, c).join().await, (1, \"hello\", 3));\n```\n\n**Concurrently process items in a collection**\n```\nuse futures_concurrency::prelude::*;\nlet v: Vec<_> = vec![\"chashu\", \"nori\"]\n  .into_co_stream()\n  .map(|msg| async move { format!(\"hello {msg}\") })\n  .collect()\n  .await;\nassert_eq!(v, &[\"hello chashu\", \"hello nori\"]);\n```\n\n**Access stack data outside the futures\u2019 scope**\n_Adapted from`std::thread::scope`\u27e85\u27e9._\n```\nuse futures_concurrency::prelude::*;\nlet mut container = vec![1, 2, 3];\nlet mut num = 0;\nlet a = async {\n  println!(\"hello from the first future\");\n  dbg!(&container);\n};\nlet b = async {\n  println!(\"hello from the second future\");\n  num += container[0] + container[2];\n};\nprintln!(\"hello from the main future\");\nlet _ = (a, b).join().await;\ncontainer.push(4);\nassert_eq!(num, container.len());\n```\n\n## \u00a7\u27e86\u27e9Operations\n### \u00a7\u27e87\u27e9Futures\nFor futures which return a regular type `T` only the `join` and `race` operations are available. `join` waits for all futures to complete, while `race` will wait for the first future to complete. However for futures which return a `Try<Output = T>` two additional operations are available. The following table describes the behavior of concurrency operations for fallible futures:\n| **Wait for all outputs**| **Wait for first output**  \n---|---|---  \n**Continue on error**| `Future::join`| `Future::race_ok`  \n**Short-circuit on error**| `Future::try_join`| `Future::race`  \nThe following futures implementations are provided by `futures-concurrency`:\n  * `FutureGroup`\u27e88\u27e9: A growable group of futures which operate as a single unit.\n  * `tuple`: `join`\u27e89\u27e9 \"trait futures_concurrency::future::Join\"), `try_join`\u27e810\u27e9 \"trait futures_concurrency::future::TryJoin\"), `race`\u27e811\u27e9 \"trait futures_concurrency::future::Race\"), `race_ok`\u27e812\u27e9 \"trait futures_concurrency::future::RaceOk\")\n  * `array`: `join`\u27e813\u27e9, `try_join`\u27e814\u27e9, `race`\u27e815\u27e9, `race_ok`\u27e816\u27e9\n  * `Vec`: `join`\u27e817\u27e9, `try_join`\u27e818\u27e9, `race`\u27e819\u27e9, `race_ok`\u27e820\u27e9\n\n\n### \u00a7\u27e821\u27e9Streams\nStreams yield outputs one-by-one, which means that deciding to stop iterating is the same for fallible and infallible streams. The operations provided for streams can be categorized based on whether their inputs can be concurrently evaluated, and whether their outputs can be concurrently processed.\nSpecifically in the case of `merge`, it takes `N` streams in, and yields items one-by-one as soon as any are available. This enables the output of individual streams to be concurrently processed by further operations later on.\n| **Sequential output processing**| **Concurrent output processing**  \n---|---|---  \n**Sequential input evaluation**| `Stream::chain`|  _not yet available_ \u2021  \n**Concurrent input evaluation**| `Stream::zip`| `Stream::merge`  \n\u2021: _This could be addressed by a hypothetical`Stream::unzip` operation, however because we aspire for semantic compatibility with `std::iter::Iterator` in our operations, the path to adding it is currently unclear_.\nThe following streams implementations are provided by `futures-concurrency`:\n  * `StreamGroup`\u27e822\u27e9: A growable group of streams which operate as a single unit.\n  * `ConcurrentStream`\u27e823\u27e9: A trait for asynchronous streams which can concurrently process items.\n  * `tuple`: `chain`\u27e824\u27e9 \"trait futures_concurrency::stream::Chain\"), `merge`\u27e825\u27e9 \"trait futures_concurrency::stream::Merge\"), `zip`\u27e826\u27e9 \"trait futures_concurrency::stream::Zip\")\n  * `array`: `chain`\u27e827\u27e9, `merge`\u27e828\u27e9, `zip`\u27e829\u27e9\n  * `Vec`: `chain`\u27e830\u27e9, `merge`\u27e831\u27e9, `zip`\u27e832\u27e9\n\n\n## \u00a7\u27e833\u27e9Runtime Support\n`futures-concurrency` does not depend on any runtime executor being present. This enables it to work out of the box with any async runtime, including: `tokio`, `async-std`, `smol`, `glommio`, and `monoio`. It also supports `#[no_std]` environments, allowing it to be used with embedded async runtimes such as `embassy`.\n## \u00a7\u27e834\u27e9Feature Flags\nThe `std` feature flag is enabled by default. To target `alloc` or `no_std` environments, you can enable the following configuration:\n```\n[dependencies]\n# no_std\nfutures-concurrency = { version = \"7.5.0\", default-features = false }\n# alloc\nfutures-concurrency = { version = \"7.5.0\", default-features = false, features = [\"alloc\"] }\n```\n\n## \u00a7\u27e835\u27e9Further Reading\n`futures-concurrency` has been developed over the span of several years. It is primarily maintained by Yosh Wuyts, a member of the Rust Async WG. You can read more about the development and ideas behind `futures-concurrency` here:\n  * Futures Concurrency I: Introduction\u27e836\u27e9\n  * Futures Concurrency II: A Trait Approach\u27e837\u27e9\n  * Futures Concurrency III: `select!`\u27e838\u27e9\n  * Futures Concurrency IV: Join Semantics\u27e839\u27e9\n\n\n## Modules\u00a7\u27e840\u27e9\n\narray\u27e841\u27e9\n    Helper functions and types for fixed-length arrays.\n\nconcurrent_stream\u27e842\u27e9\n    Concurrent execution of streams\n\nfuture\u27e843\u27e9\n    Asynchronous basic functionality.\n\nprelude\u27e844\u27e9\n    The futures concurrency prelude.\n\nstream\u27e845\u27e9\n    Composable asynchronous iteration.\n\nvec\u27e846\u27e9\n    Parallel iterator types for vectors\u27e847\u27e9 (`Vec<T>`)\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/futures-concurrency/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/futures-concurrency/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/futures-concurrency/latest/src/futures_concurrency/lib.rs.html#1-203: Source\n\u27e84\u27e9 https://docs.rs/futures-concurrency/latest/futures_concurrency/#examples: \u00a7\n\u27e85\u27e9 https://doc.rust-lang.org/std/thread/fn.scope.html: `std::thread::scope`\n\u27e86\u27e9 https://docs.rs/futures-concurrency/latest/futures_concurrency/#operations: \u00a7\n\u27e87\u27e9 https://docs.rs/futures-concurrency/latest/futures_concurrency/#futures: \u00a7\n\u27e88\u27e9 https://docs.rs/futures-concurrency/latest/futures_concurrency/future/struct.FutureGroup.html: struct futures_concurrency::future::FutureGroup - `FutureGroup`\n\u27e89\u27e9 https://docs.rs/futures-concurrency/latest/futures_concurrency/future/trait.Join.html#impl-Join-for-\\(A,+B\\: `join`\n\u27e810\u27e9 https://docs.rs/futures-concurrency/latest/futures_concurrency/future/trait.TryJoin.html#impl-TryJoin-for-\\(A,+B\\: `try_join`\n\u27e811\u27e9 https://docs.rs/futures-concurrency/latest/futures_concurrency/future/trait.Race.html#impl-Race-for-\\(A,+B\\: `race`\n\u27e812\u27e9 https://docs.rs/futures-concurrency/latest/futures_concurrency/future/trait.RaceOk.html#impl-RaceOk-for-\\(A,+B\\: `race_ok`\n\u27e813\u27e9 https://docs.rs/futures-concurrency/latest/futures_concurrency/future/trait.Join.html#impl-Join-for-%5C%5BFut;+N%5C%5D: trait futures_concurrency::future::Join - `join`\n\u27e814\u27e9 https://docs.rs/futures-concurrency/latest/futures_concurrency/future/trait.TryJoin.html#impl-TryJoin-for-%5C%5BFut;+N%5C%5D: trait futures_concurrency::future::TryJoin - `try_join`\n\u27e815\u27e9 https://docs.rs/futures-concurrency/latest/futures_concurrency/future/trait.Race.html#impl-Race-for-%5C%5BFut;+N%5C%5D: trait futures_concurrency::future::Race - `race`\n\u27e816\u27e9 https://docs.rs/futures-concurrency/latest/futures_concurrency/future/trait.RaceOk.html#impl-RaceOk-for-%5C%5BFut;+N%5C%5D: trait futures_concurrency::future::RaceOk - `race_ok`\n\u27e817\u27e9 https://docs.rs/futures-concurrency/latest/futures_concurrency/future/trait.Join.html#impl-Join-for-Vec%3CFut%3E: trait futures_concurrency::future::Join - `join`\n\u27e818\u27e9 https://docs.rs/futures-concurrency/latest/futures_concurrency/future/trait.TryJoin.html#impl-TryJoin-for-Vec%3CFut%3E: trait futures_concurrency::future::TryJoin - `try_join`\n\u27e819\u27e9 https://docs.rs/futures-concurrency/latest/futures_concurrency/future/trait.Race.html#impl-Race-for-Vec%3CFut%3E: trait futures_concurrency::future::Race - `race`\n\u27e820\u27e9 https://docs.rs/futures-concurrency/latest/futures_concurrency/future/trait.RaceOk.html#impl-RaceOk-for-Vec%3CFut%3E: trait futures_concurrency::future::RaceOk - `race_ok`\n\u27e821\u27e9 https://docs.rs/futures-concurrency/latest/futures_concurrency/#streams: \u00a7\n\u27e822\u27e9 https://docs.rs/futures-concurrency/latest/futures_concurrency/stream/struct.StreamGroup.html: struct futures_concurrency::stream::StreamGroup - `StreamGroup`\n\u27e823\u27e9 https://docs.rs/futures-concurrency/latest/futures_concurrency/concurrent_stream/trait.ConcurrentStream.html: trait futures_concurrency::concurrent_stream::ConcurrentStream - `ConcurrentStream`\n\u27e824\u27e9 https://docs.rs/futures-concurrency/latest/futures_concurrency/stream/trait.Chain.html#impl-Chain-for-\\(A,+B\\: `chain`\n\u27e825\u27e9 https://docs.rs/futures-concurrency/latest/futures_concurrency/stream/trait.Merge.html#impl-Merge-for-\\(A,+B\\: `merge`\n\u27e826\u27e9 https://docs.rs/futures-concurrency/latest/futures_concurrency/stream/trait.Zip.html#impl-Zip-for-\\(A,+B\\: `zip`\n\u27e827\u27e9 https://docs.rs/futures-concurrency/latest/futures_concurrency/stream/trait.Chain.html#impl-Chain-for-%5C%5BFut;+N%5C%5D: trait futures_concurrency::stream::Chain - `chain`\n\u27e828\u27e9 https://docs.rs/futures-concurrency/latest/futures_concurrency/stream/trait.Merge.html#impl-Merge-for-%5C%5BFut;+N%5C%5D: trait futures_concurrency::stream::Merge - `merge`\n\u27e829\u27e9 https://docs.rs/futures-concurrency/latest/futures_concurrency/stream/trait.Zip.html#impl-Zip-for-%5C%5BFut;+N%5C%5D: trait futures_concurrency::stream::Zip - `zip`\n\u27e830\u27e9 https://docs.rs/futures-concurrency/latest/futures_concurrency/stream/trait.Chain.html#impl-Chain-for-Vec%3CFut%3E: trait futures_concurrency::stream::Chain - `chain`\n\u27e831\u27e9 https://docs.rs/futures-concurrency/latest/futures_concurrency/stream/trait.Merge.html#impl-Merge-for-Vec%3CFut%3E: trait futures_concurrency::stream::Merge - `merge`\n\u27e832\u27e9 https://docs.rs/futures-concurrency/latest/futures_concurrency/stream/trait.Zip.html#impl-Zip-for-Vec%3CFut%3E: trait futures_concurrency::stream::Zip - `zip`\n\u27e833\u27e9 https://docs.rs/futures-concurrency/latest/futures_concurrency/#runtime-support: \u00a7\n\u27e834\u27e9 https://docs.rs/futures-concurrency/latest/futures_concurrency/#feature-flags: \u00a7\n\u27e835\u27e9 https://docs.rs/futures-concurrency/latest/futures_concurrency/#further-reading: \u00a7\n\u27e836\u27e9 https://blog.yoshuawuyts.com/futures-concurrency/: Futures Concurrency I: Introduction\n\u27e837\u27e9 https://blog.yoshuawuyts.com/futures-concurrency-2/: Futures Concurrency II: A Trait Approach\n\u27e838\u27e9 https://blog.yoshuawuyts.com/futures-concurrency-3/: Futures Concurrency III: `select!`\n\u27e839\u27e9 https://blog.yoshuawuyts.com/futures-concurrency-4/: Futures Concurrency IV: Join Semantics\n\u27e840\u27e9 https://docs.rs/futures-concurrency/latest/futures_concurrency/#modules: \u00a7\n\u27e841\u27e9 https://docs.rs/futures-concurrency/latest/futures_concurrency/array/index.html: mod futures_concurrency::array - array\n\u27e842\u27e9 https://docs.rs/futures-concurrency/latest/futures_concurrency/concurrent_stream/index.html: mod futures_concurrency::concurrent_stream - concurrent_stream\n\u27e843\u27e9 https://docs.rs/futures-concurrency/latest/futures_concurrency/future/index.html: mod futures_concurrency::future - future\n\u27e844\u27e9 https://docs.rs/futures-concurrency/latest/futures_concurrency/prelude/index.html: mod futures_concurrency::prelude - prelude\n\u27e845\u27e9 https://docs.rs/futures-concurrency/latest/futures_concurrency/stream/index.html: mod futures_concurrency::stream - stream\n\u27e846\u27e9 https://docs.rs/futures-concurrency/latest/futures_concurrency/vec/index.html: mod futures_concurrency::vec - vec\n\u27e847\u27e9 https://doc.rust-lang.org/std/vec/index.html: vectors\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `futures-concurrency` crate provides performant and structured concurrency operations for async Rust, supporting both futures and streams with bounded and unbounded sets. It offers operations like `join`, `race`, `try_join`, and `merge` for concurrent execution, while ensuring cancellation handling and compatibility with any async runtime, including `tokio`, `async-std`, and embedded `#[no_std]` environments. The crate emphasizes portability, lifetime preservation, and efficient processing of async tasks.",
    "feature_summary": null,
    "use_case": "Utilities",
    "score": 6.0,
    "factual_counterfactual": "### Pair 1: Runtime Support  \n\u2705 **Factual:** The `futures-concurrency` crate is runtime-agnostic and works seamlessly with popular async runtimes like `tokio`, `async-std`, `smol`, `glommio`, and `monoio`. It also supports `#[no_std]` environments, enabling usage in embedded systems with runtimes like `embassy`.  \n\u274c **Counterfactual:** The `futures-concurrency` crate requires `tokio` as its default runtime and does not support other runtimes or `#[no_std]` environments.  \n\n---\n\n### Pair 2: Concurrency Operations  \n\u2705 **Factual:** The crate provides structured concurrency operations such as `join` and `race` for futures, where `join` waits for all futures to complete and `race` waits for the first future to complete. Additionally, for fallible futures, operations like `try_join` and `race_ok` are available for error handling.  \n\u274c **Counterfactual:** The crate only supports the `join` operation for futures and does not provide specialized operations for error handling, such as `try_join` or `race_ok`.  \n\n---\n\n### Pair 3: Stream Processing  \n\u2705 **Factual:** The `futures-concurrency` crate supports concurrent stream processing with operations like `merge`, which processes items from multiple streams as soon as they become available, and `zip`, which pairs items from multiple streams sequential",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}