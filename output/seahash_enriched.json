{
    "name": "seahash",
    "version": "4.1.0",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/seahash/latest/seahash/all.html \"show sidebar\")\n# Crate seahashCopy item path\n[Settings](https://docs.rs/seahash/latest/settings.html)\n[Help](https://docs.rs/seahash/latest/help.html)\nSummary[Source](https://docs.rs/seahash/latest/src/seahash/lib.rs.html#1-168)\nExpand description\nSeaHash: A blazingly fast, portable hash function with proven statistical guarantees.\nSeaHash is a hash function with performance better than (around 3-20% improvement) xxHash and MetroHash. Furthermore, SeaHash has mathematically provable statistical guarantees.\nSeaHash is a portable hash function, meaning that the output is not dependent on the hosting architecture, and makes no assumptions on endianness or the alike. This stable layout allows it to be used for on-disk/permanent storage (e.g. checksums).\n## [\u00a7](https://docs.rs/seahash/latest/seahash/#design-advantages-and-features)Design, advantages, and features\n  * **High quality** : It beats most other general purpose hash functions because it provides full avalanche inbetween state updates.\n  * **Performance** : SeaHash beats every high-quality (grading 10/10 in smhasher) hash function that I know of.\n  * **Provable quality guarantees** : Contrary to most other non-cryptographic hash function, SeaHash can be proved to satisfy the avalanche criterion as well as BIC.\n  * **Parallelizable** : Consists of multiple, independent states to take advantage of ILP and/or software threads.\n  * **Bulk reads** : Reads 8 or 4 bytes a time.\n  * **Stable and portable** : Does not depend on the target architecture, and produces a stable value, which is only changed in major version bumps.\n  * **Keyed** : Designed to not leak the seed/key. Note that it has not gone through cryptoanalysis yet, so the keyed version shouldn\u2019t be relied on when security is needed.\n  * **Hardware accelerateable** : SeaHash is designed such that ASICs can implement it with really high performance.\n\n\n## [\u00a7](https://docs.rs/seahash/latest/seahash/#a-word-of-warning)A word of warning!\nThis is **not** a cryptographic function, and it certainly should not be used as one. If you want a good cryptographic hash function, you should use SHA-3 (Keccak) or BLAKE2.\nIt is not secure, nor does it aim to be. It aims to have high quality pseudorandom output and few collisions, as well as being fast.\n## [\u00a7](https://docs.rs/seahash/latest/seahash/#benchmark)Benchmark\nOn normal hardware, it is expected to run with a rate around 5.9-6.7 GB/S on a 2.5 GHz CPU. Further improvement can be seen when hashing very big buffers in parallel.\nFunction| Quality| Cycles per byte (lower is better)| Author  \n---|---|---|---  \n**SeaHash**| **Excellent**| **0.24**| **Ticki**  \nxxHash| Excellent| 0.31| Collet  \nMetroHash| Excellent| 0.35| Rogers  \nMurmur| Excellent| 0.64| Appleby  \nRabin| Medium| 1.51| Rabin  \nCityHash| Excellent| 1.62| Pike, Alakuijala  \nLoseLose| Terrible| 2.01| Kernighan, Ritchie  \nFNV| Poor| 3.12| Fowler, Noll, Vo  \nSipHash| Pseudorandom| 3.21| Aumasson, Bernstein  \nCRC| Good| 3.91| Peterson  \nDJB2| Poor| 4.13| Bernstein  \n### [\u00a7](https://docs.rs/seahash/latest/seahash/#ideal-architecture)Ideal architecture\nSeaHash is designed and optimized for the most common architecture in use:\n  * Little-endian\n  * 64-bit\n  * 64 or more bytes cache lines\n  * 4 or more instruction pipelines\n  * 4 or more 64-bit registers\n\n\nAnything that does not hold the above requirements will perform worse by up to 30-40%. Note that this means it is still faster than CityHash (~1 GB/S), MurMurHash (~2.6 GB/S), FNV (~0.5 GB/S), etc.\n## [\u00a7](https://docs.rs/seahash/latest/seahash/#achieving-the-performance)Achieving the performance\nLike any good general-purpose hash function, SeaHash reads 8 bytes at once effectively reducing the running time by an order of ~5.\nSecondly, SeaHash achieves the performance by heavily exploiting Instruction-Level Parallelism. In particular, it fetches 4 integers in every round and independently diffuses them. This yields four different states, which are finally combined.\n## [\u00a7](https://docs.rs/seahash/latest/seahash/#statistical-guarantees)Statistical guarantees\nSeaHash comes with certain proven guarantees about the statistical properties of the output:\n  1. Pick some _n_ -byte sequence, _s_. The number of _n_ -byte sequence colliding with _s_ is independent of the choice of _s_ (all equivalence class have equal size).\n  2. If you flip any bit in the input, the probability for any bit in the output to be flipped is 0.5.\n  3. The hash value of a sequence of uniformly distributed bytes is itself uniformly distributed.\n\n\nThe first guarantee can be derived through deduction, by proving that the diffusion function is bijective (reverse the XORs and find the congruence inverses to the primes).\nThe second guarantee requires more complex calculations: Construct a matrix of probabilities and set one to certain (1), then apply transformations through the respective operations. The proof is a bit long, but relatively simple.\nThe third guarantee requires proving that the hash value is a tree, such that:\n  * Leafs represents the input values.\n  * Single-child nodes reduce to the diffusion of the child.\n  * Multiple-child nodes reduce to the sum of the children.\n\n\nThen simply show that each of these reductions transform uniformly distributed variables to uniformly distributed variables.\n## [\u00a7](https://docs.rs/seahash/latest/seahash/#inner-workings)Inner workings\nIn technical terms, SeaHash follows a alternating 4-state length-padded Merkle\u2013Damg\u00e5rd construction with an XOR-diffuse compression function (click to enlarge):\n[![A diagram.](http://ticki.github.io/img/seahash_construction_diagram.svg)] (http://ticki.github.io/img/seahash_construction_diagram.svg)\nIt starts with 4 initial states, then it alternates between them (increment, wrap on 4) and does XOR with the respective block. When a state has been visited the diffusion function (f) is applied. The very last block is padded with zeros.\nAfter all the blocks have been gone over, all the states are XOR\u2019d to the number of bytes written. The sum is then passed through the diffusion function, which produces the final hash value.\nThe diffusion function is drawn below.\n```\nx \u2190 px\nx \u2190 x \u2295 ((x \u226b 32) \u226b (x \u226b 60))\nx \u2190 px\n```\n\nThe advantage of having four completely segregated (note that there is no mix round, so they\u2019re entirely independent) states is that fast parallelism is possible. For example, if I were to hash 1 TB, I can spawn up four threads which can run independently without _any_ intercommunication or synchronization before the last round.\nIf the diffusion function (f) was cryptographically secure, it would pass cryptoanalysis trivially. This might seem irrelevant, as it clearly isn\u2019t cryptographically secure, but it tells us something about the inner semantics. In particular, any diffusion function with sufficient statistical quality will make up a good hash function in this construction.\nRead [the blog post](http://ticki.github.io/blog/seahash-explained/) for more details.\n## [\u00a7](https://docs.rs/seahash/latest/seahash/#asic-version)ASIC version\nSeaHash is specifically designed such that it can be efficiently implemented in the form of ASIC while only using very few transistors.\n## [\u00a7](https://docs.rs/seahash/latest/seahash/#specification)Specification\nSee the [`reference`](https://docs.rs/seahash/latest/seahash/reference) module.\n## [\u00a7](https://docs.rs/seahash/latest/seahash/#credits)Credits\nAside for myself (@ticki), there are couple of other people who have helped creating this. Joshua Landau suggested using the [PCG family of diffusions](http://www.pcg-random.org/), created by Melissa E. O\u2019Neill. Sokolov Yura spotted multiple bugs in SeaHash.\n## Modules[\u00a7](https://docs.rs/seahash/latest/seahash/#modules)\n\n[reference](https://docs.rs/seahash/latest/seahash/reference/index.html \"mod seahash::reference\")\n    A slow, but clear reference implementation of SeaHash.\n## Structs[\u00a7](https://docs.rs/seahash/latest/seahash/#structs)\n\n[SeaHasher](https://docs.rs/seahash/latest/seahash/struct.SeaHasher.html \"struct seahash::SeaHasher\")\n    The streaming version of the algorithm.\n\n[State](https://docs.rs/seahash/latest/seahash/struct.State.html \"struct seahash::State\")\n    A SeaHash state.\n## Functions[\u00a7](https://docs.rs/seahash/latest/seahash/#functions)\n\n[hash](https://docs.rs/seahash/latest/seahash/fn.hash.html \"fn seahash::hash\")\n    Hash some buffer.\n\n[hash_seeded](https://docs.rs/seahash/latest/seahash/fn.hash_seeded.html \"fn seahash::hash_seeded\")\n    Hash some buffer according to a chosen seed.\n",
        "markdown_with_citations": "[](https://docs.rs/seahash/latest/seahash/all.html \"show sidebar\")\n# Crate seahashCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nSeaHash: A blazingly fast, portable hash function with proven statistical guarantees.\nSeaHash is a hash function with performance better than (around 3-20% improvement) xxHash and MetroHash. Furthermore, SeaHash has mathematically provable statistical guarantees.\nSeaHash is a portable hash function, meaning that the output is not dependent on the hosting architecture, and makes no assumptions on endianness or the alike. This stable layout allows it to be used for on-disk/permanent storage (e.g. checksums).\n## \u00a7\u27e84\u27e9Design, advantages, and features\n  * **High quality** : It beats most other general purpose hash functions because it provides full avalanche inbetween state updates.\n  * **Performance** : SeaHash beats every high-quality (grading 10/10 in smhasher) hash function that I know of.\n  * **Provable quality guarantees** : Contrary to most other non-cryptographic hash function, SeaHash can be proved to satisfy the avalanche criterion as well as BIC.\n  * **Parallelizable** : Consists of multiple, independent states to take advantage of ILP and/or software threads.\n  * **Bulk reads** : Reads 8 or 4 bytes a time.\n  * **Stable and portable** : Does not depend on the target architecture, and produces a stable value, which is only changed in major version bumps.\n  * **Keyed** : Designed to not leak the seed/key. Note that it has not gone through cryptoanalysis yet, so the keyed version shouldn\u2019t be relied on when security is needed.\n  * **Hardware accelerateable** : SeaHash is designed such that ASICs can implement it with really high performance.\n\n\n## \u00a7\u27e85\u27e9A word of warning!\nThis is **not** a cryptographic function, and it certainly should not be used as one. If you want a good cryptographic hash function, you should use SHA-3 (Keccak) or BLAKE2.\nIt is not secure, nor does it aim to be. It aims to have high quality pseudorandom output and few collisions, as well as being fast.\n## \u00a7\u27e86\u27e9Benchmark\nOn normal hardware, it is expected to run with a rate around 5.9-6.7 GB/S on a 2.5 GHz CPU. Further improvement can be seen when hashing very big buffers in parallel.\nFunction| Quality| Cycles per byte (lower is better)| Author  \n---|---|---|---  \n**SeaHash**| **Excellent**| **0.24**| **Ticki**  \nxxHash| Excellent| 0.31| Collet  \nMetroHash| Excellent| 0.35| Rogers  \nMurmur| Excellent| 0.64| Appleby  \nRabin| Medium| 1.51| Rabin  \nCityHash| Excellent| 1.62| Pike, Alakuijala  \nLoseLose| Terrible| 2.01| Kernighan, Ritchie  \nFNV| Poor| 3.12| Fowler, Noll, Vo  \nSipHash| Pseudorandom| 3.21| Aumasson, Bernstein  \nCRC| Good| 3.91| Peterson  \nDJB2| Poor| 4.13| Bernstein  \n### \u00a7\u27e87\u27e9Ideal architecture\nSeaHash is designed and optimized for the most common architecture in use:\n  * Little-endian\n  * 64-bit\n  * 64 or more bytes cache lines\n  * 4 or more instruction pipelines\n  * 4 or more 64-bit registers\n\n\nAnything that does not hold the above requirements will perform worse by up to 30-40%. Note that this means it is still faster than CityHash (~1 GB/S), MurMurHash (~2.6 GB/S), FNV (~0.5 GB/S), etc.\n## \u00a7\u27e88\u27e9Achieving the performance\nLike any good general-purpose hash function, SeaHash reads 8 bytes at once effectively reducing the running time by an order of ~5.\nSecondly, SeaHash achieves the performance by heavily exploiting Instruction-Level Parallelism. In particular, it fetches 4 integers in every round and independently diffuses them. This yields four different states, which are finally combined.\n## \u00a7\u27e89\u27e9Statistical guarantees\nSeaHash comes with certain proven guarantees about the statistical properties of the output:\n  1. Pick some _n_ -byte sequence, _s_. The number of _n_ -byte sequence colliding with _s_ is independent of the choice of _s_ (all equivalence class have equal size).\n  2. If you flip any bit in the input, the probability for any bit in the output to be flipped is 0.5.\n  3. The hash value of a sequence of uniformly distributed bytes is itself uniformly distributed.\n\n\nThe first guarantee can be derived through deduction, by proving that the diffusion function is bijective (reverse the XORs and find the congruence inverses to the primes).\nThe second guarantee requires more complex calculations: Construct a matrix of probabilities and set one to certain (1), then apply transformations through the respective operations. The proof is a bit long, but relatively simple.\nThe third guarantee requires proving that the hash value is a tree, such that:\n  * Leafs represents the input values.\n  * Single-child nodes reduce to the diffusion of the child.\n  * Multiple-child nodes reduce to the sum of the children.\n\n\nThen simply show that each of these reductions transform uniformly distributed variables to uniformly distributed variables.\n## \u00a7\u27e810\u27e9Inner workings\nIn technical terms, SeaHash follows a alternating 4-state length-padded Merkle\u2013Damg\u00e5rd construction with an XOR-diffuse compression function (click to enlarge):\n![A diagram.\u27e811\u27e9] (http://ticki.github.io/img/seahash_construction_diagram.svg)\nIt starts with 4 initial states, then it alternates between them (increment, wrap on 4) and does XOR with the respective block. When a state has been visited the diffusion function (f) is applied. The very last block is padded with zeros.\nAfter all the blocks have been gone over, all the states are XOR\u2019d to the number of bytes written. The sum is then passed through the diffusion function, which produces the final hash value.\nThe diffusion function is drawn below.\n```\nx \u2190 px\nx \u2190 x \u2295 ((x \u226b 32) \u226b (x \u226b 60))\nx \u2190 px\n```\n\nThe advantage of having four completely segregated (note that there is no mix round, so they\u2019re entirely independent) states is that fast parallelism is possible. For example, if I were to hash 1 TB, I can spawn up four threads which can run independently without _any_ intercommunication or synchronization before the last round.\nIf the diffusion function (f) was cryptographically secure, it would pass cryptoanalysis trivially. This might seem irrelevant, as it clearly isn\u2019t cryptographically secure, but it tells us something about the inner semantics. In particular, any diffusion function with sufficient statistical quality will make up a good hash function in this construction.\nRead the blog post\u27e812\u27e9 for more details.\n## \u00a7\u27e813\u27e9ASIC version\nSeaHash is specifically designed such that it can be efficiently implemented in the form of ASIC while only using very few transistors.\n## \u00a7\u27e814\u27e9Specification\nSee the `reference`\u27e815\u27e9 module.\n## \u00a7\u27e816\u27e9Credits\nAside for myself (@ticki), there are couple of other people who have helped creating this. Joshua Landau suggested using the PCG family of diffusions\u27e817\u27e9, created by Melissa E. O\u2019Neill. Sokolov Yura spotted multiple bugs in SeaHash.\n## Modules\u00a7\u27e818\u27e9\n\nreference\u27e819\u27e9\n    A slow, but clear reference implementation of SeaHash.\n## Structs\u00a7\u27e820\u27e9\n\nSeaHasher\u27e821\u27e9\n    The streaming version of the algorithm.\n\nState\u27e822\u27e9\n    A SeaHash state.\n## Functions\u00a7\u27e823\u27e9\n\nhash\u27e824\u27e9\n    Hash some buffer.\n\nhash_seeded\u27e825\u27e9\n    Hash some buffer according to a chosen seed.\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/seahash/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/seahash/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/seahash/latest/src/seahash/lib.rs.html#1-168: Source\n\u27e84\u27e9 https://docs.rs/seahash/latest/seahash/#design-advantages-and-features: \u00a7\n\u27e85\u27e9 https://docs.rs/seahash/latest/seahash/#a-word-of-warning: \u00a7\n\u27e86\u27e9 https://docs.rs/seahash/latest/seahash/#benchmark: \u00a7\n\u27e87\u27e9 https://docs.rs/seahash/latest/seahash/#ideal-architecture: \u00a7\n\u27e88\u27e9 https://docs.rs/seahash/latest/seahash/#achieving-the-performance: \u00a7\n\u27e89\u27e9 https://docs.rs/seahash/latest/seahash/#statistical-guarantees: \u00a7\n\u27e810\u27e9 https://docs.rs/seahash/latest/seahash/#inner-workings: \u00a7\n\u27e811\u27e9 http://ticki.github.io/img/seahash_construction_diagram.svg: ![A diagram.\n\u27e812\u27e9 http://ticki.github.io/blog/seahash-explained/: the blog post\n\u27e813\u27e9 https://docs.rs/seahash/latest/seahash/#asic-version: \u00a7\n\u27e814\u27e9 https://docs.rs/seahash/latest/seahash/#specification: \u00a7\n\u27e815\u27e9 https://docs.rs/seahash/latest/seahash/reference: `reference`\n\u27e816\u27e9 https://docs.rs/seahash/latest/seahash/#credits: \u00a7\n\u27e817\u27e9 http://www.pcg-random.org/: PCG family of diffusions\n\u27e818\u27e9 https://docs.rs/seahash/latest/seahash/#modules: \u00a7\n\u27e819\u27e9 https://docs.rs/seahash/latest/seahash/reference/index.html: mod seahash::reference - reference\n\u27e820\u27e9 https://docs.rs/seahash/latest/seahash/#structs: \u00a7\n\u27e821\u27e9 https://docs.rs/seahash/latest/seahash/struct.SeaHasher.html: struct seahash::SeaHasher - SeaHasher\n\u27e822\u27e9 https://docs.rs/seahash/latest/seahash/struct.State.html: struct seahash::State - State\n\u27e823\u27e9 https://docs.rs/seahash/latest/seahash/#functions: \u00a7\n\u27e824\u27e9 https://docs.rs/seahash/latest/seahash/fn.hash.html: fn seahash::hash - hash\n\u27e825\u27e9 https://docs.rs/seahash/latest/seahash/fn.hash_seeded.html: fn seahash::hash_seeded - hash_seeded\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `seahash` crate provides a blazingly fast, portable, and high-quality non-cryptographic hash function with proven statistical guarantees. It offers superior performance compared to popular alternatives like xxHash and MetroHash, supports parallelism, bulk reads, and stable architecture-independent outputs suitable for permanent storage. While not cryptographically secure, it is designed for efficiency, with features like keyed hashing, hardware acceleration, and optimized performance on modern architectures.",
    "feature_summary": null,
    "use_case": "Utilities",
    "score": 6.0,
    "factual_counterfactual": "### Pair 1: Performance Characteristics  \n\u2705 **Factual:** SeaHash achieves a hashing rate of approximately 5.9\u20136.7 GB/s on a 2.5 GHz CPU, outperforming other high-quality hash functions like xxHash and MetroHash by 3\u201320%.  \n\u274c **Counterfactual:** SeaHash achieves a hashing rate of approximately 10 GB/s on a 2.5 GHz CPU, making it the fastest hash function available for general-purpose use.  \n\n---\n\n### Pair 2: Cryptographic Security  \n\u2705 **Factual:** SeaHash is explicitly not a cryptographic hash function and should not be used for security-critical applications; it is optimized for high-quality pseudorandom output and low collision rates.  \n\u274c **Counterfactual:** SeaHash has undergone rigorous cryptoanalysis and is suitable for cryptographic use cases, such as secure password hashing or digital signatures.  \n\n---\n\n### Pair 3: Parallelism and Architecture  \n\u2705 **Factual:** SeaHash is designed with four independent states that enable efficient parallelism, allowing hashing of large buffers (e.g., 1 TB) across multiple threads without intercommunication or synchronization.  \n\u274c **Counterfactual:** SeaHash relies on a single-threaded design and does not support parallelism, making it unsuitable for hashing large buffers efficiently.",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}