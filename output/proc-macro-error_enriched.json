{
    "name": "proc-macro-error",
    "version": "1.0.4",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/proc-macro-error/latest/proc_macro_error/all.html \"show sidebar\")\n# Crate proc_macro_errorCopy item path\n[Settings](https://docs.rs/proc-macro-error/latest/settings.html)\n[Help](https://docs.rs/proc-macro-error/latest/help.html)\nSummary[Source](https://docs.rs/proc-macro-error/latest/src/proc_macro_error/lib.rs.html#1-560)\nExpand description\n## [\u00a7](https://docs.rs/proc-macro-error/latest/proc_macro_error/#proc-macro-error)proc-macro-error\nThis crate aims to make error reporting in proc-macros simple and easy to use. Migrate from `panic!`-based errors for as little effort as possible!\n(Also, you can explicitly [append a dummy token stream](https://docs.rs/proc-macro-error/latest/proc_macro_error/dummy/index.html) to your errors).\nTo achieve his, this crate serves as a tiny shim around `proc_macro::Diagnostic` and `compile_error!`. It detects the best way of emitting available based on compiler\u2019s version. When the underlying diagnostic type is finally stabilized, this crate will simply be delegating to it requiring no changes in your code!\nSo you can just use this crate and have _both_ some of `proc_macro::Diagnostic` functionality available on stable ahead of time _and_ your error-reporting code future-proof.\n### [\u00a7](https://docs.rs/proc-macro-error/latest/proc_macro_error/#cargo-features)Cargo features\nThis crate provides _enabled by default_ `syn-error` feature that gates `impl From<syn::Error> for Diagnostic` conversion. If you don\u2019t use `syn` and want to cut off some of compilation time, you can disable it via\n```\n[dependencies]\nproc-macro-error = { version = \"1\", default-features = false }\n```\n\n* **Please note that disabling this feature makes sense only if you don\u2019t depend on`syn` directly or indirectly, and you very likely do.**\n### [\u00a7](https://docs.rs/proc-macro-error/latest/proc_macro_error/#real-world-examples)Real world examples\n  * [`structopt-derive`](https://github.com/TeXitoi/structopt/tree/master/structopt-derive) (abort-like usage)\n  * [`auto-impl`](https://github.com/auto-impl-rs/auto_impl/) (emit-like usage)\n\n\n### [\u00a7](https://docs.rs/proc-macro-error/latest/proc_macro_error/#limitations)Limitations\n  * Warnings are emitted only on nightly, they are ignored on stable.\n  * \u201chelp\u201d suggestions can\u2019t have their own span info on stable, (essentially inheriting the parent span).\n  * If a panic occurs somewhere in your macro no errors will be displayed. This is not a technical limitation but rather intentional design. `panic` is not for error reporting.\n\n\n#### [\u00a7](https://docs.rs/proc-macro-error/latest/proc_macro_error/#proc_macro_error-attribute)`#[proc_macro_error]` attribute\n**This attribute MUST be present on the top level of your macro** (the function annotated with any of `#[proc_macro]`, `#[proc_macro_derive]`, `#[proc_macro_attribute]`).\nThis attribute performs the setup and cleanup necessary to make things work.\nIn most cases you\u2019ll need the simple `#[proc_macro_error]` form without any additional settings. Feel free to [skip the \u201cSyntax\u201d section](https://docs.rs/proc-macro-error/latest/proc_macro_error/#macros).\n##### [\u00a7](https://docs.rs/proc-macro-error/latest/proc_macro_error/#syntax)Syntax\n`#[proc_macro_error]` or `#[proc_macro_error(settings...)]`, where `settings...` is a comma-separated list of:\n  * `proc_macro_hack`:\nIn order to correctly cooperate with `#[proc_macro_hack]`, `#[proc_macro_error]` attribute must be placed _before_ (above) it, like this:\n```\n#[proc_macro_error]\n#[proc_macro_hack]\n#[proc_macro]\nfn my_macro(input: TokenStream) -> TokenStream {\n  unimplemented!()\n}\n```\n\nIf, for some reason, you can\u2019t place it like that you can use `#[proc_macro_error(proc_macro_hack)]` instead.\n## [\u00a7](https://docs.rs/proc-macro-error/latest/proc_macro_error/#note)Note\nIf `proc-macro-hack` was detected (by any means) `allow_not_macro` and `assert_unwind_safe` will be applied automatically.\n  * `allow_not_macro`:\nBy default, the attribute checks that it\u2019s applied to a proc-macro. If none of `#[proc_macro]`, `#[proc_macro_derive]` nor `#[proc_macro_attribute]` are present it will panic. It\u2019s the intention - this crate is supposed to be used only with proc-macros.\nThis setting is made to bypass the check, useful in certain circumstances.\nPay attention: the function this attribute is applied to must return `proc_macro::TokenStream`.\nThis setting is implied if `proc-macro-hack` was detected.\n  * `assert_unwind_safe`:\nBy default, your code must be [unwind safe](https://doc.rust-lang.org/std/panic/trait.UnwindSafe.html#what-is-unwind-safety). If your code is not unwind safe, but you believe it\u2019s correct, you can use this setting to bypass the check. You would need this for code that uses `lazy_static` or `thread_local` with `Cell/RefCell` inside (and the like).\nThis setting is implied if `#[proc_macro_error]` is applied to a function marked as `#[proc_macro]`, `#[proc_macro_derive]` or `#[proc_macro_attribute]`.\nThis setting is also implied if `proc-macro-hack` was detected.\n\n\n### [\u00a7](https://docs.rs/proc-macro-error/latest/proc_macro_error/#macros)Macros\nMost of the time you want to use the macros. Syntax is described in the next section below.\nYou\u2019ll need to decide how you want to emit errors:\n  * Emit the error and abort. Very much panic-like usage. Served by [`abort!`](https://docs.rs/proc-macro-error/latest/proc_macro_error/macro.abort.html) and [`abort_call_site!`](https://docs.rs/proc-macro-error/latest/proc_macro_error/macro.abort_call_site.html).\n  * Emit the error but do not abort right away, looking for other errors to report. Served by [`emit_error!`](https://docs.rs/proc-macro-error/latest/proc_macro_error/macro.emit_error.html) and [`emit_call_site_error!`](https://docs.rs/proc-macro-error/latest/proc_macro_error/macro.emit_call_site_warning.html).\n\n\nYou **can** mix these usages.\n`abort` and `emit_error` take a \u201csource span\u201d as the first argument. This source will be used to highlight the place the error originates from. It must be one of:\n  * _Something_ that implements [`ToTokens`](https://docs.rs/quote/1.0.3/quote/trait.ToTokens.html) (most types in `syn` and `proc-macro2` do). This source is the preferable one since it doesn\u2019t lose span information on multi-token spans, see [this issue](https://gitlab.com/CreepySkeleton/proc-macro-error/-/issues/6) for details.\n  * [`proc_macro::Span`](https://doc.rust-lang.org/proc_macro/struct.Span.html)\n  * [`proc-macro2::Span`](https://docs.rs/proc-macro2/1.0.10/proc_macro2/struct.Span.html)\n\n\nThe rest is your message in format-like style.\nSee [the next section](https://docs.rs/proc-macro-error/latest/proc_macro_error/#syntax-1) for detailed syntax.\n  * [`abort!`](https://docs.rs/proc-macro-error/latest/proc_macro_error/macro.abort.html):\nVery much panic-like usage - abort right away and show the error. Expands to [`!`](https://doc.rust-lang.org/std/primitive.never.html) (never type).\n  * [`abort_call_site!`](https://docs.rs/proc-macro-error/latest/proc_macro_error/macro.abort_call_site.html):\nShortcut for `abort!(Span::call_site(), ...)`. Expands to [`!`](https://doc.rust-lang.org/std/primitive.never.html) (never type).\n  * [`emit_error!`](https://docs.rs/proc-macro-error/latest/proc_macro_error/macro.emit_error.html):\n[`proc_macro::Diagnostic`](https://doc.rust-lang.org/proc_macro/struct.Diagnostic.html)-like usage - emit the error but keep going, looking for other errors to report. The compilation will fail nonetheless. Expands to [`()`](https://doc.rust-lang.org/std/primitive.unit.html) (unit type).\n  * [`emit_call_site_error!`](https://docs.rs/proc-macro-error/latest/proc_macro_error/macro.emit_call_site_warning.html):\nShortcut for `emit_error!(Span::call_site(), ...)`. Expands to [`()`](https://doc.rust-lang.org/std/primitive.unit.html) (unit type).\n  * [`emit_warning!`](https://docs.rs/proc-macro-error/latest/proc_macro_error/macro.emit_warning.html):\nLike `emit_error!` but emit a warning instead of error. The compilation won\u2019t fail because of warnings. Expands to [`()`](https://doc.rust-lang.org/std/primitive.unit.html) (unit type).\n**Beware** : warnings are nightly only, they are completely ignored on stable.\n  * [`emit_call_site_warning!`](https://docs.rs/proc-macro-error/latest/proc_macro_error/macro.emit_call_site_error.html):\nShortcut for `emit_warning!(Span::call_site(), ...)`. Expands to [`()`](https://doc.rust-lang.org/std/primitive.unit.html) (unit type).\n  * [`diagnostic`](https://docs.rs/proc-macro-error/latest/proc_macro_error/struct.Diagnostic.html):\nBuild an instance of `Diagnostic` in format-like style.\n\n\n##### [\u00a7](https://docs.rs/proc-macro-error/latest/proc_macro_error/#syntax-1)Syntax\nAll the macros have pretty much the same syntax:\n  1. [\u24d8](https://docs.rs/proc-macro-error/latest/proc_macro_error/ \"This example is not tested\")```\nabort!(single_expr)\n```\n\nShortcut for `Diagnostic::from(expr).abort()`.\n  2. [\u24d8](https://docs.rs/proc-macro-error/latest/proc_macro_error/ \"This example is not tested\")```\nabort!(span, message)\n```\n\nThe first argument is an expression the span info should be taken from.\nThe second argument is the error message, it must implement [`ToString`](https://doc.rust-lang.org/std/string/trait.ToString.html).\n  3. [\u24d8](https://docs.rs/proc-macro-error/latest/proc_macro_error/ \"This example is not tested\")```\nabort!(span, format_literal, format_args...)\n```\n\nThis form is pretty much the same as 2, except `format!(format_literal, format_args...)` will be used to for the message instead of [`ToString`](https://doc.rust-lang.org/std/string/trait.ToString.html).\n\n\nThat\u2019s it. `abort!`, `emit_warning`, `emit_error` share this exact syntax.\n`abort_call_site!`, `emit_call_site_warning`, `emit_call_site_error` lack 1 form and do not take span in 2\u2019th and 3\u2019th forms. Those are essentially shortcuts for `macro!(Span::call_site(), args...)`.\n`diagnostic!` requires a [`Level`](https://docs.rs/proc-macro-error/latest/proc_macro_error/enum.Level.html \"enum proc_macro_error::Level\") instance between `span` and second argument (1\u2019th form is the same).\n> **Important!**\n> If you have some type from `proc_macro` or `syn` to point to, do not call `.span()` on it but rather use it directly:\n> ```\nlet ty: syn::Type = syn::parse2(input).unwrap();\nabort!(ty, \"BOOM\");\n//   ^^ <-- avoid .span()\n```\n\n> `.span()` calls work too, but you may experience regressions in message quality.\n##### [\u00a7](https://docs.rs/proc-macro-error/latest/proc_macro_error/#note-attachments)Note attachments\n  1. Every macro can have \u201cnote\u201d attachments (only 2 and 3 form).\n\n\n[\u24d8](https://docs.rs/proc-macro-error/latest/proc_macro_error/ \"This example is not tested\")```\nlet opt_help = if have_some_info { Some(\"did you mean `this`?\") } else { None };\nabort!(\n  span, message; // <--- attachments start with `;` (semicolon)\n  help = \"format {} {}\", \"arg1\", \"arg2\"; // <--- every attachment ends with `;`,\n                      //   maybe except the last one\n  note = \"to_string\"; // <--- one arg uses `.to_string()` instead of `format!()`\n  yay = \"I see what {} did here\", \"you\"; // <--- \"help =\" and \"hint =\" are mapped\n                      // to Diagnostic::help,\n                      // anything else is Diagnostic::note\n  wow = note_span => \"custom span\"; // <--- attachments can have their own span\n                   //   it takes effect only on nightly though\n  hint =? opt_help; // <-- \"optional\" attachment, get displayed only if `Some`\n           //   must be single `Option` expression\n  note =? note_span => opt_help // <-- optional attachments can have custom spans too\n);\n```\n\n#### [\u00a7](https://docs.rs/proc-macro-error/latest/proc_macro_error/#diagnostic-type)Diagnostic type\n[`Diagnostic`](https://docs.rs/proc-macro-error/latest/proc_macro_error/struct.Diagnostic.html) type is intentionally designed to be API compatible with [`proc_macro::Diagnostic`](https://doc.rust-lang.org/proc_macro/struct.Diagnostic.html). Not all API is implemented, only the part that can be reasonably implemented on stable.\n## Re-exports[\u00a7](https://docs.rs/proc-macro-error/latest/proc_macro_error/#reexports)\n\n`pub use crate::dummy::append_dummy[](https://docs.rs/proc-macro-error/latest/proc_macro_error/dummy/fn.append_dummy.html \"fn proc_macro_error::dummy::append_dummy\");`\n\n\n`pub use crate::dummy::set_dummy[](https://docs.rs/proc-macro-error/latest/proc_macro_error/dummy/fn.set_dummy.html \"fn proc_macro_error::dummy::set_dummy\");`\n\n## Modules[\u00a7](https://docs.rs/proc-macro-error/latest/proc_macro_error/#modules)\n\n[dummy](https://docs.rs/proc-macro-error/latest/proc_macro_error/dummy/index.html \"mod proc_macro_error::dummy\")\n    Facility to emit dummy implementations (or whatever) in case an error happen.\n## Macros[\u00a7](https://docs.rs/proc-macro-error/latest/proc_macro_error/#macros-1)\n\n[abort](https://docs.rs/proc-macro-error/latest/proc_macro_error/macro.abort.html \"macro proc_macro_error::abort\")\n    Abort proc-macro execution right now and display the error.\n\n[abort_call_site](https://docs.rs/proc-macro-error/latest/proc_macro_error/macro.abort_call_site.html \"macro proc_macro_error::abort_call_site\")\n    Shortcut for `abort!(Span::call_site(), msg...)`. This macro is still preferable over plain panic, panics are not for error reporting.\n\n[diagnostic](https://docs.rs/proc-macro-error/latest/proc_macro_error/macro.diagnostic.html \"macro proc_macro_error::diagnostic\")\n    Build [`Diagnostic`](https://docs.rs/proc-macro-error/latest/proc_macro_error/struct.Diagnostic.html) instance from provided arguments.\n\n[emit_call_site_error](https://docs.rs/proc-macro-error/latest/proc_macro_error/macro.emit_call_site_error.html \"macro proc_macro_error::emit_call_site_error\")\n    Shortcut for `emit_error!(Span::call_site(), ...)`. This macro is still preferable over plain panic, panics are not for error reporting..\n\n[emit_call_site_warning](https://docs.rs/proc-macro-error/latest/proc_macro_error/macro.emit_call_site_warning.html \"macro proc_macro_error::emit_call_site_warning\")\n    Shortcut for `emit_warning!(Span::call_site(), ...)`.\n\n[emit_error](https://docs.rs/proc-macro-error/latest/proc_macro_error/macro.emit_error.html \"macro proc_macro_error::emit_error\")\n    Emit an error while not aborting the proc-macro right away.\n\n[emit_warning](https://docs.rs/proc-macro-error/latest/proc_macro_error/macro.emit_warning.html \"macro proc_macro_error::emit_warning\")\n    Emit a warning. Warnings are not errors and compilation won\u2019t fail because of them.\n## Structs[\u00a7](https://docs.rs/proc-macro-error/latest/proc_macro_error/#structs)\n\n[Diagnostic](https://docs.rs/proc-macro-error/latest/proc_macro_error/struct.Diagnostic.html \"struct proc_macro_error::Diagnostic\")\n    Represents a single diagnostic message\n\n[SpanRange](https://docs.rs/proc-macro-error/latest/proc_macro_error/struct.SpanRange.html \"struct proc_macro_error::SpanRange\")\n\n## Enums[\u00a7](https://docs.rs/proc-macro-error/latest/proc_macro_error/#enums)\n\n[Level](https://docs.rs/proc-macro-error/latest/proc_macro_error/enum.Level.html \"enum proc_macro_error::Level\")\n    Represents a diagnostic level\n## Traits[\u00a7](https://docs.rs/proc-macro-error/latest/proc_macro_error/#traits)\n\n[DiagnosticExt](https://docs.rs/proc-macro-error/latest/proc_macro_error/trait.DiagnosticExt.html \"trait proc_macro_error::DiagnosticExt\")\n    A collection of methods that do not exist in `proc_macro::Diagnostic` but still useful to have around.\n\n[OptionExt](https://docs.rs/proc-macro-error/latest/proc_macro_error/trait.OptionExt.html \"trait proc_macro_error::OptionExt\")\n    This traits expands `Option` with some handy shortcuts.\n\n[ResultExt](https://docs.rs/proc-macro-error/latest/proc_macro_error/trait.ResultExt.html \"trait proc_macro_error::ResultExt\")\n    This traits expands `Result<T, Into<Diagnostic>>` with some handy shortcuts.\n## Functions[\u00a7](https://docs.rs/proc-macro-error/latest/proc_macro_error/#functions)\n\n[abort_if_dirty](https://docs.rs/proc-macro-error/latest/proc_macro_error/fn.abort_if_dirty.html \"fn proc_macro_error::abort_if_dirty\")\n    Abort macro execution and display all the emitted errors, if any.\n## Attribute Macros[\u00a7](https://docs.rs/proc-macro-error/latest/proc_macro_error/#attributes)\n\n[proc_macro_error](https://docs.rs/proc-macro-error/latest/proc_macro_error/attr.proc_macro_error.html \"attr proc_macro_error::proc_macro_error\")\n\n",
        "markdown_with_citations": "[](https://docs.rs/proc-macro-error/latest/proc_macro_error/all.html \"show sidebar\")\n# Crate proc_macro_errorCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\n## \u00a7\u27e84\u27e9proc-macro-error\nThis crate aims to make error reporting in proc-macros simple and easy to use. Migrate from `panic!`-based errors for as little effort as possible!\n(Also, you can explicitly append a dummy token stream\u27e85\u27e9 to your errors).\nTo achieve his, this crate serves as a tiny shim around `proc_macro::Diagnostic` and `compile_error!`. It detects the best way of emitting available based on compiler\u2019s version. When the underlying diagnostic type is finally stabilized, this crate will simply be delegating to it requiring no changes in your code!\nSo you can just use this crate and have _both_ some of `proc_macro::Diagnostic` functionality available on stable ahead of time _and_ your error-reporting code future-proof.\n### \u00a7\u27e86\u27e9Cargo features\nThis crate provides _enabled by default_ `syn-error` feature that gates `impl From<syn::Error> for Diagnostic` conversion. If you don\u2019t use `syn` and want to cut off some of compilation time, you can disable it via\n```\n[dependencies]\nproc-macro-error = { version = \"1\", default-features = false }\n```\n\n* **Please note that disabling this feature makes sense only if you don\u2019t depend on`syn` directly or indirectly, and you very likely do.**\n### \u00a7\u27e87\u27e9Real world examples\n  * `structopt-derive`\u27e88\u27e9 (abort-like usage)\n  * `auto-impl`\u27e89\u27e9 (emit-like usage)\n\n\n### \u00a7\u27e810\u27e9Limitations\n  * Warnings are emitted only on nightly, they are ignored on stable.\n  * \u201chelp\u201d suggestions can\u2019t have their own span info on stable, (essentially inheriting the parent span).\n  * If a panic occurs somewhere in your macro no errors will be displayed. This is not a technical limitation but rather intentional design. `panic` is not for error reporting.\n\n\n#### \u00a7\u27e811\u27e9`#[proc_macro_error]` attribute\n**This attribute MUST be present on the top level of your macro** (the function annotated with any of `#[proc_macro]`, `#[proc_macro_derive]`, `#[proc_macro_attribute]`).\nThis attribute performs the setup and cleanup necessary to make things work.\nIn most cases you\u2019ll need the simple `#[proc_macro_error]` form without any additional settings. Feel free to skip the \u201cSyntax\u201d section\u27e812\u27e9.\n##### \u00a7\u27e813\u27e9Syntax\n`#[proc_macro_error]` or `#[proc_macro_error(settings...)]`, where `settings...` is a comma-separated list of:\n  * `proc_macro_hack`:\nIn order to correctly cooperate with `#[proc_macro_hack]`, `#[proc_macro_error]` attribute must be placed _before_ (above) it, like this:\n```\n#[proc_macro_error]\n#[proc_macro_hack]\n#[proc_macro]\nfn my_macro(input: TokenStream) -> TokenStream {\n  unimplemented!()\n}\n```\n\nIf, for some reason, you can\u2019t place it like that you can use `#[proc_macro_error(proc_macro_hack)]` instead.\n## \u00a7\u27e814\u27e9Note\nIf `proc-macro-hack` was detected (by any means) `allow_not_macro` and `assert_unwind_safe` will be applied automatically.\n  * `allow_not_macro`:\nBy default, the attribute checks that it\u2019s applied to a proc-macro. If none of `#[proc_macro]`, `#[proc_macro_derive]` nor `#[proc_macro_attribute]` are present it will panic. It\u2019s the intention - this crate is supposed to be used only with proc-macros.\nThis setting is made to bypass the check, useful in certain circumstances.\nPay attention: the function this attribute is applied to must return `proc_macro::TokenStream`.\nThis setting is implied if `proc-macro-hack` was detected.\n  * `assert_unwind_safe`:\nBy default, your code must be unwind safe\u27e815\u27e9. If your code is not unwind safe, but you believe it\u2019s correct, you can use this setting to bypass the check. You would need this for code that uses `lazy_static` or `thread_local` with `Cell/RefCell` inside (and the like).\nThis setting is implied if `#[proc_macro_error]` is applied to a function marked as `#[proc_macro]`, `#[proc_macro_derive]` or `#[proc_macro_attribute]`.\nThis setting is also implied if `proc-macro-hack` was detected.\n\n\n### \u00a7\u27e812\u27e9Macros\nMost of the time you want to use the macros. Syntax is described in the next section below.\nYou\u2019ll need to decide how you want to emit errors:\n  * Emit the error and abort. Very much panic-like usage. Served by `abort!`\u27e816\u27e9 and `abort_call_site!`\u27e817\u27e9.\n  * Emit the error but do not abort right away, looking for other errors to report. Served by `emit_error!`\u27e818\u27e9 and `emit_call_site_error!`\u27e819\u27e9.\n\n\nYou **can** mix these usages.\n`abort` and `emit_error` take a \u201csource span\u201d as the first argument. This source will be used to highlight the place the error originates from. It must be one of:\n  * _Something_ that implements `ToTokens`\u27e820\u27e9 (most types in `syn` and `proc-macro2` do). This source is the preferable one since it doesn\u2019t lose span information on multi-token spans, see this issue\u27e821\u27e9 for details.\n  * `proc_macro::Span`\u27e822\u27e9\n  * `proc-macro2::Span`\u27e823\u27e9\n\n\nThe rest is your message in format-like style.\nSee the next section\u27e824\u27e9 for detailed syntax.\n  * `abort!`\u27e816\u27e9:\nVery much panic-like usage - abort right away and show the error. Expands to `!`\u27e825\u27e9 (never type).\n  * `abort_call_site!`\u27e817\u27e9:\nShortcut for `abort!(Span::call_site(), ...)`. Expands to `!`\u27e825\u27e9 (never type).\n  * `emit_error!`\u27e818\u27e9:\n`proc_macro::Diagnostic`\u27e826\u27e9-like usage - emit the error but keep going, looking for other errors to report. The compilation will fail nonetheless. Expands to `()`\u27e827\u27e9 (unit type).\n  * `emit_call_site_error!`\u27e819\u27e9:\nShortcut for `emit_error!(Span::call_site(), ...)`. Expands to `()`\u27e827\u27e9 (unit type).\n  * `emit_warning!`\u27e828\u27e9:\nLike `emit_error!` but emit a warning instead of error. The compilation won\u2019t fail because of warnings. Expands to `()`\u27e827\u27e9 (unit type).\n**Beware** : warnings are nightly only, they are completely ignored on stable.\n  * `emit_call_site_warning!`\u27e829\u27e9:\nShortcut for `emit_warning!(Span::call_site(), ...)`. Expands to `()`\u27e827\u27e9 (unit type).\n  * `diagnostic`\u27e830\u27e9:\nBuild an instance of `Diagnostic` in format-like style.\n\n\n##### \u00a7\u27e824\u27e9Syntax\nAll the macros have pretty much the same syntax:\n  1. \u24d8\u27e831\u27e9```\nabort!(single_expr)\n```\n\nShortcut for `Diagnostic::from(expr).abort()`.\n  2. \u24d8\u27e831\u27e9```\nabort!(span, message)\n```\n\nThe first argument is an expression the span info should be taken from.\nThe second argument is the error message, it must implement `ToString`\u27e832\u27e9.\n  3. \u24d8\u27e831\u27e9```\nabort!(span, format_literal, format_args...)\n```\n\nThis form is pretty much the same as 2, except `format!(format_literal, format_args...)` will be used to for the message instead of `ToString`\u27e832\u27e9.\n\n\nThat\u2019s it. `abort!`, `emit_warning`, `emit_error` share this exact syntax.\n`abort_call_site!`, `emit_call_site_warning`, `emit_call_site_error` lack 1 form and do not take span in 2\u2019th and 3\u2019th forms. Those are essentially shortcuts for `macro!(Span::call_site(), args...)`.\n`diagnostic!` requires a `Level`\u27e833\u27e9 instance between `span` and second argument (1\u2019th form is the same).\n> **Important!**\n> If you have some type from `proc_macro` or `syn` to point to, do not call `.span()` on it but rather use it directly:\n> ```\nlet ty: syn::Type = syn::parse2(input).unwrap();\nabort!(ty, \"BOOM\");\n//   ^^ <-- avoid .span()\n```\n\n> `.span()` calls work too, but you may experience regressions in message quality.\n##### \u00a7\u27e834\u27e9Note attachments\n  1. Every macro can have \u201cnote\u201d attachments (only 2 and 3 form).\n\n\n\u24d8\u27e831\u27e9```\nlet opt_help = if have_some_info { Some(\"did you mean `this`?\") } else { None };\nabort!(\n  span, message; // <--- attachments start with `;` (semicolon)\n  help = \"format {} {}\", \"arg1\", \"arg2\"; // <--- every attachment ends with `;`,\n                      //   maybe except the last one\n  note = \"to_string\"; // <--- one arg uses `.to_string()` instead of `format!()`\n  yay = \"I see what {} did here\", \"you\"; // <--- \"help =\" and \"hint =\" are mapped\n                      // to Diagnostic::help,\n                      // anything else is Diagnostic::note\n  wow = note_span => \"custom span\"; // <--- attachments can have their own span\n                   //   it takes effect only on nightly though\n  hint =? opt_help; // <-- \"optional\" attachment, get displayed only if `Some`\n           //   must be single `Option` expression\n  note =? note_span => opt_help // <-- optional attachments can have custom spans too\n);\n```\n\n#### \u00a7\u27e835\u27e9Diagnostic type\n`Diagnostic`\u27e830\u27e9 type is intentionally designed to be API compatible with `proc_macro::Diagnostic`\u27e826\u27e9. Not all API is implemented, only the part that can be reasonably implemented on stable.\n## Re-exports\u00a7\u27e836\u27e9\n\n`pub use crate::dummy::append_dummy[](https://docs.rs/proc-macro-error/latest/proc_macro_error/dummy/fn.append_dummy.html \"fn proc_macro_error::dummy::append_dummy\");`\n\n\n`pub use crate::dummy::set_dummy[](https://docs.rs/proc-macro-error/latest/proc_macro_error/dummy/fn.set_dummy.html \"fn proc_macro_error::dummy::set_dummy\");`\n\n## Modules\u00a7\u27e837\u27e9\n\ndummy\u27e85\u27e9\n    Facility to emit dummy implementations (or whatever) in case an error happen.\n## Macros\u00a7\u27e838\u27e9\n\nabort\u27e816\u27e9\n    Abort proc-macro execution right now and display the error.\n\nabort_call_site\u27e817\u27e9\n    Shortcut for `abort!(Span::call_site(), msg...)`. This macro is still preferable over plain panic, panics are not for error reporting.\n\ndiagnostic\u27e839\u27e9\n    Build `Diagnostic`\u27e830\u27e9 instance from provided arguments.\n\nemit_call_site_error\u27e829\u27e9\n    Shortcut for `emit_error!(Span::call_site(), ...)`. This macro is still preferable over plain panic, panics are not for error reporting..\n\nemit_call_site_warning\u27e819\u27e9\n    Shortcut for `emit_warning!(Span::call_site(), ...)`.\n\nemit_error\u27e818\u27e9\n    Emit an error while not aborting the proc-macro right away.\n\nemit_warning\u27e828\u27e9\n    Emit a warning. Warnings are not errors and compilation won\u2019t fail because of them.\n## Structs\u00a7\u27e840\u27e9\n\nDiagnostic\u27e830\u27e9\n    Represents a single diagnostic message\n\nSpanRange\u27e841\u27e9\n\n## Enums\u00a7\u27e842\u27e9\n\nLevel\u27e833\u27e9\n    Represents a diagnostic level\n## Traits\u00a7\u27e843\u27e9\n\nDiagnosticExt\u27e844\u27e9\n    A collection of methods that do not exist in `proc_macro::Diagnostic` but still useful to have around.\n\nOptionExt\u27e845\u27e9\n    This traits expands `Option` with some handy shortcuts.\n\nResultExt\u27e846\u27e9\n    This traits expands `Result<T, Into<Diagnostic>>` with some handy shortcuts.\n## Functions\u00a7\u27e847\u27e9\n\nabort_if_dirty\u27e848\u27e9\n    Abort macro execution and display all the emitted errors, if any.\n## Attribute Macros\u00a7\u27e849\u27e9\n\nproc_macro_error\u27e850\u27e9\n\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/proc-macro-error/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/proc-macro-error/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/proc-macro-error/latest/src/proc_macro_error/lib.rs.html#1-560: Source\n\u27e84\u27e9 https://docs.rs/proc-macro-error/latest/proc_macro_error/#proc-macro-error: \u00a7\n\u27e85\u27e9 https://docs.rs/proc-macro-error/latest/proc_macro_error/dummy/index.html: append a dummy token stream\n\u27e86\u27e9 https://docs.rs/proc-macro-error/latest/proc_macro_error/#cargo-features: \u00a7\n\u27e87\u27e9 https://docs.rs/proc-macro-error/latest/proc_macro_error/#real-world-examples: \u00a7\n\u27e88\u27e9 https://github.com/TeXitoi/structopt/tree/master/structopt-derive: `structopt-derive`\n\u27e89\u27e9 https://github.com/auto-impl-rs/auto_impl/: `auto-impl`\n\u27e810\u27e9 https://docs.rs/proc-macro-error/latest/proc_macro_error/#limitations: \u00a7\n\u27e811\u27e9 https://docs.rs/proc-macro-error/latest/proc_macro_error/#proc_macro_error-attribute: \u00a7\n\u27e812\u27e9 https://docs.rs/proc-macro-error/latest/proc_macro_error/#macros: skip the \u201cSyntax\u201d section\n\u27e813\u27e9 https://docs.rs/proc-macro-error/latest/proc_macro_error/#syntax: \u00a7\n\u27e814\u27e9 https://docs.rs/proc-macro-error/latest/proc_macro_error/#note: \u00a7\n\u27e815\u27e9 https://doc.rust-lang.org/std/panic/trait.UnwindSafe.html#what-is-unwind-safety: unwind safe\n\u27e816\u27e9 https://docs.rs/proc-macro-error/latest/proc_macro_error/macro.abort.html: `abort!`\n\u27e817\u27e9 https://docs.rs/proc-macro-error/latest/proc_macro_error/macro.abort_call_site.html: `abort_call_site!`\n\u27e818\u27e9 https://docs.rs/proc-macro-error/latest/proc_macro_error/macro.emit_error.html: `emit_error!`\n\u27e819\u27e9 https://docs.rs/proc-macro-error/latest/proc_macro_error/macro.emit_call_site_warning.html: `emit_call_site_error!`\n\u27e820\u27e9 https://docs.rs/quote/1.0.3/quote/trait.ToTokens.html: `ToTokens`\n\u27e821\u27e9 https://gitlab.com/CreepySkeleton/proc-macro-error/-/issues/6: this issue\n\u27e822\u27e9 https://doc.rust-lang.org/proc_macro/struct.Span.html: `proc_macro::Span`\n\u27e823\u27e9 https://docs.rs/proc-macro2/1.0.10/proc_macro2/struct.Span.html: `proc-macro2::Span`\n\u27e824\u27e9 https://docs.rs/proc-macro-error/latest/proc_macro_error/#syntax-1: the next section\n\u27e825\u27e9 https://doc.rust-lang.org/std/primitive.never.html: `!`\n\u27e826\u27e9 https://doc.rust-lang.org/proc_macro/struct.Diagnostic.html: `proc_macro::Diagnostic`\n\u27e827\u27e9 https://doc.rust-lang.org/std/primitive.unit.html: `()`\n\u27e828\u27e9 https://docs.rs/proc-macro-error/latest/proc_macro_error/macro.emit_warning.html: `emit_warning!`\n\u27e829\u27e9 https://docs.rs/proc-macro-error/latest/proc_macro_error/macro.emit_call_site_error.html: `emit_call_site_warning!`\n\u27e830\u27e9 https://docs.rs/proc-macro-error/latest/proc_macro_error/struct.Diagnostic.html: `diagnostic`\n\u27e831\u27e9 https://docs.rs/proc-macro-error/latest/proc_macro_error/: This example is not tested - \u24d8\n\u27e832\u27e9 https://doc.rust-lang.org/std/string/trait.ToString.html: `ToString`\n\u27e833\u27e9 https://docs.rs/proc-macro-error/latest/proc_macro_error/enum.Level.html: enum proc_macro_error::Level - `Level`\n\u27e834\u27e9 https://docs.rs/proc-macro-error/latest/proc_macro_error/#note-attachments: \u00a7\n\u27e835\u27e9 https://docs.rs/proc-macro-error/latest/proc_macro_error/#diagnostic-type: \u00a7\n\u27e836\u27e9 https://docs.rs/proc-macro-error/latest/proc_macro_error/#reexports: \u00a7\n\u27e837\u27e9 https://docs.rs/proc-macro-error/latest/proc_macro_error/#modules: \u00a7\n\u27e838\u27e9 https://docs.rs/proc-macro-error/latest/proc_macro_error/#macros-1: \u00a7\n\u27e839\u27e9 https://docs.rs/proc-macro-error/latest/proc_macro_error/macro.diagnostic.html: macro proc_macro_error::diagnostic - diagnostic\n\u27e840\u27e9 https://docs.rs/proc-macro-error/latest/proc_macro_error/#structs: \u00a7\n\u27e841\u27e9 https://docs.rs/proc-macro-error/latest/proc_macro_error/struct.SpanRange.html: struct proc_macro_error::SpanRange - SpanRange\n\u27e842\u27e9 https://docs.rs/proc-macro-error/latest/proc_macro_error/#enums: \u00a7\n\u27e843\u27e9 https://docs.rs/proc-macro-error/latest/proc_macro_error/#traits: \u00a7\n\u27e844\u27e9 https://docs.rs/proc-macro-error/latest/proc_macro_error/trait.DiagnosticExt.html: trait proc_macro_error::DiagnosticExt - DiagnosticExt\n\u27e845\u27e9 https://docs.rs/proc-macro-error/latest/proc_macro_error/trait.OptionExt.html: trait proc_macro_error::OptionExt - OptionExt\n\u27e846\u27e9 https://docs.rs/proc-macro-error/latest/proc_macro_error/trait.ResultExt.html: trait proc_macro_error::ResultExt - ResultExt\n\u27e847\u27e9 https://docs.rs/proc-macro-error/latest/proc_macro_error/#functions: \u00a7\n\u27e848\u27e9 https://docs.rs/proc-macro-error/latest/proc_macro_error/fn.abort_if_dirty.html: fn proc_macro_error::abort_if_dirty - abort_if_dirty\n\u27e849\u27e9 https://docs.rs/proc-macro-error/latest/proc_macro_error/#attributes: \u00a7\n\u27e850\u27e9 https://docs.rs/proc-macro-error/latest/proc_macro_error/attr.proc_macro_error.html: attr proc_macro_error::proc_macro_error - proc_macro_error\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `proc-macro-error` crate simplifies error reporting in Rust procedural macros by providing a stable API for emitting diagnostics, replacing `panic!`-based errors. It supports macros like `abort!` and `emit_error!` for flexible error handling, integrates with `proc_macro::Diagnostic` and `compile_error!`, and ensures future-proof compatibility as diagnostics stabilize. Additional features include optional warnings (nightly-only), dummy token stream handling, and compatibility with `syn` via a configurable feature.",
    "feature_summary": null,
    "use_case": "DevTools",
    "score": 7.0,
    "factual_counterfactual": "### Pair 1: Error Reporting  \n\u2705 **Factual**: The `proc-macro-error` crate provides macros like `abort!` and `emit_error!` to simplify error reporting in procedural macros, allowing developers to emit errors without immediately aborting compilation.  \n\u274c **Counterfactual**: The `proc-macro-error` crate requires developers to manually implement error handling logic for procedural macros, as it does not provide built-in macros for error reporting.  \n\n---\n\n### Pair 2: Compatibility with Compiler Versions  \n\u2705 **Factual**: The crate automatically detects the best error emission method based on the compiler version, enabling compatibility with stable, beta, and nightly Rust compilers.  \n\u274c **Counterfactual**: The crate is only compatible with nightly Rust compilers and fails to work on stable or beta versions due to its reliance on unstable features.  \n\n---\n\n### Pair 3: Warnings and Limitations  \n\u2705 **Factual**: Warnings emitted by `proc-macro-error` are ignored on stable Rust compilers and only take effect on nightly builds.  \n\u274c **Counterfactual**: Warnings emitted by `proc-macro-error` are fully supported on stable Rust compilers and will halt compilation if not addressed.  \n\n---",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}