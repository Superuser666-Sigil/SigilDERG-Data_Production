{
    "name": "atomic",
    "version": "0.6.1",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/atomic/latest/atomic/all.html \"show sidebar\")\n# Crate atomicCopy item path\n[Settings](https://docs.rs/atomic/latest/settings.html)\n[Help](https://docs.rs/atomic/latest/help.html)\nSummary[Source](https://docs.rs/atomic/latest/src/atomic/lib.rs.html#8-829)\nExpand description\nGeneric `Atomic<T>` wrapper type\nAtomic types provide primitive shared-memory communication between threads, and are the building blocks of other concurrent types.\nThis library defines a generic atomic wrapper type `Atomic<T>` for all `T: NoUninit` types. Atomic types present operations that, when used correctly, synchronize updates between threads.\nThe `NoUninit` bound is from the [bytemuck](https://docs.rs/bytemuck) crate, and indicates that a type has no internal padding bytes. You will need to derive or implement this trait for all types used with `Atomic<T>`.\nEach method takes an `Ordering` which represents the strength of the memory barrier for that operation. These orderings are the same as [LLVM atomic orderings](http://llvm.org/docs/LangRef.html#memory-model-for-concurrent-operations).\nAtomic variables are safe to share between threads (they implement `Sync`) but they do not themselves provide the mechanism for sharing. The most common way to share an atomic variable is to put it into an `Arc` (an atomically-reference-counted shared pointer).\nMost atomic types may be stored in static variables, initialized using the `const fn` constructors. Atomic statics are often used for lazy global initialization.\n## Structs[\u00a7](https://docs.rs/atomic/latest/atomic/#structs)\n\n[Atomic](https://docs.rs/atomic/latest/atomic/struct.Atomic.html \"struct atomic::Atomic\")\n    A generic atomic wrapper type which allows an object to be safely shared between threads.\n## Enums[\u00a7](https://docs.rs/atomic/latest/atomic/#enums)\n\n[Ordering](https://docs.rs/atomic/latest/atomic/enum.Ordering.html \"enum atomic::Ordering\")\n    Atomic memory orderings\n## Functions[\u00a7](https://docs.rs/atomic/latest/atomic/#functions)\n\n[fence](https://docs.rs/atomic/latest/atomic/fn.fence.html \"fn atomic::fence\")\n    An atomic fence.\n",
        "markdown_with_citations": "[](https://docs.rs/atomic/latest/atomic/all.html \"show sidebar\")\n# Crate atomicCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nGeneric `Atomic<T>` wrapper type\nAtomic types provide primitive shared-memory communication between threads, and are the building blocks of other concurrent types.\nThis library defines a generic atomic wrapper type `Atomic<T>` for all `T: NoUninit` types. Atomic types present operations that, when used correctly, synchronize updates between threads.\nThe `NoUninit` bound is from the bytemuck\u27e84\u27e9 crate, and indicates that a type has no internal padding bytes. You will need to derive or implement this trait for all types used with `Atomic<T>`.\nEach method takes an `Ordering` which represents the strength of the memory barrier for that operation. These orderings are the same as LLVM atomic orderings\u27e85\u27e9.\nAtomic variables are safe to share between threads (they implement `Sync`) but they do not themselves provide the mechanism for sharing. The most common way to share an atomic variable is to put it into an `Arc` (an atomically-reference-counted shared pointer).\nMost atomic types may be stored in static variables, initialized using the `const fn` constructors. Atomic statics are often used for lazy global initialization.\n## Structs\u00a7\u27e86\u27e9\n\nAtomic\u27e87\u27e9\n    A generic atomic wrapper type which allows an object to be safely shared between threads.\n## Enums\u00a7\u27e88\u27e9\n\nOrdering\u27e89\u27e9\n    Atomic memory orderings\n## Functions\u00a7\u27e810\u27e9\n\nfence\u27e811\u27e9\n    An atomic fence.\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/atomic/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/atomic/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/atomic/latest/src/atomic/lib.rs.html#8-829: Source\n\u27e84\u27e9 https://docs.rs/bytemuck: bytemuck\n\u27e85\u27e9 http://llvm.org/docs/LangRef.html#memory-model-for-concurrent-operations: LLVM atomic orderings\n\u27e86\u27e9 https://docs.rs/atomic/latest/atomic/#structs: \u00a7\n\u27e87\u27e9 https://docs.rs/atomic/latest/atomic/struct.Atomic.html: struct atomic::Atomic - Atomic\n\u27e88\u27e9 https://docs.rs/atomic/latest/atomic/#enums: \u00a7\n\u27e89\u27e9 https://docs.rs/atomic/latest/atomic/enum.Ordering.html: enum atomic::Ordering - Ordering\n\u27e810\u27e9 https://docs.rs/atomic/latest/atomic/#functions: \u00a7\n\u27e811\u27e9 https://docs.rs/atomic/latest/atomic/fn.fence.html: fn atomic::fence - fence\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `atomic` crate provides a generic `Atomic<T>` wrapper type for thread-safe shared-memory communication, supporting all `T: NoUninit` types (from the `bytemuck` crate). It enables synchronized updates between threads using atomic operations with configurable memory orderings (aligned with LLVM atomic orderings). Key features include compatibility with `Arc` for sharing, `const fn` constructors for static initialization, and the `fence` function for atomic memory barriers.",
    "feature_summary": null,
    "use_case": "Utilities",
    "score": 4.0,
    "factual_counterfactual": "### Pair 1: Generic Atomic Wrapper Type  \n\u2705 Factual: The `atomic` crate provides a generic `Atomic<T>` wrapper type that supports all types implementing the `NoUninit` trait from the `bytemuck` crate, ensuring there are no internal padding bytes.  \n\u274c Counterfactual: The `atomic` crate allows any type, regardless of whether it implements the `NoUninit` trait, to be used with the `Atomic<T>` wrapper.  \n\n---\n\n### Pair 2: Memory Orderings  \n\u2705 Factual: The `atomic` crate uses memory orderings based on LLVM atomic orderings, which dictate the synchronization guarantees for atomic operations.  \n\u274c Counterfactual: The `atomic` crate defines its own custom memory ordering model, which is unrelated to LLVM atomic orderings.  \n\n---\n\n### Pair 3: Sharing Atomic Variables  \n\u2705 Factual: Atomic variables in the `atomic` crate implement the `Sync` trait, making them safe to share between threads, but require mechanisms like `Arc` for actual sharing.  \n\u274c Counterfactual: Atomic variables in the `atomic` crate automatically provide thread-safe sharing mechanisms without requiring additional constructs like `Arc`.",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}