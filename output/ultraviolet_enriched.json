{
    "name": "ultraviolet",
    "version": "0.10.0",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/ultraviolet/latest/ultraviolet/all.html \"show sidebar\")\n# Crate ultravioletCopy item path\n[Settings](https://docs.rs/ultraviolet/latest/settings.html)\n[Help](https://docs.rs/ultraviolet/latest/help.html)\nSummary[Source](https://docs.rs/ultraviolet/latest/src/ultraviolet/lib.rs.html#1-139)\nExpand description\n## [\u00a7](https://docs.rs/ultraviolet/latest/ultraviolet/#ultraviolet)`ultraviolet`\nThis is a crate to computer-graphics and games-related linear and geometric algebra, but _fast_ , both in terms of productivity and in terms of runtime performance.\nIn terms of productivity, ultraviolet uses no generics and is designed to be as straightforward of an interface as possible, resulting in fast compilation times and clear code. In addition, the lack of generics and Rust type-system \u201chacks\u201d result in clear and concise errors that are easy to parse and fix for the user.\nIn terms of runtime performance, ultraviolet was designed from the start with performance in mind. To do so, we provide two separate kinds of each type, each with nearly identical functionality, one with usual scalar f32 values, and the other a \u2018wide\u2019 type which uses SIMD f32x4 vectors for each value. This design is clear and explicit in intent, and it also allows code to take full advantage of SIMD.\nThe \u2018wide\u2019 types use an \u201cSoA\u201d (Structure of Arrays) architecture such that each wide data structure actually contains the data for 4 or 8 of its associated data type and will do any operation on all of the simd \u2018lanes\u2019 at the same time. For example, a `Vec3x8` is equivalent to 8 `Vec3`s all bundled together into one data structure.\nDoing this is potentially _much_ (factor of 10) faster than an standard \u201cAoS\u201d (Array of Structs) layout, though it does depend on your workload and algorithm requirements. Algorithms must be carefully architected to take full advantage of this, and doing so can be easier said than done, especially if your algorithm involves significant branching.\n`ultraviolet` was the first Rust math library to be designed in this \u201cAoSoA\u201d manner, though `nalgebra` now supports it for several of their data structures as well.\n### [\u00a7](https://docs.rs/ultraviolet/latest/ultraviolet/#benchmarks)Benchmarks\nSee [`mathbench-rs`](https://github.com/bitshifter/mathbench-rs) for latest benchmarks.\n### [\u00a7](https://docs.rs/ultraviolet/latest/ultraviolet/#cargo-features)Cargo Features\nTo help further improve build times, `ultraviolet` puts various functionality under feature flags. For example, the 2d and 3d projective geometric algebras as well as f64 and integer types are disabled by default. In order to enable them, enable the corresponding crate feature flags in your `Cargo.toml`. For example:\n```\n[dependencies]\nultraviolet = { version = \"0.9\", features = [ \"f64\", \"int\" ] }\n```\n\nWill enable the `f64` and `int` features. Here\u2019s a list of the available features:\n  * `f64` \u2013 Enable `f64` bit wide floating point support. Naming convention is `D[Type]`, such as `DVec3x4` would be a collection of 4 3d vectors with `f64` precision each.\n  * `int` \u2013 Enable integer vector types.\n  * `bytemuck` \u2013 Enable casting of many types to byte arrays, for use with graphics APIs.\n  * `mint` \u2013 Enable interoperation with other math crates through the `mint` interface.\n  * `num-traits` \u2013 Enable [identity traits](https://docs.rs/num-traits/latest/num_traits/identities/index.html) for interoperation with other math crates.\n  * `serde` \u2013 Enable `Serialize` and `Deserialize` implementations for many scalar types.\n\n\n### [\u00a7](https://docs.rs/ultraviolet/latest/ultraviolet/#crate-features)Crate Features\nThis crate is currently being dogfooded in my ray tracer [`rayn`](https://github.com/termhn/rayn), and is being used by various independent Rust game developers for various projects. It does what those users have currently needed it to do.\nThere are a couple relatively unique/novel features in this library, the most important being the use of the Geometric Algebra.\nInstead of implementing complex number algebra (for 2d rotations) and Quaternion algebra (for 3d rotations), we use Rotors, a concept taken from Geometric Algebra, to represent 2d and 3d rotations.\nWhat this means for the programmer is that you will be using the `Rotor3` type in place of a Quaternion, though you can expect it to do basically all the same things that a Quaternion does. In fact, Quaternions are directly isomorphic to Rotors (meaning they are in essense the same thing, just formulated differently). The reason this decision was made was twofold: first, the derivation of the math is actually quite simple to understand. All the derivations for the code implemented in the Rotor structs in this library are written out in the `derivations` folder of the GitHub repo; I derived them manually as part of the implementation.\nOn the other hand, Quaternions are often basically just seen as black boxes that we programmers use to do rotations because they have some nice properties, but that we don\u2019t really understand. You can use Rotors this same way, but you can also easily understand them. Second is that in some sense they can be seen as \u2018more correct\u2019 than Quaternions. Specifically, they facilitate a more proper understanding of rotation as being something that occurs _within a plane_ rather than something that occurs _around an axis_ , as it is generally thought. Finally, Rotors also generalize to 4 and even higher dimensions, and if someone wants to they could implement a Rotor4 which retains all the properties of a Rotor3/Quaternion but does rotation in 4 dimensions instead, something which simply is not possible to do with Quaternions.\nIf it\u2019s missing something you need it to do, bug me on the [GitHub issue tracker](https://github.com/termhn/ultraviolet/issues) and/or Rust community discord server (I\u2019m Fusha there) and I\u2019ll try to add it for you, if I believe it fits with the vision of the lib :)\n## Re-exports[\u00a7](https://docs.rs/ultraviolet/latest/ultraviolet/#reexports)\n\n`pub use bivec[](https://docs.rs/ultraviolet/latest/ultraviolet/bivec/index.html \"mod ultraviolet::bivec\")::*;`\n\n\n`pub use conversion[](https://docs.rs/ultraviolet/latest/ultraviolet/conversion/index.html \"mod ultraviolet::conversion\")::*;`\n\n\n`pub use int[](https://docs.rs/ultraviolet/latest/ultraviolet/int/index.html \"mod ultraviolet::int\")::*;`\n\n\n`pub use interp[](https://docs.rs/ultraviolet/latest/ultraviolet/interp/index.html \"mod ultraviolet::interp\")::*;`\n\n\n`pub use mat[](https://docs.rs/ultraviolet/latest/ultraviolet/mat/index.html \"mod ultraviolet::mat\")::*;`\n\n\n`pub use rotor[](https://docs.rs/ultraviolet/latest/ultraviolet/rotor/index.html \"mod ultraviolet::rotor\")::*;`\n\n\n`pub use transform[](https://docs.rs/ultraviolet/latest/ultraviolet/transform/index.html \"mod ultraviolet::transform\")::*;`\n\n\n`pub use vec[](https://docs.rs/ultraviolet/latest/ultraviolet/vec/index.html \"mod ultraviolet::vec\")::*;`\n\n## Modules[\u00a7](https://docs.rs/ultraviolet/latest/ultraviolet/#modules)\n\n[bivec](https://docs.rs/ultraviolet/latest/ultraviolet/bivec/index.html \"mod ultraviolet::bivec\")\n    Bivectors, i.e. oriented areas.\n\n[conversion](https://docs.rs/ultraviolet/latest/ultraviolet/conversion/index.html \"mod ultraviolet::conversion\")\n    Contains implementations to convert between `UVec`/`IVec` and `Vec`/`DVec`.\n\n[int](https://docs.rs/ultraviolet/latest/ultraviolet/int/index.html \"mod ultraviolet::int\")\n\n\n[interp](https://docs.rs/ultraviolet/latest/ultraviolet/interp/index.html \"mod ultraviolet::interp\")\n    Interpolation on types for which it makes sense.\n\n[mat](https://docs.rs/ultraviolet/latest/ultraviolet/mat/index.html \"mod ultraviolet::mat\")\n    Square matrices.\n\n[projection](https://docs.rs/ultraviolet/latest/ultraviolet/projection/index.html \"mod ultraviolet::projection\")\n    Utility functions to create projection matrices.\n\n[rotor](https://docs.rs/ultraviolet/latest/ultraviolet/rotor/index.html \"mod ultraviolet::rotor\")\n    Rotors, i.e. constructs that describe and perform rotations.\n\n[transform](https://docs.rs/ultraviolet/latest/ultraviolet/transform/index.html \"mod ultraviolet::transform\")\n    Dedicated transformation types as the combination of primitives.\n\n[vec](https://docs.rs/ultraviolet/latest/ultraviolet/vec/index.html \"mod ultraviolet::vec\")\n    Vectors and points, i.e. directed line segments and locations.\n## Macros[\u00a7](https://docs.rs/ultraviolet/latest/ultraviolet/#macros)\n\n[derive_default_identity](https://docs.rs/ultraviolet/latest/ultraviolet/macro.derive_default_identity.html \"macro ultraviolet::derive_default_identity\")\n\n## Structs[\u00a7](https://docs.rs/ultraviolet/latest/ultraviolet/#structs)\n\n[f32x4](https://docs.rs/ultraviolet/latest/ultraviolet/struct.f32x4.html \"struct ultraviolet::f32x4\")\n\n\n[f32x8](https://docs.rs/ultraviolet/latest/ultraviolet/struct.f32x8.html \"struct ultraviolet::f32x8\")\n\n\n[f64x2](https://docs.rs/ultraviolet/latest/ultraviolet/struct.f64x2.html \"struct ultraviolet::f64x2\")\n\n\n[f64x4](https://docs.rs/ultraviolet/latest/ultraviolet/struct.f64x4.html \"struct ultraviolet::f64x4\")\n\n\n[m32x4](https://docs.rs/ultraviolet/latest/ultraviolet/struct.m32x4.html \"struct ultraviolet::m32x4\")\n\n\n[m32x8](https://docs.rs/ultraviolet/latest/ultraviolet/struct.m32x8.html \"struct ultraviolet::m32x8\")\n\n\n[m64x2](https://docs.rs/ultraviolet/latest/ultraviolet/struct.m64x2.html \"struct ultraviolet::m64x2\")\n\n\n[m64x4](https://docs.rs/ultraviolet/latest/ultraviolet/struct.m64x4.html \"struct ultraviolet::m64x4\")\n\n",
        "markdown_with_citations": "[](https://docs.rs/ultraviolet/latest/ultraviolet/all.html \"show sidebar\")\n# Crate ultravioletCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\n## \u00a7\u27e84\u27e9`ultraviolet`\nThis is a crate to computer-graphics and games-related linear and geometric algebra, but _fast_ , both in terms of productivity and in terms of runtime performance.\nIn terms of productivity, ultraviolet uses no generics and is designed to be as straightforward of an interface as possible, resulting in fast compilation times and clear code. In addition, the lack of generics and Rust type-system \u201chacks\u201d result in clear and concise errors that are easy to parse and fix for the user.\nIn terms of runtime performance, ultraviolet was designed from the start with performance in mind. To do so, we provide two separate kinds of each type, each with nearly identical functionality, one with usual scalar f32 values, and the other a \u2018wide\u2019 type which uses SIMD f32x4 vectors for each value. This design is clear and explicit in intent, and it also allows code to take full advantage of SIMD.\nThe \u2018wide\u2019 types use an \u201cSoA\u201d (Structure of Arrays) architecture such that each wide data structure actually contains the data for 4 or 8 of its associated data type and will do any operation on all of the simd \u2018lanes\u2019 at the same time. For example, a `Vec3x8` is equivalent to 8 `Vec3`s all bundled together into one data structure.\nDoing this is potentially _much_ (factor of 10) faster than an standard \u201cAoS\u201d (Array of Structs) layout, though it does depend on your workload and algorithm requirements. Algorithms must be carefully architected to take full advantage of this, and doing so can be easier said than done, especially if your algorithm involves significant branching.\n`ultraviolet` was the first Rust math library to be designed in this \u201cAoSoA\u201d manner, though `nalgebra` now supports it for several of their data structures as well.\n### \u00a7\u27e85\u27e9Benchmarks\nSee `mathbench-rs`\u27e86\u27e9 for latest benchmarks.\n### \u00a7\u27e87\u27e9Cargo Features\nTo help further improve build times, `ultraviolet` puts various functionality under feature flags. For example, the 2d and 3d projective geometric algebras as well as f64 and integer types are disabled by default. In order to enable them, enable the corresponding crate feature flags in your `Cargo.toml`. For example:\n```\n[dependencies]\nultraviolet = { version = \"0.9\", features = [ \"f64\", \"int\" ] }\n```\n\nWill enable the `f64` and `int` features. Here\u2019s a list of the available features:\n  * `f64` \u2013 Enable `f64` bit wide floating point support. Naming convention is `D[Type]`, such as `DVec3x4` would be a collection of 4 3d vectors with `f64` precision each.\n  * `int` \u2013 Enable integer vector types.\n  * `bytemuck` \u2013 Enable casting of many types to byte arrays, for use with graphics APIs.\n  * `mint` \u2013 Enable interoperation with other math crates through the `mint` interface.\n  * `num-traits` \u2013 Enable identity traits\u27e88\u27e9 for interoperation with other math crates.\n  * `serde` \u2013 Enable `Serialize` and `Deserialize` implementations for many scalar types.\n\n\n### \u00a7\u27e89\u27e9Crate Features\nThis crate is currently being dogfooded in my ray tracer `rayn`\u27e810\u27e9, and is being used by various independent Rust game developers for various projects. It does what those users have currently needed it to do.\nThere are a couple relatively unique/novel features in this library, the most important being the use of the Geometric Algebra.\nInstead of implementing complex number algebra (for 2d rotations) and Quaternion algebra (for 3d rotations), we use Rotors, a concept taken from Geometric Algebra, to represent 2d and 3d rotations.\nWhat this means for the programmer is that you will be using the `Rotor3` type in place of a Quaternion, though you can expect it to do basically all the same things that a Quaternion does. In fact, Quaternions are directly isomorphic to Rotors (meaning they are in essense the same thing, just formulated differently). The reason this decision was made was twofold: first, the derivation of the math is actually quite simple to understand. All the derivations for the code implemented in the Rotor structs in this library are written out in the `derivations` folder of the GitHub repo; I derived them manually as part of the implementation.\nOn the other hand, Quaternions are often basically just seen as black boxes that we programmers use to do rotations because they have some nice properties, but that we don\u2019t really understand. You can use Rotors this same way, but you can also easily understand them. Second is that in some sense they can be seen as \u2018more correct\u2019 than Quaternions. Specifically, they facilitate a more proper understanding of rotation as being something that occurs _within a plane_ rather than something that occurs _around an axis_ , as it is generally thought. Finally, Rotors also generalize to 4 and even higher dimensions, and if someone wants to they could implement a Rotor4 which retains all the properties of a Rotor3/Quaternion but does rotation in 4 dimensions instead, something which simply is not possible to do with Quaternions.\nIf it\u2019s missing something you need it to do, bug me on the GitHub issue tracker\u27e811\u27e9 and/or Rust community discord server (I\u2019m Fusha there) and I\u2019ll try to add it for you, if I believe it fits with the vision of the lib :)\n## Re-exports\u00a7\u27e812\u27e9\n\n`pub use bivec[](https://docs.rs/ultraviolet/latest/ultraviolet/bivec/index.html \"mod ultraviolet::bivec\")::*;`\n\n\n`pub use conversion[](https://docs.rs/ultraviolet/latest/ultraviolet/conversion/index.html \"mod ultraviolet::conversion\")::*;`\n\n\n`pub use int[](https://docs.rs/ultraviolet/latest/ultraviolet/int/index.html \"mod ultraviolet::int\")::*;`\n\n\n`pub use interp[](https://docs.rs/ultraviolet/latest/ultraviolet/interp/index.html \"mod ultraviolet::interp\")::*;`\n\n\n`pub use mat[](https://docs.rs/ultraviolet/latest/ultraviolet/mat/index.html \"mod ultraviolet::mat\")::*;`\n\n\n`pub use rotor[](https://docs.rs/ultraviolet/latest/ultraviolet/rotor/index.html \"mod ultraviolet::rotor\")::*;`\n\n\n`pub use transform[](https://docs.rs/ultraviolet/latest/ultraviolet/transform/index.html \"mod ultraviolet::transform\")::*;`\n\n\n`pub use vec[](https://docs.rs/ultraviolet/latest/ultraviolet/vec/index.html \"mod ultraviolet::vec\")::*;`\n\n## Modules\u00a7\u27e813\u27e9\n\nbivec\u27e814\u27e9\n    Bivectors, i.e. oriented areas.\n\nconversion\u27e815\u27e9\n    Contains implementations to convert between `UVec`/`IVec` and `Vec`/`DVec`.\n\nint\u27e816\u27e9\n\n\ninterp\u27e817\u27e9\n    Interpolation on types for which it makes sense.\n\nmat\u27e818\u27e9\n    Square matrices.\n\nprojection\u27e819\u27e9\n    Utility functions to create projection matrices.\n\nrotor\u27e820\u27e9\n    Rotors, i.e. constructs that describe and perform rotations.\n\ntransform\u27e821\u27e9\n    Dedicated transformation types as the combination of primitives.\n\nvec\u27e822\u27e9\n    Vectors and points, i.e. directed line segments and locations.\n## Macros\u00a7\u27e823\u27e9\n\nderive_default_identity\u27e824\u27e9\n\n## Structs\u00a7\u27e825\u27e9\n\nf32x4\u27e826\u27e9\n\n\nf32x8\u27e827\u27e9\n\n\nf64x2\u27e828\u27e9\n\n\nf64x4\u27e829\u27e9\n\n\nm32x4\u27e830\u27e9\n\n\nm32x8\u27e831\u27e9\n\n\nm64x2\u27e832\u27e9\n\n\nm64x4\u27e833\u27e9\n\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/ultraviolet/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/ultraviolet/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/ultraviolet/latest/src/ultraviolet/lib.rs.html#1-139: Source\n\u27e84\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/#ultraviolet: \u00a7\n\u27e85\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/#benchmarks: \u00a7\n\u27e86\u27e9 https://github.com/bitshifter/mathbench-rs: `mathbench-rs`\n\u27e87\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/#cargo-features: \u00a7\n\u27e88\u27e9 https://docs.rs/num-traits/latest/num_traits/identities/index.html: identity traits\n\u27e89\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/#crate-features: \u00a7\n\u27e810\u27e9 https://github.com/termhn/rayn: `rayn`\n\u27e811\u27e9 https://github.com/termhn/ultraviolet/issues: GitHub issue tracker\n\u27e812\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/#reexports: \u00a7\n\u27e813\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/#modules: \u00a7\n\u27e814\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/bivec/index.html: mod ultraviolet::bivec - bivec\n\u27e815\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/conversion/index.html: mod ultraviolet::conversion - conversion\n\u27e816\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/int/index.html: mod ultraviolet::int - int\n\u27e817\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/interp/index.html: mod ultraviolet::interp - interp\n\u27e818\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/mat/index.html: mod ultraviolet::mat - mat\n\u27e819\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/projection/index.html: mod ultraviolet::projection - projection\n\u27e820\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/rotor/index.html: mod ultraviolet::rotor - rotor\n\u27e821\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/transform/index.html: mod ultraviolet::transform - transform\n\u27e822\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/vec/index.html: mod ultraviolet::vec - vec\n\u27e823\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/#macros: \u00a7\n\u27e824\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/macro.derive_default_identity.html: macro ultraviolet::derive_default_identity - derive_default_identity\n\u27e825\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/#structs: \u00a7\n\u27e826\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/struct.f32x4.html: struct ultraviolet::f32x4 - f32x4\n\u27e827\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/struct.f32x8.html: struct ultraviolet::f32x8 - f32x8\n\u27e828\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/struct.f64x2.html: struct ultraviolet::f64x2 - f64x2\n\u27e829\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/struct.f64x4.html: struct ultraviolet::f64x4 - f64x4\n\u27e830\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/struct.m32x4.html: struct ultraviolet::m32x4 - m32x4\n\u27e831\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/struct.m32x8.html: struct ultraviolet::m32x8 - m32x8\n\u27e832\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/struct.m64x2.html: struct ultraviolet::m64x2 - m64x2\n\u27e833\u27e9 https://docs.rs/ultraviolet/latest/ultraviolet/struct.m64x4.html: struct ultraviolet::m64x4 - m64x4\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `ultraviolet` crate is a high-performance linear and geometric algebra library designed for computer graphics and game development. It emphasizes simplicity with a non-generic API for fast compilation and clear error messages, while offering SIMD-optimized \"wide\" types using an AoSoA (Array of Structures of Arrays) architecture for significant runtime performance gains. Key features include support for Rotors (geometric algebra-based rotation), feature flags for optional functionality (e.g., `f64`, integers, `serde`), and interoperability with other math crates via `mint` and `num-traits`.",
    "feature_summary": null,
    "use_case": "Utilities",
    "score": 7.0,
    "factual_counterfactual": "### Pair 1: SIMD and Performance  \n\u2705 **Factual:** The `ultraviolet` crate provides SIMD-optimized \"wide\" types, such as `Vec3x8`, which bundle multiple vectors into a single structure and operate on all SIMD lanes simultaneously, potentially achieving a performance improvement of up to a factor of 10 compared to standard \"Array of Structs\" layouts.  \n\u274c **Counterfactual:** The `ultraviolet` crate exclusively uses SIMD for all types, including scalar types like `Vec3`, ensuring SIMD acceleration even for single-vector operations.  \n\n---\n\n### Pair 2: Rotors vs Quaternions  \n\u2705 **Factual:** The `ultraviolet` crate uses Rotors from Geometric Algebra to represent 2D and 3D rotations, offering an alternative to Quaternions with a focus on rotations occurring within a plane rather than around an axis. Rotors are isomorphic to Quaternions and can perform equivalent rotation operations.  \n\u274c **Counterfactual:** The `ultraviolet` crate completely replaces Quaternions with Rotors and does not allow any interoperation with Quaternion-based rotation systems or libraries.  \n\n---\n\n### Pair 3: Feature Flags and Build Customization  \n\u2705 **Factual:** The `ultraviolet` crate uses feature flags to customize builds, allowing users to enable support for `f64` precision, integer vector types, and interoperability with other libraries via `serde`, `mint`, and `",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}