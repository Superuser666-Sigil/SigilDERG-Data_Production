{
    "name": "thiserror",
    "version": "2.0.12",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/thiserror/latest/thiserror/all.html \"show sidebar\")\n# Crate thiserrorCopy item path\n[Settings](https://docs.rs/thiserror/latest/settings.html)\n[Help](https://docs.rs/thiserror/latest/help.html)\nSummary[Source](https://docs.rs/thiserror/latest/src/thiserror/lib.rs.html#1-303)\nExpand description\n[![github](https://img.shields.io/badge/github-8da0cb?style=for-the-badge&labelColor=555555&logo=github)](https://github.com/dtolnay/thiserror) [![crates-io](https://img.shields.io/badge/crates.io-fc8d62?style=for-the-badge&labelColor=555555&logo=rust)](https://crates.io/crates/thiserror) [![docs-rs](https://img.shields.io/badge/docs.rs-66c2a5?style=for-the-badge&labelColor=555555&logo=docs.rs)](https://docs.rs/thiserror)\nThis library provides a convenient derive macro for the standard library\u2019s [`std::error::Error`](https://doc.rust-lang.org/core/error/trait.Error.html \"trait core::error::Error\") trait.\n## [\u00a7](https://docs.rs/thiserror/latest/thiserror/#example)Example\n```\nuse thiserror::Error;\n#[derive(Error, Debug)]\npub enum DataStoreError {\n  #[error(\"data store disconnected\")]\n  Disconnect(#[from] io::Error),\n  #[error(\"the data for key `{0}` is not available\")]\n  Redaction(String),\n  #[error(\"invalid header (expected {expected:?}, found {found:?})\")]\n  InvalidHeader {\n    expected: String,\n    found: String,\n  },\n  #[error(\"unknown data store error\")]\n  Unknown,\n}\n```\n\n## [\u00a7](https://docs.rs/thiserror/latest/thiserror/#details)Details\n  * Thiserror deliberately does not appear in your public API. You get the same thing as if you had written an implementation of `std::error::Error` by hand, and switching from handwritten impls to thiserror or vice versa is not a breaking change.\n  * Errors may be enums, structs with named fields, tuple structs, or unit structs.\n  * A `Display` impl is generated for your error if you provide `#[error(\"...\")]` messages on the struct or each variant of your enum, as shown above in the example.\nThe messages support a shorthand for interpolating fields from the error.\n    * `#[error(\"{var}\")]` \u27f6 `write!(\"{}\", self.var)`\n    * `#[error(\"{0}\")]` \u27f6 `write!(\"{}\", self.0)`\n    * `#[error(\"{var:?}\")]` \u27f6 `write!(\"{:?}\", self.var)`\n    * `#[error(\"{0:?}\")]` \u27f6 `write!(\"{:?}\", self.0)`\nThese shorthands can be used together with any additional format args, which may be arbitrary expressions. For example:\n```\n#[derive(Error, Debug)]\npub enum Error {\n  #[error(\"invalid rdo_lookahead_frames {0} (expected < {max})\", max = i32::MAX)]\n  InvalidLookahead(u32),\n}\n```\n\nIf one of the additional expression arguments needs to refer to a field of the struct or enum, then refer to named fields as `.var` and tuple fields as `.0`.\n```\n#[derive(Error, Debug)]\npub enum Error {\n  #[error(\"first letter must be lowercase but was {:?}\", first_char(.0))]\n  WrongCase(String),\n  #[error(\"invalid index {idx}, expected at least {} and at most {}\", .limits.lo, .limits.hi)]\n  OutOfBounds { idx: usize, limits: Limits },\n}\n```\n\n  * A `From` impl is generated for each variant that contains a `#[from]` attribute.\nThe variant using `#[from]` must not contain any other fields beyond the source error (and possibly a backtrace \u2014 see below). Usually `#[from]` fields are unnamed, but `#[from]` is allowed on a named field too.\n```\n#[derive(Error, Debug)]\npub enum MyError {\n  Io(#[from] io::Error),\n  Glob(#[from] globset::Error),\n}\n```\n\n  * The Error trait\u2019s `source()` method is implemented to return whichever field has a `#[source]` attribute or is named `source`, if any. This is for identifying the underlying lower level error that caused your error.\nThe `#[from]` attribute always implies that the same field is `#[source]`, so you don\u2019t ever need to specify both attributes.\nAny error type that implements `std::error::Error` or dereferences to `dyn std::error::Error` will work as a source.\n```\n#[derive(Error, Debug)]\npub struct MyError {\n  msg: String,\n  #[source] // optional if field name is `source`\n  source: anyhow::Error,\n}\n```\n\n  * The Error trait\u2019s `provide()` method is implemented to provide whichever field has a type named `Backtrace`, if any, as a `std::backtrace::Backtrace`. Using `Backtrace` in errors requires a nightly compiler with Rust version 1.73 or newer.\n```\nuse std::backtrace::Backtrace;\n#[derive(Error, Debug)]\npub struct MyError {\n  msg: String,\n  backtrace: Backtrace, // automatically detected\n}\n```\n\n  * If a field is both a source (named `source`, or has `#[source]` or `#[from]` attribute) _and_ is marked `#[backtrace]`, then the Error trait\u2019s `provide()` method is forwarded to the source\u2019s `provide` so that both layers of the error share the same backtrace. The `#[backtrace]` attribute requires a nightly compiler with Rust version 1.73 or newer.\n```\n#[derive(Error, Debug)]\npub enum MyError {\n  Io {\n    #[backtrace]\n    source: io::Error,\n  },\n}\n```\n\n  * For variants that use `#[from]` and also contain a `Backtrace` field, a backtrace is captured from within the `From` impl.\n```\n#[derive(Error, Debug)]\npub enum MyError {\n  Io {\n    #[from]\n    source: io::Error,\n    backtrace: Backtrace,\n  },\n}\n```\n\n  * Errors may use `error(transparent)` to forward the source and Display methods straight through to an underlying error without adding an additional message. This would be appropriate for enums that need an \u201canything else\u201d variant.\n```\n#[derive(Error, Debug)]\npub enum MyError {\n  ...\n  #[error(transparent)]\n  Other(#[from] anyhow::Error), // source and Display delegate to anyhow::Error\n}\n```\n\nAnother use case is hiding implementation details of an error representation behind an opaque error type, so that the representation is able to evolve without breaking the crate\u2019s public API.\n```\n// PublicError is public, but opaque and easy to keep compatible.\n#[derive(Error, Debug)]\n#[error(transparent)]\npub struct PublicError(#[from] ErrorRepr);\nimpl PublicError {\n  // Accessors for anything we do want to expose publicly.\n}\n// Private and free to change across minor version of the crate.\n#[derive(Error, Debug)]\nenum ErrorRepr {\n  ...\n}\n```\n\n  * See also the [`anyhow`](https://github.com/dtolnay/anyhow) library for a convenient single error type to use in application code.\n\n\n## Derive Macros[\u00a7](https://docs.rs/thiserror/latest/thiserror/#derives)\n\n[Error](https://docs.rs/thiserror/latest/thiserror/derive.Error.html \"derive thiserror::Error\")\n\n",
        "markdown_with_citations": "[](https://docs.rs/thiserror/latest/thiserror/all.html \"show sidebar\")\n# Crate thiserrorCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\n![github\u27e84\u27e9](https://github.com/dtolnay/thiserror) ![crates-io\u27e85\u27e9](https://crates.io/crates/thiserror) ![docs-rs\u27e86\u27e9](https://docs.rs/thiserror)\nThis library provides a convenient derive macro for the standard library\u2019s `std::error::Error`\u27e87\u27e9 trait.\n## \u00a7\u27e88\u27e9Example\n```\nuse thiserror::Error;\n#[derive(Error, Debug)]\npub enum DataStoreError {\n  #[error(\"data store disconnected\")]\n  Disconnect(#[from] io::Error),\n  #[error(\"the data for key `{0}` is not available\")]\n  Redaction(String),\n  #[error(\"invalid header (expected {expected:?}, found {found:?})\")]\n  InvalidHeader {\n    expected: String,\n    found: String,\n  },\n  #[error(\"unknown data store error\")]\n  Unknown,\n}\n```\n\n## \u00a7\u27e89\u27e9Details\n  * Thiserror deliberately does not appear in your public API. You get the same thing as if you had written an implementation of `std::error::Error` by hand, and switching from handwritten impls to thiserror or vice versa is not a breaking change.\n  * Errors may be enums, structs with named fields, tuple structs, or unit structs.\n  * A `Display` impl is generated for your error if you provide `#[error(\"...\")]` messages on the struct or each variant of your enum, as shown above in the example.\nThe messages support a shorthand for interpolating fields from the error.\n    * `#[error(\"{var}\")]` \u27f6 `write!(\"{}\", self.var)`\n    * `#[error(\"{0}\")]` \u27f6 `write!(\"{}\", self.0)`\n    * `#[error(\"{var:?}\")]` \u27f6 `write!(\"{:?}\", self.var)`\n    * `#[error(\"{0:?}\")]` \u27f6 `write!(\"{:?}\", self.0)`\nThese shorthands can be used together with any additional format args, which may be arbitrary expressions. For example:\n```\n#[derive(Error, Debug)]\npub enum Error {\n  #[error(\"invalid rdo_lookahead_frames {0} (expected < {max})\", max = i32::MAX)]\n  InvalidLookahead(u32),\n}\n```\n\nIf one of the additional expression arguments needs to refer to a field of the struct or enum, then refer to named fields as `.var` and tuple fields as `.0`.\n```\n#[derive(Error, Debug)]\npub enum Error {\n  #[error(\"first letter must be lowercase but was {:?}\", first_char(.0))]\n  WrongCase(String),\n  #[error(\"invalid index {idx}, expected at least {} and at most {}\", .limits.lo, .limits.hi)]\n  OutOfBounds { idx: usize, limits: Limits },\n}\n```\n\n  * A `From` impl is generated for each variant that contains a `#[from]` attribute.\nThe variant using `#[from]` must not contain any other fields beyond the source error (and possibly a backtrace \u2014 see below). Usually `#[from]` fields are unnamed, but `#[from]` is allowed on a named field too.\n```\n#[derive(Error, Debug)]\npub enum MyError {\n  Io(#[from] io::Error),\n  Glob(#[from] globset::Error),\n}\n```\n\n  * The Error trait\u2019s `source()` method is implemented to return whichever field has a `#[source]` attribute or is named `source`, if any. This is for identifying the underlying lower level error that caused your error.\nThe `#[from]` attribute always implies that the same field is `#[source]`, so you don\u2019t ever need to specify both attributes.\nAny error type that implements `std::error::Error` or dereferences to `dyn std::error::Error` will work as a source.\n```\n#[derive(Error, Debug)]\npub struct MyError {\n  msg: String,\n  #[source] // optional if field name is `source`\n  source: anyhow::Error,\n}\n```\n\n  * The Error trait\u2019s `provide()` method is implemented to provide whichever field has a type named `Backtrace`, if any, as a `std::backtrace::Backtrace`. Using `Backtrace` in errors requires a nightly compiler with Rust version 1.73 or newer.\n```\nuse std::backtrace::Backtrace;\n#[derive(Error, Debug)]\npub struct MyError {\n  msg: String,\n  backtrace: Backtrace, // automatically detected\n}\n```\n\n  * If a field is both a source (named `source`, or has `#[source]` or `#[from]` attribute) _and_ is marked `#[backtrace]`, then the Error trait\u2019s `provide()` method is forwarded to the source\u2019s `provide` so that both layers of the error share the same backtrace. The `#[backtrace]` attribute requires a nightly compiler with Rust version 1.73 or newer.\n```\n#[derive(Error, Debug)]\npub enum MyError {\n  Io {\n    #[backtrace]\n    source: io::Error,\n  },\n}\n```\n\n  * For variants that use `#[from]` and also contain a `Backtrace` field, a backtrace is captured from within the `From` impl.\n```\n#[derive(Error, Debug)]\npub enum MyError {\n  Io {\n    #[from]\n    source: io::Error,\n    backtrace: Backtrace,\n  },\n}\n```\n\n  * Errors may use `error(transparent)` to forward the source and Display methods straight through to an underlying error without adding an additional message. This would be appropriate for enums that need an \u201canything else\u201d variant.\n```\n#[derive(Error, Debug)]\npub enum MyError {\n  ...\n  #[error(transparent)]\n  Other(#[from] anyhow::Error), // source and Display delegate to anyhow::Error\n}\n```\n\nAnother use case is hiding implementation details of an error representation behind an opaque error type, so that the representation is able to evolve without breaking the crate\u2019s public API.\n```\n// PublicError is public, but opaque and easy to keep compatible.\n#[derive(Error, Debug)]\n#[error(transparent)]\npub struct PublicError(#[from] ErrorRepr);\nimpl PublicError {\n  // Accessors for anything we do want to expose publicly.\n}\n// Private and free to change across minor version of the crate.\n#[derive(Error, Debug)]\nenum ErrorRepr {\n  ...\n}\n```\n\n  * See also the `anyhow`\u27e810\u27e9 library for a convenient single error type to use in application code.\n\n\n## Derive Macros\u00a7\u27e811\u27e9\n\nError\u27e812\u27e9\n\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/thiserror/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/thiserror/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/thiserror/latest/src/thiserror/lib.rs.html#1-303: Source\n\u27e84\u27e9 https://img.shields.io/badge/github-8da0cb?style=for-the-badge&labelColor=555555&logo=github: ![github\n\u27e85\u27e9 https://img.shields.io/badge/crates.io-fc8d62?style=for-the-badge&labelColor=555555&logo=rust: ![crates-io\n\u27e86\u27e9 https://img.shields.io/badge/docs.rs-66c2a5?style=for-the-badge&labelColor=555555&logo=docs.rs: ![docs-rs\n\u27e87\u27e9 https://doc.rust-lang.org/core/error/trait.Error.html: trait core::error::Error - `std::error::Error`\n\u27e88\u27e9 https://docs.rs/thiserror/latest/thiserror/#example: \u00a7\n\u27e89\u27e9 https://docs.rs/thiserror/latest/thiserror/#details: \u00a7\n\u27e810\u27e9 https://github.com/dtolnay/anyhow: `anyhow`\n\u27e811\u27e9 https://docs.rs/thiserror/latest/thiserror/#derives: \u00a7\n\u27e812\u27e9 https://docs.rs/thiserror/latest/thiserror/derive.Error.html: derive thiserror::Error - Error\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `thiserror` crate provides a derive macro for implementing the `std::error::Error` trait, simplifying error handling in Rust. It supports enums, structs, and tuple structs, automatically generating `Display` implementations via `#[error]` annotations with field interpolation. Additional features include automatic `From` and `source` implementations, optional backtrace support, and transparent error forwarding for flexible error composition.",
    "feature_summary": null,
    "use_case": "Utilities",
    "score": 9.0,
    "factual_counterfactual": "### Pair 1: Derive Macros for `std::error::Error`\n\u2705 **Factual**: The `thiserror` crate provides a derive macro that simplifies the implementation of the `std::error::Error` trait, allowing developers to define custom error types with minimal boilerplate.  \n\u274c **Counterfactual**: The `thiserror` crate automatically generates implementations for the `std::fmt::Debug` trait, even if the user does not derive it explicitly.\n\n---\n\n### Pair 2: `#[from]` Attribute for Automatic Conversion\n\u2705 **Factual**: The `#[from]` attribute in `thiserror` automatically generates `From` trait implementations for error variants, enabling seamless conversion from source errors to custom error types.  \n\u274c **Counterfactual**: The `#[from]` attribute allows multiple fields in a single error variant to be automatically converted from different source errors.\n\n---\n\n### Pair 3: Backtrace Support\n\u2705 **Factual**: The `thiserror` crate supports capturing and providing backtraces for errors when using the `Backtrace` type, but this feature requires a nightly compiler with Rust version 1.73 or newer.  \n\u274c **Counterfactual**: The `thiserror` crate automatically captures backtraces for all error types, regardless of whether the `Backtrace` type is explicitly included in the error definition.",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}