{
    "name": "crossbeam-epoch",
    "version": "0.9.18",
    "description": "ALLOW: Positive community sentiment",
    "repository": "",
    "keywords": [],
    "categories": [],
    "readme": {
        "raw_markdown": "[](https://docs.rs/crossbeam-epoch/latest/crossbeam_epoch/all.html \"show sidebar\")\n# Crate crossbeam_epochCopy item path\n[Settings](https://docs.rs/crossbeam-epoch/latest/settings.html)\n[Help](https://docs.rs/crossbeam-epoch/latest/help.html)\nSummary[Source](https://docs.rs/crossbeam-epoch/latest/src/crossbeam_epoch/lib.rs.html#1-166)\nExpand description\nEpoch-based memory reclamation.\nAn interesting problem concurrent collections deal with comes from the remove operation. Suppose that a thread removes an element from a lock-free map, while another thread is reading that same element at the same time. The first thread must wait until the second thread stops reading the element. Only then it is safe to destruct it.\nProgramming languages that come with garbage collectors solve this problem trivially. The garbage collector will destruct the removed element when no thread can hold a reference to it anymore.\nThis crate implements a basic memory reclamation mechanism, which is based on epochs. When an element gets removed from a concurrent collection, it is inserted into a pile of garbage and marked with the current epoch. Every time a thread accesses a collection, it checks the current epoch, attempts to increment it, and destructs some garbage that became so old that no thread can be referencing it anymore.\nThat is the general mechanism behind epoch-based memory reclamation, but the details are a bit more complicated. Anyhow, memory reclamation is designed to be fully automatic and something users of concurrent collections don\u2019t have to worry much about.\n## [\u00a7](https://docs.rs/crossbeam-epoch/latest/crossbeam_epoch/#pointers)Pointers\nConcurrent collections are built using atomic pointers. This module provides [`Atomic`](https://docs.rs/crossbeam-epoch/latest/crossbeam_epoch/struct.Atomic.html \"struct crossbeam_epoch::Atomic\"), which is just a shared atomic pointer to a heap-allocated object. Loading an [`Atomic`](https://docs.rs/crossbeam-epoch/latest/crossbeam_epoch/struct.Atomic.html \"struct crossbeam_epoch::Atomic\") yields a [`Shared`](https://docs.rs/crossbeam-epoch/latest/crossbeam_epoch/struct.Shared.html \"struct crossbeam_epoch::Shared\"), which is an epoch-protected pointer through which the loaded object can be safely read.\n## [\u00a7](https://docs.rs/crossbeam-epoch/latest/crossbeam_epoch/#pinning)Pinning\nBefore an [`Atomic`](https://docs.rs/crossbeam-epoch/latest/crossbeam_epoch/struct.Atomic.html \"struct crossbeam_epoch::Atomic\") can be loaded, a participant must be [`pin`](https://docs.rs/crossbeam-epoch/latest/crossbeam_epoch/fn.pin.html \"fn crossbeam_epoch::pin\")ned. By pinning a participant we declare that any object that gets removed from now on must not be destructed just yet. Garbage collection of newly removed objects is suspended until the participant gets unpinned.\n## [\u00a7](https://docs.rs/crossbeam-epoch/latest/crossbeam_epoch/#garbage)Garbage\nObjects that get removed from concurrent collections must be stashed away until all currently pinned participants get unpinned. Such objects can be stored into a thread-local or global storage, where they are kept until the right time for their destruction comes.\nThere is a global shared instance of garbage queue. You can [`defer`](https://docs.rs/crossbeam-epoch/latest/crossbeam_epoch/struct.Guard.html#method.defer \"method crossbeam_epoch::Guard::defer\") the execution of an arbitrary function until the global epoch is advanced enough. Most notably, concurrent data structures may defer the deallocation of an object.\n## [\u00a7](https://docs.rs/crossbeam-epoch/latest/crossbeam_epoch/#apis)APIs\nFor majority of use cases, just use the default garbage collector by invoking [`pin`](https://docs.rs/crossbeam-epoch/latest/crossbeam_epoch/fn.pin.html \"fn crossbeam_epoch::pin\"). If you want to create your own garbage collector, use the [`Collector`](https://docs.rs/crossbeam-epoch/latest/crossbeam_epoch/struct.Collector.html \"struct crossbeam_epoch::Collector\") API.\n## Structs[\u00a7](https://docs.rs/crossbeam-epoch/latest/crossbeam_epoch/#structs)\n\n[Atomic](https://docs.rs/crossbeam-epoch/latest/crossbeam_epoch/struct.Atomic.html \"struct crossbeam_epoch::Atomic\")\n    An atomic pointer that can be safely shared between threads.\n\n[Collector](https://docs.rs/crossbeam-epoch/latest/crossbeam_epoch/struct.Collector.html \"struct crossbeam_epoch::Collector\")\n    An epoch-based garbage collector.\n\n[CompareExchangeError](https://docs.rs/crossbeam-epoch/latest/crossbeam_epoch/struct.CompareExchangeError.html \"struct crossbeam_epoch::CompareExchangeError\")\n    The error returned on failed compare-and-swap operation.\n\n[Guard](https://docs.rs/crossbeam-epoch/latest/crossbeam_epoch/struct.Guard.html \"struct crossbeam_epoch::Guard\")\n    A guard that keeps the current thread pinned.\n\n[LocalHandle](https://docs.rs/crossbeam-epoch/latest/crossbeam_epoch/struct.LocalHandle.html \"struct crossbeam_epoch::LocalHandle\")\n    A handle to a garbage collector.\n\n[Owned](https://docs.rs/crossbeam-epoch/latest/crossbeam_epoch/struct.Owned.html \"struct crossbeam_epoch::Owned\")\n    An owned heap-allocated object.\n\n[Shared](https://docs.rs/crossbeam-epoch/latest/crossbeam_epoch/struct.Shared.html \"struct crossbeam_epoch::Shared\")\n    A pointer to an object protected by the epoch GC.\n## Traits[\u00a7](https://docs.rs/crossbeam-epoch/latest/crossbeam_epoch/#traits)\n\n[CompareAndSetOrdering](https://docs.rs/crossbeam-epoch/latest/crossbeam_epoch/trait.CompareAndSetOrdering.html \"trait crossbeam_epoch::CompareAndSetOrdering\")Deprecated\n    Memory orderings for compare-and-set operations.\n\n[Pointable](https://docs.rs/crossbeam-epoch/latest/crossbeam_epoch/trait.Pointable.html \"trait crossbeam_epoch::Pointable\")\n    Types that are pointed to by a single word.\n\n[Pointer](https://docs.rs/crossbeam-epoch/latest/crossbeam_epoch/trait.Pointer.html \"trait crossbeam_epoch::Pointer\")\n    A trait for either `Owned` or `Shared` pointers.\n## Functions[\u00a7](https://docs.rs/crossbeam-epoch/latest/crossbeam_epoch/#functions)\n\n[default_collector](https://docs.rs/crossbeam-epoch/latest/crossbeam_epoch/fn.default_collector.html \"fn crossbeam_epoch::default_collector\")\n    Returns the default global collector.\n\n[is_pinned](https://docs.rs/crossbeam-epoch/latest/crossbeam_epoch/fn.is_pinned.html \"fn crossbeam_epoch::is_pinned\")\n    Returns `true` if the current thread is pinned.\n\n[pin](https://docs.rs/crossbeam-epoch/latest/crossbeam_epoch/fn.pin.html \"fn crossbeam_epoch::pin\")\n    Pins the current thread.\n\n[unprotected](https://docs.rs/crossbeam-epoch/latest/crossbeam_epoch/fn.unprotected.html \"fn crossbeam_epoch::unprotected\")\u26a0\n    Returns a reference to a dummy guard that allows unprotected access to [`Atomic`](https://docs.rs/crossbeam-epoch/latest/crossbeam_epoch/struct.Atomic.html \"struct crossbeam_epoch::Atomic\")s.\n## Type Aliases[\u00a7](https://docs.rs/crossbeam-epoch/latest/crossbeam_epoch/#types)\n\n[CompareAndSetError](https://docs.rs/crossbeam-epoch/latest/crossbeam_epoch/type.CompareAndSetError.html \"type crossbeam_epoch::CompareAndSetError\")Deprecated\n    The error returned on failed compare-and-set operation.\n",
        "markdown_with_citations": "[](https://docs.rs/crossbeam-epoch/latest/crossbeam_epoch/all.html \"show sidebar\")\n# Crate crossbeam_epochCopy item path\nSettings\u27e81\u27e9\nHelp\u27e82\u27e9\nSummarySource\u27e83\u27e9\nExpand description\nEpoch-based memory reclamation.\nAn interesting problem concurrent collections deal with comes from the remove operation. Suppose that a thread removes an element from a lock-free map, while another thread is reading that same element at the same time. The first thread must wait until the second thread stops reading the element. Only then it is safe to destruct it.\nProgramming languages that come with garbage collectors solve this problem trivially. The garbage collector will destruct the removed element when no thread can hold a reference to it anymore.\nThis crate implements a basic memory reclamation mechanism, which is based on epochs. When an element gets removed from a concurrent collection, it is inserted into a pile of garbage and marked with the current epoch. Every time a thread accesses a collection, it checks the current epoch, attempts to increment it, and destructs some garbage that became so old that no thread can be referencing it anymore.\nThat is the general mechanism behind epoch-based memory reclamation, but the details are a bit more complicated. Anyhow, memory reclamation is designed to be fully automatic and something users of concurrent collections don\u2019t have to worry much about.\n## \u00a7\u27e84\u27e9Pointers\nConcurrent collections are built using atomic pointers. This module provides `Atomic`\u27e85\u27e9, which is just a shared atomic pointer to a heap-allocated object. Loading an `Atomic`\u27e85\u27e9 yields a `Shared`\u27e86\u27e9, which is an epoch-protected pointer through which the loaded object can be safely read.\n## \u00a7\u27e87\u27e9Pinning\nBefore an `Atomic`\u27e85\u27e9 can be loaded, a participant must be `pin`\u27e88\u27e9ned. By pinning a participant we declare that any object that gets removed from now on must not be destructed just yet. Garbage collection of newly removed objects is suspended until the participant gets unpinned.\n## \u00a7\u27e89\u27e9Garbage\nObjects that get removed from concurrent collections must be stashed away until all currently pinned participants get unpinned. Such objects can be stored into a thread-local or global storage, where they are kept until the right time for their destruction comes.\nThere is a global shared instance of garbage queue. You can `defer`\u27e810\u27e9 the execution of an arbitrary function until the global epoch is advanced enough. Most notably, concurrent data structures may defer the deallocation of an object.\n## \u00a7\u27e811\u27e9APIs\nFor majority of use cases, just use the default garbage collector by invoking `pin`\u27e88\u27e9. If you want to create your own garbage collector, use the `Collector`\u27e812\u27e9 API.\n## Structs\u00a7\u27e813\u27e9\n\nAtomic\u27e85\u27e9\n    An atomic pointer that can be safely shared between threads.\n\nCollector\u27e812\u27e9\n    An epoch-based garbage collector.\n\nCompareExchangeError\u27e814\u27e9\n    The error returned on failed compare-and-swap operation.\n\nGuard\u27e815\u27e9\n    A guard that keeps the current thread pinned.\n\nLocalHandle\u27e816\u27e9\n    A handle to a garbage collector.\n\nOwned\u27e817\u27e9\n    An owned heap-allocated object.\n\nShared\u27e86\u27e9\n    A pointer to an object protected by the epoch GC.\n## Traits\u00a7\u27e818\u27e9\n\nCompareAndSetOrdering\u27e819\u27e9Deprecated\n    Memory orderings for compare-and-set operations.\n\nPointable\u27e820\u27e9\n    Types that are pointed to by a single word.\n\nPointer\u27e821\u27e9\n    A trait for either `Owned` or `Shared` pointers.\n## Functions\u00a7\u27e822\u27e9\n\ndefault_collector\u27e823\u27e9\n    Returns the default global collector.\n\nis_pinned\u27e824\u27e9\n    Returns `true` if the current thread is pinned.\n\npin\u27e88\u27e9\n    Pins the current thread.\n\nunprotected\u27e825\u27e9\u26a0\n    Returns a reference to a dummy guard that allows unprotected access to `Atomic`\u27e85\u27e9s.\n## Type Aliases\u00a7\u27e826\u27e9\n\nCompareAndSetError\u27e827\u27e9Deprecated\n    The error returned on failed compare-and-set operation.\n",
        "references_markdown": "\n\n## References\n\n\u27e81\u27e9 https://docs.rs/crossbeam-epoch/latest/settings.html: Settings\n\u27e82\u27e9 https://docs.rs/crossbeam-epoch/latest/help.html: Help\n\u27e83\u27e9 https://docs.rs/crossbeam-epoch/latest/src/crossbeam_epoch/lib.rs.html#1-166: Source\n\u27e84\u27e9 https://docs.rs/crossbeam-epoch/latest/crossbeam_epoch/#pointers: \u00a7\n\u27e85\u27e9 https://docs.rs/crossbeam-epoch/latest/crossbeam_epoch/struct.Atomic.html: struct crossbeam_epoch::Atomic - `Atomic`\n\u27e86\u27e9 https://docs.rs/crossbeam-epoch/latest/crossbeam_epoch/struct.Shared.html: struct crossbeam_epoch::Shared - `Shared`\n\u27e87\u27e9 https://docs.rs/crossbeam-epoch/latest/crossbeam_epoch/#pinning: \u00a7\n\u27e88\u27e9 https://docs.rs/crossbeam-epoch/latest/crossbeam_epoch/fn.pin.html: fn crossbeam_epoch::pin - `pin`\n\u27e89\u27e9 https://docs.rs/crossbeam-epoch/latest/crossbeam_epoch/#garbage: \u00a7\n\u27e810\u27e9 https://docs.rs/crossbeam-epoch/latest/crossbeam_epoch/struct.Guard.html#method.defer: method crossbeam_epoch::Guard::defer - `defer`\n\u27e811\u27e9 https://docs.rs/crossbeam-epoch/latest/crossbeam_epoch/#apis: \u00a7\n\u27e812\u27e9 https://docs.rs/crossbeam-epoch/latest/crossbeam_epoch/struct.Collector.html: struct crossbeam_epoch::Collector - `Collector`\n\u27e813\u27e9 https://docs.rs/crossbeam-epoch/latest/crossbeam_epoch/#structs: \u00a7\n\u27e814\u27e9 https://docs.rs/crossbeam-epoch/latest/crossbeam_epoch/struct.CompareExchangeError.html: struct crossbeam_epoch::CompareExchangeError - CompareExchangeError\n\u27e815\u27e9 https://docs.rs/crossbeam-epoch/latest/crossbeam_epoch/struct.Guard.html: struct crossbeam_epoch::Guard - Guard\n\u27e816\u27e9 https://docs.rs/crossbeam-epoch/latest/crossbeam_epoch/struct.LocalHandle.html: struct crossbeam_epoch::LocalHandle - LocalHandle\n\u27e817\u27e9 https://docs.rs/crossbeam-epoch/latest/crossbeam_epoch/struct.Owned.html: struct crossbeam_epoch::Owned - Owned\n\u27e818\u27e9 https://docs.rs/crossbeam-epoch/latest/crossbeam_epoch/#traits: \u00a7\n\u27e819\u27e9 https://docs.rs/crossbeam-epoch/latest/crossbeam_epoch/trait.CompareAndSetOrdering.html: trait crossbeam_epoch::CompareAndSetOrdering - CompareAndSetOrdering\n\u27e820\u27e9 https://docs.rs/crossbeam-epoch/latest/crossbeam_epoch/trait.Pointable.html: trait crossbeam_epoch::Pointable - Pointable\n\u27e821\u27e9 https://docs.rs/crossbeam-epoch/latest/crossbeam_epoch/trait.Pointer.html: trait crossbeam_epoch::Pointer - Pointer\n\u27e822\u27e9 https://docs.rs/crossbeam-epoch/latest/crossbeam_epoch/#functions: \u00a7\n\u27e823\u27e9 https://docs.rs/crossbeam-epoch/latest/crossbeam_epoch/fn.default_collector.html: fn crossbeam_epoch::default_collector - default_collector\n\u27e824\u27e9 https://docs.rs/crossbeam-epoch/latest/crossbeam_epoch/fn.is_pinned.html: fn crossbeam_epoch::is_pinned - is_pinned\n\u27e825\u27e9 https://docs.rs/crossbeam-epoch/latest/crossbeam_epoch/fn.unprotected.html: fn crossbeam_epoch::unprotected - unprotected\n\u27e826\u27e9 https://docs.rs/crossbeam-epoch/latest/crossbeam_epoch/#types: \u00a7\n\u27e827\u27e9 https://docs.rs/crossbeam-epoch/latest/crossbeam_epoch/type.CompareAndSetError.html: type crossbeam_epoch::CompareAndSetError - CompareAndSetError\n",
        "fit_markdown": "",
        "fit_html": ""
    },
    "downloads": 0,
    "github_stars": 0,
    "dependencies": [],
    "features": {},
    "code_snippets": [],
    "readme_sections": {},
    "librs_downloads": null,
    "source": "crates.io",
    "enhanced_scraping": {},
    "enhanced_features": [],
    "enhanced_dependencies": [],
    "readme_summary": "The `crossbeam-epoch` crate provides epoch-based memory reclamation for concurrent data structures, ensuring safe deallocation of removed elements while other threads may still be accessing them. It features atomic pointers (`Atomic`), pinning mechanisms to manage garbage collection, and APIs for automatic or custom garbage collectors (`Collector`). This enables efficient and thread-safe memory management in lock-free collections.",
    "feature_summary": null,
    "use_case": "Utilities",
    "score": 8.0,
    "factual_counterfactual": "### Pair 1: Memory Reclamation Mechanism  \n\u2705 **Factual:** The `crossbeam-epoch` crate implements epoch-based memory reclamation, allowing safe deallocation of objects removed from concurrent collections only after all threads have finished accessing them.  \n\u274c **Counterfactual:** The `crossbeam-epoch` crate uses reference counting for memory reclamation, requiring manual cleanup of objects by the user.  \n\n---\n\n### Pair 2: Pinning for Thread Safety  \n\u2705 **Factual:** Before accessing an `Atomic` pointer, a thread must be \"pinned\" using the `pin` function to ensure that objects removed during the pinning period are not destructed prematurely.  \n\u274c **Counterfactual:** Threads accessing `Atomic` pointers do not need to be pinned, as the crate automatically tracks thread states without user intervention.  \n\n---\n\n### Pair 3: Garbage Collection Customization  \n\u2705 **Factual:** The `crossbeam-epoch` crate allows users to create custom garbage collectors using the `Collector` API, providing flexibility for specific use cases.  \n\u274c **Counterfactual:** The `crossbeam-epoch` crate only supports a single global garbage collector and does not allow users to define custom collectors.",
    "source_analysis": null,
    "user_behavior": null,
    "security": null
}